var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j, _k, _l;
import { k as getAugmentedNamespace, m as commonjsGlobal, q as __vitePreload, R as React, o as jsxRuntimeExports } from "./index-3bddf13b.js";
import { R as RawContextKey, I as IContextKeyService, a as registerEditorContribution, b as registerEditorAction, S as Selection, M as MarkdownString, c as localize, d as alert, E as EditorAction, e as EditorContextKeys, K as KeyChord, f as registerColor, g as ModelDecorationOptions, t as themeColorFromId, O as OverviewRulerLane, h as MenuRegistry, i as MenuId, D as Disposable, j as RunOnceScheduler, k as Range$1, P as Position$1, n as MoveOperations, o as ReplaceCommand, p as isNative, q as isFirefox, s as MultiCommand, C as ContextKeyExpr, u as ICodeEditorService, v as IClipboardService, w as isWeb, x as InMemoryClipboardMetadataManager, y as CopyOptions, z as EditorCommand, A as codeActionCommandId, B as CodeActionCommandArgs, F as CodeActionKind$1, G as CodeActionController, H as CodeActionTriggerSource, J as quickFixCommandId, L as refactorCommandId, N as sourceActionCommandId, Q as organizeImportsCommandId, T as fixAllCommandId, U as autoFixCommandId, V as SUPPORTED_CODE_ACTIONS, W as escapeRegExpCharacters, X as LightBulbWidget, Y as registerEditorCommand, Z as Registry, _ as Extensions, $ as editorConfigurationBaseNode, a0 as CommandsRegistry, a1 as assertType, a2 as URI$1, a3 as ILanguageFeaturesService, a4 as IModelService, a5 as illegalArgument, a6 as DisposableStore, a7 as CancellationToken, a8 as onUnexpectedExternalError, a9 as createDecorator, aa as IStorageService, ab as LRUCache, ac as runWhenIdle, ad as once, ae as WillSaveStateReason, af as registerSingleton, ag as renderLabelWithIcons, ah as $$8, ai as reset, aj as ILanguageFeatureDebounceService, ak as ICommandService, al as INotificationService, am as EDITOR_FONT_DEFAULTS, an as disposableTimeout, ao as createCancelablePromise, ap as onUnexpectedError, aq as toDisposable, ar as StableEditorScrollState, as as IQuickInputService, at as ILanguageConfigurationService, au as EditorWorkerClient, av as Color$1, aw as RGBA, ax as registerEditorFeature, ay as IConfigurationService, az as DynamicCssRules, aA as TimeoutTimer, aB as StopWatch, aC as noBreakWhitespace, aD as Emitter, aE as Widget, aF as PixelRatio, aG as append, aH as editorHoverBackground, aI as addDisposableListener, aJ as EventType, aK as ThemeIcon, aL as registerIcon, aM as Codicon, aN as HSVA, aO as GlobalPointerMoveMonitor, aP as getDomNodePagePosition, aQ as IThemeService, aR as AsyncIterableObject, aS as Dimension, aT as isMacintosh, aU as defaultGenerator, aV as basename, aW as ResourceMap, aX as dispose, aY as extUri, aZ as commonPrefixLength, a_ as ITextModelService, a$ as IKeybindingService, b0 as ILabelService, b1 as IInstantiationService, b2 as IconLabel, b3 as CountBadge, b4 as defaultCountBadgeStyles, b5 as dirname, b6 as createMatches, b7 as HighlightedLabel, b8 as FuzzyScore, b9 as IPeekViewService, ba as IUndoRedoService, bb as ILanguageService, bc as PeekViewWidget, bd as peekViewBorder, be as peekViewTitleBackground, bf as peekViewTitleForeground, bg as peekViewTitleInfoForeground, bh as hide, bi as SplitView, bj as EmbeddedCodeEditorWidget, bk as TextModel, bl as PLAINTEXT_LANGUAGE_ID, bm as peekViewResultsBackground, bn as addStandardDisposableListener, bo as Event, bp as Sizing, bq as show, br as Schemas, bs as basenameOrAuthority, bt as WorkbenchAsyncDataTree, bu as KeybindingsRegistry, bv as PeekContext, bw as WorkbenchListFocusContextKey, bx as WorkbenchTreeElementCanCollapse, by as WorkbenchTreeElementCanExpand, bz as IListService, bA as getOuterEditor, bB as isEqual, bC as combinedDisposable, bD as registerModelAndPositionCommand, bE as coalesce, bF as registerAction2, bG as isCodeEditor, bH as IsWebContext, bI as EditorAction2, bJ as Iterable, bK as IEditorProgressService, bL as EditorStateCancellationTokenSource, bM as raceCancellation, bN as MessageController, bO as isLocationLink, bP as withNullAsUndefined, bQ as EditorState$1, bR as ModelDecorationInjectedTextOptions, bS as DomScrollableElement, bT as StandardKeyboardEvent, bU as createCancelableAsyncIterable, bV as ResizableHTMLElement, bW as getClientArea, bX as TokenizationRegistry, bY as trackFocus, bZ as getTotalHeight, b_ as getTotalWidth, b$ as MarkdownRenderer, c0 as isEmptyMarkdownString, c1 as asArray, c2 as IOpenerService, c3 as IMarkerService, c4 as binarySearch, c5 as LinkedList, c6 as MarkerSeverity, c7 as compare, c8 as Severity, c9 as IMenuService, ca as contrastBorder, cb as transparent, cc as editorBackground, cd as createAndFillInActionBarActions, ce as oneOf, cf as editorErrorBorder, cg as editorErrorForeground, ch as editorWarningBorder, ci as editorWarningForeground, cj as editorInfoBorder, ck as editorInfoForeground, cl as ScrollableElement, cm as splitLines, cn as clearNode, co as isNonEmptyArray, cp as IMarkerDecorationsService, cq as IMarkerData, cr as getCodeActions, cs as Progress, ct as IContextMenuService, cu as ITelemetryService, cv as observableFromEvent, cw as derived, cx as autorunWithStore2, cy as Action, cz as h, cA as ActionBar, cB as MenuItemAction, cC as autorun, cD as equals$1, cE as Separator, cF as MenuEntryActionViewItem, cG as KeybindingLabel, cH as OS, cI as unthemedKeybindingLabelOptions, cJ as WorkbenchToolBar, cK as InlineCompletionTriggerKind, cL as registerThemingParticipant, cM as editorHoverBorder, cN as IAccessibilityService, cO as status, cP as EditOperation, cQ as firstNonWhitespaceIndex, cR as createStringDataTransferItem, cS as createFileDataTransferItem, cT as DataTransfers, cU as Mimes, cV as UriList, cW as VSDataTransfer, cX as CodeDataTransfers, cY as ResourceTextEdit, cZ as MutableDisposable, c_ as IBulkEditService, c$ as Button, d0 as toAction, d1 as IProgressService, d2 as isWindows, d3 as generateUuid, d4 as matchesMimeType, d5 as ClipboardEventUtils, d6 as withUndefinedAsNull, d7 as IWorkspaceContextService, d8 as relativePath, d9 as ITreeViewsDnDService, da as LocalSelectionTransfer, db as DraggedTreeItemsIdentifier, dc as MinimapPosition, dd as overviewRulerFindMatchForeground, de as minimapFindMatch, df as buildReplaceStringWithCasePreserved, dg as findFirstInSorted, dh as SearchParams, di as ReplaceCommandThatPreservesSelection, dj as asCssVariable, dk as CaseSensitiveToggle, dl as WholeWordsToggle, dm as RegexToggle, dn as inputActiveOptionBorder, dp as inputActiveOptionForeground, dq as inputActiveOptionBackground, dr as Delayer, ds as format, dt as getTopLeftOffset, du as isInDOM, dv as ContextScopedFindInput, dw as showHistoryKeybindingHint, dx as defaultInputBoxStyles, dy as defaultToggleStyles, dz as isLinux, dA as assertIsDefined, dB as Toggle, dC as widgetClose, dD as ContextScopedReplaceInput, dE as Sash, dF as getComputedStyle, dG as editorFindMatchHighlight, dH as editorFindMatch, dI as editorFindRangeHighlight, dJ as editorWidgetBackground, dK as widgetShadow, dL as widgetBorder, dM as editorFindMatchHighlightBorder, dN as isHighContrast, dO as editorFindMatchBorder, dP as editorFindRangeHighlightBorder, dQ as editorWidgetForeground, dR as errorForeground, dS as editorWidgetResizeBorder, dT as editorWidgetBorder, dU as toolbarHoverBackground, dV as focusBorder, dW as IContextViewService, dX as registerMultiEditorAction, dY as MultiEditorAction, dZ as Severity$1, d_ as overviewRulerRangeHighlight, d$ as hash, e0 as countEOL, e1 as computeIndentLevel, e2 as editorSelectionBackground, e3 as iconForeground, e4 as registerInstantiatedEditorAction, e5 as FoldingRangeKind$1, e6 as isUndefined, e7 as isObject, e8 as isNumber, e9 as isString, ea as EditorZoom, eb as IEditorWorkerService, ec as CharacterSet, ed as CancellationTokenSource, ee as getOnTypeFormattingEdits, ef as FormattingEdit, eg as alertFormattingEdits, eh as formatDocumentRangesWithSelectedProvider, ei as formatDocumentWithSelectedProvider, ej as IOutlineModelService, ek as BugIndicatingError, el as createTrustedTypesPolicy, em as observableValue, en as observableSignalFromEvent, eo as containsRTL, ep as LineTokens, eq as renderViewLine, er as RenderLineInput, es as EditorFontLigatures, et as applyFontInfo, eu as InjectedTextCursorStops, ev as StringBuilder, ew as isBasicASCII, ex as LineDecoration, ey as getLeadingWhitespace, ez as LcsDiff, eA as TextBufferTokenizer, eB as parseDocument, eC as LanguageAgnosticBracketTokens, eD as lengthAdd, eE as lengthGetColumnCountIfZeroLineCount, eF as lengthZero, eG as DenseKeyProvider, eH as SnippetParser, eI as Text, eJ as assertNever, eK as SetMap, eL as DeferredPromise, eM as disposableObservableValue, eN as transaction, eO as matchesSubString, eP as observableSignal, eQ as derivedHandleChanges, eR as keepAlive, eS as subtransaction, eT as SnippetController2, eU as isDefined, eV as mapFind, eW as SuggestController, eX as findMaxBy, eY as SnippetSession, eZ as SelectedSuggestionInfo, e_ as compareBy, e$ as numberComparator, f0 as IAudioCueService, f1 as constObservable, f2 as InlineCompletionContextKeys, f3 as CoreEditingCommands, f4 as AudioCue, f5 as Context$1, f6 as Action2, f7 as getGoodIndentForLine, f8 as getIndentMetadata, f9 as ShiftCommand, fa as normalizeIndentation, fb as CancellationError, fc as isIMenuItem, fd as ModifierKeyEmitter, fe as Command$1, ff as editorActiveLinkForeground, fg as InlayHintKind$1, fh as editorInlayHintParameterBackground, fi as editorInlayHintParameterForeground, fj as editorInlayHintTypeBackground, fk as editorInlayHintTypeForeground, fl as editorInlayHintBackground, fm as editorInlayHintForeground, fn as timeout, fo as CursorMoveCommands, fp as lastNonWhitespaceIndex, fq as IndentAction, fr as getEnterAction, fs as ReplaceCommandThatSelectsText, ft as TypeOperations, fu as commonSuffixLength, fv as isCancellationError, fw as first, fx as isDisposable, fy as originalFSPath, fz as joinPath, fA as activeContrastBorder, fB as overviewRulerSelectionHighlightForeground, fC as minimapSelectionOccurrenceHighlight, fD as editorSelectionHighlight, fE as DocumentHighlightKind$1, fF as SignatureHelpTriggerKind, fG as listHighlightForeground, fH as EventHelper, fI as Lazy, fJ as inputForeground, fK as inputBackground, fL as inputBorder, fM as ILogService, fN as ITextResourceConfigurationService, fO as encodeSemanticTokensDto, fP as ISemanticTokensStylingService, fQ as toMultilineTokens2, fR as isLowerAsciiLetter, fS as isUpperAsciiLetter, fT as BracketSelectionRangeProvider, fU as StandardMouseEvent, fV as OutlineModel, fW as OutlineGroup, fX as OutlineElement, fY as Categories, fZ as ISuggestMemoryService, f_ as RefCountedDisposable, f$ as QuickSuggestionsOptions, g0 as LineContext, g1 as provideSuggestionItems, g2 as CompletionOptions, g3 as CompletionModel, g4 as WordDistance, g5 as TabFocus, g6 as Link$1, g7 as IWorkspaceTrustManagementService, g8 as language, g9 as inUntrustedWorkspace, ga as isModelDecorationVisible, gb as isModelDecorationInComment, gc as isModelDecorationInString, gd as UnicodeTextModelHighlighter, ge as InvisibleCharacters, gf as unicodeHighlightConfigKeys, gg as IDialogService, gh as CONTEXT_ACCESSIBILITY_MODE_ENABLED, gi as IsWindowsContext, gj as getMapForWordSeparators, gk as EditorOptions, gl as WordOperations, gm as CursorState$1, gn as WordPartOperations, go as isIOS, gp as editorOptionsRegistry, gq as ConfigurationChangedEvent, gr as ExtensionsRegistry, gs as isEqualOrParent, gt as _util, gu as __decorate$U, gv as __param$U, gw as isCompositeEditor, gx as IEditorService, gy as asCssVariableWithDefault, gz as buttonBackground, gA as editorForeground, gB as buttonForeground, gC as EmbeddedDiffEditorWidget, gD as EmbeddedDiffEditorWidget2, gE as AccessibilityHelpAction, gF as IAccessibleViewService, gG as AccessibleDiffViewerNext, gH as AccessibleDiffViewerPrev, gI as DiffEditorWidget2, gJ as ContextKeyEqualsExpr, gK as registerDiffEditorContribution, gL as basename$1, gM as n, gN as isBoolean, gO as refineServiceDecorator, gP as SemanticTokenRule, gQ as TokenMetadata, gR as ITextMateTokenizationService, gS as SelectActionViewItem, gT as defaultSelectBoxStyles, gU as createStyleSheet, gV as rot, gW as gotoPreviousLocation, gX as gotoNextLocation, gY as prepend, gZ as TextCompareEditorActiveContext, g_ as ActionRunner, g$ as IQuickDiffService, h0 as shouldSynchronizeModel, h1 as Extensions$1, h2 as applyCodeAction, h3 as ApplyCodeActionReason, h4 as ITextFileService, h5 as IExtensionService, h6 as languagesExtPoint, h7 as ColorExtensionPoint, h8 as distinct, h9 as StandaloneKeybindingService, ha as deepClone, hb as StandaloneServices, hc as StandaloneEditor, hd as StandaloneDiffEditor, he as IFileService, hf as VSBuffer, hg as ServiceCollection, hh as SyncDescriptor, hi as StandaloneQuickInputService, hj as Uri, l as languages, hk as editor, hl as Configuration$1, hm as distinct$1, hn as ConfigurationModelParser, ho as ConfigurationModel, hp as toValuesTree, hq as equals$2, hr as Queue, hs as setProperty, ht as parse, hu as OVERRIDE_PROPERTY_REGEX, hv as keyFromOverrideIdentifiers, hw as IUserDataProfileService, hx as IUserDataProfilesService, hy as IPreferencesService, hz as IUriIdentityService, hA as ErrorNoTelemetry, hB as DefaultConfiguration$1, hC as isEmptyObject, hD as UserSettings, hE as whenProviderRegistered, hF as getErrorMessage, hG as workbenchConfigurationNodeBase, hH as applicationSettings, hI as windowSettings, hJ as resourceSettings, hK as allSettings, hL as machineSettings, hM as machineOverridableSettings, hN as OVERRIDE_PROPERTY_PATTERN, hO as resourceLanguageSettingsSchemaId, hP as Extensions$2, hQ as configurationDefaultsSchemaId, hR as IWorkbenchEnvironmentService, hS as ILifecycleService, hT as IWorkbenchAssignmentService, hU as Barrier, hV as NullPolicyService, hW as NullPolicyConfiguration, hX as PolicyConfiguration, hY as isWorkspaceIdentifier, hZ as isSingleFolderWorkspaceIdentifier, h_ as isStoredWorkspaceFolder, h$ as toWorkspaceFolders, i0 as getStoredWorkspaceFolder, i1 as IJSONEditingService, i2 as isConfigurationOverrides, i3 as isConfigurationUpdateOverrides, i4 as Promises, i5 as isWorkspaceFolder, i6 as mark, i7 as toWorkspaceFolder, i8 as delta, i9 as mergeChanges, ia as toErrorMessage, ib as ConfigurationTargetToString, ic as ConfigurationChangeEvent, id as Workspace$1, ie as sep, ig as isProposedApiEnabled, ih as Memento, ii as match, ij as getPathLabel, ik as firstOrDefault, il as posix, im as win32, io as isWorkspace, ip as toWorkspaceIdentifier, iq as isUntitledWorkspace, ir as isTemporaryWorkspace, is as WORKSPACE_EXTENSION, it as tildify, iu as IPathService, iv as IRemoteAgentService, iw as restoreRecentlyOpened, ix as isRecentFolder, iy as isRecentWorkspace, iz as isRecentFile, iA as toStoreData, iB as mnemonicButtonLabel, iC as WORKSPACE_FILTER, iD as hasWorkspaceFileExtension, iE as isSavedWorkspace, iF as removeTrailingPathSeparator, iG as isEqualAuthority, iH as rewriteWorkspaceFileForNewLocation, iI as IWorkspacesService, iJ as IFileDialogService, iK as IDialogService$1, iL as IHostService, iM as ExtensionIdentifierMap, iN as validateProperty, iO as memoizedConstructor, iP as IPolicyService, iQ as getServiceOverride$1, iR as IWorkspaceEditingService, iS as unsupported, iT as registerServiceInitializePreParticipant, r as registerExtension, iU as api$2, iV as initialize, iW as initialize$1, iX as commands } from "./theme-defaults-1df7f429.js";
const anchorSelect = "";
var __decorate$T = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$T = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$P = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
let SelectionAnchorController = class SelectionAnchorController2 {
  static get(editor2) {
    return editor2.getContribution(SelectionAnchorController2.ID);
  }
  constructor(editor2, contextKeyService) {
    this.editor = editor2;
    this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
    this.modelChangeListener = editor2.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const position = this.editor.getPosition();
      this.editor.changeDecorations((accessor) => {
        if (this.decorationId) {
          accessor.removeDecoration(this.decorationId);
        }
        this.decorationId = accessor.addDecoration(Selection.fromPositions(position, position), {
          description: "selection-anchor",
          stickiness: 1,
          hoverMessage: new MarkdownString().appendText(localize("selectionAnchor", "Selection Anchor")),
          className: "selection-anchor"
        });
      });
      this.selectionAnchorSetContextKey.set(!!this.decorationId);
      alert(localize("anchorSet", "Anchor set at {0}:{1}", position.lineNumber, position.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
      if (anchorPosition) {
        this.editor.setPosition(anchorPosition.getStartPosition());
      }
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const start = this.editor.getModel().getDecorationRange(this.decorationId);
      if (start) {
        const end = this.editor.getPosition();
        this.editor.setSelection(Selection.fromPositions(start.getStartPosition(), end));
        this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      const decorationId = this.decorationId;
      this.editor.changeDecorations((accessor) => {
        accessor.removeDecoration(decorationId);
        this.decorationId = void 0;
      });
      this.selectionAnchorSetContextKey.set(false);
    }
  }
  dispose() {
    this.cancelSelectionAnchor();
    this.modelChangeListener.dispose();
  }
};
SelectionAnchorController.ID = "editor.contrib.selectionAnchorController";
SelectionAnchorController = __decorate$T([
  __param$T(1, IContextKeyService)
], SelectionAnchorController);
class SetSelectionAnchor extends EditorAction {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: localize("setSelectionAnchor", "Set Selection Anchor"),
      alias: "Set Selection Anchor",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 32
          /* KeyCode.KeyB */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a3;
    return __awaiter$P(this, void 0, void 0, function* () {
      (_a3 = SelectionAnchorController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.setSelectionAnchor();
    });
  }
}
class GoToSelectionAnchor extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: localize("goToSelectionAnchor", "Go to Selection Anchor"),
      alias: "Go to Selection Anchor",
      precondition: SelectionAnchorSet
    });
  }
  run(_accessor, editor2) {
    var _a3;
    return __awaiter$P(this, void 0, void 0, function* () {
      (_a3 = SelectionAnchorController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.goToSelectionAnchor();
    });
  }
}
class SelectFromAnchorToCursor extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: localize("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
      alias: "Select from Anchor to Cursor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 41
          /* KeyCode.KeyK */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a3;
    return __awaiter$P(this, void 0, void 0, function* () {
      (_a3 = SelectionAnchorController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.selectFromAnchorToCursor();
    });
  }
}
class CancelSelectionAnchor extends EditorAction {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: localize("cancelSelectionAnchor", "Cancel Selection Anchor"),
      alias: "Cancel Selection Anchor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a3;
    return __awaiter$P(this, void 0, void 0, function* () {
      (_a3 = SelectionAnchorController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.cancelSelectionAnchor();
    });
  }
}
registerEditorContribution(
  SelectionAnchorController.ID,
  SelectionAnchorController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(SetSelectionAnchor);
registerEditorAction(GoToSelectionAnchor);
registerEditorAction(SelectFromAnchorToCursor);
registerEditorAction(CancelSelectionAnchor);
const bracketMatching = "";
const overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hcDark: "#A0A0A0", hcLight: "#A0A0A0" }, localize("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
class JumpToBracketAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: localize("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 93,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    var _a3;
    (_a3 = BracketMatchingController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.jumpToBracket();
  }
}
class SelectToBracketAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: localize("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      description: {
        description: `Select to Bracket`,
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "selectBrackets": {
                type: "boolean",
                default: true
              }
            }
          }
        }]
      }
    });
  }
  run(accessor, editor2, args) {
    var _a3;
    let selectBrackets = true;
    if (args && args.selectBrackets === false) {
      selectBrackets = false;
    }
    (_a3 = BracketMatchingController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.selectToBracket(selectBrackets);
  }
}
class RemoveBracketsAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeBrackets",
      label: localize("smartSelect.removeBrackets", "Remove Brackets"),
      alias: "Remove Brackets",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 1,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    var _a3;
    (_a3 = BracketMatchingController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.removeBrackets(this.id);
  }
}
class BracketsData {
  constructor(position, brackets, options) {
    this.position = position;
    this.brackets = brackets;
    this.options = options;
  }
}
class BracketMatchingController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(BracketMatchingController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._lastBracketsData = [];
    this._lastVersionId = 0;
    this._decorations = this._editor.createDecorationsCollection();
    this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
    this._matchBrackets = this._editor.getOption(
      70
      /* EditorOption.matchBrackets */
    );
    this._updateBracketsSoon.schedule();
    this._register(editor2.onDidChangeCursorPosition((e) => {
      if (this._matchBrackets === "never") {
        return;
      }
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelLanguageConfiguration((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        70
        /* EditorOption.matchBrackets */
      )) {
        this._matchBrackets = this._editor.getOption(
          70
          /* EditorOption.matchBrackets */
        );
        this._decorations.clear();
        this._lastBracketsData = [];
        this._lastVersionId = 0;
        this._updateBracketsSoon.schedule();
      }
    }));
    this._register(editor2.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  jumpToBracket() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = this._editor.getSelections().map((selection) => {
      const position = selection.getStartPosition();
      const brackets = model.bracketPairs.matchBracket(position);
      let newCursorPosition = null;
      if (brackets) {
        if (brackets[0].containsPosition(position) && !brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[1].getStartPosition();
        } else if (brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[0].getStartPosition();
        }
      } else {
        const enclosingBrackets = model.bracketPairs.findEnclosingBrackets(position);
        if (enclosingBrackets) {
          newCursorPosition = enclosingBrackets[1].getStartPosition();
        } else {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            newCursorPosition = nextBracket.range.getStartPosition();
          }
        }
      }
      if (newCursorPosition) {
        return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
      }
      return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
    });
    this._editor.setSelections(newSelections);
    this._editor.revealRange(newSelections[0]);
  }
  selectToBracket(selectBrackets) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = [];
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getStartPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
        if (!brackets) {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            brackets = model.bracketPairs.matchBracket(nextBracket.range.getStartPosition());
          }
        }
      }
      let selectFrom = null;
      let selectTo = null;
      if (brackets) {
        brackets.sort(Range$1.compareRangesUsingStarts);
        const [open, close] = brackets;
        selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
        selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
        if (close.containsPosition(position)) {
          const tmp = selectFrom;
          selectFrom = selectTo;
          selectTo = tmp;
        }
      }
      if (selectFrom && selectTo) {
        newSelections.push(new Selection(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
      }
    });
    if (newSelections.length > 0) {
      this._editor.setSelections(newSelections);
      this._editor.revealRange(newSelections[0]);
    }
  }
  removeBrackets(editSource) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
      }
      if (brackets) {
        this._editor.pushUndoStop();
        this._editor.executeEdits(editSource, [
          { range: brackets[0], text: "" },
          { range: brackets[1], text: "" }
        ]);
        this._editor.pushUndoStop();
      }
    });
  }
  _updateBrackets() {
    if (this._matchBrackets === "never") {
      return;
    }
    this._recomputeBrackets();
    const newDecorations = [];
    let newDecorationsLen = 0;
    for (const bracketData of this._lastBracketsData) {
      const brackets = bracketData.brackets;
      if (brackets) {
        newDecorations[newDecorationsLen++] = { range: brackets[0], options: bracketData.options };
        newDecorations[newDecorationsLen++] = { range: brackets[1], options: bracketData.options };
      }
    }
    this._decorations.set(newDecorations);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const selections = this._editor.getSelections();
    if (selections.length > 100) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const model = this._editor.getModel();
    const versionId = model.getVersionId();
    let previousData = [];
    if (this._lastVersionId === versionId) {
      previousData = this._lastBracketsData;
    }
    const positions = [];
    let positionsLen = 0;
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (selection.isEmpty()) {
        positions[positionsLen++] = selection.getStartPosition();
      }
    }
    if (positions.length > 1) {
      positions.sort(Position$1.compare);
    }
    const newData = [];
    let newDataLen = 0;
    let previousIndex = 0;
    const previousLen = previousData.length;
    for (let i = 0, len = positions.length; i < len; i++) {
      const position = positions[i];
      while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
        previousIndex++;
      }
      if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
        newData[newDataLen++] = previousData[previousIndex];
      } else {
        let brackets = model.bracketPairs.matchBracket(
          position,
          20
          /* give at most 20ms to compute */
        );
        let options = BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        if (!brackets && this._matchBrackets === "always") {
          brackets = model.bracketPairs.findEnclosingBrackets(
            position,
            20
            /* give at most 20ms to compute */
          );
          options = BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
        }
        newData[newDataLen++] = new BracketsData(position, brackets, options);
      }
    }
    this._lastBracketsData = newData;
    this._lastVersionId = versionId;
  }
}
BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: themeColorFromId(overviewRulerBracketMatchForeground),
    position: OverviewRulerLane.Center
  }
});
BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
registerEditorContribution(
  BracketMatchingController.ID,
  BracketMatchingController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
registerEditorAction(RemoveBracketsAction);
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: localize({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
  },
  order: 2
});
class MoveCaretCommand {
  constructor(selection, isMovingLeft) {
    this._selection = selection;
    this._isMovingLeft = isMovingLeft;
  }
  getEditOperations(model, builder) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) {
      return;
    }
    const lineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    const endColumn = this._selection.endColumn;
    if (this._isMovingLeft && startColumn === 1) {
      return;
    }
    if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) {
      return;
    }
    if (this._isMovingLeft) {
      const rangeBefore = new Range$1(lineNumber, startColumn - 1, lineNumber, startColumn);
      const charBefore = model.getValueInRange(rangeBefore);
      builder.addEditOperation(rangeBefore, null);
      builder.addEditOperation(new Range$1(lineNumber, endColumn, lineNumber, endColumn), charBefore);
    } else {
      const rangeAfter = new Range$1(lineNumber, endColumn, lineNumber, endColumn + 1);
      const charAfter = model.getValueInRange(rangeAfter);
      builder.addEditOperation(rangeAfter, null);
      builder.addEditOperation(new Range$1(lineNumber, startColumn, lineNumber, startColumn), charAfter);
    }
  }
  computeCursorState(model, helper) {
    if (this._isMovingLeft) {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
    } else {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
    }
  }
}
class MoveCaretAction extends EditorAction {
  constructor(left, opts) {
    super(opts);
    this.left = left;
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands2 = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands2.push(new MoveCaretCommand(selection, this.left));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class MoveCaretLeftAction extends MoveCaretAction {
  constructor() {
    super(true, {
      id: "editor.action.moveCarretLeftAction",
      label: localize("caret.moveLeft", "Move Selected Text Left"),
      alias: "Move Selected Text Left",
      precondition: EditorContextKeys.writable
    });
  }
}
class MoveCaretRightAction extends MoveCaretAction {
  constructor() {
    super(false, {
      id: "editor.action.moveCarretRightAction",
      label: localize("caret.moveRight", "Move Selected Text Right"),
      alias: "Move Selected Text Right",
      precondition: EditorContextKeys.writable
    });
  }
}
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);
class TransposeLettersAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: localize("transposeLetters.label", "Transpose Letters"),
      alias: "Transpose Letters",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 50
          /* KeyCode.KeyT */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands2 = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      if (!selection.isEmpty()) {
        continue;
      }
      const lineNumber = selection.startLineNumber;
      const column = selection.startColumn;
      const lastColumn = model.getLineMaxColumn(lineNumber);
      if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) {
        continue;
      }
      const endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
      const middlePosition = MoveOperations.leftPosition(model, endPosition);
      const beginPosition = MoveOperations.leftPosition(model, middlePosition);
      const leftChar = model.getValueInRange(Range$1.fromPositions(beginPosition, middlePosition));
      const rightChar = model.getValueInRange(Range$1.fromPositions(middlePosition, endPosition));
      const replaceRange = Range$1.fromPositions(beginPosition, endPosition);
      commands2.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
    }
    if (commands2.length > 0) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, commands2);
      editor2.pushUndoStop();
    }
  }
}
registerEditorAction(TransposeLettersAction);
var __awaiter$O = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
const supportsCut = isNative || document.queryCommandSupported("cut");
const supportsCopy = isNative || document.queryCommandSupported("copy");
const supportsPaste = typeof navigator.clipboard === "undefined" || isFirefox ? document.queryCommandSupported("paste") : true;
function registerCommand(command) {
  command.register();
  return command;
}
const CutAction = supportsCut ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind cut keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 54,
      win: { primary: 2048 | 54, secondary: [
        1024 | 20
        /* KeyCode.Delete */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
    order: 1
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.cutLabel", "Cut"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }]
})) : void 0;
const CopyAction = supportsCopy ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind copy keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 33,
      win: { primary: 2048 | 33, secondary: [
        2048 | 19
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
    order: 2
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }]
})) : void 0;
MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: "2_ccp", order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextShare, title: { value: localize("share", "Share"), original: "Share" }, group: "11_share", order: -1, when: ContextKeyExpr.and(ContextKeyExpr.notEquals("resourceScheme", "output"), EditorContextKeys.editorTextFocus) });
MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, { submenu: MenuId.EditorTitleContextShare, title: { value: localize("share", "Share"), original: "Share" }, group: "11_share", order: -1 });
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, { submenu: MenuId.ExplorerContextShare, title: { value: localize("share", "Share"), original: "Share" }, group: "11_share", order: -1 });
const PasteAction = supportsPaste ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind paste keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 52,
      win: { primary: 2048 | 52, secondary: [
        1024 | 19
        /* KeyCode.Insert */
      ] },
      linux: { primary: 2048 | 52, secondary: [
        1024 | 19
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
    order: 4
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }]
})) : void 0;
class ExecCommandCopyWithSyntaxHighlightingAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: localize("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
      alias: "Copy With Syntax Highlighting",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const emptySelectionClipboard = editor2.getOption(
      36
      /* EditorOption.emptySelectionClipboard */
    );
    if (!emptySelectionClipboard && editor2.getSelection().isEmpty()) {
      return;
    }
    CopyOptions.forceCopyWithSyntaxHighlighting = true;
    editor2.focus();
    document.execCommand("copy");
    CopyOptions.forceCopyWithSyntaxHighlighting = false;
  }
}
function registerExecCommandImpl(target, browserCommand) {
  if (!target) {
    return;
  }
  target.addImplementation(1e4, "code-editor", (accessor, args) => {
    const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const emptySelectionClipboard = focusedEditor.getOption(
        36
        /* EditorOption.emptySelectionClipboard */
      );
      const selection = focusedEditor.getSelection();
      if (selection && selection.isEmpty() && !emptySelectionClipboard) {
        return true;
      }
      document.execCommand(browserCommand);
      return true;
    }
    return false;
  });
  target.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand(browserCommand);
    return true;
  });
}
registerExecCommandImpl(CutAction, "cut");
registerExecCommandImpl(CopyAction, "copy");
if (PasteAction) {
  PasteAction.addImplementation(1e4, "code-editor", (accessor, args) => {
    const codeEditorService = accessor.get(ICodeEditorService);
    const clipboardService = accessor.get(IClipboardService);
    const focusedEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const result = document.execCommand("paste");
      if (!result && isWeb) {
        return (() => __awaiter$O(void 0, void 0, void 0, function* () {
          const clipboardText = yield clipboardService.readText();
          if (clipboardText !== "") {
            const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
            let pasteOnNewLine = false;
            let multicursorText = null;
            let mode = null;
            if (metadata) {
              pasteOnNewLine = focusedEditor.getOption(
                36
                /* EditorOption.emptySelectionClipboard */
              ) && !!metadata.isFromEmptySelection;
              multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
              mode = metadata.mode;
            }
            focusedEditor.trigger("keyboard", "paste", {
              text: clipboardText,
              pasteOnNewLine,
              multicursorText,
              mode
            });
          }
        }))();
      }
      return true;
    }
    return false;
  });
  PasteAction.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand("paste");
    return true;
  });
}
if (supportsCopy) {
  registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
}
function contextKeyForSupportedActions(kind) {
  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
const argsSchema = {
  type: "object",
  defaultSnippets: [{ body: { kind: "" } }],
  properties: {
    "kind": {
      type: "string",
      description: localize("args.schema.kind", "Kind of the code action to run.")
    },
    "apply": {
      type: "string",
      description: localize("args.schema.apply", "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: [
        "first",
        "ifSingle",
        "never"
        /* CodeActionAutoApply.Never */
      ],
      enumDescriptions: [
        localize("args.schema.apply.first", "Always apply the first returned code action."),
        localize("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
        localize("args.schema.apply.never", "Do not apply the returned code actions.")
      ]
    },
    "preferred": {
      type: "boolean",
      default: false,
      description: localize("args.schema.preferred", "Controls if only preferred code actions should be returned.")
    }
  }
};
function triggerCodeActionsForEditorSelection(editor2, notAvailableMessage, filter, autoApply, triggerAction = CodeActionTriggerSource.Default) {
  if (editor2.hasModel()) {
    const controller = CodeActionController.get(editor2);
    controller === null || controller === void 0 ? void 0 : controller.manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply);
  }
}
class QuickFixAction extends EditorAction {
  constructor() {
    super({
      id: quickFixCommandId,
      label: localize("quickfix.trigger.label", "Quick Fix..."),
      alias: "Quick Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 89,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0, CodeActionTriggerSource.QuickFix);
  }
}
class CodeActionCommand extends EditorCommand {
  constructor() {
    super({
      id: codeActionCommandId,
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      description: {
        description: "Trigger a code action",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  runEditorCommand(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind$1.Empty,
      apply: "ifSingle"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", userArgs.kind) : localize("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : localize("editor.action.codeAction.noneMessage", "No code actions available"), {
      include: args.kind,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
}
class RefactorAction extends EditorAction {
  constructor() {
    super({
      id: refactorCommandId,
      label: localize("refactor.label", "Refactor..."),
      alias: "Refactor...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 48,
        mac: {
          primary: 256 | 1024 | 48
          /* KeyCode.KeyR */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind$1.Refactor))
      },
      description: {
        description: "Refactor...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind$1.Refactor,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", userArgs.kind) : localize("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : localize("editor.action.refactor.noneMessage", "No refactorings available"), {
      include: CodeActionKind$1.Refactor.contains(args.kind) ? args.kind : CodeActionKind$1.None,
      onlyIncludePreferredActions: args.preferred
    }, args.apply, CodeActionTriggerSource.Refactor);
  }
}
class SourceAction extends EditorAction {
  constructor() {
    super({
      id: sourceActionCommandId,
      label: localize("source.label", "Source Action..."),
      alias: "Source Action...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind$1.Source))
      },
      description: {
        description: "Source Action...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind$1.Source,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", userArgs.kind) : localize("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.source.noneMessage.preferred", "No preferred source actions available") : localize("editor.action.source.noneMessage", "No source actions available"), {
      include: CodeActionKind$1.Source.contains(args.kind) ? args.kind : CodeActionKind$1.None,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply, CodeActionTriggerSource.SourceAction);
  }
}
class OrganizeImportsAction extends EditorAction {
  constructor() {
    super({
      id: organizeImportsCommandId,
      label: localize("organizeImports.label", "Organize Imports"),
      alias: "Organize Imports",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind$1.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 512 | 45,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.organize.noneMessage", "No organize imports action available"), { include: CodeActionKind$1.SourceOrganizeImports, includeSourceActions: true }, "ifSingle", CodeActionTriggerSource.OrganizeImports);
  }
}
class FixAllAction extends EditorAction {
  constructor() {
    super({
      id: fixAllCommandId,
      label: localize("fixAll.label", "Fix All"),
      alias: "Fix All",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind$1.SourceFixAll))
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("fixAll.noneMessage", "No fix all action available"), { include: CodeActionKind$1.SourceFixAll, includeSourceActions: true }, "ifSingle", CodeActionTriggerSource.FixAll);
  }
}
class AutoFixAction extends EditorAction {
  constructor() {
    super({
      id: autoFixCommandId,
      label: localize("autoFix.label", "Auto Fix..."),
      alias: "Auto Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind$1.QuickFix)),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 512 | 1024 | 89,
        mac: {
          primary: 2048 | 512 | 89
          /* KeyCode.Period */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.autoFix.noneMessage", "No auto fixes available"), {
      include: CodeActionKind$1.QuickFix,
      onlyIncludePreferredActions: true
    }, "ifSingle", CodeActionTriggerSource.AutoFix);
  }
}
registerEditorContribution(
  CodeActionController.ID,
  CodeActionController,
  3
  /* EditorContributionInstantiation.Eventually */
);
registerEditorContribution(
  LightBulbWidget.ID,
  LightBulbWidget,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorAction(AutoFixAction);
registerEditorAction(FixAllAction);
registerEditorCommand(new CodeActionCommand());
Registry.as(Extensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
  "editor.codeActionWidget.showHeaders": {
    type: "boolean",
    scope: 5,
    description: localize("showCodeActionHeaders", "Enable/disable showing group headers in the Code Action menu."),
    default: true
  }
} }));
var __awaiter$N = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class CodeLensModel {
  constructor() {
    this.lenses = [];
    this._disposables = new DisposableStore();
  }
  dispose() {
    this._disposables.dispose();
  }
  get isDisposed() {
    return this._disposables.isDisposed;
  }
  add(list, provider) {
    this._disposables.add(list);
    for (const symbol of list.lenses) {
      this.lenses.push({ symbol, provider });
    }
  }
}
function getCodeLensModel(registry, model, token) {
  return __awaiter$N(this, void 0, void 0, function* () {
    const provider = registry.ordered(model);
    const providerRanks = /* @__PURE__ */ new Map();
    const result = new CodeLensModel();
    const promises = provider.map((provider2, i) => __awaiter$N(this, void 0, void 0, function* () {
      providerRanks.set(provider2, i);
      try {
        const list = yield Promise.resolve(provider2.provideCodeLenses(model, token));
        if (list) {
          result.add(list, provider2);
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }));
    yield Promise.all(promises);
    result.lenses = result.lenses.sort((a, b) => {
      if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
        return -1;
      } else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
        return 1;
      } else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) {
        return -1;
      } else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) {
        return 1;
      } else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
        return -1;
      } else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
        return 1;
      } else {
        return 0;
      }
    });
    return result;
  });
}
CommandsRegistry.registerCommand("_executeCodeLensProvider", function(accessor, ...args) {
  let [uri, itemResolveCount] = args;
  assertType(URI$1.isUri(uri));
  assertType(typeof itemResolveCount === "number" || !itemResolveCount);
  const { codeLensProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    throw illegalArgument();
  }
  const result = [];
  const disposables = new DisposableStore();
  return getCodeLensModel(codeLensProvider, model, CancellationToken.None).then((value) => {
    disposables.add(value);
    const resolve = [];
    for (const item of value.lenses) {
      if (itemResolveCount === void 0 || itemResolveCount === null || Boolean(item.symbol.command)) {
        result.push(item.symbol);
      } else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) {
        resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol) => result.push(symbol || item.symbol)));
      }
    }
    return Promise.all(resolve);
  }).then(() => {
    return result;
  }).finally(() => {
    setTimeout(() => disposables.dispose(), 100);
  });
});
var __decorate$S = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$S = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const ICodeLensCache = createDecorator("ICodeLensCache");
class CacheItem {
  constructor(lineCount, data) {
    this.lineCount = lineCount;
    this.data = data;
  }
}
let CodeLensCache = class CodeLensCache2 {
  constructor(storageService) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }();
    this._cache = new LRUCache(20, 0.75);
    const oldkey = "codelens/cache";
    runWhenIdle(() => storageService.remove(
      oldkey,
      1
      /* StorageScope.WORKSPACE */
    ));
    const key = "codelens/cache2";
    const raw = storageService.get(key, 1, "{}");
    this._deserialize(raw);
    once(storageService.onWillSaveState)((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        storageService.store(
          key,
          this._serialize(),
          1,
          1
          /* StorageTarget.MACHINE */
        );
      }
    });
  }
  put(model, data) {
    const copyItems = data.lenses.map((item2) => {
      var _a3;
      return {
        range: item2.symbol.range,
        command: item2.symbol.command && { id: "", title: (_a3 = item2.symbol.command) === null || _a3 === void 0 ? void 0 : _a3.title }
      };
    });
    const copyModel = new CodeLensModel();
    copyModel.add({ lenses: copyItems, dispose: () => {
    } }, this._fakeProvider);
    const item = new CacheItem(model.getLineCount(), copyModel);
    this._cache.set(model.uri.toString(), item);
  }
  get(model) {
    const item = this._cache.get(model.uri.toString());
    return item && item.lineCount === model.getLineCount() ? item.data : void 0;
  }
  delete(model) {
    this._cache.delete(model.uri.toString());
  }
  // --- persistence
  _serialize() {
    const data = /* @__PURE__ */ Object.create(null);
    for (const [key, value] of this._cache) {
      const lines = /* @__PURE__ */ new Set();
      for (const d of value.data.lenses) {
        lines.add(d.symbol.range.startLineNumber);
      }
      data[key] = {
        lineCount: value.lineCount,
        lines: [...lines.values()]
      };
    }
    return JSON.stringify(data);
  }
  _deserialize(raw) {
    try {
      const data = JSON.parse(raw);
      for (const key in data) {
        const element = data[key];
        const lenses = [];
        for (const line of element.lines) {
          lenses.push({ range: new Range$1(line, 1, line, 11) });
        }
        const model = new CodeLensModel();
        model.add({ lenses, dispose() {
        } }, this._fakeProvider);
        this._cache.set(key, new CacheItem(element.lineCount, model));
      }
    } catch (_a3) {
    }
  }
};
CodeLensCache = __decorate$S([
  __param$S(0, IStorageService)
], CodeLensCache);
registerSingleton(
  ICodeLensCache,
  CodeLensCache,
  1
  /* InstantiationType.Delayed */
);
const codelensWidget = "";
class CodeLensViewZone {
  constructor(afterLineNumber, heightInPx, onHeight) {
    this.afterColumn = 1073741824;
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = heightInPx;
    this._onHeight = onHeight;
    this.suppressMouseDown = true;
    this.domNode = document.createElement("div");
  }
  onComputedHeight(height) {
    if (this._lastHeight === void 0) {
      this._lastHeight = height;
    } else if (this._lastHeight !== height) {
      this._lastHeight = height;
      this._onHeight();
    }
  }
  isVisible() {
    return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
  }
}
class CodeLensContentWidget {
  constructor(editor2, line) {
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this._commands = /* @__PURE__ */ new Map();
    this._isEmpty = true;
    this._editor = editor2;
    this._id = `codelens.widget-${CodeLensContentWidget._idPool++}`;
    this.updatePosition(line);
    this._domNode = document.createElement("span");
    this._domNode.className = `codelens-decoration`;
  }
  withCommands(lenses, animate) {
    this._commands.clear();
    const children = [];
    let hasSymbol = false;
    for (let i = 0; i < lenses.length; i++) {
      const lens = lenses[i];
      if (!lens) {
        continue;
      }
      hasSymbol = true;
      if (lens.command) {
        const title = renderLabelWithIcons(lens.command.title.trim());
        if (lens.command.id) {
          children.push($$8("a", { id: String(i), title: lens.command.tooltip, role: "button" }, ...title));
          this._commands.set(String(i), lens.command);
        } else {
          children.push($$8("span", { title: lens.command.tooltip }, ...title));
        }
        if (i + 1 < lenses.length) {
          children.push($$8("span", void 0, " | "));
        }
      }
    }
    if (!hasSymbol) {
      reset(this._domNode, $$8("span", void 0, "no commands"));
    } else {
      reset(this._domNode, ...children);
      if (this._isEmpty && animate) {
        this._domNode.classList.add("fadein");
      }
      this._isEmpty = false;
    }
  }
  getCommand(link) {
    return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(line) {
    const column = this._editor.getModel().getLineFirstNonWhitespaceColumn(line);
    this._widgetPosition = {
      position: { lineNumber: line, column },
      preference: [
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
}
CodeLensContentWidget._idPool = 0;
class CodeLensHelper {
  constructor() {
    this._removeDecorations = [];
    this._addDecorations = [];
    this._addDecorationsCallbacks = [];
  }
  addDecoration(decoration2, callback) {
    this._addDecorations.push(decoration2);
    this._addDecorationsCallbacks.push(callback);
  }
  removeDecoration(decorationId) {
    this._removeDecorations.push(decorationId);
  }
  commit(changeAccessor) {
    const resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i = 0, len = resultingDecorations.length; i < len; i++) {
      this._addDecorationsCallbacks[i](resultingDecorations[i]);
    }
  }
}
const codeLensDecorationOptions = ModelDecorationOptions.register({
  collapseOnReplaceEdit: true,
  description: "codelens"
});
class CodeLensWidget {
  constructor(data, editor2, helper, viewZoneChangeAccessor, heightInPx, updateCallback) {
    this._isDisposed = false;
    this._editor = editor2;
    this._data = data;
    this._decorationIds = [];
    let range;
    const lenses = [];
    this._data.forEach((codeLensData, i) => {
      if (codeLensData.symbol.command) {
        lenses.push(codeLensData.symbol);
      }
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: codeLensDecorationOptions
      }, (id) => this._decorationIds[i] = id);
      if (!range) {
        range = Range$1.lift(codeLensData.symbol.range);
      } else {
        range = Range$1.plusRange(range, codeLensData.symbol.range);
      }
    });
    this._viewZone = new CodeLensViewZone(range.startLineNumber - 1, heightInPx, updateCallback);
    this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
    if (lenses.length > 0) {
      this._createContentWidgetIfNecessary();
      this._contentWidget.withCommands(lenses, false);
    }
  }
  _createContentWidgetIfNecessary() {
    if (!this._contentWidget) {
      this._contentWidget = new CodeLensContentWidget(this._editor, this._viewZone.afterLineNumber + 1);
      this._editor.addContentWidget(this._contentWidget);
    } else {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  dispose(helper, viewZoneChangeAccessor) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    viewZoneChangeAccessor === null || viewZoneChangeAccessor === void 0 ? void 0 : viewZoneChangeAccessor.removeZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.removeContentWidget(this._contentWidget);
      this._contentWidget = void 0;
    }
    this._isDisposed = true;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((id, i) => {
      const range = this._editor.getModel().getDecorationRange(id);
      const symbol = this._data[i].symbol;
      return !!(range && Range$1.isEmpty(symbol.range) === range.isEmpty());
    });
  }
  updateCodeLensSymbols(data, helper) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    this._data = data;
    this._data.forEach((codeLensData, i) => {
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: codeLensDecorationOptions
      }, (id) => this._decorationIds[i] = id);
    });
  }
  updateHeight(height, viewZoneChangeAccessor) {
    this._viewZone.heightInPx = height;
    viewZoneChangeAccessor.layoutZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  computeIfNecessary(model) {
    if (!this._viewZone.isVisible()) {
      return null;
    }
    for (let i = 0; i < this._decorationIds.length; i++) {
      const range = model.getDecorationRange(this._decorationIds[i]);
      if (range) {
        this._data[i].symbol.range = range;
      }
    }
    return this._data;
  }
  updateCommands(symbols) {
    this._createContentWidgetIfNecessary();
    this._contentWidget.withCommands(symbols, true);
    for (let i = 0; i < this._data.length; i++) {
      const resolved = symbols[i];
      if (resolved) {
        const { symbol } = this._data[i];
        symbol.command = resolved.command || symbol.command;
      }
    }
  }
  getCommand(link) {
    var _a3;
    return (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.getCommand(link);
  }
  getLineNumber() {
    const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    if (range) {
      return range.startLineNumber;
    }
    return -1;
  }
  update(viewZoneChangeAccessor) {
    if (this.isValid()) {
      const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      if (range) {
        this._viewZone.afterLineNumber = range.startLineNumber - 1;
        viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        if (this._contentWidget) {
          this._contentWidget.updatePosition(range.startLineNumber);
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
    }
  }
  getItems() {
    return this._data;
  }
}
var __decorate$R = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$R = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$M = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let CodeLensContribution = class CodeLensContribution2 {
  constructor(_editor, _languageFeaturesService, debounceService, _commandService, _notificationService, _codeLensCache) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._codeLensCache = _codeLensCache;
    this._disposables = new DisposableStore();
    this._localToDispose = new DisposableStore();
    this._lenses = [];
    this._oldCodeLensModels = new DisposableStore();
    this._provideCodeLensDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensProvide", { min: 250 });
    this._resolveCodeLensesDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensResolve", { min: 250, salt: "resolve" });
    this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default());
    this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      ) || e.hasChanged(
        18
        /* EditorOption.codeLensFontSize */
      ) || e.hasChanged(
        17
        /* EditorOption.codeLensFontFamily */
      )) {
        this._updateLensStyle();
      }
      if (e.hasChanged(
        16
        /* EditorOption.codeLens */
      )) {
        this._onModelChange();
      }
    }));
    this._disposables.add(_languageFeaturesService.codeLensProvider.onDidChange(this._onModelChange, this));
    this._onModelChange();
    this._updateLensStyle();
  }
  dispose() {
    var _a3;
    this._localDispose();
    this._disposables.dispose();
    this._oldCodeLensModels.dispose();
    (_a3 = this._currentCodeLensModel) === null || _a3 === void 0 ? void 0 : _a3.dispose();
  }
  _getLayoutInfo() {
    const lineHeightFactor = Math.max(1.3, this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    ) / this._editor.getOption(
      51
      /* EditorOption.fontSize */
    ));
    let fontSize = this._editor.getOption(
      18
      /* EditorOption.codeLensFontSize */
    );
    if (!fontSize || fontSize < 5) {
      fontSize = this._editor.getOption(
        51
        /* EditorOption.fontSize */
      ) * 0.9 | 0;
    }
    return {
      fontSize,
      codeLensHeight: fontSize * lineHeightFactor | 0
    };
  }
  _updateLensStyle() {
    const { codeLensHeight, fontSize } = this._getLayoutInfo();
    const fontFamily = this._editor.getOption(
      17
      /* EditorOption.codeLensFontFamily */
    );
    const editorFontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    const { style } = this._editor.getContainerDomNode();
    style.setProperty("--vscode-editorCodeLens-lineHeight", `${codeLensHeight}px`);
    style.setProperty("--vscode-editorCodeLens-fontSize", `${fontSize}px`);
    style.setProperty("--vscode-editorCodeLens-fontFeatureSettings", editorFontInfo.fontFeatureSettings);
    if (fontFamily) {
      style.setProperty("--vscode-editorCodeLens-fontFamily", fontFamily);
      style.setProperty("--vscode-editorCodeLens-fontFamilyDefault", EDITOR_FONT_DEFAULTS.fontFamily);
    }
    this._editor.changeViewZones((accessor) => {
      for (const lens of this._lenses) {
        lens.updateHeight(codeLensHeight, accessor);
      }
    });
  }
  _localDispose() {
    var _a3, _b3, _c3;
    (_a3 = this._getCodeLensModelPromise) === null || _a3 === void 0 ? void 0 : _a3.cancel();
    this._getCodeLensModelPromise = void 0;
    (_b3 = this._resolveCodeLensesPromise) === null || _b3 === void 0 ? void 0 : _b3.cancel();
    this._resolveCodeLensesPromise = void 0;
    this._localToDispose.clear();
    this._oldCodeLensModels.clear();
    (_c3 = this._currentCodeLensModel) === null || _c3 === void 0 ? void 0 : _c3.dispose();
  }
  _onModelChange() {
    this._localDispose();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (!this._editor.getOption(
      16
      /* EditorOption.codeLens */
    )) {
      return;
    }
    const cachedLenses = this._codeLensCache.get(model);
    if (cachedLenses) {
      this._renderCodeLensSymbols(cachedLenses);
    }
    if (!this._languageFeaturesService.codeLensProvider.has(model)) {
      if (cachedLenses) {
        this._localToDispose.add(disposableTimeout(() => {
          const cachedLensesNow = this._codeLensCache.get(model);
          if (cachedLenses === cachedLensesNow) {
            this._codeLensCache.delete(model);
            this._onModelChange();
          }
        }, 30 * 1e3));
      }
      return;
    }
    for (const provider of this._languageFeaturesService.codeLensProvider.all(model)) {
      if (typeof provider.onDidChange === "function") {
        const registration = provider.onDidChange(() => scheduler.schedule());
        this._localToDispose.add(registration);
      }
    }
    const scheduler = new RunOnceScheduler(() => {
      var _a3;
      const t1 = Date.now();
      (_a3 = this._getCodeLensModelPromise) === null || _a3 === void 0 ? void 0 : _a3.cancel();
      this._getCodeLensModelPromise = createCancelablePromise((token) => getCodeLensModel(this._languageFeaturesService.codeLensProvider, model, token));
      this._getCodeLensModelPromise.then((result) => {
        if (this._currentCodeLensModel) {
          this._oldCodeLensModels.add(this._currentCodeLensModel);
        }
        this._currentCodeLensModel = result;
        this._codeLensCache.put(model, result);
        const newDelay = this._provideCodeLensDebounce.update(model, Date.now() - t1);
        scheduler.delay = newDelay;
        this._renderCodeLensSymbols(result);
        this._resolveCodeLensesInViewportSoon();
      }, onUnexpectedError);
    }, this._provideCodeLensDebounce.get(model));
    this._localToDispose.add(scheduler);
    this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      var _a3;
      this._editor.changeDecorations((decorationsAccessor) => {
        this._editor.changeViewZones((viewZonesAccessor) => {
          const toDispose = [];
          let lastLensLineNumber = -1;
          this._lenses.forEach((lens) => {
            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
              toDispose.push(lens);
            } else {
              lens.update(viewZonesAccessor);
              lastLensLineNumber = lens.getLineNumber();
            }
          });
          const helper = new CodeLensHelper();
          toDispose.forEach((l) => {
            l.dispose(helper, viewZonesAccessor);
            this._lenses.splice(this._lenses.indexOf(l), 1);
          });
          helper.commit(decorationsAccessor);
        });
      });
      scheduler.schedule();
      this._resolveCodeLensesScheduler.cancel();
      (_a3 = this._resolveCodeLensesPromise) === null || _a3 === void 0 ? void 0 : _a3.cancel();
      this._resolveCodeLensesPromise = void 0;
    }));
    this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged && this._lenses.length > 0) {
        this._resolveCodeLensesInViewportSoon();
      }
    }));
    this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      this._resolveCodeLensesInViewportSoon();
    }));
    this._localToDispose.add(toDisposable(() => {
      if (this._editor.getModel()) {
        const scrollState = StableEditorScrollState.capture(this._editor);
        this._editor.changeDecorations((decorationsAccessor) => {
          this._editor.changeViewZones((viewZonesAccessor) => {
            this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
          });
        });
        scrollState.restore(this._editor);
      } else {
        this._disposeAllLenses(void 0, void 0);
      }
    }));
    this._localToDispose.add(this._editor.onMouseDown((e) => {
      if (e.target.type !== 9) {
        return;
      }
      let target = e.target.element;
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "SPAN") {
        target = target.parentElement;
      }
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "A") {
        for (const lens of this._lenses) {
          const command = lens.getCommand(target);
          if (command) {
            this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
            break;
          }
        }
      }
    }));
    scheduler.schedule();
  }
  _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
    const helper = new CodeLensHelper();
    for (const lens of this._lenses) {
      lens.dispose(helper, viewZoneChangeAccessor);
    }
    if (decChangeAccessor) {
      helper.commit(decChangeAccessor);
    }
    this._lenses.length = 0;
  }
  _renderCodeLensSymbols(symbols) {
    if (!this._editor.hasModel()) {
      return;
    }
    const maxLineNumber = this._editor.getModel().getLineCount();
    const groups = [];
    let lastGroup;
    for (const symbol of symbols.lenses) {
      const line = symbol.symbol.range.startLineNumber;
      if (line < 1 || line > maxLineNumber) {
        continue;
      } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
        lastGroup.push(symbol);
      } else {
        lastGroup = [symbol];
        groups.push(lastGroup);
      }
    }
    if (!groups.length && !this._lenses.length) {
      return;
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    const layoutInfo = this._getLayoutInfo();
    this._editor.changeDecorations((decorationsAccessor) => {
      this._editor.changeViewZones((viewZoneAccessor) => {
        const helper = new CodeLensHelper();
        let codeLensIndex = 0;
        let groupsIndex = 0;
        while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
          const symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
          const codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
          if (codeLensLineNumber < symbolsLineNumber) {
            this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
            this._lenses.splice(codeLensIndex, 1);
          } else if (codeLensLineNumber === symbolsLineNumber) {
            this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
            groupsIndex++;
            codeLensIndex++;
          } else {
            this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
            codeLensIndex++;
            groupsIndex++;
          }
        }
        while (codeLensIndex < this._lenses.length) {
          this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
          this._lenses.splice(codeLensIndex, 1);
        }
        while (groupsIndex < groups.length) {
          this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
          groupsIndex++;
        }
        helper.commit(decorationsAccessor);
      });
    });
    scrollState.restore(this._editor);
  }
  _resolveCodeLensesInViewportSoon() {
    const model = this._editor.getModel();
    if (model) {
      this._resolveCodeLensesScheduler.schedule();
    }
  }
  _resolveCodeLensesInViewport() {
    var _a3;
    (_a3 = this._resolveCodeLensesPromise) === null || _a3 === void 0 ? void 0 : _a3.cancel();
    this._resolveCodeLensesPromise = void 0;
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    const toResolve = [];
    const lenses = [];
    this._lenses.forEach((lens) => {
      const request = lens.computeIfNecessary(model);
      if (request) {
        toResolve.push(request);
        lenses.push(lens);
      }
    });
    if (toResolve.length === 0) {
      return;
    }
    const t1 = Date.now();
    const resolvePromise = createCancelablePromise((token) => {
      const promises = toResolve.map((request, i) => {
        const resolvedSymbols = new Array(request.length);
        const promises2 = request.map((request2, i2) => {
          if (!request2.symbol.command && typeof request2.provider.resolveCodeLens === "function") {
            return Promise.resolve(request2.provider.resolveCodeLens(model, request2.symbol, token)).then((symbol) => {
              resolvedSymbols[i2] = symbol;
            }, onUnexpectedExternalError);
          } else {
            resolvedSymbols[i2] = request2.symbol;
            return Promise.resolve(void 0);
          }
        });
        return Promise.all(promises2).then(() => {
          if (!token.isCancellationRequested && !lenses[i].isDisposed()) {
            lenses[i].updateCommands(resolvedSymbols);
          }
        });
      });
      return Promise.all(promises);
    });
    this._resolveCodeLensesPromise = resolvePromise;
    this._resolveCodeLensesPromise.then(() => {
      const newDelay = this._resolveCodeLensesDebounce.update(model, Date.now() - t1);
      this._resolveCodeLensesScheduler.delay = newDelay;
      if (this._currentCodeLensModel) {
        this._codeLensCache.put(model, this._currentCodeLensModel);
      }
      this._oldCodeLensModels.clear();
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    }, (err) => {
      onUnexpectedError(err);
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    });
  }
  getModel() {
    return this._currentCodeLensModel;
  }
};
CodeLensContribution.ID = "css.editor.codeLens";
CodeLensContribution = __decorate$R([
  __param$R(1, ILanguageFeaturesService),
  __param$R(2, ILanguageFeatureDebounceService),
  __param$R(3, ICommandService),
  __param$R(4, INotificationService),
  __param$R(5, ICodeLensCache)
], CodeLensContribution);
registerEditorContribution(
  CodeLensContribution.ID,
  CodeLensContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(class ShowLensesInCurrentLine extends EditorAction {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: EditorContextKeys.hasCodeLensProvider,
      label: localize("showLensOnLine", "Show CodeLens Commands For Current Line"),
      alias: "Show CodeLens Commands For Current Line"
    });
  }
  run(accessor, editor2) {
    return __awaiter$M(this, void 0, void 0, function* () {
      if (!editor2.hasModel()) {
        return;
      }
      const quickInputService = accessor.get(IQuickInputService);
      const commandService = accessor.get(ICommandService);
      const notificationService = accessor.get(INotificationService);
      const lineNumber = editor2.getSelection().positionLineNumber;
      const codelensController = editor2.getContribution(CodeLensContribution.ID);
      if (!codelensController) {
        return;
      }
      const model = codelensController.getModel();
      if (!model) {
        return;
      }
      const items = [];
      for (const lens of model.lenses) {
        if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) {
          items.push({
            label: lens.symbol.command.title,
            command: lens.symbol.command
          });
        }
      }
      if (items.length === 0) {
        return;
      }
      const item = yield quickInputService.pick(items, { canPickMany: false });
      if (!item) {
        return;
      }
      if (model.isDisposed) {
        return yield commandService.executeCommand(this.id);
      }
      try {
        yield commandService.executeCommand(item.command.id, ...item.command.arguments || []);
      } catch (err) {
        notificationService.error(err);
      }
    });
  }
});
var __decorate$Q = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$Q = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$L = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DefaultDocumentColorProvider {
  constructor(modelService, languageConfigurationService) {
    this._editorWorkerClient = new EditorWorkerClient(modelService, false, "editorWorkerService", languageConfigurationService);
  }
  provideDocumentColors(model, _token) {
    return __awaiter$L(this, void 0, void 0, function* () {
      return this._editorWorkerClient.computeDefaultDocumentColors(model.uri);
    });
  }
  provideColorPresentations(_model, colorInfo, _token) {
    const range = colorInfo.range;
    const colorFromInfo = colorInfo.color;
    const alpha = colorFromInfo.alpha;
    const color = new Color$1(new RGBA(Math.round(255 * colorFromInfo.red), Math.round(255 * colorFromInfo.green), Math.round(255 * colorFromInfo.blue), alpha));
    const rgb = alpha ? Color$1.Format.CSS.formatRGB(color) : Color$1.Format.CSS.formatRGBA(color);
    const hsl = alpha ? Color$1.Format.CSS.formatHSL(color) : Color$1.Format.CSS.formatHSLA(color);
    const hex = alpha ? Color$1.Format.CSS.formatHex(color) : Color$1.Format.CSS.formatHexA(color);
    const colorPresentations = [];
    colorPresentations.push({ label: rgb, textEdit: { range, text: rgb } });
    colorPresentations.push({ label: hsl, textEdit: { range, text: hsl } });
    colorPresentations.push({ label: hex, textEdit: { range, text: hex } });
    return colorPresentations;
  }
}
let DefaultDocumentColorProviderFeature = class DefaultDocumentColorProviderFeature2 extends Disposable {
  constructor(_modelService, _languageConfigurationService, _languageFeaturesService) {
    super();
    this._register(_languageFeaturesService.colorProvider.register("*", new DefaultDocumentColorProvider(_modelService, _languageConfigurationService)));
  }
};
DefaultDocumentColorProviderFeature = __decorate$Q([
  __param$Q(0, IModelService),
  __param$Q(1, ILanguageConfigurationService),
  __param$Q(2, ILanguageFeaturesService)
], DefaultDocumentColorProviderFeature);
registerEditorFeature(DefaultDocumentColorProviderFeature);
var __awaiter$K = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getColors(colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled = true) {
  return __awaiter$K(this, void 0, void 0, function* () {
    return _findColorData(new ColorDataCollector(), colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled);
  });
}
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
class ColorDataCollector {
  constructor() {
  }
  compute(provider, model, token, colors) {
    return __awaiter$K(this, void 0, void 0, function* () {
      const documentColors = yield provider.provideDocumentColors(model, token);
      if (Array.isArray(documentColors)) {
        for (const colorInfo of documentColors) {
          colors.push({ colorInfo, provider });
        }
      }
      return Array.isArray(documentColors);
    });
  }
}
class ExtColorDataCollector {
  constructor() {
  }
  compute(provider, model, token, colors) {
    return __awaiter$K(this, void 0, void 0, function* () {
      const documentColors = yield provider.provideDocumentColors(model, token);
      if (Array.isArray(documentColors)) {
        for (const colorInfo of documentColors) {
          colors.push({ range: colorInfo.range, color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha] });
        }
      }
      return Array.isArray(documentColors);
    });
  }
}
class ColorPresentationsCollector {
  constructor(colorInfo) {
    this.colorInfo = colorInfo;
  }
  compute(provider, model, _token, colors) {
    return __awaiter$K(this, void 0, void 0, function* () {
      const documentColors = yield provider.provideColorPresentations(model, this.colorInfo, CancellationToken.None);
      if (Array.isArray(documentColors)) {
        colors.push(...documentColors);
      }
      return Array.isArray(documentColors);
    });
  }
}
function _findColorData(collector, colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled) {
  return __awaiter$K(this, void 0, void 0, function* () {
    let validDocumentColorProviderFound = false;
    let defaultProvider;
    const colorData = [];
    const documentColorProviders = colorProviderRegistry.ordered(model);
    for (let i = documentColorProviders.length - 1; i >= 0; i--) {
      const provider = documentColorProviders[i];
      if (provider instanceof DefaultDocumentColorProvider) {
        defaultProvider = provider;
      } else {
        try {
          if (yield collector.compute(provider, model, token, colorData)) {
            validDocumentColorProviderFound = true;
          }
        } catch (e) {
          onUnexpectedExternalError(e);
        }
      }
    }
    if (validDocumentColorProviderFound) {
      return colorData;
    }
    if (defaultProvider && isDefaultColorDecoratorsEnabled) {
      yield collector.compute(defaultProvider, model, token, colorData);
      return colorData;
    }
    return [];
  });
}
function _setupColorCommand(accessor, resource) {
  const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const isDefaultColorDecoratorsEnabled = accessor.get(IConfigurationService).getValue("editor.defaultColorDecorators", { resource });
  return { model, colorProviderRegistry, isDefaultColorDecoratorsEnabled };
}
CommandsRegistry.registerCommand("_executeDocumentColorProvider", function(accessor, ...args) {
  const [resource] = args;
  if (!(resource instanceof URI$1)) {
    throw illegalArgument();
  }
  const { model, colorProviderRegistry, isDefaultColorDecoratorsEnabled } = _setupColorCommand(accessor, resource);
  return _findColorData(new ExtColorDataCollector(), colorProviderRegistry, model, CancellationToken.None, isDefaultColorDecoratorsEnabled);
});
CommandsRegistry.registerCommand("_executeColorPresentationProvider", function(accessor, ...args) {
  const [color, context] = args;
  const { uri, range } = context;
  if (!(uri instanceof URI$1) || !Array.isArray(color) || color.length !== 4 || !Range$1.isIRange(range)) {
    throw illegalArgument();
  }
  const { model, colorProviderRegistry, isDefaultColorDecoratorsEnabled } = _setupColorCommand(accessor, uri);
  const [red, green, blue, alpha] = color;
  return _findColorData(new ColorPresentationsCollector({ range, color: { red, green, blue, alpha } }), colorProviderRegistry, model, CancellationToken.None, isDefaultColorDecoratorsEnabled);
});
var __decorate$P = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$P = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$J = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ColorDecorationInjectedTextMarker = /* @__PURE__ */ Object.create({});
let ColorDetector = class ColorDetector2 extends Disposable {
  constructor(_editor, _configurationService, _languageFeaturesService, languageFeatureDebounceService) {
    super();
    this._editor = _editor;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._localToDispose = this._register(new DisposableStore());
    this._decorationsIds = [];
    this._colorDatas = /* @__PURE__ */ new Map();
    this._colorDecoratorIds = this._editor.createDecorationsCollection();
    this._ruleFactory = new DynamicCssRules(this._editor);
    this._decoratorLimitReporter = new DecoratorLimitReporter();
    this._colorDecorationClassRefs = this._register(new DisposableStore());
    this._debounceInformation = languageFeatureDebounceService.for(_languageFeaturesService.colorProvider, "Document Colors", { min: ColorDetector2.RECOMPUTE_TIME });
    this._register(_editor.onDidChangeModel(() => {
      this._isColorDecoratorsEnabled = this.isEnabled();
      this.updateColors();
    }));
    this._register(_editor.onDidChangeModelLanguage(() => this.updateColors()));
    this._register(_languageFeaturesService.colorProvider.onDidChange(() => this.updateColors()));
    this._register(_editor.onDidChangeConfiguration((e) => {
      const prevIsEnabled = this._isColorDecoratorsEnabled;
      this._isColorDecoratorsEnabled = this.isEnabled();
      this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
        144
        /* EditorOption.defaultColorDecorators */
      );
      const updatedColorDecoratorsSetting = prevIsEnabled !== this._isColorDecoratorsEnabled || e.hasChanged(
        20
        /* EditorOption.colorDecoratorsLimit */
      );
      const updatedDefaultColorDecoratorsSetting = e.hasChanged(
        144
        /* EditorOption.defaultColorDecorators */
      );
      if (updatedColorDecoratorsSetting || updatedDefaultColorDecoratorsSetting) {
        if (this._isColorDecoratorsEnabled) {
          this.updateColors();
        } else {
          this.removeAllDecorations();
        }
      }
    }));
    this._timeoutTimer = null;
    this._computePromise = null;
    this._isColorDecoratorsEnabled = this.isEnabled();
    this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
      144
      /* EditorOption.defaultColorDecorators */
    );
    this.updateColors();
  }
  isEnabled() {
    const model = this._editor.getModel();
    if (!model) {
      return false;
    }
    const languageId = model.getLanguageId();
    const deprecatedConfig = this._configurationService.getValue(languageId);
    if (deprecatedConfig && typeof deprecatedConfig === "object") {
      const colorDecorators = deprecatedConfig["colorDecorators"];
      if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) {
        return colorDecorators["enable"];
      }
    }
    return this._editor.getOption(
      19
      /* EditorOption.colorDecorators */
    );
  }
  get limitReporter() {
    return this._decoratorLimitReporter;
  }
  static get(editor2) {
    return editor2.getContribution(this.ID);
  }
  dispose() {
    this.stop();
    this.removeAllDecorations();
    super.dispose();
  }
  updateColors() {
    this.stop();
    if (!this._isColorDecoratorsEnabled) {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !this._languageFeaturesService.colorProvider.has(model)) {
      return;
    }
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!this._timeoutTimer) {
        this._timeoutTimer = new TimeoutTimer();
        this._timeoutTimer.cancelAndSet(() => {
          this._timeoutTimer = null;
          this.beginCompute();
        }, this._debounceInformation.get(model));
      }
    }));
    this.beginCompute();
  }
  beginCompute() {
    return __awaiter$J(this, void 0, void 0, function* () {
      this._computePromise = createCancelablePromise((token) => __awaiter$J(this, void 0, void 0, function* () {
        const model = this._editor.getModel();
        if (!model) {
          return [];
        }
        const sw = new StopWatch(false);
        const colors = yield getColors(this._languageFeaturesService.colorProvider, model, token, this._isDefaultColorDecoratorsEnabled);
        this._debounceInformation.update(model, sw.elapsed());
        return colors;
      }));
      try {
        const colors = yield this._computePromise;
        this.updateDecorations(colors);
        this.updateColorDecorators(colors);
        this._computePromise = null;
      } catch (e) {
        onUnexpectedError(e);
      }
    });
  }
  stop() {
    if (this._timeoutTimer) {
      this._timeoutTimer.cancel();
      this._timeoutTimer = null;
    }
    if (this._computePromise) {
      this._computePromise.cancel();
      this._computePromise = null;
    }
    this._localToDispose.clear();
  }
  updateDecorations(colorDatas) {
    const decorations = colorDatas.map((c) => ({
      range: {
        startLineNumber: c.colorInfo.range.startLineNumber,
        startColumn: c.colorInfo.range.startColumn,
        endLineNumber: c.colorInfo.range.endLineNumber,
        endColumn: c.colorInfo.range.endColumn
      },
      options: ModelDecorationOptions.EMPTY
    }));
    this._editor.changeDecorations((changeAccessor) => {
      this._decorationsIds = changeAccessor.deltaDecorations(this._decorationsIds, decorations);
      this._colorDatas = /* @__PURE__ */ new Map();
      this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));
    });
  }
  updateColorDecorators(colorData) {
    this._colorDecorationClassRefs.clear();
    const decorations = [];
    const limit = this._editor.getOption(
      20
      /* EditorOption.colorDecoratorsLimit */
    );
    for (let i = 0; i < colorData.length && decorations.length < limit; i++) {
      const { red, green, blue, alpha } = colorData[i].colorInfo.color;
      const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      const color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      const ref = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: color
      }));
      decorations.push({
        range: {
          startLineNumber: colorData[i].colorInfo.range.startLineNumber,
          startColumn: colorData[i].colorInfo.range.startColumn,
          endLineNumber: colorData[i].colorInfo.range.endLineNumber,
          endColumn: colorData[i].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: noBreakWhitespace,
            inlineClassName: `${ref.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: true,
            attachedData: ColorDecorationInjectedTextMarker
          }
        }
      });
    }
    const limited = limit < colorData.length ? limit : false;
    this._decoratorLimitReporter.update(colorData.length, limited);
    this._colorDecoratorIds.set(decorations);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds);
    this._decorationsIds = [];
    this._colorDecoratorIds.clear();
    this._colorDecorationClassRefs.clear();
  }
  getColorData(position) {
    const model = this._editor.getModel();
    if (!model) {
      return null;
    }
    const decorations = model.getDecorationsInRange(Range$1.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
    if (decorations.length === 0) {
      return null;
    }
    return this._colorDatas.get(decorations[0].id);
  }
  isColorDecoration(decoration2) {
    return this._colorDecoratorIds.has(decoration2);
  }
};
ColorDetector.ID = "editor.contrib.colorDetector";
ColorDetector.RECOMPUTE_TIME = 1e3;
ColorDetector = __decorate$P([
  __param$P(1, IConfigurationService),
  __param$P(2, ILanguageFeaturesService),
  __param$P(3, ILanguageFeatureDebounceService)
], ColorDetector);
class DecoratorLimitReporter {
  constructor() {
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._computed = 0;
    this._limited = false;
  }
  get computed() {
    return this._computed;
  }
  get limited() {
    return this._limited;
  }
  update(computed, limited) {
    if (computed !== this._computed || limited !== this._limited) {
      this._computed = computed;
      this._limited = limited;
      this._onDidChange.fire();
    }
  }
}
registerEditorContribution(
  ColorDetector.ID,
  ColorDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class ColorPickerModel {
  get color() {
    return this._color;
  }
  set color(color) {
    if (this._color.equals(color)) {
      return;
    }
    this._color = color;
    this._onDidChangeColor.fire(color);
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(colorPresentations) {
    this._colorPresentations = colorPresentations;
    if (this.presentationIndex > colorPresentations.length - 1) {
      this.presentationIndex = 0;
    }
    this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(color, availableColorPresentations, presentationIndex) {
    this.presentationIndex = presentationIndex;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._onDidChangeColor = new Emitter();
    this.onDidChangeColor = this._onDidChangeColor.event;
    this._onDidChangePresentation = new Emitter();
    this.onDidChangePresentation = this._onDidChangePresentation.event;
    this.originalColor = color;
    this._color = color;
    this._colorPresentations = availableColorPresentations;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
    this.flushColor();
    this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(color, originalText) {
    let presentationIndex = -1;
    for (let i = 0; i < this.colorPresentations.length; i++) {
      if (originalText.toLowerCase() === this.colorPresentations[i].label) {
        presentationIndex = i;
        break;
      }
    }
    if (presentationIndex === -1) {
      const originalTextPrefix = originalText.split("(")[0].toLowerCase();
      for (let i = 0; i < this.colorPresentations.length; i++) {
        if (this.colorPresentations[i].label.toLowerCase().startsWith(originalTextPrefix)) {
          presentationIndex = i;
          break;
        }
      }
    }
    if (presentationIndex !== -1 && presentationIndex !== this.presentationIndex) {
      this.presentationIndex = presentationIndex;
      this._onDidChangePresentation.fire(this.presentation);
    }
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
}
const colorPicker = "";
const $$7 = $$8;
class ColorPickerHeader extends Disposable {
  constructor(container, model, themeService, showingStandaloneColorPicker = false) {
    super();
    this.model = model;
    this.showingStandaloneColorPicker = showingStandaloneColorPicker;
    this._closeButton = null;
    this._domNode = $$7(".colorpicker-header");
    append(container, this._domNode);
    this._pickedColorNode = append(this._domNode, $$7(".picked-color"));
    append(this._pickedColorNode, $$7("span.codicon.codicon-color-mode"));
    this._pickedColorPresentation = append(this._pickedColorNode, document.createElement("span"));
    this._pickedColorPresentation.classList.add("picked-color-presentation");
    const tooltip = localize("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this._pickedColorNode.setAttribute("title", tooltip);
    this._originalColorNode = append(this._domNode, $$7(".original-color"));
    this._originalColorNode.style.backgroundColor = Color$1.Format.CSS.format(this.model.originalColor) || "";
    this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color$1.white;
    this._register(themeService.onDidColorThemeChange((theme) => {
      this.backgroundColor = theme.getColor(editorHoverBackground) || Color$1.white;
    }));
    this._register(addDisposableListener(this._pickedColorNode, EventType.CLICK, () => this.model.selectNextColorPresentation()));
    this._register(addDisposableListener(this._originalColorNode, EventType.CLICK, () => {
      this.model.color = this.model.originalColor;
      this.model.flushColor();
    }));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
    this._pickedColorNode.style.backgroundColor = Color$1.Format.CSS.format(model.color) || "";
    this._pickedColorNode.classList.toggle("light", model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());
    this.onDidChangeColor(this.model.color);
    if (this.showingStandaloneColorPicker) {
      this._domNode.classList.add("standalone-colorpicker");
      this._closeButton = this._register(new CloseButton(this._domNode));
    }
  }
  get domNode() {
    return this._domNode;
  }
  get closeButton() {
    return this._closeButton;
  }
  get pickedColorNode() {
    return this._pickedColorNode;
  }
  get originalColorNode() {
    return this._originalColorNode;
  }
  onDidChangeColor(color) {
    this._pickedColorNode.style.backgroundColor = Color$1.Format.CSS.format(color) || "";
    this._pickedColorNode.classList.toggle("light", color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
    this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this._pickedColorPresentation.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
}
class CloseButton extends Disposable {
  constructor(container) {
    super();
    this._onClicked = this._register(new Emitter());
    this.onClicked = this._onClicked.event;
    this._button = document.createElement("div");
    this._button.classList.add("close-button");
    append(container, this._button);
    const innerDiv = document.createElement("div");
    innerDiv.classList.add("close-button-inner-div");
    append(this._button, innerDiv);
    const closeButton = append(innerDiv, $$7(".button" + ThemeIcon.asCSSSelector(registerIcon("color-picker-close", Codicon.close, localize("closeIcon", "Icon to close the color picker")))));
    closeButton.classList.add("close-icon");
    this._button.onclick = () => {
      this._onClicked.fire();
    };
  }
}
class ColorPickerBody extends Disposable {
  constructor(container, model, pixelRatio, isStandaloneColorPicker = false) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._insertButton = null;
    this._domNode = $$7(".colorpicker-body");
    append(container, this._domNode);
    this._saturationBox = new SaturationBox(this._domNode, this.model, this.pixelRatio);
    this._register(this._saturationBox);
    this._register(this._saturationBox.onDidChange(this.onDidSaturationValueChange, this));
    this._register(this._saturationBox.onColorFlushed(this.flushColor, this));
    this._opacityStrip = new OpacityStrip(this._domNode, this.model, isStandaloneColorPicker);
    this._register(this._opacityStrip);
    this._register(this._opacityStrip.onDidChange(this.onDidOpacityChange, this));
    this._register(this._opacityStrip.onColorFlushed(this.flushColor, this));
    this._hueStrip = new HueStrip(this._domNode, this.model, isStandaloneColorPicker);
    this._register(this._hueStrip);
    this._register(this._hueStrip.onDidChange(this.onDidHueChange, this));
    this._register(this._hueStrip.onColorFlushed(this.flushColor, this));
    if (isStandaloneColorPicker) {
      this._insertButton = this._register(new InsertButton(this._domNode));
      this._domNode.classList.add("standalone-colorpicker");
    }
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s, v }) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color$1(new HSVA(hsva.h, s, v, hsva.a));
  }
  onDidOpacityChange(a) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color$1(new HSVA(hsva.h, hsva.s, hsva.v, a));
  }
  onDidHueChange(value) {
    const hsva = this.model.color.hsva;
    const h2 = (1 - value) * 360;
    this.model.color = new Color$1(new HSVA(h2 === 360 ? 0 : h2, hsva.s, hsva.v, hsva.a));
  }
  get domNode() {
    return this._domNode;
  }
  get saturationBox() {
    return this._saturationBox;
  }
  get opacityStrip() {
    return this._opacityStrip;
  }
  get hueStrip() {
    return this._hueStrip;
  }
  get enterButton() {
    return this._insertButton;
  }
  layout() {
    this._saturationBox.layout();
    this._opacityStrip.layout();
    this._hueStrip.layout();
  }
}
class SaturationBox extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._domNode = $$7(".saturation-wrap");
    append(container, this._domNode);
    this._canvas = document.createElement("canvas");
    this._canvas.className = "saturation-box";
    append(this._domNode, this._canvas);
    this.selection = $$7(".saturation-selection");
    append(this._domNode, this.selection);
    this.layout();
    this._register(addDisposableListener(this._domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
    this.monitor = null;
  }
  get domNode() {
    return this._domNode;
  }
  get canvas() {
    return this._canvas;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    this.monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this._domNode);
    if (e.target !== this.selection) {
      this.onDidChangePosition(e.offsetX, e.offsetY);
    }
    this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangePosition(event.pageX - origin.left, event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(document, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      if (this.monitor) {
        this.monitor.stopMonitoring(true);
        this.monitor = null;
      }
    }, true);
  }
  onDidChangePosition(left, top) {
    const s = Math.max(0, Math.min(1, left / this.width));
    const v = Math.max(0, Math.min(1, 1 - top / this.height));
    this.paintSelection(s, v);
    this._onDidChange.fire({ s, v });
  }
  layout() {
    this.width = this._domNode.offsetWidth;
    this.height = this._domNode.offsetHeight;
    this._canvas.width = this.width * this.pixelRatio;
    this._canvas.height = this.height * this.pixelRatio;
    this.paint();
    const hsva = this.model.color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
  paint() {
    const hsva = this.model.color.hsva;
    const saturatedColor = new Color$1(new HSVA(hsva.h, 1, 1, 1));
    const ctx = this._canvas.getContext("2d");
    const whiteGradient = ctx.createLinearGradient(0, 0, this._canvas.width, 0);
    whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
    whiteGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
    whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
    const blackGradient = ctx.createLinearGradient(0, 0, 0, this._canvas.height);
    blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
    blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
    ctx.rect(0, 0, this._canvas.width, this._canvas.height);
    ctx.fillStyle = Color$1.Format.CSS.format(saturatedColor);
    ctx.fill();
    ctx.fillStyle = whiteGradient;
    ctx.fill();
    ctx.fillStyle = blackGradient;
    ctx.fill();
  }
  paintSelection(s, v) {
    this.selection.style.left = `${s * this.width}px`;
    this.selection.style.top = `${this.height - v * this.height}px`;
  }
  onDidChangeColor() {
    if (this.monitor && this.monitor.isMonitoring()) {
      return;
    }
    this.paint();
  }
}
class Strip extends Disposable {
  constructor(container, model, showingStandaloneColorPicker = false) {
    super();
    this.model = model;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    if (showingStandaloneColorPicker) {
      this.domNode = append(container, $$7(".standalone-strip"));
      this.overlay = append(this.domNode, $$7(".standalone-overlay"));
    } else {
      this.domNode = append(container, $$7(".strip"));
      this.overlay = append(this.domNode, $$7(".overlay"));
    }
    this.slider = append(this.domNode, $$7(".slider"));
    this.slider.style.top = `0px`;
    this._register(addDisposableListener(this.domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const value = this.getValue(this.model.color);
    this.updateSliderPosition(value);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    const monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    this.domNode.classList.add("grabbing");
    if (e.target !== this.slider) {
      this.onDidChangeTop(e.offsetY);
    }
    monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangeTop(event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(document, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      monitor.stopMonitoring(true);
      this.domNode.classList.remove("grabbing");
    }, true);
  }
  onDidChangeTop(top) {
    const value = Math.max(0, Math.min(1, 1 - top / this.height));
    this.updateSliderPosition(value);
    this._onDidChange.fire(value);
  }
  updateSliderPosition(value) {
    this.slider.style.top = `${(1 - value) * this.height}px`;
  }
}
class OpacityStrip extends Strip {
  constructor(container, model, showingStandaloneColorPicker = false) {
    super(container, model, showingStandaloneColorPicker);
    this.domNode.classList.add("opacity-strip");
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    const { r, g, b } = color.rgba;
    const opaque = new Color$1(new RGBA(r, g, b, 1));
    const transparent2 = new Color$1(new RGBA(r, g, b, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent2} 100%)`;
  }
  getValue(color) {
    return color.hsva.a;
  }
}
class HueStrip extends Strip {
  constructor(container, model, showingStandaloneColorPicker = false) {
    super(container, model, showingStandaloneColorPicker);
    this.domNode.classList.add("hue-strip");
  }
  getValue(color) {
    return 1 - color.hsva.h / 360;
  }
}
class InsertButton extends Disposable {
  constructor(container) {
    super();
    this._onClicked = this._register(new Emitter());
    this.onClicked = this._onClicked.event;
    this._button = append(container, document.createElement("button"));
    this._button.classList.add("insert-button");
    this._button.textContent = "Insert";
    this._button.onclick = (e) => {
      this._onClicked.fire();
    };
  }
  get button() {
    return this._button;
  }
}
class ColorPickerWidget extends Widget {
  constructor(container, model, pixelRatio, themeService, standaloneColorPicker = false) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._register(PixelRatio.onDidChange(() => this.layout()));
    const element = $$7(".colorpicker-widget");
    container.appendChild(element);
    this.header = this._register(new ColorPickerHeader(element, this.model, themeService, standaloneColorPicker));
    this.body = this._register(new ColorPickerBody(element, this.model, this.pixelRatio, standaloneColorPicker));
  }
  getId() {
    return ColorPickerWidget.ID;
  }
  layout() {
    this.body.layout();
  }
}
ColorPickerWidget.ID = "editor.contrib.colorPickerWidget";
var __decorate$O = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$O = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$I = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ColorHover {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
    this.forceShowAtRange = true;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
}
let ColorHoverParticipant = class ColorHoverParticipant2 {
  constructor(_editor, _themeService) {
    this._editor = _editor;
    this._themeService = _themeService;
    this.hoverOrdinal = 2;
  }
  computeSync(_anchor, _lineDecorations) {
    return [];
  }
  computeAsync(anchor, lineDecorations, token) {
    return AsyncIterableObject.fromPromise(this._computeAsync(anchor, lineDecorations, token));
  }
  _computeAsync(_anchor, lineDecorations, _token) {
    return __awaiter$I(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return [];
      }
      const colorDetector = ColorDetector.get(this._editor);
      if (!colorDetector) {
        return [];
      }
      for (const d of lineDecorations) {
        if (!colorDetector.isColorDecoration(d)) {
          continue;
        }
        const colorData = colorDetector.getColorData(d.range.getStartPosition());
        if (colorData) {
          const colorHover = yield _createColorHover(this, this._editor.getModel(), colorData.colorInfo, colorData.provider);
          return [colorHover];
        }
      }
      return [];
    });
  }
  renderHoverParts(context, hoverParts) {
    return renderHoverParts(this, this._editor, this._themeService, hoverParts, context);
  }
};
ColorHoverParticipant = __decorate$O([
  __param$O(1, IThemeService)
], ColorHoverParticipant);
class StandaloneColorPickerHover {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
  }
}
let StandaloneColorPickerParticipant = class StandaloneColorPickerParticipant2 {
  constructor(_editor, _themeService) {
    this._editor = _editor;
    this._themeService = _themeService;
    this.hoverOrdinal = 2;
    this._color = null;
  }
  createColorHover(defaultColorInfo, defaultColorProvider, colorProviderRegistry) {
    return __awaiter$I(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return null;
      }
      const colorDetector = ColorDetector.get(this._editor);
      if (!colorDetector) {
        return null;
      }
      const colors = yield getColors(colorProviderRegistry, this._editor.getModel(), CancellationToken.None);
      let foundColorInfo = null;
      let foundColorProvider = null;
      for (const colorData of colors) {
        const colorInfo2 = colorData.colorInfo;
        if (Range$1.containsRange(colorInfo2.range, defaultColorInfo.range)) {
          foundColorInfo = colorInfo2;
          foundColorProvider = colorData.provider;
        }
      }
      const colorInfo = foundColorInfo !== null && foundColorInfo !== void 0 ? foundColorInfo : defaultColorInfo;
      const colorProvider2 = foundColorProvider !== null && foundColorProvider !== void 0 ? foundColorProvider : defaultColorProvider;
      const foundInEditor = !!foundColorInfo;
      return { colorHover: yield _createColorHover(this, this._editor.getModel(), colorInfo, colorProvider2), foundInEditor };
    });
  }
  updateEditorModel(colorHoverData) {
    return __awaiter$I(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return;
      }
      const colorPickerModel = colorHoverData.model;
      let range = new Range$1(colorHoverData.range.startLineNumber, colorHoverData.range.startColumn, colorHoverData.range.endLineNumber, colorHoverData.range.endColumn);
      if (this._color) {
        yield _updateColorPresentations(this._editor.getModel(), colorPickerModel, this._color, range, colorHoverData);
        range = _updateEditorModel(this._editor, range, colorPickerModel);
      }
    });
  }
  renderHoverParts(context, hoverParts) {
    return renderHoverParts(this, this._editor, this._themeService, hoverParts, context);
  }
  set color(color) {
    this._color = color;
  }
  get color() {
    return this._color;
  }
};
StandaloneColorPickerParticipant = __decorate$O([
  __param$O(1, IThemeService)
], StandaloneColorPickerParticipant);
function _createColorHover(participant, editorModel, colorInfo, provider) {
  return __awaiter$I(this, void 0, void 0, function* () {
    const originalText = editorModel.getValueInRange(colorInfo.range);
    const { red, green, blue, alpha } = colorInfo.color;
    const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
    const color = new Color$1(rgba);
    const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
    const model = new ColorPickerModel(color, [], 0);
    model.colorPresentations = colorPresentations || [];
    model.guessColorPresentation(color, originalText);
    if (participant instanceof ColorHoverParticipant) {
      return new ColorHover(participant, Range$1.lift(colorInfo.range), model, provider);
    } else {
      return new StandaloneColorPickerHover(participant, Range$1.lift(colorInfo.range), model, provider);
    }
  });
}
function renderHoverParts(participant, editor2, themeService, hoverParts, context) {
  if (hoverParts.length === 0 || !editor2.hasModel()) {
    return Disposable.None;
  }
  if (context.setMinimumDimensions) {
    const minimumHeight = editor2.getOption(
      65
      /* EditorOption.lineHeight */
    ) + 8;
    context.setMinimumDimensions(new Dimension(302, minimumHeight));
  }
  const disposables = new DisposableStore();
  const colorHover = hoverParts[0];
  const editorModel = editor2.getModel();
  const model = colorHover.model;
  const widget = disposables.add(new ColorPickerWidget(context.fragment, model, editor2.getOption(
    140
    /* EditorOption.pixelRatio */
  ), themeService, participant instanceof StandaloneColorPickerParticipant));
  context.setColorPicker(widget);
  let editorUpdatedByColorPicker = false;
  let range = new Range$1(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
  if (participant instanceof StandaloneColorPickerParticipant) {
    const color = hoverParts[0].model.color;
    participant.color = color;
    _updateColorPresentations(editorModel, model, color, range, colorHover);
    disposables.add(model.onColorFlushed((color2) => {
      participant.color = color2;
    }));
  } else {
    disposables.add(model.onColorFlushed((color) => __awaiter$I(this, void 0, void 0, function* () {
      yield _updateColorPresentations(editorModel, model, color, range, colorHover);
      editorUpdatedByColorPicker = true;
      range = _updateEditorModel(editor2, range, model, context);
    })));
  }
  disposables.add(model.onDidChangeColor((color) => {
    _updateColorPresentations(editorModel, model, color, range, colorHover);
  }));
  disposables.add(editor2.onDidChangeModelContent((e) => {
    if (editorUpdatedByColorPicker) {
      editorUpdatedByColorPicker = false;
    } else {
      context.hide();
      editor2.focus();
    }
  }));
  return disposables;
}
function _updateEditorModel(editor2, range, model, context) {
  let textEdits;
  let newRange;
  if (model.presentation.textEdit) {
    textEdits = [model.presentation.textEdit];
    newRange = new Range$1(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);
    const trackedRange = editor2.getModel()._setTrackedRange(
      null,
      newRange,
      3
      /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
    );
    editor2.pushUndoStop();
    editor2.executeEdits("colorpicker", textEdits);
    newRange = editor2.getModel()._getTrackedRange(trackedRange) || newRange;
  } else {
    textEdits = [{ range, text: model.presentation.label, forceMoveMarkers: false }];
    newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);
    editor2.pushUndoStop();
    editor2.executeEdits("colorpicker", textEdits);
  }
  if (model.presentation.additionalTextEdits) {
    textEdits = [...model.presentation.additionalTextEdits];
    editor2.executeEdits("colorpicker", textEdits);
    if (context) {
      context.hide();
    }
  }
  editor2.pushUndoStop();
  return newRange;
}
function _updateColorPresentations(editorModel, colorPickerModel, color, range, colorHover) {
  return __awaiter$I(this, void 0, void 0, function* () {
    const colorPresentations = yield getColorPresentations(editorModel, {
      range,
      color: {
        red: color.rgba.r / 255,
        green: color.rgba.g / 255,
        blue: color.rgba.b / 255,
        alpha: color.rgba.a
      }
    }, colorHover.provider, CancellationToken.None);
    colorPickerModel.colorPresentations = colorPresentations || [];
  });
}
const goToDefinitionAtPosition = "";
function hasModifier(e, modifier) {
  return !!e[modifier];
}
class ClickLinkMouseEvent {
  constructor(source, opts) {
    this.target = source.target;
    this.isLeftClick = source.event.leftButton;
    this.isMiddleClick = source.event.middleButton;
    this.isRightClick = source.event.rightButton;
    this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
    this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
    this.isNoneOrSingleMouseDown = source.event.detail <= 1;
  }
}
class ClickLinkKeyboardEvent {
  constructor(source, opts) {
    this.keyCodeIsTriggerKey = source.keyCode === opts.triggerKey;
    this.keyCodeIsSideBySideKey = source.keyCode === opts.triggerSideBySideKey;
    this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
  }
}
class ClickLinkOptions {
  constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {
    this.triggerKey = triggerKey;
    this.triggerModifier = triggerModifier;
    this.triggerSideBySideKey = triggerSideBySideKey;
    this.triggerSideBySideModifier = triggerSideBySideModifier;
  }
  equals(other) {
    return this.triggerKey === other.triggerKey && this.triggerModifier === other.triggerModifier && this.triggerSideBySideKey === other.triggerSideBySideKey && this.triggerSideBySideModifier === other.triggerSideBySideModifier;
  }
}
function createOptions(multiCursorModifier2) {
  if (multiCursorModifier2 === "altKey") {
    if (isMacintosh) {
      return new ClickLinkOptions(57, "metaKey", 6, "altKey");
    }
    return new ClickLinkOptions(5, "ctrlKey", 6, "altKey");
  }
  if (isMacintosh) {
    return new ClickLinkOptions(6, "altKey", 57, "metaKey");
  }
  return new ClickLinkOptions(6, "altKey", 5, "ctrlKey");
}
class ClickLinkGesture extends Disposable {
  constructor(editor2, alwaysFireOnMouseUp) {
    super();
    this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter());
    this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
    this._onExecute = this._register(new Emitter());
    this.onExecute = this._onExecute.event;
    this._onCancel = this._register(new Emitter());
    this.onCancel = this._onCancel.event;
    this._editor = editor2;
    this._alwaysFireExecuteOnMouseUp = alwaysFireOnMouseUp;
    this._opts = createOptions(this._editor.getOption(
      76
      /* EditorOption.multiCursorModifier */
    ));
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._lineNumberOnMouseDown = 0;
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        76
        /* EditorOption.multiCursorModifier */
      )) {
        const newOpts = createOptions(this._editor.getOption(
          76
          /* EditorOption.multiCursorModifier */
        ));
        if (this._opts.equals(newOpts)) {
          return;
        }
        this._opts = newOpts;
        this._lastMouseMoveEvent = null;
        this._hasTriggerKeyOnMouseDown = false;
        this._lineNumberOnMouseDown = 0;
        this._onCancel.fire();
      }
    }));
    this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onMouseDrag(() => this._resetHandler()));
    this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));
    this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));
    this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));
    this._register(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || e.scrollLeftChanged) {
        this._resetHandler();
      }
    }));
  }
  _onDidChangeCursorSelection(e) {
    if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
      this._resetHandler();
    }
  }
  _onEditorMouseMove(mouseEvent) {
    this._lastMouseMoveEvent = mouseEvent;
    this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
  }
  _onEditorMouseDown(mouseEvent) {
    this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
    this._lineNumberOnMouseDown = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
  }
  _onEditorMouseUp(mouseEvent) {
    const currentLineNumber = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
    if (this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber || this._alwaysFireExecuteOnMouseUp) {
      this._onExecute.fire(mouseEvent);
    }
  }
  _onEditorKeyDown(e) {
    if (this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier)) {
      this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);
    } else if (e.hasTriggerModifier) {
      this._onCancel.fire();
    }
  }
  _onEditorKeyUp(e) {
    if (e.keyCodeIsTriggerKey) {
      this._onCancel.fire();
    }
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._onCancel.fire();
  }
}
var __awaiter$H = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class OneReference {
  constructor(isProviderFirst, parent, link, _rangeCallback) {
    this.isProviderFirst = isProviderFirst;
    this.parent = parent;
    this.link = link;
    this._rangeCallback = _rangeCallback;
    this.id = defaultGenerator.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    var _a3, _b3;
    return (_b3 = (_a3 = this._range) !== null && _a3 !== void 0 ? _a3 : this.link.targetSelectionRange) !== null && _b3 !== void 0 ? _b3 : this.link.range;
  }
  set range(value) {
    this._range = value;
    this._rangeCallback(this);
  }
  get ariaMessage() {
    var _a3;
    const preview = (_a3 = this.parent.getPreview(this)) === null || _a3 === void 0 ? void 0 : _a3.preview(this.range);
    if (!preview) {
      return localize("aria.oneReference", "in {0} on line {1} at column {2}", basename(this.uri), this.range.startLineNumber, this.range.startColumn);
    } else {
      return localize({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "{0} in {1} on line {2} at column {3}", preview.value, basename(this.uri), this.range.startLineNumber, this.range.startColumn);
    }
  }
}
class FilePreview {
  constructor(_modelReference) {
    this._modelReference = _modelReference;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(range, n2 = 8) {
    const model = this._modelReference.object.textEditorModel;
    if (!model) {
      return void 0;
    }
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    const word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n2 });
    const beforeRange = new Range$1(startLineNumber, word.startColumn, startLineNumber, startColumn);
    const afterRange = new Range$1(
      endLineNumber,
      endColumn,
      endLineNumber,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    const before = model.getValueInRange(beforeRange).replace(/^\s+/, "");
    const inside = model.getValueInRange(range);
    const after = model.getValueInRange(afterRange).replace(/\s+$/, "");
    return {
      value: before + inside + after,
      highlight: { start: before.length, end: before.length + inside.length }
    };
  }
}
class FileReferences {
  constructor(parent, uri) {
    this.parent = parent;
    this.uri = uri;
    this.children = [];
    this._previews = new ResourceMap();
  }
  dispose() {
    dispose(this._previews.values());
    this._previews.clear();
  }
  getPreview(child) {
    return this._previews.get(child.uri);
  }
  get ariaMessage() {
    const len = this.children.length;
    if (len === 1) {
      return localize("aria.fileReferences.1", "1 symbol in {0}, full path {1}", basename(this.uri), this.uri.fsPath);
    } else {
      return localize("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", len, basename(this.uri), this.uri.fsPath);
    }
  }
  resolve(textModelResolverService) {
    return __awaiter$H(this, void 0, void 0, function* () {
      if (this._previews.size !== 0) {
        return this;
      }
      for (const child of this.children) {
        if (this._previews.has(child.uri)) {
          continue;
        }
        try {
          const ref = yield textModelResolverService.createModelReference(child.uri);
          this._previews.set(child.uri, new FilePreview(ref));
        } catch (err) {
          onUnexpectedError(err);
        }
      }
      return this;
    });
  }
}
class ReferencesModel {
  constructor(links2, title) {
    this.groups = [];
    this.references = [];
    this._onDidChangeReferenceRange = new Emitter();
    this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
    this._links = links2;
    this._title = title;
    const [providersFirst] = links2;
    links2.sort(ReferencesModel._compareReferences);
    let current;
    for (const link of links2) {
      if (!current || !extUri.isEqual(current.uri, link.uri, true)) {
        current = new FileReferences(this, link.uri);
        this.groups.push(current);
      }
      if (current.children.length === 0 || ReferencesModel._compareReferences(link, current.children[current.children.length - 1]) !== 0) {
        const oneRef = new OneReference(providersFirst === link, current, link, (ref) => this._onDidChangeReferenceRange.fire(ref));
        this.references.push(oneRef);
        current.children.push(oneRef);
      }
    }
  }
  dispose() {
    dispose(this.groups);
    this._onDidChangeReferenceRange.dispose();
    this.groups.length = 0;
  }
  clone() {
    return new ReferencesModel(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    if (this.isEmpty) {
      return localize("aria.result.0", "No results found");
    } else if (this.references.length === 1) {
      return localize("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath);
    } else if (this.groups.length === 1) {
      return localize("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
    } else {
      return localize("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
    }
  }
  nextOrPreviousReference(reference2, next) {
    const { parent } = reference2;
    let idx = parent.children.indexOf(reference2);
    const childCount = parent.children.length;
    const groupCount = parent.parent.groups.length;
    if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
      if (next) {
        idx = (idx + 1) % childCount;
      } else {
        idx = (idx + childCount - 1) % childCount;
      }
      return parent.children[idx];
    }
    idx = parent.parent.groups.indexOf(parent);
    if (next) {
      idx = (idx + 1) % groupCount;
      return parent.parent.groups[idx].children[0];
    } else {
      idx = (idx + groupCount - 1) % groupCount;
      return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];
    }
  }
  nearestReference(resource, position) {
    const nearest = this.references.map((ref, idx) => {
      return {
        idx,
        prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
        offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
      };
    }).sort((a, b) => {
      if (a.prefixLen > b.prefixLen) {
        return -1;
      } else if (a.prefixLen < b.prefixLen) {
        return 1;
      } else if (a.offsetDist < b.offsetDist) {
        return -1;
      } else if (a.offsetDist > b.offsetDist) {
        return 1;
      } else {
        return 0;
      }
    })[0];
    if (nearest) {
      return this.references[nearest.idx];
    }
    return void 0;
  }
  referenceAt(resource, position) {
    for (const ref of this.references) {
      if (ref.uri.toString() === resource.toString()) {
        if (Range$1.containsPosition(ref.range, position)) {
          return ref;
        }
      }
    }
    return void 0;
  }
  firstReference() {
    for (const ref of this.references) {
      if (ref.isProviderFirst) {
        return ref;
      }
    }
    return this.references[0];
  }
  static _compareReferences(a, b) {
    return extUri.compare(a.uri, b.uri) || Range$1.compareRangesUsingStarts(a.range, b.range);
  }
}
const referencesWidget = "";
var __decorate$N = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$N = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let DataSource = class DataSource2 {
  constructor(_resolverService) {
    this._resolverService = _resolverService;
  }
  hasChildren(element) {
    if (element instanceof ReferencesModel) {
      return true;
    }
    if (element instanceof FileReferences) {
      return true;
    }
    return false;
  }
  getChildren(element) {
    if (element instanceof ReferencesModel) {
      return element.groups;
    }
    if (element instanceof FileReferences) {
      return element.resolve(this._resolverService).then((val) => {
        return val.children;
      });
    }
    throw new Error("bad tree");
  }
};
DataSource = __decorate$N([
  __param$N(0, ITextModelService)
], DataSource);
class Delegate {
  getHeight() {
    return 23;
  }
  getTemplateId(element) {
    if (element instanceof FileReferences) {
      return FileReferencesRenderer.id;
    } else {
      return OneReferenceRenderer.id;
    }
  }
}
let StringRepresentationProvider = class StringRepresentationProvider2 {
  constructor(_keybindingService) {
    this._keybindingService = _keybindingService;
  }
  getKeyboardNavigationLabel(element) {
    var _a3;
    if (element instanceof OneReference) {
      const parts = (_a3 = element.parent.getPreview(element)) === null || _a3 === void 0 ? void 0 : _a3.preview(element.range);
      if (parts) {
        return parts.value;
      }
    }
    return basename(element.uri);
  }
  mightProducePrintableCharacter(event) {
    return this._keybindingService.mightProducePrintableCharacter(event);
  }
};
StringRepresentationProvider = __decorate$N([
  __param$N(0, IKeybindingService)
], StringRepresentationProvider);
class IdentityProvider {
  getId(element) {
    return element instanceof OneReference ? element.id : element.uri;
  }
}
let FileReferencesTemplate = class FileReferencesTemplate2 extends Disposable {
  constructor(container, _labelService) {
    super();
    this._labelService = _labelService;
    const parent = document.createElement("div");
    parent.classList.add("reference-file");
    this.file = this._register(new IconLabel(parent, { supportHighlights: true }));
    this.badge = new CountBadge(append(parent, $$8(".count")), {}, defaultCountBadgeStyles);
    container.appendChild(parent);
  }
  set(element, matches) {
    const parent = dirname(element.uri);
    this.file.setLabel(this._labelService.getUriBasenameLabel(element.uri), this._labelService.getUriLabel(parent, { relative: true }), { title: this._labelService.getUriLabel(element.uri), matches });
    const len = element.children.length;
    this.badge.setCount(len);
    if (len > 1) {
      this.badge.setTitleFormat(localize("referencesCount", "{0} references", len));
    } else {
      this.badge.setTitleFormat(localize("referenceCount", "{0} reference", len));
    }
  }
};
FileReferencesTemplate = __decorate$N([
  __param$N(1, ILabelService)
], FileReferencesTemplate);
let FileReferencesRenderer = class FileReferencesRenderer2 {
  constructor(_instantiationService) {
    this._instantiationService = _instantiationService;
    this.templateId = FileReferencesRenderer2.id;
  }
  renderTemplate(container) {
    return this._instantiationService.createInstance(FileReferencesTemplate, container);
  }
  renderElement(node, index2, template) {
    template.set(node.element, createMatches(node.filterData));
  }
  disposeTemplate(templateData) {
    templateData.dispose();
  }
};
FileReferencesRenderer.id = "FileReferencesRenderer";
FileReferencesRenderer = __decorate$N([
  __param$N(0, IInstantiationService)
], FileReferencesRenderer);
class OneReferenceTemplate {
  constructor(container) {
    this.label = new HighlightedLabel(container);
  }
  set(element, score) {
    var _a3;
    const preview = (_a3 = element.parent.getPreview(element)) === null || _a3 === void 0 ? void 0 : _a3.preview(element.range);
    if (!preview || !preview.value) {
      this.label.set(`${basename(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
    } else {
      const { value, highlight } = preview;
      if (score && !FuzzyScore.isDefault(score)) {
        this.label.element.classList.toggle("referenceMatch", false);
        this.label.set(value, createMatches(score));
      } else {
        this.label.element.classList.toggle("referenceMatch", true);
        this.label.set(value, [highlight]);
      }
    }
  }
}
class OneReferenceRenderer {
  constructor() {
    this.templateId = OneReferenceRenderer.id;
  }
  renderTemplate(container) {
    return new OneReferenceTemplate(container);
  }
  renderElement(node, index2, templateData) {
    templateData.set(node.element, node.filterData);
  }
  disposeTemplate() {
  }
}
OneReferenceRenderer.id = "OneReferenceRenderer";
class AccessibilityProvider {
  getWidgetAriaLabel() {
    return localize("treeAriaLabel", "References");
  }
  getAriaLabel(element) {
    return element.ariaMessage;
  }
}
var __decorate$M = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$M = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$G = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DecorationsManager {
  constructor(_editor, _model) {
    this._editor = _editor;
    this._model = _model;
    this._decorations = /* @__PURE__ */ new Map();
    this._decorationIgnoreSet = /* @__PURE__ */ new Set();
    this._callOnDispose = new DisposableStore();
    this._callOnModelChange = new DisposableStore();
    this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));
    this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose();
    this._callOnDispose.dispose();
    this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (const ref of this._model.references) {
      if (ref.uri.toString() === model.uri.toString()) {
        this._addDecorations(ref.parent);
        return;
      }
    }
  }
  _addDecorations(reference2) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const newDecorations = [];
    const newDecorationsActualIndex = [];
    for (let i = 0, len = reference2.children.length; i < len; i++) {
      const oneReference = reference2.children[i];
      if (this._decorationIgnoreSet.has(oneReference.id)) {
        continue;
      }
      if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) {
        continue;
      }
      newDecorations.push({
        range: oneReference.range,
        options: DecorationsManager.DecorationOptions
      });
      newDecorationsActualIndex.push(i);
    }
    this._editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations([], newDecorations);
      for (let i = 0; i < decorations.length; i++) {
        this._decorations.set(decorations[i], reference2.children[newDecorationsActualIndex[i]]);
      }
    });
  }
  _onDecorationChanged() {
    const toRemove = [];
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (const [decorationId, reference2] of this._decorations) {
      const newRange = model.getDecorationRange(decorationId);
      if (!newRange) {
        continue;
      }
      let ignore = false;
      if (Range$1.equalsRange(newRange, reference2.range)) {
        continue;
      }
      if (Range$1.spansMultipleLines(newRange)) {
        ignore = true;
      } else {
        const lineLength = reference2.range.endColumn - reference2.range.startColumn;
        const newLineLength = newRange.endColumn - newRange.startColumn;
        if (lineLength !== newLineLength) {
          ignore = true;
        }
      }
      if (ignore) {
        this._decorationIgnoreSet.add(reference2.id);
        toRemove.push(decorationId);
      } else {
        reference2.range = newRange;
      }
    }
    for (let i = 0, len = toRemove.length; i < len; i++) {
      this._decorations.delete(toRemove[i]);
    }
    this._editor.removeDecorations(toRemove);
  }
  removeDecorations() {
    this._editor.removeDecorations([...this._decorations.keys()]);
    this._decorations.clear();
  }
}
DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
class LayoutData {
  constructor() {
    this.ratio = 0.7;
    this.heightInLines = 18;
  }
  static fromJSON(raw) {
    let ratio;
    let heightInLines;
    try {
      const data = JSON.parse(raw);
      ratio = data.ratio;
      heightInLines = data.heightInLines;
    } catch (_a3) {
    }
    return {
      ratio: ratio || 0.7,
      heightInLines: heightInLines || 18
    };
  }
}
class ReferencesTree extends WorkbenchAsyncDataTree {
}
let ReferenceWidget = class ReferenceWidget2 extends PeekViewWidget {
  constructor(editor2, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _undoRedoService, _keybindingService, _languageService, _languageConfigurationService) {
    super(editor2, { showFrame: false, showArrow: true, isResizeable: true, isAccessible: true, supportOnTitleClick: true }, _instantiationService);
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this.layoutData = layoutData;
    this._textModelResolverService = _textModelResolverService;
    this._instantiationService = _instantiationService;
    this._peekViewService = _peekViewService;
    this._uriLabel = _uriLabel;
    this._undoRedoService = _undoRedoService;
    this._keybindingService = _keybindingService;
    this._languageService = _languageService;
    this._languageConfigurationService = _languageConfigurationService;
    this._disposeOnNewModel = new DisposableStore();
    this._callOnDispose = new DisposableStore();
    this._onDidSelectReference = new Emitter();
    this.onDidSelectReference = this._onDidSelectReference.event;
    this._dim = new Dimension(0, 0);
    this._applyTheme(themeService.getColorTheme());
    this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this._peekViewService.addExclusiveWidget(editor2, this);
    this.create();
  }
  dispose() {
    this.setModel(void 0);
    this._callOnDispose.dispose();
    this._disposeOnNewModel.dispose();
    dispose(this._preview);
    dispose(this._previewNotAvailableMessage);
    dispose(this._tree);
    dispose(this._previewModelReference);
    this._splitView.dispose();
    super.dispose();
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color$1.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color$1.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  show(where) {
    super.show(where, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    if (this._preview && this._preview.getModel()) {
      this._onDidSelectReference.fire({
        element: this._getFocusedReference(),
        kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
        source: "title"
      });
    }
  }
  _fillBody(containerElement) {
    this.setCssClass("reference-zone-widget");
    this._messageContainer = append(containerElement, $$8("div.messages"));
    hide(this._messageContainer);
    this._splitView = new SplitView(containerElement, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    });
    this._previewContainer = append(containerElement, $$8("div.preview.inline"));
    const options = {
      scrollBeyondLastLine: false,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false,
        alwaysConsumeMouseWheel: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: {
        enabled: false
      }
    };
    this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, options, {}, this.editor);
    hide(this._previewContainer);
    this._previewNotAvailableMessage = new TextModel(localize("missingPreviewMessage", "no preview available"), PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService);
    this._treeContainer = append(containerElement, $$8("div.ref-tree.inline"));
    const treeOptions = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new AccessibilityProvider(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(StringRepresentationProvider),
      identityProvider: new IdentityProvider(),
      openOnSingleClick: true,
      selectionNavigation: true,
      overrideStyles: {
        listBackground: peekViewResultsBackground
      }
    };
    if (this._defaultTreeKeyboardSupport) {
      this._callOnDispose.add(addStandardDisposableListener(this._treeContainer, "keydown", (e) => {
        if (e.equals(
          9
          /* KeyCode.Escape */
        )) {
          this._keybindingService.dispatchEvent(e, e.target);
          e.stopPropagation();
        }
      }, true));
    }
    this._tree = this._instantiationService.createInstance(ReferencesTree, "ReferencesWidget", this._treeContainer, new Delegate(), [
      this._instantiationService.createInstance(FileReferencesRenderer),
      this._instantiationService.createInstance(OneReferenceRenderer)
    ], this._instantiationService.createInstance(DataSource), treeOptions);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._preview.layout({ height: this._dim.height, width });
      }
    }, Sizing.Distribute);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._treeContainer.style.height = `${this._dim.height}px`;
        this._treeContainer.style.width = `${width}px`;
        this._tree.layout(this._dim.height, width);
      }
    }, Sizing.Distribute);
    this._disposables.add(this._splitView.onDidSashChange(() => {
      if (this._dim.width) {
        this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;
      }
    }, void 0));
    const onEvent = (element, kind) => {
      if (element instanceof OneReference) {
        if (kind === "show") {
          this._revealReference(element, false);
        }
        this._onDidSelectReference.fire({ element, kind, source: "tree" });
      }
    };
    this._tree.onDidOpen((e) => {
      if (e.sideBySide) {
        onEvent(e.element, "side");
      } else if (e.editorOptions.pinned) {
        onEvent(e.element, "goto");
      } else {
        onEvent(e.element, "show");
      }
    });
    hide(this._treeContainer);
  }
  _onWidth(width) {
    if (this._dim) {
      this._doLayoutBody(this._dim.height, width);
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._dim = new Dimension(widthInPixel, heightInPixel);
    this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;
    this._splitView.layout(widthInPixel);
    this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);
  }
  setSelection(selection) {
    return this._revealReference(selection, true).then(() => {
      if (!this._model) {
        return;
      }
      this._tree.setSelection([selection]);
      this._tree.setFocus([selection]);
    });
  }
  setModel(newModel) {
    this._disposeOnNewModel.clear();
    this._model = newModel;
    if (this._model) {
      return this._onNewModel();
    }
    return Promise.resolve();
  }
  _onNewModel() {
    if (!this._model) {
      return Promise.resolve(void 0);
    }
    if (this._model.isEmpty) {
      this.setTitle("");
      this._messageContainer.innerText = localize("noResults", "No results");
      show(this._messageContainer);
      return Promise.resolve(void 0);
    }
    hide(this._messageContainer);
    this._decorationsManager = new DecorationsManager(this._preview, this._model);
    this._disposeOnNewModel.add(this._decorationsManager);
    this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((reference2) => this._tree.rerender(reference2)));
    this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event, target } = e;
      if (event.detail !== 2) {
        return;
      }
      const element = this._getFocusedReference();
      if (!element) {
        return;
      }
      this._onDidSelectReference.fire({
        element: { uri: element.uri, range: target.range },
        kind: event.ctrlKey || event.metaKey || event.altKey ? "side" : "open",
        source: "editor"
      });
    }));
    this.container.classList.add("results-loaded");
    show(this._treeContainer);
    show(this._previewContainer);
    this._splitView.layout(this._dim.width);
    this.focusOnReferenceTree();
    return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);
  }
  _getFocusedReference() {
    const [element] = this._tree.getFocus();
    if (element instanceof OneReference) {
      return element;
    } else if (element instanceof FileReferences) {
      if (element.children.length > 0) {
        return element.children[0];
      }
    }
    return void 0;
  }
  revealReference(reference2) {
    return __awaiter$G(this, void 0, void 0, function* () {
      yield this._revealReference(reference2, false);
      this._onDidSelectReference.fire({ element: reference2, kind: "goto", source: "tree" });
    });
  }
  _revealReference(reference2, revealParent) {
    return __awaiter$G(this, void 0, void 0, function* () {
      if (this._revealedReference === reference2) {
        return;
      }
      this._revealedReference = reference2;
      if (reference2.uri.scheme !== Schemas.inMemory) {
        this.setTitle(basenameOrAuthority(reference2.uri), this._uriLabel.getUriLabel(dirname(reference2.uri)));
      } else {
        this.setTitle(localize("peekView.alternateTitle", "References"));
      }
      const promise = this._textModelResolverService.createModelReference(reference2.uri);
      if (this._tree.getInput() === reference2.parent) {
        this._tree.reveal(reference2);
      } else {
        if (revealParent) {
          this._tree.reveal(reference2.parent);
        }
        yield this._tree.expand(reference2.parent);
        this._tree.reveal(reference2);
      }
      const ref = yield promise;
      if (!this._model) {
        ref.dispose();
        return;
      }
      dispose(this._previewModelReference);
      const model = ref.object;
      if (model) {
        const scrollType = this._preview.getModel() === model.textEditorModel ? 0 : 1;
        const sel = Range$1.lift(reference2.range).collapseToStart();
        this._previewModelReference = ref;
        this._preview.setModel(model.textEditorModel);
        this._preview.setSelection(sel);
        this._preview.revealRangeInCenter(sel, scrollType);
      } else {
        this._preview.setModel(this._previewNotAvailableMessage);
        ref.dispose();
      }
    });
  }
};
ReferenceWidget = __decorate$M([
  __param$M(3, IThemeService),
  __param$M(4, ITextModelService),
  __param$M(5, IInstantiationService),
  __param$M(6, IPeekViewService),
  __param$M(7, ILabelService),
  __param$M(8, IUndoRedoService),
  __param$M(9, IKeybindingService),
  __param$M(10, ILanguageService),
  __param$M(11, ILanguageConfigurationService)
], ReferenceWidget);
var __decorate$L = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$L = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$F = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ctxReferenceSearchVisible = new RawContextKey("referenceSearchVisible", false, localize("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
let ReferencesController = class ReferencesController2 {
  static get(editor2) {
    return editor2.getContribution(ReferencesController2.ID);
  }
  constructor(_defaultTreeKeyboardSupport, _editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this._editor = _editor;
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._instantiationService = _instantiationService;
    this._storageService = _storageService;
    this._configurationService = _configurationService;
    this._disposables = new DisposableStore();
    this._requestIdPool = 0;
    this._ignoreModelChangeEvent = false;
    this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
  }
  dispose() {
    var _a3, _b3;
    this._referenceSearchVisible.reset();
    this._disposables.dispose();
    (_a3 = this._widget) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    (_b3 = this._model) === null || _b3 === void 0 ? void 0 : _b3.dispose();
    this._widget = void 0;
    this._model = void 0;
  }
  toggleWidget(range, modelPromise, peekMode) {
    let widgetPosition;
    if (this._widget) {
      widgetPosition = this._widget.position;
    }
    this.closeWidget();
    if (!!widgetPosition && range.containsPosition(widgetPosition)) {
      return;
    }
    this._peekMode = peekMode;
    this._referenceSearchVisible.set(true);
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    }));
    this._disposables.add(this._editor.onDidChangeModel(() => {
      if (!this._ignoreModelChangeEvent) {
        this.closeWidget();
      }
    }));
    const storageKey = "peekViewLayout";
    const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0, "{}"));
    this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
    this._widget.setTitle(localize("labelLoading", "Loading..."));
    this._widget.show(range);
    this._disposables.add(this._widget.onDidClose(() => {
      modelPromise.cancel();
      if (this._widget) {
        this._storageService.store(
          storageKey,
          JSON.stringify(this._widget.layoutData),
          0,
          1
          /* StorageTarget.MACHINE */
        );
        this._widget = void 0;
      }
      this.closeWidget();
    }));
    this._disposables.add(this._widget.onDidSelectReference((event) => {
      const { element, kind } = event;
      if (!element) {
        return;
      }
      switch (kind) {
        case "open":
          if (event.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) {
            this.openReference(element, false, false);
          }
          break;
        case "side":
          this.openReference(element, true, false);
          break;
        case "goto":
          if (peekMode) {
            this._gotoReference(element, true);
          } else {
            this.openReference(element, false, true);
          }
          break;
      }
    }));
    const requestId = ++this._requestIdPool;
    modelPromise.then((model) => {
      var _a3;
      if (requestId !== this._requestIdPool || !this._widget) {
        model.dispose();
        return void 0;
      }
      (_a3 = this._model) === null || _a3 === void 0 ? void 0 : _a3.dispose();
      this._model = model;
      return this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          if (!this._model.isEmpty) {
            this._widget.setMetaTitle(localize("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          } else {
            this._widget.setMetaTitle("");
          }
          const uri = this._editor.getModel().uri;
          const pos = new Position$1(range.startLineNumber, range.startColumn);
          const selection = this._model.nearestReference(uri, pos);
          if (selection) {
            return this._widget.setSelection(selection).then(() => {
              if (this._widget && this._editor.getOption(
                85
                /* EditorOption.peekWidgetDefaultFocus */
              ) === "editor") {
                this._widget.focusOnPreviewEditor();
              }
            });
          }
        }
        return void 0;
      });
    }, (error) => {
      this._notificationService.error(error);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    if (!this._widget) {
      return;
    }
    if (this._widget.isPreviewEditorFocused()) {
      this._widget.focusOnReferenceTree();
    } else {
      this._widget.focusOnPreviewEditor();
    }
  }
  goToNextOrPreviousReference(fwd) {
    return __awaiter$F(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      const currentPosition = this._widget.position;
      if (!currentPosition) {
        return;
      }
      const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
      if (!source) {
        return;
      }
      const target = this._model.nextOrPreviousReference(source, fwd);
      const editorFocus = this._editor.hasTextFocus();
      const previewEditorFocus = this._widget.isPreviewEditorFocused();
      yield this._widget.setSelection(target);
      yield this._gotoReference(target, false);
      if (editorFocus) {
        this._editor.focus();
      } else if (this._widget && previewEditorFocus) {
        this._widget.focusOnPreviewEditor();
      }
    });
  }
  revealReference(reference2) {
    return __awaiter$F(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      yield this._widget.revealReference(reference2);
    });
  }
  closeWidget(focusEditor = true) {
    var _a3, _b3;
    (_a3 = this._widget) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    (_b3 = this._model) === null || _b3 === void 0 ? void 0 : _b3.dispose();
    this._referenceSearchVisible.reset();
    this._disposables.clear();
    this._widget = void 0;
    this._model = void 0;
    if (focusEditor) {
      this._editor.focus();
    }
    this._requestIdPool += 1;
  }
  _gotoReference(ref, pinned) {
    var _a3;
    (_a3 = this._widget) === null || _a3 === void 0 ? void 0 : _a3.hide();
    this._ignoreModelChangeEvent = true;
    const range = Range$1.lift(ref.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: ref.uri,
      options: { selection: range, selectionSource: "code.jump", pinned }
    }, this._editor).then((openedEditor) => {
      var _a4;
      this._ignoreModelChangeEvent = false;
      if (!openedEditor || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === openedEditor) {
        this._widget.show(range);
        this._widget.focusOnReferenceTree();
      } else {
        const other = ReferencesController2.get(openedEditor);
        const model = this._model.clone();
        this.closeWidget();
        openedEditor.focus();
        other === null || other === void 0 ? void 0 : other.toggleWidget(range, createCancelablePromise((_) => Promise.resolve(model)), (_a4 = this._peekMode) !== null && _a4 !== void 0 ? _a4 : false);
      }
    }, (err) => {
      this._ignoreModelChangeEvent = false;
      onUnexpectedError(err);
    });
  }
  openReference(ref, sideBySide, pinned) {
    if (!sideBySide) {
      this.closeWidget();
    }
    const { uri, range } = ref;
    this._editorService.openCodeEditor({
      resource: uri,
      options: { selection: range, selectionSource: "code.jump", pinned }
    }, this._editor, sideBySide);
  }
};
ReferencesController.ID = "editor.contrib.referencesController";
ReferencesController = __decorate$L([
  __param$L(2, IContextKeyService),
  __param$L(3, ICodeEditorService),
  __param$L(4, INotificationService),
  __param$L(5, IInstantiationService),
  __param$L(6, IStorageService),
  __param$L(7, IConfigurationService)
], ReferencesController);
function withController(accessor, fn) {
  const outerEditor = getOuterEditor(accessor);
  if (!outerEditor) {
    return;
  }
  const controller = ReferencesController.get(outerEditor);
  if (controller) {
    fn(controller);
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: KeyChord(
    2048 | 41,
    60
    /* KeyCode.F2 */
  ),
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.changeFocusBetweenPreviewAndReferences();
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 100 - 10,
  primary: 62,
  secondary: [
    70
    /* KeyCode.F12 */
  ],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(true);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 100 - 10,
  primary: 1024 | 62,
  secondary: [
    1024 | 70
    /* KeyCode.F12 */
  ],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(false);
    });
  }
});
CommandsRegistry.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
CommandsRegistry.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
CommandsRegistry.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
CommandsRegistry.registerCommand("closeReferenceSearch", (accessor) => withController(accessor, (controller) => controller.closeWidget()));
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 100 - 101,
  primary: 9,
  secondary: [
    1024 | 9
    /* KeyCode.Escape */
  ],
  when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 200 + 50,
  primary: 9,
  secondary: [
    1024 | 9
    /* KeyCode.Escape */
  ],
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [
      2048 | 18
      /* KeyCode.DownArrow */
    ]
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
  handler(accessor) {
    var _a3;
    const listService = accessor.get(IListService);
    const focus = (_a3 = listService.lastFocusedList) === null || _a3 === void 0 ? void 0 : _a3.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.revealReference(focus[0]));
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2048 | 3,
  mac: {
    primary: 256 | 3
    /* KeyCode.Enter */
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
  handler(accessor) {
    var _a3;
    const listService = accessor.get(IListService);
    const focus = (_a3 = listService.lastFocusedList) === null || _a3 === void 0 ? void 0 : _a3.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.openReference(focus[0], true, true));
    }
  }
});
CommandsRegistry.registerCommand("openReference", (accessor) => {
  var _a3;
  const listService = accessor.get(IListService);
  const focus = (_a3 = listService.lastFocusedList) === null || _a3 === void 0 ? void 0 : _a3.getFocus();
  if (Array.isArray(focus) && focus[0] instanceof OneReference) {
    withController(accessor, (controller) => controller.openReference(focus[0], false, true));
  }
});
var __decorate$K = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$K = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const ctxHasSymbols = new RawContextKey("hasSymbols", false, localize("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only."));
const ISymbolNavigationService = createDecorator("ISymbolNavigationService");
let SymbolNavigationService = class SymbolNavigationService2 {
  constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._keybindingService = _keybindingService;
    this._currentModel = void 0;
    this._currentIdx = -1;
    this._ignoreEditorChange = false;
    this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
  }
  reset() {
    var _a3, _b3;
    this._ctxHasSymbols.reset();
    (_a3 = this._currentState) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    (_b3 = this._currentMessage) === null || _b3 === void 0 ? void 0 : _b3.dispose();
    this._currentModel = void 0;
    this._currentIdx = -1;
  }
  put(anchor) {
    const refModel = anchor.parent.parent;
    if (refModel.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = refModel;
    this._currentIdx = refModel.references.indexOf(anchor);
    this._ctxHasSymbols.set(true);
    this._showMessage();
    const editorState = new EditorState(this._editorService);
    const listener = editorState.onDidChange((_) => {
      if (this._ignoreEditorChange) {
        return;
      }
      const editor2 = this._editorService.getActiveCodeEditor();
      if (!editor2) {
        return;
      }
      const model = editor2.getModel();
      const position = editor2.getPosition();
      if (!model || !position) {
        return;
      }
      let seenUri = false;
      let seenPosition = false;
      for (const reference2 of refModel.references) {
        if (isEqual(reference2.uri, model.uri)) {
          seenUri = true;
          seenPosition = seenPosition || Range$1.containsPosition(reference2.range, position);
        } else if (seenUri) {
          break;
        }
      }
      if (!seenUri || !seenPosition) {
        this.reset();
      }
    });
    this._currentState = combinedDisposable(editorState, listener);
  }
  revealNext(source) {
    if (!this._currentModel) {
      return Promise.resolve();
    }
    this._currentIdx += 1;
    this._currentIdx %= this._currentModel.references.length;
    const reference2 = this._currentModel.references[this._currentIdx];
    this._showMessage();
    this._ignoreEditorChange = true;
    return this._editorService.openCodeEditor({
      resource: reference2.uri,
      options: {
        selection: Range$1.collapseToStart(reference2.range),
        selectionRevealType: 3
        /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */
      }
    }, source).finally(() => {
      this._ignoreEditorChange = false;
    });
  }
  _showMessage() {
    var _a3;
    (_a3 = this._currentMessage) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    const kb = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult");
    const message = kb ? localize("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel()) : localize("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(message);
  }
};
SymbolNavigationService = __decorate$K([
  __param$K(0, IContextKeyService),
  __param$K(1, ICodeEditorService),
  __param$K(2, INotificationService),
  __param$K(3, IKeybindingService)
], SymbolNavigationService);
registerSingleton(
  ISymbolNavigationService,
  SymbolNavigationService,
  1
  /* InstantiationType.Delayed */
);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: ctxHasSymbols,
      kbOpts: {
        weight: 100,
        primary: 70
        /* KeyCode.F12 */
      }
    });
  }
  runEditorCommand(accessor, editor2) {
    return accessor.get(ISymbolNavigationService).revealNext(editor2);
  }
}());
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: ctxHasSymbols,
  primary: 9,
  handler(accessor) {
    accessor.get(ISymbolNavigationService).reset();
  }
});
let EditorState = class EditorState2 {
  constructor(editorService) {
    this._listener = /* @__PURE__ */ new Map();
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));
    this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));
    editorService.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
    dispose(this._listener.values());
  }
  _onDidAddEditor(editor2) {
    this._listener.set(editor2, combinedDisposable(editor2.onDidChangeCursorPosition((_) => this._onDidChange.fire({ editor: editor2 })), editor2.onDidChangeModelContent((_) => this._onDidChange.fire({ editor: editor2 }))));
  }
  _onDidRemoveEditor(editor2) {
    var _a3;
    (_a3 = this._listener.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    this._listener.delete(editor2);
  }
};
EditorState = __decorate$K([
  __param$K(0, ICodeEditorService)
], EditorState);
var __awaiter$E = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getLocationLinks(model, position, registry, provide) {
  return __awaiter$E(this, void 0, void 0, function* () {
    const provider = registry.ordered(model);
    const promises = provider.map((provider2) => {
      return Promise.resolve(provide(provider2, model, position)).then(void 0, (err) => {
        onUnexpectedExternalError(err);
        return void 0;
      });
    });
    const values = yield Promise.all(promises);
    return coalesce(values.flat());
  });
}
function getDefinitionsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideDefinition(model2, position2, token);
  });
}
function getDeclarationsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideDeclaration(model2, position2, token);
  });
}
function getImplementationsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideImplementation(model2, position2, token);
  });
}
function getTypeDefinitionsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideTypeDefinition(model2, position2, token);
  });
}
function getReferencesAtPosition(registry, model, position, compact, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => __awaiter$E(this, void 0, void 0, function* () {
    const result = yield provider.provideReferences(model2, position2, { includeDeclaration: true }, token);
    if (!compact || !result || result.length !== 2) {
      return result;
    }
    const resultWithoutDeclaration = yield provider.provideReferences(model2, position2, { includeDeclaration: false }, token);
    if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {
      return resultWithoutDeclaration;
    }
    return result;
  }));
}
function _sortedAndDeduped(callback) {
  return __awaiter$E(this, void 0, void 0, function* () {
    const rawLinks = yield callback();
    const model = new ReferencesModel(rawLinks, "");
    const modelLinks = model.references.map((ref) => ref.link);
    model.dispose();
    return modelLinks;
  });
}
registerModelAndPositionCommand("_executeDefinitionProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeTypeDefinitionProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeDeclarationProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeReferenceProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeImplementationProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
var __awaiter$D = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a, _b, _c, _d, _e, _f, _g, _h;
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
  submenu: MenuId.EditorContextPeek,
  title: localize("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
class SymbolNavigationAnchor {
  static is(thing) {
    if (!thing || typeof thing !== "object") {
      return false;
    }
    if (thing instanceof SymbolNavigationAnchor) {
      return true;
    }
    if (Position$1.isIPosition(thing.position) && thing.model) {
      return true;
    }
    return false;
  }
  constructor(model, position) {
    this.model = model;
    this.position = position;
  }
}
class SymbolNavigationAction extends EditorAction2 {
  static all() {
    return SymbolNavigationAction._allSymbolNavigationCommands.values();
  }
  static _patchConfig(opts) {
    const result = Object.assign(Object.assign({}, opts), { f1: true });
    if (result.menu) {
      for (const item of Iterable.wrap(result.menu)) {
        if (item.id === MenuId.EditorContext || item.id === MenuId.EditorContextPeek) {
          item.when = ContextKeyExpr.and(opts.precondition, item.when);
        }
      }
    }
    return result;
  }
  constructor(configuration2, opts) {
    super(SymbolNavigationAction._patchConfig(opts));
    this.configuration = configuration2;
    SymbolNavigationAction._allSymbolNavigationCommands.set(opts.id, this);
  }
  runEditorCommand(accessor, editor2, arg, range) {
    if (!editor2.hasModel()) {
      return Promise.resolve(void 0);
    }
    const notificationService = accessor.get(INotificationService);
    const editorService = accessor.get(ICodeEditorService);
    const progressService = accessor.get(IEditorProgressService);
    const symbolNavService = accessor.get(ISymbolNavigationService);
    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
    const instaService = accessor.get(IInstantiationService);
    const model = editor2.getModel();
    const position = editor2.getPosition();
    const anchor = SymbolNavigationAnchor.is(arg) ? arg : new SymbolNavigationAnchor(model, position);
    const cts = new EditorStateCancellationTokenSource(
      editor2,
      1 | 4
      /* CodeEditorStateFlag.Position */
    );
    const promise = raceCancellation(this._getLocationModel(languageFeaturesService, anchor.model, anchor.position, cts.token), cts.token).then((references) => __awaiter$D(this, void 0, void 0, function* () {
      var _j2;
      if (!references || cts.token.isCancellationRequested) {
        return;
      }
      alert(references.ariaMessage);
      let altAction;
      if (references.referenceAt(model.uri, position)) {
        const altActionId = this._getAlternativeCommand(editor2);
        if (!SymbolNavigationAction._activeAlternativeCommands.has(altActionId) && SymbolNavigationAction._allSymbolNavigationCommands.has(altActionId)) {
          altAction = SymbolNavigationAction._allSymbolNavigationCommands.get(altActionId);
        }
      }
      const referenceCount = references.references.length;
      if (referenceCount === 0) {
        if (!this.configuration.muteMessage) {
          const info = model.getWordAtPosition(position);
          (_j2 = MessageController.get(editor2)) === null || _j2 === void 0 ? void 0 : _j2.showMessage(this._getNoResultFoundMessage(info), position);
        }
      } else if (referenceCount === 1 && altAction) {
        SymbolNavigationAction._activeAlternativeCommands.add(this.desc.id);
        instaService.invokeFunction((accessor2) => altAction.runEditorCommand(accessor2, editor2, arg, range).finally(() => {
          SymbolNavigationAction._activeAlternativeCommands.delete(this.desc.id);
        }));
      } else {
        return this._onResult(editorService, symbolNavService, editor2, references, range);
      }
    }), (err) => {
      notificationService.error(err);
    }).finally(() => {
      cts.dispose();
    });
    progressService.showWhile(promise, 250);
    return promise;
  }
  _onResult(editorService, symbolNavService, editor2, model, range) {
    return __awaiter$D(this, void 0, void 0, function* () {
      const gotoLocation = this._getGoToPreference(editor2);
      if (!(editor2 instanceof EmbeddedCodeEditorWidget) && (this.configuration.openInPeek || gotoLocation === "peek" && model.references.length > 1)) {
        this._openInPeek(editor2, model, range);
      } else {
        const next = model.firstReference();
        const peek = model.references.length > 1 && gotoLocation === "gotoAndPeek";
        const targetEditor = yield this._openReference(editor2, editorService, next, this.configuration.openToSide, !peek);
        if (peek && targetEditor) {
          this._openInPeek(targetEditor, model, range);
        } else {
          model.dispose();
        }
        if (gotoLocation === "goto") {
          symbolNavService.put(next);
        }
      }
    });
  }
  _openReference(editor2, editorService, reference2, sideBySide, highlight) {
    return __awaiter$D(this, void 0, void 0, function* () {
      let range = void 0;
      if (isLocationLink(reference2)) {
        range = reference2.targetSelectionRange;
      }
      if (!range) {
        range = reference2.range;
      }
      if (!range) {
        return void 0;
      }
      const targetEditor = yield editorService.openCodeEditor({
        resource: reference2.uri,
        options: {
          selection: Range$1.collapseToStart(range),
          selectionRevealType: 3,
          selectionSource: "code.jump"
          /* TextEditorSelectionSource.JUMP */
        }
      }, editor2, sideBySide);
      if (!targetEditor) {
        return void 0;
      }
      if (highlight) {
        const modelNow = targetEditor.getModel();
        const decorations = targetEditor.createDecorationsCollection([{ range, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
        setTimeout(() => {
          if (targetEditor.getModel() === modelNow) {
            decorations.clear();
          }
        }, 350);
      }
      return targetEditor;
    });
  }
  _openInPeek(target, model, range) {
    const controller = ReferencesController.get(target);
    if (controller && target.hasModel()) {
      controller.toggleWidget(range !== null && range !== void 0 ? range : target.getSelection(), createCancelablePromise((_) => Promise.resolve(model)), this.configuration.openInPeek);
    } else {
      model.dispose();
    }
  }
}
SymbolNavigationAction._allSymbolNavigationCommands = /* @__PURE__ */ new Map();
SymbolNavigationAction._activeAlternativeCommands = /* @__PURE__ */ new Set();
class DefinitionAction extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter$D(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, token), localize("def.title", "Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("noResultWord", "No definition found for '{0}'", info.word) : localize("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).alternativeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).multipleDefinitions;
  }
}
registerAction2((_a = class GoToDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDefinitionAction.id,
      title: {
        value: localize("actions.goToDecl.label", "Go to Definition"),
        original: "Go to Definition",
        mnemonicTitle: localize({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: [{
        when: EditorContextKeys.editorTextFocus,
        primary: 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, IsWebContext),
        primary: 2048 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }],
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.1
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 2
      }]
    });
    CommandsRegistry.registerCommandAlias("editor.action.goToDeclaration", GoToDefinitionAction.id);
  }
}, _a.id = "editor.action.revealDefinition", _a));
registerAction2((_b = class OpenDefinitionToSideAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: true,
      openInPeek: false,
      muteMessage: false
    }, {
      id: OpenDefinitionToSideAction.id,
      title: {
        value: localize("actions.goToDeclToSide.label", "Open Definition to the Side"),
        original: "Open Definition to the Side"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: [{
        when: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, IsWebContext),
        primary: KeyChord(
          2048 | 41,
          2048 | 70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
    CommandsRegistry.registerCommandAlias("editor.action.openDeclarationToTheSide", OpenDefinitionToSideAction.id);
  }
}, _b.id = "editor.action.revealDefinitionAside", _b));
registerAction2((_c = class PeekDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekDefinitionAction.id,
      title: {
        value: localize("actions.previewDecl.label", "Peek Definition"),
        original: "Peek Definition"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 512 | 70,
        linux: {
          primary: 2048 | 1024 | 68
          /* KeyCode.F10 */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 2
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.previewDeclaration", PeekDefinitionAction.id);
  }
}, _c.id = "editor.action.peekDefinition", _c));
class DeclarationAction extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter$D(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, token), localize("decl.title", "Declarations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).alternativeDeclarationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).multipleDeclarations;
  }
}
registerAction2((_d = class GoToDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDeclarationAction.id,
      title: {
        value: localize("actions.goToDeclaration.label", "Go to Declaration"),
        original: "Go to Declaration",
        mnemonicTitle: localize({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.3
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
}, _d.id = "editor.action.revealDeclaration", _d));
registerAction2(class PeekDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.peekDeclaration",
      title: {
        value: localize("actions.peekDecl.label", "Peek Declaration"),
        original: "Peek Declaration"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
class TypeDefinitionAction extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter$D(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, token), localize("typedef.title", "Type Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", info.word) : localize("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).multipleTypeDefinitions;
  }
}
registerAction2((_e = class GoToTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToTypeDefinitionAction.ID,
      title: {
        value: localize("actions.goToTypeDefinition.label", "Go to Type Definition"),
        original: "Go to Type Definition",
        mnemonicTitle: localize({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.4
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
}, _e.ID = "editor.action.goToTypeDefinition", _e));
registerAction2((_f = class PeekTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekTypeDefinitionAction.ID,
      title: {
        value: localize("actions.peekTypeDefinition.label", "Peek Type Definition"),
        original: "Peek Type Definition"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, _f.ID = "editor.action.peekTypeDefinition", _f));
class ImplementationAction extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter$D(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, token), localize("impl.title", "Implementations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToImplementation.noResultWord", "No implementation found for '{0}'", info.word) : localize("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).alternativeImplementationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).multipleImplementations;
  }
}
registerAction2((_g = class GoToImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToImplementationAction.ID,
      title: {
        value: localize("actions.goToImplementation.label", "Go to Implementations"),
        original: "Go to Implementations",
        mnemonicTitle: localize({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 2048 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 4
      }]
    });
  }
}, _g.ID = "editor.action.goToImplementation", _g));
registerAction2((_h = class PeekImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekImplementationAction.ID,
      title: {
        value: localize("actions.peekImplementation.label", "Peek Implementations"),
        original: "Peek Implementations"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, _h.ID = "editor.action.peekImplementation", _h));
class ReferencesAction extends SymbolNavigationAction {
  _getNoResultFoundMessage(info) {
    return info ? localize("references.no", "No references found for '{0}'", info.word) : localize("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).alternativeReferenceCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
}
registerAction2(class GoToReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: "editor.action.goToReferences",
      title: {
        value: localize("goToReferences.label", "Go to References"),
        original: "Go to References",
        mnemonicTitle: localize({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 1024 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 5
      }]
    });
  }
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter$D(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, true, token), localize("ref.title", "References"));
    });
  }
});
registerAction2(class PeekReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.referenceSearch.trigger",
      title: {
        value: localize("references.action.label", "Peek References"),
        original: "Peek References"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter$D(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, token), localize("ref.title", "References"));
    });
  }
});
class GenericGoToLocationAction extends SymbolNavigationAction {
  constructor(config, _references, _gotoMultipleBehaviour) {
    super(config, {
      id: "editor.action.goToLocation",
      title: {
        value: localize("label.generic", "Go to Any Symbol"),
        original: "Go to Any Symbol"
      },
      precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated())
    });
    this._references = _references;
    this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
  }
  _getLocationModel(languageFeaturesService, _model, _position, _token) {
    return __awaiter$D(this, void 0, void 0, function* () {
      return new ReferencesModel(this._references, localize("generic.title", "Locations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && localize("generic.noResult", "No results for '{0}'", info.word) || "";
  }
  _getGoToPreference(editor2) {
    var _j2;
    return (_j2 = this._gotoMultipleBehaviour) !== null && _j2 !== void 0 ? _j2 : editor2.getOption(
      57
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
}
CommandsRegistry.registerCommand({
  id: "editor.action.goToLocations",
  description: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI$1 },
      { name: "position", description: "The position at which to start", constraint: Position$1.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => __awaiter$D(void 0, void 0, void 0, function* () {
    assertType(URI$1.isUri(resource));
    assertType(Position$1.isIPosition(position));
    assertType(Array.isArray(references));
    assertType(typeof multiple === "undefined" || typeof multiple === "string");
    assertType(typeof openInPeek === "undefined" || typeof openInPeek === "boolean");
    const editorService = accessor.get(ICodeEditorService);
    const editor2 = yield editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
    if (isCodeEditor(editor2)) {
      editor2.setPosition(position);
      editor2.revealPositionInCenterIfOutsideViewport(
        position,
        0
        /* ScrollType.Smooth */
      );
      return editor2.invokeWithinContext((accessor2) => {
        const command = new class extends GenericGoToLocationAction {
          _getNoResultFoundMessage(info) {
            return noResultsMessage || super._getNoResultFoundMessage(info);
          }
        }({
          muteMessage: !Boolean(noResultsMessage),
          openInPeek: Boolean(openInPeek),
          openToSide: false
        }, references, multiple);
        accessor2.get(IInstantiationService).invokeFunction(command.run.bind(command), editor2);
      });
    }
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.peekLocations",
  description: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI$1 },
      { name: "position", description: "The position at which to start", constraint: Position$1.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" }
    ]
  },
  handler: (accessor, resource, position, references, multiple) => __awaiter$D(void 0, void 0, void 0, function* () {
    accessor.get(ICommandService).executeCommand("editor.action.goToLocations", resource, position, references, multiple, void 0, true);
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.findReferences",
  handler: (accessor, resource, position) => {
    assertType(URI$1.isUri(resource));
    assertType(Position$1.isIPosition(position));
    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
    const codeEditorService = accessor.get(ICodeEditorService);
    return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then((control) => {
      if (!isCodeEditor(control) || !control.hasModel()) {
        return void 0;
      }
      const controller = ReferencesController.get(control);
      if (!controller) {
        return void 0;
      }
      const references = createCancelablePromise((token) => getReferencesAtPosition(languageFeaturesService.referenceProvider, control.getModel(), Position$1.lift(position), false, token).then((references2) => new ReferencesModel(references2, localize("ref.title", "References"))));
      const range = new Range$1(position.lineNumber, position.column, position.lineNumber, position.column);
      return Promise.resolve(controller.toggleWidget(range, references, false));
    });
  }
});
CommandsRegistry.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
var __decorate$J = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$J = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$C = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let GotoDefinitionAtPositionEditorContribution = class GotoDefinitionAtPositionEditorContribution2 {
  constructor(editor2, textModelResolverService, languageService, languageFeaturesService) {
    this.textModelResolverService = textModelResolverService;
    this.languageService = languageService;
    this.languageFeaturesService = languageFeaturesService;
    this.toUnhook = new DisposableStore();
    this.toUnhookForKeyboard = new DisposableStore();
    this.currentWordAtPosition = null;
    this.previousPromise = null;
    this.editor = editor2;
    this.linkDecorations = this.editor.createDecorationsCollection();
    const linkGesture = new ClickLinkGesture(editor2);
    this.toUnhook.add(linkGesture);
    this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this.startFindDefinitionFromMouse(mouseEvent, withNullAsUndefined(keyboardEvent));
    }));
    this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
      if (this.isEnabled(mouseEvent)) {
        this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).catch((error) => {
          onUnexpectedError(error);
        }).finally(() => {
          this.removeLinkDecorations();
        });
      }
    }));
    this.toUnhook.add(linkGesture.onCancel(() => {
      this.removeLinkDecorations();
      this.currentWordAtPosition = null;
    }));
  }
  static get(editor2) {
    return editor2.getContribution(GotoDefinitionAtPositionEditorContribution2.ID);
  }
  startFindDefinitionFromCursor(position) {
    return __awaiter$C(this, void 0, void 0, function* () {
      yield this.startFindDefinition(position);
      this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        this.toUnhookForKeyboard.clear();
      }));
      this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
        if (e) {
          this.currentWordAtPosition = null;
          this.removeLinkDecorations();
          this.toUnhookForKeyboard.clear();
        }
      }));
    });
  }
  startFindDefinitionFromMouse(mouseEvent, withKey) {
    if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) {
      return;
    }
    if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return;
    }
    const position = mouseEvent.target.position;
    this.startFindDefinition(position);
  }
  startFindDefinition(position) {
    var _a3;
    return __awaiter$C(this, void 0, void 0, function* () {
      this.toUnhookForKeyboard.clear();
      const word = position ? (_a3 = this.editor.getModel()) === null || _a3 === void 0 ? void 0 : _a3.getWordAtPosition(position) : null;
      if (!word) {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        return;
      }
      if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
        return;
      }
      this.currentWordAtPosition = word;
      const state = new EditorState$1(
        this.editor,
        4 | 1 | 2 | 8
        /* CodeEditorStateFlag.Scroll */
      );
      if (this.previousPromise) {
        this.previousPromise.cancel();
        this.previousPromise = null;
      }
      this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
      let results;
      try {
        results = yield this.previousPromise;
      } catch (error) {
        onUnexpectedError(error);
        return;
      }
      if (!results || !results.length || !state.validate(this.editor)) {
        this.removeLinkDecorations();
        return;
      }
      const linkRange = results[0].originSelectionRange ? Range$1.lift(results[0].originSelectionRange) : new Range$1(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
      if (results.length > 1) {
        let combinedRange = linkRange;
        for (const { originSelectionRange } of results) {
          if (originSelectionRange) {
            combinedRange = Range$1.plusRange(combinedRange, originSelectionRange);
          }
        }
        this.addDecoration(combinedRange, new MarkdownString().appendText(localize("multipleResults", "Click to show {0} definitions.", results.length)));
      } else {
        const result = results[0];
        if (!result.uri) {
          return;
        }
        this.textModelResolverService.createModelReference(result.uri).then((ref) => {
          if (!ref.object || !ref.object.textEditorModel) {
            ref.dispose();
            return;
          }
          const { object: { textEditorModel } } = ref;
          const { startLineNumber } = result.range;
          if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
            ref.dispose();
            return;
          }
          const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
          const languageId = this.languageService.guessLanguageIdByFilepathOrFirstLine(textEditorModel.uri);
          this.addDecoration(linkRange, previewValue ? new MarkdownString().appendCodeblock(languageId ? languageId : "", previewValue) : void 0);
          ref.dispose();
        });
      }
    });
  }
  getPreviewValue(textEditorModel, startLineNumber, result) {
    let rangeToUse = result.range;
    const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;
    if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES) {
      rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
    }
    const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
    return previewValue;
  }
  stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    let minIndent = startIndent;
    for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      minIndent = Math.min(minIndent, endIndent);
    }
    const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
    return previewValue;
  }
  getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
    let endLineNumber = startLineNumber + 1;
    for (; endLineNumber < maxLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      if (startIndent === endIndent) {
        break;
      }
    }
    return new Range$1(startLineNumber, 1, endLineNumber + 1, 1);
  }
  addDecoration(range, hoverMessage) {
    const newDecorations = {
      range,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage
      }
    };
    this.linkDecorations.set([newDecorations]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(mouseEvent, withKey) {
    var _a3;
    return this.editor.hasModel() && mouseEvent.isLeftClick && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && !(((_a3 = mouseEvent.target.detail.injectedText) === null || _a3 === void 0 ? void 0 : _a3.options) instanceof ModelDecorationInjectedTextOptions) && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(position, token) {
    const model = this.editor.getModel();
    if (!model) {
      return Promise.resolve(null);
    }
    return getDefinitionsAtPosition(this.languageFeaturesService.definitionProvider, model, position, token);
  }
  gotoDefinition(position, openToSide) {
    this.editor.setPosition(position);
    return this.editor.invokeWithinContext((accessor) => {
      const canPeek = !openToSide && this.editor.getOption(
        86
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !this.isInPeekEditor(accessor);
      const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: "", original: "" }, id: "", precondition: void 0 });
      return action.run(accessor);
    });
  }
  isInPeekEditor(accessor) {
    const contextKeyService = accessor.get(IContextKeyService);
    return PeekContext.inPeekEditor.getValue(contextKeyService);
  }
  dispose() {
    this.toUnhook.dispose();
    this.toUnhookForKeyboard.dispose();
  }
};
GotoDefinitionAtPositionEditorContribution.ID = "editor.contrib.gotodefinitionatposition";
GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
GotoDefinitionAtPositionEditorContribution = __decorate$J([
  __param$J(1, ITextModelService),
  __param$J(2, ILanguageService),
  __param$J(3, ILanguageFeaturesService)
], GotoDefinitionAtPositionEditorContribution);
registerEditorContribution(
  GotoDefinitionAtPositionEditorContribution.ID,
  GotoDefinitionAtPositionEditorContribution,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
const hover$2 = "";
const $$6 = $$8;
class HoverWidget extends Disposable {
  constructor() {
    super();
    this.containerDomNode = document.createElement("div");
    this.containerDomNode.className = "monaco-hover";
    this.containerDomNode.tabIndex = 0;
    this.containerDomNode.setAttribute("role", "tooltip");
    this.contentsDomNode = document.createElement("div");
    this.contentsDomNode.className = "monaco-hover-content";
    this.scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: true
    }));
    this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
}
class HoverAction extends Disposable {
  static render(parent, actionOptions, keybindingLabel) {
    return new HoverAction(parent, actionOptions, keybindingLabel);
  }
  constructor(parent, actionOptions, keybindingLabel) {
    super();
    this.actionContainer = append(parent, $$6("div.action-container"));
    this.actionContainer.setAttribute("tabindex", "0");
    this.action = append(this.actionContainer, $$6("a.action"));
    this.action.setAttribute("role", "button");
    if (actionOptions.iconClass) {
      append(this.action, $$6(`span.icon.${actionOptions.iconClass}`));
    }
    const label = append(this.action, $$6("span"));
    label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
    this._register(addDisposableListener(this.actionContainer, EventType.CLICK, (e) => {
      e.stopPropagation();
      e.preventDefault();
      actionOptions.run(this.actionContainer);
    }));
    this._register(addDisposableListener(this.actionContainer, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        3
        /* KeyCode.Enter */
      ) || event.equals(
        10
        /* KeyCode.Space */
      )) {
        e.stopPropagation();
        e.preventDefault();
        actionOptions.run(this.actionContainer);
      }
    }));
    this.setEnabled(true);
  }
  setEnabled(enabled) {
    if (enabled) {
      this.actionContainer.classList.remove("disabled");
      this.actionContainer.removeAttribute("aria-disabled");
    } else {
      this.actionContainer.classList.add("disabled");
      this.actionContainer.setAttribute("aria-disabled", "true");
    }
  }
}
var __awaiter$B = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues$1 = globalThis && globalThis.__asyncValues || function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n2](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
let HoverResult$1 = class HoverResult {
  constructor(value, isComplete, hasLoadingMessage) {
    this.value = value;
    this.isComplete = isComplete;
    this.hasLoadingMessage = hasLoadingMessage;
  }
};
class HoverOperation extends Disposable {
  constructor(_editor, _computer) {
    super();
    this._editor = _editor;
    this._computer = _computer;
    this._onResult = this._register(new Emitter());
    this.onResult = this._onResult.event;
    this._firstWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerAsyncComputation(), 0));
    this._secondWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerSyncComputation(), 0));
    this._loadingMessageScheduler = this._register(new RunOnceScheduler(() => this._triggerLoadingMessage(), 0));
    this._state = 0;
    this._asyncIterable = null;
    this._asyncIterableDone = false;
    this._result = [];
  }
  dispose() {
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(
      59
      /* EditorOption.hover */
    ).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(state, fireResult = true) {
    this._state = state;
    if (fireResult) {
      this._fireResult();
    }
  }
  _triggerAsyncComputation() {
    this._setState(
      2
      /* HoverOperationState.SecondWait */
    );
    this._secondWaitScheduler.schedule(this._secondWaitTime);
    if (this._computer.computeAsync) {
      this._asyncIterableDone = false;
      this._asyncIterable = createCancelableAsyncIterable((token) => this._computer.computeAsync(token));
      (() => __awaiter$B(this, void 0, void 0, function* () {
        var _a3, e_1, _b3, _c3;
        try {
          try {
            for (var _d3 = true, _e3 = __asyncValues$1(this._asyncIterable), _f3; _f3 = yield _e3.next(), _a3 = _f3.done, !_a3; _d3 = true) {
              _c3 = _f3.value;
              _d3 = false;
              const item = _c3;
              if (item) {
                this._result.push(item);
                this._fireResult();
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d3 && !_a3 && (_b3 = _e3.return))
                yield _b3.call(_e3);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this._asyncIterableDone = true;
          if (this._state === 3 || this._state === 4) {
            this._setState(
              0
              /* HoverOperationState.Idle */
            );
          }
        } catch (e) {
          onUnexpectedError(e);
        }
      }))();
    } else {
      this._asyncIterableDone = true;
    }
  }
  _triggerSyncComputation() {
    if (this._computer.computeSync) {
      this._result = this._result.concat(this._computer.computeSync());
    }
    this._setState(
      this._asyncIterableDone ? 0 : 3
      /* HoverOperationState.WaitingForAsync */
    );
  }
  _triggerLoadingMessage() {
    if (this._state === 3) {
      this._setState(
        4
        /* HoverOperationState.WaitingForAsyncShowingLoading */
      );
    }
  }
  _fireResult() {
    if (this._state === 1 || this._state === 2) {
      return;
    }
    const isComplete = this._state === 0;
    const hasLoadingMessage = this._state === 4;
    this._onResult.fire(new HoverResult$1(this._result.slice(0), isComplete, hasLoadingMessage));
  }
  start(mode) {
    if (mode === 0) {
      if (this._state === 0) {
        this._setState(
          1
          /* HoverOperationState.FirstWait */
        );
        this._firstWaitScheduler.schedule(this._firstWaitTime);
        this._loadingMessageScheduler.schedule(this._loadingMessageTime);
      }
    } else {
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation();
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
      }
    }
  }
  cancel() {
    this._firstWaitScheduler.cancel();
    this._secondWaitScheduler.cancel();
    this._loadingMessageScheduler.cancel();
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    this._result = [];
    this._setState(0, false);
  }
}
class HoverRangeAnchor {
  constructor(priority, range, initialMousePosX, initialMousePosY) {
    this.priority = priority;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.type = 1;
  }
  equals(other) {
    return other.type === 1 && this.range.equalsRange(other.range);
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 1 && showAtPosition.lineNumber === this.range.startLineNumber;
  }
}
class HoverForeignElementAnchor {
  constructor(priority, owner, range, initialMousePosX, initialMousePosY, supportsMarkerHover) {
    this.priority = priority;
    this.owner = owner;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.supportsMarkerHover = supportsMarkerHover;
    this.type = 2;
  }
  equals(other) {
    return other.type === 2 && this.owner === other.owner;
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 2 && this.owner === lastAnchor.owner;
  }
}
const HoverParticipantRegistry = new class HoverParticipantRegistry2 {
  constructor() {
    this._participants = [];
  }
  register(ctor) {
    this._participants.push(ctor);
  }
  getAll() {
    return this._participants;
  }
}();
const TOP_HEIGHT = 30;
const BOTTOM_HEIGHT = 24;
class ResizableContentWidget extends Disposable {
  constructor(_editor, minimumSize = new Dimension(10, 10)) {
    super();
    this._editor = _editor;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._resizableNode = this._register(new ResizableHTMLElement());
    this._contentPosition = null;
    this._isResizing = false;
    this._resizableNode.domNode.style.position = "absolute";
    this._resizableNode.minSize = Dimension.lift(minimumSize);
    this._resizableNode.layout(minimumSize.height, minimumSize.width);
    this._resizableNode.enableSashes(true, true, true, true);
    this._register(this._resizableNode.onDidResize((e) => {
      this._resize(new Dimension(e.dimension.width, e.dimension.height));
      if (e.done) {
        this._isResizing = false;
      }
    }));
    this._register(this._resizableNode.onDidWillResize(() => {
      this._isResizing = true;
    }));
  }
  get isResizing() {
    return this._isResizing;
  }
  getDomNode() {
    return this._resizableNode.domNode;
  }
  getPosition() {
    return this._contentPosition;
  }
  get position() {
    var _a3;
    return ((_a3 = this._contentPosition) === null || _a3 === void 0 ? void 0 : _a3.position) ? Position$1.lift(this._contentPosition.position) : void 0;
  }
  _availableVerticalSpaceAbove(position) {
    const editorDomNode = this._editor.getDomNode();
    const mouseBox = this._editor.getScrolledVisiblePosition(position);
    if (!editorDomNode || !mouseBox) {
      return;
    }
    const editorBox = getDomNodePagePosition(editorDomNode);
    return editorBox.top + mouseBox.top - TOP_HEIGHT;
  }
  _availableVerticalSpaceBelow(position) {
    const editorDomNode = this._editor.getDomNode();
    const mouseBox = this._editor.getScrolledVisiblePosition(position);
    if (!editorDomNode || !mouseBox) {
      return;
    }
    const editorBox = getDomNodePagePosition(editorDomNode);
    const bodyBox = getClientArea(document.body);
    const mouseBottom = editorBox.top + mouseBox.top + mouseBox.height;
    return bodyBox.height - mouseBottom - BOTTOM_HEIGHT;
  }
  _findPositionPreference(widgetHeight, showAtPosition) {
    var _a3, _b3;
    const maxHeightBelow = Math.min((_a3 = this._availableVerticalSpaceBelow(showAtPosition)) !== null && _a3 !== void 0 ? _a3 : Infinity, widgetHeight);
    const maxHeightAbove = Math.min((_b3 = this._availableVerticalSpaceAbove(showAtPosition)) !== null && _b3 !== void 0 ? _b3 : Infinity, widgetHeight);
    const maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow), widgetHeight);
    const height = Math.min(widgetHeight, maxHeight);
    let renderingAbove;
    if (this._editor.getOption(
      59
      /* EditorOption.hover */
    ).above) {
      renderingAbove = height <= maxHeightAbove ? 1 : 2;
    } else {
      renderingAbove = height <= maxHeightBelow ? 2 : 1;
    }
    if (renderingAbove === 1) {
      this._resizableNode.enableSashes(true, true, false, false);
    } else {
      this._resizableNode.enableSashes(false, true, true, false);
    }
    return renderingAbove;
  }
  _resize(dimension) {
    this._resizableNode.layout(dimension.height, dimension.width);
  }
}
var __decorate$I = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$I = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const $$5 = $$8;
let ContentHoverController = class ContentHoverController2 extends Disposable {
  getWidgetContent() {
    const node = this._widget.getDomNode();
    if (!node.textContent) {
      return void 0;
    }
    return node.textContent;
  }
  constructor(_editor, _instantiationService, _keybindingService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._keybindingService = _keybindingService;
    this._currentResult = null;
    const minimumHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    ) + 8;
    const minimumWidth = 4 / 3 * minimumHeight;
    const minimumSize = new Dimension(minimumWidth, minimumHeight);
    this._widget = this._register(this._instantiationService.createInstance(ContentHoverWidget, this._editor, minimumSize));
    this._participants = [];
    for (const participant of HoverParticipantRegistry.getAll()) {
      this._participants.push(this._instantiationService.createInstance(participant, this._editor));
    }
    this._participants.sort((p1, p2) => p1.hoverOrdinal - p2.hoverOrdinal);
    this._computer = new ContentHoverComputer(this._editor, this._participants);
    this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
    this._register(this._hoverOperation.onResult((result) => {
      if (!this._computer.anchor) {
        return;
      }
      const messages2 = result.hasLoadingMessage ? this._addLoadingMessage(result.value) : result.value;
      this._withResult(new HoverResult2(this._computer.anchor, messages2, result.isComplete));
    }));
    this._register(addStandardDisposableListener(this._widget.getDomNode(), "keydown", (e) => {
      if (e.equals(
        9
        /* KeyCode.Escape */
      )) {
        this.hide();
      }
    }));
    this._register(TokenizationRegistry.onDidChange(() => {
      if (this._widget.position && this._currentResult) {
        this._setCurrentResult(this._currentResult);
      }
    }));
  }
  get widget() {
    return this._widget;
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  maybeShowAt(mouseEvent) {
    if (this._widget.isResizing) {
      return true;
    }
    const anchorCandidates = [];
    for (const participant of this._participants) {
      if (participant.suggestHoverAnchor) {
        const anchor = participant.suggestHoverAnchor(mouseEvent);
        if (anchor) {
          anchorCandidates.push(anchor);
        }
      }
    }
    const target = mouseEvent.target;
    if (target.type === 6) {
      anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
    }
    if (target.type === 7) {
      const epsilon = this._editor.getOption(
        49
        /* EditorOption.fontInfo */
      ).typicalHalfwidthCharacterWidth / 2;
      if (!target.detail.isAfterLines && typeof target.detail.horizontalDistanceToText === "number" && target.detail.horizontalDistanceToText < epsilon) {
        anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
      }
    }
    if (anchorCandidates.length === 0) {
      return this._startShowingOrUpdateHover(null, 0, 0, false, mouseEvent);
    }
    anchorCandidates.sort((a, b) => b.priority - a.priority);
    return this._startShowingOrUpdateHover(anchorCandidates[0], 0, 0, false, mouseEvent);
  }
  startShowingAtRange(range, mode, source, focus) {
    this._startShowingOrUpdateHover(new HoverRangeAnchor(0, range, void 0, void 0), mode, source, focus, null);
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  _startShowingOrUpdateHover(anchor, mode, source, focus, mouseEvent) {
    if (!this._widget.position || !this._currentResult) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
        return true;
      }
      return false;
    }
    const hoverIsSticky = this._editor.getOption(
      59
      /* EditorOption.hover */
    ).sticky;
    const isGettingCloser = hoverIsSticky && mouseEvent && this._widget.isMouseGettingCloser(mouseEvent.event.posx, mouseEvent.event.posy);
    if (isGettingCloser) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, true);
      }
      return true;
    }
    if (!anchor) {
      this._setCurrentResult(null);
      return false;
    }
    if (anchor && this._currentResult.anchor.equals(anchor)) {
      return true;
    }
    if (!anchor.canAdoptVisibleHover(this._currentResult.anchor, this._widget.position)) {
      this._setCurrentResult(null);
      this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
      return true;
    }
    this._setCurrentResult(this._currentResult.filter(anchor));
    this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
    return true;
  }
  _startHoverOperationIfNecessary(anchor, mode, source, focus, insistOnKeepingHoverVisible) {
    if (this._computer.anchor && this._computer.anchor.equals(anchor)) {
      return;
    }
    this._hoverOperation.cancel();
    this._computer.anchor = anchor;
    this._computer.shouldFocus = focus;
    this._computer.source = source;
    this._computer.insistOnKeepingHoverVisible = insistOnKeepingHoverVisible;
    this._hoverOperation.start(mode);
  }
  _setCurrentResult(hoverResult) {
    if (this._currentResult === hoverResult) {
      return;
    }
    if (hoverResult && hoverResult.messages.length === 0) {
      hoverResult = null;
    }
    this._currentResult = hoverResult;
    if (this._currentResult) {
      this._renderMessages(this._currentResult.anchor, this._currentResult.messages);
    } else {
      this._widget.hide();
    }
  }
  hide() {
    this._computer.anchor = null;
    this._hoverOperation.cancel();
    this._setCurrentResult(null);
  }
  get isColorPickerVisible() {
    return this._widget.isColorPickerVisible;
  }
  get isVisibleFromKeyboard() {
    return this._widget.isVisibleFromKeyboard;
  }
  get isVisible() {
    return this._widget.isVisible;
  }
  get isFocused() {
    return this._widget.isFocused;
  }
  get isResizing() {
    return this._widget.isResizing;
  }
  containsNode(node) {
    return node ? this._widget.getDomNode().contains(node) : false;
  }
  _addLoadingMessage(result) {
    if (this._computer.anchor) {
      for (const participant of this._participants) {
        if (participant.createLoadingMessage) {
          const loadingMessage = participant.createLoadingMessage(this._computer.anchor);
          if (loadingMessage) {
            return result.slice(0).concat([loadingMessage]);
          }
        }
      }
    }
    return result;
  }
  _withResult(hoverResult) {
    if (this._widget.position && this._currentResult && this._currentResult.isComplete) {
      if (!hoverResult.isComplete) {
        return;
      }
      if (this._computer.insistOnKeepingHoverVisible && hoverResult.messages.length === 0) {
        return;
      }
    }
    this._setCurrentResult(hoverResult);
  }
  _renderMessages(anchor, messages2) {
    const { showAtPosition, showAtSecondaryPosition, highlightRange } = ContentHoverController2.computeHoverRanges(this._editor, anchor.range, messages2);
    const disposables = new DisposableStore();
    const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));
    const fragment = document.createDocumentFragment();
    let colorPicker2 = null;
    const context = {
      fragment,
      statusBar,
      setColorPicker: (widget) => colorPicker2 = widget,
      onContentsChanged: () => this._widget.onContentsChanged(),
      setMinimumDimensions: (dimensions) => this._widget.setMinimumDimensions(dimensions),
      hide: () => this.hide()
    };
    for (const participant of this._participants) {
      const hoverParts = messages2.filter((msg) => msg.owner === participant);
      if (hoverParts.length > 0) {
        disposables.add(participant.renderHoverParts(context, hoverParts));
      }
    }
    const isBeforeContent = messages2.some((m) => m.isBeforeContent);
    if (statusBar.hasContent) {
      fragment.appendChild(statusBar.hoverElement);
    }
    if (fragment.hasChildNodes()) {
      if (highlightRange) {
        const highlightDecoration = this._editor.createDecorationsCollection();
        highlightDecoration.set([{
          range: highlightRange,
          options: ContentHoverController2._DECORATION_OPTIONS
        }]);
        disposables.add(toDisposable(() => {
          highlightDecoration.clear();
        }));
      }
      this._widget.showAt(fragment, new ContentHoverVisibleData(colorPicker2, showAtPosition, showAtSecondaryPosition, this._editor.getOption(
        59
        /* EditorOption.hover */
      ).above, this._computer.shouldFocus, this._computer.source, isBeforeContent, anchor.initialMousePosX, anchor.initialMousePosY, disposables));
    } else {
      disposables.dispose();
    }
  }
  static computeHoverRanges(editor2, anchorRange, messages2) {
    let startColumnBoundary = 1;
    if (editor2.hasModel()) {
      const viewModel = editor2._getViewModel();
      const coordinatesConverter = viewModel.coordinatesConverter;
      const anchorViewRange = coordinatesConverter.convertModelRangeToViewRange(anchorRange);
      const anchorViewRangeStart = new Position$1(anchorViewRange.startLineNumber, viewModel.getLineMinColumn(anchorViewRange.startLineNumber));
      startColumnBoundary = coordinatesConverter.convertViewPositionToModelPosition(anchorViewRangeStart).column;
    }
    const anchorLineNumber = anchorRange.startLineNumber;
    let renderStartColumn = anchorRange.startColumn;
    let highlightRange = messages2[0].range;
    let forceShowAtRange = null;
    for (const msg of messages2) {
      highlightRange = Range$1.plusRange(highlightRange, msg.range);
      if (msg.range.startLineNumber === anchorLineNumber && msg.range.endLineNumber === anchorLineNumber) {
        renderStartColumn = Math.max(Math.min(renderStartColumn, msg.range.startColumn), startColumnBoundary);
      }
      if (msg.forceShowAtRange) {
        forceShowAtRange = msg.range;
      }
    }
    return {
      showAtPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position$1(anchorLineNumber, anchorRange.startColumn),
      showAtSecondaryPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position$1(anchorLineNumber, renderStartColumn),
      highlightRange
    };
  }
  focus() {
    this._widget.focus();
  }
  scrollUp() {
    this._widget.scrollUp();
  }
  scrollDown() {
    this._widget.scrollDown();
  }
  scrollLeft() {
    this._widget.scrollLeft();
  }
  scrollRight() {
    this._widget.scrollRight();
  }
  pageUp() {
    this._widget.pageUp();
  }
  pageDown() {
    this._widget.pageDown();
  }
  goToTop() {
    this._widget.goToTop();
  }
  goToBottom() {
    this._widget.goToBottom();
  }
};
ContentHoverController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
ContentHoverController = __decorate$I([
  __param$I(1, IInstantiationService),
  __param$I(2, IKeybindingService)
], ContentHoverController);
class HoverResult2 {
  constructor(anchor, messages2, isComplete) {
    this.anchor = anchor;
    this.messages = messages2;
    this.isComplete = isComplete;
  }
  filter(anchor) {
    const filteredMessages = this.messages.filter((m) => m.isValidForHoverAnchor(anchor));
    if (filteredMessages.length === this.messages.length) {
      return this;
    }
    return new FilteredHoverResult(this, this.anchor, filteredMessages, this.isComplete);
  }
}
class FilteredHoverResult extends HoverResult2 {
  constructor(original, anchor, messages2, isComplete) {
    super(anchor, messages2, isComplete);
    this.original = original;
  }
  filter(anchor) {
    return this.original.filter(anchor);
  }
}
class ContentHoverVisibleData {
  constructor(colorPicker2, showAtPosition, showAtSecondaryPosition, preferAbove, stoleFocus, source, isBeforeContent, initialMousePosX, initialMousePosY, disposables) {
    this.colorPicker = colorPicker2;
    this.showAtPosition = showAtPosition;
    this.showAtSecondaryPosition = showAtSecondaryPosition;
    this.preferAbove = preferAbove;
    this.stoleFocus = stoleFocus;
    this.source = source;
    this.isBeforeContent = isBeforeContent;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.disposables = disposables;
    this.closestMouseDistance = void 0;
  }
}
const HORIZONTAL_SCROLLING_BY = 30;
const SCROLLBAR_WIDTH = 10;
const CONTAINER_HEIGHT_PADDING = 6;
let ContentHoverWidget = class ContentHoverWidget2 extends ResizableContentWidget {
  get isColorPickerVisible() {
    var _a3;
    return Boolean((_a3 = this._visibleData) === null || _a3 === void 0 ? void 0 : _a3.colorPicker);
  }
  get isVisibleFromKeyboard() {
    var _a3;
    return ((_a3 = this._visibleData) === null || _a3 === void 0 ? void 0 : _a3.source) === 1;
  }
  get isVisible() {
    var _a3;
    return (_a3 = this._hoverVisibleKey.get()) !== null && _a3 !== void 0 ? _a3 : false;
  }
  get isFocused() {
    var _a3;
    return (_a3 = this._hoverFocusedKey.get()) !== null && _a3 !== void 0 ? _a3 : false;
  }
  constructor(editor2, minimumSize, contextKeyService) {
    super(editor2, minimumSize);
    this._hover = this._register(new HoverWidget());
    this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(contextKeyService);
    this._hoverFocusedKey = EditorContextKeys.hoverFocused.bindTo(contextKeyService);
    append(this._resizableNode.domNode, this._hover.containerDomNode);
    this._resizableNode.domNode.style.zIndex = "50";
    this._register(this._editor.onDidLayoutChange(() => this._layout()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    const focusTracker = this._register(trackFocus(this._resizableNode.domNode));
    this._register(focusTracker.onDidFocus(() => {
      this._hoverFocusedKey.set(true);
    }));
    this._register(focusTracker.onDidBlur(() => {
      this._hoverFocusedKey.set(false);
    }));
    this._setHoverData(void 0);
    this._layout();
    this._editor.addContentWidget(this);
  }
  dispose() {
    var _a3;
    super.dispose();
    (_a3 = this._visibleData) === null || _a3 === void 0 ? void 0 : _a3.disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return ContentHoverWidget2.ID;
  }
  static _applyDimensions(container, width, height) {
    const transformedWidth = typeof width === "number" ? `${width}px` : width;
    const transformedHeight = typeof height === "number" ? `${height}px` : height;
    container.style.width = transformedWidth;
    container.style.height = transformedHeight;
  }
  _setContentsDomNodeDimensions(width, height) {
    const contentsDomNode = this._hover.contentsDomNode;
    return ContentHoverWidget2._applyDimensions(contentsDomNode, width, height);
  }
  _setContainerDomNodeDimensions(width, height) {
    const containerDomNode = this._hover.containerDomNode;
    return ContentHoverWidget2._applyDimensions(containerDomNode, width, height);
  }
  _setHoverWidgetDimensions(width, height) {
    this._setContentsDomNodeDimensions(width, height);
    this._setContainerDomNodeDimensions(width, height);
    this._layoutContentWidget();
  }
  static _applyMaxDimensions(container, width, height) {
    const transformedWidth = typeof width === "number" ? `${width}px` : width;
    const transformedHeight = typeof height === "number" ? `${height}px` : height;
    container.style.maxWidth = transformedWidth;
    container.style.maxHeight = transformedHeight;
  }
  _setHoverWidgetMaxDimensions(width, height) {
    ContentHoverWidget2._applyMaxDimensions(this._hover.contentsDomNode, width, height);
    ContentHoverWidget2._applyMaxDimensions(this._hover.containerDomNode, width, height);
    this._hover.containerDomNode.style.setProperty("--hover-maxWidth", typeof width === "number" ? `${width}px` : width);
    this._layoutContentWidget();
  }
  _hasHorizontalScrollbar() {
    const scrollDimensions = this._hover.scrollbar.getScrollDimensions();
    const hasHorizontalScrollbar = scrollDimensions.scrollWidth > scrollDimensions.width;
    return hasHorizontalScrollbar;
  }
  _adjustContentsBottomPadding() {
    const contentsDomNode = this._hover.contentsDomNode;
    const extraBottomPadding = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;
    if (contentsDomNode.style.paddingBottom !== extraBottomPadding) {
      contentsDomNode.style.paddingBottom = extraBottomPadding;
    }
  }
  _setAdjustedHoverWidgetDimensions(size) {
    this._setHoverWidgetMaxDimensions("none", "none");
    const width = size.width;
    const height = size.height;
    this._setHoverWidgetDimensions(width, height);
    if (this._hasHorizontalScrollbar()) {
      this._adjustContentsBottomPadding();
      this._setContentsDomNodeDimensions(width, height - SCROLLBAR_WIDTH);
    }
  }
  _setResizableNodeMaxDimensions() {
    var _a3, _b3;
    const maxRenderingWidth = (_a3 = this._findMaximumRenderingWidth()) !== null && _a3 !== void 0 ? _a3 : Infinity;
    const maxRenderingHeight = (_b3 = this._findMaximumRenderingHeight()) !== null && _b3 !== void 0 ? _b3 : Infinity;
    this._resizableNode.maxSize = new Dimension(maxRenderingWidth, maxRenderingHeight);
    this._setHoverWidgetMaxDimensions(maxRenderingWidth, maxRenderingHeight);
  }
  _resize(size) {
    var _a3, _b3;
    ContentHoverWidget2._lastDimensions = new Dimension(size.width, size.height);
    this._setAdjustedHoverWidgetDimensions(size);
    this._resizableNode.layout(size.height, size.width);
    this._setResizableNodeMaxDimensions();
    this._hover.scrollbar.scanDomNode();
    this._editor.layoutContentWidget(this);
    (_b3 = (_a3 = this._visibleData) === null || _a3 === void 0 ? void 0 : _a3.colorPicker) === null || _b3 === void 0 ? void 0 : _b3.layout();
  }
  _findAvailableSpaceVertically() {
    var _a3;
    const position = (_a3 = this._visibleData) === null || _a3 === void 0 ? void 0 : _a3.showAtPosition;
    if (!position) {
      return;
    }
    return this._positionPreference === 1 ? this._availableVerticalSpaceAbove(position) : this._availableVerticalSpaceBelow(position);
  }
  _findMaximumRenderingHeight() {
    const availableSpace = this._findAvailableSpaceVertically();
    if (!availableSpace) {
      return;
    }
    let maximumHeight = CONTAINER_HEIGHT_PADDING;
    Array.from(this._hover.contentsDomNode.children).forEach((hoverPart) => {
      maximumHeight += hoverPart.clientHeight;
    });
    if (this._hasHorizontalScrollbar()) {
      maximumHeight += SCROLLBAR_WIDTH;
    }
    return Math.min(availableSpace, maximumHeight);
  }
  _findMaximumRenderingWidth() {
    if (!this._editor || !this._editor.hasModel()) {
      return;
    }
    const bodyBoxWidth = getClientArea(document.body).width;
    const horizontalPadding = 14;
    return bodyBoxWidth - horizontalPadding;
  }
  isMouseGettingCloser(posx, posy) {
    if (!this._visibleData) {
      return false;
    }
    if (typeof this._visibleData.initialMousePosX === "undefined" || typeof this._visibleData.initialMousePosY === "undefined") {
      this._visibleData.initialMousePosX = posx;
      this._visibleData.initialMousePosY = posy;
      return false;
    }
    const widgetRect = getDomNodePagePosition(this.getDomNode());
    if (typeof this._visibleData.closestMouseDistance === "undefined") {
      this._visibleData.closestMouseDistance = computeDistanceFromPointToRectangle(this._visibleData.initialMousePosX, this._visibleData.initialMousePosY, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    }
    const distance = computeDistanceFromPointToRectangle(posx, posy, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    if (distance > this._visibleData.closestMouseDistance + 4) {
      return false;
    }
    this._visibleData.closestMouseDistance = Math.min(this._visibleData.closestMouseDistance, distance);
    return true;
  }
  _setHoverData(hoverData) {
    var _a3;
    (_a3 = this._visibleData) === null || _a3 === void 0 ? void 0 : _a3.disposables.dispose();
    this._visibleData = hoverData;
    this._hoverVisibleKey.set(!!hoverData);
    this._hover.containerDomNode.classList.toggle("hidden", !hoverData);
  }
  _layout() {
    const { fontSize, lineHeight } = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    const contentsDomNode = this._hover.contentsDomNode;
    contentsDomNode.style.fontSize = `${fontSize}px`;
    contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;
    this._updateMaxDimensions();
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _updateContent(node) {
    const contentsDomNode = this._hover.contentsDomNode;
    contentsDomNode.style.paddingBottom = "";
    contentsDomNode.textContent = "";
    contentsDomNode.appendChild(node);
  }
  _layoutContentWidget() {
    this._editor.layoutContentWidget(this);
    this._hover.onContentsChanged();
  }
  _updateMaxDimensions() {
    const height = Math.max(this._editor.getLayoutInfo().height / 4, 250, ContentHoverWidget2._lastDimensions.height);
    const width = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, ContentHoverWidget2._lastDimensions.width);
    this._setHoverWidgetMaxDimensions(width, height);
  }
  _render(node, hoverData) {
    this._setHoverData(hoverData);
    this._updateFont();
    this._updateContent(node);
    this._updateMaxDimensions();
    this.onContentsChanged();
    this._editor.render();
  }
  getPosition() {
    var _a3;
    if (!this._visibleData) {
      return null;
    }
    return {
      position: this._visibleData.showAtPosition,
      secondaryPosition: this._visibleData.showAtSecondaryPosition,
      positionAffinity: this._visibleData.isBeforeContent ? 3 : void 0,
      preference: [
        (_a3 = this._positionPreference) !== null && _a3 !== void 0 ? _a3 : 1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  showAt(node, hoverData) {
    var _a3, _b3;
    if (!this._editor || !this._editor.hasModel()) {
      return;
    }
    this._render(node, hoverData);
    const widgetHeight = getTotalHeight(this._hover.containerDomNode);
    const widgetPosition = hoverData.showAtPosition;
    this._positionPreference = (_a3 = this._findPositionPreference(widgetHeight, widgetPosition)) !== null && _a3 !== void 0 ? _a3 : 1;
    this.onContentsChanged();
    if (hoverData.stoleFocus) {
      this._hover.containerDomNode.focus();
    }
    (_b3 = hoverData.colorPicker) === null || _b3 === void 0 ? void 0 : _b3.layout();
  }
  hide() {
    if (!this._visibleData) {
      return;
    }
    const stoleFocus = this._visibleData.stoleFocus || this._hoverFocusedKey.get();
    this._setHoverData(void 0);
    this._resizableNode.maxSize = new Dimension(Infinity, Infinity);
    this._resizableNode.clearSashHoverState();
    this._hoverFocusedKey.set(false);
    this._editor.layoutContentWidget(this);
    if (stoleFocus) {
      this._editor.focus();
    }
  }
  _removeConstraintsRenderNormally() {
    const layoutInfo = this._editor.getLayoutInfo();
    this._resizableNode.layout(layoutInfo.height, layoutInfo.width);
    this._setHoverWidgetDimensions("auto", "auto");
  }
  _adjustHoverHeightForScrollbar(height) {
    var _a3;
    const containerDomNode = this._hover.containerDomNode;
    const contentsDomNode = this._hover.contentsDomNode;
    const maxRenderingHeight = (_a3 = this._findMaximumRenderingHeight()) !== null && _a3 !== void 0 ? _a3 : Infinity;
    this._setContainerDomNodeDimensions(getTotalWidth(containerDomNode), Math.min(maxRenderingHeight, height));
    this._setContentsDomNodeDimensions(getTotalWidth(contentsDomNode), Math.min(maxRenderingHeight, height - SCROLLBAR_WIDTH));
  }
  setMinimumDimensions(dimensions) {
    this._resizableNode.minSize = dimensions;
  }
  onContentsChanged() {
    var _a3;
    this._removeConstraintsRenderNormally();
    const containerDomNode = this._hover.containerDomNode;
    let height = getTotalHeight(containerDomNode);
    let width = getTotalWidth(containerDomNode);
    this._resizableNode.layout(height, width);
    this._setHoverWidgetDimensions(width, height);
    height = getTotalHeight(containerDomNode);
    width = getTotalWidth(containerDomNode);
    this._resizableNode.layout(height, width);
    if (this._hasHorizontalScrollbar()) {
      this._adjustContentsBottomPadding();
      this._adjustHoverHeightForScrollbar(height);
    }
    if ((_a3 = this._visibleData) === null || _a3 === void 0 ? void 0 : _a3.showAtPosition) {
      const widgetHeight = getTotalHeight(this._hover.containerDomNode);
      this._positionPreference = this._findPositionPreference(widgetHeight, this._visibleData.showAtPosition);
    }
    this._layoutContentWidget();
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  scrollUp() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - fontInfo.lineHeight });
  }
  scrollDown() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + fontInfo.lineHeight });
  }
  scrollLeft() {
    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft - HORIZONTAL_SCROLLING_BY });
  }
  scrollRight() {
    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft + HORIZONTAL_SCROLLING_BY });
  }
  pageUp() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - scrollHeight });
  }
  pageDown() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + scrollHeight });
  }
  goToTop() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });
  }
  goToBottom() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });
  }
};
ContentHoverWidget.ID = "editor.contrib.resizableContentHoverWidget";
ContentHoverWidget._lastDimensions = new Dimension(0, 0);
ContentHoverWidget = __decorate$I([
  __param$I(2, IContextKeyService)
], ContentHoverWidget);
let EditorHoverStatusBar = class EditorHoverStatusBar2 extends Disposable {
  get hasContent() {
    return this._hasContent;
  }
  constructor(_keybindingService) {
    super();
    this._keybindingService = _keybindingService;
    this._hasContent = false;
    this.hoverElement = $$5("div.hover-row.status-bar");
    this.actionsElement = append(this.hoverElement, $$5("div.actions"));
  }
  addAction(actionOptions) {
    const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
    const keybindingLabel = keybinding ? keybinding.getLabel() : null;
    this._hasContent = true;
    return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));
  }
  append(element) {
    const result = append(this.actionsElement, element);
    this._hasContent = true;
    return result;
  }
};
EditorHoverStatusBar = __decorate$I([
  __param$I(0, IKeybindingService)
], EditorHoverStatusBar);
class ContentHoverComputer {
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor = value;
  }
  get shouldFocus() {
    return this._shouldFocus;
  }
  set shouldFocus(value) {
    this._shouldFocus = value;
  }
  get source() {
    return this._source;
  }
  set source(value) {
    this._source = value;
  }
  get insistOnKeepingHoverVisible() {
    return this._insistOnKeepingHoverVisible;
  }
  set insistOnKeepingHoverVisible(value) {
    this._insistOnKeepingHoverVisible = value;
  }
  constructor(_editor, _participants) {
    this._editor = _editor;
    this._participants = _participants;
    this._anchor = null;
    this._shouldFocus = false;
    this._source = 0;
    this._insistOnKeepingHoverVisible = false;
  }
  static _getLineDecorations(editor2, anchor) {
    if (anchor.type !== 1 && !anchor.supportsMarkerHover) {
      return [];
    }
    const model = editor2.getModel();
    const lineNumber = anchor.range.startLineNumber;
    if (lineNumber > model.getLineCount()) {
      return [];
    }
    const maxColumn = model.getLineMaxColumn(lineNumber);
    return editor2.getLineDecorations(lineNumber).filter((d) => {
      if (d.options.isWholeLine) {
        return true;
      }
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      if (d.options.showIfCollapsed) {
        if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) {
          return false;
        }
      } else {
        if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {
          return false;
        }
      }
      return true;
    });
  }
  computeAsync(token) {
    const anchor = this._anchor;
    if (!this._editor.hasModel() || !anchor) {
      return AsyncIterableObject.EMPTY;
    }
    const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, anchor);
    return AsyncIterableObject.merge(this._participants.map((participant) => {
      if (!participant.computeAsync) {
        return AsyncIterableObject.EMPTY;
      }
      return participant.computeAsync(anchor, lineDecorations, token);
    }));
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor) {
      return [];
    }
    const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, this._anchor);
    let result = [];
    for (const participant of this._participants) {
      result = result.concat(participant.computeSync(this._anchor, lineDecorations));
    }
    return coalesce(result);
  }
}
function computeDistanceFromPointToRectangle(pointX, pointY, left, top, width, height) {
  const x = left + width / 2;
  const y = top + height / 2;
  const dx = Math.max(Math.abs(pointX - x) - width / 2, 0);
  const dy = Math.max(Math.abs(pointY - y) - height / 2, 0);
  return Math.sqrt(dx * dx + dy * dy);
}
const $$4 = $$8;
class MarginHoverWidget extends Disposable {
  constructor(editor2, languageService, openerService) {
    super();
    this._renderDisposeables = this._register(new DisposableStore());
    this._editor = editor2;
    this._isVisible = false;
    this._messages = [];
    this._hover = this._register(new HoverWidget());
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    this._markdownRenderer = this._register(new MarkdownRenderer({ editor: this._editor }, languageService, openerService));
    this._computer = new MarginHoverComputer(this._editor);
    this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
    this._register(this._hoverOperation.onResult((result) => {
      this._withResult(result.value);
    }));
    this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return MarginHoverWidget.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _onModelDecorationsChanged() {
    if (this._isVisible) {
      this._hoverOperation.cancel();
      this._hoverOperation.start(
        0
        /* HoverStartMode.Delayed */
      );
    }
  }
  startShowingAt(lineNumber) {
    if (this._computer.lineNumber === lineNumber) {
      return;
    }
    this._hoverOperation.cancel();
    this.hide();
    this._computer.lineNumber = lineNumber;
    this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    );
  }
  hide() {
    this._computer.lineNumber = -1;
    this._hoverOperation.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
  }
  _withResult(result) {
    this._messages = result;
    if (this._messages.length > 0) {
      this._renderMessages(this._computer.lineNumber, this._messages);
    } else {
      this.hide();
    }
  }
  _renderMessages(lineNumber, messages2) {
    this._renderDisposeables.clear();
    const fragment = document.createDocumentFragment();
    for (const msg of messages2) {
      const markdownHoverElement = $$4("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $$4("div.hover-contents"));
      const renderedContents = this._renderDisposeables.add(this._markdownRenderer.render(msg.value));
      hoverContentsElement.appendChild(renderedContents.element);
      fragment.appendChild(markdownHoverElement);
    }
    this._updateContents(fragment);
    this._showAt(lineNumber);
  }
  _updateContents(node) {
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this._updateFont();
  }
  _showAt(lineNumber) {
    if (!this._isVisible) {
      this._isVisible = true;
      this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    }
    const editorLayout = this._editor.getLayoutInfo();
    const topForLineNumber = this._editor.getTopForLineNumber(lineNumber);
    const editorScrollTop = this._editor.getScrollTop();
    const lineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    const nodeHeight = this._hover.containerDomNode.clientHeight;
    const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
    this._hover.containerDomNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;
    this._hover.containerDomNode.style.top = `${Math.max(Math.round(top), 0)}px`;
  }
}
MarginHoverWidget.ID = "editor.contrib.modesGlyphHoverWidget";
class MarginHoverComputer {
  get lineNumber() {
    return this._lineNumber;
  }
  set lineNumber(value) {
    this._lineNumber = value;
  }
  constructor(_editor) {
    this._editor = _editor;
    this._lineNumber = -1;
  }
  computeSync() {
    const toHoverMessage = (contents) => {
      return {
        value: contents
      };
    };
    const lineDecorations = this._editor.getLineDecorations(this._lineNumber);
    const result = [];
    if (!lineDecorations) {
      return result;
    }
    for (const d of lineDecorations) {
      if (!d.options.glyphMarginClassName) {
        continue;
      }
      const hoverMessage = d.options.glyphMarginHoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      result.push(...asArray(hoverMessage).map(toHoverMessage));
    }
    return result;
  }
}
var __awaiter$A = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class HoverProviderResult {
  constructor(provider, hover2, ordinal) {
    this.provider = provider;
    this.hover = hover2;
    this.ordinal = ordinal;
  }
}
function executeProvider(provider, ordinal, model, position, token) {
  return __awaiter$A(this, void 0, void 0, function* () {
    try {
      const result = yield Promise.resolve(provider.provideHover(model, position, token));
      if (result && isValid(result)) {
        return new HoverProviderResult(provider, result, ordinal);
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
    return void 0;
  });
}
function getHover(registry, model, position, token) {
  const providers = registry.ordered(model);
  const promises = providers.map((provider, index2) => executeProvider(provider, index2, model, position, token));
  return AsyncIterableObject.fromPromises(promises).coalesce();
}
function getHoverPromise(registry, model, position, token) {
  return getHover(registry, model, position, token).map((item) => item.hover).toPromise();
}
registerModelAndPositionCommand("_executeHoverProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getHoverPromise(languageFeaturesService.hoverProvider, model, position, CancellationToken.None);
});
function isValid(result) {
  const hasRange = typeof result.range !== "undefined";
  const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
  return hasRange && hasHtmlContent;
}
var __decorate$H = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$H = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const $$3 = $$8;
class MarkdownHover {
  constructor(owner, range, contents, isBeforeContent, ordinal) {
    this.owner = owner;
    this.range = range;
    this.contents = contents;
    this.isBeforeContent = isBeforeContent;
    this.ordinal = ordinal;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
}
let MarkdownHoverParticipant = class MarkdownHoverParticipant2 {
  constructor(_editor, _languageService, _openerService, _configurationService, _languageFeaturesService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this.hoverOrdinal = 3;
  }
  createLoadingMessage(anchor) {
    return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("modesContentHover.loading", "Loading..."))], false, 2e3);
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    let index2 = 1e3;
    const lineLength = model.getLineLength(lineNumber);
    const languageId = model.getLanguageIdAtPosition(anchor.range.startLineNumber, anchor.range.startColumn);
    const stopRenderingLineAfter = this._editor.getOption(
      115
      /* EditorOption.stopRenderingLineAfter */
    );
    const maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: languageId
    });
    let stopRenderingMessage = false;
    if (stopRenderingLineAfter >= 0 && lineLength > stopRenderingLineAfter && anchor.range.startColumn >= stopRenderingLineAfter) {
      stopRenderingMessage = true;
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize("stopped rendering", "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
      }], false, index2++));
    }
    if (!stopRenderingMessage && typeof maxTokenizationLineLength === "number" && lineLength >= maxTokenizationLineLength) {
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
      }], false, index2++));
    }
    let isBeforeContent = false;
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const hoverMessage = d.options.hoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      if (d.options.beforeContentClassName) {
        isBeforeContent = true;
      }
      const range = new Range$1(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkdownHover(this, range, asArray(hoverMessage), isBeforeContent, index2++));
    }
    return result;
  }
  computeAsync(anchor, lineDecorations, token) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return AsyncIterableObject.EMPTY;
    }
    const model = this._editor.getModel();
    if (!this._languageFeaturesService.hoverProvider.has(model)) {
      return AsyncIterableObject.EMPTY;
    }
    const position = new Position$1(anchor.range.startLineNumber, anchor.range.startColumn);
    return getHover(this._languageFeaturesService.hoverProvider, model, position, token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => {
      const rng = item.hover.range ? Range$1.lift(item.hover.range) : anchor.range;
      return new MarkdownHover(this, rng, item.hover.contents, false, item.ordinal);
    });
  }
  renderHoverParts(context, hoverParts) {
    return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
  }
};
MarkdownHoverParticipant = __decorate$H([
  __param$H(1, ILanguageService),
  __param$H(2, IOpenerService),
  __param$H(3, IConfigurationService),
  __param$H(4, ILanguageFeaturesService)
], MarkdownHoverParticipant);
function renderMarkdownHovers(context, hoverParts, editor2, languageService, openerService) {
  hoverParts.sort((a, b) => a.ordinal - b.ordinal);
  const disposables = new DisposableStore();
  for (const hoverPart of hoverParts) {
    for (const contents of hoverPart.contents) {
      if (isEmptyMarkdownString(contents)) {
        continue;
      }
      const markdownHoverElement = $$3("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $$3("div.hover-contents"));
      const renderer = disposables.add(new MarkdownRenderer({ editor: editor2 }, languageService, openerService));
      disposables.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        context.onContentsChanged();
      }));
      const renderedContents = disposables.add(renderer.render(contents));
      hoverContentsElement.appendChild(renderedContents.element);
      context.fragment.appendChild(markdownHoverElement);
    }
  }
  return disposables;
}
var __decorate$G = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$G = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
class MarkerCoordinate {
  constructor(marker, index2, total) {
    this.marker = marker;
    this.index = index2;
    this.total = total;
  }
}
let MarkerList = class MarkerList2 {
  constructor(resourceFilter, _markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._dispoables = new DisposableStore();
    this._markers = [];
    this._nextIdx = -1;
    if (URI$1.isUri(resourceFilter)) {
      this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
    } else if (resourceFilter) {
      this._resourceFilter = resourceFilter;
    }
    const compareOrder = this._configService.getValue("problems.sortOrder");
    const compareMarker = (a, b) => {
      let res = compare(a.resource.toString(), b.resource.toString());
      if (res === 0) {
        if (compareOrder === "position") {
          res = Range$1.compareRangesUsingStarts(a, b) || MarkerSeverity.compare(a.severity, b.severity);
        } else {
          res = MarkerSeverity.compare(a.severity, b.severity) || Range$1.compareRangesUsingStarts(a, b);
        }
      }
      return res;
    };
    const updateMarker = () => {
      this._markers = this._markerService.read({
        resource: URI$1.isUri(resourceFilter) ? resourceFilter : void 0,
        severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
      });
      if (typeof resourceFilter === "function") {
        this._markers = this._markers.filter((m) => this._resourceFilter(m.resource));
      }
      this._markers.sort(compareMarker);
    };
    updateMarker();
    this._dispoables.add(_markerService.onMarkerChanged((uris) => {
      if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
        updateMarker();
        this._nextIdx = -1;
        this._onDidChange.fire();
      }
    }));
  }
  dispose() {
    this._dispoables.dispose();
    this._onDidChange.dispose();
  }
  matches(uri) {
    if (!this._resourceFilter && !uri) {
      return true;
    }
    if (!this._resourceFilter || !uri) {
      return false;
    }
    return this._resourceFilter(uri);
  }
  get selected() {
    const marker = this._markers[this._nextIdx];
    return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(model, position, fwd) {
    let found = false;
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === model.uri.toString());
    if (idx < 0) {
      idx = binarySearch(this._markers, { resource: model.uri }, (a, b) => compare(a.resource.toString(), b.resource.toString()));
      if (idx < 0) {
        idx = ~idx;
      }
    }
    for (let i = idx; i < this._markers.length; i++) {
      let range = Range$1.lift(this._markers[i]);
      if (range.isEmpty()) {
        const word = model.getWordAtPosition(range.getStartPosition());
        if (word) {
          range = new Range$1(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);
        }
      }
      if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {
        this._nextIdx = i;
        found = true;
        break;
      }
      if (this._markers[i].resource.toString() !== model.uri.toString()) {
        break;
      }
    }
    if (!found) {
      this._nextIdx = fwd ? 0 : this._markers.length - 1;
    }
    if (this._nextIdx < 0) {
      this._nextIdx = this._markers.length - 1;
    }
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(fwd, model, position) {
    if (this._markers.length === 0) {
      return false;
    }
    const oldIdx = this._nextIdx;
    if (this._nextIdx === -1) {
      this._initIdx(model, position, fwd);
    } else if (fwd) {
      this._nextIdx = (this._nextIdx + 1) % this._markers.length;
    } else if (!fwd) {
      this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
    }
    if (oldIdx !== this._nextIdx) {
      return true;
    }
    return false;
  }
  find(uri, position) {
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
    if (idx < 0) {
      return void 0;
    }
    for (; idx < this._markers.length; idx++) {
      if (Range$1.containsPosition(this._markers[idx], position)) {
        return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
      }
    }
    return void 0;
  }
};
MarkerList = __decorate$G([
  __param$G(1, IMarkerService),
  __param$G(2, IConfigurationService)
], MarkerList);
const IMarkerNavigationService = createDecorator("IMarkerNavigationService");
let MarkerNavigationService = class MarkerNavigationService2 {
  constructor(_markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._provider = new LinkedList();
  }
  registerProvider(provider) {
    const remove = this._provider.unshift(provider);
    return toDisposable(() => remove());
  }
  getMarkerList(resource) {
    for (const provider of this._provider) {
      const result = provider.getMarkerList(resource);
      if (result) {
        return result;
      }
    }
    return new MarkerList(resource, this._markerService, this._configService);
  }
};
MarkerNavigationService = __decorate$G([
  __param$G(0, IMarkerService),
  __param$G(1, IConfigurationService)
], MarkerNavigationService);
registerSingleton(
  IMarkerNavigationService,
  MarkerNavigationService,
  1
  /* InstantiationType.Delayed */
);
const gotoErrorWidget = "";
const severityIcon = "";
var SeverityIcon;
(function(SeverityIcon2) {
  function className(severity) {
    switch (severity) {
      case Severity.Ignore:
        return "severity-ignore " + ThemeIcon.asClassName(Codicon.info);
      case Severity.Info:
        return ThemeIcon.asClassName(Codicon.info);
      case Severity.Warning:
        return ThemeIcon.asClassName(Codicon.warning);
      case Severity.Error:
        return ThemeIcon.asClassName(Codicon.error);
      default:
        return "";
    }
  }
  SeverityIcon2.className = className;
})(SeverityIcon || (SeverityIcon = {}));
var __decorate$F = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$F = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
class MessageWidget {
  constructor(parent, editor2, onRelatedInformation, _openerService, _labelService) {
    this._openerService = _openerService;
    this._labelService = _labelService;
    this._lines = 0;
    this._longestLineLength = 0;
    this._relatedDiagnostics = /* @__PURE__ */ new WeakMap();
    this._disposables = new DisposableStore();
    this._editor = editor2;
    const domNode = document.createElement("div");
    domNode.className = "descriptioncontainer";
    this._messageBlock = document.createElement("div");
    this._messageBlock.classList.add("message");
    this._messageBlock.setAttribute("aria-live", "assertive");
    this._messageBlock.setAttribute("role", "alert");
    domNode.appendChild(this._messageBlock);
    this._relatedBlock = document.createElement("div");
    domNode.appendChild(this._relatedBlock);
    this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
      event.preventDefault();
      const related = this._relatedDiagnostics.get(event.target);
      if (related) {
        onRelatedInformation(related);
      }
    }));
    this._scrollable = new ScrollableElement(domNode, {
      horizontal: 1,
      vertical: 1,
      useShadows: false,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    });
    parent.appendChild(this._scrollable.getDomNode());
    this._disposables.add(this._scrollable.onScroll((e) => {
      domNode.style.left = `-${e.scrollLeft}px`;
      domNode.style.top = `-${e.scrollTop}px`;
    }));
    this._disposables.add(this._scrollable);
  }
  dispose() {
    dispose(this._disposables);
  }
  update(marker) {
    const { source, message, relatedInformation, code } = marker;
    let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + "()".length;
    if (code) {
      if (typeof code === "string") {
        sourceAndCodeLength += code.length;
      } else {
        sourceAndCodeLength += code.value.length;
      }
    }
    const lines = splitLines(message);
    this._lines = lines.length;
    this._longestLineLength = 0;
    for (const line of lines) {
      this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
    }
    clearNode(this._messageBlock);
    this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
    this._editor.applyFontInfo(this._messageBlock);
    let lastLineElement = this._messageBlock;
    for (const line of lines) {
      lastLineElement = document.createElement("div");
      lastLineElement.innerText = line;
      if (line === "") {
        lastLineElement.style.height = this._messageBlock.style.lineHeight;
      }
      this._messageBlock.appendChild(lastLineElement);
    }
    if (source || code) {
      const detailsElement = document.createElement("span");
      detailsElement.classList.add("details");
      lastLineElement.appendChild(detailsElement);
      if (source) {
        const sourceElement = document.createElement("span");
        sourceElement.innerText = source;
        sourceElement.classList.add("source");
        detailsElement.appendChild(sourceElement);
      }
      if (code) {
        if (typeof code === "string") {
          const codeElement = document.createElement("span");
          codeElement.innerText = `(${code})`;
          codeElement.classList.add("code");
          detailsElement.appendChild(codeElement);
        } else {
          this._codeLink = $$8("a.code-link");
          this._codeLink.setAttribute("href", `${code.target.toString()}`);
          this._codeLink.onclick = (e) => {
            this._openerService.open(code.target, { allowCommands: true });
            e.preventDefault();
            e.stopPropagation();
          };
          const codeElement = append(this._codeLink, $$8("span"));
          codeElement.innerText = code.value;
          detailsElement.appendChild(this._codeLink);
        }
      }
    }
    clearNode(this._relatedBlock);
    this._editor.applyFontInfo(this._relatedBlock);
    if (isNonEmptyArray(relatedInformation)) {
      const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
      relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(
        65
        /* EditorOption.lineHeight */
      ) * 0.66)}px`;
      this._lines += 1;
      for (const related of relatedInformation) {
        const container = document.createElement("div");
        const relatedResource = document.createElement("a");
        relatedResource.classList.add("filename");
        relatedResource.innerText = `${this._labelService.getUriBasenameLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
        relatedResource.title = this._labelService.getUriLabel(related.resource);
        this._relatedDiagnostics.set(relatedResource, related);
        const relatedMessage = document.createElement("span");
        relatedMessage.innerText = related.message;
        container.appendChild(relatedResource);
        container.appendChild(relatedMessage);
        this._lines += 1;
        relatedInformationNode.appendChild(container);
      }
    }
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);
    const scrollHeight = fontInfo.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });
  }
  layout(height, width) {
    this._scrollable.getDomNode().style.height = `${height}px`;
    this._scrollable.getDomNode().style.width = `${width}px`;
    this._scrollable.setScrollDimensions({ width, height });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(marker) {
    let severityLabel = "";
    switch (marker.severity) {
      case MarkerSeverity.Error:
        severityLabel = localize("Error", "Error");
        break;
      case MarkerSeverity.Warning:
        severityLabel = localize("Warning", "Warning");
        break;
      case MarkerSeverity.Info:
        severityLabel = localize("Info", "Info");
        break;
      case MarkerSeverity.Hint:
        severityLabel = localize("Hint", "Hint");
        break;
    }
    let ariaLabel = localize("marker aria", "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
    const model = this._editor.getModel();
    if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) {
      const lineContent = model.getLineContent(marker.startLineNumber);
      ariaLabel = `${lineContent}, ${ariaLabel}`;
    }
    return ariaLabel;
  }
}
let MarkerNavigationWidget = class MarkerNavigationWidget2 extends PeekViewWidget {
  constructor(editor2, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {
    super(editor2, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);
    this._themeService = _themeService;
    this._openerService = _openerService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._labelService = _labelService;
    this._callOnDispose = new DisposableStore();
    this._onDidSelectRelatedInformation = new Emitter();
    this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
    this._severity = MarkerSeverity.Warning;
    this._backgroundColor = Color$1.white;
    this._applyTheme(_themeService.getColorTheme());
    this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this.create();
  }
  _applyTheme(theme) {
    this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
    let colorId = editorMarkerNavigationError;
    let headerBackground = editorMarkerNavigationErrorHeader;
    if (this._severity === MarkerSeverity.Warning) {
      colorId = editorMarkerNavigationWarning;
      headerBackground = editorMarkerNavigationWarningHeader;
    } else if (this._severity === MarkerSeverity.Info) {
      colorId = editorMarkerNavigationInfo;
      headerBackground = editorMarkerNavigationInfoHeader;
    }
    const frameColor = theme.getColor(colorId);
    const headerBg = theme.getColor(headerBackground);
    this.style({
      arrowColor: frameColor,
      frameColor,
      headerBackgroundColor: headerBg,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  _applyStyles() {
    if (this._parentContainer) {
      this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
    }
    super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose();
    super.dispose();
  }
  focus() {
    this._parentContainer.focus();
  }
  _fillHead(container) {
    super._fillHead(container);
    this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((e) => this.editor.focus()));
    const actions = [];
    const menu = this._menuService.createMenu(MarkerNavigationWidget2.TitleMenu, this._contextKeyService);
    createAndFillInActionBarActions(menu, void 0, actions);
    this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });
    menu.dispose();
  }
  _fillTitleIcon(container) {
    this._icon = append(container, $$8(""));
  }
  _fillBody(container) {
    this._parentContainer = container;
    container.classList.add("marker-widget");
    this._parentContainer.tabIndex = 0;
    this._parentContainer.setAttribute("role", "tooltip");
    this._container = document.createElement("div");
    container.appendChild(this._container);
    this._message = new MessageWidget(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);
    this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(marker, markerIdx, markerCount) {
    this._container.classList.remove("stale");
    this._message.update(marker);
    this._severity = marker.severity;
    this._applyTheme(this._themeService.getColorTheme());
    const range = Range$1.lift(marker);
    const editorPosition = this.editor.getPosition();
    const position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();
    super.show(position, this.computeRequiredHeight());
    const model = this.editor.getModel();
    if (model) {
      const detail = markerCount > 1 ? localize("problems", "{0} of {1} problems", markerIdx, markerCount) : localize("change", "{0} of {1} problem", markerIdx, markerCount);
      this.setTitle(basename(model.uri), detail);
    }
    this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
    this.editor.revealPositionNearTop(
      position,
      0
      /* ScrollType.Smooth */
    );
    this.editor.focus();
  }
  updateMarker(marker) {
    this._container.classList.remove("stale");
    this._message.update(marker);
  }
  showStale() {
    this._container.classList.add("stale");
    this._relayout();
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._heightInPixel = heightInPixel;
    this._message.layout(heightInPixel, widthInPixel);
    this._container.style.height = `${heightInPixel}px`;
  }
  _onWidth(widthInPixel) {
    this._message.layout(this._heightInPixel, widthInPixel);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
};
MarkerNavigationWidget.TitleMenu = new MenuId("gotoErrorTitleMenu");
MarkerNavigationWidget = __decorate$F([
  __param$F(1, IThemeService),
  __param$F(2, IOpenerService),
  __param$F(3, IMenuService),
  __param$F(4, IInstantiationService),
  __param$F(5, IContextKeyService),
  __param$F(6, ILabelService)
], MarkerNavigationWidget);
const errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
const warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
const infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
const editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", { dark: errorDefault, light: errorDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationError", "Editor marker navigation widget error color."));
const editorMarkerNavigationErrorHeader = registerColor("editorMarkerNavigationError.headerBackground", { dark: transparent(editorMarkerNavigationError, 0.1), light: transparent(editorMarkerNavigationError, 0.1), hcDark: null, hcLight: null }, localize("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background."));
const editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", { dark: warningDefault, light: warningDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationWarning", "Editor marker navigation widget warning color."));
const editorMarkerNavigationWarningHeader = registerColor("editorMarkerNavigationWarning.headerBackground", { dark: transparent(editorMarkerNavigationWarning, 0.1), light: transparent(editorMarkerNavigationWarning, 0.1), hcDark: "#0C141F", hcLight: transparent(editorMarkerNavigationWarning, 0.2) }, localize("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background."));
const editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", { dark: infoDefault, light: infoDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationInfo", "Editor marker navigation widget info color."));
const editorMarkerNavigationInfoHeader = registerColor("editorMarkerNavigationInfo.headerBackground", { dark: transparent(editorMarkerNavigationInfo, 0.1), light: transparent(editorMarkerNavigationInfo, 0.1), hcDark: null, hcLight: null }, localize("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background."));
const editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, localize("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
var __decorate$E = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$E = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$z = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let MarkerController = class MarkerController2 {
  static get(editor2) {
    return editor2.getContribution(MarkerController2.ID);
  }
  constructor(editor2, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
    this._markerNavigationService = _markerNavigationService;
    this._contextKeyService = _contextKeyService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._sessionDispoables = new DisposableStore();
    this._editor = editor2;
    this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp();
    this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset();
    this._sessionDispoables.clear();
    this._widget = void 0;
    this._model = void 0;
  }
  _getOrCreateModel(uri) {
    if (this._model && this._model.matches(uri)) {
      return this._model;
    }
    let reusePosition = false;
    if (this._model) {
      reusePosition = true;
      this._cleanUp();
    }
    this._model = this._markerNavigationService.getMarkerList(uri);
    if (reusePosition) {
      this._model.move(true, this._editor.getModel(), this._editor.getPosition());
    }
    this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
    this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
    this._widgetVisible.set(true);
    this._sessionDispoables.add(this._model);
    this._sessionDispoables.add(this._widget);
    this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
      var _a3, _b3, _c3;
      if (!((_a3 = this._model) === null || _a3 === void 0 ? void 0 : _a3.selected) || !Range$1.containsPosition((_b3 = this._model) === null || _b3 === void 0 ? void 0 : _b3.selected.marker, e.position)) {
        (_c3 = this._model) === null || _c3 === void 0 ? void 0 : _c3.resetIndex();
      }
    }));
    this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model) {
        return;
      }
      const info = this._model.find(this._editor.getModel().uri, this._widget.position);
      if (info) {
        this._widget.updateMarker(info.marker);
      } else {
        this._widget.showStale();
      }
    }));
    this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
      this._editorService.openCodeEditor({
        resource: related.resource,
        options: { pinned: true, revealIfOpened: true, selection: Range$1.lift(related).collapseToStart() }
      }, this._editor);
      this.close(false);
    }));
    this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
    return this._model;
  }
  close(focusEditor = true) {
    this._cleanUp();
    if (focusEditor) {
      this._editor.focus();
    }
  }
  showAtMarker(marker) {
    if (this._editor.hasModel()) {
      const model = this._getOrCreateModel(this._editor.getModel().uri);
      model.resetIndex();
      model.move(true, this._editor.getModel(), new Position$1(marker.startLineNumber, marker.startColumn));
      if (model.selected) {
        this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
      }
    }
  }
  nagivate(next, multiFile) {
    var _a3, _b3;
    return __awaiter$z(this, void 0, void 0, function* () {
      if (this._editor.hasModel()) {
        const model = this._getOrCreateModel(multiFile ? void 0 : this._editor.getModel().uri);
        model.move(next, this._editor.getModel(), this._editor.getPosition());
        if (!model.selected) {
          return;
        }
        if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
          this._cleanUp();
          const otherEditor = yield this._editorService.openCodeEditor({
            resource: model.selected.marker.resource,
            options: { pinned: false, revealIfOpened: true, selectionRevealType: 2, selection: model.selected.marker }
          }, this._editor);
          if (otherEditor) {
            (_a3 = MarkerController2.get(otherEditor)) === null || _a3 === void 0 ? void 0 : _a3.close();
            (_b3 = MarkerController2.get(otherEditor)) === null || _b3 === void 0 ? void 0 : _b3.nagivate(next, multiFile);
          }
        } else {
          this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
        }
      }
    });
  }
};
MarkerController.ID = "editor.contrib.markerController";
MarkerController = __decorate$E([
  __param$E(1, IMarkerNavigationService),
  __param$E(2, IContextKeyService),
  __param$E(3, ICodeEditorService),
  __param$E(4, IInstantiationService)
], MarkerController);
class MarkerNavigationAction extends EditorAction {
  constructor(_next, _multiFile, opts) {
    super(opts);
    this._next = _next;
    this._multiFile = _multiFile;
  }
  run(_accessor, editor2) {
    var _a3;
    return __awaiter$z(this, void 0, void 0, function* () {
      if (editor2.hasModel()) {
        (_a3 = MarkerController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.nagivate(this._next, this._multiFile);
      }
    });
  }
}
class NextMarkerAction extends MarkerNavigationAction {
  constructor() {
    super(true, false, {
      id: NextMarkerAction.ID,
      label: NextMarkerAction.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: NextMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-next", Codicon.arrowDown, localize("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
}
NextMarkerAction.ID = "editor.action.marker.next";
NextMarkerAction.LABEL = localize("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
class PrevMarkerAction extends MarkerNavigationAction {
  constructor() {
    super(false, false, {
      id: PrevMarkerAction.ID,
      label: PrevMarkerAction.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 512 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: PrevMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-previous", Codicon.arrowUp, localize("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
}
PrevMarkerAction.ID = "editor.action.marker.prev";
PrevMarkerAction.LABEL = localize("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
class NextMarkerInFilesAction extends MarkerNavigationAction {
  constructor() {
    super(true, true, {
      id: "editor.action.marker.nextInFiles",
      label: localize("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
}
class PrevMarkerInFilesAction extends MarkerNavigationAction {
  constructor() {
    super(false, true, {
      id: "editor.action.marker.prevInFiles",
      label: localize("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
}
registerEditorContribution(
  MarkerController.ID,
  MarkerController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
registerEditorAction(NextMarkerInFilesAction);
registerEditorAction(PrevMarkerInFilesAction);
const CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
const MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
registerEditorCommand(new MarkerCommand({
  id: "closeMarkersNavigation",
  precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
  handler: (x) => x.close(),
  kbOpts: {
    weight: 100 + 50,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
var __decorate$D = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$D = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const $$2 = $$8;
class MarkerHover {
  constructor(owner, range, marker) {
    this.owner = owner;
    this.range = range;
    this.marker = marker;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
}
const markerCodeActionTrigger = {
  type: 1,
  filter: { include: CodeActionKind$1.QuickFix },
  triggerAction: CodeActionTriggerSource.QuickFixHover
};
let MarkerHoverParticipant = class MarkerHoverParticipant2 {
  constructor(_editor, _markerDecorationsService, _openerService, _languageFeaturesService) {
    this._editor = _editor;
    this._markerDecorationsService = _markerDecorationsService;
    this._openerService = _openerService;
    this._languageFeaturesService = _languageFeaturesService;
    this.hoverOrdinal = 1;
    this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1 && !anchor.supportsMarkerHover) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const marker = this._markerDecorationsService.getMarker(model.uri, d);
      if (!marker) {
        continue;
      }
      const range = new Range$1(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkerHover(this, range, marker));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    if (!hoverParts.length) {
      return Disposable.None;
    }
    const disposables = new DisposableStore();
    hoverParts.forEach((msg) => context.fragment.appendChild(this.renderMarkerHover(msg, disposables)));
    const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];
    this.renderMarkerStatusbar(context, markerHoverForStatusbar, disposables);
    return disposables;
  }
  renderMarkerHover(markerHover, disposables) {
    const hoverElement = $$2("div.hover-row");
    const markerElement = append(hoverElement, $$2("div.marker.hover-contents"));
    const { source, message, code, relatedInformation } = markerHover.marker;
    this._editor.applyFontInfo(markerElement);
    const messageElement = append(markerElement, $$2("span"));
    messageElement.style.whiteSpace = "pre-wrap";
    messageElement.innerText = message;
    if (source || code) {
      if (code && typeof code !== "string") {
        const sourceAndCodeElement = $$2("span");
        if (source) {
          const sourceElement = append(sourceAndCodeElement, $$2("span"));
          sourceElement.innerText = source;
        }
        const codeLink = append(sourceAndCodeElement, $$2("a.code-link"));
        codeLink.setAttribute("href", code.target.toString());
        disposables.add(addDisposableListener(codeLink, "click", (e) => {
          this._openerService.open(code.target, { allowCommands: true });
          e.preventDefault();
          e.stopPropagation();
        }));
        const codeElement = append(codeLink, $$2("span"));
        codeElement.innerText = code.value;
        const detailsElement = append(markerElement, sourceAndCodeElement);
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
      } else {
        const detailsElement = append(markerElement, $$2("span"));
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
        detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;
      }
    }
    if (isNonEmptyArray(relatedInformation)) {
      for (const { message: message2, resource, startLineNumber, startColumn } of relatedInformation) {
        const relatedInfoContainer = append(markerElement, $$2("div"));
        relatedInfoContainer.style.marginTop = "8px";
        const a = append(relatedInfoContainer, $$2("a"));
        a.innerText = `${basename(resource)}(${startLineNumber}, ${startColumn}): `;
        a.style.cursor = "pointer";
        disposables.add(addDisposableListener(a, "click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (this._openerService) {
            this._openerService.open(resource, {
              fromUserGesture: true,
              editorOptions: { selection: { startLineNumber, startColumn } }
            }).catch(onUnexpectedError);
          }
        }));
        const messageElement2 = append(relatedInfoContainer, $$2("span"));
        messageElement2.innerText = message2;
        this._editor.applyFontInfo(messageElement2);
      }
    }
    return hoverElement;
  }
  renderMarkerStatusbar(context, markerHover, disposables) {
    if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
      context.statusBar.addAction({
        label: localize("view problem", "View Problem"),
        commandId: NextMarkerAction.ID,
        run: () => {
          var _a3;
          context.hide();
          (_a3 = MarkerController.get(this._editor)) === null || _a3 === void 0 ? void 0 : _a3.showAtMarker(markerHover.marker);
          this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(
      89
      /* EditorOption.readOnly */
    )) {
      const quickfixPlaceholderElement = context.statusBar.append($$2("div"));
      if (this.recentMarkerCodeActionsInfo) {
        if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
          if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
            quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          }
        } else {
          this.recentMarkerCodeActionsInfo = void 0;
        }
      }
      const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = localize("checkingForQuickFixes", "Checking for quick fixes..."), 200));
      if (!quickfixPlaceholderElement.textContent) {
        quickfixPlaceholderElement.textContent = String.fromCharCode(160);
      }
      const codeActionsPromise = this.getCodeActions(markerHover.marker);
      disposables.add(toDisposable(() => codeActionsPromise.cancel()));
      codeActionsPromise.then((actions) => {
        updatePlaceholderDisposable.dispose();
        this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };
        if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
          actions.dispose();
          quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          return;
        }
        quickfixPlaceholderElement.style.display = "none";
        let showing = false;
        disposables.add(toDisposable(() => {
          if (!showing) {
            actions.dispose();
          }
        }));
        context.statusBar.addAction({
          label: localize("quick fixes", "Quick Fix..."),
          commandId: quickFixCommandId,
          run: (target) => {
            showing = true;
            const controller = CodeActionController.get(this._editor);
            const elementPosition = getDomNodePagePosition(target);
            context.hide();
            controller === null || controller === void 0 ? void 0 : controller.showCodeActions(markerCodeActionTrigger, actions, {
              x: elementPosition.left,
              y: elementPosition.top,
              width: elementPosition.width,
              height: elementPosition.height
            });
          }
        });
      }, onUnexpectedError);
    }
  }
  getCodeActions(marker) {
    return createCancelablePromise((cancellationToken) => {
      return getCodeActions(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new Range$1(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
    });
  }
};
MarkerHoverParticipant = __decorate$D([
  __param$D(1, IMarkerDecorationsService),
  __param$D(2, IOpenerService),
  __param$D(3, ILanguageFeaturesService)
], MarkerHoverParticipant);
const inlineCompletionsHintsWidget = "";
const inlineSuggestCommitId = "editor.action.inlineSuggest.commit";
const showPreviousInlineSuggestionActionId = "editor.action.inlineSuggest.showPrevious";
const showNextInlineSuggestionActionId = "editor.action.inlineSuggest.showNext";
var __decorate$C = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$C = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let InlineCompletionsHintsWidget = class InlineCompletionsHintsWidget2 extends Disposable {
  constructor(editor2, model, instantiationService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.instantiationService = instantiationService;
    this.alwaysShowToolbar = observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      61
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always");
    this.sessionPosition = void 0;
    this.position = derived("position", (reader) => {
      var _a3, _b3, _c3;
      const ghostText2 = (_a3 = this.model.read(reader)) === null || _a3 === void 0 ? void 0 : _a3.ghostText.read(reader);
      if (!this.alwaysShowToolbar.read(reader) || !ghostText2 || ghostText2.parts.length === 0) {
        this.sessionPosition = void 0;
        return null;
      }
      const firstColumn = ghostText2.parts[0].column;
      if (this.sessionPosition && this.sessionPosition.lineNumber !== ghostText2.lineNumber) {
        this.sessionPosition = void 0;
      }
      const position = new Position$1(ghostText2.lineNumber, Math.min(firstColumn, (_c3 = (_b3 = this.sessionPosition) === null || _b3 === void 0 ? void 0 : _b3.column) !== null && _c3 !== void 0 ? _c3 : Number.MAX_SAFE_INTEGER));
      this.sessionPosition = position;
      return position;
    });
    this._register(autorunWithStore2("setup content widget", (reader, store) => {
      const model2 = this.model.read(reader);
      if (!model2 || !this.alwaysShowToolbar.read(reader)) {
        return;
      }
      const contentWidget = store.add(this.instantiationService.createInstance(InlineSuggestionHintsContentWidget, this.editor, true, this.position, model2.selectedInlineCompletionIndex, model2.inlineCompletionsCount, model2.selectedInlineCompletion.map((v) => {
        var _a3;
        return (_a3 = v === null || v === void 0 ? void 0 : v.inlineCompletion.source.inlineCompletions.commands) !== null && _a3 !== void 0 ? _a3 : [];
      })));
      editor2.addContentWidget(contentWidget);
      store.add(toDisposable(() => editor2.removeContentWidget(contentWidget)));
      store.add(autorun("request explicit", (reader2) => {
        const position = this.position.read(reader2);
        if (!position) {
          return;
        }
        if (model2.lastTriggerKind.read(reader2) !== InlineCompletionTriggerKind.Explicit) {
          model2.triggerExplicitly();
        }
      }));
    }));
  }
};
InlineCompletionsHintsWidget = __decorate$C([
  __param$C(2, IInstantiationService)
], InlineCompletionsHintsWidget);
const inlineSuggestionHintsNextIcon = registerIcon("inline-suggestion-hints-next", Codicon.chevronRight, localize("parameterHintsNextIcon", "Icon for show next parameter hint."));
const inlineSuggestionHintsPreviousIcon = registerIcon("inline-suggestion-hints-previous", Codicon.chevronLeft, localize("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
let InlineSuggestionHintsContentWidget = class InlineSuggestionHintsContentWidget2 extends Disposable {
  static get dropDownVisible() {
    return this._dropDownVisible;
  }
  createCommandAction(commandId, label, iconClassName) {
    const action = new Action(commandId, label, iconClassName, true, () => this._commandService.executeCommand(commandId));
    const kb = this.keybindingService.lookupKeybinding(commandId, this._contextKeyService);
    let tooltip = label;
    if (kb) {
      tooltip = localize({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", label, kb.getLabel());
    }
    action.tooltip = tooltip;
    return action;
  }
  constructor(editor2, withBorder, _position, _currentSuggestionIdx, _suggestionCount, _extraCommands, _commandService, instantiationService, keybindingService, _contextKeyService, _menuService) {
    super();
    this.editor = editor2;
    this.withBorder = withBorder;
    this._position = _position;
    this._currentSuggestionIdx = _currentSuggestionIdx;
    this._suggestionCount = _suggestionCount;
    this._extraCommands = _extraCommands;
    this._commandService = _commandService;
    this.keybindingService = keybindingService;
    this._contextKeyService = _contextKeyService;
    this._menuService = _menuService;
    this.id = `InlineSuggestionHintsContentWidget${InlineSuggestionHintsContentWidget2.id++}`;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this.nodes = h("div.inlineSuggestionsHints", { className: this.withBorder ? ".withBorder" : "" }, [
      h("div", { style: { display: "flex" } }, [
        h("div@actionBar", { className: "custom-actions" }),
        h("div@toolBar")
      ])
    ]);
    this.previousAction = this.createCommandAction(showPreviousInlineSuggestionActionId, localize("previous", "Previous"), ThemeIcon.asClassName(inlineSuggestionHintsPreviousIcon));
    this.availableSuggestionCountAction = new Action("inlineSuggestionHints.availableSuggestionCount", "", void 0, false);
    this.nextAction = this.createCommandAction(showNextInlineSuggestionActionId, localize("next", "Next"), ThemeIcon.asClassName(inlineSuggestionHintsNextIcon));
    this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
    this.clearAvailableSuggestionCountLabelDebounced = this._register(new RunOnceScheduler(() => {
      this.availableSuggestionCountAction.label = "";
    }, 100));
    this.disableButtonsDebounced = this._register(new RunOnceScheduler(() => {
      this.previousAction.enabled = this.nextAction.enabled = false;
    }, 100));
    this.lastCommands = [];
    const actionBar = this._register(new ActionBar(this.nodes.actionBar));
    actionBar.push(this.previousAction, { icon: true, label: false });
    actionBar.push(this.availableSuggestionCountAction);
    actionBar.push(this.nextAction, { icon: true, label: false });
    this.toolBar = this._register(instantiationService.createInstance(CustomizedMenuWorkbenchToolBar, this.nodes.toolBar, MenuId.InlineSuggestionToolbar, {
      menuOptions: { renderShortTitle: true },
      toolbarOptions: { primaryGroup: (g) => g.startsWith("primary") },
      actionViewItemProvider: (action, options) => {
        return action instanceof MenuItemAction ? instantiationService.createInstance(StatusBarViewItem, action, void 0) : void 0;
      },
      telemetrySource: "InlineSuggestionToolbar"
    }));
    this._register(this.toolBar.onDidChangeDropdownVisibility((e) => {
      InlineSuggestionHintsContentWidget2._dropDownVisible = e;
    }));
    this._register(autorun("update position", (reader) => {
      this._position.read(reader);
      this.editor.layoutContentWidget(this);
    }));
    this._register(autorun("counts", (reader) => {
      const suggestionCount = this._suggestionCount.read(reader);
      const currentSuggestionIdx = this._currentSuggestionIdx.read(reader);
      if (suggestionCount !== void 0) {
        this.clearAvailableSuggestionCountLabelDebounced.cancel();
        this.availableSuggestionCountAction.label = `${currentSuggestionIdx + 1}/${suggestionCount}`;
      } else {
        this.clearAvailableSuggestionCountLabelDebounced.schedule();
      }
      if (suggestionCount !== void 0 && suggestionCount > 1) {
        this.disableButtonsDebounced.cancel();
        this.previousAction.enabled = this.nextAction.enabled = true;
      } else {
        this.disableButtonsDebounced.schedule();
      }
    }));
    this._register(autorun("extra commands", (reader) => {
      const extraCommands = this._extraCommands.read(reader);
      if (equals$1(this.lastCommands, extraCommands)) {
        return;
      }
      this.lastCommands = extraCommands;
      const extraActions = extraCommands.map((c) => ({
        class: void 0,
        id: c.id,
        enabled: true,
        tooltip: c.tooltip || "",
        label: c.title,
        run: (event) => {
          return this._commandService.executeCommand(c.id);
        }
      }));
      for (const [_, group] of this.inlineCompletionsActionsMenus.getActions()) {
        for (const action of group) {
          if (action instanceof MenuItemAction) {
            extraActions.push(action);
          }
        }
      }
      if (extraActions.length > 0) {
        extraActions.unshift(new Separator());
      }
      this.toolBar.setAdditionalSecondaryActions(extraActions);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
};
InlineSuggestionHintsContentWidget._dropDownVisible = false;
InlineSuggestionHintsContentWidget.id = 0;
InlineSuggestionHintsContentWidget = __decorate$C([
  __param$C(6, ICommandService),
  __param$C(7, IInstantiationService),
  __param$C(8, IKeybindingService),
  __param$C(9, IContextKeyService),
  __param$C(10, IMenuService)
], InlineSuggestionHintsContentWidget);
class StatusBarViewItem extends MenuEntryActionViewItem {
  updateLabel() {
    const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!kb) {
      return super.updateLabel();
    }
    if (this.label) {
      const div = h("div.keybinding").root;
      const k = new KeybindingLabel(div, OS, Object.assign({ disableTitle: true }, unthemedKeybindingLabelOptions));
      k.set(kb);
      this.label.textContent = this._action.label;
      this.label.appendChild(div);
      this.label.classList.add("inlineSuggestionStatusBarItemLabel");
    }
  }
}
let CustomizedMenuWorkbenchToolBar = class CustomizedMenuWorkbenchToolBar2 extends WorkbenchToolBar {
  constructor(container, menuId, options2, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService) {
    super(container, Object.assign({ resetMenu: menuId }, options2), menuService, contextKeyService, contextMenuService, keybindingService, telemetryService);
    this.menuId = menuId;
    this.options2 = options2;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: true }));
    this.additionalActions = [];
    this._store.add(this.menu.onDidChange(() => this.updateToolbar()));
    this.updateToolbar();
  }
  updateToolbar() {
    var _a3, _b3, _c3, _d3, _e3, _f3, _g3;
    const primary = [];
    const secondary = [];
    createAndFillInActionBarActions(this.menu, (_a3 = this.options2) === null || _a3 === void 0 ? void 0 : _a3.menuOptions, { primary, secondary }, (_c3 = (_b3 = this.options2) === null || _b3 === void 0 ? void 0 : _b3.toolbarOptions) === null || _c3 === void 0 ? void 0 : _c3.primaryGroup, (_e3 = (_d3 = this.options2) === null || _d3 === void 0 ? void 0 : _d3.toolbarOptions) === null || _e3 === void 0 ? void 0 : _e3.shouldInlineSubmenu, (_g3 = (_f3 = this.options2) === null || _f3 === void 0 ? void 0 : _f3.toolbarOptions) === null || _g3 === void 0 ? void 0 : _g3.useSeparatorsInPrimaryActions);
    secondary.push(...this.additionalActions);
    this.setActions(primary, secondary);
  }
  setAdditionalSecondaryActions(actions) {
    if (equals$1(this.additionalActions, actions, (a, b) => a === b)) {
      return;
    }
    this.additionalActions = actions;
    this.updateToolbar();
  }
};
CustomizedMenuWorkbenchToolBar = __decorate$C([
  __param$C(3, IMenuService),
  __param$C(4, IContextKeyService),
  __param$C(5, IContextMenuService),
  __param$C(6, IKeybindingService),
  __param$C(7, ITelemetryService)
], CustomizedMenuWorkbenchToolBar);
const hover$1 = "";
var __decorate$B = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$B = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const _sticky = false;
let ModesHoverController = class ModesHoverController2 {
  getWidgetContent() {
    var _a3;
    return (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.getWidgetContent();
  }
  static get(editor2) {
    return editor2.getContribution(ModesHoverController2.ID);
  }
  constructor(_editor, _instantiationService, _openerService, _languageService, _keybindingService) {
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._openerService = _openerService;
    this._languageService = _languageService;
    this._keybindingService = _keybindingService;
    this._toUnhook = new DisposableStore();
    this._hoverActivatedByColorDecoratorClick = false;
    this._isMouseDown = false;
    this._hoverClicked = false;
    this._contentWidget = null;
    this._glyphWidget = null;
    this._hookEvents();
    this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        59
        /* EditorOption.hover */
      )) {
        this._unhookEvents();
        this._hookEvents();
      }
    });
  }
  _hookEvents() {
    const hideWidgetsEventHandler = () => this._hideWidgets();
    const hoverOpts = this._editor.getOption(
      59
      /* EditorOption.hover */
    );
    this._isHoverEnabled = hoverOpts.enabled;
    this._isHoverSticky = hoverOpts.sticky;
    if (this._isHoverEnabled) {
      this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
      this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    } else {
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    }
    this._toUnhook.add(this._editor.onMouseLeave((e) => this._onEditorMouseLeave(e)));
    this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));
    this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
  }
  _unhookEvents() {
    this._toUnhook.clear();
  }
  _onEditorScrollChanged(e) {
    if (e.scrollTopChanged || e.scrollLeftChanged) {
      this._hideWidgets();
    }
  }
  _onEditorMouseDown(mouseEvent) {
    var _a3;
    this._isMouseDown = true;
    const target = mouseEvent.target;
    if (target.type === 9 && target.detail === ContentHoverWidget.ID) {
      this._hoverClicked = true;
      return;
    }
    if (target.type === 12 && target.detail === MarginHoverWidget.ID) {
      return;
    }
    if (target.type !== 12) {
      this._hoverClicked = false;
    }
    if (!((_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.widget.isResizing)) {
      this._hideWidgets();
    }
  }
  _onEditorMouseUp(mouseEvent) {
    this._isMouseDown = false;
  }
  _onEditorMouseLeave(mouseEvent) {
    var _a3, _b3;
    const targetEm = mouseEvent.event.browserEvent.relatedTarget;
    if (((_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.widget.isResizing) || ((_b3 = this._contentWidget) === null || _b3 === void 0 ? void 0 : _b3.containsNode(targetEm))) {
      return;
    }
    {
      this._hideWidgets();
    }
  }
  _onEditorMouseMove(mouseEvent) {
    var _a3, _b3, _c3, _d3, _e3, _f3, _g3, _h3, _j2, _k2, _l2;
    const target = mouseEvent.target;
    if (((_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.isFocused) || ((_b3 = this._contentWidget) === null || _b3 === void 0 ? void 0 : _b3.isResizing)) {
      return;
    }
    if (this._isMouseDown && this._hoverClicked) {
      return;
    }
    if (this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID) {
      return;
    }
    if (this._isHoverSticky && ((_c3 = this._contentWidget) === null || _c3 === void 0 ? void 0 : _c3.containsNode((_d3 = mouseEvent.event.browserEvent.view) === null || _d3 === void 0 ? void 0 : _d3.document.activeElement)) && !((_f3 = (_e3 = mouseEvent.event.browserEvent.view) === null || _e3 === void 0 ? void 0 : _e3.getSelection()) === null || _f3 === void 0 ? void 0 : _f3.isCollapsed)) {
      return;
    }
    if (!this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID && ((_g3 = this._contentWidget) === null || _g3 === void 0 ? void 0 : _g3.isColorPickerVisible)) {
      return;
    }
    if (this._isHoverSticky && target.type === 12 && target.detail === MarginHoverWidget.ID) {
      return;
    }
    if (this._isHoverSticky && ((_h3 = this._contentWidget) === null || _h3 === void 0 ? void 0 : _h3.isVisibleFromKeyboard)) {
      return;
    }
    const mouseOnDecorator = (_j2 = target.element) === null || _j2 === void 0 ? void 0 : _j2.classList.contains("colorpicker-color-decoration");
    const decoratorActivatedOn = this._editor.getOption(
      145
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    if (mouseOnDecorator && (decoratorActivatedOn === "click" && !this._hoverActivatedByColorDecoratorClick || decoratorActivatedOn === "hover" && !this._isHoverEnabled && !_sticky || decoratorActivatedOn === "clickAndHover" && !this._isHoverEnabled && !this._hoverActivatedByColorDecoratorClick) || !mouseOnDecorator && !this._isHoverEnabled && !this._hoverActivatedByColorDecoratorClick) {
      this._hideWidgets();
      return;
    }
    const contentWidget = this._getOrCreateContentWidget();
    if (contentWidget.maybeShowAt(mouseEvent)) {
      (_k2 = this._glyphWidget) === null || _k2 === void 0 ? void 0 : _k2.hide();
      return;
    }
    if (target.type === 2 && target.position) {
      (_l2 = this._contentWidget) === null || _l2 === void 0 ? void 0 : _l2.hide();
      if (!this._glyphWidget) {
        this._glyphWidget = new MarginHoverWidget(this._editor, this._languageService, this._openerService);
      }
      this._glyphWidget.startShowingAt(target.position.lineNumber);
      return;
    }
    this._hideWidgets();
  }
  _onKeyDown(e) {
    var _a3;
    if (!this._editor.hasModel()) {
      return;
    }
    const resolvedKeyboardEvent = this._keybindingService.softDispatch(e, this._editor.getDomNode());
    const mightTriggerFocus = resolvedKeyboardEvent.kind === 1 || resolvedKeyboardEvent.kind === 2 && resolvedKeyboardEvent.commandId === "editor.action.showHover" && ((_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.isVisible);
    if (e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4 && !mightTriggerFocus) {
      this._hideWidgets();
    }
  }
  _hideWidgets() {
    var _a3, _b3, _c3;
    if (this._isMouseDown && this._hoverClicked && ((_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.isColorPickerVisible) || InlineSuggestionHintsContentWidget.dropDownVisible) {
      return;
    }
    this._hoverActivatedByColorDecoratorClick = false;
    this._hoverClicked = false;
    (_b3 = this._glyphWidget) === null || _b3 === void 0 ? void 0 : _b3.hide();
    (_c3 = this._contentWidget) === null || _c3 === void 0 ? void 0 : _c3.hide();
  }
  _getOrCreateContentWidget() {
    if (!this._contentWidget) {
      this._contentWidget = this._instantiationService.createInstance(ContentHoverController, this._editor);
    }
    return this._contentWidget;
  }
  showContentHover(range, mode, source, focus, activatedByColorDecoratorClick = false) {
    this._hoverActivatedByColorDecoratorClick = activatedByColorDecoratorClick;
    this._getOrCreateContentWidget().startShowingAtRange(range, mode, source, focus);
  }
  focus() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.focus();
  }
  scrollUp() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.scrollUp();
  }
  scrollDown() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.scrollDown();
  }
  scrollLeft() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.scrollLeft();
  }
  scrollRight() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.scrollRight();
  }
  pageUp() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.pageUp();
  }
  pageDown() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.pageDown();
  }
  goToTop() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.goToTop();
  }
  goToBottom() {
    var _a3;
    (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.goToBottom();
  }
  get isColorPickerVisible() {
    var _a3;
    return (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.isColorPickerVisible;
  }
  get isHoverVisible() {
    var _a3;
    return (_a3 = this._contentWidget) === null || _a3 === void 0 ? void 0 : _a3.isVisible;
  }
  dispose() {
    var _a3, _b3;
    this._unhookEvents();
    this._toUnhook.dispose();
    this._didChangeConfigurationHandler.dispose();
    (_a3 = this._glyphWidget) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    (_b3 = this._contentWidget) === null || _b3 === void 0 ? void 0 : _b3.dispose();
  }
};
ModesHoverController.ID = "editor.contrib.hover";
ModesHoverController = __decorate$B([
  __param$B(1, IInstantiationService),
  __param$B(2, IOpenerService),
  __param$B(3, ILanguageService),
  __param$B(4, IKeybindingService)
], ModesHoverController);
class ShowOrFocusHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showHover",
      label: localize({
        key: "showOrFocusHover",
        comment: [
          "Label for action that will trigger the showing/focusing of a hover in the editor.",
          "If the hover is not visible, it will show the hover.",
          "This allows for users to show the hover without using the mouse.",
          "If the hover is already visible, it will take focus."
        ]
      }, "Show or Focus Hover"),
      description: {
        description: `Show or Focus Hover`,
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "focus": {
                description: "Controls if when triggered with the keyboard, the hover should take focus immediately.",
                type: "boolean",
                default: false
              }
            }
          }
        }]
      },
      alias: "Show or Focus Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 39
          /* KeyCode.KeyI */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    var _a3;
    const configurationService = accessor.get(IConfigurationService);
    const accessibilityService = accessor.get(IAccessibilityService);
    const keybindingService = accessor.get(IKeybindingService);
    if (!editor2.hasModel()) {
      return;
    }
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    const range = new Range$1(position.lineNumber, position.column, position.lineNumber, position.column);
    const focus = editor2.getOption(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 || !!(args === null || args === void 0 ? void 0 : args.focus);
    if (controller.isHoverVisible) {
      controller.focus();
    } else {
      controller.showContentHover(range, 1, 1, focus);
    }
    if (configurationService.getValue("accessibility.verbosity.hover") && accessibilityService.isScreenReaderOptimized()) {
      const keybinding = (_a3 = keybindingService.lookupKeybinding("editor.action.accessibleView")) === null || _a3 === void 0 ? void 0 : _a3.getAriaLabel();
      const hint = keybinding ? localize("chatAccessibleViewHint", "Inspect this in the accessible view with {0}", keybinding) : localize("chatAccessibleViewHintNoKb", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding");
      status(hint);
    }
  }
}
class ShowDefinitionPreviewHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showDefinitionPreviewHover",
      label: localize({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    if (!position) {
      return;
    }
    const range = new Range$1(position.lineNumber, position.column, position.lineNumber, position.column);
    const goto = GotoDefinitionAtPositionEditorContribution.get(editor2);
    if (!goto) {
      return;
    }
    const promise = goto.startFindDefinitionFromCursor(position);
    promise.then(() => {
      controller.showContentHover(range, 1, 1, true);
    });
  }
}
class ScrollUpHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollUpHover",
      label: localize({
        key: "scrollUpHover",
        comment: [
          "Action that allows to scroll up in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Up Hover"),
      alias: "Scroll Up Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 16,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollUp();
  }
}
class ScrollDownHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollDownHover",
      label: localize({
        key: "scrollDownHover",
        comment: [
          "Action that allows to scroll down in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Down Hover"),
      alias: "Scroll Down Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 18,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollDown();
  }
}
class ScrollLeftHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollLeftHover",
      label: localize({
        key: "scrollLeftHover",
        comment: [
          "Action that allows to scroll left in the hover widget with the left arrow when the hover widget is focused."
        ]
      }, "Scroll Left Hover"),
      alias: "Scroll Left Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 15,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollLeft();
  }
}
class ScrollRightHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.scrollRightHover",
      label: localize({
        key: "scrollRightHover",
        comment: [
          "Action that allows to scroll right in the hover widget with the right arrow when the hover widget is focused."
        ]
      }, "Scroll Right Hover"),
      alias: "Scroll Right Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 17,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollRight();
  }
}
class PageUpHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.pageUpHover",
      label: localize({
        key: "pageUpHover",
        comment: [
          "Action that allows to page up in the hover widget with the page up command when the hover widget is focused."
        ]
      }, "Page Up Hover"),
      alias: "Page Up Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 11,
        secondary: [
          512 | 16
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.pageUp();
  }
}
class PageDownHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.pageDownHover",
      label: localize({
        key: "pageDownHover",
        comment: [
          "Action that allows to page down in the hover widget with the page down command when the hover widget is focused."
        ]
      }, "Page Down Hover"),
      alias: "Page Down Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 12,
        secondary: [
          512 | 18
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.pageDown();
  }
}
class GoToTopHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToTopHover",
      label: localize({
        key: "goToTopHover",
        comment: [
          "Action that allows to go to the top of the hover widget with the home command when the hover widget is focused."
        ]
      }, "Go To Top Hover"),
      alias: "Go To Bottom Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 14,
        secondary: [
          2048 | 16
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.goToTop();
  }
}
class GoToBottomHoverAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToBottomHover",
      label: localize({
        key: "goToBottomHover",
        comment: [
          "Action that allows to go to the bottom in the hover widget with the end command when the hover widget is focused."
        ]
      }, "Go To Bottom Hover"),
      alias: "Go To Bottom Hover",
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 13,
        secondary: [
          2048 | 18
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.goToBottom();
  }
}
registerEditorContribution(
  ModesHoverController.ID,
  ModesHoverController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(ShowOrFocusHoverAction);
registerEditorAction(ShowDefinitionPreviewHoverAction);
registerEditorAction(ScrollUpHoverAction);
registerEditorAction(ScrollDownHoverAction);
registerEditorAction(ScrollLeftHoverAction);
registerEditorAction(ScrollRightHoverAction);
registerEditorAction(PageUpHoverAction);
registerEditorAction(PageDownHoverAction);
registerEditorAction(GoToTopHoverAction);
registerEditorAction(GoToBottomHoverAction);
HoverParticipantRegistry.register(MarkdownHoverParticipant);
HoverParticipantRegistry.register(MarkerHoverParticipant);
registerThemingParticipant((theme, collector) => {
  const hoverBorder = theme.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);
  }
});
class ColorContribution extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(_editor.onMouseDown((e) => this.onMouseDown(e)));
  }
  dispose() {
    super.dispose();
  }
  onMouseDown(mouseEvent) {
    const colorDecoratorsActivatedOn = this._editor.getOption(
      145
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    if (colorDecoratorsActivatedOn !== "click" && colorDecoratorsActivatedOn !== "clickAndHover") {
      return;
    }
    const target = mouseEvent.target;
    if (target.type !== 6) {
      return;
    }
    if (!target.detail.injectedText) {
      return;
    }
    if (target.detail.injectedText.options.attachedData !== ColorDecorationInjectedTextMarker) {
      return;
    }
    if (!target.range) {
      return;
    }
    const hoverController = this._editor.getContribution(ModesHoverController.ID);
    if (!hoverController) {
      return;
    }
    if (!hoverController.isColorPickerVisible) {
      const range = new Range$1(target.range.startLineNumber, target.range.startColumn + 1, target.range.endLineNumber, target.range.endColumn + 1);
      hoverController.showContentHover(range, 1, 0, false, true);
    }
  }
}
ColorContribution.ID = "editor.contrib.colorContribution";
ColorContribution.RECOMPUTE_TIME = 1e3;
registerEditorContribution(
  ColorContribution.ID,
  ColorContribution,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
HoverParticipantRegistry.register(ColorHoverParticipant);
var __decorate$A = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$A = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$y = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let StandaloneColorPickerController = class StandaloneColorPickerController2 extends Disposable {
  constructor(_editor, _contextKeyService, _modelService, _keybindingService, _instantiationService, _languageFeatureService, _languageConfigurationService) {
    super();
    this._editor = _editor;
    this._modelService = _modelService;
    this._keybindingService = _keybindingService;
    this._instantiationService = _instantiationService;
    this._languageFeatureService = _languageFeatureService;
    this._languageConfigurationService = _languageConfigurationService;
    this._standaloneColorPickerWidget = null;
    this._standaloneColorPickerVisible = EditorContextKeys.standaloneColorPickerVisible.bindTo(_contextKeyService);
    this._standaloneColorPickerFocused = EditorContextKeys.standaloneColorPickerFocused.bindTo(_contextKeyService);
  }
  showOrFocus() {
    var _a3;
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._standaloneColorPickerVisible.get()) {
      this._standaloneColorPickerWidget = new StandaloneColorPickerWidget(this._editor, this._standaloneColorPickerVisible, this._standaloneColorPickerFocused, this._instantiationService, this._modelService, this._keybindingService, this._languageFeatureService, this._languageConfigurationService);
    } else if (!this._standaloneColorPickerFocused.get()) {
      (_a3 = this._standaloneColorPickerWidget) === null || _a3 === void 0 ? void 0 : _a3.focus();
    }
  }
  hide() {
    var _a3;
    this._standaloneColorPickerFocused.set(false);
    this._standaloneColorPickerVisible.set(false);
    (_a3 = this._standaloneColorPickerWidget) === null || _a3 === void 0 ? void 0 : _a3.hide();
    this._editor.focus();
  }
  insertColor() {
    var _a3;
    (_a3 = this._standaloneColorPickerWidget) === null || _a3 === void 0 ? void 0 : _a3.updateEditor();
    this.hide();
  }
  static get(editor2) {
    return editor2.getContribution(StandaloneColorPickerController2.ID);
  }
};
StandaloneColorPickerController.ID = "editor.contrib.standaloneColorPickerController";
StandaloneColorPickerController = __decorate$A([
  __param$A(1, IContextKeyService),
  __param$A(2, IModelService),
  __param$A(3, IKeybindingService),
  __param$A(4, IInstantiationService),
  __param$A(5, ILanguageFeaturesService),
  __param$A(6, ILanguageConfigurationService)
], StandaloneColorPickerController);
registerEditorContribution(
  StandaloneColorPickerController.ID,
  StandaloneColorPickerController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
const PADDING = 8;
const CLOSE_BUTTON_WIDTH = 22;
let StandaloneColorPickerWidget = class StandaloneColorPickerWidget2 extends Disposable {
  constructor(_editor, _standaloneColorPickerVisible, _standaloneColorPickerFocused, _instantiationService, _modelService, _keybindingService, _languageFeaturesService, _languageConfigurationService) {
    var _a3;
    super();
    this._editor = _editor;
    this._standaloneColorPickerVisible = _standaloneColorPickerVisible;
    this._standaloneColorPickerFocused = _standaloneColorPickerFocused;
    this._modelService = _modelService;
    this._keybindingService = _keybindingService;
    this._languageFeaturesService = _languageFeaturesService;
    this._languageConfigurationService = _languageConfigurationService;
    this.allowEditorOverflow = true;
    this.body = document.createElement("div");
    this._position = void 0;
    this._colorHover = null;
    this._selectionSetInEditor = false;
    this._onResult = this._register(new Emitter());
    this.onResult = this._onResult.event;
    this._standaloneColorPickerVisible.set(true);
    this._standaloneColorPickerParticipant = _instantiationService.createInstance(StandaloneColorPickerParticipant, this._editor);
    this._position = (_a3 = this._editor._getViewModel()) === null || _a3 === void 0 ? void 0 : _a3.getPrimaryCursorState().modelState.position;
    const editorSelection = this._editor.getSelection();
    const selection = editorSelection ? {
      startLineNumber: editorSelection.startLineNumber,
      startColumn: editorSelection.startColumn,
      endLineNumber: editorSelection.endLineNumber,
      endColumn: editorSelection.endColumn
    } : { startLineNumber: 0, endLineNumber: 0, endColumn: 0, startColumn: 0 };
    const focusTracker = this._register(trackFocus(this.body));
    this._register(focusTracker.onDidBlur((_) => {
      this.hide();
    }));
    this._register(focusTracker.onDidFocus((_) => {
      this.focus();
    }));
    this._register(this._editor.onDidChangeCursorPosition(() => {
      if (!this._selectionSetInEditor) {
        this.hide();
      } else {
        this._selectionSetInEditor = false;
      }
    }));
    this._register(this._editor.onMouseMove((e) => {
      var _a4;
      const classList = (_a4 = e.target.element) === null || _a4 === void 0 ? void 0 : _a4.classList;
      if (classList && classList.contains("colorpicker-color-decoration")) {
        this.hide();
      }
    }));
    this._register(this.onResult((result) => {
      this._render(result.value, result.foundInEditor);
    }));
    this._start(selection);
    this._editor.addContentWidget(this);
  }
  updateEditor() {
    if (this._colorHover) {
      this._standaloneColorPickerParticipant.updateEditorModel(this._colorHover);
    }
  }
  getId() {
    return StandaloneColorPickerWidget2.ID;
  }
  getDomNode() {
    return this.body;
  }
  getPosition() {
    if (!this._position) {
      return null;
    }
    const positionPreference = this._editor.getOption(
      59
      /* EditorOption.hover */
    ).above;
    return {
      position: this._position,
      secondaryPosition: this._position,
      preference: positionPreference ? [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ] : [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ],
      positionAffinity: 2
      /* PositionAffinity.None */
    };
  }
  hide() {
    this.dispose();
    this._standaloneColorPickerVisible.set(false);
    this._standaloneColorPickerFocused.set(false);
    this._editor.removeContentWidget(this);
    this._editor.focus();
  }
  focus() {
    this._standaloneColorPickerFocused.set(true);
    this.body.focus();
  }
  _start(selection) {
    return __awaiter$y(this, void 0, void 0, function* () {
      const computeAsyncResult = yield this._computeAsync(selection);
      if (!computeAsyncResult) {
        return;
      }
      this._onResult.fire(new StandaloneColorPickerResult(computeAsyncResult.result, computeAsyncResult.foundInEditor));
    });
  }
  _computeAsync(range) {
    return __awaiter$y(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return null;
      }
      const colorInfo = {
        range,
        color: { red: 0, green: 0, blue: 0, alpha: 1 }
      };
      const colorHoverResult = yield this._standaloneColorPickerParticipant.createColorHover(colorInfo, new DefaultDocumentColorProvider(this._modelService, this._languageConfigurationService), this._languageFeaturesService.colorProvider);
      if (!colorHoverResult) {
        return null;
      }
      return { result: colorHoverResult.colorHover, foundInEditor: colorHoverResult.foundInEditor };
    });
  }
  _render(colorHover, foundInEditor) {
    const fragment = document.createDocumentFragment();
    const statusBar = this._register(new EditorHoverStatusBar(this._keybindingService));
    let colorPickerWidget;
    const context = {
      fragment,
      statusBar,
      setColorPicker: (widget) => colorPickerWidget = widget,
      onContentsChanged: () => {
      },
      hide: () => this.hide()
    };
    this._colorHover = colorHover;
    this._register(this._standaloneColorPickerParticipant.renderHoverParts(context, [colorHover]));
    if (colorPickerWidget === void 0) {
      return;
    }
    this.body.classList.add("standalone-colorpicker-body");
    this.body.style.maxHeight = Math.max(this._editor.getLayoutInfo().height / 4, 250) + "px";
    this.body.style.maxWidth = Math.max(this._editor.getLayoutInfo().width * 0.66, 500) + "px";
    this.body.tabIndex = 0;
    this.body.appendChild(fragment);
    colorPickerWidget.layout();
    const colorPickerBody = colorPickerWidget.body;
    const saturationBoxWidth = colorPickerBody.saturationBox.domNode.clientWidth;
    const widthOfOriginalColorBox = colorPickerBody.domNode.clientWidth - saturationBoxWidth - CLOSE_BUTTON_WIDTH - PADDING;
    const enterButton = colorPickerWidget.body.enterButton;
    enterButton === null || enterButton === void 0 ? void 0 : enterButton.onClicked(() => {
      this.updateEditor();
      this.hide();
    });
    const colorPickerHeader = colorPickerWidget.header;
    const pickedColorNode = colorPickerHeader.pickedColorNode;
    pickedColorNode.style.width = saturationBoxWidth + PADDING + "px";
    const originalColorNode = colorPickerHeader.originalColorNode;
    originalColorNode.style.width = widthOfOriginalColorBox + "px";
    const closeButton = colorPickerWidget.header.closeButton;
    closeButton === null || closeButton === void 0 ? void 0 : closeButton.onClicked(() => {
      this.hide();
    });
    if (foundInEditor) {
      if (enterButton) {
        enterButton.button.textContent = "Replace";
      }
      this._selectionSetInEditor = true;
      this._editor.setSelection(colorHover.range);
    }
    this._editor.layoutContentWidget(this);
  }
};
StandaloneColorPickerWidget.ID = "editor.contrib.standaloneColorPickerWidget";
StandaloneColorPickerWidget = __decorate$A([
  __param$A(3, IInstantiationService),
  __param$A(4, IModelService),
  __param$A(5, IKeybindingService),
  __param$A(6, ILanguageFeaturesService),
  __param$A(7, ILanguageConfigurationService)
], StandaloneColorPickerWidget);
class StandaloneColorPickerResult {
  // The color picker result consists of: an array of color results and a boolean indicating if the color was found in the editor
  constructor(value, foundInEditor) {
    this.value = value;
    this.foundInEditor = foundInEditor;
  }
}
class ShowOrFocusStandaloneColorPicker extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.showOrFocusStandaloneColorPicker",
      title: {
        value: localize("showOrFocusStandaloneColorPicker", "Show or Focus Standalone Color Picker"),
        mnemonicTitle: localize({ key: "mishowOrFocusStandaloneColorPicker", comment: ["&& denotes a mnemonic"] }, "&&Show or Focus Standalone Color Picker"),
        original: "Show or Focus Standalone Color Picker"
      },
      precondition: void 0,
      menu: [
        { id: MenuId.CommandPalette }
      ]
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a3;
    (_a3 = StandaloneColorPickerController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.showOrFocus();
  }
}
class HideStandaloneColorPicker extends EditorAction {
  constructor() {
    super({
      id: "editor.action.hideColorPicker",
      label: localize({
        key: "hideColorPicker",
        comment: [
          "Action that hides the color picker"
        ]
      }, "Hide the Color Picker"),
      alias: "Hide the Color Picker",
      precondition: EditorContextKeys.standaloneColorPickerVisible.isEqualTo(true),
      kbOpts: {
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a3;
    (_a3 = StandaloneColorPickerController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.hide();
  }
}
class InsertColorWithStandaloneColorPicker extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertColorWithStandaloneColorPicker",
      label: localize({
        key: "insertColorWithStandaloneColorPicker",
        comment: [
          "Action that inserts color with standalone color picker"
        ]
      }, "Insert Color with Standalone Color Picker"),
      alias: "Insert Color with Standalone Color Picker",
      precondition: EditorContextKeys.standaloneColorPickerFocused.isEqualTo(true),
      kbOpts: {
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    var _a3;
    (_a3 = StandaloneColorPickerController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.insertColor();
  }
}
registerEditorAction(HideStandaloneColorPicker);
registerEditorAction(InsertColorWithStandaloneColorPicker);
registerAction2(ShowOrFocusStandaloneColorPicker);
class BlockCommentCommand {
  constructor(selection, insertSpace, languageConfigurationService) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._insertSpace = insertSpace;
    this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(haystack, needle, offset) {
    if (offset < 0) {
      return false;
    }
    const needleLength = needle.length;
    const haystackLength = haystack.length;
    if (offset + needleLength > haystackLength) {
      return false;
    }
    for (let i = 0; i < needleLength; i++) {
      const codeA = haystack.charCodeAt(offset + i);
      const codeB = needle.charCodeAt(i);
      if (codeA === codeB) {
        continue;
      }
      if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) {
        continue;
      }
      if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) {
        continue;
      }
      return false;
    }
    return true;
  }
  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
    const startLineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endLineNumber = selection.endLineNumber;
    const endColumn = selection.endColumn;
    const startLineText = model.getLineContent(startLineNumber);
    const endLineText = model.getLineContent(endLineNumber);
    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (startLineNumber === endLineNumber) {
        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
        if (lineBetweenTokens.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      } else {
        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      }
    }
    let ops;
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) {
        startToken = startToken + " ";
      }
      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
        endToken = " " + endToken;
        endTokenIndex -= 1;
      }
      ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range$1(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    } else {
      ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
      this._usedEndToken = ops.length === 1 ? endToken : null;
    }
    for (const op of ops) {
      builder.addTrackedEditOperation(op.range, op.text);
    }
  }
  static _createRemoveBlockCommentOperations(r, startToken, endToken) {
    const res = [];
    if (!Range$1.isEmpty(r)) {
      res.push(EditOperation.delete(new Range$1(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
      res.push(EditOperation.delete(new Range$1(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
    } else {
      res.push(EditOperation.delete(new Range$1(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
    }
    return res;
  }
  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
    const res = [];
    if (!Range$1.isEmpty(r)) {
      res.push(EditOperation.insert(new Position$1(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
      res.push(EditOperation.insert(new Position$1(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
    } else {
      res.push(EditOperation.replace(new Range$1(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
    }
    return res;
  }
  getEditOperations(model, builder) {
    const startLineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    if (inverseEditOperations.length === 2) {
      const startTokenEditOperation = inverseEditOperations[0];
      const endTokenEditOperation = inverseEditOperations[1];
      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
    } else {
      const srcRange = inverseEditOperations[0].range;
      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
    }
  }
}
class LineCommentCommand {
  constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._tabSize = tabSize;
    this._type = type;
    this._insertSpace = insertSpace;
    this._selectionId = null;
    this._deltaColumn = 0;
    this._moveEndPositionDown = false;
    this._ignoreEmptyLines = ignoreEmptyLines;
    this._ignoreFirstLine = ignoreFirstLine || false;
  }
  /**
   * Do an initial pass over the lines and gather info about the line comment string.
   * Returns null if any of the lines doesn't support a line comment string.
   */
  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
    const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;
    const commentStr = config ? config.lineCommentToken : null;
    if (!commentStr) {
      return null;
    }
    const lines = [];
    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
      lines[i] = {
        ignore: false,
        commentStr,
        commentStrOffset: 0,
        commentStrLength: commentStr.length
      };
    }
    return lines;
  }
  /**
   * Analyze lines and decide which lines are relevant and what the toggle should do.
   * Also, build up several offsets and lengths useful in the generation of editor operations.
   */
  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
    let onlyWhitespaceLines = true;
    let shouldRemoveComments;
    if (type === 0) {
      shouldRemoveComments = true;
    } else if (type === 1) {
      shouldRemoveComments = false;
    } else {
      shouldRemoveComments = true;
    }
    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
      const lineData = lines[i];
      const lineNumber = startLineNumber + i;
      if (lineNumber === startLineNumber && ignoreFirstLine) {
        lineData.ignore = true;
        continue;
      }
      const lineContent = model.getLineContent(lineNumber);
      const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
      if (lineContentStartOffset === -1) {
        lineData.ignore = ignoreEmptyLines;
        lineData.commentStrOffset = lineContent.length;
        continue;
      }
      onlyWhitespaceLines = false;
      lineData.ignore = false;
      lineData.commentStrOffset = lineContentStartOffset;
      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
        if (type === 0) {
          shouldRemoveComments = false;
        } else if (type === 1)
          ;
        else {
          lineData.ignore = true;
        }
      }
      if (shouldRemoveComments && insertSpace) {
        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) {
          lineData.commentStrLength += 1;
        }
      }
    }
    if (type === 0 && onlyWhitespaceLines) {
      shouldRemoveComments = false;
      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
        lines[i].ignore = false;
      }
    }
    return {
      supported: true,
      shouldRemoveComments,
      lines
    };
  }
  /**
   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
   */
  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);
    if (lines === null) {
      return {
        supported: false
      };
    }
    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);
  }
  /**
   * Given a successful analysis, execute either insert line comments, either remove line comments
   */
  _executeLineComments(model, builder, data, s) {
    let ops;
    if (data.shouldRemoveComments) {
      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
    } else {
      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
    }
    const cursorPosition = new Position$1(s.positionLineNumber, s.positionColumn);
    for (let i = 0, len = ops.length; i < len; i++) {
      builder.addEditOperation(ops[i].range, ops[i].text);
      if (Range$1.isEmpty(ops[i].range) && Range$1.getStartPosition(ops[i].range).equals(cursorPosition)) {
        const lineContent = model.getLineContent(cursorPosition.lineNumber);
        if (lineContent.length + 1 === cursorPosition.column) {
          this._deltaColumn = (ops[i].text || "").length;
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  _attemptRemoveBlockComment(model, s, startToken, endToken) {
    let startLineNumber = s.startLineNumber;
    let endLineNumber = s.endLineNumber;
    const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
    if (startTokenIndex !== -1 && endTokenIndex === -1) {
      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      endLineNumber = startLineNumber;
    }
    if (startTokenIndex === -1 && endTokenIndex !== -1) {
      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
      startLineNumber = endLineNumber;
    }
    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
      if (startTokenIndex !== -1) {
        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      }
    }
    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) {
      startToken += " ";
    }
    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
      endToken = " " + endToken;
      endTokenIndex -= 1;
    }
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range$1(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    }
    return null;
  }
  /**
   * Given an unsuccessful analysis, delegate to the block comment command
   */
  _executeBlockComment(model, builder, s) {
    model.tokenization.tokenizeIfCheap(s.startLineNumber);
    const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    const startToken = config.blockCommentStartToken;
    const endToken = config.blockCommentEndToken;
    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
    if (!ops) {
      if (s.isEmpty()) {
        const lineContent = model.getLineContent(s.startLineNumber);
        let firstNonWhitespaceIndex$1 = firstNonWhitespaceIndex(lineContent);
        if (firstNonWhitespaceIndex$1 === -1) {
          firstNonWhitespaceIndex$1 = lineContent.length;
        }
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range$1(s.startLineNumber, firstNonWhitespaceIndex$1 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
      } else {
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range$1(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
      }
      if (ops.length === 1) {
        this._deltaColumn = startToken.length + 1;
      }
    }
    this._selectionId = builder.trackSelection(s);
    for (const op of ops) {
      builder.addEditOperation(op.range, op.text);
    }
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._moveEndPositionDown = false;
    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {
      builder.addEditOperation(new Range$1(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? "" : "\n");
      this._selectionId = builder.trackSelection(s);
      return;
    }
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
    if (data.supported) {
      return this._executeLineComments(model, builder, data, s);
    }
    return this._executeBlockComment(model, builder, s);
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
  }
  /**
   * Generate edit operations in the remove line comment case
   */
  static _createRemoveLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.delete(new Range$1(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
    }
    return res;
  }
  /**
   * Generate edit operations in the add line comment case
   */
  _createAddLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    const afterCommentStr = this._insertSpace ? " " : "";
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.insert(new Position$1(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
    }
    return res;
  }
  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {
    if (isTab) {
      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);
    }
    return currentVisibleColumn + columnSize;
  }
  /**
   * Adjust insertion points to have them vertically aligned in the add line comment case
   */
  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {
    let minVisibleColumn = 1073741824;
    let j;
    let lenJ;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (let j2 = 0, lenJ2 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j2 < lenJ2; j2++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j2) === 9, 1);
      }
      if (currentVisibleColumn < minVisibleColumn) {
        minVisibleColumn = currentVisibleColumn;
      }
    }
    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9, 1);
      }
      if (currentVisibleColumn > minVisibleColumn) {
        lines[i].commentStrOffset = j - 1;
      } else {
        lines[i].commentStrOffset = j;
      }
    }
  }
}
class CommentLineAction extends EditorAction {
  constructor(type, opts) {
    super(opts);
    this._type = type;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands2 = [];
    const modelOptions = model.getOptions();
    const commentsOptions = editor2.getOption(
      22
      /* EditorOption.comments */
    );
    const selections = editor2.getSelections().map((selection, index2) => ({ selection, index: index2, ignoreFirstLine: false }));
    selections.sort((a, b) => Range$1.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignoreFirstLine = true;
        } else {
          prev.ignoreFirstLine = true;
          prev = curr;
        }
      }
    }
    for (const selection of selections) {
      commands2.push(new LineCommentCommand(languageConfigurationService, selection.selection, modelOptions.tabSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines, selection.ignoreFirstLine));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class ToggleCommentLineAction extends CommentLineAction {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: localize("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 90,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
}
class AddLineCommentAction extends CommentLineAction {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: localize("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 33
          /* KeyCode.KeyC */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class RemoveLineCommentAction extends CommentLineAction {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: localize("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 51
          /* KeyCode.KeyU */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class BlockCommentAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: localize("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 31,
        linux: {
          primary: 2048 | 1024 | 31
          /* KeyCode.KeyA */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const commentsOptions = editor2.getOption(
      22
      /* EditorOption.comments */
    );
    const commands2 = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands2.push(new BlockCommentCommand(selection, commentsOptions.insertSpace, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);
class CursorState {
  constructor(selections) {
    this.selections = selections;
  }
  equals(other) {
    const thisLen = this.selections.length;
    const otherLen = other.selections.length;
    if (thisLen !== otherLen) {
      return false;
    }
    for (let i = 0; i < thisLen; i++) {
      if (!this.selections[i].equalsSelection(other.selections[i])) {
        return false;
      }
    }
    return true;
  }
}
class StackElement {
  constructor(cursorState, scrollTop, scrollLeft) {
    this.cursorState = cursorState;
    this.scrollTop = scrollTop;
    this.scrollLeft = scrollLeft;
  }
}
class CursorUndoRedoController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(CursorUndoRedoController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._isCursorUndoRedo = false;
    this._undoStack = [];
    this._redoStack = [];
    this._register(editor2.onDidChangeModel((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (this._isCursorUndoRedo) {
        return;
      }
      if (!e.oldSelections) {
        return;
      }
      if (e.oldModelVersionId !== e.modelVersionId) {
        return;
      }
      const prevState = new CursorState(e.oldSelections);
      const isEqualToLastUndoStack = this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState);
      if (!isEqualToLastUndoStack) {
        this._undoStack.push(new StackElement(prevState, editor2.getScrollTop(), editor2.getScrollLeft()));
        this._redoStack = [];
        if (this._undoStack.length > 50) {
          this._undoStack.shift();
        }
      }
    }));
  }
  cursorUndo() {
    if (!this._editor.hasModel() || this._undoStack.length === 0) {
      return;
    }
    this._redoStack.push(new StackElement(new CursorState(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._undoStack.pop());
  }
  cursorRedo() {
    if (!this._editor.hasModel() || this._redoStack.length === 0) {
      return;
    }
    this._undoStack.push(new StackElement(new CursorState(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._redoStack.pop());
  }
  _applyState(stackElement) {
    this._isCursorUndoRedo = true;
    this._editor.setSelections(stackElement.cursorState.selections);
    this._editor.setScrollPosition({
      scrollTop: stackElement.scrollTop,
      scrollLeft: stackElement.scrollLeft
    });
    this._isCursorUndoRedo = false;
  }
}
CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
class CursorUndo extends EditorAction {
  constructor() {
    super({
      id: "cursorUndo",
      label: localize("cursor.undo", "Cursor Undo"),
      alias: "Cursor Undo",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 51,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    var _a3;
    (_a3 = CursorUndoRedoController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.cursorUndo();
  }
}
class CursorRedo extends EditorAction {
  constructor() {
    super({
      id: "cursorRedo",
      label: localize("cursor.redo", "Cursor Redo"),
      alias: "Cursor Redo",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    var _a3;
    (_a3 = CursorUndoRedoController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.cursorRedo();
  }
}
registerEditorContribution(
  CursorUndoRedoController.ID,
  CursorUndoRedoController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(CursorUndo);
registerEditorAction(CursorRedo);
const dnd = "";
class DragAndDropCommand {
  constructor(selection, targetPosition, copy) {
    this.selection = selection;
    this.targetPosition = targetPosition;
    this.copy = copy;
    this.targetSelection = null;
  }
  getEditOperations(model, builder) {
    const text = model.getValueInRange(this.selection);
    if (!this.copy) {
      builder.addEditOperation(this.selection, null);
    }
    builder.addEditOperation(new Range$1(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text);
    if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.selection.endColumn <= this.targetPosition.column) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
    } else {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
    }
  }
  computeCursorState(model, helper) {
    return this.targetSelection;
  }
}
function hasTriggerModifier(e) {
  if (isMacintosh) {
    return e.altKey;
  } else {
    return e.ctrlKey;
  }
}
class DragAndDropController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(DragAndDropController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._dndDecorationIds = this._editor.createDecorationsCollection();
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
    this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
    this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
    this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled()));
    this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
    this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
    this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
    this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
    this._mouseDown = false;
    this._modifierPressed = false;
    this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
  }
  onEditorKeyDown(e) {
    if (!this._editor.getOption(
      34
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      21
      /* EditorOption.columnSelection */
    )) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = true;
    }
    if (this._mouseDown && hasTriggerModifier(e)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    }
  }
  onEditorKeyUp(e) {
    if (!this._editor.getOption(
      34
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      21
      /* EditorOption.columnSelection */
    )) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = false;
    }
    if (this._mouseDown && e.keyCode === DragAndDropController.TRIGGER_KEY_VALUE) {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._mouseDown = true;
  }
  _onEditorMouseUp(mouseEvent) {
    this._mouseDown = false;
    this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(mouseEvent) {
    const target = mouseEvent.target;
    if (this._dragSelection === null) {
      const selections = this._editor.getSelections() || [];
      const possibleSelections = selections.filter((selection) => target.position && selection.containsPosition(target.position));
      if (possibleSelections.length === 1) {
        this._dragSelection = possibleSelections[0];
      } else {
        return;
      }
    }
    if (hasTriggerModifier(mouseEvent.event)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    } else {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
    if (target.position) {
      if (this._dragSelection.containsPosition(target.position)) {
        this._removeDecoration();
      } else {
        this.showAt(target.position);
      }
    }
  }
  _onEditorMouseDropCanceled() {
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  _onEditorMouseDrop(mouseEvent) {
    if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
      const newCursorPosition = new Position$1(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
      if (this._dragSelection === null) {
        let newSelections = null;
        if (mouseEvent.event.shiftKey) {
          const primarySelection = this._editor.getSelection();
          if (primarySelection) {
            const { selectionStartLineNumber, selectionStartColumn } = primarySelection;
            newSelections = [new Selection(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
          }
        } else {
          newSelections = (this._editor.getSelections() || []).map((selection) => {
            if (selection.containsPosition(newCursorPosition)) {
              return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
            } else {
              return selection;
            }
          });
        }
        this._editor.setSelections(
          newSelections || [],
          "mouse",
          3
          /* CursorChangeReason.Explicit */
        );
      } else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
        this._editor.pushUndoStop();
        this._editor.executeCommand(DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
        this._editor.pushUndoStop();
      }
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  showAt(position) {
    this._dndDecorationIds.set([{
      range: new Range$1(position.lineNumber, position.column, position.lineNumber, position.column),
      options: DragAndDropController._DECORATION_OPTIONS
    }]);
    this._editor.revealPosition(
      position,
      1
      /* ScrollType.Immediate */
    );
  }
  _removeDecoration() {
    this._dndDecorationIds.clear();
  }
  _hitContent(target) {
    return target.type === 6 || target.type === 7;
  }
  _hitMargin(target) {
    return target.type === 2 || target.type === 3 || target.type === 4;
  }
  dispose() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
    super.dispose();
  }
}
DragAndDropController.ID = "editor.contrib.dragAndDrop";
DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "dnd-target",
  className: "dnd-target"
});
registerEditorContribution(
  DragAndDropController.ID,
  DragAndDropController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
var __awaiter$x = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function toVSDataTransfer(dataTransfer) {
  const vsDataTransfer = new VSDataTransfer();
  for (const item of dataTransfer.items) {
    const type = item.type;
    if (item.kind === "string") {
      const asStringValue = new Promise((resolve) => item.getAsString(resolve));
      vsDataTransfer.append(type, createStringDataTransferItem(asStringValue));
    } else if (item.kind === "file") {
      const file = item.getAsFile();
      if (file) {
        vsDataTransfer.append(type, createFileDataTransferItemFromFile(file));
      }
    }
  }
  return vsDataTransfer;
}
function createFileDataTransferItemFromFile(file) {
  const uri = file.path ? URI$1.parse(file.path) : void 0;
  return createFileDataTransferItem(file.name, uri, () => __awaiter$x(this, void 0, void 0, function* () {
    return new Uint8Array(yield file.arrayBuffer());
  }));
}
const INTERNAL_DND_MIME_TYPES = Object.freeze([
  CodeDataTransfers.EDITORS,
  CodeDataTransfers.FILES,
  DataTransfers.RESOURCES,
  DataTransfers.INTERNAL_URI_LIST
]);
function toExternalVSDataTransfer(sourceDataTransfer, overwriteUriList = false) {
  const vsDataTransfer = toVSDataTransfer(sourceDataTransfer);
  const uriList = vsDataTransfer.get(DataTransfers.INTERNAL_URI_LIST);
  if (uriList) {
    vsDataTransfer.replace(Mimes.uriList, uriList);
  } else {
    if (overwriteUriList || !vsDataTransfer.has(Mimes.uriList)) {
      const editorData = [];
      for (const item of sourceDataTransfer.items) {
        const file = item.getAsFile();
        if (file) {
          const path2 = file.path;
          try {
            if (path2) {
              editorData.push(URI$1.file(path2).toString());
            } else {
              editorData.push(URI$1.parse(file.name, true).toString());
            }
          } catch (_a3) {
          }
        }
      }
      if (editorData.length) {
        vsDataTransfer.replace(Mimes.uriList, createStringDataTransferItem(UriList.create(editorData)));
      }
    }
  }
  for (const internal of INTERNAL_DND_MIME_TYPES) {
    vsDataTransfer.delete(internal);
  }
  return vsDataTransfer;
}
function createCombinedWorkspaceEdit(uri, ranges, edit) {
  var _a3, _b3;
  return {
    edits: [
      ...ranges.map((range) => new ResourceTextEdit(uri, typeof edit.insertText === "string" ? { range, text: edit.insertText, insertAsSnippet: false } : { range, text: edit.insertText.snippet, insertAsSnippet: true })),
      ...(_b3 = (_a3 = edit.additionalEdit) === null || _a3 === void 0 ? void 0 : _a3.edits) !== null && _b3 !== void 0 ? _b3 : []
    ]
  };
}
const inlineProgressWidget = "";
var __decorate$z = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$z = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$w = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const inlineProgressDecoration = ModelDecorationOptions.register({
  description: "inline-progress-widget",
  stickiness: 1,
  showIfCollapsed: true,
  after: {
    content: noBreakWhitespace,
    inlineClassName: "inline-editor-progress-decoration",
    inlineClassNameAffectsLetterSpacing: true
  }
});
class InlineProgressWidget extends Disposable {
  constructor(typeId, editor2, range, title, delegate) {
    super();
    this.typeId = typeId;
    this.editor = editor2;
    this.range = range;
    this.delegate = delegate;
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this.create(title);
    this.editor.addContentWidget(this);
    this.editor.layoutContentWidget(this);
  }
  create(title) {
    this.domNode = $$8(".inline-progress-widget");
    this.domNode.role = "button";
    this.domNode.title = title;
    const iconElement = $$8("span.icon");
    this.domNode.append(iconElement);
    iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.loading), "codicon-modifier-spin");
    const updateSize = () => {
      const lineHeight = this.editor.getOption(
        65
        /* EditorOption.lineHeight */
      );
      this.domNode.style.height = `${lineHeight}px`;
      this.domNode.style.width = `${Math.ceil(0.8 * lineHeight)}px`;
    };
    updateSize();
    this._register(this.editor.onDidChangeConfiguration((c) => {
      if (c.hasChanged(
        51
        /* EditorOption.fontSize */
      ) || c.hasChanged(
        65
        /* EditorOption.lineHeight */
      )) {
        updateSize();
      }
    }));
    this._register(addDisposableListener(this.domNode, EventType.CLICK, (e) => {
      this.delegate.cancel();
    }));
  }
  getId() {
    return InlineProgressWidget.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn },
      preference: [
        0
        /* ContentWidgetPositionPreference.EXACT */
      ]
    };
  }
  dispose() {
    super.dispose();
    this.editor.removeContentWidget(this);
  }
}
InlineProgressWidget.baseId = "editor.widget.inlineProgressWidget";
let InlineProgressManager = class InlineProgressManager2 extends Disposable {
  constructor(id, _editor, _instantiationService) {
    super();
    this.id = id;
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._showDelay = 500;
    this._showPromise = this._register(new MutableDisposable());
    this._currentWidget = new MutableDisposable();
    this._operationIdPool = 0;
    this._currentDecorations = _editor.createDecorationsCollection();
  }
  showWhile(position, title, promise) {
    return __awaiter$w(this, void 0, void 0, function* () {
      const operationId = this._operationIdPool++;
      this._currentOperation = operationId;
      this.clear();
      this._showPromise.value = disposableTimeout(() => {
        const range = Range$1.fromPositions(position);
        const decorationIds = this._currentDecorations.set([{
          range,
          options: inlineProgressDecoration
        }]);
        if (decorationIds.length > 0) {
          this._currentWidget.value = this._instantiationService.createInstance(InlineProgressWidget, this.id, this._editor, range, title, promise);
        }
      }, this._showDelay);
      try {
        return yield promise;
      } finally {
        if (this._currentOperation === operationId) {
          this.clear();
          this._currentOperation = void 0;
        }
      }
    });
  }
  clear() {
    this._showPromise.clear();
    this._currentDecorations.clear();
    this._currentWidget.clear();
  }
};
InlineProgressManager = __decorate$z([
  __param$z(2, IInstantiationService)
], InlineProgressManager);
const postEditWidget = "";
var __decorate$y = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$y = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$v = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let PostEditWidget = class PostEditWidget2 extends Disposable {
  constructor(typeId, editor2, visibleContext, showCommand, range, edits, onSelectNewEdit, _contextMenuService, contextKeyService, _keybindingService) {
    super();
    this.typeId = typeId;
    this.editor = editor2;
    this.showCommand = showCommand;
    this.range = range;
    this.edits = edits;
    this.onSelectNewEdit = onSelectNewEdit;
    this._contextMenuService = _contextMenuService;
    this._keybindingService = _keybindingService;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = true;
    this.create();
    this.visibleContext = visibleContext.bindTo(contextKeyService);
    this.visibleContext.set(true);
    this._register(toDisposable(() => this.visibleContext.reset()));
    this.editor.addContentWidget(this);
    this.editor.layoutContentWidget(this);
    this._register(toDisposable(() => this.editor.removeContentWidget(this)));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      if (!range.containsPosition(e.position)) {
        this.dispose();
      }
    }));
    this._register(Event.runAndSubscribe(_keybindingService.onDidUpdateKeybindings, () => {
      this._updateButtonTitle();
    }));
  }
  _updateButtonTitle() {
    var _a3;
    const binding = (_a3 = this._keybindingService.lookupKeybinding(this.showCommand.id)) === null || _a3 === void 0 ? void 0 : _a3.getLabel();
    this.button.element.title = this.showCommand.label + (binding ? ` (${binding})` : "");
  }
  create() {
    this.domNode = $$8(".post-edit-widget");
    this.button = this._register(new Button(this.domNode, {
      supportIcons: true
    }));
    this.button.label = "$(insert)";
    this._register(addDisposableListener(this.domNode, EventType.CLICK, () => this.showSelector()));
  }
  getId() {
    return PostEditWidget2.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.range.getEndPosition(),
      preference: [
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    };
  }
  showSelector() {
    this._contextMenuService.showContextMenu({
      getAnchor: () => {
        const pos = getDomNodePagePosition(this.button.element);
        return { x: pos.left + pos.width, y: pos.top + pos.height };
      },
      getActions: () => {
        return this.edits.allEdits.map((edit, i) => toAction({
          id: "",
          label: edit.label,
          checked: i === this.edits.activeEditIndex,
          run: () => {
            if (i !== this.edits.activeEditIndex) {
              return this.onSelectNewEdit(i);
            }
          }
        }));
      }
    });
  }
};
PostEditWidget.baseId = "editor.widget.postEditWidget";
PostEditWidget = __decorate$y([
  __param$y(7, IContextMenuService),
  __param$y(8, IContextKeyService),
  __param$y(9, IKeybindingService)
], PostEditWidget);
let PostEditWidgetManager = class PostEditWidgetManager2 extends Disposable {
  constructor(_id, _editor, _visibleContext, _showCommand, _instantiationService, _bulkEditService) {
    super();
    this._id = _id;
    this._editor = _editor;
    this._visibleContext = _visibleContext;
    this._showCommand = _showCommand;
    this._instantiationService = _instantiationService;
    this._bulkEditService = _bulkEditService;
    this._currentWidget = this._register(new MutableDisposable());
    this._register(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelContent)(() => this.clear()));
  }
  applyEditAndShowIfNeeded(ranges, edits, canShowWidget, token) {
    var _a3, _b3;
    return __awaiter$v(this, void 0, void 0, function* () {
      const model = this._editor.getModel();
      if (!model || !ranges.length) {
        return;
      }
      const edit = edits.allEdits[edits.activeEditIndex];
      if (!edit) {
        return;
      }
      let insertTextEdit = [];
      if (typeof edit.insertText === "string" ? edit.insertText === "" : edit.insertText.snippet === "") {
        insertTextEdit = [];
      } else {
        insertTextEdit = ranges.map((range) => new ResourceTextEdit(model.uri, typeof edit.insertText === "string" ? { range, text: edit.insertText, insertAsSnippet: false } : { range, text: edit.insertText.snippet, insertAsSnippet: true }));
      }
      const allEdits = [
        ...insertTextEdit,
        ...(_b3 = (_a3 = edit.additionalEdit) === null || _a3 === void 0 ? void 0 : _a3.edits) !== null && _b3 !== void 0 ? _b3 : []
      ];
      const combinedWorkspaceEdit = {
        edits: allEdits
      };
      const primaryRange = ranges[0];
      const editTrackingDecoration = model.deltaDecorations([], [{
        range: primaryRange,
        options: {
          description: "paste-line-suffix",
          stickiness: 0
          /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
        }
      }]);
      let editResult;
      let editRange;
      try {
        editResult = yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor, token });
        editRange = model.getDecorationRange(editTrackingDecoration[0]);
      } finally {
        model.deltaDecorations(editTrackingDecoration, []);
      }
      if (canShowWidget && editResult.isApplied && edits.allEdits.length > 1) {
        this.show(editRange !== null && editRange !== void 0 ? editRange : primaryRange, edits, (newEditIndex) => __awaiter$v(this, void 0, void 0, function* () {
          const model2 = this._editor.getModel();
          if (!model2) {
            return;
          }
          yield model2.undo();
          this.applyEditAndShowIfNeeded(ranges, { activeEditIndex: newEditIndex, allEdits: edits.allEdits }, canShowWidget, token);
        }));
      }
    });
  }
  show(range, edits, onDidSelectEdit) {
    this.clear();
    if (this._editor.hasModel()) {
      this._currentWidget.value = this._instantiationService.createInstance(PostEditWidget, this._id, this._editor, this._visibleContext, this._showCommand, range, edits, onDidSelectEdit);
    }
  }
  clear() {
    this._currentWidget.clear();
  }
  tryShowSelector() {
    var _a3;
    (_a3 = this._currentWidget.value) === null || _a3 === void 0 ? void 0 : _a3.showSelector();
  }
};
PostEditWidgetManager = __decorate$y([
  __param$y(4, IInstantiationService),
  __param$y(5, IBulkEditService)
], PostEditWidgetManager);
var __decorate$x = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$x = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$u = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const changePasteTypeCommandId = "editor.changePasteType";
const pasteWidgetVisibleCtx = new RawContextKey("pasteWidgetVisible", false, localize("pasteWidgetVisible", "Whether the paste widget is showing"));
const vscodeClipboardMime = "application/vnd.code.copyMetadata";
let CopyPasteController = class CopyPasteController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(CopyPasteController2.ID);
  }
  constructor(editor2, instantiationService, _bulkEditService, _clipboardService, _languageFeaturesService, _quickInputService, _progressService) {
    super();
    this._bulkEditService = _bulkEditService;
    this._clipboardService = _clipboardService;
    this._languageFeaturesService = _languageFeaturesService;
    this._quickInputService = _quickInputService;
    this._progressService = _progressService;
    this._editor = editor2;
    const container = editor2.getContainerDomNode();
    this._register(addDisposableListener(container, "copy", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "cut", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "paste", (e) => this.handlePaste(e), true));
    this._pasteProgressManager = this._register(new InlineProgressManager("pasteIntoEditor", editor2, instantiationService));
    this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, "pasteIntoEditor", editor2, pasteWidgetVisibleCtx, { id: changePasteTypeCommandId, label: localize("postPasteWidgetTitle", "Show paste options...") }));
  }
  changePasteType() {
    this._postPasteWidgetManager.tryShowSelector();
  }
  pasteAs(preferredId) {
    this._editor.focus();
    try {
      this._pasteAsActionContext = { preferredId };
      document.execCommand("paste");
    } finally {
      this._pasteAsActionContext = void 0;
    }
  }
  clearWidgets() {
    this._postPasteWidgetManager.clear();
  }
  isPasteAsEnabled() {
    return this._editor.getOption(
      83
      /* EditorOption.pasteAs */
    ).enabled && !this._editor.getOption(
      89
      /* EditorOption.readOnly */
    );
  }
  handleCopy(e) {
    var _a3, _b3;
    if (!this._editor.hasTextFocus()) {
      return;
    }
    if (isWeb) {
      this._clipboardService.writeResources([]);
    }
    if (!e.clipboardData || !this.isPasteAsEnabled()) {
      return;
    }
    const model = this._editor.getModel();
    const selections = this._editor.getSelections();
    if (!model || !(selections === null || selections === void 0 ? void 0 : selections.length)) {
      return;
    }
    const enableEmptySelectionClipboard = this._editor.getOption(
      36
      /* EditorOption.emptySelectionClipboard */
    );
    let ranges = selections;
    const wasFromEmptySelection = selections.length === 1 && selections[0].isEmpty();
    if (wasFromEmptySelection) {
      if (!enableEmptySelectionClipboard) {
        return;
      }
      ranges = [new Range$1(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];
    }
    const toCopy = (_a3 = this._editor._getViewModel()) === null || _a3 === void 0 ? void 0 : _a3.getPlainTextToCopy(selections, enableEmptySelectionClipboard, isWindows);
    const multicursorText = Array.isArray(toCopy) ? toCopy : null;
    const defaultPastePayload = {
      multicursorText,
      pasteOnNewLine: wasFromEmptySelection,
      mode: null
    };
    const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((x) => !!x.prepareDocumentPaste);
    if (!providers.length) {
      this.setCopyMetadata(e.clipboardData, { defaultPastePayload });
      return;
    }
    const dataTransfer = toVSDataTransfer(e.clipboardData);
    const providerCopyMimeTypes = providers.flatMap((x) => {
      var _a4;
      return (_a4 = x.copyMimeTypes) !== null && _a4 !== void 0 ? _a4 : [];
    });
    const handle = generateUuid();
    this.setCopyMetadata(e.clipboardData, {
      id: handle,
      providerCopyMimeTypes,
      defaultPastePayload
    });
    const promise = createCancelablePromise((token) => __awaiter$u(this, void 0, void 0, function* () {
      const results = coalesce(yield Promise.all(providers.map((provider) => __awaiter$u(this, void 0, void 0, function* () {
        try {
          return yield provider.prepareDocumentPaste(model, ranges, dataTransfer, token);
        } catch (err) {
          console.error(err);
          return void 0;
        }
      }))));
      results.reverse();
      for (const result of results) {
        for (const [mime, value] of result) {
          dataTransfer.replace(mime, value);
        }
      }
      return dataTransfer;
    }));
    (_b3 = this._currentCopyOperation) === null || _b3 === void 0 ? void 0 : _b3.dataTransferPromise.cancel();
    this._currentCopyOperation = { handle, dataTransferPromise: promise };
  }
  handlePaste(e) {
    var _a3, _b3;
    return __awaiter$u(this, void 0, void 0, function* () {
      if (!e.clipboardData || !this._editor.hasTextFocus()) {
        return;
      }
      (_a3 = this._currentPasteOperation) === null || _a3 === void 0 ? void 0 : _a3.cancel();
      this._currentPasteOperation = void 0;
      const model = this._editor.getModel();
      const selections = this._editor.getSelections();
      if (!(selections === null || selections === void 0 ? void 0 : selections.length) || !model) {
        return;
      }
      if (!this.isPasteAsEnabled()) {
        return;
      }
      const metadata = this.fetchCopyMetadata(e);
      const dataTransfer = toExternalVSDataTransfer(e.clipboardData);
      dataTransfer.delete(vscodeClipboardMime);
      const allPotentialMimeTypes = [
        ...e.clipboardData.types,
        ...(_b3 = metadata === null || metadata === void 0 ? void 0 : metadata.providerCopyMimeTypes) !== null && _b3 !== void 0 ? _b3 : [],
        // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.
        // However we can only check the system clipboard async. For this early check, just add it in.
        // We filter providers again once we have the final dataTransfer we will use.
        Mimes.uriList
      ];
      const allProviders = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((provider) => {
        var _a4;
        return (_a4 = provider.pasteMimeTypes) === null || _a4 === void 0 ? void 0 : _a4.some((type) => matchesMimeType(type, allPotentialMimeTypes));
      });
      if (!allProviders.length) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
      if (this._pasteAsActionContext) {
        this.showPasteAsPick(this._pasteAsActionContext.preferredId, allProviders, selections, dataTransfer, metadata);
      } else {
        this.doPasteInline(allProviders, selections, dataTransfer, metadata);
      }
    });
  }
  doPasteInline(allProviders, selections, dataTransfer, metadata) {
    const p = createCancelablePromise((token) => __awaiter$u(this, void 0, void 0, function* () {
      const editor2 = this._editor;
      if (!editor2.hasModel()) {
        return;
      }
      const model = editor2.getModel();
      const tokenSource = new EditorStateCancellationTokenSource(editor2, 1 | 2, void 0, token);
      try {
        yield this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        const supportedProviders = allProviders.filter((provider) => isSupportedPasteProvider(provider, dataTransfer));
        if (!supportedProviders.length || supportedProviders.length === 1 && supportedProviders[0].id === "text") {
          yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
          return;
        }
        const providerEdits = yield this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        if (providerEdits.length === 1 && providerEdits[0].id === "text") {
          yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
          return;
        }
        if (providerEdits.length) {
          const canShowWidget = editor2.getOption(
            83
            /* EditorOption.pasteAs */
          ).showPasteSelector === "afterPaste";
          return this._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, { activeEditIndex: 0, allEdits: providerEdits }, canShowWidget, tokenSource.token);
        }
        yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
      } finally {
        tokenSource.dispose();
        if (this._currentPasteOperation === p) {
          this._currentPasteOperation = void 0;
        }
      }
    }));
    this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize("pasteIntoEditorProgress", "Running paste handlers. Click to cancel"), p);
    this._currentPasteOperation = p;
  }
  showPasteAsPick(preferredId, allProviders, selections, dataTransfer, metadata) {
    const p = createCancelablePromise((token) => __awaiter$u(this, void 0, void 0, function* () {
      const editor2 = this._editor;
      if (!editor2.hasModel()) {
        return;
      }
      const model = editor2.getModel();
      const tokenSource = new EditorStateCancellationTokenSource(editor2, 1 | 2, void 0, token);
      try {
        yield this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        const supportedProviders = allProviders.filter((provider) => isSupportedPasteProvider(provider, dataTransfer));
        const providerEdits = yield this.getPasteEdits(supportedProviders, dataTransfer, model, selections, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        if (!providerEdits.length) {
          return;
        }
        let pickedEdit;
        if (typeof preferredId === "string") {
          pickedEdit = providerEdits.find((edit) => edit.id === preferredId);
        } else {
          const selected = yield this._quickInputService.pick(providerEdits.map((edit) => ({
            label: edit.label,
            description: edit.id,
            detail: edit.detail,
            edit
          })), {
            placeHolder: localize("pasteAsPickerPlaceholder", "Select Paste Action")
          });
          pickedEdit = selected === null || selected === void 0 ? void 0 : selected.edit;
        }
        if (!pickedEdit) {
          return;
        }
        const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);
        yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });
      } finally {
        tokenSource.dispose();
        if (this._currentPasteOperation === p) {
          this._currentPasteOperation = void 0;
        }
      }
    }));
    this._progressService.withProgress({
      location: 10,
      title: localize("pasteAsProgress", "Running paste handlers")
    }, () => p);
  }
  setCopyMetadata(dataTransfer, metadata) {
    dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));
  }
  fetchCopyMetadata(e) {
    if (!e.clipboardData) {
      return;
    }
    const rawMetadata = e.clipboardData.getData(vscodeClipboardMime);
    if (rawMetadata) {
      try {
        return JSON.parse(rawMetadata);
      } catch (_a3) {
        return void 0;
      }
    }
    const [_, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);
    if (metadata) {
      return {
        defaultPastePayload: {
          mode: metadata.mode,
          multicursorText: withUndefinedAsNull(metadata.multicursorText),
          pasteOnNewLine: !!metadata.isFromEmptySelection
        }
      };
    }
    return void 0;
  }
  mergeInDataFromCopy(dataTransfer, metadata, token) {
    var _a3;
    return __awaiter$u(this, void 0, void 0, function* () {
      if ((metadata === null || metadata === void 0 ? void 0 : metadata.id) && ((_a3 = this._currentCopyOperation) === null || _a3 === void 0 ? void 0 : _a3.handle) === metadata.id) {
        const toMergeDataTransfer = yield this._currentCopyOperation.dataTransferPromise;
        if (token.isCancellationRequested) {
          return;
        }
        for (const [key, value] of toMergeDataTransfer) {
          dataTransfer.replace(key, value);
        }
      }
      if (!dataTransfer.has(Mimes.uriList)) {
        const resources = yield this._clipboardService.readResources();
        if (token.isCancellationRequested) {
          return;
        }
        if (resources.length) {
          dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));
        }
      }
    });
  }
  getPasteEdits(providers, dataTransfer, model, selections, token) {
    return __awaiter$u(this, void 0, void 0, function* () {
      const result = yield raceCancellation(Promise.all(providers.map((provider) => {
        var _a3;
        try {
          return (_a3 = provider.provideDocumentPasteEdits) === null || _a3 === void 0 ? void 0 : _a3.call(provider, model, selections, dataTransfer, token);
        } catch (err) {
          console.error(err);
          return void 0;
        }
      })).then(coalesce), token);
      result === null || result === void 0 ? void 0 : result.sort((a, b) => b.priority - a.priority);
      return result !== null && result !== void 0 ? result : [];
    });
  }
  applyDefaultPasteHandler(dataTransfer, metadata, token) {
    var _a3, _b3, _c3;
    return __awaiter$u(this, void 0, void 0, function* () {
      const textDataTransfer = (_a3 = dataTransfer.get(Mimes.text)) !== null && _a3 !== void 0 ? _a3 : dataTransfer.get("text");
      if (!textDataTransfer) {
        return;
      }
      const text = yield textDataTransfer.asString();
      if (token.isCancellationRequested) {
        return;
      }
      const payload = {
        text,
        pasteOnNewLine: (_b3 = metadata === null || metadata === void 0 ? void 0 : metadata.defaultPastePayload.pasteOnNewLine) !== null && _b3 !== void 0 ? _b3 : false,
        multicursorText: (_c3 = metadata === null || metadata === void 0 ? void 0 : metadata.defaultPastePayload.multicursorText) !== null && _c3 !== void 0 ? _c3 : null,
        mode: null
      };
      this._editor.trigger("keyboard", "paste", payload);
    });
  }
};
CopyPasteController.ID = "editor.contrib.copyPasteActionController";
CopyPasteController = __decorate$x([
  __param$x(1, IInstantiationService),
  __param$x(2, IBulkEditService),
  __param$x(3, IClipboardService),
  __param$x(4, ILanguageFeaturesService),
  __param$x(5, IQuickInputService),
  __param$x(6, IProgressService)
], CopyPasteController);
function isSupportedPasteProvider(provider, dataTransfer) {
  var _a3;
  return Boolean((_a3 = provider.pasteMimeTypes) === null || _a3 === void 0 ? void 0 : _a3.some((type) => dataTransfer.matches(type)));
}
var __decorate$w = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$w = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$t = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const builtInLabel = localize("builtIn", "Built-in");
class SimplePasteAndDropProvider {
  provideDocumentPasteEdits(_model, _ranges, dataTransfer, token) {
    return __awaiter$t(this, void 0, void 0, function* () {
      const edit = yield this.getEdit(dataTransfer, token);
      return edit ? { id: this.id, insertText: edit.insertText, label: edit.label, detail: edit.detail, priority: edit.priority } : void 0;
    });
  }
  provideDocumentOnDropEdits(_model, _position, dataTransfer, token) {
    return __awaiter$t(this, void 0, void 0, function* () {
      const edit = yield this.getEdit(dataTransfer, token);
      return edit ? { id: this.id, insertText: edit.insertText, label: edit.label, priority: edit.priority } : void 0;
    });
  }
}
class DefaultTextProvider extends SimplePasteAndDropProvider {
  constructor() {
    super(...arguments);
    this.id = "text";
    this.dropMimeTypes = [Mimes.text];
    this.pasteMimeTypes = [Mimes.text];
  }
  getEdit(dataTransfer, _token) {
    return __awaiter$t(this, void 0, void 0, function* () {
      const textEntry = dataTransfer.get(Mimes.text);
      if (!textEntry) {
        return;
      }
      if (dataTransfer.has(Mimes.uriList)) {
        return;
      }
      const insertText = yield textEntry.asString();
      return {
        id: this.id,
        priority: 0,
        label: localize("text.label", "Insert Plain Text"),
        detail: builtInLabel,
        insertText
      };
    });
  }
}
class PathProvider extends SimplePasteAndDropProvider {
  constructor() {
    super(...arguments);
    this.id = "uri";
    this.dropMimeTypes = [Mimes.uriList];
    this.pasteMimeTypes = [Mimes.uriList];
  }
  getEdit(dataTransfer, token) {
    return __awaiter$t(this, void 0, void 0, function* () {
      const entries = yield extractUriList(dataTransfer);
      if (!entries.length || token.isCancellationRequested) {
        return;
      }
      let uriCount = 0;
      const insertText = entries.map(({ uri, originalText }) => {
        if (uri.scheme === Schemas.file) {
          return uri.fsPath;
        } else {
          uriCount++;
          return originalText;
        }
      }).join(" ");
      let label;
      if (uriCount > 0) {
        label = entries.length > 1 ? localize("defaultDropProvider.uriList.uris", "Insert Uris") : localize("defaultDropProvider.uriList.uri", "Insert Uri");
      } else {
        label = entries.length > 1 ? localize("defaultDropProvider.uriList.paths", "Insert Paths") : localize("defaultDropProvider.uriList.path", "Insert Path");
      }
      return {
        id: this.id,
        priority: 0,
        insertText,
        label,
        detail: builtInLabel
      };
    });
  }
}
let RelativePathProvider = class RelativePathProvider2 extends SimplePasteAndDropProvider {
  constructor(_workspaceContextService) {
    super();
    this._workspaceContextService = _workspaceContextService;
    this.id = "relativePath";
    this.dropMimeTypes = [Mimes.uriList];
    this.pasteMimeTypes = [Mimes.uriList];
  }
  getEdit(dataTransfer, token) {
    return __awaiter$t(this, void 0, void 0, function* () {
      const entries = yield extractUriList(dataTransfer);
      if (!entries.length || token.isCancellationRequested) {
        return;
      }
      const relativeUris = coalesce(entries.map(({ uri }) => {
        const root = this._workspaceContextService.getWorkspaceFolder(uri);
        return root ? relativePath(root.uri, uri) : void 0;
      }));
      if (!relativeUris.length) {
        return;
      }
      return {
        id: this.id,
        priority: 0,
        insertText: relativeUris.join(" "),
        label: entries.length > 1 ? localize("defaultDropProvider.uriList.relativePaths", "Insert Relative Paths") : localize("defaultDropProvider.uriList.relativePath", "Insert Relative Path"),
        detail: builtInLabel
      };
    });
  }
};
RelativePathProvider = __decorate$w([
  __param$w(0, IWorkspaceContextService)
], RelativePathProvider);
function extractUriList(dataTransfer) {
  return __awaiter$t(this, void 0, void 0, function* () {
    const urlListEntry = dataTransfer.get(Mimes.uriList);
    if (!urlListEntry) {
      return [];
    }
    const strUriList = yield urlListEntry.asString();
    const entries = [];
    for (const entry of UriList.parse(strUriList)) {
      try {
        entries.push({ uri: URI$1.parse(entry), originalText: entry });
      } catch (_a3) {
      }
    }
    return entries;
  });
}
let DefaultDropProvidersFeature = class DefaultDropProvidersFeature2 extends Disposable {
  constructor(languageFeaturesService, workspaceContextService) {
    super();
    this._register(languageFeaturesService.documentOnDropEditProvider.register("*", new DefaultTextProvider()));
    this._register(languageFeaturesService.documentOnDropEditProvider.register("*", new PathProvider()));
    this._register(languageFeaturesService.documentOnDropEditProvider.register("*", new RelativePathProvider(workspaceContextService)));
  }
};
DefaultDropProvidersFeature = __decorate$w([
  __param$w(0, ILanguageFeaturesService),
  __param$w(1, IWorkspaceContextService)
], DefaultDropProvidersFeature);
let DefaultPasteProvidersFeature = class DefaultPasteProvidersFeature2 extends Disposable {
  constructor(languageFeaturesService, workspaceContextService) {
    super();
    this._register(languageFeaturesService.documentPasteEditProvider.register("*", new DefaultTextProvider()));
    this._register(languageFeaturesService.documentPasteEditProvider.register("*", new PathProvider()));
    this._register(languageFeaturesService.documentPasteEditProvider.register("*", new RelativePathProvider(workspaceContextService)));
  }
};
DefaultPasteProvidersFeature = __decorate$w([
  __param$w(0, ILanguageFeaturesService),
  __param$w(1, IWorkspaceContextService)
], DefaultPasteProvidersFeature);
registerEditorContribution(
  CopyPasteController.ID,
  CopyPasteController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorFeature(DefaultPasteProvidersFeature);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: changePasteTypeCommandId,
      precondition: pasteWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 2048 | 89
      }
    });
  }
  runEditorCommand(_accessor, editor2, _args) {
    var _a3;
    return (_a3 = CopyPasteController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.changePasteType();
  }
}());
registerEditorAction(class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.pasteAs",
      label: localize("pasteAs", "Paste As..."),
      alias: "Paste As...",
      precondition: void 0,
      description: {
        description: "Paste as",
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "id": {
                type: "string",
                description: localize("pasteAs.id", "The id of the paste edit to try applying. If not provided, the editor will show a picker.")
              }
            }
          }
        }]
      }
    });
  }
  run(_accessor, editor2, args) {
    var _a3;
    const id = typeof (args === null || args === void 0 ? void 0 : args.id) === "string" ? args.id : void 0;
    return (_a3 = CopyPasteController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.pasteAs(id);
  }
});
var __decorate$v = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$v = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$s = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const changeDropTypeCommandId = "editor.changeDropType";
const dropWidgetVisibleCtx = new RawContextKey("dropWidgetVisible", false, localize("dropWidgetVisible", "Whether the drop widget is showing"));
let DropIntoEditorController = class DropIntoEditorController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(DropIntoEditorController2.ID);
  }
  constructor(editor2, instantiationService, _languageFeaturesService, _treeViewsDragAndDropService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this._treeViewsDragAndDropService = _treeViewsDragAndDropService;
    this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
    this._dropProgressManager = this._register(instantiationService.createInstance(InlineProgressManager, "dropIntoEditor", editor2));
    this._postDropWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, "dropIntoEditor", editor2, dropWidgetVisibleCtx, { id: changeDropTypeCommandId, label: localize("postDropWidgetTitle", "Show drop options...") }));
    this._register(editor2.onDropIntoEditor((e) => this.onDropIntoEditor(editor2, e.position, e.event)));
  }
  clearWidgets() {
    this._postDropWidgetManager.clear();
  }
  changeDropType() {
    this._postDropWidgetManager.tryShowSelector();
  }
  onDropIntoEditor(editor2, position, dragEvent) {
    var _a3;
    return __awaiter$s(this, void 0, void 0, function* () {
      if (!dragEvent.dataTransfer || !editor2.hasModel()) {
        return;
      }
      (_a3 = this._currentOperation) === null || _a3 === void 0 ? void 0 : _a3.cancel();
      editor2.focus();
      editor2.setPosition(position);
      const p = createCancelablePromise((token) => __awaiter$s(this, void 0, void 0, function* () {
        const tokenSource = new EditorStateCancellationTokenSource(editor2, 1, void 0, token);
        try {
          const ourDataTransfer = yield this.extractDataTransferData(dragEvent);
          if (ourDataTransfer.size === 0 || tokenSource.token.isCancellationRequested) {
            return;
          }
          const model = editor2.getModel();
          if (!model) {
            return;
          }
          const providers = this._languageFeaturesService.documentOnDropEditProvider.ordered(model).filter((provider) => {
            if (!provider.dropMimeTypes) {
              return true;
            }
            return provider.dropMimeTypes.some((mime) => ourDataTransfer.matches(mime));
          });
          const edits = yield this.getDropEdits(providers, model, position, ourDataTransfer, tokenSource);
          if (tokenSource.token.isCancellationRequested) {
            return;
          }
          if (edits.length) {
            const canShowWidget = editor2.getOption(
              35
              /* EditorOption.dropIntoEditor */
            ).showDropSelector === "afterDrop";
            yield this._postDropWidgetManager.applyEditAndShowIfNeeded([Range$1.fromPositions(position)], { activeEditIndex: 0, allEdits: edits }, canShowWidget, token);
          }
        } finally {
          tokenSource.dispose();
          if (this._currentOperation === p) {
            this._currentOperation = void 0;
          }
        }
      }));
      this._dropProgressManager.showWhile(position, localize("dropIntoEditorProgress", "Running drop handlers. Click to cancel"), p);
      this._currentOperation = p;
    });
  }
  getDropEdits(providers, model, position, dataTransfer, tokenSource) {
    return __awaiter$s(this, void 0, void 0, function* () {
      const results = yield raceCancellation(Promise.all(providers.map((provider) => {
        return provider.provideDocumentOnDropEdits(model, position, dataTransfer, tokenSource.token);
      })), tokenSource.token);
      const edits = coalesce(results !== null && results !== void 0 ? results : []);
      edits.sort((a, b) => b.priority - a.priority);
      return edits;
    });
  }
  extractDataTransferData(dragEvent) {
    return __awaiter$s(this, void 0, void 0, function* () {
      if (!dragEvent.dataTransfer) {
        return new VSDataTransfer();
      }
      const dataTransfer = toExternalVSDataTransfer(dragEvent.dataTransfer);
      if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
        const data = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype);
        if (Array.isArray(data)) {
          for (const id of data) {
            const treeDataTransfer = yield this._treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
            if (treeDataTransfer) {
              for (const [type, value] of treeDataTransfer) {
                dataTransfer.replace(type, value);
              }
            }
          }
        }
      }
      return dataTransfer;
    });
  }
};
DropIntoEditorController.ID = "editor.contrib.dropIntoEditorController";
DropIntoEditorController = __decorate$v([
  __param$v(1, IInstantiationService),
  __param$v(2, ILanguageFeaturesService),
  __param$v(3, ITreeViewsDnDService)
], DropIntoEditorController);
registerEditorContribution(
  DropIntoEditorController.ID,
  DropIntoEditorController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: changeDropTypeCommandId,
      precondition: dropWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 2048 | 89
      }
    });
  }
  runEditorCommand(_accessor, editor2, _args) {
    var _a3;
    (_a3 = DropIntoEditorController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.changeDropType();
  }
}());
registerEditorFeature(DefaultDropProvidersFeature);
class FindDecorations {
  constructor(editor2) {
    this._editor = editor2;
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
    this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.removeDecorations(this._allDecorations());
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  /** @deprecated use getFindScopes to support multiple selections */
  getFindScope() {
    if (this._findScopeDecorationIds[0]) {
      return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
    }
    return null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
      if (scopes.length) {
        return scopes;
      }
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(newStartPosition) {
    this._startPosition = newStartPosition;
    this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(decorationId) {
    const index2 = this._decorations.indexOf(decorationId);
    if (index2 >= 0) {
      return index2 + 1;
    }
    return 1;
  }
  getDecorationRangeAt(index2) {
    const decorationId = index2 < this._decorations.length ? this._decorations[index2] : null;
    if (decorationId) {
      return this._editor.getModel().getDecorationRange(decorationId);
    }
    return null;
  }
  getCurrentMatchesPosition(desiredRange) {
    const candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
    for (const candidate of candidates) {
      const candidateOpts = candidate.options;
      if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
        return this._getDecorationIndex(candidate.id);
      }
    }
    return 0;
  }
  setCurrentFindMatch(nextMatch) {
    let newCurrentDecorationId = null;
    let matchPosition = 0;
    if (nextMatch) {
      for (let i = 0, len = this._decorations.length; i < len; i++) {
        const range = this._editor.getModel().getDecorationRange(this._decorations[i]);
        if (nextMatch.equalsRange(range)) {
          newCurrentDecorationId = this._decorations[i];
          matchPosition = i + 1;
          break;
        }
      }
    }
    if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
      this._editor.changeDecorations((changeAccessor) => {
        if (this._highlightedDecorationId !== null) {
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);
          this._highlightedDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          this._highlightedDecorationId = newCurrentDecorationId;
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);
        }
        if (this._rangeHighlightDecorationId !== null) {
          changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
          this._rangeHighlightDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
          if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
            const lineBeforeEnd = rng.endLineNumber - 1;
            const lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
            rng = new Range$1(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
          }
          this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);
        }
      });
    }
    return matchPosition;
  }
  set(findMatches, findScopes) {
    this._editor.changeDecorations((accessor) => {
      let findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;
      const newOverviewRulerApproximateDecorations = [];
      if (findMatches.length > 1e3) {
        findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const lineCount = this._editor.getModel().getLineCount();
        const height = this._editor.getLayoutInfo().height;
        const approxPixelsPerLine = height / lineCount;
        const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
        let prevStartLineNumber = findMatches[0].range.startLineNumber;
        let prevEndLineNumber = findMatches[0].range.endLineNumber;
        for (let i = 1, len = findMatches.length; i < len; i++) {
          const range = findMatches[i].range;
          if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {
            if (range.endLineNumber > prevEndLineNumber) {
              prevEndLineNumber = range.endLineNumber;
            }
          } else {
            newOverviewRulerApproximateDecorations.push({
              range: new Range$1(prevStartLineNumber, 1, prevEndLineNumber, 1),
              options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            });
            prevStartLineNumber = range.startLineNumber;
            prevEndLineNumber = range.endLineNumber;
          }
        }
        newOverviewRulerApproximateDecorations.push({
          range: new Range$1(prevStartLineNumber, 1, prevEndLineNumber, 1),
          options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      const newFindMatchesDecorations = new Array(findMatches.length);
      for (let i = 0, len = findMatches.length; i < len; i++) {
        newFindMatchesDecorations[i] = {
          range: findMatches[i].range,
          options: findMatchesOptions
        };
      }
      this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
      this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
      if (this._rangeHighlightDecorationId) {
        accessor.removeDecoration(this._rangeHighlightDecorationId);
        this._rangeHighlightDecorationId = null;
      }
      if (this._findScopeDecorationIds.length) {
        this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
        this._findScopeDecorationIds = [];
      }
      if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {
        this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));
      }
    });
  }
  matchBeforePosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = this._decorations.length - 1; i >= 0; i--) {
      const decorationId = this._decorations[i];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.endLineNumber > position.lineNumber) {
        continue;
      }
      if (r.endLineNumber < position.lineNumber) {
        return r;
      }
      if (r.endColumn > position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = 0, len = this._decorations.length; i < len; i++) {
      const decorationId = this._decorations[i];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.startLineNumber < position.lineNumber) {
        continue;
      }
      if (r.startLineNumber > position.lineNumber) {
        return r;
      }
      if (r.startColumn < position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let result = [];
    result = result.concat(this._decorations);
    result = result.concat(this._overviewRulerApproximateDecorations);
    if (this._findScopeDecorationIds.length) {
      result.push(...this._findScopeDecorationIds);
    }
    if (this._rangeHighlightDecorationId) {
      result.push(this._rangeHighlightDecorationId);
    }
    return result;
  }
}
FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: true
});
FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  }
});
FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
});
FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: true
});
class ReplaceAllCommand {
  constructor(editorSelection, ranges, replaceStrings) {
    this._editorSelection = editorSelection;
    this._ranges = ranges;
    this._replaceStrings = replaceStrings;
    this._trackedEditorSelectionId = null;
  }
  getEditOperations(model, builder) {
    if (this._ranges.length > 0) {
      const ops = [];
      for (let i = 0; i < this._ranges.length; i++) {
        ops.push({
          range: this._ranges[i],
          text: this._replaceStrings[i]
        });
      }
      ops.sort((o1, o2) => {
        return Range$1.compareRangesUsingStarts(o1.range, o2.range);
      });
      const resultOps = [];
      let previousOp = ops[0];
      for (let i = 1; i < ops.length; i++) {
        if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
          previousOp.range = previousOp.range.plusRange(ops[i].range);
          previousOp.text = previousOp.text + ops[i].text;
        } else {
          resultOps.push(previousOp);
          previousOp = ops[i];
        }
      }
      resultOps.push(previousOp);
      for (const op of resultOps) {
        builder.addEditOperation(op.range, op.text);
      }
    }
    this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._trackedEditorSelectionId);
  }
}
class StaticValueReplacePattern {
  constructor(staticValue) {
    this.staticValue = staticValue;
    this.kind = 0;
  }
}
class DynamicPiecesReplacePattern {
  constructor(pieces) {
    this.pieces = pieces;
    this.kind = 1;
  }
}
class ReplacePattern {
  static fromStaticValue(value) {
    return new ReplacePattern([ReplacePiece.staticValue(value)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  constructor(pieces) {
    if (!pieces || pieces.length === 0) {
      this._state = new StaticValueReplacePattern("");
    } else if (pieces.length === 1 && pieces[0].staticValue !== null) {
      this._state = new StaticValueReplacePattern(pieces[0].staticValue);
    } else {
      this._state = new DynamicPiecesReplacePattern(pieces);
    }
  }
  buildReplaceString(matches, preserveCase) {
    if (this._state.kind === 0) {
      if (preserveCase) {
        return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
      } else {
        return this._state.staticValue;
      }
    }
    let result = "";
    for (let i = 0, len = this._state.pieces.length; i < len; i++) {
      const piece = this._state.pieces[i];
      if (piece.staticValue !== null) {
        result += piece.staticValue;
        continue;
      }
      let match2 = ReplacePattern._substitute(piece.matchIndex, matches);
      if (piece.caseOps !== null && piece.caseOps.length > 0) {
        const repl = [];
        const lenOps = piece.caseOps.length;
        let opIdx = 0;
        for (let idx = 0, len2 = match2.length; idx < len2; idx++) {
          if (opIdx >= lenOps) {
            repl.push(match2.slice(idx));
            break;
          }
          switch (piece.caseOps[opIdx]) {
            case "U":
              repl.push(match2[idx].toUpperCase());
              break;
            case "u":
              repl.push(match2[idx].toUpperCase());
              opIdx++;
              break;
            case "L":
              repl.push(match2[idx].toLowerCase());
              break;
            case "l":
              repl.push(match2[idx].toLowerCase());
              opIdx++;
              break;
            default:
              repl.push(match2[idx]);
          }
        }
        match2 = repl.join("");
      }
      result += match2;
    }
    return result;
  }
  static _substitute(matchIndex, matches) {
    if (matches === null) {
      return "";
    }
    if (matchIndex === 0) {
      return matches[0];
    }
    let remainder = "";
    while (matchIndex > 0) {
      if (matchIndex < matches.length) {
        const match2 = matches[matchIndex] || "";
        return match2 + remainder;
      }
      remainder = String(matchIndex % 10) + remainder;
      matchIndex = Math.floor(matchIndex / 10);
    }
    return "$" + remainder;
  }
}
class ReplacePiece {
  static staticValue(value) {
    return new ReplacePiece(value, -1, null);
  }
  static matchIndex(index2) {
    return new ReplacePiece(null, index2, null);
  }
  static caseOps(index2, caseOps) {
    return new ReplacePiece(null, index2, caseOps);
  }
  constructor(staticValue, matchIndex, caseOps) {
    this.staticValue = staticValue;
    this.matchIndex = matchIndex;
    if (!caseOps || caseOps.length === 0) {
      this.caseOps = null;
    } else {
      this.caseOps = caseOps.slice(0);
    }
  }
}
class ReplacePieceBuilder {
  constructor(source) {
    this._source = source;
    this._lastCharIndex = 0;
    this._result = [];
    this._resultLen = 0;
    this._currentStaticPiece = "";
  }
  emitUnchanged(toCharIndex) {
    this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
    this._lastCharIndex = toCharIndex;
  }
  emitStatic(value, toCharIndex) {
    this._emitStatic(value);
    this._lastCharIndex = toCharIndex;
  }
  _emitStatic(value) {
    if (value.length === 0) {
      return;
    }
    this._currentStaticPiece += value;
  }
  emitMatchIndex(index2, toCharIndex, caseOps) {
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    this._result[this._resultLen++] = ReplacePiece.caseOps(index2, caseOps);
    this._lastCharIndex = toCharIndex;
  }
  finalize() {
    this.emitUnchanged(this._source.length);
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    return new ReplacePattern(this._result);
  }
}
function parseReplaceString(replaceString) {
  if (!replaceString || replaceString.length === 0) {
    return new ReplacePattern(null);
  }
  const caseOps = [];
  const result = new ReplacePieceBuilder(replaceString);
  for (let i = 0, len = replaceString.length; i < len; i++) {
    const chCode = replaceString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i);
      switch (nextChCode) {
        case 92:
          result.emitUnchanged(i - 1);
          result.emitStatic("\\", i + 1);
          break;
        case 110:
          result.emitUnchanged(i - 1);
          result.emitStatic("\n", i + 1);
          break;
        case 116:
          result.emitUnchanged(i - 1);
          result.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          result.emitUnchanged(i - 1);
          result.emitStatic("", i + 1);
          caseOps.push(String.fromCharCode(nextChCode));
          break;
      }
      continue;
    }
    if (chCode === 36) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i);
      if (nextChCode === 36) {
        result.emitUnchanged(i - 1);
        result.emitStatic("$", i + 1);
        continue;
      }
      if (nextChCode === 48 || nextChCode === 38) {
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(0, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
      if (49 <= nextChCode && nextChCode <= 57) {
        let matchIndex = nextChCode - 48;
        if (i + 1 < len) {
          const nextNextChCode = replaceString.charCodeAt(i + 1);
          if (48 <= nextNextChCode && nextNextChCode <= 57) {
            i++;
            matchIndex = matchIndex * 10 + (nextNextChCode - 48);
            result.emitUnchanged(i - 2);
            result.emitMatchIndex(matchIndex, i + 1, caseOps);
            caseOps.length = 0;
            continue;
          }
        }
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(matchIndex, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
    }
  }
  return result.finalize();
}
const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
const CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
const ToggleCaseSensitiveKeybinding = {
  primary: 512 | 33,
  mac: {
    primary: 2048 | 512 | 33
    /* KeyCode.KeyC */
  }
};
const ToggleWholeWordKeybinding = {
  primary: 512 | 53,
  mac: {
    primary: 2048 | 512 | 53
    /* KeyCode.KeyW */
  }
};
const ToggleRegexKeybinding = {
  primary: 512 | 48,
  mac: {
    primary: 2048 | 512 | 48
    /* KeyCode.KeyR */
  }
};
const ToggleSearchScopeKeybinding = {
  primary: 512 | 42,
  mac: {
    primary: 2048 | 512 | 42
    /* KeyCode.KeyL */
  }
};
const TogglePreserveCaseKeybinding = {
  primary: 512 | 46,
  mac: {
    primary: 2048 | 512 | 46
    /* KeyCode.KeyP */
  }
};
const FIND_IDS = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  GoToMatchFindAction: "editor.action.goToMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
};
const MATCHES_LIMIT = 19999;
const RESEARCH_DELAY = 240;
class FindModelBoundToEditorModel {
  constructor(editor2, state) {
    this._toDispose = new DisposableStore();
    this._editor = editor2;
    this._state = state;
    this._isDisposed = false;
    this._startSearchingTimer = new TimeoutTimer();
    this._decorations = new FindDecorations(editor2);
    this._toDispose.add(this._decorations);
    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);
    this._toDispose.add(this._updateDecorationsScheduler);
    this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
      if (e.reason === 3 || e.reason === 5 || e.reason === 6) {
        this._decorations.setStartPosition(this._editor.getPosition());
      }
    }));
    this._ignoreModelContentChanged = false;
    this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (this._ignoreModelContentChanged) {
        return;
      }
      if (e.isFlush) {
        this._decorations.reset();
      }
      this._decorations.setStartPosition(this._editor.getPosition());
      this._updateDecorationsScheduler.schedule();
    }));
    this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this.research(false, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = true;
    dispose(this._startSearchingTimer);
    this._toDispose.dispose();
  }
  _onStateChanged(e) {
    if (this._isDisposed) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
      const model = this._editor.getModel();
      if (model.isTooLargeForSyncing()) {
        this._startSearchingTimer.cancel();
        this._startSearchingTimer.setIfNotSet(() => {
          if (e.searchScope) {
            this.research(e.moveCursor, this._state.searchScope);
          } else {
            this.research(e.moveCursor);
          }
        }, RESEARCH_DELAY);
      } else {
        if (e.searchScope) {
          this.research(e.moveCursor, this._state.searchScope);
        } else {
          this.research(e.moveCursor);
        }
      }
    }
  }
  static _getSearchRange(model, findScope) {
    if (findScope) {
      return findScope;
    }
    return model.getFullModelRange();
  }
  research(moveCursor, newFindScope) {
    let findScopes = null;
    if (typeof newFindScope !== "undefined") {
      if (newFindScope !== null) {
        if (!Array.isArray(newFindScope)) {
          findScopes = [newFindScope];
        } else {
          findScopes = newFindScope;
        }
      }
    } else {
      findScopes = this._decorations.getFindScopes();
    }
    if (findScopes !== null) {
      findScopes = findScopes.map((findScope) => {
        if (findScope.startLineNumber !== findScope.endLineNumber) {
          let endLineNumber = findScope.endLineNumber;
          if (findScope.endColumn === 1) {
            endLineNumber = endLineNumber - 1;
          }
          return new Range$1(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
        }
        return findScope;
      });
    }
    const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
    this._decorations.set(findMatches, findScopes);
    const editorSelection = this._editor.getSelection();
    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
    if (currentMatchesPosition === 0 && findMatches.length > 0) {
      const matchAfterSelection = findFirstInSorted(findMatches.map((match2) => match2.range), (range) => Range$1.compareRangesUsingStarts(range, editorSelection) >= 0);
      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
    }
    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
    if (moveCursor && this._editor.getOption(
      40
      /* EditorOption.find */
    ).cursorMoveOnType) {
      this._moveToNextMatch(this._decorations.getStartPosition());
    }
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      const findScope = this._decorations.getFindScope();
      if (findScope) {
        this._editor.revealRangeInCenterIfOutsideViewport(
          findScope,
          0
          /* ScrollType.Smooth */
        );
      }
      return true;
    }
    return false;
  }
  _setCurrentFindMatch(match2) {
    const matchesPosition = this._decorations.setCurrentFindMatch(match2);
    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match2);
    this._editor.setSelection(match2);
    this._editor.revealRangeInCenterIfOutsideViewport(
      match2,
      0
      /* ScrollType.Smooth */
    );
  }
  _prevSearchPosition(before) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = before;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === 1) {
      if (lineNumber === 1) {
        lineNumber = model.getLineCount();
      } else {
        lineNumber--;
      }
      column = model.getLineMaxColumn(lineNumber);
    } else {
      column--;
    }
    return new Position$1(lineNumber, column);
  }
  _moveToPrevMatch(before, isRecursed = false) {
    if (!this._state.canNavigateBack()) {
      const nextMatchRange = this._decorations.matchAfterPosition(before);
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let prevMatchRange = this._decorations.matchBeforePosition(before);
      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
        before = this._prevSearchPosition(before);
        prevMatchRange = this._decorations.matchBeforePosition(before);
      }
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._cannotFind()) {
      return;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(before)) {
      before = searchRange.getEndPosition();
    }
    if (before.isBefore(searchRange.getStartPosition())) {
      before = searchRange.getEndPosition();
    }
    const { lineNumber, column } = before;
    const model = this._editor.getModel();
    let position = new Position$1(lineNumber, column);
    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
      position = this._prevSearchPosition(position);
      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ) : null, false);
    }
    if (!prevMatch) {
      return;
    }
    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
    }
    this._setCurrentFindMatch(prevMatch.range);
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(after) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = after;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
      if (lineNumber === model.getLineCount()) {
        lineNumber = 1;
      } else {
        lineNumber++;
      }
      column = 1;
    } else {
      column++;
    }
    return new Position$1(lineNumber, column);
  }
  _moveToNextMatch(after) {
    if (!this._state.canNavigateForward()) {
      const prevMatchRange = this._decorations.matchBeforePosition(after);
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let nextMatchRange = this._decorations.matchAfterPosition(after);
      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
        after = this._nextSearchPosition(after);
        nextMatchRange = this._decorations.matchAfterPosition(after);
      }
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    const nextMatch = this._getNextMatch(after, false, true);
    if (nextMatch) {
      this._setCurrentFindMatch(nextMatch.range);
    }
  }
  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
    if (this._cannotFind()) {
      return null;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(after)) {
      after = searchRange.getStartPosition();
    }
    if (after.isBefore(searchRange.getStartPosition())) {
      after = searchRange.getStartPosition();
    }
    const { lineNumber, column } = after;
    const model = this._editor.getModel();
    let position = new Position$1(lineNumber, column);
    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, captureMatches);
    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
      position = this._nextSearchPosition(position);
      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ) : null, captureMatches);
    }
    if (!nextMatch) {
      return null;
    }
    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
    }
    return nextMatch;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _moveToMatch(index2) {
    const decorationRange = this._decorations.getDecorationRangeAt(index2);
    if (decorationRange) {
      this._setCurrentFindMatch(decorationRange);
    }
  }
  moveToMatch(index2) {
    this._moveToMatch(index2);
  }
  _getReplacePattern() {
    if (this._state.isRegex) {
      return parseReplaceString(this._state.replaceString);
    }
    return ReplacePattern.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches()) {
      return;
    }
    const replacePattern = this._getReplacePattern();
    const selection = this._editor.getSelection();
    const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
    if (nextMatch) {
      if (selection.equalsRange(nextMatch.range)) {
        const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
        const command = new ReplaceCommand(selection, replaceString);
        this._executeEditorCommand("replace", command);
        this._decorations.setStartPosition(new Position$1(selection.startLineNumber, selection.startColumn + replaceString.length));
        this.research(true);
      } else {
        this._decorations.setStartPosition(this._editor.getPosition());
        this._setCurrentFindMatch(nextMatch.range);
      }
    }
  }
  _findMatches(findScopes, captureMatches, limitResultCount) {
    const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, captureMatches, limitResultCount);
  }
  replaceAll() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {
      this._largeReplaceAll();
    } else {
      this._regularReplaceAll(findScopes);
    }
    this.research(false);
  }
  _largeReplaceAll() {
    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return;
    }
    let searchRegex = searchData.regex;
    if (!searchRegex.multiline) {
      let mod = "mu";
      if (searchRegex.ignoreCase) {
        mod += "i";
      }
      if (searchRegex.global) {
        mod += "g";
      }
      searchRegex = new RegExp(searchRegex.source, mod);
    }
    const model = this._editor.getModel();
    const modelText = model.getValue(
      1
      /* EndOfLinePreference.LF */
    );
    const fullModelRange = model.getFullModelRange();
    const replacePattern = this._getReplacePattern();
    let resultText;
    const preserveCase = this._state.preserveCase;
    if (replacePattern.hasReplacementPatterns || preserveCase) {
      resultText = modelText.replace(searchRegex, function() {
        return replacePattern.buildReplaceString(arguments, preserveCase);
      });
    } else {
      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
    }
    const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", command);
  }
  _regularReplaceAll(findScopes) {
    const replacePattern = this._getReplacePattern();
    const matches = this._findMatches(
      findScopes,
      replacePattern.hasReplacementPatterns || this._state.preserveCase,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    const replaceStrings = [];
    for (let i = 0, len = matches.length; i < len; i++) {
      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);
    }
    const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
    this._executeEditorCommand("replaceAll", command);
  }
  selectAllMatches() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    const matches = this._findMatches(
      findScopes,
      false,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    let selections = matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
    const editorSelection = this._editor.getSelection();
    for (let i = 0, len = selections.length; i < len; i++) {
      const sel = selections[i];
      if (sel.equalsRange(editorSelection)) {
        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
        break;
      }
    }
    this._editor.setSelections(selections);
  }
  _executeEditorCommand(source, command) {
    try {
      this._ignoreModelContentChanged = true;
      this._editor.pushUndoStop();
      this._editor.executeCommand(source, command);
      this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = false;
    }
  }
}
const findOptionsWidget = "";
class FindOptionsWidget extends Widget {
  constructor(editor2, state, keybindingService) {
    super();
    this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
    this._isVisible = false;
    this._editor = editor2;
    this._state = state;
    this._keybindingService = keybindingService;
    this._domNode = document.createElement("div");
    this._domNode.className = "findOptionsWidget";
    this._domNode.style.display = "none";
    this._domNode.style.top = "10px";
    this._domNode.style.zIndex = "12";
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    const toggleStyles = {
      inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
      inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
    };
    this.caseSensitive = this._register(new CaseSensitiveToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand), isChecked: this._state.matchCase }, toggleStyles)));
    this._domNode.appendChild(this.caseSensitive.domNode);
    this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, false);
    }));
    this.wholeWords = this._register(new WholeWordsToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand), isChecked: this._state.wholeWord }, toggleStyles)));
    this._domNode.appendChild(this.wholeWords.domNode);
    this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, false);
    }));
    this.regex = this._register(new RegexToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand), isChecked: this._state.isRegex }, toggleStyles)));
    this._domNode.appendChild(this.regex.domNode);
    this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, false);
    }));
    this._editor.addOverlayWidget(this);
    this._register(this._state.onFindReplaceStateChange((e) => {
      let somethingChanged = false;
      if (e.isRegex) {
        this.regex.checked = this._state.isRegex;
        somethingChanged = true;
      }
      if (e.wholeWord) {
        this.wholeWords.checked = this._state.wholeWord;
        somethingChanged = true;
      }
      if (e.matchCase) {
        this.caseSensitive.checked = this._state.matchCase;
        somethingChanged = true;
      }
      if (!this._state.isRevealed && somethingChanged) {
        this._revealTemporarily();
      }
    }));
    this._register(addDisposableListener(this._domNode, EventType.MOUSE_LEAVE, (e) => this._onMouseLeave()));
    this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
  }
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return FindOptionsWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show();
    this._hideSoon.schedule();
  }
  _onMouseLeave() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._domNode.style.display = "block";
  }
  _hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._domNode.style.display = "none";
  }
}
FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";
function effectiveOptionValue(override, value) {
  if (override === 1) {
    return true;
  }
  if (override === 2) {
    return false;
  }
  return value;
}
class FindReplaceState extends Disposable {
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return effectiveOptionValue(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  get isSearching() {
    return this._isSearching;
  }
  get filters() {
    return this._filters;
  }
  constructor() {
    super();
    this._onFindReplaceStateChange = this._register(new Emitter());
    this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
    this._searchString = "";
    this._replaceString = "";
    this._isRevealed = false;
    this._isReplaceRevealed = false;
    this._isRegex = false;
    this._isRegexOverride = 0;
    this._wholeWord = false;
    this._wholeWordOverride = 0;
    this._matchCase = false;
    this._matchCaseOverride = 0;
    this._preserveCase = false;
    this._preserveCaseOverride = 0;
    this._searchScope = null;
    this._matchesPosition = 0;
    this._matchesCount = 0;
    this._currentMatch = null;
    this._loop = true;
    this._isSearching = false;
    this._filters = null;
  }
  changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
    const changeEvent = {
      moveCursor: false,
      updateHistory: false,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    if (matchesCount === 0) {
      matchesPosition = 0;
    }
    if (matchesPosition > matchesCount) {
      matchesPosition = matchesCount;
    }
    if (this._matchesPosition !== matchesPosition) {
      this._matchesPosition = matchesPosition;
      changeEvent.matchesPosition = true;
      somethingChanged = true;
    }
    if (this._matchesCount !== matchesCount) {
      this._matchesCount = matchesCount;
      changeEvent.matchesCount = true;
      somethingChanged = true;
    }
    if (typeof currentMatch !== "undefined") {
      if (!Range$1.equalsRange(this._currentMatch, currentMatch)) {
        this._currentMatch = currentMatch;
        changeEvent.currentMatch = true;
        somethingChanged = true;
      }
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  change(newState, moveCursor, updateHistory = true) {
    var _a3;
    const changeEvent = {
      moveCursor,
      updateHistory,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    const oldEffectiveIsRegex = this.isRegex;
    const oldEffectiveWholeWords = this.wholeWord;
    const oldEffectiveMatchCase = this.matchCase;
    const oldEffectivePreserveCase = this.preserveCase;
    if (typeof newState.searchString !== "undefined") {
      if (this._searchString !== newState.searchString) {
        this._searchString = newState.searchString;
        changeEvent.searchString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.replaceString !== "undefined") {
      if (this._replaceString !== newState.replaceString) {
        this._replaceString = newState.replaceString;
        changeEvent.replaceString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRevealed !== "undefined") {
      if (this._isRevealed !== newState.isRevealed) {
        this._isRevealed = newState.isRevealed;
        changeEvent.isRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isReplaceRevealed !== "undefined") {
      if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
        this._isReplaceRevealed = newState.isReplaceRevealed;
        changeEvent.isReplaceRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRegex !== "undefined") {
      this._isRegex = newState.isRegex;
    }
    if (typeof newState.wholeWord !== "undefined") {
      this._wholeWord = newState.wholeWord;
    }
    if (typeof newState.matchCase !== "undefined") {
      this._matchCase = newState.matchCase;
    }
    if (typeof newState.preserveCase !== "undefined") {
      this._preserveCase = newState.preserveCase;
    }
    if (typeof newState.searchScope !== "undefined") {
      if (!((_a3 = newState.searchScope) === null || _a3 === void 0 ? void 0 : _a3.every((newSearchScope) => {
        var _a4;
        return (_a4 = this._searchScope) === null || _a4 === void 0 ? void 0 : _a4.some((existingSearchScope) => {
          return !Range$1.equalsRange(existingSearchScope, newSearchScope);
        });
      }))) {
        this._searchScope = newState.searchScope;
        changeEvent.searchScope = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.loop !== "undefined") {
      if (this._loop !== newState.loop) {
        this._loop = newState.loop;
        changeEvent.loop = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isSearching !== "undefined") {
      if (this._isSearching !== newState.isSearching) {
        this._isSearching = newState.isSearching;
        changeEvent.isSearching = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.filters !== "undefined") {
      if (this._filters) {
        this._filters.update(newState.filters);
      } else {
        this._filters = newState.filters;
      }
      changeEvent.filters = true;
      somethingChanged = true;
    }
    this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
    this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
    this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
    this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
    if (oldEffectiveIsRegex !== this.isRegex) {
      somethingChanged = true;
      changeEvent.isRegex = true;
    }
    if (oldEffectiveWholeWords !== this.wholeWord) {
      somethingChanged = true;
      changeEvent.wholeWord = true;
    }
    if (oldEffectiveMatchCase !== this.matchCase) {
      somethingChanged = true;
      changeEvent.matchCase = true;
    }
    if (oldEffectivePreserveCase !== this.preserveCase) {
      somethingChanged = true;
      changeEvent.preserveCase = true;
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= MATCHES_LIMIT;
  }
}
const findWidget = "";
var __awaiter$r = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const findSelectionIcon = registerIcon("find-selection", Codicon.selection, localize("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget."));
const findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight, localize("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed."));
const findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown, localize("findExpandedIcon", "Icon to indicate that the editor find widget is expanded."));
const findReplaceIcon = registerIcon("find-replace", Codicon.replace, localize("findReplaceIcon", "Icon for 'Replace' in the editor find widget."));
const findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll, localize("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget."));
const findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp, localize("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget."));
const findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown, localize("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget."));
const NLS_FIND_DIALOG_LABEL = localize("label.findDialog", "Find / Replace");
const NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
const NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find");
const NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous Match");
const NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next Match");
const NLS_TOGGLE_SELECTION_FIND_TITLE = localize("label.toggleSelectionFind", "Find in Selection");
const NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
const NLS_REPLACE_INPUT_LABEL = localize("label.replace", "Replace");
const NLS_REPLACE_INPUT_PLACEHOLDER = localize("placeholder.replace", "Replace");
const NLS_REPLACE_BTN_LABEL = localize("label.replaceButton", "Replace");
const NLS_REPLACE_ALL_BTN_LABEL = localize("label.replaceAllButton", "Replace All");
const NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize("label.toggleReplaceButton", "Toggle Replace");
const NLS_MATCHES_COUNT_LIMIT_TITLE = localize("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
const NLS_MATCHES_LOCATION = localize("label.matchesLocation", "{0} of {1}");
const NLS_NO_RESULTS = localize("label.noResults", "No results");
const FIND_WIDGET_INITIAL_WIDTH = 419;
const PART_WIDTH = 275;
const FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
let MAX_MATCHES_COUNT_WIDTH = 69;
const FIND_INPUT_AREA_HEIGHT = 33;
const ctrlEnterReplaceAllWarningPromptedKey = "ctrlEnterReplaceAll.windows.donotask";
const ctrlKeyMod = isMacintosh ? 256 : 2048;
class FindWidgetViewZone {
  constructor(afterLineNumber) {
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = FIND_INPUT_AREA_HEIGHT;
    this.suppressMouseDown = false;
    this.domNode = document.createElement("div");
    this.domNode.className = "dock-find-viewzone";
  }
}
function stopPropagationForMultiLineUpwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionStart > 0) {
    event.stopPropagation();
    return;
  }
}
function stopPropagationForMultiLineDownwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
    event.stopPropagation();
    return;
  }
}
class FindWidget extends Widget {
  constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService) {
    super();
    this._cachedHeight = null;
    this._revealTimeouts = [];
    this._codeEditor = codeEditor;
    this._controller = controller;
    this._state = state;
    this._contextViewProvider = contextViewProvider;
    this._keybindingService = keybindingService;
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._notificationService = notificationService;
    this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(
      ctrlEnterReplaceAllWarningPromptedKey,
      0
      /* StorageScope.PROFILE */
    );
    this._isVisible = false;
    this._isReplaceVisible = false;
    this._ignoreChangeEvent = false;
    this._updateHistoryDelayer = new Delayer(500);
    this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._buildDomNode();
    this._updateButtons();
    this._tryUpdateWidgetWidth();
    this._findInput.inputBox.layout();
    this._register(this._codeEditor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        89
        /* EditorOption.readOnly */
      )) {
        if (this._codeEditor.getOption(
          89
          /* EditorOption.readOnly */
        )) {
          this._state.change({ isReplaceRevealed: false }, false);
        }
        this._updateButtons();
      }
      if (e.hasChanged(
        142
        /* EditorOption.layoutInfo */
      )) {
        this._tryUpdateWidgetWidth();
      }
      if (e.hasChanged(
        2
        /* EditorOption.accessibilitySupport */
      )) {
        this.updateAccessibilitySupport();
      }
      if (e.hasChanged(
        40
        /* EditorOption.find */
      )) {
        const supportLoop = this._codeEditor.getOption(
          40
          /* EditorOption.find */
        ).loop;
        this._state.change({ loop: supportLoop }, false);
        const addExtraSpaceOnTop = this._codeEditor.getOption(
          40
          /* EditorOption.find */
        ).addExtraSpaceOnTop;
        if (addExtraSpaceOnTop && !this._viewZone) {
          this._viewZone = new FindWidgetViewZone(0);
          this._showViewZone();
        }
        if (!addExtraSpaceOnTop && this._viewZone) {
          this._removeViewZone();
        }
      }
    }));
    this.updateAccessibilitySupport();
    this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      if (this._isVisible) {
        this._updateToggleSelectionFindButton();
      }
    }));
    this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter$r(this, void 0, void 0, function* () {
      if (this._isVisible) {
        const globalBufferTerm = yield this._controller.getGlobalBufferTerm();
        if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
          this._state.change({ searchString: globalBufferTerm }, false);
          this._findInput.select();
        }
      }
    })));
    this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
    this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
    this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(false);
    }));
    this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
    this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
    this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(false);
    }));
    this._codeEditor.addOverlayWidget(this);
    if (this._codeEditor.getOption(
      40
      /* EditorOption.find */
    ).addExtraSpaceOnTop) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    this._register(this._codeEditor.onDidChangeModel(() => {
      if (!this._isVisible) {
        return;
      }
      this._viewZoneId = void 0;
    }));
    this._register(this._codeEditor.onDidScrollChange((e) => {
      if (e.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  // ----- IOverlayWidget API
  getId() {
    return FindWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    if (this._isVisible) {
      return {
        preference: 0
        /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
      };
    }
    return null;
  }
  // ----- React to state changes
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = true;
        this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = false;
      }
      this._updateButtons();
    }
    if (e.replaceString) {
      this._replaceInput.inputBox.value = this._state.replaceString;
    }
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._reveal();
      } else {
        this._hide(true);
      }
    }
    if (e.isReplaceRevealed) {
      if (this._state.isReplaceRevealed) {
        if (!this._codeEditor.getOption(
          89
          /* EditorOption.readOnly */
        ) && !this._isReplaceVisible) {
          this._isReplaceVisible = true;
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._updateButtons();
          this._replaceInput.inputBox.layout();
        }
      } else {
        if (this._isReplaceVisible) {
          this._isReplaceVisible = false;
          this._updateButtons();
        }
      }
    }
    if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }
    if (e.isRegex) {
      this._findInput.setRegex(this._state.isRegex);
    }
    if (e.wholeWord) {
      this._findInput.setWholeWords(this._state.wholeWord);
    }
    if (e.matchCase) {
      this._findInput.setCaseSensitive(this._state.matchCase);
    }
    if (e.preserveCase) {
      this._replaceInput.setPreserveCase(this._state.preserveCase);
    }
    if (e.searchScope) {
      if (this._state.searchScope) {
        this._toggleSelectionFind.checked = true;
      } else {
        this._toggleSelectionFind.checked = false;
      }
      this._updateToggleSelectionFindButton();
    }
    if (e.searchString || e.matchesCount || e.matchesPosition) {
      const showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", showRedOutline);
      this._updateMatchesCount();
      this._updateButtons();
    }
    if (e.searchString || e.currentMatch) {
      this._layoutViewZone();
    }
    if (e.updateHistory) {
      this._delayedUpdateHistory();
    }
    if (e.loop) {
      this._updateButtons();
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, onUnexpectedError);
  }
  _updateHistory() {
    if (this._state.searchString) {
      this._findInput.inputBox.addToHistory();
    }
    if (this._state.replaceString) {
      this._replaceInput.inputBox.addToHistory();
    }
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
    if (this._state.matchesCount >= MATCHES_LIMIT) {
      this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
    } else {
      this._matchesCount.title = "";
    }
    if (this._matchesCount.firstChild) {
      this._matchesCount.removeChild(this._matchesCount.firstChild);
    }
    let label;
    if (this._state.matchesCount > 0) {
      let matchesCount = String(this._state.matchesCount);
      if (this._state.matchesCount >= MATCHES_LIMIT) {
        matchesCount += "+";
      }
      let matchesPosition = String(this._state.matchesPosition);
      if (matchesPosition === "0") {
        matchesPosition = "?";
      }
      label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
    } else {
      label = NLS_NO_RESULTS;
    }
    this._matchesCount.appendChild(document.createTextNode(label));
    alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
    MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
  }
  // ----- actions
  _getAriaLabel(label, currentMatch, searchString) {
    if (label === NLS_NO_RESULTS) {
      return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
    }
    if (currentMatch) {
      const ariaLabel = localize("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
      const model = this._codeEditor.getModel();
      if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) {
        const lineContent = model.getLineContent(currentMatch.startLineNumber);
        return `${lineContent}, ${ariaLabel}`;
      }
      return ariaLabel;
    }
    return localize("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", label, searchString);
  }
  /**
   * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
   * If 'selection find' is OFF we enable the button only if there is a selection.
   */
  _updateToggleSelectionFindButton() {
    const selection = this._codeEditor.getSelection();
    const isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
    const isChecked = this._toggleSelectionFind.checked;
    if (this._isVisible && (isChecked || isSelection)) {
      this._toggleSelectionFind.enable();
    } else {
      this._toggleSelectionFind.disable();
    }
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible);
    this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
    this._updateToggleSelectionFindButton();
    this._closeBtn.setEnabled(this._isVisible);
    const findInputIsNonEmpty = this._state.searchString.length > 0;
    const matchesCount = this._state.matchesCount ? true : false;
    this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
    this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
    this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible);
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    const canReplace = !this._codeEditor.getOption(
      89
      /* EditorOption.readOnly */
    );
    this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
  }
  _reveal() {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (!this._isVisible) {
      this._isVisible = true;
      const selection = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(
        40
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = true;
          break;
        case "never":
          this._toggleSelectionFind.checked = false;
          break;
        case "multiline": {
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          this._toggleSelectionFind.checked = isSelectionMultipleLine;
          break;
        }
      }
      this._tryUpdateWidgetWidth();
      this._updateButtons();
      this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible");
        this._domNode.setAttribute("aria-hidden", "false");
      }, 0));
      this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200));
      this._codeEditor.layoutOverlayWidget(this);
      let adjustEditorScrollTop = true;
      if (this._codeEditor.getOption(
        40
        /* EditorOption.find */
      ).seedSearchStringFromSelection && selection) {
        const domNode = this._codeEditor.getDomNode();
        if (domNode) {
          const editorCoords = getDomNodePagePosition(domNode);
          const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
          const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
          const startTop = startCoords ? startCoords.top : 0;
          if (this._viewZone && startTop < this._viewZone.heightInPx) {
            if (selection.endLineNumber > selection.startLineNumber) {
              adjustEditorScrollTop = false;
            }
            const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
            if (startLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
            const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
            const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);
            if (endLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
          }
        }
      }
      this._showViewZone(adjustEditorScrollTop);
    }
  }
  _hide(focusTheEditor) {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (this._isVisible) {
      this._isVisible = false;
      this._updateButtons();
      this._domNode.classList.remove("visible");
      this._domNode.setAttribute("aria-hidden", "true");
      this._findInput.clearMessage();
      if (focusTheEditor) {
        this._codeEditor.focus();
      }
      this._codeEditor.layoutOverlayWidget(this);
      this._removeViewZone();
    }
  }
  _layoutViewZone(targetScrollTop) {
    const addExtraSpaceOnTop = this._codeEditor.getOption(
      40
      /* EditorOption.find */
    ).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible) {
      return;
    }
    const viewZone = this._viewZone;
    if (this._viewZoneId !== void 0 || !viewZone) {
      return;
    }
    this._codeEditor.changeViewZones((accessor) => {
      viewZone.heightInPx = this._getHeight();
      this._viewZoneId = accessor.addZone(viewZone);
      this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);
    });
  }
  _showViewZone(adjustScroll = true) {
    if (!this._isVisible) {
      return;
    }
    const addExtraSpaceOnTop = this._codeEditor.getOption(
      40
      /* EditorOption.find */
    ).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      return;
    }
    if (this._viewZone === void 0) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    const viewZone = this._viewZone;
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        const newHeight = this._getHeight();
        if (newHeight === viewZone.heightInPx) {
          return;
        }
        const scrollAdjustment = newHeight - viewZone.heightInPx;
        viewZone.heightInPx = newHeight;
        accessor.layoutZone(this._viewZoneId);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
        return;
      } else {
        let scrollAdjustment = this._getHeight();
        scrollAdjustment -= this._codeEditor.getOption(
          82
          /* EditorOption.padding */
        ).top;
        if (scrollAdjustment <= 0) {
          return;
        }
        viewZone.heightInPx = scrollAdjustment;
        this._viewZoneId = accessor.addZone(viewZone);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        accessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
        if (this._viewZone) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
          this._viewZone = void 0;
        }
      }
    });
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible) {
      return;
    }
    if (!isInDOM(this._domNode)) {
      return;
    }
    const layoutInfo = this._codeEditor.getLayoutInfo();
    const editorContentWidth = layoutInfo.contentWidth;
    if (editorContentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else if (this._domNode.classList.contains("hiddenEditor")) {
      this._domNode.classList.remove("hiddenEditor");
    }
    const editorWidth = layoutInfo.width;
    const minimapWidth = layoutInfo.minimap.minimapWidth;
    let collapsedFindWidget = false;
    let reducedFindWidget = false;
    let narrowFindWidget = false;
    if (this._resized) {
      const widgetWidth = getTotalWidth(this._domNode);
      if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
        this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
        return;
      }
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
      reducedFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
      narrowFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
      collapsedFindWidget = true;
    }
    this._domNode.classList.toggle("collapsed-find-widget", collapsedFindWidget);
    this._domNode.classList.toggle("narrow-find-widget", narrowFindWidget);
    this._domNode.classList.toggle("reduced-find-widget", reducedFindWidget);
    if (!narrowFindWidget && !collapsedFindWidget) {
      this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
    }
    this._findInput.layout({ collapsedFindWidget, narrowFindWidget, reducedFindWidget });
    if (this._resized) {
      const findInputWidth = this._findInput.inputBox.element.clientWidth;
      if (findInputWidth > 0) {
        this._replaceInput.width = findInputWidth;
      }
    } else if (this._isReplaceVisible) {
      this._replaceInput.width = getTotalWidth(this._findInput.domNode);
    }
  }
  _getHeight() {
    let totalheight = 0;
    totalheight += 4;
    totalheight += this._findInput.inputBox.height + 2;
    if (this._isReplaceVisible) {
      totalheight += 4;
      totalheight += this._replaceInput.inputBox.height + 2;
    }
    totalheight += 4;
    return totalheight;
  }
  _tryUpdateHeight() {
    const totalHeight = this._getHeight();
    if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {
      return false;
    }
    this._cachedHeight = totalHeight;
    this._domNode.style.height = `${totalHeight}px`;
    return true;
  }
  // ----- Public
  focusFindInput() {
    this._findInput.select();
    this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select();
    this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (!this._codeEditor.hasModel()) {
      return;
    }
    if (this._toggleSelectionFind.checked) {
      const selections = this._codeEditor.getSelections();
      selections.map((selection) => {
        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
          selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
        }
        const currentMatch = this._state.currentMatch;
        if (selection.startLineNumber !== selection.endLineNumber) {
          if (!Range$1.equalsRange(selection, currentMatch)) {
            return selection;
          }
        }
        return null;
      }).filter((element) => !!element);
      if (selections.length) {
        this._state.change({ searchScope: selections }, true);
      }
    }
  }
  _onFindInputMouseDown(e) {
    if (e.middleButton) {
      e.stopPropagation();
    }
  }
  _onFindInputKeyDown(e) {
    if (e.equals(
      ctrlKeyMod | 3
      /* KeyCode.Enter */
    )) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      if (this._isReplaceVisible) {
        this._replaceInput.focus();
      } else {
        this._findInput.focusOnCaseSensitive();
      }
      e.preventDefault();
      return;
    }
    if (e.equals(
      2048 | 18
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    )) {
      return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    )) {
      return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(
      ctrlKeyMod | 3
      /* KeyCode.Enter */
    )) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        if (isWindows && isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
          this._notificationService.info(localize("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior."));
          this._ctrlEnterReplaceAllWarningPrompted = true;
          this._storageService.store(
            ctrlEnterReplaceAllWarningPromptedKey,
            true,
            0,
            0
            /* StorageTarget.USER */
          );
        }
        this._replaceInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._findInput.focusOnCaseSensitive();
      e.preventDefault();
      return;
    }
    if (e.equals(
      1024 | 2
      /* KeyCode.Tab */
    )) {
      this._findInput.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      2048 | 18
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    )) {
      return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    )) {
      return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
  }
  // ----- sash
  getVerticalSashLeft(_sash) {
    return 0;
  }
  // ----- initialization
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  _buildDomNode() {
    const flexibleHeight = true;
    const flexibleWidth = true;
    this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
      width: FIND_INPUT_AREA_WIDTH,
      label: NLS_FIND_INPUT_LABEL,
      placeholder: NLS_FIND_INPUT_PLACEHOLDER,
      appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      validation: (value) => {
        if (value.length === 0 || !this._findInput.getRegex()) {
          return null;
        }
        try {
          new RegExp(value, "gu");
          return null;
        } catch (e) {
          return { content: e.message };
        }
      },
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showCommonFindToggles: true,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, this._contextKeyService));
    this._findInput.setRegex(!!this._state.isRegex);
    this._findInput.setCaseSensitive(!!this._state.matchCase);
    this._findInput.setWholeWords(!!this._state.wholeWord);
    this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));
    this._register(this._findInput.inputBox.onDidChange(() => {
      if (this._ignoreChangeEvent) {
        return;
      }
      this._state.change({ searchString: this._findInput.getValue() }, true);
    }));
    this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, true);
    }));
    this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
      if (e.equals(
        1024 | 2
        /* KeyCode.Tab */
      )) {
        if (this._isReplaceVisible) {
          this._replaceInput.focus();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.onRegexKeyDown((e) => {
      if (e.equals(
        2
        /* KeyCode.Tab */
      )) {
        if (this._isReplaceVisible) {
          this._replaceInput.focusOnPreserve();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.inputBox.onDidHeightChange((e) => {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    if (isLinux) {
      this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
    }
    this._matchesCount = document.createElement("div");
    this._matchesCount.className = "matchesCount";
    this._updateMatchesCount();
    this._prevBtn = this._register(new SimpleButton({
      label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
      icon: findPreviousMatchIcon,
      onTrigger: () => {
        assertIsDefined(this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }));
    this._nextBtn = this._register(new SimpleButton({
      label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
      icon: findNextMatchIcon,
      onTrigger: () => {
        assertIsDefined(this._codeEditor.getAction(FIND_IDS.NextMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }));
    const findPart = document.createElement("div");
    findPart.className = "find-part";
    findPart.appendChild(this._findInput.domNode);
    const actionsContainer = document.createElement("div");
    actionsContainer.className = "find-actions";
    findPart.appendChild(actionsContainer);
    actionsContainer.appendChild(this._matchesCount);
    actionsContainer.appendChild(this._prevBtn.domNode);
    actionsContainer.appendChild(this._nextBtn.domNode);
    this._toggleSelectionFind = this._register(new Toggle({
      icon: findSelectionIcon,
      title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
      isChecked: false,
      inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground),
      inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground)
    }));
    this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          const selections = this._codeEditor.getSelections();
          selections.map((selection) => {
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
              selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
            }
            if (!selection.isEmpty()) {
              return selection;
            }
            return null;
          }).filter((element) => !!element);
          if (selections.length) {
            this._state.change({ searchScope: selections }, true);
          }
        }
      } else {
        this._state.change({ searchScope: null }, true);
      }
    }));
    actionsContainer.appendChild(this._toggleSelectionFind.domNode);
    this._closeBtn = this._register(new SimpleButton({
      label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
      icon: widgetClose,
      onTrigger: () => {
        this._state.change({ isRevealed: false, searchScope: null }, false);
      },
      onKeyDown: (e) => {
        if (e.equals(
          2
          /* KeyCode.Tab */
        )) {
          if (this._isReplaceVisible) {
            if (this._replaceBtn.isEnabled()) {
              this._replaceBtn.focus();
            } else {
              this._codeEditor.focus();
            }
            e.preventDefault();
          }
        }
      }
    }));
    this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
      label: NLS_REPLACE_INPUT_LABEL,
      placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
      appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),
      history: [],
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, this._contextKeyService, true));
    this._replaceInput.setPreserveCase(!!this._state.preserveCase);
    this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
    this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);
    }));
    this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
      if (this._isReplaceVisible && this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, true);
    }));
    this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
      if (e.equals(
        2
        /* KeyCode.Tab */
      )) {
        if (this._prevBtn.isEnabled()) {
          this._prevBtn.focus();
        } else if (this._nextBtn.isEnabled()) {
          this._nextBtn.focus();
        } else if (this._toggleSelectionFind.enabled) {
          this._toggleSelectionFind.focus();
        } else if (this._closeBtn.isEnabled()) {
          this._closeBtn.focus();
        }
        e.preventDefault();
      }
    }));
    this._replaceBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
      icon: findReplaceIcon,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (e) => {
        if (e.equals(
          1024 | 2
          /* KeyCode.Tab */
        )) {
          this._closeBtn.focus();
          e.preventDefault();
        }
      }
    }));
    this._replaceAllBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
      icon: findReplaceAllIcon,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }));
    const replacePart = document.createElement("div");
    replacePart.className = "replace-part";
    replacePart.appendChild(this._replaceInput.domNode);
    const replaceActionsContainer = document.createElement("div");
    replaceActionsContainer.className = "replace-actions";
    replacePart.appendChild(replaceActionsContainer);
    replaceActionsContainer.appendChild(this._replaceBtn.domNode);
    replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
    this._toggleReplaceBtn = this._register(new SimpleButton({
      label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);
        if (this._isReplaceVisible) {
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._replaceInput.inputBox.layout();
        }
        this._showViewZone();
      }
    }));
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    this._domNode = document.createElement("div");
    this._domNode.className = "editor-widget find-widget";
    this._domNode.setAttribute("aria-hidden", "true");
    this._domNode.ariaLabel = NLS_FIND_DIALOG_LABEL;
    this._domNode.role = "dialog";
    this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
    this._domNode.appendChild(this._toggleReplaceBtn.domNode);
    this._domNode.appendChild(findPart);
    this._domNode.appendChild(this._closeBtn.domNode);
    this._domNode.appendChild(replacePart);
    this._resizeSash = new Sash(this._domNode, this, { orientation: 0, size: 2 });
    this._resized = false;
    let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
    this._register(this._resizeSash.onDidStart(() => {
      originalWidth = getTotalWidth(this._domNode);
    }));
    this._register(this._resizeSash.onDidChange((evt) => {
      this._resized = true;
      const width = originalWidth + evt.startX - evt.currentX;
      if (width < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      const maxWidth = parseFloat(getComputedStyle(this._domNode).maxWidth) || 0;
      if (width > maxWidth) {
        return;
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
      this._tryUpdateHeight();
    }));
    this._register(this._resizeSash.onDidReset(() => {
      const currentWidth = getTotalWidth(this._domNode);
      if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      let width = FIND_WIDGET_INITIAL_WIDTH;
      if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
        const layoutInfo = this._codeEditor.getLayoutInfo();
        width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
        this._resized = true;
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const value = this._codeEditor.getOption(
      2
      /* EditorOption.accessibilitySupport */
    );
    this._findInput.setFocusInputOnOptionClick(
      value !== 2
      /* AccessibilitySupport.Enabled */
    );
  }
  getViewState() {
    let widgetViewZoneVisible = false;
    if (this._viewZone && this._viewZoneId) {
      widgetViewZoneVisible = this._viewZone.heightInPx > this._codeEditor.getScrollTop();
    }
    return {
      widgetViewZoneVisible,
      scrollTop: this._codeEditor.getScrollTop()
    };
  }
  setViewState(state) {
    if (!state) {
      return;
    }
    if (state.widgetViewZoneVisible) {
      this._layoutViewZone(state.scrollTop);
    }
  }
}
FindWidget.ID = "editor.contrib.findWidget";
class SimpleButton extends Widget {
  constructor(opts) {
    super();
    this._opts = opts;
    let className = "button";
    if (this._opts.className) {
      className = className + " " + this._opts.className;
    }
    if (this._opts.icon) {
      className = className + " " + ThemeIcon.asClassName(this._opts.icon);
    }
    this._domNode = document.createElement("div");
    this._domNode.title = this._opts.label;
    this._domNode.tabIndex = 0;
    this._domNode.className = className;
    this._domNode.setAttribute("role", "button");
    this._domNode.setAttribute("aria-label", this._opts.label);
    this.onclick(this._domNode, (e) => {
      this._opts.onTrigger();
      e.preventDefault();
    });
    this.onkeydown(this._domNode, (e) => {
      var _a3, _b3;
      if (e.equals(
        10
        /* KeyCode.Space */
      ) || e.equals(
        3
        /* KeyCode.Enter */
      )) {
        this._opts.onTrigger();
        e.preventDefault();
        return;
      }
      (_b3 = (_a3 = this._opts).onKeyDown) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, e);
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(enabled) {
    this._domNode.classList.toggle("disabled", !enabled);
    this._domNode.setAttribute("aria-disabled", String(!enabled));
    this._domNode.tabIndex = enabled ? 0 : -1;
  }
  setExpanded(expanded) {
    this._domNode.setAttribute("aria-expanded", String(!!expanded));
    if (expanded) {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));
    } else {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));
    }
  }
}
registerThemingParticipant((theme, collector) => {
  const addBackgroundColorRule = (selector, color) => {
    if (color) {
      collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
    }
  };
  addBackgroundColorRule(".findMatch", theme.getColor(editorFindMatchHighlight));
  addBackgroundColorRule(".currentFindMatch", theme.getColor(editorFindMatch));
  addBackgroundColorRule(".findScope", theme.getColor(editorFindRangeHighlight));
  const widgetBackground = theme.getColor(editorWidgetBackground);
  addBackgroundColorRule(".find-widget", widgetBackground);
  const widgetShadowColor = theme.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
  }
  const widgetBorderColor = theme.getColor(widgetBorder);
  if (widgetBorderColor) {
    collector.addRule(`.monaco-editor .find-widget { border-left: 1px solid ${widgetBorderColor}; border-right: 1px solid ${widgetBorderColor}; border-bottom: 1px solid ${widgetBorderColor}; }`);
  }
  const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .findMatch { border: 1px ${isHighContrast(theme.type) ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
  const findMatchBorder = theme.getColor(editorFindMatchBorder);
  if (findMatchBorder) {
    collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);
  }
  const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
  if (findRangeHighlightBorder) {
    collector.addRule(`.monaco-editor .findScope { border: 1px ${isHighContrast(theme.type) ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
  }
  const hcBorder = theme.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
  }
  const foreground = theme.getColor(editorWidgetForeground);
  if (foreground) {
    collector.addRule(`.monaco-editor .find-widget { color: ${foreground}; }`);
  }
  const error = theme.getColor(errorForeground);
  if (error) {
    collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);
  }
  const resizeBorderBackground = theme.getColor(editorWidgetResizeBorder);
  if (resizeBorderBackground) {
    collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);
  } else {
    const border = theme.getColor(editorWidgetBorder);
    if (border) {
      collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);
    }
  }
  const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);
  if (toolbarHoverBackgroundColor) {
    collector.addRule(`
		.monaco-editor .find-widget .button:not(.disabled):hover,
		.monaco-editor .find-widget .codicon-find-selection:hover {
			background-color: ${toolbarHoverBackgroundColor} !important;
		}
	`);
  }
  const focusOutline = theme.getColor(focusBorder);
  if (focusOutline) {
    collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);
  }
});
var __decorate$u = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$u = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const SEARCH_STRING_MAX_LENGTH = 524288;
function getSelectionSearchString(editor2, seedSearchStringFromSelection = "single", seedSearchStringFromNonEmptySelection = false) {
  if (!editor2.hasModel()) {
    return null;
  }
  const selection = editor2.getSelection();
  if (seedSearchStringFromSelection === "single" && selection.startLineNumber === selection.endLineNumber || seedSearchStringFromSelection === "multiple") {
    if (selection.isEmpty()) {
      const wordAtPosition = editor2.getConfiguredWordAtPosition(selection.getStartPosition());
      if (wordAtPosition && false === seedSearchStringFromNonEmptySelection) {
        return wordAtPosition.word;
      }
    } else {
      if (editor2.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {
        return editor2.getModel().getValueInRange(selection);
      }
    }
  }
  return null;
}
let CommonFindController = class CommonFindController2 extends Disposable {
  get editor() {
    return this._editor;
  }
  static get(editor2) {
    return editor2.getContribution(CommonFindController2.ID);
  }
  constructor(editor2, contextKeyService, storageService, clipboardService) {
    super();
    this._editor = editor2;
    this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._clipboardService = clipboardService;
    this._updateHistoryDelayer = new Delayer(500);
    this._state = this._register(new FindReplaceState());
    this.loadQueryState();
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._model = null;
    this._register(this._editor.onDidChangeModel(() => {
      const shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel();
      this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
      }, false);
      if (shouldRestartFind) {
        this._start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: false,
          updateSearchScope: false,
          loop: this._editor.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
      }
    }));
  }
  dispose() {
    this.disposeModel();
    super.dispose();
  }
  disposeModel() {
    if (this._model) {
      this._model.dispose();
      this._model = null;
    }
  }
  _onStateChanged(e) {
    this.saveQueryState(e);
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._findWidgetVisible.set(true);
      } else {
        this._findWidgetVisible.reset();
        this.disposeModel();
      }
    }
    if (e.searchString) {
      this.setGlobalBufferTerm(this._state.searchString);
    }
  }
  saveQueryState(e) {
    if (e.isRegex) {
      this._storageService.store(
        "editor.isRegex",
        this._state.actualIsRegex,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.wholeWord) {
      this._storageService.store(
        "editor.wholeWord",
        this._state.actualWholeWord,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.matchCase) {
      this._storageService.store(
        "editor.matchCase",
        this._state.actualMatchCase,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.preserveCase) {
      this._storageService.store(
        "editor.preserveCase",
        this._state.actualPreserveCase,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, false);
  }
  isFindInputFocused() {
    return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: false,
      searchScope: null
    }, false);
    this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleSearchScope() {
    if (this._state.searchScope) {
      this._state.change({ searchScope: null }, true);
    } else {
      if (this._editor.hasModel()) {
        const selections = this._editor.getSelections();
        selections.map((selection) => {
          if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
            selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
          }
          if (!selection.isEmpty()) {
            return selection;
          }
          return null;
        }).filter((element) => !!element);
        if (selections.length) {
          this._state.change({ searchScope: selections }, true);
        }
      }
    }
  }
  setSearchString(searchString) {
    if (this._state.isRegex) {
      searchString = escapeRegExpCharacters(searchString);
    }
    this._state.change({ searchString }, false);
  }
  highlightFindOptions(ignoreWhenVisible = false) {
  }
  _start(opts, newState) {
    return __awaiter$q(this, void 0, void 0, function* () {
      this.disposeModel();
      if (!this._editor.hasModel()) {
        return;
      }
      const stateChanges = Object.assign(Object.assign({}, newState), { isRevealed: true });
      if (opts.seedSearchStringFromSelection === "single") {
        const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
        if (selectionSearchString) {
          if (this._state.isRegex) {
            stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
          } else {
            stateChanges.searchString = selectionSearchString;
          }
        }
      } else if (opts.seedSearchStringFromSelection === "multiple" && !opts.updateSearchScope) {
        const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
        const selectionSearchString = yield this.getGlobalBufferTerm();
        if (!this._editor.hasModel()) {
          return;
        }
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {
        stateChanges.isReplaceRevealed = true;
      } else if (!this._findWidgetVisible.get()) {
        stateChanges.isReplaceRevealed = false;
      }
      if (opts.updateSearchScope) {
        const currentSelections = this._editor.getSelections();
        if (currentSelections.some((selection) => !selection.isEmpty())) {
          stateChanges.searchScope = currentSelections;
        }
      }
      stateChanges.loop = opts.loop;
      this._state.change(stateChanges, false);
      if (!this._model) {
        this._model = new FindModelBoundToEditorModel(this._editor, this._state);
      }
    });
  }
  start(opts, newState) {
    return this._start(opts, newState);
  }
  moveToNextMatch() {
    if (this._model) {
      this._model.moveToNextMatch();
      return true;
    }
    return false;
  }
  moveToPrevMatch() {
    if (this._model) {
      this._model.moveToPrevMatch();
      return true;
    }
    return false;
  }
  goToMatch(index2) {
    if (this._model) {
      this._model.moveToMatch(index2);
      return true;
    }
    return false;
  }
  replace() {
    if (this._model) {
      this._model.replace();
      return true;
    }
    return false;
  }
  replaceAll() {
    if (this._model) {
      this._model.replaceAll();
      return true;
    }
    return false;
  }
  selectAllMatches() {
    if (this._model) {
      this._model.selectAllMatches();
      this._editor.focus();
      return true;
    }
    return false;
  }
  getGlobalBufferTerm() {
    return __awaiter$q(this, void 0, void 0, function* () {
      if (this._editor.getOption(
        40
        /* EditorOption.find */
      ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
        return this._clipboardService.readFindText();
      }
      return "";
    });
  }
  setGlobalBufferTerm(text) {
    if (this._editor.getOption(
      40
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
      this._clipboardService.writeFindText(text);
    }
  }
};
CommonFindController.ID = "editor.contrib.findController";
CommonFindController = __decorate$u([
  __param$u(1, IContextKeyService),
  __param$u(2, IStorageService),
  __param$u(3, IClipboardService)
], CommonFindController);
let FindController = class FindController2 extends CommonFindController {
  constructor(editor2, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, clipboardService) {
    super(editor2, _contextKeyService, _storageService, clipboardService);
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._themeService = _themeService;
    this._notificationService = _notificationService;
    this._widget = null;
    this._findOptionsWidget = null;
  }
  _start(opts, newState) {
    const _super = Object.create(null, {
      _start: { get: () => super._start }
    });
    return __awaiter$q(this, void 0, void 0, function* () {
      if (!this._widget) {
        this._createFindWidget();
      }
      const selection = this._editor.getSelection();
      let updateSearchScope = false;
      switch (this._editor.getOption(
        40
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          updateSearchScope = true;
          break;
        case "never":
          updateSearchScope = false;
          break;
        case "multiline": {
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          updateSearchScope = isSelectionMultipleLine;
          break;
        }
      }
      opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
      yield _super._start.call(this, opts, newState);
      if (this._widget) {
        if (opts.shouldFocus === 2) {
          this._widget.focusReplaceInput();
        } else if (opts.shouldFocus === 1) {
          this._widget.focusFindInput();
        }
      }
    });
  }
  highlightFindOptions(ignoreWhenVisible = false) {
    if (!this._widget) {
      this._createFindWidget();
    }
    if (this._state.isRevealed && !ignoreWhenVisible) {
      this._widget.highlightFindOptions();
    } else {
      this._findOptionsWidget.highlightFindOptions();
    }
  }
  _createFindWidget() {
    this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
    this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService));
  }
  saveViewState() {
    var _a3;
    return (_a3 = this._widget) === null || _a3 === void 0 ? void 0 : _a3.getViewState();
  }
  restoreViewState(state) {
    var _a3;
    (_a3 = this._widget) === null || _a3 === void 0 ? void 0 : _a3.setViewState(state);
  }
};
FindController = __decorate$u([
  __param$u(1, IContextViewService),
  __param$u(2, IContextKeyService),
  __param$u(3, IKeybindingService),
  __param$u(4, IThemeService),
  __param$u(5, INotificationService),
  __param$u(6, IStorageService),
  __param$u(7, IClipboardService)
], FindController);
const StartFindAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindAction,
  label: localize("startFindAction", "Find"),
  alias: "Find",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 36,
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
    order: 1
  }
}));
StartFindAction.addImplementation(0, (accessor, editor2, args) => {
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  return controller.start({
    forceRevealReplace: false,
    seedSearchStringFromSelection: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(
      40
      /* EditorOption.find */
    ).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(
      40
      /* EditorOption.find */
    ).loop
  });
});
const findArgDescription = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        regex: { type: "boolean" },
        regexOverride: {
          type: "number",
          description: localize("actions.find.isRegexOverride", 'Overrides "Use Regular Expression" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        wholeWord: { type: "boolean" },
        wholeWordOverride: {
          type: "number",
          description: localize("actions.find.wholeWordOverride", 'Overrides "Match Whole Word" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        matchCase: { type: "boolean" },
        matchCaseOverride: {
          type: "number",
          description: localize("actions.find.matchCaseOverride", 'Overrides "Math Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        preserveCase: { type: "boolean" },
        preserveCaseOverride: {
          type: "number",
          description: localize("actions.find.preserveCaseOverride", 'Overrides "Preserve Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
class StartFindWithArgsAction extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithArgs,
      label: localize("startFindWithArgsAction", "Find With Arguments"),
      alias: "Find With Arguments",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      description: findArgDescription
    });
  }
  run(accessor, editor2, args) {
    return __awaiter$q(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller) {
        const newState = args ? {
          searchString: args.searchString,
          replaceString: args.replaceString,
          isReplaceRevealed: args.replaceString !== void 0,
          isRegex: args.isRegex,
          // isRegexOverride: args.regexOverride,
          wholeWord: args.matchWholeWord,
          // wholeWordOverride: args.wholeWordOverride,
          matchCase: args.isCaseSensitive,
          // matchCaseOverride: args.matchCaseOverride,
          preserveCase: args.preserveCase
          // preserveCaseOverride: args.preserveCaseOverride,
        } : {};
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 1,
          shouldAnimate: true,
          updateSearchScope: (args === null || args === void 0 ? void 0 : args.findInSelection) || false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        }, newState);
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
}
class StartFindWithSelectionAction extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithSelection,
      label: localize("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2048 | 35
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter$q(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "multiple",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
}
class MatchFindAction extends EditorAction {
  run(accessor, editor2) {
    return __awaiter$q(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller && !this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(
            40
            /* EditorOption.find */
          ).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
        this._run(controller);
      }
    });
  }
}
class NextMatchFindAction extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextMatchFindAction,
      label: localize("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: [{
        kbExpr: EditorContextKeys.focus,
        primary: 61,
        mac: { primary: 2048 | 37, secondary: [
          61
          /* KeyCode.F3 */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
  }
  _run(controller) {
    const result = controller.moveToNextMatch();
    if (result) {
      controller.editor.pushUndoStop();
      return true;
    }
    return false;
  }
}
class PreviousMatchFindAction extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousMatchFindAction,
      label: localize("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: EditorContextKeys.focus,
          primary: 1024 | 61,
          mac: { primary: 2048 | 1024 | 37, secondary: [
            1024 | 61
            /* KeyCode.F3 */
          ] },
          weight: 100
          /* KeybindingWeight.EditorContrib */
        },
        {
          kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
          primary: 1024 | 3,
          weight: 100
          /* KeybindingWeight.EditorContrib */
        }
      ]
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
}
class MoveToMatchFindAction extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.GoToMatchFindAction,
      label: localize("findMatchAction.goToMatch", "Go to Match..."),
      alias: "Go to Match...",
      precondition: CONTEXT_FIND_WIDGET_VISIBLE
    });
    this._highlightDecorations = [];
  }
  run(accessor, editor2, args) {
    const controller = CommonFindController.get(editor2);
    if (!controller) {
      return;
    }
    const matchesCount = controller.getState().matchesCount;
    if (matchesCount < 1) {
      const notificationService = accessor.get(INotificationService);
      notificationService.notify({
        severity: Severity$1.Warning,
        message: localize("findMatchAction.noResults", "No matches. Try searching for something else.")
      });
      return;
    }
    const quickInputService = accessor.get(IQuickInputService);
    const inputBox = quickInputService.createInputBox();
    inputBox.placeholder = localize("findMatchAction.inputPlaceHolder", "Type a number to go to a specific match (between 1 and {0})", matchesCount);
    const toFindMatchIndex = (value) => {
      const index2 = parseInt(value);
      if (isNaN(index2)) {
        return void 0;
      }
      const matchCount = controller.getState().matchesCount;
      if (index2 > 0 && index2 <= matchCount) {
        return index2 - 1;
      } else if (index2 < 0 && index2 >= -matchCount) {
        return matchCount + index2;
      }
      return void 0;
    };
    const updatePickerAndEditor = (value) => {
      const index2 = toFindMatchIndex(value);
      if (typeof index2 === "number") {
        inputBox.validationMessage = void 0;
        controller.goToMatch(index2);
        const currentMatch = controller.getState().currentMatch;
        if (currentMatch) {
          this.addDecorations(editor2, currentMatch);
        }
      } else {
        inputBox.validationMessage = localize("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", controller.getState().matchesCount);
        this.clearDecorations(editor2);
      }
    };
    inputBox.onDidChangeValue((value) => {
      updatePickerAndEditor(value);
    });
    inputBox.onDidAccept(() => {
      const index2 = toFindMatchIndex(inputBox.value);
      if (typeof index2 === "number") {
        controller.goToMatch(index2);
        inputBox.hide();
      } else {
        inputBox.validationMessage = localize("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", controller.getState().matchesCount);
      }
    });
    inputBox.onDidHide(() => {
      this.clearDecorations(editor2);
      inputBox.dispose();
    });
    inputBox.show();
  }
  clearDecorations(editor2) {
    editor2.changeDecorations((changeAccessor) => {
      this._highlightDecorations = changeAccessor.deltaDecorations(this._highlightDecorations, []);
    });
  }
  addDecorations(editor2, range) {
    editor2.changeDecorations((changeAccessor) => {
      this._highlightDecorations = changeAccessor.deltaDecorations(this._highlightDecorations, [
        {
          range,
          options: {
            description: "find-match-quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: true
          }
        },
        {
          range,
          options: {
            description: "find-match-quick-access-range-highlight-overview",
            overviewRuler: {
              color: themeColorFromId(overviewRulerRangeHighlight),
              position: OverviewRulerLane.Full
            }
          }
        }
      ]);
    });
  }
}
class SelectionMatchFindAction extends EditorAction {
  run(accessor, editor2) {
    return __awaiter$q(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (!controller) {
        return;
      }
      const selectionSearchString = getSelectionSearchString(editor2, "single", false);
      if (selectionSearchString) {
        controller.setSearchString(selectionSearchString);
      }
      if (!this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(
            40
            /* EditorOption.find */
          ).loop
        });
        this._run(controller);
      }
    });
  }
}
class NextSelectionMatchFindAction extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextSelectionMatchFindAction,
      label: localize("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 61,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
}
class PreviousSelectionMatchFindAction extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousSelectionMatchFindAction,
      label: localize("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 61,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
}
const StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindReplaceAction,
  label: localize("startReplace", "Replace"),
  alias: "Replace",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 38,
    mac: {
      primary: 2048 | 512 | 36
      /* KeyCode.KeyF */
    },
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
    order: 2
  }
}));
StartFindReplaceAction.addImplementation(0, (accessor, editor2, args) => {
  if (!editor2.hasModel() || editor2.getOption(
    89
    /* EditorOption.readOnly */
  )) {
    return false;
  }
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  const currentSelection = editor2.getSelection();
  const findInputFocused = controller.isFindInputFocused();
  const seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor2.getOption(
    40
    /* EditorOption.find */
  ).seedSearchStringFromSelection !== "never" && !findInputFocused;
  const shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
  return controller.start({
    forceRevealReplace: true,
    seedSearchStringFromSelection: seedSearchStringFromSelection ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(
      40
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never",
    shouldFocus,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(
      40
      /* EditorOption.find */
    ).loop
  });
});
registerEditorContribution(
  CommonFindController.ID,
  FindController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(StartFindWithArgsAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(MoveToMatchFindAction);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
const FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
  id: FIND_IDS.CloseFindWidgetCommand,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.closeFindWidget(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (x) => x.toggleCaseSensitive(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleCaseSensitiveKeybinding.primary,
    mac: ToggleCaseSensitiveKeybinding.mac,
    win: ToggleCaseSensitiveKeybinding.win,
    linux: ToggleCaseSensitiveKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (x) => x.toggleWholeWords(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleWholeWordKeybinding.primary,
    mac: ToggleWholeWordKeybinding.mac,
    win: ToggleWholeWordKeybinding.win,
    linux: ToggleWholeWordKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleRegexCommand,
  precondition: void 0,
  handler: (x) => x.toggleRegex(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleRegexKeybinding.primary,
    mac: ToggleRegexKeybinding.mac,
    win: ToggleRegexKeybinding.win,
    linux: ToggleRegexKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (x) => x.toggleSearchScope(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleSearchScopeKeybinding.primary,
    mac: ToggleSearchScopeKeybinding.mac,
    win: ToggleSearchScopeKeybinding.win,
    linux: ToggleSearchScopeKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (x) => x.togglePreserveCase(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: TogglePreserveCaseKeybinding.primary,
    mac: TogglePreserveCaseKeybinding.mac,
    win: TogglePreserveCaseKeybinding.win,
    linux: TogglePreserveCaseKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 1024 | 22
    /* KeyCode.Digit1 */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 512 | 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: void 0,
    mac: {
      primary: 2048 | 3
    }
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.SelectAllMatchesAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.selectAllMatches(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 512 | 3
    /* KeyCode.Enter */
  }
}));
const folding = "";
const foldSourceAbbr = {
  [
    0
    /* FoldSource.provider */
  ]: " ",
  [
    1
    /* FoldSource.userDefined */
  ]: "u",
  [
    2
    /* FoldSource.recovered */
  ]: "r"
};
const MAX_FOLDING_REGIONS = 65535;
const MAX_LINE_NUMBER = 16777215;
const MASK_INDENT = 4278190080;
class BitField {
  constructor(size) {
    const numWords = Math.ceil(size / 32);
    this._states = new Uint32Array(numWords);
  }
  get(index2) {
    const arrayIndex = index2 / 32 | 0;
    const bit = index2 % 32;
    return (this._states[arrayIndex] & 1 << bit) !== 0;
  }
  set(index2, newState) {
    const arrayIndex = index2 / 32 | 0;
    const bit = index2 % 32;
    const value = this._states[arrayIndex];
    if (newState) {
      this._states[arrayIndex] = value | 1 << bit;
    } else {
      this._states[arrayIndex] = value & ~(1 << bit);
    }
  }
}
class FoldingRegions {
  constructor(startIndexes, endIndexes, types) {
    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
      throw new Error("invalid startIndexes or endIndexes size");
    }
    this._startIndexes = startIndexes;
    this._endIndexes = endIndexes;
    this._collapseStates = new BitField(startIndexes.length);
    this._userDefinedStates = new BitField(startIndexes.length);
    this._recoveredStates = new BitField(startIndexes.length);
    this._types = types;
    this._parentsComputed = false;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = true;
      const parentIndexes = [];
      const isInsideLast = (startLineNumber, endLineNumber) => {
        const index2 = parentIndexes[parentIndexes.length - 1];
        return this.getStartLineNumber(index2) <= startLineNumber && this.getEndLineNumber(index2) >= endLineNumber;
      };
      for (let i = 0, len = this._startIndexes.length; i < len; i++) {
        const startLineNumber = this._startIndexes[i];
        const endLineNumber = this._endIndexes[i];
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
        }
        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
          parentIndexes.pop();
        }
        const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
        parentIndexes.push(i);
        this._startIndexes[i] = startLineNumber + ((parentIndex & 255) << 24);
        this._endIndexes[i] = endLineNumber + ((parentIndex & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(index2) {
    return this._startIndexes[index2] & MAX_LINE_NUMBER;
  }
  getEndLineNumber(index2) {
    return this._endIndexes[index2] & MAX_LINE_NUMBER;
  }
  getType(index2) {
    return this._types ? this._types[index2] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(index2) {
    return this._collapseStates.get(index2);
  }
  setCollapsed(index2, newState) {
    this._collapseStates.set(index2, newState);
  }
  isUserDefined(index2) {
    return this._userDefinedStates.get(index2);
  }
  setUserDefined(index2, newState) {
    return this._userDefinedStates.set(index2, newState);
  }
  isRecovered(index2) {
    return this._recoveredStates.get(index2);
  }
  setRecovered(index2, newState) {
    return this._recoveredStates.set(index2, newState);
  }
  getSource(index2) {
    if (this.isUserDefined(index2)) {
      return 1;
    } else if (this.isRecovered(index2)) {
      return 2;
    }
    return 0;
  }
  setSource(index2, source) {
    if (source === 1) {
      this.setUserDefined(index2, true);
      this.setRecovered(index2, false);
    } else if (source === 2) {
      this.setUserDefined(index2, false);
      this.setRecovered(index2, true);
    } else {
      this.setUserDefined(index2, false);
      this.setRecovered(index2, false);
    }
  }
  setCollapsedAllOfType(type, newState) {
    let hasChanged = false;
    if (this._types) {
      for (let i = 0; i < this._types.length; i++) {
        if (this._types[i] === type) {
          this.setCollapsed(i, newState);
          hasChanged = true;
        }
      }
    }
    return hasChanged;
  }
  toRegion(index2) {
    return new FoldingRegion(this, index2);
  }
  getParentIndex(index2) {
    this.ensureParentIndices();
    const parent = ((this._startIndexes[index2] & MASK_INDENT) >>> 24) + ((this._endIndexes[index2] & MASK_INDENT) >>> 16);
    if (parent === MAX_FOLDING_REGIONS) {
      return -1;
    }
    return parent;
  }
  contains(index2, line) {
    return this.getStartLineNumber(index2) <= line && this.getEndLineNumber(index2) >= line;
  }
  findIndex(line) {
    let low = 0, high = this._startIndexes.length;
    if (high === 0) {
      return -1;
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (line < this.getStartLineNumber(mid)) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low - 1;
  }
  findRange(line) {
    let index2 = this.findIndex(line);
    if (index2 >= 0) {
      const endLineNumber = this.getEndLineNumber(index2);
      if (endLineNumber >= line) {
        return index2;
      }
      index2 = this.getParentIndex(index2);
      while (index2 !== -1) {
        if (this.contains(index2, line)) {
          return index2;
        }
        index2 = this.getParentIndex(index2);
      }
    }
    return -1;
  }
  toString() {
    const res = [];
    for (let i = 0; i < this.length; i++) {
      res[i] = `[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? "+" : "-"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;
    }
    return res.join(", ");
  }
  toFoldRange(index2) {
    return {
      startLineNumber: this._startIndexes[index2] & MAX_LINE_NUMBER,
      endLineNumber: this._endIndexes[index2] & MAX_LINE_NUMBER,
      type: this._types ? this._types[index2] : void 0,
      isCollapsed: this.isCollapsed(index2),
      source: this.getSource(index2)
    };
  }
  static fromFoldRanges(ranges) {
    const rangesLength = ranges.length;
    const startIndexes = new Uint32Array(rangesLength);
    const endIndexes = new Uint32Array(rangesLength);
    let types = [];
    let gotTypes = false;
    for (let i = 0; i < rangesLength; i++) {
      const range = ranges[i];
      startIndexes[i] = range.startLineNumber;
      endIndexes[i] = range.endLineNumber;
      types.push(range.type);
      if (range.type) {
        gotTypes = true;
      }
    }
    if (!gotTypes) {
      types = void 0;
    }
    const regions = new FoldingRegions(startIndexes, endIndexes, types);
    for (let i = 0; i < rangesLength; i++) {
      if (ranges[i].isCollapsed) {
        regions.setCollapsed(i, true);
      }
      regions.setSource(i, ranges[i].source);
    }
    return regions;
  }
  /**
   * Two inputs, each a FoldingRegions or a FoldRange[], are merged.
   * Each input must be pre-sorted on startLineNumber.
   * The first list is assumed to always include all regions currently defined by range providers.
   * The second list only contains the previously collapsed and all manual ranges.
   * If the line position matches, the range of the new range is taken, and the range is no longer manual
   * When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
   * overlapping entries in the first list are discarded.
   * Invalid entries are discarded. An entry is invalid if:
   * 		the start and end line numbers aren't a valid range of line numbers,
   * 		it is out of sequence or has the same start line as a preceding entry,
   * 		it overlaps a preceding entry and is not fully contained by that entry.
   */
  static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {
    maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;
    const getIndexedFunction = (r, limit) => {
      return Array.isArray(r) ? (i) => {
        return i < limit ? r[i] : void 0;
      } : (i) => {
        return i < limit ? r.toFoldRange(i) : void 0;
      };
    };
    const getA = getIndexedFunction(rangesA, rangesA.length);
    const getB = getIndexedFunction(rangesB, rangesB.length);
    let indexA = 0;
    let indexB = 0;
    let nextA = getA(0);
    let nextB = getB(0);
    const stackedRanges = [];
    let topStackedRange;
    let prevLineNumber = 0;
    const resultRanges = [];
    while (nextA || nextB) {
      let useRange = void 0;
      if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {
        if (nextA && nextA.startLineNumber === nextB.startLineNumber) {
          if (nextB.source === 1) {
            useRange = nextB;
          } else {
            useRange = nextA;
            useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;
            useRange.source = 0;
          }
          nextA = getA(++indexA);
        } else {
          useRange = nextB;
          if (nextB.isCollapsed && nextB.source === 0) {
            useRange.source = 2;
          }
        }
        nextB = getB(++indexB);
      } else {
        let scanIndex = indexB;
        let prescanB = nextB;
        while (true) {
          if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {
            useRange = nextA;
            break;
          }
          if (prescanB.source === 1 && prescanB.endLineNumber > nextA.endLineNumber) {
            break;
          }
          prescanB = getB(++scanIndex);
        }
        nextA = getA(++indexA);
      }
      if (useRange) {
        while (topStackedRange && topStackedRange.endLineNumber < useRange.startLineNumber) {
          topStackedRange = stackedRanges.pop();
        }
        if (useRange.endLineNumber > useRange.startLineNumber && useRange.startLineNumber > prevLineNumber && useRange.endLineNumber <= maxLineNumber && (!topStackedRange || topStackedRange.endLineNumber >= useRange.endLineNumber)) {
          resultRanges.push(useRange);
          prevLineNumber = useRange.startLineNumber;
          if (topStackedRange) {
            stackedRanges.push(topStackedRange);
          }
          topStackedRange = useRange;
        }
      }
    }
    return resultRanges;
  }
}
class FoldingRegion {
  constructor(ranges, index2) {
    this.ranges = ranges;
    this.index = index2;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(range) {
    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;
  }
  containsLine(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
  }
  hidesLine(lineNumber) {
    return this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;
  }
}
class FoldingModel {
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  get decorationProvider() {
    return this._decorationProvider;
  }
  constructor(textModel, decorationProvider) {
    this._updateEventEmitter = new Emitter();
    this.onDidChange = this._updateEventEmitter.event;
    this._textModel = textModel;
    this._decorationProvider = decorationProvider;
    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
    this._editorDecorationIds = [];
  }
  toggleCollapseState(toggledRegions) {
    if (!toggledRegions.length) {
      return;
    }
    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
    const processed = {};
    this._decorationProvider.changeDecorations((accessor) => {
      let k = 0;
      let dirtyRegionEndLine = -1;
      let lastHiddenLine = -1;
      const updateDecorationsUntil = (index2) => {
        while (k < index2) {
          const endLineNumber = this._regions.getEndLineNumber(k);
          const isCollapsed = this._regions.isCollapsed(k);
          if (endLineNumber <= dirtyRegionEndLine) {
            const isManual = this.regions.getSource(k) !== 0;
            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));
          }
          if (isCollapsed && endLineNumber > lastHiddenLine) {
            lastHiddenLine = endLineNumber;
          }
          k++;
        }
      };
      for (const region of toggledRegions) {
        const index2 = region.regionIndex;
        const editorDecorationId = this._editorDecorationIds[index2];
        if (editorDecorationId && !processed[editorDecorationId]) {
          processed[editorDecorationId] = true;
          updateDecorationsUntil(index2);
          const newCollapseState = !this._regions.isCollapsed(index2);
          this._regions.setCollapsed(index2, newCollapseState);
          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index2));
        }
      }
      updateDecorationsUntil(this._regions.length);
    });
    this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });
  }
  removeManualRanges(ranges) {
    const newFoldingRanges = new Array();
    const intersects = (foldRange) => {
      for (const range of ranges) {
        if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {
          return true;
        }
      }
      return false;
    };
    for (let i = 0; i < this._regions.length; i++) {
      const foldRange = this._regions.toFoldRange(i);
      if (foldRange.source === 0 || !intersects(foldRange)) {
        newFoldingRanges.push(foldRange);
      }
    }
    this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));
  }
  update(newRegions, blockedLineNumers = []) {
    const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);
    const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());
    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
  }
  updatePost(newRegions) {
    const newEditorDecorations = [];
    let lastHiddenLine = -1;
    for (let index2 = 0, limit = newRegions.length; index2 < limit; index2++) {
      const startLineNumber = newRegions.getStartLineNumber(index2);
      const endLineNumber = newRegions.getEndLineNumber(index2);
      const isCollapsed = newRegions.isCollapsed(index2);
      const isManual = newRegions.getSource(index2) !== 0;
      const decorationRange = {
        startLineNumber,
        startColumn: this._textModel.getLineMaxColumn(startLineNumber),
        endLineNumber,
        endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1
      };
      newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });
      if (isCollapsed && endLineNumber > lastHiddenLine) {
        lastHiddenLine = endLineNumber;
      }
    }
    this._decorationProvider.changeDecorations((accessor) => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));
    this._regions = newRegions;
    this._updateEventEmitter.fire({ model: this });
  }
  _currentFoldedOrManualRanges(blockedLineNumers = []) {
    const isBlocked = (startLineNumber, endLineNumber) => {
      for (const blockedLineNumber of blockedLineNumers) {
        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {
          return true;
        }
      }
      return false;
    };
    const foldedRanges = [];
    for (let i = 0, limit = this._regions.length; i < limit; i++) {
      let isCollapsed = this.regions.isCollapsed(i);
      const source = this.regions.getSource(i);
      if (isCollapsed || source !== 0) {
        const foldRange = this._regions.toFoldRange(i);
        const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
        if (decRange) {
          if (isCollapsed && isBlocked(decRange.startLineNumber, decRange.endLineNumber)) {
            isCollapsed = false;
          }
          foldedRanges.push({
            startLineNumber: decRange.startLineNumber,
            endLineNumber: decRange.endLineNumber,
            type: foldRange.type,
            isCollapsed,
            source
          });
        }
      }
    }
    return foldedRanges;
  }
  /**
   * Collapse state memento, for persistence only
   */
  getMemento() {
    const foldedOrManualRanges = this._currentFoldedOrManualRanges();
    const result = [];
    const maxLineNumber = this._textModel.getLineCount();
    for (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {
      const range = foldedOrManualRanges[i];
      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {
        continue;
      }
      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
      result.push({
        startLineNumber: range.startLineNumber,
        endLineNumber: range.endLineNumber,
        isCollapsed: range.isCollapsed,
        source: range.source,
        checksum
      });
    }
    return result.length > 0 ? result : void 0;
  }
  /**
   * Apply persisted state, for persistence only
   */
  applyMemento(state) {
    var _a3, _b3;
    if (!Array.isArray(state)) {
      return;
    }
    const rangesToRestore = [];
    const maxLineNumber = this._textModel.getLineCount();
    for (const range of state) {
      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {
        continue;
      }
      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
      if (!range.checksum || checksum === range.checksum) {
        rangesToRestore.push({
          startLineNumber: range.startLineNumber,
          endLineNumber: range.endLineNumber,
          type: void 0,
          isCollapsed: (_a3 = range.isCollapsed) !== null && _a3 !== void 0 ? _a3 : true,
          source: (_b3 = range.source) !== null && _b3 !== void 0 ? _b3 : 0
          /* FoldSource.provider */
        });
      }
    }
    const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);
    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
  }
  _getLinesChecksum(lineNumber1, lineNumber2) {
    const h2 = hash(this._textModel.getLineContent(lineNumber1) + this._textModel.getLineContent(lineNumber2));
    return h2 % 1e6;
  }
  dispose() {
    this._decorationProvider.removeDecorations(this._editorDecorationIds);
  }
  getAllRegionsAtLine(lineNumber, filter) {
    const result = [];
    if (this._regions) {
      let index2 = this._regions.findRange(lineNumber);
      let level = 1;
      while (index2 >= 0) {
        const current = this._regions.toRegion(index2);
        if (!filter || filter(current, level)) {
          result.push(current);
        }
        level++;
        index2 = current.parentIndex;
      }
    }
    return result;
  }
  getRegionAtLine(lineNumber) {
    if (this._regions) {
      const index2 = this._regions.findRange(lineNumber);
      if (index2 >= 0) {
        return this._regions.toRegion(index2);
      }
    }
    return null;
  }
  getRegionsInside(region, filter) {
    const result = [];
    const index2 = region ? region.regionIndex + 1 : 0;
    const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
    if (filter && filter.length === 2) {
      const levelStack = [];
      for (let i = index2, len = this._regions.length; i < len; i++) {
        const current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {
            levelStack.pop();
          }
          levelStack.push(current);
          if (filter(current, levelStack.length)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    } else {
      for (let i = index2, len = this._regions.length; i < len; i++) {
        const current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          if (!filter || filter(current)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    }
    return result;
  }
}
function toggleCollapseState(foldingModel, levels, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const region = foldingModel.getRegionAtLine(lineNumber);
    if (region) {
      const doCollapse = !region.isCollapsed;
      toToggle.push(region);
      if (levels > 1) {
        const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
        toToggle.push(...regionsInside);
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {
  const toToggle = [];
  if (lineNumbers && lineNumbers.length > 0) {
    for (const lineNumber of lineNumbers) {
      const region = foldingModel.getRegionAtLine(lineNumber);
      if (region) {
        if (region.isCollapsed !== doCollapse) {
          toToggle.push(region);
        }
        if (levels > 1) {
          const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
          toToggle.push(...regionsInside);
        }
      }
    }
  } else {
    const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);
    toToggle.push(...regionsInside);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);
    toToggle.push(...regions);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);
    if (regions.length > 0) {
      toToggle.push(regions[0]);
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
  const filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some((line) => region.containsLine(line));
  const toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {
  const filteredRegions = [];
  for (const lineNumber of blockedLineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, void 0);
    if (regions.length > 0) {
      filteredRegions.push(regions[0]);
    }
  }
  const filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;
  const toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
  const editorModel = foldingModel.textModel;
  const regions = foldingModel.regions;
  const toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i)) {
      const startLineNumber = regions.getStartLineNumber(i);
      if (regExp.test(editorModel.getLineContent(startLineNumber))) {
        toToggle.push(regions.toRegion(i));
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForType(foldingModel, type, doCollapse) {
  const regions = foldingModel.regions;
  const toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {
      toToggle.push(regions.toRegion(i));
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function getParentFoldLine(lineNumber, foldingModel) {
  let startLineNumber = null;
  const foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null) {
    startLineNumber = foldingRegion.startLineNumber;
    if (lineNumber === startLineNumber) {
      const parentFoldingIdx = foldingRegion.parentIndex;
      if (parentFoldingIdx !== -1) {
        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);
      } else {
        startLineNumber = null;
      }
    }
  }
  return startLineNumber;
}
function getPreviousFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    if (lineNumber !== foldingRegion.startLineNumber) {
      return foldingRegion.startLineNumber;
    } else {
      const expectedParentIndex = foldingRegion.parentIndex;
      let minLineNumber = 0;
      if (expectedParentIndex !== -1) {
        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);
      }
      while (foldingRegion !== null) {
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
          if (foldingRegion.startLineNumber <= minLineNumber) {
            return null;
          } else if (foldingRegion.parentIndex === expectedParentIndex) {
            return foldingRegion.startLineNumber;
          }
        } else {
          return null;
        }
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber < lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
function getNextFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    const expectedParentIndex = foldingRegion.parentIndex;
    let maxLineNumber = 0;
    if (expectedParentIndex !== -1) {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);
    } else if (foldingModel.regions.length === 0) {
      return null;
    } else {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);
    }
    while (foldingRegion !== null) {
      if (foldingRegion.regionIndex < foldingModel.regions.length) {
        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        if (foldingRegion.startLineNumber >= maxLineNumber) {
          return null;
        } else if (foldingRegion.parentIndex === expectedParentIndex) {
          return foldingRegion.startLineNumber;
        }
      } else {
        return null;
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(0);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber > lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex < foldingModel.regions.length) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
class HiddenRangeModel {
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  constructor(model) {
    this._updateEventEmitter = new Emitter();
    this._hasLineChanges = false;
    this._foldingModel = model;
    this._foldingModelListener = model.onDidChange((_) => this.updateHiddenRanges());
    this._hiddenRanges = [];
    if (model.regions.length) {
      this.updateHiddenRanges();
    }
  }
  notifyChangeModelContent(e) {
    if (this._hiddenRanges.length && !this._hasLineChanges) {
      this._hasLineChanges = e.changes.some((change) => {
        return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;
      });
    }
  }
  updateHiddenRanges() {
    let updateHiddenAreas = false;
    const newHiddenAreas = [];
    let i = 0;
    let k = 0;
    let lastCollapsedStart = Number.MAX_VALUE;
    let lastCollapsedEnd = -1;
    const ranges = this._foldingModel.regions;
    for (; i < ranges.length; i++) {
      if (!ranges.isCollapsed(i)) {
        continue;
      }
      const startLineNumber = ranges.getStartLineNumber(i) + 1;
      const endLineNumber = ranges.getEndLineNumber(i);
      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
        continue;
      }
      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
        newHiddenAreas.push(this._hiddenRanges[k]);
        k++;
      } else {
        updateHiddenAreas = true;
        newHiddenAreas.push(new Range$1(startLineNumber, 1, endLineNumber, 1));
      }
      lastCollapsedStart = startLineNumber;
      lastCollapsedEnd = endLineNumber;
    }
    if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {
      this.applyHiddenRanges(newHiddenAreas);
    }
  }
  applyHiddenRanges(newHiddenAreas) {
    this._hiddenRanges = newHiddenAreas;
    this._hasLineChanges = false;
    this._updateEventEmitter.fire(newHiddenAreas);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(line) {
    return findRange(this._hiddenRanges, line) !== null;
  }
  adjustSelections(selections) {
    let hasChanges = false;
    const editorModel = this._foldingModel.textModel;
    let lastRange = null;
    const adjustLine = (line) => {
      if (!lastRange || !isInside(line, lastRange)) {
        lastRange = findRange(this._hiddenRanges, line);
      }
      if (lastRange) {
        return lastRange.startLineNumber - 1;
      }
      return null;
    };
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      const adjustedStartLine = adjustLine(selection.startLineNumber);
      if (adjustedStartLine) {
        selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
        hasChanges = true;
      }
      const adjustedEndLine = adjustLine(selection.endLineNumber);
      if (adjustedEndLine) {
        selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
        hasChanges = true;
      }
      selections[i] = selection;
    }
    return hasChanges;
  }
  dispose() {
    if (this.hiddenRanges.length > 0) {
      this._hiddenRanges = [];
      this._updateEventEmitter.fire(this._hiddenRanges);
    }
    if (this._foldingModelListener) {
      this._foldingModelListener.dispose();
      this._foldingModelListener = null;
    }
  }
}
function isInside(line, range) {
  return line >= range.startLineNumber && line <= range.endLineNumber;
}
function findRange(ranges, line) {
  const i = findFirstInSorted(ranges, (r) => line < r.startLineNumber) - 1;
  if (i >= 0 && ranges[i].endLineNumber >= line) {
    return ranges[i];
  }
  return null;
}
const MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5e3;
const ID_INDENT_PROVIDER = "indent";
class IndentRangeProvider {
  constructor(editorModel, languageConfigurationService, foldingRangesLimit) {
    this.editorModel = editorModel;
    this.languageConfigurationService = languageConfigurationService;
    this.foldingRangesLimit = foldingRangesLimit;
    this.id = ID_INDENT_PROVIDER;
  }
  dispose() {
  }
  compute(cancelationToken) {
    const foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;
    const offSide = foldingRules && !!foldingRules.offSide;
    const markers = foldingRules && foldingRules.markers;
    return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.foldingRangesLimit));
  }
}
let RangesCollector$1 = class RangesCollector {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._indentOccurrences = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  insertFirst(startLineNumber, endLineNumber, indent) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    const index2 = this._length;
    this._startIndexes[index2] = startLineNumber;
    this._endIndexes[index2] = endLineNumber;
    this._length++;
    if (indent < 1e3) {
      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
    }
  }
  toIndentRanges(model) {
    const limit = this._foldingRangesLimit.limit;
    if (this._length <= limit) {
      this._foldingRangesLimit.update(this._length, false);
      const startIndexes = new Uint32Array(this._length);
      const endIndexes = new Uint32Array(this._length);
      for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
        startIndexes[k] = this._startIndexes[i];
        endIndexes[k] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes);
    } else {
      this._foldingRangesLimit.update(this._length, limit);
      let entries = 0;
      let maxIndent = this._indentOccurrences.length;
      for (let i = 0; i < this._indentOccurrences.length; i++) {
        const n2 = this._indentOccurrences[i];
        if (n2) {
          if (n2 + entries > limit) {
            maxIndent = i;
            break;
          }
          entries += n2;
        }
      }
      const tabSize = model.getOptions().tabSize;
      const startIndexes = new Uint32Array(limit);
      const endIndexes = new Uint32Array(limit);
      for (let i = this._length - 1, k = 0; i >= 0; i--) {
        const startIndex = this._startIndexes[i];
        const lineContent = model.getLineContent(startIndex);
        const indent = computeIndentLevel(lineContent, tabSize);
        if (indent < maxIndent || indent === maxIndent && entries++ < limit) {
          startIndexes[k] = startIndex;
          endIndexes[k] = this._endIndexes[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes);
    }
  }
};
const foldingRangesLimitDefault = {
  limit: MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT,
  update: () => {
  }
};
function computeRanges(model, offSide, markers, foldingRangesLimit = foldingRangesLimitDefault) {
  const tabSize = model.getOptions().tabSize;
  const result = new RangesCollector$1(foldingRangesLimit);
  let pattern = void 0;
  if (markers) {
    pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);
  }
  const previousRegions = [];
  const line = model.getLineCount() + 1;
  previousRegions.push({ indent: -1, endAbove: line, line });
  for (let line2 = model.getLineCount(); line2 > 0; line2--) {
    const lineContent = model.getLineContent(line2);
    const indent = computeIndentLevel(lineContent, tabSize);
    let previous = previousRegions[previousRegions.length - 1];
    if (indent === -1) {
      if (offSide) {
        previous.endAbove = line2;
      }
      continue;
    }
    let m;
    if (pattern && (m = lineContent.match(pattern))) {
      if (m[1]) {
        let i = previousRegions.length - 1;
        while (i > 0 && previousRegions[i].indent !== -2) {
          i--;
        }
        if (i > 0) {
          previousRegions.length = i + 1;
          previous = previousRegions[i];
          result.insertFirst(line2, previous.line, indent);
          previous.line = line2;
          previous.indent = indent;
          previous.endAbove = line2;
          continue;
        }
      } else {
        previousRegions.push({ indent: -2, endAbove: line2, line: line2 });
        continue;
      }
    }
    if (previous.indent > indent) {
      do {
        previousRegions.pop();
        previous = previousRegions[previousRegions.length - 1];
      } while (previous.indent > indent);
      const endLineNumber = previous.endAbove - 1;
      if (endLineNumber - line2 >= 1) {
        result.insertFirst(line2, endLineNumber, indent);
      }
    }
    if (previous.indent === indent) {
      previous.endAbove = line2;
    } else {
      previousRegions.push({ indent, endAbove: line2, line: line2 });
    }
  }
  return result.toIndentRanges(model);
}
const foldBackground = registerColor("editor.foldBackground", { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hcDark: null, hcLight: null }, localize("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editorGutter.foldingControlForeground", { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, localize("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
const foldingExpandedIcon = registerIcon("folding-expanded", Codicon.chevronDown, localize("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin."));
const foldingCollapsedIcon = registerIcon("folding-collapsed", Codicon.chevronRight, localize("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin."));
const foldingManualCollapsedIcon = registerIcon("folding-manual-collapsed", foldingCollapsedIcon, localize("foldingManualCollapedIcon", "Icon for manually collapsed ranges in the editor glyph margin."));
const foldingManualExpandedIcon = registerIcon("folding-manual-expanded", foldingExpandedIcon, localize("foldingManualExpandedIcon", "Icon for manually expanded ranges in the editor glyph margin."));
const foldedBackgroundMinimap = { color: themeColorFromId(foldBackground), position: MinimapPosition.Inline };
class FoldingDecorationProvider {
  constructor(editor2) {
    this.editor = editor2;
    this.showFoldingControls = "mouseover";
    this.showFoldingHighlights = true;
  }
  getDecorationOption(isCollapsed, isHidden, isManual) {
    if (isHidden) {
      return FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;
    }
    if (this.showFoldingControls === "never") {
      if (isCollapsed) {
        return this.showFoldingHighlights ? FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION : FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION;
      }
      return FoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION;
    }
    if (isCollapsed) {
      return isManual ? this.showFoldingHighlights ? FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION : this.showFoldingHighlights ? FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
    } else if (this.showFoldingControls === "mouseover") {
      return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
    } else {
      return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
    }
  }
  changeDecorations(callback) {
    return this.editor.changeDecorations(callback);
  }
  removeDecorations(decorationIds) {
    this.editor.removeDecorations(decorationIds);
  }
}
FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)
});
FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)
});
FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true
});
FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true
});
FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-auto-hide-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-expanded-visual-decoration",
  stickiness: 0,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingManualExpandedIcon)
});
FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-expanded-auto-hide-visual-decoration",
  stickiness: 0,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualExpandedIcon)
});
FoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  isWholeLine: true
});
FoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-hidden-range-decoration",
  stickiness: 1
  /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
});
const foldingContext = {};
const ID_SYNTAX_PROVIDER = "syntax";
class SyntaxRangeProvider {
  constructor(editorModel, providers, handleFoldingRangesChange, foldingRangesLimit, fallbackRangeProvider) {
    this.editorModel = editorModel;
    this.providers = providers;
    this.handleFoldingRangesChange = handleFoldingRangesChange;
    this.foldingRangesLimit = foldingRangesLimit;
    this.fallbackRangeProvider = fallbackRangeProvider;
    this.id = ID_SYNTAX_PROVIDER;
    this.disposables = new DisposableStore();
    if (fallbackRangeProvider) {
      this.disposables.add(fallbackRangeProvider);
    }
    for (const provider of providers) {
      if (typeof provider.onDidChange === "function") {
        this.disposables.add(provider.onDidChange(handleFoldingRangesChange));
      }
    }
  }
  compute(cancellationToken) {
    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then((ranges) => {
      var _a3, _b3;
      if (ranges) {
        const res = sanitizeRanges(ranges, this.foldingRangesLimit);
        return res;
      }
      return (_b3 = (_a3 = this.fallbackRangeProvider) === null || _a3 === void 0 ? void 0 : _a3.compute(cancellationToken)) !== null && _b3 !== void 0 ? _b3 : null;
    });
  }
  dispose() {
    this.disposables.dispose();
  }
}
function collectSyntaxRanges(providers, model, cancellationToken) {
  let rangeData = null;
  const promises = providers.map((provider, i) => {
    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then((ranges) => {
      if (cancellationToken.isCancellationRequested) {
        return;
      }
      if (Array.isArray(ranges)) {
        if (!Array.isArray(rangeData)) {
          rangeData = [];
        }
        const nLines = model.getLineCount();
        for (const r of ranges) {
          if (r.start > 0 && r.end > r.start && r.end <= nLines) {
            rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
          }
        }
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then((_) => {
    return rangeData;
  });
}
class RangesCollector2 {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._nestingLevels = [];
    this._nestingLevelCounts = [];
    this._types = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  add(startLineNumber, endLineNumber, type, nestingLevel) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    const index2 = this._length;
    this._startIndexes[index2] = startLineNumber;
    this._endIndexes[index2] = endLineNumber;
    this._nestingLevels[index2] = nestingLevel;
    this._types[index2] = type;
    this._length++;
    if (nestingLevel < 30) {
      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
    }
  }
  toIndentRanges() {
    const limit = this._foldingRangesLimit.limit;
    if (this._length <= limit) {
      this._foldingRangesLimit.update(this._length, false);
      const startIndexes = new Uint32Array(this._length);
      const endIndexes = new Uint32Array(this._length);
      for (let i = 0; i < this._length; i++) {
        startIndexes[i] = this._startIndexes[i];
        endIndexes[i] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes, this._types);
    } else {
      this._foldingRangesLimit.update(this._length, limit);
      let entries = 0;
      let maxLevel = this._nestingLevelCounts.length;
      for (let i = 0; i < this._nestingLevelCounts.length; i++) {
        const n2 = this._nestingLevelCounts[i];
        if (n2) {
          if (n2 + entries > limit) {
            maxLevel = i;
            break;
          }
          entries += n2;
        }
      }
      const startIndexes = new Uint32Array(limit);
      const endIndexes = new Uint32Array(limit);
      const types = [];
      for (let i = 0, k = 0; i < this._length; i++) {
        const level = this._nestingLevels[i];
        if (level < maxLevel || level === maxLevel && entries++ < limit) {
          startIndexes[k] = this._startIndexes[i];
          endIndexes[k] = this._endIndexes[i];
          types[k] = this._types[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes, types);
    }
  }
}
function sanitizeRanges(rangeData, foldingRangesLimit) {
  const sorted = rangeData.sort((d1, d2) => {
    let diff = d1.start - d2.start;
    if (diff === 0) {
      diff = d1.rank - d2.rank;
    }
    return diff;
  });
  const collector = new RangesCollector2(foldingRangesLimit);
  let top = void 0;
  const previous = [];
  for (const entry of sorted) {
    if (!top) {
      top = entry;
      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
    } else {
      if (entry.start > top.start) {
        if (entry.end <= top.end) {
          previous.push(top);
          top = entry;
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        } else {
          if (entry.start > top.end) {
            do {
              top = previous.pop();
            } while (top && entry.start > top.end);
            if (top) {
              previous.push(top);
            }
            top = entry;
          }
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        }
      }
    }
  }
  return collector.toIndentRanges();
}
var __decorate$t = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$t = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$p = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const CONTEXT_FOLDING_ENABLED = new RawContextKey("foldingEnabled", false);
let FoldingController = class FoldingController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(FoldingController2.ID);
  }
  static getFoldingRangeProviders(languageFeaturesService, model) {
    var _a3, _b3;
    const foldingRangeProviders = languageFeaturesService.foldingRangeProvider.ordered(model);
    return (_b3 = (_a3 = FoldingController2._foldingRangeSelector) === null || _a3 === void 0 ? void 0 : _a3.call(FoldingController2, foldingRangeProviders, model)) !== null && _b3 !== void 0 ? _b3 : foldingRangeProviders;
  }
  static setFoldingRangeProviderSelector(foldingRangeSelector) {
    FoldingController2._foldingRangeSelector = foldingRangeSelector;
    return { dispose: () => {
      FoldingController2._foldingRangeSelector = void 0;
    } };
  }
  constructor(editor2, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this.contextKeyService = contextKeyService;
    this.languageConfigurationService = languageConfigurationService;
    this.languageFeaturesService = languageFeaturesService;
    this.localToDispose = this._register(new DisposableStore());
    this.editor = editor2;
    this._foldingLimitReporter = new RangesLimitReporter(editor2);
    const options = this.editor.getOptions();
    this._isEnabled = options.get(
      42
      /* EditorOption.folding */
    );
    this._useFoldingProviders = options.get(
      43
      /* EditorOption.foldingStrategy */
    ) !== "indentation";
    this._unfoldOnClickAfterEndOfLine = options.get(
      47
      /* EditorOption.unfoldOnClickAfterEndOfLine */
    );
    this._restoringViewState = false;
    this._currentModelHasFoldedImports = false;
    this._foldingImportsByDefault = options.get(
      45
      /* EditorOption.foldingImportsByDefault */
    );
    this.updateDebounceInfo = languageFeatureDebounceService.for(languageFeaturesService.foldingRangeProvider, "Folding", { min: 200 });
    this.foldingModel = null;
    this.hiddenRangeModel = null;
    this.rangeProvider = null;
    this.foldingRegionPromise = null;
    this.foldingModelPromise = null;
    this.updateScheduler = null;
    this.cursorChangedScheduler = null;
    this.mouseDownInfo = null;
    this.foldingDecorationProvider = new FoldingDecorationProvider(editor2);
    this.foldingDecorationProvider.showFoldingControls = options.get(
      108
      /* EditorOption.showFoldingControls */
    );
    this.foldingDecorationProvider.showFoldingHighlights = options.get(
      44
      /* EditorOption.foldingHighlight */
    );
    this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);
    this.foldingEnabled.set(this._isEnabled);
    this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        42
        /* EditorOption.folding */
      )) {
        this._isEnabled = this.editor.getOptions().get(
          42
          /* EditorOption.folding */
        );
        this.foldingEnabled.set(this._isEnabled);
        this.onModelChanged();
      }
      if (e.hasChanged(
        46
        /* EditorOption.foldingMaximumRegions */
      )) {
        this.onModelChanged();
      }
      if (e.hasChanged(
        108
        /* EditorOption.showFoldingControls */
      ) || e.hasChanged(
        44
        /* EditorOption.foldingHighlight */
      )) {
        const options2 = this.editor.getOptions();
        this.foldingDecorationProvider.showFoldingControls = options2.get(
          108
          /* EditorOption.showFoldingControls */
        );
        this.foldingDecorationProvider.showFoldingHighlights = options2.get(
          44
          /* EditorOption.foldingHighlight */
        );
        this.triggerFoldingModelChanged();
      }
      if (e.hasChanged(
        43
        /* EditorOption.foldingStrategy */
      )) {
        this._useFoldingProviders = this.editor.getOptions().get(
          43
          /* EditorOption.foldingStrategy */
        ) !== "indentation";
        this.onFoldingStrategyChanged();
      }
      if (e.hasChanged(
        47
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      )) {
        this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(
          47
          /* EditorOption.unfoldOnClickAfterEndOfLine */
        );
      }
      if (e.hasChanged(
        45
        /* EditorOption.foldingImportsByDefault */
      )) {
        this._foldingImportsByDefault = this.editor.getOptions().get(
          45
          /* EditorOption.foldingImportsByDefault */
        );
      }
    }));
    this.onModelChanged();
  }
  get limitReporter() {
    return this._foldingLimitReporter;
  }
  /**
   * Store view state.
   */
  saveViewState() {
    const model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
      return {};
    }
    if (this.foldingModel) {
      const collapsedRegions = this.foldingModel.getMemento();
      const provider = this.rangeProvider ? this.rangeProvider.id : void 0;
      return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };
    }
    return void 0;
  }
  /**
   * Restore view state.
   */
  restoreViewState(state) {
    const model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {
      return;
    }
    if (!state) {
      return;
    }
    this._currentModelHasFoldedImports = !!state.foldedImports;
    if (state.collapsedRegions && state.collapsedRegions.length > 0 && this.foldingModel) {
      this._restoringViewState = true;
      try {
        this.foldingModel.applyMemento(state.collapsedRegions);
      } finally {
        this._restoringViewState = false;
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    const model = this.editor.getModel();
    if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {
      return;
    }
    this._currentModelHasFoldedImports = false;
    this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
    this.localToDispose.add(this.foldingModel);
    this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
    this.localToDispose.add(this.hiddenRangeModel);
    this.localToDispose.add(this.hiddenRangeModel.onDidChange((hr) => this.onHiddenRangesChanges(hr)));
    this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));
    this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);
    this.localToDispose.add(this.cursorChangedScheduler);
    this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelContent((e) => this.onDidChangeModelContent(e)));
    this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));
    this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
    this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
    this.localToDispose.add({
      dispose: () => {
        var _a3, _b3;
        if (this.foldingRegionPromise) {
          this.foldingRegionPromise.cancel();
          this.foldingRegionPromise = null;
        }
        (_a3 = this.updateScheduler) === null || _a3 === void 0 ? void 0 : _a3.cancel();
        this.updateScheduler = null;
        this.foldingModel = null;
        this.foldingModelPromise = null;
        this.hiddenRangeModel = null;
        this.cursorChangedScheduler = null;
        (_b3 = this.rangeProvider) === null || _b3 === void 0 ? void 0 : _b3.dispose();
        this.rangeProvider = null;
      }
    });
    this.triggerFoldingModelChanged();
  }
  onFoldingStrategyChanged() {
    var _a3;
    (_a3 = this.rangeProvider) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    this.rangeProvider = null;
    this.triggerFoldingModelChanged();
  }
  getRangeProvider(editorModel) {
    if (this.rangeProvider) {
      return this.rangeProvider;
    }
    const indentRangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._foldingLimitReporter);
    this.rangeProvider = indentRangeProvider;
    if (this._useFoldingProviders && this.foldingModel) {
      const selectedProviders = FoldingController2.getFoldingRangeProviders(this.languageFeaturesService, editorModel);
      if (selectedProviders.length > 0) {
        this.rangeProvider = new SyntaxRangeProvider(editorModel, selectedProviders, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter, indentRangeProvider);
      }
    }
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onDidChangeModelContent(e) {
    var _a3;
    (_a3 = this.hiddenRangeModel) === null || _a3 === void 0 ? void 0 : _a3.notifyChangeModelContent(e);
    this.triggerFoldingModelChanged();
  }
  triggerFoldingModelChanged() {
    if (this.updateScheduler) {
      if (this.foldingRegionPromise) {
        this.foldingRegionPromise.cancel();
        this.foldingRegionPromise = null;
      }
      this.foldingModelPromise = this.updateScheduler.trigger(() => {
        const foldingModel = this.foldingModel;
        if (!foldingModel) {
          return null;
        }
        const sw = new StopWatch();
        const provider = this.getRangeProvider(foldingModel.textModel);
        const foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise((token) => provider.compute(token));
        return foldingRegionPromise.then((foldingRanges) => {
          if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) {
            let scrollState;
            if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
              const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind$1.Imports.value, true);
              if (hasChanges) {
                scrollState = StableEditorScrollState.capture(this.editor);
                this._currentModelHasFoldedImports = hasChanges;
              }
            }
            const selections = this.editor.getSelections();
            const selectionLineNumbers = selections ? selections.map((s) => s.startLineNumber) : [];
            foldingModel.update(foldingRanges, selectionLineNumbers);
            scrollState === null || scrollState === void 0 ? void 0 : scrollState.restore(this.editor);
            const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());
            if (this.updateScheduler) {
              this.updateScheduler.defaultDelay = newValue;
            }
          }
          return foldingModel;
        });
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return null;
      });
    }
  }
  onHiddenRangesChanges(hiddenRanges) {
    if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {
      const selections = this.editor.getSelections();
      if (selections) {
        if (this.hiddenRangeModel.adjustSelections(selections)) {
          this.editor.setSelections(selections);
        }
      }
    }
    this.editor.setHiddenAreas(hiddenRanges, this);
  }
  onCursorPositionChanged() {
    if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {
      this.cursorChangedScheduler.schedule();
    }
  }
  revealCursor() {
    const foldingModel = this.getFoldingModel();
    if (!foldingModel) {
      return;
    }
    foldingModel.then((foldingModel2) => {
      if (foldingModel2) {
        const selections = this.editor.getSelections();
        if (selections && selections.length > 0) {
          const toToggle = [];
          for (const selection of selections) {
            const lineNumber = selection.selectionStartLineNumber;
            if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {
              toToggle.push(...foldingModel2.getAllRegionsAtLine(lineNumber, (r) => r.isCollapsed && lineNumber > r.startLineNumber));
            }
          }
          if (toToggle.length) {
            foldingModel2.toggleCollapseState(toToggle);
            this.reveal(selections[0].getPosition());
          }
        }
      }
    }).then(void 0, onUnexpectedError);
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = null;
    if (!this.hiddenRangeModel || !e.target || !e.target.range) {
      return;
    }
    if (!e.event.leftButton && !e.event.middleButton) {
      return;
    }
    const range = e.target.range;
    let iconClicked = false;
    switch (e.target.type) {
      case 4: {
        const data = e.target.detail;
        const offsetLeftInGutter = e.target.element.offsetLeft;
        const gutterOffsetX = data.offsetX - offsetLeftInGutter;
        if (gutterOffsetX < 4) {
          return;
        }
        iconClicked = true;
        break;
      }
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {
          const data = e.target.detail;
          if (!data.isAfterLines) {
            break;
          }
        }
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          const model = this.editor.getModel();
          if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
            break;
          }
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };
  }
  onEditorMouseUp(e) {
    const foldingModel = this.foldingModel;
    if (!foldingModel || !this.mouseDownInfo || !e.target) {
      return;
    }
    const lineNumber = this.mouseDownInfo.lineNumber;
    const iconClicked = this.mouseDownInfo.iconClicked;
    const range = e.target.range;
    if (!range || range.startLineNumber !== lineNumber) {
      return;
    }
    if (iconClicked) {
      if (e.target.type !== 4) {
        return;
      }
    } else {
      const model = this.editor.getModel();
      if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {
        return;
      }
    }
    const region = foldingModel.getRegionAtLine(lineNumber);
    if (region && region.startLineNumber === lineNumber) {
      const isCollapsed = region.isCollapsed;
      if (iconClicked || isCollapsed) {
        const surrounding = e.event.altKey;
        let toToggle = [];
        if (surrounding) {
          const filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);
          const toMaybeToggle = foldingModel.getRegionsInside(null, filter);
          for (const r of toMaybeToggle) {
            if (r.isCollapsed) {
              toToggle.push(r);
            }
          }
          if (toToggle.length === 0) {
            toToggle = toMaybeToggle;
          }
        } else {
          const recursive = e.event.middleButton || e.event.shiftKey;
          if (recursive) {
            for (const r of foldingModel.getRegionsInside(region)) {
              if (r.isCollapsed === isCollapsed) {
                toToggle.push(r);
              }
            }
          }
          if (isCollapsed || !recursive || toToggle.length === 0) {
            toToggle.push(region);
          }
        }
        foldingModel.toggleCollapseState(toToggle);
        this.reveal({ lineNumber, column: 1 });
      }
    }
  }
  reveal(position) {
    this.editor.revealPositionInCenterIfOutsideViewport(
      position,
      0
      /* ScrollType.Smooth */
    );
  }
};
FoldingController.ID = "editor.contrib.folding";
FoldingController = __decorate$t([
  __param$t(1, IContextKeyService),
  __param$t(2, ILanguageConfigurationService),
  __param$t(3, INotificationService),
  __param$t(4, ILanguageFeatureDebounceService),
  __param$t(5, ILanguageFeaturesService)
], FoldingController);
class RangesLimitReporter {
  constructor(editor2) {
    this.editor = editor2;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._computed = 0;
    this._limited = false;
  }
  get limit() {
    return this.editor.getOptions().get(
      46
      /* EditorOption.foldingMaximumRegions */
    );
  }
  get computed() {
    return this._computed;
  }
  get limited() {
    return this._limited;
  }
  update(computed, limited) {
    if (computed !== this._computed || limited !== this._limited) {
      this._computed = computed;
      this._limited = limited;
      this._onDidChange.fire();
    }
  }
}
class FoldingAction extends EditorAction {
  runEditorCommand(accessor, editor2, args) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const foldingController = FoldingController.get(editor2);
    if (!foldingController) {
      return;
    }
    const foldingModelPromise = foldingController.getFoldingModel();
    if (foldingModelPromise) {
      this.reportTelemetry(accessor, editor2);
      return foldingModelPromise.then((foldingModel) => {
        if (foldingModel) {
          this.invoke(foldingController, foldingModel, editor2, args, languageConfigurationService);
          const selection = editor2.getSelection();
          if (selection) {
            foldingController.reveal(selection.getStartPosition());
          }
        }
      });
    }
  }
  getSelectedLines(editor2) {
    const selections = editor2.getSelections();
    return selections ? selections.map((s) => s.startLineNumber) : [];
  }
  getLineNumbers(args, editor2) {
    if (args && args.selectionLines) {
      return args.selectionLines.map((l) => l + 1);
    }
    return this.getSelectedLines(editor2);
  }
  run(_accessor, _editor) {
  }
}
function foldingArgumentsConstraint(args) {
  if (!isUndefined(args)) {
    if (!isObject(args)) {
      return false;
    }
    const foldingArgs = args;
    if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) {
      return false;
    }
    if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) {
      return false;
    }
    if (!isUndefined(foldingArgs.selectionLines) && (!Array.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) {
      return false;
    }
  }
  return true;
}
class UnfoldAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfold",
      label: localize("unfoldAction.label", "Unfold"),
      alias: "Unfold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 94,
        mac: {
          primary: 2048 | 512 | 94
          /* KeyCode.BracketRight */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      description: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number",
                  "default": 1
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"],
                  "default": "down"
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    const levels = args && args.levels || 1;
    const lineNumbers = this.getLineNumbers(args, editor2);
    if (args && args.direction === "up") {
      setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
    } else {
      setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
    }
  }
}
class UnFoldRecursivelyAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: localize("unFoldRecursivelyAction.label", "Unfold Recursively"),
      alias: "Unfold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 94
          /* KeyCode.BracketRight */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, _args) {
    setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor2));
  }
}
class FoldAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.fold",
      label: localize("foldAction.label", "Fold"),
      alias: "Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 92,
        mac: {
          primary: 2048 | 512 | 92
          /* KeyCode.BracketLeft */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      description: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number"
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"]
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    const lineNumbers = this.getLineNumbers(args, editor2);
    const levels = args && args.levels;
    const direction = args && args.direction;
    if (typeof levels !== "number" && typeof direction !== "string") {
      setCollapseStateUp(foldingModel, true, lineNumbers);
    } else {
      if (direction === "up") {
        setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);
      } else {
        setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);
      }
    }
  }
}
class ToggleFoldAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: localize("toggleFoldAction.label", "Toggle Fold"),
      alias: "Toggle Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 42
          /* KeyCode.KeyL */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    toggleCollapseState(foldingModel, 1, selectedLines);
  }
}
class FoldRecursivelyAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: localize("foldRecursivelyAction.label", "Fold Recursively"),
      alias: "Fold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 92
          /* KeyCode.BracketLeft */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
  }
}
class FoldAllBlockCommentsAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: localize("foldAllBlockComments.label", "Fold All Block Comments"),
      alias: "Fold All Block Comments",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 90
          /* KeyCode.Slash */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind$1.Comment.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;
      if (comments && comments.blockCommentStartToken) {
        const regExp = new RegExp("^\\s*" + escapeRegExpCharacters(comments.blockCommentStartToken));
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
}
class FoldAllRegionsAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: localize("foldAllMarkerRegions.label", "Fold All Regions"),
      alias: "Fold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 29
          /* KeyCode.Digit8 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind$1.Region.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        const regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
}
class UnfoldAllRegionsAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: localize("unfoldAllMarkerRegions.label", "Unfold All Regions"),
      alias: "Unfold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 30
          /* KeyCode.Digit9 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind$1.Region.value, false);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        const regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, false);
      }
    }
  }
}
class FoldAllRegionsExceptAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllExcept",
      label: localize("foldAllExcept.label", "Fold All Regions Except Selected"),
      alias: "Fold All Regions Except Selected",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 88
          /* KeyCode.Minus */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, true, selectedLines);
  }
}
class UnfoldAllRegionsExceptAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllExcept",
      label: localize("unfoldAllExcept.label", "Unfold All Regions Except Selected"),
      alias: "Unfold All Regions Except Selected",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 86
          /* KeyCode.Equal */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, false, selectedLines);
  }
}
class FoldAllAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAll",
      label: localize("foldAllAction.label", "Fold All"),
      alias: "Fold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 21
          /* KeyCode.Digit0 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, true);
  }
}
class UnfoldAllAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: localize("unfoldAllAction.label", "Unfold All"),
      alias: "Unfold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 40
          /* KeyCode.KeyJ */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, false);
  }
}
class FoldLevelAction extends FoldingAction {
  getFoldingLevel() {
    return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
  }
  invoke(_foldingController, foldingModel, editor2) {
    setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor2));
  }
}
FoldLevelAction.ID_PREFIX = "editor.foldLevel";
FoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;
class GotoParentFoldAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoParentFold",
      label: localize("gotoParentFold.label", "Go to Parent Fold"),
      alias: "Go to Parent Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
}
class GotoPreviousFoldAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoPreviousFold",
      label: localize("gotoPreviousFold.label", "Go to Previous Folding Range"),
      alias: "Go to Previous Folding Range",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
}
class GotoNextFoldAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoNextFold",
      label: localize("gotoNextFold.label", "Go to Next Folding Range"),
      alias: "Go to Next Folding Range",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
}
class FoldRangeFromSelectionAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.createFoldingRangeFromSelection",
      label: localize("createManualFoldRange.label", "Create Folding Range from Selection"),
      alias: "Create Folding Range from Selection",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 87
          /* KeyCode.Comma */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    var _a3;
    const collapseRanges = [];
    const selections = editor2.getSelections();
    if (selections) {
      for (const selection of selections) {
        let endLineNumber = selection.endLineNumber;
        if (selection.endColumn === 1) {
          --endLineNumber;
        }
        if (endLineNumber > selection.startLineNumber) {
          collapseRanges.push({
            startLineNumber: selection.startLineNumber,
            endLineNumber,
            type: void 0,
            isCollapsed: true,
            source: 1
            /* FoldSource.userDefined */
          });
          editor2.setSelection({
            startLineNumber: selection.startLineNumber,
            startColumn: 1,
            endLineNumber: selection.startLineNumber,
            endColumn: 1
          });
        }
      }
      if (collapseRanges.length > 0) {
        collapseRanges.sort((a, b) => {
          return a.startLineNumber - b.startLineNumber;
        });
        const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, (_a3 = editor2.getModel()) === null || _a3 === void 0 ? void 0 : _a3.getLineCount());
        foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));
      }
    }
  }
}
class RemoveFoldRangeFromSelectionAction extends FoldingAction {
  constructor() {
    super({
      id: "editor.removeManualFoldingRanges",
      label: localize("removeManualFoldingRanges.label", "Remove Manual Folding Ranges"),
      alias: "Remove Manual Folding Ranges",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 89
          /* KeyCode.Period */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(foldingController, foldingModel, editor2) {
    const selections = editor2.getSelections();
    if (selections) {
      const ranges = [];
      for (const selection of selections) {
        const { startLineNumber, endLineNumber } = selection;
        ranges.push(endLineNumber >= startLineNumber ? { startLineNumber, endLineNumber } : { endLineNumber, startLineNumber });
      }
      foldingModel.removeManualRanges(ranges);
      foldingController.triggerFoldingModelChanged();
    }
  }
}
registerEditorContribution(
  FoldingController.ID,
  FoldingController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(UnfoldAction);
registerEditorAction(UnFoldRecursivelyAction);
registerEditorAction(FoldAction);
registerEditorAction(FoldRecursivelyAction);
registerEditorAction(FoldAllAction);
registerEditorAction(UnfoldAllAction);
registerEditorAction(FoldAllBlockCommentsAction);
registerEditorAction(FoldAllRegionsAction);
registerEditorAction(UnfoldAllRegionsAction);
registerEditorAction(FoldAllRegionsExceptAction);
registerEditorAction(UnfoldAllRegionsExceptAction);
registerEditorAction(ToggleFoldAction);
registerEditorAction(GotoParentFoldAction);
registerEditorAction(GotoPreviousFoldAction);
registerEditorAction(GotoNextFoldAction);
registerEditorAction(FoldRangeFromSelectionAction);
registerEditorAction(RemoveFoldRangeFromSelectionAction);
for (let i = 1; i <= 7; i++) {
  registerInstantiatedEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(i),
    label: localize("foldLevelAction.label", "Fold Level {0}", i),
    alias: `Fold Level ${i}`,
    precondition: CONTEXT_FOLDING_ENABLED,
    kbOpts: {
      kbExpr: EditorContextKeys.editorTextFocus,
      primary: KeyChord(2048 | 41, 2048 | 21 + i),
      weight: 100
      /* KeybindingWeight.EditorContrib */
    }
  }));
}
CommandsRegistry.registerCommand("_executeFoldingRangeProvider", function(accessor, ...args) {
  return __awaiter$p(this, void 0, void 0, function* () {
    const [resource] = args;
    if (!(resource instanceof URI$1)) {
      throw illegalArgument();
    }
    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
    const model = accessor.get(IModelService).getModel(resource);
    if (!model) {
      throw illegalArgument();
    }
    const configurationService = accessor.get(IConfigurationService);
    if (!configurationService.getValue("editor.folding", { resource })) {
      return [];
    }
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const strategy = configurationService.getValue("editor.foldingStrategy", { resource });
    const foldingLimitReporter = {
      get limit() {
        return configurationService.getValue("editor.foldingMaximumRegions", { resource });
      },
      update: (computed, limited) => {
      }
    };
    const indentRangeProvider = new IndentRangeProvider(model, languageConfigurationService, foldingLimitReporter);
    let rangeProvider = indentRangeProvider;
    if (strategy !== "indentation") {
      const providers = FoldingController.getFoldingRangeProviders(languageFeaturesService, model);
      if (providers.length) {
        rangeProvider = new SyntaxRangeProvider(model, providers, () => {
        }, foldingLimitReporter, indentRangeProvider);
      }
    }
    const ranges = yield rangeProvider.compute(CancellationToken.None);
    const result = [];
    try {
      if (ranges) {
        for (let i = 0; i < ranges.length; i++) {
          const type = ranges.getType(i);
          result.push({ start: ranges.getStartLineNumber(i), end: ranges.getEndLineNumber(i), kind: type ? FoldingRangeKind$1.fromValue(type) : void 0 });
        }
      }
      return result;
    } finally {
      rangeProvider.dispose();
    }
  });
});
class EditorFontZoomIn extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: localize("EditorFontZoomIn.label", "Editor Font Zoom In"),
      alias: "Editor Font Zoom In",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
  }
}
class EditorFontZoomOut extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: localize("EditorFontZoomOut.label", "Editor Font Zoom Out"),
      alias: "Editor Font Zoom Out",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
  }
}
class EditorFontZoomReset extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: localize("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
      alias: "Editor Font Zoom Reset",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(0);
  }
}
registerEditorAction(EditorFontZoomIn);
registerEditorAction(EditorFontZoomOut);
registerEditorAction(EditorFontZoomReset);
var __decorate$s = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$s = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$o = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let FormatOnType = class FormatOnType2 {
  constructor(_editor, _languageFeaturesService, _workerService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._workerService = _workerService;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._disposables.add(_languageFeaturesService.onTypeFormattingEditProvider.onDidChange(this._update, this));
    this._disposables.add(_editor.onDidChangeModel(() => this._update()));
    this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
    this._disposables.add(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        55
        /* EditorOption.formatOnType */
      )) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    this._disposables.dispose();
    this._sessionDisposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear();
    if (!this._editor.getOption(
      55
      /* EditorOption.formatOnType */
    )) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const [support] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
    if (!support || !support.autoFormatTriggerCharacters) {
      return;
    }
    const triggerChars = new CharacterSet();
    for (const ch of support.autoFormatTriggerCharacters) {
      triggerChars.add(ch.charCodeAt(0));
    }
    this._sessionDisposables.add(this._editor.onDidType((text) => {
      const lastCharCode = text.charCodeAt(text.length - 1);
      if (triggerChars.has(lastCharCode)) {
        this._trigger(String.fromCharCode(lastCharCode));
      }
    }));
  }
  _trigger(ch) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty()) {
      return;
    }
    const model = this._editor.getModel();
    const position = this._editor.getPosition();
    const cts = new CancellationTokenSource();
    const unbind = this._editor.onDidChangeModelContent((e) => {
      if (e.isFlush) {
        cts.cancel();
        unbind.dispose();
        return;
      }
      for (let i = 0, len = e.changes.length; i < len; i++) {
        const change = e.changes[i];
        if (change.range.endLineNumber <= position.lineNumber) {
          cts.cancel();
          unbind.dispose();
          return;
        }
      }
    });
    getOnTypeFormattingEdits(this._workerService, this._languageFeaturesService, model, position, ch, model.getFormattingOptions(), cts.token).then((edits) => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      if (isNonEmptyArray(edits)) {
        FormattingEdit.execute(this._editor, edits, true);
        alertFormattingEdits(edits);
      }
    }).finally(() => {
      unbind.dispose();
    });
  }
};
FormatOnType.ID = "editor.contrib.autoFormat";
FormatOnType = __decorate$s([
  __param$s(1, ILanguageFeaturesService),
  __param$s(2, IEditorWorkerService)
], FormatOnType);
let FormatOnPaste = class FormatOnPaste2 {
  constructor(editor2, _languageFeaturesService, _instantiationService) {
    this.editor = editor2;
    this._languageFeaturesService = _languageFeaturesService;
    this._instantiationService = _instantiationService;
    this._callOnDispose = new DisposableStore();
    this._callOnModel = new DisposableStore();
    this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
    this._callOnDispose.add(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose();
    this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear();
    if (!this.editor.getOption(
      54
      /* EditorOption.formatOnPaste */
    )) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    if (!this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel())) {
      return;
    }
    this._callOnModel.add(this.editor.onDidPaste(({ range }) => this._trigger(range)));
  }
  _trigger(range) {
    if (!this.editor.hasModel()) {
      return;
    }
    if (this.editor.getSelections().length > 1) {
      return;
    }
    this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None).catch(onUnexpectedError);
  }
};
FormatOnPaste.ID = "editor.contrib.formatOnPaste";
FormatOnPaste = __decorate$s([
  __param$s(1, ILanguageFeaturesService),
  __param$s(2, IInstantiationService)
], FormatOnPaste);
class FormatDocumentAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatDocument",
      label: localize("formatDocument.label", "Format Document"),
      alias: "Format Document",
      precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 36,
        linux: {
          primary: 2048 | 1024 | 39
          /* KeyCode.KeyI */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.3
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter$o(this, void 0, void 0, function* () {
      if (editor2.hasModel()) {
        const instaService = accessor.get(IInstantiationService);
        const progressService = accessor.get(IEditorProgressService);
        yield progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor2, 1, Progress.None, CancellationToken.None), 250);
      }
    });
  }
}
class FormatSelectionAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatSelection",
      label: localize("formatSelection.label", "Format Selection"),
      alias: "Format Selection",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 36
          /* KeyCode.KeyF */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        when: EditorContextKeys.hasNonEmptySelection,
        group: "1_modification",
        order: 1.31
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter$o(this, void 0, void 0, function* () {
      if (!editor2.hasModel()) {
        return;
      }
      const instaService = accessor.get(IInstantiationService);
      const model = editor2.getModel();
      const ranges = editor2.getSelections().map((range) => {
        return range.isEmpty() ? new Range$1(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
      });
      const progressService = accessor.get(IEditorProgressService);
      yield progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor2, ranges, 1, Progress.None, CancellationToken.None), 250);
    });
  }
}
registerEditorContribution(
  FormatOnType.ID,
  FormatOnType,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorContribution(
  FormatOnPaste.ID,
  FormatOnPaste,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(FormatDocumentAction);
registerEditorAction(FormatSelectionAction);
CommandsRegistry.registerCommand("editor.action.format", (accessor) => __awaiter$o(void 0, void 0, void 0, function* () {
  const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (!editor2 || !editor2.hasModel()) {
    return;
  }
  const commandService = accessor.get(ICommandService);
  if (editor2.getSelection().isEmpty()) {
    yield commandService.executeCommand("editor.action.formatDocument");
  } else {
    yield commandService.executeCommand("editor.action.formatSelection");
  }
}));
var __awaiter$n = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", function(accessor, ...args) {
  return __awaiter$n(this, void 0, void 0, function* () {
    const [resource] = args;
    assertType(URI$1.isUri(resource));
    const outlineService = accessor.get(IOutlineModelService);
    const modelService = accessor.get(ITextModelService);
    const reference2 = yield modelService.createModelReference(resource);
    try {
      return (yield outlineService.getOrCreate(reference2.object.textEditorModel, CancellationToken.None)).getTopLevelSymbols();
    } finally {
      reference2.dispose();
    }
  });
});
const ghostText = "";
function applyEdits(text, edits) {
  const transformer = new PositionOffsetTransformer(text);
  const offsetEdits = edits.map((e) => {
    const range = Range$1.lift(e.range);
    return {
      startOffset: transformer.getOffset(range.getStartPosition()),
      endOffset: transformer.getOffset(range.getEndPosition()),
      text: e.text
    };
  });
  offsetEdits.sort((a, b) => b.startOffset - a.startOffset);
  for (const edit of offsetEdits) {
    text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);
  }
  return text;
}
class PositionOffsetTransformer {
  constructor(text) {
    this.lineStartOffsetByLineIdx = [];
    this.lineStartOffsetByLineIdx.push(0);
    for (let i = 0; i < text.length; i++) {
      if (text.charAt(i) === "\n") {
        this.lineStartOffsetByLineIdx.push(i + 1);
      }
    }
  }
  getOffset(position) {
    return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
  }
}
const array = [];
function getReadonlyEmptyArray() {
  return array;
}
class ColumnRange {
  constructor(startColumn, endColumnExclusive) {
    this.startColumn = startColumn;
    this.endColumnExclusive = endColumnExclusive;
    if (startColumn > endColumnExclusive) {
      throw new BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);
    }
  }
  toRange(lineNumber) {
    return new Range$1(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);
  }
}
function applyObservableDecorations(editor2, decorations) {
  const d = new DisposableStore();
  const decorationsCollection = editor2.createDecorationsCollection();
  d.add(autorun(`Apply decorations from ${decorations.debugName}`, (reader) => {
    const d2 = decorations.read(reader);
    decorationsCollection.set(d2);
  }));
  d.add({
    dispose: () => {
      decorationsCollection.clear();
    }
  });
  return d;
}
function addPositions(pos1, pos2) {
  return new Position$1(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);
}
function lengthOfText(text) {
  let line = 1;
  let column = 1;
  for (const c of text) {
    if (c === "\n") {
      line++;
      column = 1;
    } else {
      column++;
    }
  }
  return new Position$1(line, column);
}
class GhostText {
  constructor(lineNumber, parts) {
    this.lineNumber = lineNumber;
    this.parts = parts;
  }
  equals(other) {
    return this.lineNumber === other.lineNumber && this.parts.length === other.parts.length && this.parts.every((part, index2) => part.equals(other.parts[index2]));
  }
  /**
   * Only used for testing/debugging.
  */
  render(documentText, debug = false) {
    const l = this.lineNumber;
    return applyEdits(documentText, [
      ...this.parts.map((p) => ({
        range: { startLineNumber: l, endLineNumber: l, startColumn: p.column, endColumn: p.column },
        text: debug ? `[${p.lines.join("\n")}]` : p.lines.join("\n")
      }))
    ]);
  }
  renderForScreenReader(lineText) {
    if (this.parts.length === 0) {
      return "";
    }
    const lastPart = this.parts[this.parts.length - 1];
    const cappedLineText = lineText.substr(0, lastPart.column - 1);
    const text = applyEdits(cappedLineText, this.parts.map((p) => ({
      range: { startLineNumber: 1, endLineNumber: 1, startColumn: p.column, endColumn: p.column },
      text: p.lines.join("\n")
    })));
    return text.substring(this.parts[0].column - 1);
  }
  isEmpty() {
    return this.parts.every((p) => p.lines.length === 0);
  }
  get lineCount() {
    return 1 + this.parts.reduce((r, p) => r + p.lines.length - 1, 0);
  }
}
class GhostTextPart {
  constructor(column, lines, preview) {
    this.column = column;
    this.lines = lines;
    this.preview = preview;
  }
  equals(other) {
    return this.column === other.column && this.lines.length === other.lines.length && this.lines.every((line, index2) => line === other.lines[index2]);
  }
}
class GhostTextReplacement {
  constructor(lineNumber, columnRange, newLines, additionalReservedLineCount = 0) {
    this.lineNumber = lineNumber;
    this.columnRange = columnRange;
    this.newLines = newLines;
    this.additionalReservedLineCount = additionalReservedLineCount;
    this.parts = [
      new GhostTextPart(this.columnRange.endColumnExclusive, this.newLines, false)
    ];
  }
  renderForScreenReader(_lineText) {
    return this.newLines.join("\n");
  }
  render(documentText, debug = false) {
    const replaceRange = this.columnRange.toRange(this.lineNumber);
    if (debug) {
      return applyEdits(documentText, [
        { range: Range$1.fromPositions(replaceRange.getStartPosition()), text: `(` },
        { range: Range$1.fromPositions(replaceRange.getEndPosition()), text: `)[${this.newLines.join("\n")}]` }
      ]);
    } else {
      return applyEdits(documentText, [
        { range: replaceRange, text: this.newLines.join("\n") }
      ]);
    }
  }
  get lineCount() {
    return this.newLines.length;
  }
  isEmpty() {
    return this.parts.every((p) => p.lines.length === 0);
  }
}
var __decorate$r = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$r = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let GhostTextWidget = class GhostTextWidget2 extends Disposable {
  constructor(editor2, model, languageService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.languageService = languageService;
    this.isDisposed = observableValue("isDisposed", false);
    this.currentTextModel = observableFromEvent(this.editor.onDidChangeModel, () => this.editor.getModel());
    this.uiState = derived("uiState", (reader) => {
      if (this.isDisposed.read(reader)) {
        return void 0;
      }
      const textModel = this.currentTextModel.read(reader);
      if (textModel !== this.model.targetTextModel.read(reader)) {
        return void 0;
      }
      const ghostText2 = this.model.ghostText.read(reader);
      if (!ghostText2) {
        return void 0;
      }
      const replacedRange = ghostText2 instanceof GhostTextReplacement ? ghostText2.columnRange : void 0;
      const inlineTexts = [];
      const additionalLines = [];
      function addToAdditionalLines(lines, className) {
        if (additionalLines.length > 0) {
          const lastLine = additionalLines[additionalLines.length - 1];
          if (className) {
            lastLine.decorations.push(new LineDecoration(
              lastLine.content.length + 1,
              lastLine.content.length + 1 + lines[0].length,
              className,
              0
              /* InlineDecorationType.Regular */
            ));
          }
          lastLine.content += lines[0];
          lines = lines.slice(1);
        }
        for (const line of lines) {
          additionalLines.push({
            content: line,
            decorations: className ? [new LineDecoration(
              1,
              line.length + 1,
              className,
              0
              /* InlineDecorationType.Regular */
            )] : []
          });
        }
      }
      const textBufferLine = textModel.getLineContent(ghostText2.lineNumber);
      let hiddenTextStartColumn = void 0;
      let lastIdx = 0;
      for (const part of ghostText2.parts) {
        let lines = part.lines;
        if (hiddenTextStartColumn === void 0) {
          inlineTexts.push({
            column: part.column,
            text: lines[0],
            preview: part.preview
          });
          lines = lines.slice(1);
        } else {
          addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], void 0);
        }
        if (lines.length > 0) {
          addToAdditionalLines(lines, "ghost-text");
          if (hiddenTextStartColumn === void 0 && part.column <= textBufferLine.length) {
            hiddenTextStartColumn = part.column;
          }
        }
        lastIdx = part.column - 1;
      }
      if (hiddenTextStartColumn !== void 0) {
        addToAdditionalLines([textBufferLine.substring(lastIdx)], void 0);
      }
      const hiddenRange = hiddenTextStartColumn !== void 0 ? new ColumnRange(hiddenTextStartColumn, textBufferLine.length + 1) : void 0;
      return {
        replacedRange,
        inlineTexts,
        additionalLines,
        hiddenRange,
        lineNumber: ghostText2.lineNumber,
        additionalReservedLineCount: this.model.minReservedLineCount.read(reader),
        targetTextModel: textModel
      };
    });
    this.decorations = derived("decorations", (reader) => {
      const uiState = this.uiState.read(reader);
      if (!uiState) {
        return [];
      }
      const decorations = [];
      if (uiState.replacedRange) {
        decorations.push({
          range: uiState.replacedRange.toRange(uiState.lineNumber),
          options: { inlineClassName: "inline-completion-text-to-replace", description: "GhostTextReplacement" }
        });
      }
      if (uiState.hiddenRange) {
        decorations.push({
          range: uiState.hiddenRange.toRange(uiState.lineNumber),
          options: { inlineClassName: "ghost-text-hidden", description: "ghost-text-hidden" }
        });
      }
      for (const p of uiState.inlineTexts) {
        decorations.push({
          range: Range$1.fromPositions(new Position$1(uiState.lineNumber, p.column)),
          options: {
            description: "ghost-text",
            after: { content: p.text, inlineClassName: p.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration", cursorStops: InjectedTextCursorStops.Left },
            showIfCollapsed: true
          }
        });
      }
      return decorations;
    });
    this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this.editor, this.languageService.languageIdCodec, derived("lines", (reader) => {
      const uiState = this.uiState.read(reader);
      return uiState ? {
        lineNumber: uiState.lineNumber,
        additionalLines: uiState.additionalLines,
        minReservedLineCount: uiState.additionalReservedLineCount,
        targetTextModel: uiState.targetTextModel
      } : void 0;
    })));
    this._register(toDisposable(() => {
      this.isDisposed.set(true, void 0);
    }));
    this._register(applyObservableDecorations(this.editor, this.decorations));
  }
  ownsViewZone(viewZoneId) {
    return this.additionalLinesWidget.viewZoneId === viewZoneId;
  }
};
GhostTextWidget = __decorate$r([
  __param$r(2, ILanguageService)
], GhostTextWidget);
class AdditionalLinesWidget extends Disposable {
  get viewZoneId() {
    return this._viewZoneId;
  }
  constructor(editor2, languageIdCodec, lines) {
    super();
    this.editor = editor2;
    this.languageIdCodec = languageIdCodec;
    this.lines = lines;
    this._viewZoneId = void 0;
    this.editorOptionsChanged = observableSignalFromEvent("editorOptionChanged", Event.filter(this.editor.onDidChangeConfiguration, (e) => e.hasChanged(
      32
      /* EditorOption.disableMonospaceOptimizations */
    ) || e.hasChanged(
      115
      /* EditorOption.stopRenderingLineAfter */
    ) || e.hasChanged(
      97
      /* EditorOption.renderWhitespace */
    ) || e.hasChanged(
      92
      /* EditorOption.renderControlCharacters */
    ) || e.hasChanged(
      50
      /* EditorOption.fontLigatures */
    ) || e.hasChanged(
      49
      /* EditorOption.fontInfo */
    ) || e.hasChanged(
      65
      /* EditorOption.lineHeight */
    )));
    this._register(autorun("update view zone", (reader) => {
      const lines2 = this.lines.read(reader);
      this.editorOptionsChanged.read(reader);
      if (lines2) {
        this.updateLines(lines2.lineNumber, lines2.additionalLines, lines2.minReservedLineCount);
      } else {
        this.clear();
      }
    }));
  }
  dispose() {
    super.dispose();
    this.clear();
  }
  clear() {
    this.editor.changeViewZones((changeAccessor) => {
      if (this._viewZoneId) {
        changeAccessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
      }
    });
  }
  updateLines(lineNumber, additionalLines, minReservedLineCount) {
    const textModel = this.editor.getModel();
    if (!textModel) {
      return;
    }
    const { tabSize } = textModel.getOptions();
    this.editor.changeViewZones((changeAccessor) => {
      if (this._viewZoneId) {
        changeAccessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
      }
      const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
      if (heightInLines > 0) {
        const domNode = document.createElement("div");
        renderLines(domNode, tabSize, additionalLines, this.editor.getOptions(), this.languageIdCodec);
        this._viewZoneId = changeAccessor.addZone({
          afterLineNumber: lineNumber,
          heightInLines,
          domNode,
          afterColumnAffinity: 1
          /* PositionAffinity.Right */
        });
      }
    });
  }
}
function renderLines(domNode, tabSize, lines, opts, languageIdCodec) {
  const disableMonospaceOptimizations = opts.get(
    32
    /* EditorOption.disableMonospaceOptimizations */
  );
  const stopRenderingLineAfter = opts.get(
    115
    /* EditorOption.stopRenderingLineAfter */
  );
  const renderWhitespace = "none";
  const renderControlCharacters = opts.get(
    92
    /* EditorOption.renderControlCharacters */
  );
  const fontLigatures = opts.get(
    50
    /* EditorOption.fontLigatures */
  );
  const fontInfo = opts.get(
    49
    /* EditorOption.fontInfo */
  );
  const lineHeight = opts.get(
    65
    /* EditorOption.lineHeight */
  );
  const sb = new StringBuilder(1e4);
  sb.appendString('<div class="suggest-preview-text">');
  for (let i = 0, len = lines.length; i < len; i++) {
    const lineData = lines[i];
    const line = lineData.content;
    sb.appendString('<div class="view-line');
    sb.appendString('" style="top:');
    sb.appendString(String(i * lineHeight));
    sb.appendString('px;width:1000000px;">');
    const isBasicASCII$1 = isBasicASCII(line);
    const containsRTL$1 = containsRTL(line);
    const lineTokens = LineTokens.createEmpty(line, languageIdCodec);
    renderViewLine(new RenderLineInput(fontInfo.isMonospace && !disableMonospaceOptimizations, fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII$1, containsRTL$1, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null), sb);
    sb.appendString("</div>");
  }
  sb.appendString("</div>");
  applyFontInfo(domNode, fontInfo);
  const html = sb.build();
  const trustedhtml = ttPolicy ? ttPolicy.createHTML(html) : html;
  domNode.innerHTML = trustedhtml;
}
const ttPolicy = createTrustedTypesPolicy("editorGhostText", { createHTML: (value) => value });
class SingleTextEdit {
  constructor(range, text) {
    this.range = range;
    this.text = text;
  }
  removeCommonPrefix(model, validModelRange) {
    const modelRange = validModelRange ? this.range.intersectRanges(validModelRange) : this.range;
    if (!modelRange) {
      return this;
    }
    const valueToReplace = model.getValueInRange(
      modelRange,
      1
      /* EndOfLinePreference.LF */
    );
    const commonPrefixLen = commonPrefixLength(valueToReplace, this.text);
    const start = addPositions(this.range.getStartPosition(), lengthOfText(valueToReplace.substring(0, commonPrefixLen)));
    const text = this.text.substring(commonPrefixLen);
    const range = Range$1.fromPositions(start, this.range.getEndPosition());
    return new SingleTextEdit(range, text);
  }
  augments(base) {
    return this.text.startsWith(base.text) && rangeExtends(this.range, base.range);
  }
  /**
   * @param previewSuffixLength Sets where to split `inlineCompletion.text`.
   * 	If the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.
  */
  computeGhostText(model, mode, cursorPosition, previewSuffixLength = 0) {
    let edit = this.removeCommonPrefix(model);
    if (edit.range.endLineNumber !== edit.range.startLineNumber) {
      return void 0;
    }
    const sourceLine = model.getLineContent(edit.range.startLineNumber);
    const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;
    const suggestionTouchesIndentation = edit.range.startColumn - 1 <= sourceIndentationLength;
    if (suggestionTouchesIndentation) {
      const suggestionAddedIndentationLength = getLeadingWhitespace(edit.text).length;
      const replacedIndentation = sourceLine.substring(edit.range.startColumn - 1, sourceIndentationLength);
      const [startPosition, endPosition] = [edit.range.getStartPosition(), edit.range.getEndPosition()];
      const newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column ? startPosition.delta(0, replacedIndentation.length) : endPosition;
      const rangeThatDoesNotReplaceIndentation = Range$1.fromPositions(newStartPosition, endPosition);
      const suggestionWithoutIndentationChange = edit.text.startsWith(replacedIndentation) ? edit.text.substring(replacedIndentation.length) : edit.text.substring(suggestionAddedIndentationLength);
      edit = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);
    }
    const valueToBeReplaced = model.getValueInRange(edit.range);
    const changes = cachingDiff(valueToBeReplaced, edit.text);
    if (!changes) {
      return void 0;
    }
    const lineNumber = edit.range.startLineNumber;
    const parts = new Array();
    if (mode === "prefix") {
      const filteredChanges = changes.filter((c) => c.originalLength === 0);
      if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {
        return void 0;
      }
    }
    const previewStartInCompletionText = edit.text.length - previewSuffixLength;
    for (const c of changes) {
      const insertColumn = edit.range.startColumn + c.originalStart + c.originalLength;
      if (mode === "subwordSmart" && cursorPosition && cursorPosition.lineNumber === edit.range.startLineNumber && insertColumn < cursorPosition.column) {
        return void 0;
      }
      if (c.originalLength > 0) {
        return void 0;
      }
      if (c.modifiedLength === 0) {
        continue;
      }
      const modifiedEnd = c.modifiedStart + c.modifiedLength;
      const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));
      const nonPreviewText = edit.text.substring(c.modifiedStart, nonPreviewTextEnd);
      const italicText = edit.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));
      if (nonPreviewText.length > 0) {
        const lines = splitLines(nonPreviewText);
        parts.push(new GhostTextPart(insertColumn, lines, false));
      }
      if (italicText.length > 0) {
        const lines = splitLines(italicText);
        parts.push(new GhostTextPart(insertColumn, lines, true));
      }
    }
    return new GhostText(lineNumber, parts);
  }
}
function rangeExtends(extendingRange, rangeToExtend) {
  return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition()) && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());
}
let lastRequest = void 0;
function cachingDiff(originalValue, newValue) {
  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {
    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;
  } else {
    let changes = smartDiff(originalValue, newValue, true);
    if (changes) {
      const deletedChars = deletedCharacters(changes);
      if (deletedChars > 0) {
        const newChanges = smartDiff(originalValue, newValue, false);
        if (newChanges && deletedCharacters(newChanges) < deletedChars) {
          changes = newChanges;
        }
      }
    }
    lastRequest = {
      originalValue,
      newValue,
      changes
    };
    return changes;
  }
}
function deletedCharacters(changes) {
  let sum = 0;
  for (const c of changes) {
    sum += c.originalLength;
  }
  return sum;
}
function smartDiff(originalValue, newValue, smartBracketMatching) {
  if (originalValue.length > 5e3 || newValue.length > 5e3) {
    return void 0;
  }
  function getMaxCharCode(val) {
    let maxCharCode2 = 0;
    for (let i = 0, len = val.length; i < len; i++) {
      const charCode = val.charCodeAt(i);
      if (charCode > maxCharCode2) {
        maxCharCode2 = charCode;
      }
    }
    return maxCharCode2;
  }
  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));
  function getUniqueCharCode(id) {
    if (id < 0) {
      throw new Error("unexpected");
    }
    return maxCharCode + id + 1;
  }
  function getElements(source) {
    let level = 0;
    let group = 0;
    const characters = new Int32Array(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      if (smartBracketMatching && source[i] === "(") {
        const id = group * 100 + level;
        characters[i] = getUniqueCharCode(2 * id);
        level++;
      } else if (smartBracketMatching && source[i] === ")") {
        level = Math.max(level - 1, 0);
        const id = group * 100 + level;
        characters[i] = getUniqueCharCode(2 * id + 1);
        if (level === 0) {
          group++;
        }
      } else {
        characters[i] = source.charCodeAt(i);
      }
    }
    return characters;
  }
  const elements1 = getElements(originalValue);
  const elements2 = getElements(newValue);
  return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;
}
function fixBracketsInLine(tokens, languageConfigurationService) {
  const denseKeyProvider = new DenseKeyProvider();
  const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));
  const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);
  const node = parseDocument(tokenizer, [], void 0, true);
  let str = "";
  const line = tokens.getLineContent();
  function processNode(node2, offset) {
    if (node2.kind === 2) {
      processNode(node2.openingBracket, offset);
      offset = lengthAdd(offset, node2.openingBracket.length);
      if (node2.child) {
        processNode(node2.child, offset);
        offset = lengthAdd(offset, node2.child.length);
      }
      if (node2.closingBracket) {
        processNode(node2.closingBracket, offset);
        offset = lengthAdd(offset, node2.closingBracket.length);
      } else {
        const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node2.openingBracket.languageId);
        const closingTokenText = singleLangBracketTokens.findClosingTokenText(node2.openingBracket.bracketIds);
        str += closingTokenText;
      }
    } else if (node2.kind === 3)
      ;
    else if (node2.kind === 0 || node2.kind === 1) {
      str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node2.length)));
    } else if (node2.kind === 4) {
      for (const child of node2.children) {
        processNode(child, offset);
        offset = lengthAdd(offset, child.length);
      }
    }
  }
  processNode(node, lengthZero);
  return str;
}
class StaticTokenizerSource {
  constructor(lines) {
    this.lines = lines;
    this.tokenization = {
      getLineTokens: (lineNumber) => {
        return this.lines[lineNumber - 1];
      }
    };
  }
  getValue() {
    return this.lines.map((l) => l.getLineContent()).join("\n");
  }
  getLineCount() {
    return this.lines.length;
  }
  getLineLength(lineNumber) {
    return this.lines[lineNumber - 1].getLineContent().length;
  }
}
var __awaiter$m = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {
  return __awaiter$m(this, void 0, void 0, function* () {
    const defaultReplaceRange = getDefaultRange(position, model);
    const providers = registry.all(model);
    const multiMap = new SetMap();
    for (const provider of providers) {
      if (provider.groupId) {
        multiMap.add(provider.groupId, provider);
      }
    }
    function getPreferredProviders(provider) {
      if (!provider.yieldsToGroupIds) {
        return [];
      }
      const result = [];
      for (const groupId of provider.yieldsToGroupIds || []) {
        const providers2 = multiMap.get(groupId);
        for (const p of providers2) {
          result.push(p);
        }
      }
      return result;
    }
    const states = /* @__PURE__ */ new Map();
    const seen = /* @__PURE__ */ new Set();
    function findPreferredProviderCircle(provider, stack) {
      stack = [...stack, provider];
      if (seen.has(provider)) {
        return stack;
      }
      seen.add(provider);
      try {
        const preferred = getPreferredProviders(provider);
        for (const p of preferred) {
          const c = findPreferredProviderCircle(p, stack);
          if (c) {
            return c;
          }
        }
      } finally {
        seen.delete(provider);
      }
      return void 0;
    }
    function processProvider(provider) {
      const state = states.get(provider);
      if (state) {
        return state;
      }
      const circle = findPreferredProviderCircle(provider, []);
      if (circle) {
        onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map((s) => s.toString ? s.toString() : "" + s).join(" -> ")}`));
      }
      const deferredPromise = new DeferredPromise();
      states.set(provider, deferredPromise.p);
      (() => __awaiter$m(this, void 0, void 0, function* () {
        if (!circle) {
          const preferred = getPreferredProviders(provider);
          for (const p of preferred) {
            const result = yield processProvider(p);
            if (result && result.items.length > 0) {
              return void 0;
            }
          }
        }
        try {
          const completions = yield provider.provideInlineCompletions(model, position, context, token);
          return completions;
        } catch (e) {
          onUnexpectedExternalError(e);
          return void 0;
        }
      }))().then((c) => deferredPromise.complete(c), (e) => deferredPromise.error(e));
      return deferredPromise.p;
    }
    const providerResults = yield Promise.all(providers.map((provider) => __awaiter$m(this, void 0, void 0, function* () {
      return { provider, completions: yield processProvider(provider) };
    })));
    const itemsByHash = /* @__PURE__ */ new Map();
    const lists = [];
    for (const result of providerResults) {
      const completions = result.completions;
      if (!completions) {
        continue;
      }
      const list = new InlineCompletionList(completions, result.provider);
      lists.push(list);
      for (const item of completions.items) {
        const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);
        itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);
      }
    }
    return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);
  });
}
class InlineCompletionProviderResult {
  constructor(completions, hashs, providerResults) {
    this.completions = completions;
    this.hashs = hashs;
    this.providerResults = providerResults;
  }
  has(item) {
    return this.hashs.has(item.hash());
  }
  dispose() {
    for (const result of this.providerResults) {
      result.removeRef();
    }
  }
}
class InlineCompletionList {
  constructor(inlineCompletions, provider) {
    this.inlineCompletions = inlineCompletions;
    this.provider = provider;
    this.refCount = 1;
  }
  addRef() {
    this.refCount++;
  }
  removeRef() {
    this.refCount--;
    if (this.refCount === 0) {
      this.provider.freeInlineCompletions(this.inlineCompletions);
    }
  }
}
class InlineCompletionItem {
  static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {
    let insertText;
    let snippetInfo;
    let range = inlineCompletion.range ? Range$1.lift(inlineCompletion.range) : defaultReplaceRange;
    if (typeof inlineCompletion.insertText === "string") {
      insertText = inlineCompletion.insertText;
      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {
        insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);
        const diff = insertText.length - inlineCompletion.insertText.length;
        if (diff !== 0) {
          range = new Range$1(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);
        }
      }
      snippetInfo = void 0;
    } else if ("snippet" in inlineCompletion.insertText) {
      const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;
      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {
        inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);
        const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;
        if (diff !== 0) {
          range = new Range$1(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);
        }
      }
      const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);
      if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {
        insertText = snippet.children[0].value;
        snippetInfo = void 0;
      } else {
        insertText = snippet.toString();
        snippetInfo = {
          snippet: inlineCompletion.insertText.snippet,
          range
        };
      }
    } else {
      assertNever(inlineCompletion.insertText);
    }
    return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);
  }
  constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits, sourceInlineCompletion, source) {
    this.filterText = filterText;
    this.command = command;
    this.range = range;
    this.insertText = insertText;
    this.snippetInfo = snippetInfo;
    this.additionalTextEdits = additionalTextEdits;
    this.sourceInlineCompletion = sourceInlineCompletion;
    this.source = source;
    filterText = filterText.replace(/\r\n|\r/g, "\n");
    insertText = filterText.replace(/\r\n|\r/g, "\n");
  }
  withRange(updatedRange) {
    return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);
  }
  hash() {
    return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });
  }
  toSingleTextEdit() {
    return new SingleTextEdit(this.range, this.insertText);
  }
}
function getDefaultRange(position, model) {
  const word = model.getWordAtPosition(position);
  const maxColumn = model.getLineMaxColumn(position.lineNumber);
  return word ? new Range$1(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range$1.fromPositions(position, position.with(void 0, maxColumn));
}
function closeBrackets(text, position, model, languageConfigurationService) {
  const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);
  const newLine = lineStart + text;
  const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);
  const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);
  if (!slicedTokens) {
    return text;
  }
  const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);
  return newText;
}
var __decorate$q = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$q = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$l = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let InlineCompletionsSource = class InlineCompletionsSource2 extends Disposable {
  constructor(textModel, versionId, _debounceValue, languageFeaturesService, languageConfigurationService) {
    super();
    this.textModel = textModel;
    this.versionId = versionId;
    this._debounceValue = _debounceValue;
    this.languageFeaturesService = languageFeaturesService;
    this.languageConfigurationService = languageConfigurationService;
    this._updateOperation = this._register(new MutableDisposable());
    this.inlineCompletions = disposableObservableValue("inlineCompletions", void 0);
    this.suggestWidgetInlineCompletions = disposableObservableValue("suggestWidgetInlineCompletions", void 0);
    this._register(this.textModel.onDidChangeContent(() => {
      this._updateOperation.clear();
    }));
  }
  fetch(position, context, activeInlineCompletion) {
    var _a3, _b3;
    const request = new UpdateRequest(position, context, this.textModel.getVersionId());
    const target = context.selectedSuggestionInfo ? this.suggestWidgetInlineCompletions : this.inlineCompletions;
    if ((_a3 = this._updateOperation.value) === null || _a3 === void 0 ? void 0 : _a3.request.satisfies(request)) {
      return this._updateOperation.value.promise;
    } else if ((_b3 = target.get()) === null || _b3 === void 0 ? void 0 : _b3.request.satisfies(request)) {
      return Promise.resolve(true);
    }
    const updateOngoing = !!this._updateOperation.value;
    this._updateOperation.clear();
    const source = new CancellationTokenSource();
    const promise = (() => __awaiter$l(this, void 0, void 0, function* () {
      const shouldDebounce = updateOngoing || context.triggerKind === InlineCompletionTriggerKind.Automatic;
      if (shouldDebounce) {
        yield wait(this._debounceValue.get(this.textModel));
      }
      if (source.token.isCancellationRequested || this.textModel.getVersionId() !== request.versionId) {
        return false;
      }
      const startTime = /* @__PURE__ */ new Date();
      const updatedCompletions = yield provideInlineCompletions(this.languageFeaturesService.inlineCompletionsProvider, position, this.textModel, context, source.token, this.languageConfigurationService);
      if (source.token.isCancellationRequested || this.textModel.getVersionId() !== request.versionId) {
        return false;
      }
      const endTime = /* @__PURE__ */ new Date();
      this._debounceValue.update(this.textModel, endTime.getTime() - startTime.getTime());
      const completions = new UpToDateInlineCompletions(updatedCompletions, request, this.textModel, this.versionId);
      if (activeInlineCompletion) {
        const asInlineCompletion = activeInlineCompletion.toInlineCompletion(void 0);
        if (activeInlineCompletion.canBeReused(this.textModel, position) && !updatedCompletions.has(asInlineCompletion)) {
          completions.prepend(activeInlineCompletion.inlineCompletion, asInlineCompletion.range, true);
        }
      }
      this._updateOperation.clear();
      transaction((tx) => {
        target.set(completions, tx);
      });
      return true;
    }))();
    const updateOperation = new UpdateOperation(request, source, promise);
    this._updateOperation.value = updateOperation;
    return promise;
  }
  clear(tx) {
    this._updateOperation.clear();
    this.inlineCompletions.set(void 0, tx);
    this.suggestWidgetInlineCompletions.set(void 0, tx);
  }
  clearSuggestWidgetInlineCompletions(tx) {
    var _a3;
    if ((_a3 = this._updateOperation.value) === null || _a3 === void 0 ? void 0 : _a3.request.context.selectedSuggestionInfo) {
      this._updateOperation.clear();
    }
    this.suggestWidgetInlineCompletions.set(void 0, tx);
  }
  cancelUpdate() {
    this._updateOperation.clear();
  }
};
InlineCompletionsSource = __decorate$q([
  __param$q(3, ILanguageFeaturesService),
  __param$q(4, ILanguageConfigurationService)
], InlineCompletionsSource);
function wait(ms, cancellationToken) {
  return new Promise((resolve) => {
    let d = void 0;
    const handle = setTimeout(() => {
      if (d) {
        d.dispose();
      }
      resolve();
    }, ms);
    if (cancellationToken) {
      d = cancellationToken.onCancellationRequested(() => {
        clearTimeout(handle);
        if (d) {
          d.dispose();
        }
        resolve();
      });
    }
  });
}
class UpdateRequest {
  constructor(position, context, versionId) {
    this.position = position;
    this.context = context;
    this.versionId = versionId;
  }
  satisfies(other) {
    return this.position.equals(other.position) && equals(this.context.selectedSuggestionInfo, other.context.selectedSuggestionInfo, (v1, v2) => v1.equals(v2)) && (other.context.triggerKind === InlineCompletionTriggerKind.Automatic || this.context.triggerKind === InlineCompletionTriggerKind.Explicit) && this.versionId === other.versionId;
  }
}
function equals(v1, v2, equals2) {
  if (!v1 || !v2) {
    return v1 === v2;
  }
  return equals2(v1, v2);
}
class UpdateOperation {
  constructor(request, cancellationTokenSource, promise) {
    this.request = request;
    this.cancellationTokenSource = cancellationTokenSource;
    this.promise = promise;
  }
  dispose() {
    this.cancellationTokenSource.cancel();
  }
}
class UpToDateInlineCompletions {
  get inlineCompletions() {
    return this._inlineCompletions;
  }
  constructor(inlineCompletionProviderResult, request, textModel, versionId) {
    this.inlineCompletionProviderResult = inlineCompletionProviderResult;
    this.request = request;
    this.textModel = textModel;
    this.versionId = versionId;
    this._refCount = 1;
    this._prependedInlineCompletionItems = [];
    this._rangeVersionIdValue = 0;
    this._rangeVersionId = derived("ranges", (reader) => {
      this.versionId.read(reader);
      let changed = false;
      for (const i of this._inlineCompletions) {
        changed = changed || i._updateRange(this.textModel);
      }
      if (changed) {
        this._rangeVersionIdValue++;
      }
      return this._rangeVersionIdValue;
    });
    const ids = textModel.deltaDecorations([], inlineCompletionProviderResult.completions.map((i) => ({
      range: i.range,
      options: {
        description: "inline-completion-tracking-range"
      }
    })));
    this._inlineCompletions = inlineCompletionProviderResult.completions.map((i, index2) => new InlineCompletionWithUpdatedRange(i, ids[index2], this._rangeVersionId));
  }
  clone() {
    this._refCount++;
    return this;
  }
  dispose() {
    this._refCount--;
    if (this._refCount === 0) {
      setTimeout(() => {
        if (!this.textModel.isDisposed()) {
          this.textModel.deltaDecorations(this._inlineCompletions.map((i) => i.decorationId), []);
        }
      }, 0);
      this.inlineCompletionProviderResult.dispose();
      for (const i of this._prependedInlineCompletionItems) {
        i.source.removeRef();
      }
    }
  }
  prepend(inlineCompletion, range, addRefToSource) {
    if (addRefToSource) {
      inlineCompletion.source.addRef();
    }
    const id = this.textModel.deltaDecorations([], [{
      range,
      options: {
        description: "inline-completion-tracking-range"
      }
    }])[0];
    this._inlineCompletions.unshift(new InlineCompletionWithUpdatedRange(inlineCompletion, id, this._rangeVersionId, range));
    this._prependedInlineCompletionItems.push(inlineCompletion);
  }
}
class InlineCompletionWithUpdatedRange {
  get forwardStable() {
    var _a3;
    return (_a3 = this.inlineCompletion.source.inlineCompletions.enableForwardStability) !== null && _a3 !== void 0 ? _a3 : false;
  }
  constructor(inlineCompletion, decorationId, rangeVersion, initialRange) {
    this.inlineCompletion = inlineCompletion;
    this.decorationId = decorationId;
    this.rangeVersion = rangeVersion;
    this.semanticId = JSON.stringify([
      this.inlineCompletion.filterText,
      this.inlineCompletion.insertText,
      this.inlineCompletion.range.getStartPosition().toString()
    ]);
    this._isValid = true;
    this._updatedRange = initialRange !== null && initialRange !== void 0 ? initialRange : inlineCompletion.range;
  }
  toInlineCompletion(reader) {
    return this.inlineCompletion.withRange(this._getUpdatedRange(reader));
  }
  toSingleTextEdit(reader) {
    return new SingleTextEdit(this._getUpdatedRange(reader), this.inlineCompletion.insertText);
  }
  isVisible(model, cursorPosition, reader) {
    const minimizedReplacement = this._toFilterTextReplacement(reader).removeCommonPrefix(model);
    if (!this._isValid || !this.inlineCompletion.range.getStartPosition().equals(this._getUpdatedRange(reader).getStartPosition()) || cursorPosition.lineNumber !== minimizedReplacement.range.startLineNumber) {
      return false;
    }
    const originalValue = model.getValueInRange(
      minimizedReplacement.range,
      1
      /* EndOfLinePreference.LF */
    ).toLowerCase();
    const filterText = minimizedReplacement.text.toLowerCase();
    const cursorPosIndex = Math.max(0, cursorPosition.column - minimizedReplacement.range.startColumn);
    let filterTextBefore = filterText.substring(0, cursorPosIndex);
    let filterTextAfter = filterText.substring(cursorPosIndex);
    let originalValueBefore = originalValue.substring(0, cursorPosIndex);
    let originalValueAfter = originalValue.substring(cursorPosIndex);
    const originalValueIndent = model.getLineIndentColumn(minimizedReplacement.range.startLineNumber);
    if (minimizedReplacement.range.startColumn <= originalValueIndent) {
      originalValueBefore = originalValueBefore.trimStart();
      if (originalValueBefore.length === 0) {
        originalValueAfter = originalValueAfter.trimStart();
      }
      filterTextBefore = filterTextBefore.trimStart();
      if (filterTextBefore.length === 0) {
        filterTextAfter = filterTextAfter.trimStart();
      }
    }
    return filterTextBefore.startsWith(originalValueBefore) && !!matchesSubString(originalValueAfter, filterTextAfter);
  }
  canBeReused(model, position) {
    const result = this._isValid && this._getUpdatedRange(void 0).containsPosition(position) && this.isVisible(model, position, void 0) && !this._isSmallerThanOriginal(void 0);
    return result;
  }
  _toFilterTextReplacement(reader) {
    return new SingleTextEdit(this._getUpdatedRange(reader), this.inlineCompletion.filterText);
  }
  _isSmallerThanOriginal(reader) {
    return length(this._getUpdatedRange(reader)).isBefore(length(this.inlineCompletion.range));
  }
  _getUpdatedRange(reader) {
    this.rangeVersion.read(reader);
    return this._updatedRange;
  }
  _updateRange(textModel) {
    const range = textModel.getDecorationRange(this.decorationId);
    if (!range) {
      this._isValid = false;
      return true;
    }
    if (!this._updatedRange.equalsRange(range)) {
      this._updatedRange = range;
      return true;
    }
    return false;
  }
}
function length(range) {
  if (range.startLineNumber === range.endLineNumber) {
    return new Position$1(1, 1 + range.endColumn - range.startColumn);
  } else {
    return new Position$1(1 + range.endLineNumber - range.startLineNumber, range.endColumn);
  }
}
var __decorate$p = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$p = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$k = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var VersionIdChangeReason;
(function(VersionIdChangeReason2) {
  VersionIdChangeReason2[VersionIdChangeReason2["Undo"] = 0] = "Undo";
  VersionIdChangeReason2[VersionIdChangeReason2["Redo"] = 1] = "Redo";
  VersionIdChangeReason2[VersionIdChangeReason2["AcceptWord"] = 2] = "AcceptWord";
  VersionIdChangeReason2[VersionIdChangeReason2["Other"] = 3] = "Other";
})(VersionIdChangeReason || (VersionIdChangeReason = {}));
let InlineCompletionsModel = class InlineCompletionsModel2 extends Disposable {
  get isAcceptingPartially() {
    return this._isAcceptingPartially;
  }
  constructor(textModel, selectedSuggestItem, cursorPosition, textModelVersionId, _debounceValue, _suggestPreviewEnabled, _suggestPreviewMode, _inlineSuggestMode, _enabled, _instantiationService, _commandService, _languageConfigurationService) {
    super();
    this.textModel = textModel;
    this.selectedSuggestItem = selectedSuggestItem;
    this.cursorPosition = cursorPosition;
    this.textModelVersionId = textModelVersionId;
    this._debounceValue = _debounceValue;
    this._suggestPreviewEnabled = _suggestPreviewEnabled;
    this._suggestPreviewMode = _suggestPreviewMode;
    this._inlineSuggestMode = _inlineSuggestMode;
    this._enabled = _enabled;
    this._instantiationService = _instantiationService;
    this._commandService = _commandService;
    this._languageConfigurationService = _languageConfigurationService;
    this._source = this._register(this._instantiationService.createInstance(InlineCompletionsSource, this.textModel, this.textModelVersionId, this._debounceValue));
    this._isActive = observableValue("isActive", false);
    this._forceUpdate = observableSignal("forceUpdate");
    this._selectedInlineCompletionId = observableValue("selectedInlineCompletionId", void 0);
    this._isAcceptingPartially = false;
    this._preserveCurrentCompletionReasons = /* @__PURE__ */ new Set([
      VersionIdChangeReason.Redo,
      VersionIdChangeReason.Undo,
      VersionIdChangeReason.AcceptWord
    ]);
    this._fetchInlineCompletions = derivedHandleChanges("fetch inline completions", {
      createEmptyChangeSummary: () => ({
        preserveCurrentCompletion: false,
        inlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic
      }),
      handleChange: (ctx, changeSummary) => {
        if (ctx.didChange(this.textModelVersionId) && this._preserveCurrentCompletionReasons.has(ctx.change)) {
          changeSummary.preserveCurrentCompletion = true;
        } else if (ctx.didChange(this._forceUpdate)) {
          changeSummary.inlineCompletionTriggerKind = ctx.change;
        }
        return true;
      }
    }, (reader, changeSummary) => {
      this._forceUpdate.read(reader);
      const shouldUpdate = this._enabled.read(reader) && this.selectedSuggestItem.read(reader) || this._isActive.read(reader);
      if (!shouldUpdate) {
        this._source.cancelUpdate();
        return void 0;
      }
      this.textModelVersionId.read(reader);
      const itemToPreserveCandidate = this.selectedInlineCompletion.get();
      const itemToPreserve = changeSummary.preserveCurrentCompletion || (itemToPreserveCandidate === null || itemToPreserveCandidate === void 0 ? void 0 : itemToPreserveCandidate.forwardStable) ? itemToPreserveCandidate : void 0;
      const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.get();
      const suggestItem = this.selectedSuggestItem.read(reader);
      if (suggestWidgetInlineCompletions && !suggestItem) {
        const inlineCompletions = this._source.inlineCompletions.get();
        transaction((tx) => {
          if (inlineCompletions && suggestWidgetInlineCompletions.request.versionId > inlineCompletions.request.versionId) {
            this._source.inlineCompletions.set(suggestWidgetInlineCompletions.clone(), tx);
          }
          this._source.clearSuggestWidgetInlineCompletions(tx);
        });
      }
      const cursorPosition2 = this.cursorPosition.read(reader);
      const context = {
        triggerKind: changeSummary.inlineCompletionTriggerKind,
        selectedSuggestionInfo: suggestItem === null || suggestItem === void 0 ? void 0 : suggestItem.toSelectedSuggestionInfo()
      };
      return this._source.fetch(cursorPosition2, context, itemToPreserve);
    });
    this._filteredInlineCompletionItems = derived("filteredInlineCompletionItems", (reader) => {
      const c = this._source.inlineCompletions.read(reader);
      if (!c) {
        return [];
      }
      const cursorPosition2 = this.cursorPosition.read(reader);
      const filteredCompletions = c.inlineCompletions.filter((c2) => c2.isVisible(this.textModel, cursorPosition2, reader));
      return filteredCompletions;
    });
    this.selectedInlineCompletionIndex = derived("selectedCachedCompletionIndex", (reader) => {
      const selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);
      const filteredCompletions = this._filteredInlineCompletionItems.read(reader);
      const idx = this._selectedInlineCompletionId === void 0 ? -1 : filteredCompletions.findIndex((v) => v.semanticId === selectedInlineCompletionId);
      if (idx === -1) {
        this._selectedInlineCompletionId.set(void 0, void 0);
        return 0;
      }
      return idx;
    });
    this.selectedInlineCompletion = derived("selectedCachedCompletion", (reader) => {
      const filteredCompletions = this._filteredInlineCompletionItems.read(reader);
      const idx = this.selectedInlineCompletionIndex.read(reader);
      return filteredCompletions[idx];
    });
    this.lastTriggerKind = this._source.inlineCompletions.map((v) => (
      /** @description lastTriggerKind */
      v === null || v === void 0 ? void 0 : v.request.context.triggerKind
    ));
    this.inlineCompletionsCount = derived("selectedInlineCompletionsCount", (reader) => {
      if (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {
        return this._filteredInlineCompletionItems.read(reader).length;
      } else {
        return void 0;
      }
    });
    this.state = derived("ghostTextAndCompletion", (reader) => {
      var _a3;
      const model = this.textModel;
      const suggestItem = this.selectedSuggestItem.read(reader);
      if (suggestItem) {
        const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(reader);
        const candidateInlineCompletions = suggestWidgetInlineCompletions ? suggestWidgetInlineCompletions.inlineCompletions : [this.selectedInlineCompletion.read(reader)].filter(isDefined);
        const suggestCompletion = suggestItem.toSingleTextEdit().removeCommonPrefix(model);
        const augmentedCompletion = mapFind(candidateInlineCompletions, (completion2) => {
          let r = completion2.toSingleTextEdit(reader);
          r = r.removeCommonPrefix(model, Range$1.fromPositions(r.range.getStartPosition(), suggestItem.range.getEndPosition()));
          return r.augments(suggestCompletion) ? { edit: r, completion: completion2 } : void 0;
        });
        const isSuggestionPreviewEnabled = this._suggestPreviewEnabled.read(reader);
        if (!isSuggestionPreviewEnabled && !augmentedCompletion) {
          return void 0;
        }
        const edit = (_a3 = augmentedCompletion === null || augmentedCompletion === void 0 ? void 0 : augmentedCompletion.edit) !== null && _a3 !== void 0 ? _a3 : suggestCompletion;
        const editPreviewLength = augmentedCompletion ? augmentedCompletion.edit.text.length - suggestCompletion.text.length : 0;
        const mode = this._suggestPreviewMode.read(reader);
        const cursor = this.cursorPosition.read(reader);
        const newGhostText = edit.computeGhostText(model, mode, cursor, editPreviewLength);
        const ghostText2 = newGhostText !== null && newGhostText !== void 0 ? newGhostText : new GhostText(edit.range.endLineNumber, []);
        return { ghostText: ghostText2, inlineCompletion: augmentedCompletion === null || augmentedCompletion === void 0 ? void 0 : augmentedCompletion.completion, suggestItem };
      } else {
        if (!this._isActive.read(reader)) {
          return void 0;
        }
        const item = this.selectedInlineCompletion.read(reader);
        if (!item) {
          return void 0;
        }
        const replacement = item.toSingleTextEdit(reader);
        const mode = this._inlineSuggestMode.read(reader);
        const cursor = this.cursorPosition.read(reader);
        const ghostText2 = replacement.computeGhostText(model, mode, cursor);
        return ghostText2 ? { ghostText: ghostText2, inlineCompletion: item, suggestItem: void 0 } : void 0;
      }
    });
    this.ghostText = derived("ghostText", (reader) => {
      const v = this.state.read(reader);
      if (!v) {
        return void 0;
      }
      return v.ghostText;
    });
    this._register(keepAlive(this._fetchInlineCompletions, true));
    let lastItem = void 0;
    this._register(autorun("call handleItemDidShow", (reader) => {
      var _a3, _b3;
      const item = this.state.read(reader);
      const completion2 = item === null || item === void 0 ? void 0 : item.inlineCompletion;
      if ((completion2 === null || completion2 === void 0 ? void 0 : completion2.semanticId) !== (lastItem === null || lastItem === void 0 ? void 0 : lastItem.semanticId)) {
        lastItem = completion2;
        if (completion2) {
          const i = completion2.inlineCompletion;
          const src = i.source;
          (_b3 = (_a3 = src.provider).handleItemDidShow) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, src.inlineCompletions, i.sourceInlineCompletion, i.insertText);
        }
      }
    }));
  }
  trigger(tx) {
    return __awaiter$k(this, void 0, void 0, function* () {
      this._isActive.set(true, tx);
      yield this._fetchInlineCompletions.get();
    });
  }
  triggerExplicitly(tx) {
    return __awaiter$k(this, void 0, void 0, function* () {
      subtransaction(tx, (tx2) => {
        this._isActive.set(true, tx2);
        this._forceUpdate.trigger(tx2, InlineCompletionTriggerKind.Explicit);
      });
      yield this._fetchInlineCompletions.get();
    });
  }
  stop(tx) {
    subtransaction(tx, (tx2) => {
      this._isActive.set(false, tx2);
      this._source.clear(tx2);
    });
  }
  _deltaSelectedInlineCompletionIndex(delta2) {
    return __awaiter$k(this, void 0, void 0, function* () {
      yield this.triggerExplicitly();
      const completions = this._filteredInlineCompletionItems.get() || [];
      if (completions.length > 0) {
        const newIdx = (this.selectedInlineCompletionIndex.get() + delta2 + completions.length) % completions.length;
        this._selectedInlineCompletionId.set(completions[newIdx].semanticId, void 0);
      } else {
        this._selectedInlineCompletionId.set(void 0, void 0);
      }
    });
  }
  next() {
    return __awaiter$k(this, void 0, void 0, function* () {
      yield this._deltaSelectedInlineCompletionIndex(1);
    });
  }
  previous() {
    return __awaiter$k(this, void 0, void 0, function* () {
      yield this._deltaSelectedInlineCompletionIndex(-1);
    });
  }
  accept(editor2) {
    var _a3;
    return __awaiter$k(this, void 0, void 0, function* () {
      if (editor2.getModel() !== this.textModel) {
        throw new BugIndicatingError();
      }
      const state = this.state.get();
      if (!state || state.ghostText.isEmpty() || !state.inlineCompletion) {
        return;
      }
      const completion2 = state.inlineCompletion.toInlineCompletion(void 0);
      editor2.pushUndoStop();
      if (completion2.snippetInfo) {
        editor2.executeEdits("inlineSuggestion.accept", [
          EditOperation.replaceMove(completion2.range, ""),
          ...completion2.additionalTextEdits
        ]);
        editor2.setPosition(completion2.snippetInfo.range.getStartPosition());
        (_a3 = SnippetController2.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.insert(completion2.snippetInfo.snippet, { undoStopBefore: false });
      } else {
        editor2.executeEdits("inlineSuggestion.accept", [
          EditOperation.replaceMove(completion2.range, completion2.insertText),
          ...completion2.additionalTextEdits
        ]);
      }
      if (completion2.command) {
        completion2.source.addRef();
      }
      transaction((tx) => {
        this._source.clear(tx);
        this._isActive.set(false, tx);
      });
      if (completion2.command) {
        yield this._commandService.executeCommand(completion2.command.id, ...completion2.command.arguments || []).then(void 0, onUnexpectedExternalError);
        completion2.source.removeRef();
      }
    });
  }
  acceptNextWord(editor2) {
    return __awaiter$k(this, void 0, void 0, function* () {
      yield this._acceptNext(editor2, (pos, text) => {
        const langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);
        const config = this._languageConfigurationService.getLanguageConfiguration(langId);
        const wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace("g", ""));
        const m1 = text.match(wordRegExp);
        let acceptUntilIndexExclusive = 0;
        if (m1 && m1.index !== void 0) {
          if (m1.index === 0) {
            acceptUntilIndexExclusive = m1[0].length;
          } else {
            acceptUntilIndexExclusive = m1.index;
          }
        } else {
          acceptUntilIndexExclusive = text.length;
        }
        const wsRegExp = /\s+/g;
        const m2 = wsRegExp.exec(text);
        if (m2 && m2.index !== void 0) {
          if (m2.index + m2[0].length < acceptUntilIndexExclusive) {
            acceptUntilIndexExclusive = m2.index + m2[0].length;
          }
        }
        return acceptUntilIndexExclusive;
      });
    });
  }
  acceptNextLine(editor2) {
    return __awaiter$k(this, void 0, void 0, function* () {
      yield this._acceptNext(editor2, (pos, text) => {
        const m = text.match(/\n/);
        if (m && m.index !== void 0) {
          return m.index + 1;
        }
        return text.length;
      });
    });
  }
  _acceptNext(editor2, getAcceptUntilIndex) {
    return __awaiter$k(this, void 0, void 0, function* () {
      if (editor2.getModel() !== this.textModel) {
        throw new BugIndicatingError();
      }
      const state = this.state.get();
      if (!state || state.ghostText.isEmpty() || !state.inlineCompletion) {
        return;
      }
      const ghostText2 = state.ghostText;
      const completion2 = state.inlineCompletion.toInlineCompletion(void 0);
      if (completion2.snippetInfo || completion2.filterText !== completion2.insertText) {
        yield this.accept(editor2);
        return;
      }
      const firstPart = ghostText2.parts[0];
      const position = new Position$1(ghostText2.lineNumber, firstPart.column);
      const line = firstPart.lines.join("\n");
      const acceptUntilIndexExclusive = getAcceptUntilIndex(position, line);
      if (acceptUntilIndexExclusive === line.length && ghostText2.parts.length === 1) {
        this.accept(editor2);
        return;
      }
      const partialText = line.substring(0, acceptUntilIndexExclusive);
      this._isAcceptingPartially = true;
      try {
        editor2.pushUndoStop();
        editor2.executeEdits("inlineSuggestion.accept", [
          EditOperation.replace(Range$1.fromPositions(position), partialText)
        ]);
        const length2 = lengthOfText(partialText);
        editor2.setPosition(addPositions(position, length2));
      } finally {
        this._isAcceptingPartially = false;
      }
      if (completion2.source.provider.handlePartialAccept) {
        const acceptedRange = Range$1.fromPositions(completion2.range.getStartPosition(), addPositions(position, lengthOfText(partialText)));
        const text = editor2.getModel().getValueInRange(
          acceptedRange,
          1
          /* EndOfLinePreference.LF */
        );
        completion2.source.provider.handlePartialAccept(completion2.source.inlineCompletions, completion2.sourceInlineCompletion, text.length);
      }
    });
  }
};
InlineCompletionsModel = __decorate$p([
  __param$p(9, IInstantiationService),
  __param$p(10, ICommandService),
  __param$p(11, ILanguageConfigurationService)
], InlineCompletionsModel);
class SuggestWidgetAdaptor extends Disposable {
  get selectedItem() {
    return this._selectedItem;
  }
  constructor(editor2, suggestControllerPreselector, checkModelVersion) {
    super();
    this.editor = editor2;
    this.suggestControllerPreselector = suggestControllerPreselector;
    this.checkModelVersion = checkModelVersion;
    this.isSuggestWidgetVisible = false;
    this.isShiftKeyPressed = false;
    this._isActive = false;
    this._currentSuggestItemInfo = void 0;
    this._selectedItem = observableValue("suggestWidgetInlineCompletionProvider.selectedItem", void 0);
    this._register(editor2.onKeyDown((e) => {
      if (e.shiftKey && !this.isShiftKeyPressed) {
        this.isShiftKeyPressed = true;
        this.update(this._isActive);
      }
    }));
    this._register(editor2.onKeyUp((e) => {
      if (e.shiftKey && this.isShiftKeyPressed) {
        this.isShiftKeyPressed = false;
        this.update(this._isActive);
      }
    }));
    const suggestController = SuggestController.get(this.editor);
    if (suggestController) {
      this._register(suggestController.registerSelector({
        priority: 100,
        select: (model, pos, suggestItems) => {
          var _a3;
          transaction((tx) => this.checkModelVersion(tx));
          const textModel = this.editor.getModel();
          if (!textModel) {
            return -1;
          }
          const itemToPreselect = (_a3 = this.suggestControllerPreselector()) === null || _a3 === void 0 ? void 0 : _a3.removeCommonPrefix(textModel);
          if (!itemToPreselect) {
            return -1;
          }
          const position = Position$1.lift(pos);
          const candidates = suggestItems.map((suggestItem, index2) => {
            const suggestItemInfo = SuggestItemInfo.fromSuggestion(suggestController, textModel, position, suggestItem, this.isShiftKeyPressed);
            const suggestItemTextEdit = suggestItemInfo.toSingleTextEdit().removeCommonPrefix(textModel);
            const valid = itemToPreselect.augments(suggestItemTextEdit);
            return { index: index2, valid, prefixLength: suggestItemTextEdit.text.length, suggestItem };
          }).filter((item) => item && item.valid && item.prefixLength > 0);
          const result = findMaxBy(candidates, compareBy((s) => s.prefixLength, numberComparator));
          return result ? result.index : -1;
        }
      }));
      let isBoundToSuggestWidget = false;
      const bindToSuggestWidget = () => {
        if (isBoundToSuggestWidget) {
          return;
        }
        isBoundToSuggestWidget = true;
        this._register(suggestController.widget.value.onDidShow(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
        this._register(suggestController.widget.value.onDidHide(() => {
          this.isSuggestWidgetVisible = false;
          this.update(false);
        }));
        this._register(suggestController.widget.value.onDidFocus(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
      };
      this._register(Event.once(suggestController.model.onDidTrigger)((e) => {
        bindToSuggestWidget();
      }));
    }
    this.update(this._isActive);
  }
  update(newActive) {
    const newInlineCompletion = this.getSuggestItemInfo();
    if (this._isActive !== newActive || !suggestItemInfoEquals(this._currentSuggestItemInfo, newInlineCompletion)) {
      this._isActive = newActive;
      this._currentSuggestItemInfo = newInlineCompletion;
      transaction((tx) => {
        this.checkModelVersion(tx);
        this._selectedItem.set(this._isActive ? this._currentSuggestItemInfo : void 0, tx);
      });
    }
  }
  getSuggestItemInfo() {
    const suggestController = SuggestController.get(this.editor);
    if (!suggestController || !this.isSuggestWidgetVisible) {
      return void 0;
    }
    const focusedItem = suggestController.widget.value.getFocusedItem();
    const position = this.editor.getPosition();
    const model = this.editor.getModel();
    if (!focusedItem || !position || !model) {
      return void 0;
    }
    return SuggestItemInfo.fromSuggestion(suggestController, model, position, focusedItem.item, this.isShiftKeyPressed);
  }
  stopForceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController === null || suggestController === void 0 ? void 0 : suggestController.stopForceRenderingAbove();
  }
  forceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController === null || suggestController === void 0 ? void 0 : suggestController.forceRenderingAbove();
  }
}
class SuggestItemInfo {
  static fromSuggestion(suggestController, model, position, item, toggleMode) {
    let { insertText } = item.completion;
    let isSnippetText = false;
    if (item.completion.insertTextRules & 4) {
      const snippet = new SnippetParser().parse(insertText);
      if (snippet.children.length < 100) {
        SnippetSession.adjustWhitespace(model, position, true, snippet);
      }
      insertText = snippet.toString();
      isSnippetText = true;
    }
    const info = suggestController.getOverwriteInfo(item, toggleMode);
    return new SuggestItemInfo(Range$1.fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0))), insertText, item.completion.kind, isSnippetText);
  }
  constructor(range, insertText, completionItemKind, isSnippetText) {
    this.range = range;
    this.insertText = insertText;
    this.completionItemKind = completionItemKind;
    this.isSnippetText = isSnippetText;
  }
  equals(other) {
    return this.range.equalsRange(other.range) && this.insertText === other.insertText && this.completionItemKind === other.completionItemKind && this.isSnippetText === other.isSnippetText;
  }
  toSelectedSuggestionInfo() {
    return new SelectedSuggestionInfo(this.range, this.insertText, this.completionItemKind, this.isSnippetText);
  }
  toSingleTextEdit() {
    return new SingleTextEdit(this.range, this.insertText);
  }
}
function suggestItemInfoEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.equals(b);
}
var __decorate$o = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$o = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let InlineCompletionsController = class InlineCompletionsController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(InlineCompletionsController2.ID);
  }
  constructor(editor2, instantiationService, contextKeyService, configurationService, commandService, debounceService, languageFeaturesService, audioCueService) {
    super();
    this.editor = editor2;
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.configurationService = configurationService;
    this.commandService = commandService;
    this.debounceService = debounceService;
    this.languageFeaturesService = languageFeaturesService;
    this.audioCueService = audioCueService;
    this.model = disposableObservableValue("inlineCompletionModel", void 0);
    this.textModelVersionId = observableValue("textModelVersionId", -1);
    this.cursorPosition = observableValue("cursorPosition", new Position$1(1, 1));
    this.suggestWidgetAdaptor = this._register(new SuggestWidgetAdaptor(this.editor, () => {
      var _a3, _b3;
      return (_b3 = (_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.selectedInlineCompletion.get()) === null || _b3 === void 0 ? void 0 : _b3.toSingleTextEdit(void 0);
    }, (tx) => this.updateObservables(tx, VersionIdChangeReason.Other)));
    this._enabled = observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      61
      /* EditorOption.inlineSuggest */
    ).enabled);
    this.ghostTextWidget = this._register(this.instantiationService.createInstance(GhostTextWidget, this.editor, {
      ghostText: this.model.map((v, reader) => v === null || v === void 0 ? void 0 : v.ghostText.read(reader)),
      minReservedLineCount: constObservable(0),
      targetTextModel: this.model.map((v) => v === null || v === void 0 ? void 0 : v.textModel)
    }));
    this._debounceValue = this.debounceService.for(this.languageFeaturesService.inlineCompletionsProvider, "InlineCompletionsDebounce", { min: 50, max: 50 });
    this._register(new InlineCompletionContextKeys(this.contextKeyService, this.model));
    this._register(Event.runAndSubscribe(editor2.onDidChangeModel, () => transaction((tx) => {
      this.model.set(void 0, tx);
      this.updateObservables(tx, VersionIdChangeReason.Other);
      const textModel = editor2.getModel();
      if (textModel) {
        const model = instantiationService.createInstance(InlineCompletionsModel, textModel, this.suggestWidgetAdaptor.selectedItem, this.cursorPosition, this.textModelVersionId, this._debounceValue, observableFromEvent(editor2.onDidChangeConfiguration, () => editor2.getOption(
          116
          /* EditorOption.suggest */
        ).preview), observableFromEvent(editor2.onDidChangeConfiguration, () => editor2.getOption(
          116
          /* EditorOption.suggest */
        ).previewMode), observableFromEvent(editor2.onDidChangeConfiguration, () => editor2.getOption(
          61
          /* EditorOption.inlineSuggest */
        ).mode), this._enabled);
        this.model.set(model, tx);
      }
    })));
    const getReason = (e) => {
      var _a3;
      if (e.isUndoing) {
        return VersionIdChangeReason.Undo;
      }
      if (e.isRedoing) {
        return VersionIdChangeReason.Redo;
      }
      if ((_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.isAcceptingPartially) {
        return VersionIdChangeReason.AcceptWord;
      }
      return VersionIdChangeReason.Other;
    };
    this._register(editor2.onDidChangeModelContent((e) => transaction((tx) => (
      /** @description onDidChangeModelContent */
      this.updateObservables(tx, getReason(e))
    ))));
    this._register(editor2.onDidChangeCursorPosition((e) => transaction((tx) => {
      var _a3;
      this.updateObservables(tx, VersionIdChangeReason.Other);
      if (e.reason === 3) {
        (_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.stop(tx);
      }
    })));
    this._register(editor2.onDidType(() => transaction((tx) => {
      var _a3;
      this.updateObservables(tx, VersionIdChangeReason.Other);
      if (this._enabled.get()) {
        (_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.trigger(tx);
      }
    })));
    this._register(this.commandService.onDidExecuteCommand((e) => {
      const commands2 = /* @__PURE__ */ new Set([
        CoreEditingCommands.Tab.id,
        CoreEditingCommands.DeleteLeft.id,
        CoreEditingCommands.DeleteRight.id,
        inlineSuggestCommitId,
        "acceptSelectedSuggestion"
      ]);
      if (commands2.has(e.commandId) && editor2.hasTextFocus() && this._enabled.get()) {
        transaction((tx) => {
          var _a3;
          (_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.trigger(tx);
        });
      }
    }));
    this._register(this.editor.onDidBlurEditorWidget(() => {
      if (this.configurationService.getValue("editor.inlineSuggest.keepOnBlur") || editor2.getOption(
        61
        /* EditorOption.inlineSuggest */
      ).keepOnBlur) {
        return;
      }
      if (InlineSuggestionHintsContentWidget.dropDownVisible) {
        return;
      }
      transaction((tx) => {
        var _a3;
        (_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.stop(tx);
      });
    }));
    this._register(autorun("forceRenderingAbove", (reader) => {
      var _a3;
      const state = (_a3 = this.model.read(reader)) === null || _a3 === void 0 ? void 0 : _a3.state.read(reader);
      if (state === null || state === void 0 ? void 0 : state.suggestItem) {
        if (state.ghostText.lineCount >= 2) {
          this.suggestWidgetAdaptor.forceRenderingAbove();
        }
      } else {
        this.suggestWidgetAdaptor.stopForceRenderingAbove();
      }
    }));
    this._register(toDisposable(() => {
      this.suggestWidgetAdaptor.stopForceRenderingAbove();
    }));
    let lastInlineCompletionId = void 0;
    this._register(autorun("play audio cue & read suggestion", (reader) => {
      const model = this.model.read(reader);
      const state = model === null || model === void 0 ? void 0 : model.state.read(reader);
      if (!model || !state || !state.inlineCompletion) {
        lastInlineCompletionId = void 0;
        return;
      }
      if (state.inlineCompletion.semanticId !== lastInlineCompletionId) {
        lastInlineCompletionId = state.inlineCompletion.semanticId;
        const lineText = model.textModel.getLineContent(state.ghostText.lineNumber);
        this.audioCueService.playAudioCue(AudioCue.inlineSuggestion).then(() => {
          if (this.editor.getOption(
            7
            /* EditorOption.screenReaderAnnounceInlineSuggestion */
          )) {
            alert(state.ghostText.renderForScreenReader(lineText));
          }
        });
      }
    }));
    this._register(new InlineCompletionsHintsWidget(this.editor, this.model, this.instantiationService));
  }
  /**
   * Copies over the relevant state from the text model to observables.
   * This solves all kind of eventing issues, as we make sure we always operate on the latest state,
   * regardless of who calls into us.
   */
  updateObservables(tx, changeReason) {
    var _a3, _b3;
    const newModel = this.editor.getModel();
    this.textModelVersionId.set((_a3 = newModel === null || newModel === void 0 ? void 0 : newModel.getVersionId()) !== null && _a3 !== void 0 ? _a3 : -1, tx, changeReason);
    this.cursorPosition.set((_b3 = this.editor.getPosition()) !== null && _b3 !== void 0 ? _b3 : new Position$1(1, 1), tx);
  }
  shouldShowHoverAt(range) {
    var _a3;
    const ghostText2 = (_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.ghostText.get();
    if (ghostText2) {
      return ghostText2.parts.some((p) => range.containsPosition(new Position$1(ghostText2.lineNumber, p.column)));
    }
    return false;
  }
  shouldShowHoverAtViewZone(viewZoneId) {
    return this.ghostTextWidget.ownsViewZone(viewZoneId);
  }
  hide() {
    transaction((tx) => {
      var _a3;
      (_a3 = this.model.get()) === null || _a3 === void 0 ? void 0 : _a3.stop(tx);
    });
  }
};
InlineCompletionsController.ID = "editor.contrib.inlineCompletionsController";
InlineCompletionsController = __decorate$o([
  __param$o(1, IInstantiationService),
  __param$o(2, IContextKeyService),
  __param$o(3, IConfigurationService),
  __param$o(4, ICommandService),
  __param$o(5, ILanguageFeatureDebounceService),
  __param$o(6, ILanguageFeaturesService),
  __param$o(7, IAudioCueService)
], InlineCompletionsController);
var __awaiter$j = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ShowNextInlineSuggestionAction extends EditorAction {
  constructor() {
    super({
      id: ShowNextInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
      alias: "Show Next Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 94
      }
    });
  }
  run(accessor, editor2) {
    var _a3;
    return __awaiter$j(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      (_a3 = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a3 === void 0 ? void 0 : _a3.next();
    });
  }
}
ShowNextInlineSuggestionAction.ID = showNextInlineSuggestionActionId;
class ShowPreviousInlineSuggestionAction extends EditorAction {
  constructor() {
    super({
      id: ShowPreviousInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
      alias: "Show Previous Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 92
      }
    });
  }
  run(accessor, editor2) {
    var _a3;
    return __awaiter$j(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      (_a3 = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a3 === void 0 ? void 0 : _a3.previous();
    });
  }
}
ShowPreviousInlineSuggestionAction.ID = showPreviousInlineSuggestionActionId;
class TriggerInlineSuggestionAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.trigger",
      label: localize("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
      alias: "Trigger Inline Suggestion",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    var _a3;
    return __awaiter$j(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      (_a3 = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a3 === void 0 ? void 0 : _a3.triggerExplicitly();
    });
  }
}
class AcceptNextWordOfInlineCompletion extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextWord",
      label: localize("action.inlineSuggest.acceptNextWord", "Accept Next Word Of Inline Suggestion"),
      alias: "Accept Next Word Of Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100 + 1,
        primary: 2048 | 17,
        kbExpr: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible)
      },
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize("acceptWord", "Accept Word"),
        group: "primary",
        order: 2
      }]
    });
  }
  run(accessor, editor2) {
    var _a3;
    return __awaiter$j(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      yield (_a3 = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a3 === void 0 ? void 0 : _a3.acceptNextWord(controller.editor);
    });
  }
}
class AcceptNextLineOfInlineCompletion extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextLine",
      label: localize("action.inlineSuggest.acceptNextLine", "Accept Next Line Of Inline Suggestion"),
      alias: "Accept Next Line Of Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100 + 1
      },
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize("acceptLine", "Accept Line"),
        group: "secondary",
        order: 2
      }]
    });
  }
  run(accessor, editor2) {
    var _a3;
    return __awaiter$j(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      yield (_a3 = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a3 === void 0 ? void 0 : _a3.acceptNextLine(controller.editor);
    });
  }
}
class AcceptInlineCompletion extends EditorAction {
  constructor() {
    super({
      id: inlineSuggestCommitId,
      label: localize("action.inlineSuggest.accept", "Accept Inline Suggestion"),
      alias: "Accept Inline Suggestion",
      precondition: InlineCompletionContextKeys.inlineSuggestionVisible,
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize("accept", "Accept"),
        group: "primary",
        order: 1
      }],
      kbOpts: {
        primary: 2,
        weight: 200,
        kbExpr: ContextKeyExpr.and(InlineCompletionContextKeys.inlineSuggestionVisible, EditorContextKeys.tabMovesFocus.toNegated(), InlineCompletionContextKeys.inlineSuggestionHasIndentationLessThanTabSize, Context$1.Visible.toNegated())
      }
    });
  }
  run(accessor, editor2) {
    var _a3;
    return __awaiter$j(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      if (controller) {
        (_a3 = controller.model.get()) === null || _a3 === void 0 ? void 0 : _a3.accept(controller.editor);
        controller.editor.focus();
      }
    });
  }
}
class HideInlineCompletion extends EditorAction {
  constructor() {
    super({
      id: HideInlineCompletion.ID,
      label: localize("action.inlineSuggest.hide", "Hide Inline Suggestion"),
      alias: "Hide Inline Suggestion",
      precondition: InlineCompletionContextKeys.inlineSuggestionVisible,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter$j(this, void 0, void 0, function* () {
      const controller = InlineCompletionsController.get(editor2);
      transaction((tx) => {
        var _a3;
        (_a3 = controller === null || controller === void 0 ? void 0 : controller.model.get()) === null || _a3 === void 0 ? void 0 : _a3.stop(tx);
      });
    });
  }
}
HideInlineCompletion.ID = "editor.action.inlineSuggest.hide";
class ToggleAlwaysShowInlineSuggestionToolbar extends Action2 {
  constructor() {
    super({
      id: ToggleAlwaysShowInlineSuggestionToolbar.ID,
      title: localize("action.inlineSuggest.alwaysShowToolbar", "Always Show Toolbar"),
      f1: false,
      precondition: void 0,
      menu: [{
        id: MenuId.InlineSuggestionToolbar,
        group: "secondary",
        order: 10
      }],
      toggled: ContextKeyExpr.equals("config.editor.inlineSuggest.showToolbar", "always")
    });
  }
  run(accessor, editor2) {
    return __awaiter$j(this, void 0, void 0, function* () {
      const configService = accessor.get(IConfigurationService);
      const currentValue = configService.getValue("editor.inlineSuggest.showToolbar");
      const newValue = currentValue === "always" ? "onHover" : "always";
      configService.updateValue("editor.inlineSuggest.showToolbar", newValue);
    });
  }
}
ToggleAlwaysShowInlineSuggestionToolbar.ID = "editor.action.inlineSuggest.toggleAlwaysShowToolbar";
var __decorate$n = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$n = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
class InlineCompletionsHover {
  constructor(owner, range, controller) {
    this.owner = owner;
    this.range = range;
    this.controller = controller;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
}
let InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant2 {
  constructor(_editor, _languageService, _openerService, accessibilityService, _instantiationService, _telemetryService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.accessibilityService = accessibilityService;
    this._instantiationService = _instantiationService;
    this._telemetryService = _telemetryService;
    this.hoverOrdinal = 4;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = InlineCompletionsController.get(this._editor);
    if (!controller) {
      return null;
    }
    const target = mouseEvent.target;
    if (target.type === 8) {
      const viewZoneData = target.detail;
      if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
        return new HoverForeignElementAnchor(1e3, this, Range$1.fromPositions(this._editor.getModel().validatePosition(viewZoneData.positionBefore || viewZoneData.position)), mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 7) {
      if (controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 6) {
      const mightBeForeignElement = target.detail.mightBeForeignElement;
      if (mightBeForeignElement && controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    return null;
  }
  computeSync(anchor, lineDecorations) {
    if (this._editor.getOption(
      61
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always") {
      return [];
    }
    const controller = InlineCompletionsController.get(this._editor);
    if (controller && controller.shouldShowHoverAt(anchor.range)) {
      return [new InlineCompletionsHover(this, anchor.range, controller)];
    }
    return [];
  }
  renderHoverParts(context, hoverParts) {
    const disposableStore = new DisposableStore();
    const part = hoverParts[0];
    this._telemetryService.publicLog2("inlineCompletionHover.shown");
    if (this.accessibilityService.isScreenReaderOptimized() && !this._editor.getOption(
      7
      /* EditorOption.screenReaderAnnounceInlineSuggestion */
    )) {
      this.renderScreenReaderText(context, part, disposableStore);
    }
    const model = part.controller.model.get();
    const w = this._instantiationService.createInstance(InlineSuggestionHintsContentWidget, this._editor, false, constObservable(null), model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.selectedInlineCompletion.map((v) => {
      var _a3;
      return (_a3 = v === null || v === void 0 ? void 0 : v.inlineCompletion.source.inlineCompletions.commands) !== null && _a3 !== void 0 ? _a3 : [];
    }));
    context.fragment.appendChild(w.getDomNode());
    model.triggerExplicitly();
    disposableStore.add(w);
    return disposableStore;
  }
  renderScreenReaderText(context, part, disposableStore) {
    const $2 = $$8;
    const markdownHoverElement = $2("div.hover-row.markdown-hover");
    const hoverContentsElement = append(markdownHoverElement, $2("div.hover-contents", { ["aria-live"]: "assertive" }));
    const renderer = disposableStore.add(new MarkdownRenderer({ editor: this._editor }, this._languageService, this._openerService));
    const render = (code) => {
      disposableStore.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        context.onContentsChanged();
      }));
      const inlineSuggestionAvailable = localize("inlineSuggestionFollows", "Suggestion:");
      const renderedContents = disposableStore.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock("text", code)));
      hoverContentsElement.replaceChildren(renderedContents.element);
    };
    disposableStore.add(autorun("update hover", (reader) => {
      var _a3;
      const ghostText2 = (_a3 = part.controller.model.read(reader)) === null || _a3 === void 0 ? void 0 : _a3.ghostText.read(reader);
      if (ghostText2) {
        const lineText = this._editor.getModel().getLineContent(ghostText2.lineNumber);
        render(ghostText2.renderForScreenReader(lineText));
      } else {
        reset(hoverContentsElement);
      }
    }));
    context.fragment.appendChild(markdownHoverElement);
  }
};
InlineCompletionsHoverParticipant = __decorate$n([
  __param$n(1, ILanguageService),
  __param$n(2, IOpenerService),
  __param$n(3, IAccessibilityService),
  __param$n(4, IInstantiationService),
  __param$n(5, ITelemetryService)
], InlineCompletionsHoverParticipant);
registerEditorContribution(
  InlineCompletionsController.ID,
  InlineCompletionsController,
  3
  /* EditorContributionInstantiation.Eventually */
);
registerEditorAction(TriggerInlineSuggestionAction);
registerEditorAction(ShowNextInlineSuggestionAction);
registerEditorAction(ShowPreviousInlineSuggestionAction);
registerEditorAction(AcceptNextWordOfInlineCompletion);
registerEditorAction(AcceptNextLineOfInlineCompletion);
registerEditorAction(AcceptInlineCompletion);
registerEditorAction(HideInlineCompletion);
registerAction2(ToggleAlwaysShowInlineSuggestionToolbar);
HoverParticipantRegistry.register(InlineCompletionsHoverParticipant);
function getSpaceCnt(str, tabSize) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt += tabSize;
    } else {
      spacesCnt++;
    }
  }
  return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
  spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
  let result = "";
  if (!insertSpaces) {
    const tabsCnt = Math.floor(spacesCnt / tabSize);
    spacesCnt = spacesCnt % tabSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}
var __decorate$m = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$m = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber, inheritedIndent) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return [];
  }
  const indentationRules = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentationRules;
  if (!indentationRules) {
    return [];
  }
  endLineNumber = Math.min(endLineNumber, model.getLineCount());
  while (startLineNumber <= endLineNumber) {
    if (!indentationRules.unIndentedLinePattern) {
      break;
    }
    const text = model.getLineContent(startLineNumber);
    if (!indentationRules.unIndentedLinePattern.test(text)) {
      break;
    }
    startLineNumber++;
  }
  if (startLineNumber > endLineNumber - 1) {
    return [];
  }
  const { tabSize, indentSize, insertSpaces } = model.getOptions();
  const shiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const unshiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const indentEdits = [];
  let globalIndent;
  const currentLineText = model.getLineContent(startLineNumber);
  let adjustedLineContent = currentLineText;
  if (inheritedIndent !== void 0 && inheritedIndent !== null) {
    globalIndent = inheritedIndent;
    const oldIndentation = getLeadingWhitespace(currentLineText);
    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
      globalIndent = unshiftIndent(globalIndent);
      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    }
    if (currentLineText !== adjustedLineContent) {
      indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), normalizeIndentation(globalIndent, indentSize, insertSpaces)));
    }
  } else {
    globalIndent = getLeadingWhitespace(currentLineText);
  }
  let idealIndentForNextLine = globalIndent;
  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    globalIndent = shiftIndent(globalIndent);
  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
  }
  startLineNumber++;
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    const text = model.getLineContent(lineNumber);
    const oldIndentation = getLeadingWhitespace(text);
    const adjustedLineContent2 = idealIndentForNextLine + text.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
      globalIndent = unshiftIndent(globalIndent);
    }
    if (oldIndentation !== idealIndentForNextLine) {
      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
    }
    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {
      continue;
    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent2)) {
      globalIndent = shiftIndent(globalIndent);
      idealIndentForNextLine = globalIndent;
    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    } else {
      idealIndentForNextLine = globalIndent;
    }
  }
  return indentEdits;
}
class IndentationToSpacesAction extends EditorAction {
  constructor() {
    super({
      id: IndentationToSpacesAction.ID,
      label: localize("indentationToSpaces", "Convert Indentation to Spaces"),
      alias: "Convert Indentation to Spaces",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: true
    });
  }
}
IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
class IndentationToTabsAction extends EditorAction {
  constructor() {
    super({
      id: IndentationToTabsAction.ID,
      label: localize("indentationToTabs", "Convert Indentation to Tabs"),
      alias: "Convert Indentation to Tabs",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: false
    });
  }
}
IndentationToTabsAction.ID = "editor.action.indentationToTabs";
class ChangeIndentationSizeAction extends EditorAction {
  constructor(insertSpaces, displaySizeOnly, opts) {
    super(opts);
    this.insertSpaces = insertSpaces;
    this.displaySizeOnly = displaySizeOnly;
  }
  run(accessor, editor2) {
    const quickInputService = accessor.get(IQuickInputService);
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    const modelOpts = model.getOptions();
    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map((n2) => ({
      id: n2.toString(),
      label: n2.toString(),
      // add description for tabSize value set in the configuration
      description: n2 === creationOpts.tabSize && n2 === modelOpts.tabSize ? localize("configuredTabSize", "Configured Tab Size") : n2 === creationOpts.tabSize ? localize("defaultTabSize", "Default Tab Size") : n2 === modelOpts.tabSize ? localize("currentTabSize", "Current Tab Size") : void 0
    }));
    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
    setTimeout(
      () => {
        quickInputService.pick(picks, { placeHolder: localize({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then((pick) => {
          if (pick) {
            if (model && !model.isDisposed()) {
              const pickedVal = parseInt(pick.label, 10);
              if (this.displaySizeOnly) {
                model.updateOptions({
                  tabSize: pickedVal
                });
              } else {
                model.updateOptions({
                  tabSize: pickedVal,
                  indentSize: pickedVal,
                  insertSpaces: this.insertSpaces
                });
              }
            }
          }
        });
      },
      50
      /* quick input is sensitive to being opened so soon after another */
    );
  }
}
class IndentUsingTabs extends ChangeIndentationSizeAction {
  constructor() {
    super(false, false, {
      id: IndentUsingTabs.ID,
      label: localize("indentUsingTabs", "Indent Using Tabs"),
      alias: "Indent Using Tabs",
      precondition: void 0
    });
  }
}
IndentUsingTabs.ID = "editor.action.indentUsingTabs";
class IndentUsingSpaces extends ChangeIndentationSizeAction {
  constructor() {
    super(true, false, {
      id: IndentUsingSpaces.ID,
      label: localize("indentUsingSpaces", "Indent Using Spaces"),
      alias: "Indent Using Spaces",
      precondition: void 0
    });
  }
}
IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
class ChangeTabDisplaySize extends ChangeIndentationSizeAction {
  constructor() {
    super(true, true, {
      id: ChangeTabDisplaySize.ID,
      label: localize("changeTabDisplaySize", "Change Tab Display Size"),
      alias: "Change Tab Display Size",
      precondition: void 0
    });
  }
}
ChangeTabDisplaySize.ID = "editor.action.changeTabDisplaySize";
class DetectIndentation extends EditorAction {
  constructor() {
    super({
      id: DetectIndentation.ID,
      label: localize("detectIndentation", "Detect Indentation from Content"),
      alias: "Detect Indentation from Content",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
  }
}
DetectIndentation.ID = "editor.action.detectIndentation";
class ReindentLinesAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: localize("editor.reindentlines", "Reindent Lines"),
      alias: "Reindent Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const edits = getReindentEditOperations(model, languageConfigurationService, 1, model.getLineCount());
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
}
class ReindentSelectedLinesAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: localize("editor.reindentselectedlines", "Reindent Selected Lines"),
      alias: "Reindent Selected Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const edits = [];
    for (const selection of selections) {
      let startLineNumber = selection.startLineNumber;
      let endLineNumber = selection.endLineNumber;
      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
        endLineNumber--;
      }
      if (startLineNumber === 1) {
        if (startLineNumber === endLineNumber) {
          continue;
        }
      } else {
        startLineNumber--;
      }
      const editOperations = getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber);
      edits.push(...editOperations);
    }
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
}
class AutoIndentOnPasteCommand {
  constructor(edits, initialSelection) {
    this._initialSelection = initialSelection;
    this._edits = [];
    this._selectionId = null;
    for (const edit of edits) {
      if (edit.range && typeof edit.text === "string") {
        this._edits.push(edit);
      }
    }
  }
  getEditOperations(model, builder) {
    for (const edit of this._edits) {
      builder.addEditOperation(Range$1.lift(edit.range), edit.text);
    }
    let selectionIsSet = false;
    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, true);
      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, false);
      }
    }
    if (!selectionIsSet) {
      this._selectionId = builder.trackSelection(this._initialSelection);
    }
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
}
let AutoIndentOnPaste = class AutoIndentOnPaste2 {
  constructor(editor2, _languageConfigurationService) {
    this.editor = editor2;
    this._languageConfigurationService = _languageConfigurationService;
    this.callOnDispose = new DisposableStore();
    this.callOnModel = new DisposableStore();
    this.callOnDispose.add(editor2.onDidChangeConfiguration(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModel(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear();
    if (this.editor.getOption(
      11
      /* EditorOption.autoIndent */
    ) < 4 || this.editor.getOption(
      54
      /* EditorOption.formatOnPaste */
    )) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    this.callOnModel.add(this.editor.onDidPaste(({ range }) => {
      this.trigger(range);
    }));
  }
  trigger(range) {
    const selections = this.editor.getSelections();
    if (selections === null || selections.length > 1) {
      return;
    }
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber)) {
      return;
    }
    const autoIndent = this.editor.getOption(
      11
      /* EditorOption.autoIndent */
    );
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const textEdits = [];
    const indentConverter = {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
    let startLineNumber = range.startLineNumber;
    while (startLineNumber <= range.endLineNumber) {
      if (this.shouldIgnoreLine(model, startLineNumber)) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber > range.endLineNumber) {
      return;
    }
    let firstLineText = model.getLineContent(startLineNumber);
    if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
      const indentOfFirstLine = getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter, this._languageConfigurationService);
      if (indentOfFirstLine !== null) {
        const oldIndentation = getLeadingWhitespace(firstLineText);
        const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        if (newSpaceCnt !== oldSpaceCnt) {
          const newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
          textEdits.push({
            range: new Range$1(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
            text: newIndent
          });
          firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
        } else {
          const indentMetadata = getIndentMetadata(model, startLineNumber, this._languageConfigurationService);
          if (indentMetadata === 0 || indentMetadata === 8) {
            return;
          }
        }
      }
    }
    const firstLineNumber = startLineNumber;
    while (startLineNumber < range.endLineNumber) {
      if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber !== range.endLineNumber) {
      const virtualModel = {
        tokenization: {
          getLineTokens: (lineNumber) => {
            return model.tokenization.getLineTokens(lineNumber);
          },
          getLanguageId: () => {
            return model.getLanguageId();
          },
          getLanguageIdAtPosition: (lineNumber, column) => {
            return model.getLanguageIdAtPosition(lineNumber, column);
          }
        },
        getLineContent: (lineNumber) => {
          if (lineNumber === firstLineNumber) {
            return firstLineText;
          } else {
            return model.getLineContent(lineNumber);
          }
        }
      };
      const indentOfSecondLine = getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageId(), startLineNumber + 1, indentConverter, this._languageConfigurationService);
      if (indentOfSecondLine !== null) {
        const newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
        const oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
          const spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
          for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {
            const lineContent = model.getLineContent(i);
            const originalIndent = getLeadingWhitespace(lineContent);
            const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
            const newSpacesCnt = originalSpacesCnt + spaceCntOffset;
            const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
            if (newIndent !== originalIndent) {
              textEdits.push({
                range: new Range$1(i, 1, i, originalIndent.length + 1),
                text: newIndent
              });
            }
          }
        }
      }
    }
    if (textEdits.length > 0) {
      this.editor.pushUndoStop();
      const cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
      this.editor.executeCommand("autoIndentOnPaste", cmd);
      this.editor.pushUndoStop();
    }
  }
  shouldIgnoreLine(model, lineNumber) {
    model.tokenization.forceTokenization(lineNumber);
    const nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (nonWhitespaceColumn === 0) {
      return true;
    }
    const tokens = model.tokenization.getLineTokens(lineNumber);
    if (tokens.getCount() > 0) {
      const firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);
      if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1) {
        return true;
      }
    }
    return false;
  }
  dispose() {
    this.callOnDispose.dispose();
    this.callOnModel.dispose();
  }
};
AutoIndentOnPaste.ID = "editor.contrib.autoIndentOnPaste";
AutoIndentOnPaste = __decorate$m([
  __param$m(1, ILanguageConfigurationService)
], AutoIndentOnPaste);
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return;
  }
  let spaces = "";
  for (let i = 0; i < tabSize; i++) {
    spaces += " ";
  }
  const spacesRegExp = new RegExp(spaces, "gi");
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (lastIndentationColumn === 0) {
      lastIndentationColumn = model.getLineMaxColumn(lineNumber);
    }
    if (lastIndentationColumn === 1) {
      continue;
    }
    const originalIndentationRange = new Range$1(lineNumber, 1, lineNumber, lastIndentationColumn);
    const originalIndentation = model.getValueInRange(originalIndentationRange);
    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/ig, spaces) : originalIndentation.replace(spacesRegExp, "	");
    builder.addEditOperation(originalIndentationRange, newIndentation);
  }
}
class IndentationToSpacesCommand {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, true);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
}
class IndentationToTabsCommand {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, false);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
}
registerEditorContribution(
  AutoIndentOnPaste.ID,
  AutoIndentOnPaste,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(IndentationToSpacesAction);
registerEditorAction(IndentationToTabsAction);
registerEditorAction(IndentUsingTabs);
registerEditorAction(IndentUsingSpaces);
registerEditorAction(ChangeTabDisplaySize);
registerEditorAction(DetectIndentation);
registerEditorAction(ReindentLinesAction);
registerEditorAction(ReindentSelectedLinesAction);
var __awaiter$i = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class InlayHintAnchor {
  constructor(range, direction) {
    this.range = range;
    this.direction = direction;
  }
}
class InlayHintItem {
  constructor(hint, anchor, provider) {
    this.hint = hint;
    this.anchor = anchor;
    this.provider = provider;
    this._isResolved = false;
  }
  with(delta2) {
    const result = new InlayHintItem(this.hint, delta2.anchor, this.provider);
    result._isResolved = this._isResolved;
    result._currentResolve = this._currentResolve;
    return result;
  }
  resolve(token) {
    return __awaiter$i(this, void 0, void 0, function* () {
      if (typeof this.provider.resolveInlayHint !== "function") {
        return;
      }
      if (this._currentResolve) {
        yield this._currentResolve;
        if (token.isCancellationRequested) {
          return;
        }
        return this.resolve(token);
      }
      if (!this._isResolved) {
        this._currentResolve = this._doResolve(token).finally(() => this._currentResolve = void 0);
      }
      yield this._currentResolve;
    });
  }
  _doResolve(token) {
    var _a3, _b3;
    return __awaiter$i(this, void 0, void 0, function* () {
      try {
        const newHint = yield Promise.resolve(this.provider.resolveInlayHint(this.hint, token));
        this.hint.tooltip = (_a3 = newHint === null || newHint === void 0 ? void 0 : newHint.tooltip) !== null && _a3 !== void 0 ? _a3 : this.hint.tooltip;
        this.hint.label = (_b3 = newHint === null || newHint === void 0 ? void 0 : newHint.label) !== null && _b3 !== void 0 ? _b3 : this.hint.label;
        this._isResolved = true;
      } catch (err) {
        onUnexpectedExternalError(err);
        this._isResolved = false;
      }
    });
  }
}
class InlayHintsFragments {
  static create(registry, model, ranges, token) {
    return __awaiter$i(this, void 0, void 0, function* () {
      const data = [];
      const promises = registry.ordered(model).reverse().map((provider) => ranges.map((range) => __awaiter$i(this, void 0, void 0, function* () {
        try {
          const result = yield provider.provideInlayHints(model, range, token);
          if (result === null || result === void 0 ? void 0 : result.hints.length) {
            data.push([result, provider]);
          }
        } catch (err) {
          onUnexpectedExternalError(err);
        }
      })));
      yield Promise.all(promises.flat());
      if (token.isCancellationRequested || model.isDisposed()) {
        throw new CancellationError();
      }
      return new InlayHintsFragments(ranges, data, model);
    });
  }
  constructor(ranges, data, model) {
    this._disposables = new DisposableStore();
    this.ranges = ranges;
    this.provider = /* @__PURE__ */ new Set();
    const items = [];
    for (const [list, provider] of data) {
      this._disposables.add(list);
      this.provider.add(provider);
      for (const hint of list.hints) {
        const position = model.validatePosition(hint.position);
        let direction = "before";
        const wordRange = InlayHintsFragments._getRangeAtPosition(model, position);
        let range;
        if (wordRange.getStartPosition().isBefore(position)) {
          range = Range$1.fromPositions(wordRange.getStartPosition(), position);
          direction = "after";
        } else {
          range = Range$1.fromPositions(position, wordRange.getEndPosition());
          direction = "before";
        }
        items.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));
      }
    }
    this.items = items.sort((a, b) => Position$1.compare(a.hint.position, b.hint.position));
  }
  dispose() {
    this._disposables.dispose();
  }
  static _getRangeAtPosition(model, position) {
    const line = position.lineNumber;
    const word = model.getWordAtPosition(position);
    if (word) {
      return new Range$1(line, word.startColumn, line, word.endColumn);
    }
    model.tokenization.tokenizeIfCheap(line);
    const tokens = model.tokenization.getLineTokens(line);
    const offset = position.column - 1;
    const idx = tokens.findTokenIndexAtOffset(offset);
    let start = tokens.getStartOffset(idx);
    let end = tokens.getEndOffset(idx);
    if (end - start === 1) {
      if (start === offset && idx > 1) {
        start = tokens.getStartOffset(idx - 1);
        end = tokens.getEndOffset(idx - 1);
      } else if (end === offset && idx < tokens.getCount() - 1) {
        start = tokens.getStartOffset(idx + 1);
        end = tokens.getEndOffset(idx + 1);
      }
    }
    return new Range$1(line, start + 1, line, end + 1);
  }
}
function asCommandLink(command) {
  return URI$1.from({
    scheme: Schemas.command,
    path: command.id,
    query: command.arguments && encodeURIComponent(JSON.stringify(command.arguments))
  }).toString();
}
var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function showGoToContextMenu(accessor, editor2, anchor, part) {
  var _a3;
  return __awaiter$h(this, void 0, void 0, function* () {
    const resolverService = accessor.get(ITextModelService);
    const contextMenuService = accessor.get(IContextMenuService);
    const commandService = accessor.get(ICommandService);
    const instaService = accessor.get(IInstantiationService);
    const notificationService = accessor.get(INotificationService);
    yield part.item.resolve(CancellationToken.None);
    if (!part.part.location) {
      return;
    }
    const location = part.part.location;
    const menuActions = [];
    const filter = new Set(MenuRegistry.getMenuItems(MenuId.EditorContext).map((item) => isIMenuItem(item) ? item.command.id : generateUuid()));
    for (const delegate of SymbolNavigationAction.all()) {
      if (filter.has(delegate.desc.id)) {
        menuActions.push(new Action(delegate.desc.id, MenuItemAction.label(delegate.desc, { renderShortTitle: true }), void 0, true, () => __awaiter$h(this, void 0, void 0, function* () {
          const ref = yield resolverService.createModelReference(location.uri);
          try {
            const symbolAnchor = new SymbolNavigationAnchor(ref.object.textEditorModel, Range$1.getStartPosition(location.range));
            const range = part.item.anchor.range;
            yield instaService.invokeFunction(delegate.runEditorCommand.bind(delegate), editor2, symbolAnchor, range);
          } finally {
            ref.dispose();
          }
        })));
      }
    }
    if (part.part.command) {
      const { command } = part.part;
      menuActions.push(new Separator());
      menuActions.push(new Action(command.id, command.title, void 0, true, () => __awaiter$h(this, void 0, void 0, function* () {
        var _b3;
        try {
          yield commandService.executeCommand(command.id, ...(_b3 = command.arguments) !== null && _b3 !== void 0 ? _b3 : []);
        } catch (err) {
          notificationService.notify({
            severity: Severity$1.Error,
            source: part.item.provider.displayName,
            message: err
          });
        }
      })));
    }
    const useShadowDOM = editor2.getOption(
      125
      /* EditorOption.useShadowDOM */
    );
    contextMenuService.showContextMenu({
      domForShadowRoot: useShadowDOM ? (_a3 = editor2.getDomNode()) !== null && _a3 !== void 0 ? _a3 : void 0 : void 0,
      getAnchor: () => {
        const box = getDomNodePagePosition(anchor);
        return { x: box.left, y: box.top + box.height + 8 };
      },
      getActions: () => menuActions,
      onHide: () => {
        editor2.focus();
      },
      autoSelectFirstItem: true
    });
  });
}
function goToDefinitionWithLocation(accessor, event, editor2, location) {
  return __awaiter$h(this, void 0, void 0, function* () {
    const resolverService = accessor.get(ITextModelService);
    const ref = yield resolverService.createModelReference(location.uri);
    yield editor2.invokeWithinContext((accessor2) => __awaiter$h(this, void 0, void 0, function* () {
      const openToSide = event.hasSideBySideModifier;
      const contextKeyService = accessor2.get(IContextKeyService);
      const isInPeek = PeekContext.inPeekEditor.getValue(contextKeyService);
      const canPeek = !openToSide && editor2.getOption(
        86
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !isInPeek;
      const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: "", original: "" }, id: "", precondition: void 0 });
      return action.run(accessor2, new SymbolNavigationAnchor(ref.object.textEditorModel, Range$1.getStartPosition(location.range)), Range$1.lift(location.range));
    }));
    ref.dispose();
  });
}
var __decorate$l = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$l = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class InlayHintsCache {
  constructor() {
    this._entries = new LRUCache(50);
  }
  get(model) {
    const key = InlayHintsCache._key(model);
    return this._entries.get(key);
  }
  set(model, value) {
    const key = InlayHintsCache._key(model);
    this._entries.set(key, value);
  }
  static _key(model) {
    return `${model.uri.toString()}/${model.getVersionId()}`;
  }
}
const IInlayHintsCache = createDecorator("IInlayHintsCache");
registerSingleton(
  IInlayHintsCache,
  InlayHintsCache,
  1
  /* InstantiationType.Delayed */
);
class RenderedInlayHintLabelPart {
  constructor(item, index2) {
    this.item = item;
    this.index = index2;
  }
  get part() {
    const label = this.item.hint.label;
    if (typeof label === "string") {
      return { label };
    } else {
      return label[this.index];
    }
  }
}
class ActiveInlayHintInfo {
  constructor(part, hasTriggerModifier2) {
    this.part = part;
    this.hasTriggerModifier = hasTriggerModifier2;
  }
}
let InlayHintsController = class InlayHintsController2 {
  static get(editor2) {
    var _a3;
    return (_a3 = editor2.getContribution(InlayHintsController2.ID)) !== null && _a3 !== void 0 ? _a3 : void 0;
  }
  constructor(_editor, _languageFeaturesService, _featureDebounce, _inlayHintsCache, _commandService, _notificationService, _instaService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._inlayHintsCache = _inlayHintsCache;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._instaService = _instaService;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._decorationsMetadata = /* @__PURE__ */ new Map();
    this._ruleFactory = new DynamicCssRules(this._editor);
    this._activeRenderMode = 0;
    this._debounceInfo = _featureDebounce.for(_languageFeaturesService.inlayHintsProvider, "InlayHint", { min: 25 });
    this._disposables.add(_languageFeaturesService.inlayHintsProvider.onDidChange(() => this._update()));
    this._disposables.add(_editor.onDidChangeModel(() => this._update()));
    this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
    this._disposables.add(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        138
        /* EditorOption.inlayHints */
      )) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    this._sessionDisposables.dispose();
    this._removeAllDecorations();
    this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear();
    this._removeAllDecorations();
    const options = this._editor.getOption(
      138
      /* EditorOption.inlayHints */
    );
    if (options.enabled === "off") {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !this._languageFeaturesService.inlayHintsProvider.has(model)) {
      return;
    }
    const cached = this._inlayHintsCache.get(model);
    if (cached) {
      this._updateHintsDecorators([model.getFullModelRange()], cached);
    }
    this._sessionDisposables.add(toDisposable(() => {
      if (!model.isDisposed()) {
        this._cacheHintsForFastRestore(model);
      }
    }));
    let cts;
    const watchedProviders = /* @__PURE__ */ new Set();
    const scheduler = new RunOnceScheduler(() => __awaiter$g(this, void 0, void 0, function* () {
      const t1 = Date.now();
      cts === null || cts === void 0 ? void 0 : cts.dispose(true);
      cts = new CancellationTokenSource();
      const listener = model.onWillDispose(() => cts === null || cts === void 0 ? void 0 : cts.cancel());
      try {
        const myToken = cts.token;
        const inlayHints = yield InlayHintsFragments.create(this._languageFeaturesService.inlayHintsProvider, model, this._getHintsRanges(), myToken);
        scheduler.delay = this._debounceInfo.update(model, Date.now() - t1);
        if (myToken.isCancellationRequested) {
          inlayHints.dispose();
          return;
        }
        for (const provider of inlayHints.provider) {
          if (typeof provider.onDidChangeInlayHints === "function" && !watchedProviders.has(provider)) {
            watchedProviders.add(provider);
            this._sessionDisposables.add(provider.onDidChangeInlayHints(() => {
              if (!scheduler.isScheduled()) {
                scheduler.schedule();
              }
            }));
          }
        }
        this._sessionDisposables.add(inlayHints);
        this._updateHintsDecorators(inlayHints.ranges, inlayHints.items);
        this._cacheHintsForFastRestore(model);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        cts.dispose();
        listener.dispose();
      }
    }), this._debounceInfo.get(model));
    this._sessionDisposables.add(scheduler);
    this._sessionDisposables.add(toDisposable(() => cts === null || cts === void 0 ? void 0 : cts.dispose(true)));
    scheduler.schedule(0);
    this._sessionDisposables.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || !scheduler.isScheduled()) {
        scheduler.schedule();
      }
    }));
    this._sessionDisposables.add(this._editor.onDidChangeModelContent((e) => {
      const delay = Math.max(scheduler.delay, 1250);
      scheduler.schedule(delay);
    }));
    if (options.enabled === "on") {
      this._activeRenderMode = 0;
    } else {
      let defaultMode;
      let altMode;
      if (options.enabled === "onUnlessPressed") {
        defaultMode = 0;
        altMode = 1;
      } else {
        defaultMode = 1;
        altMode = 0;
      }
      this._activeRenderMode = defaultMode;
      this._sessionDisposables.add(ModifierKeyEmitter.getInstance().event((e) => {
        if (!this._editor.hasModel()) {
          return;
        }
        const newRenderMode = e.altKey && e.ctrlKey && !(e.shiftKey || e.metaKey) ? altMode : defaultMode;
        if (newRenderMode !== this._activeRenderMode) {
          this._activeRenderMode = newRenderMode;
          const model2 = this._editor.getModel();
          const copies = this._copyInlayHintsWithCurrentAnchor(model2);
          this._updateHintsDecorators([model2.getFullModelRange()], copies);
          scheduler.schedule(0);
        }
      }));
    }
    this._sessionDisposables.add(this._installDblClickGesture(() => scheduler.schedule(0)));
    this._sessionDisposables.add(this._installLinkGesture());
    this._sessionDisposables.add(this._installContextMenu());
  }
  _installLinkGesture() {
    const store = new DisposableStore();
    const gesture = store.add(new ClickLinkGesture(this._editor));
    const sessionStore = new DisposableStore();
    store.add(sessionStore);
    store.add(gesture.onMouseMoveOrRelevantKeyDown((e) => {
      const [mouseEvent] = e;
      const labelPart = this._getInlayHintLabelPart(mouseEvent);
      const model = this._editor.getModel();
      if (!labelPart || !model) {
        sessionStore.clear();
        return;
      }
      const cts = new CancellationTokenSource();
      sessionStore.add(toDisposable(() => cts.dispose(true)));
      labelPart.item.resolve(cts.token);
      this._activeInlayHintPart = labelPart.part.command || labelPart.part.location ? new ActiveInlayHintInfo(labelPart, mouseEvent.hasTriggerModifier) : void 0;
      const lineNumber = model.validatePosition(labelPart.item.hint.position).lineNumber;
      const range = new Range$1(lineNumber, 1, lineNumber, model.getLineMaxColumn(lineNumber));
      const lineHints = this._getInlineHintsForRange(range);
      this._updateHintsDecorators([range], lineHints);
      sessionStore.add(toDisposable(() => {
        this._activeInlayHintPart = void 0;
        this._updateHintsDecorators([range], lineHints);
      }));
    }));
    store.add(gesture.onCancel(() => sessionStore.clear()));
    store.add(gesture.onExecute((e) => __awaiter$g(this, void 0, void 0, function* () {
      const label = this._getInlayHintLabelPart(e);
      if (label) {
        const part = label.part;
        if (part.location) {
          this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, part.location);
        } else if (Command$1.is(part.command)) {
          yield this._invokeCommand(part.command, label.item);
        }
      }
    })));
    return store;
  }
  _getInlineHintsForRange(range) {
    const lineHints = /* @__PURE__ */ new Set();
    for (const data of this._decorationsMetadata.values()) {
      if (range.containsRange(data.item.anchor.range)) {
        lineHints.add(data.item);
      }
    }
    return Array.from(lineHints);
  }
  _installDblClickGesture(updateInlayHints) {
    return this._editor.onMouseUp((e) => __awaiter$g(this, void 0, void 0, function* () {
      if (e.event.detail !== 2) {
        return;
      }
      const part = this._getInlayHintLabelPart(e);
      if (!part) {
        return;
      }
      e.event.preventDefault();
      yield part.item.resolve(CancellationToken.None);
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        const edits = part.item.hint.textEdits.map((edit) => EditOperation.replace(Range$1.lift(edit.range), edit.text));
        this._editor.executeEdits("inlayHint.default", edits);
        updateInlayHints();
      }
    }));
  }
  _installContextMenu() {
    return this._editor.onContextMenu((e) => __awaiter$g(this, void 0, void 0, function* () {
      if (!(e.event.target instanceof HTMLElement)) {
        return;
      }
      const part = this._getInlayHintLabelPart(e);
      if (part) {
        yield this._instaService.invokeFunction(showGoToContextMenu, this._editor, e.event.target, part);
      }
    }));
  }
  _getInlayHintLabelPart(e) {
    var _a3;
    if (e.target.type !== 6) {
      return void 0;
    }
    const options = (_a3 = e.target.detail.injectedText) === null || _a3 === void 0 ? void 0 : _a3.options;
    if (options instanceof ModelDecorationInjectedTextOptions && (options === null || options === void 0 ? void 0 : options.attachedData) instanceof RenderedInlayHintLabelPart) {
      return options.attachedData;
    }
    return void 0;
  }
  _invokeCommand(command, item) {
    var _a3;
    return __awaiter$g(this, void 0, void 0, function* () {
      try {
        yield this._commandService.executeCommand(command.id, ...(_a3 = command.arguments) !== null && _a3 !== void 0 ? _a3 : []);
      } catch (err) {
        this._notificationService.notify({
          severity: Severity$1.Error,
          source: item.provider.displayName,
          message: err
        });
      }
    });
  }
  _cacheHintsForFastRestore(model) {
    const hints = this._copyInlayHintsWithCurrentAnchor(model);
    this._inlayHintsCache.set(model, hints);
  }
  // return inlay hints but with an anchor that reflects "updates"
  // that happened after receiving them, e.g adding new lines before a hint
  _copyInlayHintsWithCurrentAnchor(model) {
    const items = /* @__PURE__ */ new Map();
    for (const [id, obj] of this._decorationsMetadata) {
      if (items.has(obj.item)) {
        continue;
      }
      const range = model.getDecorationRange(id);
      if (range) {
        const anchor = new InlayHintAnchor(range, obj.item.anchor.direction);
        const copy = obj.item.with({ anchor });
        items.set(obj.item, copy);
      }
    }
    return Array.from(items.values());
  }
  _getHintsRanges() {
    const extra = 30;
    const model = this._editor.getModel();
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    const result = [];
    for (const range of visibleRanges.sort(Range$1.compareRangesUsingStarts)) {
      const extendedRange = model.validateRange(new Range$1(range.startLineNumber - extra, range.startColumn, range.endLineNumber + extra, range.endColumn));
      if (result.length === 0 || !Range$1.areIntersectingOrTouching(result[result.length - 1], extendedRange)) {
        result.push(extendedRange);
      } else {
        result[result.length - 1] = Range$1.plusRange(result[result.length - 1], extendedRange);
      }
    }
    return result;
  }
  _updateHintsDecorators(ranges, items) {
    var _a3, _b3;
    const newDecorationsData = [];
    const addInjectedText = (item, ref, content, cursorStops, attachedData) => {
      const opts = {
        content,
        inlineClassNameAffectsLetterSpacing: true,
        inlineClassName: ref.className,
        cursorStops,
        attachedData
      };
      newDecorationsData.push({
        item,
        classNameRef: ref,
        decoration: {
          range: item.anchor.range,
          options: {
            // className: "rangeHighlight", // DEBUG highlight to see to what range a hint is attached
            description: "InlayHint",
            showIfCollapsed: item.anchor.range.isEmpty(),
            collapseOnReplaceEdit: !item.anchor.range.isEmpty(),
            stickiness: 0,
            [item.anchor.direction]: this._activeRenderMode === 0 ? opts : void 0
          }
        }
      });
    };
    const addInjectedWhitespace = (item, isLast) => {
      const marginRule = this._ruleFactory.createClassNameRef({
        width: `${fontSize / 3 | 0}px`,
        display: "inline-block"
      });
      addInjectedText(item, marginRule, " ", isLast ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None);
    };
    const { fontSize, fontFamily, padding, isUniform } = this._getLayoutInfo();
    const fontFamilyVar = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily);
    for (const item of items) {
      if (item.hint.paddingLeft) {
        addInjectedWhitespace(item, false);
      }
      const parts = typeof item.hint.label === "string" ? [{ label: item.hint.label }] : item.hint.label;
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const isFirst = i === 0;
        const isLast = i === parts.length - 1;
        const cssProperties = {
          fontSize: `${fontSize}px`,
          fontFamily: `var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}`,
          verticalAlign: isUniform ? "baseline" : "middle",
          unicodeBidi: "isolate"
        };
        if (isNonEmptyArray(item.hint.textEdits)) {
          cssProperties.cursor = "default";
        }
        this._fillInColors(cssProperties, item.hint);
        if ((part.command || part.location) && ((_a3 = this._activeInlayHintPart) === null || _a3 === void 0 ? void 0 : _a3.part.item) === item && this._activeInlayHintPart.part.index === i) {
          cssProperties.textDecoration = "underline";
          if (this._activeInlayHintPart.hasTriggerModifier) {
            cssProperties.color = themeColorFromId(editorActiveLinkForeground);
            cssProperties.cursor = "pointer";
          }
        }
        if (padding) {
          if (isFirst && isLast) {
            cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px`;
            cssProperties.borderRadius = `${fontSize / 4 | 0}px`;
          } else if (isFirst) {
            cssProperties.padding = `1px 0 1px ${Math.max(1, fontSize / 4) | 0}px`;
            cssProperties.borderRadius = `${fontSize / 4 | 0}px 0 0 ${fontSize / 4 | 0}px`;
          } else if (isLast) {
            cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px 1px 0`;
            cssProperties.borderRadius = `0 ${fontSize / 4 | 0}px ${fontSize / 4 | 0}px 0`;
          } else {
            cssProperties.padding = `1px 0 1px 0`;
          }
        }
        addInjectedText(item, this._ruleFactory.createClassNameRef(cssProperties), fixSpace(part.label), isLast && !item.hint.paddingRight ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None, new RenderedInlayHintLabelPart(item, i));
      }
      if (item.hint.paddingRight) {
        addInjectedWhitespace(item, true);
      }
      if (newDecorationsData.length > InlayHintsController2._MAX_DECORATORS) {
        break;
      }
    }
    const decorationIdsToReplace = [];
    for (const range of ranges) {
      for (const { id } of (_b3 = this._editor.getDecorationsInRange(range)) !== null && _b3 !== void 0 ? _b3 : []) {
        const metadata = this._decorationsMetadata.get(id);
        if (metadata) {
          decorationIdsToReplace.push(id);
          metadata.classNameRef.dispose();
          this._decorationsMetadata.delete(id);
        }
      }
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    this._editor.changeDecorations((accessor) => {
      const newDecorationIds = accessor.deltaDecorations(decorationIdsToReplace, newDecorationsData.map((d) => d.decoration));
      for (let i = 0; i < newDecorationIds.length; i++) {
        const data = newDecorationsData[i];
        this._decorationsMetadata.set(newDecorationIds[i], data);
      }
    });
    scrollState.restore(this._editor);
  }
  _fillInColors(props, hint) {
    if (hint.kind === InlayHintKind$1.Parameter) {
      props.backgroundColor = themeColorFromId(editorInlayHintParameterBackground);
      props.color = themeColorFromId(editorInlayHintParameterForeground);
    } else if (hint.kind === InlayHintKind$1.Type) {
      props.backgroundColor = themeColorFromId(editorInlayHintTypeBackground);
      props.color = themeColorFromId(editorInlayHintTypeForeground);
    } else {
      props.backgroundColor = themeColorFromId(editorInlayHintBackground);
      props.color = themeColorFromId(editorInlayHintForeground);
    }
  }
  _getLayoutInfo() {
    const options = this._editor.getOption(
      138
      /* EditorOption.inlayHints */
    );
    const padding = options.padding;
    const editorFontSize = this._editor.getOption(
      51
      /* EditorOption.fontSize */
    );
    const editorFontFamily = this._editor.getOption(
      48
      /* EditorOption.fontFamily */
    );
    let fontSize = options.fontSize;
    if (!fontSize || fontSize < 5 || fontSize > editorFontSize) {
      fontSize = editorFontSize;
    }
    const fontFamily = options.fontFamily || editorFontFamily;
    const isUniform = !padding && fontFamily === editorFontFamily && fontSize === editorFontSize;
    return { fontSize, fontFamily, padding, isUniform };
  }
  _removeAllDecorations() {
    this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
    for (const obj of this._decorationsMetadata.values()) {
      obj.classNameRef.dispose();
    }
    this._decorationsMetadata.clear();
  }
  // --- accessibility
  getInlayHintsForLine(line) {
    if (!this._editor.hasModel()) {
      return [];
    }
    const set = /* @__PURE__ */ new Set();
    const result = [];
    for (const deco of this._editor.getLineDecorations(line)) {
      const data = this._decorationsMetadata.get(deco.id);
      if (data && !set.has(data.item.hint)) {
        set.add(data.item.hint);
        result.push(data.item);
      }
    }
    return result;
  }
};
InlayHintsController.ID = "editor.contrib.InlayHints";
InlayHintsController._MAX_DECORATORS = 1500;
InlayHintsController = __decorate$l([
  __param$l(1, ILanguageFeaturesService),
  __param$l(2, ILanguageFeatureDebounceService),
  __param$l(3, IInlayHintsCache),
  __param$l(4, ICommandService),
  __param$l(5, INotificationService),
  __param$l(6, IInstantiationService)
], InlayHintsController);
function fixSpace(str) {
  const noBreakWhitespace2 = " ";
  return str.replace(/[ \t]/g, noBreakWhitespace2);
}
CommandsRegistry.registerCommand("_executeInlayHintProvider", (accessor, ...args) => __awaiter$g(void 0, void 0, void 0, function* () {
  const [uri, range] = args;
  assertType(URI$1.isUri(uri));
  assertType(Range$1.isIRange(range));
  const { inlayHintsProvider } = accessor.get(ILanguageFeaturesService);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const model = yield InlayHintsFragments.create(inlayHintsProvider, ref.object.textEditorModel, [Range$1.lift(range)], CancellationToken.None);
    const result = model.items.map((i) => i.hint);
    setTimeout(() => model.dispose(), 0);
    return result;
  } finally {
    ref.dispose();
  }
}));
var __decorate$k = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$k = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = globalThis && globalThis.__asyncValues || function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n2](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
class InlayHintsHoverAnchor extends HoverForeignElementAnchor {
  constructor(part, owner, initialMousePosX, initialMousePosY) {
    super(10, owner, part.item.anchor.range, initialMousePosX, initialMousePosY, true);
    this.part = part;
  }
}
let InlayHintsHover = class InlayHintsHover2 extends MarkdownHoverParticipant {
  constructor(editor2, languageService, openerService, configurationService, _resolverService, languageFeaturesService) {
    super(editor2, languageService, openerService, configurationService, languageFeaturesService);
    this._resolverService = _resolverService;
    this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(mouseEvent) {
    var _a3;
    const controller = InlayHintsController.get(this._editor);
    if (!controller) {
      return null;
    }
    if (mouseEvent.target.type !== 6) {
      return null;
    }
    const options = (_a3 = mouseEvent.target.detail.injectedText) === null || _a3 === void 0 ? void 0 : _a3.options;
    if (!(options instanceof ModelDecorationInjectedTextOptions && options.attachedData instanceof RenderedInlayHintLabelPart)) {
      return null;
    }
    return new InlayHintsHoverAnchor(options.attachedData, this, mouseEvent.event.posx, mouseEvent.event.posy);
  }
  computeSync() {
    return [];
  }
  computeAsync(anchor, _lineDecorations, token) {
    if (!(anchor instanceof InlayHintsHoverAnchor)) {
      return AsyncIterableObject.EMPTY;
    }
    return new AsyncIterableObject((executor) => __awaiter$f(this, void 0, void 0, function* () {
      var _a3, e_1, _b3, _c3;
      const { part } = anchor;
      yield part.item.resolve(token);
      if (token.isCancellationRequested) {
        return;
      }
      let itemTooltip;
      if (typeof part.item.hint.tooltip === "string") {
        itemTooltip = new MarkdownString().appendText(part.item.hint.tooltip);
      } else if (part.item.hint.tooltip) {
        itemTooltip = part.item.hint.tooltip;
      }
      if (itemTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [itemTooltip], false, 0));
      }
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("hint.dbl", "Double-click to insert"))], false, 10001));
      }
      let partTooltip;
      if (typeof part.part.tooltip === "string") {
        partTooltip = new MarkdownString().appendText(part.part.tooltip);
      } else if (part.part.tooltip) {
        partTooltip = part.part.tooltip;
      }
      if (partTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [partTooltip], false, 1));
      }
      if (part.part.location || part.part.command) {
        let linkHint;
        const useMetaKey = this._editor.getOption(
          76
          /* EditorOption.multiCursorModifier */
        ) === "altKey";
        const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
        if (part.part.location && part.part.command) {
          linkHint = new MarkdownString().appendText(localize("hint.defAndCommand", "Go to Definition ({0}), right click for more", kb));
        } else if (part.part.location) {
          linkHint = new MarkdownString().appendText(localize("hint.def", "Go to Definition ({0})", kb));
        } else if (part.part.command) {
          linkHint = new MarkdownString(`[${localize("hint.cmd", "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, { isTrusted: true });
        }
        if (linkHint) {
          executor.emitOne(new MarkdownHover(this, anchor.range, [linkHint], false, 1e4));
        }
      }
      const iterable = yield this._resolveInlayHintLabelPartHover(part, token);
      try {
        for (var _d3 = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield iterable_1.next(), _a3 = iterable_1_1.done, !_a3; _d3 = true) {
          _c3 = iterable_1_1.value;
          _d3 = false;
          const item = _c3;
          executor.emitOne(item);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d3 && !_a3 && (_b3 = iterable_1.return))
            yield _b3.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }));
  }
  _resolveInlayHintLabelPartHover(part, token) {
    return __awaiter$f(this, void 0, void 0, function* () {
      if (!part.part.location) {
        return AsyncIterableObject.EMPTY;
      }
      const { uri, range } = part.part.location;
      const ref = yield this._resolverService.createModelReference(uri);
      try {
        const model = ref.object.textEditorModel;
        if (!this._languageFeaturesService.hoverProvider.has(model)) {
          return AsyncIterableObject.EMPTY;
        }
        return getHover(this._languageFeaturesService.hoverProvider, model, new Position$1(range.startLineNumber, range.startColumn), token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => new MarkdownHover(this, part.item.anchor.range, item.hover.contents, false, 2 + item.ordinal));
      } finally {
        ref.dispose();
      }
    });
  }
};
InlayHintsHover = __decorate$k([
  __param$k(1, ILanguageService),
  __param$k(2, IOpenerService),
  __param$k(3, IConfigurationService),
  __param$k(4, ITextModelService),
  __param$k(5, ILanguageFeaturesService)
], InlayHintsHover);
registerEditorContribution(
  InlayHintsController.ID,
  InlayHintsController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
HoverParticipantRegistry.register(InlayHintsHover);
class InPlaceReplaceCommand {
  constructor(editRange, originalSelection, text) {
    this._editRange = editRange;
    this._originalSelection = originalSelection;
    this._text = text;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._editRange, this._text);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    const srcRange = inverseEditOperations[0].range;
    if (!this._originalSelection.isEmpty()) {
      return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
    }
    return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
  }
}
const inPlaceReplace = "";
var __decorate$j = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$j = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let InPlaceReplaceController = class InPlaceReplaceController2 {
  static get(editor2) {
    return editor2.getContribution(InPlaceReplaceController2.ID);
  }
  constructor(editor2, editorWorkerService) {
    this.editor = editor2;
    this.editorWorkerService = editorWorkerService;
    this.decorations = this.editor.createDecorationsCollection();
  }
  dispose() {
  }
  run(source, up) {
    var _a3;
    (_a3 = this.currentRequest) === null || _a3 === void 0 ? void 0 : _a3.cancel();
    const editorSelection = this.editor.getSelection();
    const model = this.editor.getModel();
    if (!model || !editorSelection) {
      return void 0;
    }
    let selection = editorSelection;
    if (selection.startLineNumber !== selection.endLineNumber) {
      return void 0;
    }
    const state = new EditorState$1(
      this.editor,
      1 | 4
      /* CodeEditorStateFlag.Position */
    );
    const modelURI = model.uri;
    if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
      return Promise.resolve(void 0);
    }
    this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
    return this.currentRequest.then((result) => {
      var _a4;
      if (!result || !result.range || !result.value) {
        return;
      }
      if (!state.validate(this.editor)) {
        return;
      }
      const editRange = Range$1.lift(result.range);
      let highlightRange = result.range;
      const diff = result.value.length - (selection.endColumn - selection.startColumn);
      highlightRange = {
        startLineNumber: highlightRange.startLineNumber,
        startColumn: highlightRange.startColumn,
        endLineNumber: highlightRange.endLineNumber,
        endColumn: highlightRange.startColumn + result.value.length
      };
      if (diff > 1) {
        selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
      }
      const command = new InPlaceReplaceCommand(editRange, selection, result.value);
      this.editor.pushUndoStop();
      this.editor.executeCommand(source, command);
      this.editor.pushUndoStop();
      this.decorations.set([{
        range: highlightRange,
        options: InPlaceReplaceController2.DECORATION
      }]);
      (_a4 = this.decorationRemover) === null || _a4 === void 0 ? void 0 : _a4.cancel();
      this.decorationRemover = timeout(350);
      this.decorationRemover.then(() => this.decorations.clear()).catch(onUnexpectedError);
    }).catch(onUnexpectedError);
  }
};
InPlaceReplaceController.ID = "editor.contrib.inPlaceReplaceController";
InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
  description: "in-place-replace",
  className: "valueSetReplacement"
});
InPlaceReplaceController = __decorate$j([
  __param$j(1, IEditorWorkerService)
], InPlaceReplaceController);
class InPlaceReplaceUp extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.up",
      label: localize("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
      alias: "Replace with Previous Value",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 87,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = InPlaceReplaceController.get(editor2);
    if (!controller) {
      return Promise.resolve(void 0);
    }
    return controller.run(this.id, false);
  }
}
class InPlaceReplaceDown extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.down",
      label: localize("InPlaceReplaceAction.next.label", "Replace with Next Value"),
      alias: "Replace with Next Value",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 89,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = InPlaceReplaceController.get(editor2);
    if (!controller) {
      return Promise.resolve(void 0);
    }
    return controller.run(this.id, true);
  }
}
registerEditorContribution(
  InPlaceReplaceController.ID,
  InPlaceReplaceController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(InPlaceReplaceUp);
registerEditorAction(InPlaceReplaceDown);
class ExpandLineSelectionAction extends EditorAction {
  constructor() {
    super({
      id: "expandLineSelection",
      label: localize("expandLineSelection", "Expand Line Selection"),
      alias: "Expand Line Selection",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 42
        /* KeyCode.KeyL */
      }
    });
  }
  run(_accessor, editor2, args) {
    args = args || {};
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    viewModel.model.pushStackElement();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));
    viewModel.revealPrimaryCursor(args.source, true);
  }
}
registerEditorAction(ExpandLineSelectionAction);
class TrimTrailingWhitespaceCommand {
  constructor(selection, cursors) {
    this._selection = selection;
    this._cursors = cursors;
    this._selectionId = null;
  }
  getEditOperations(model, builder) {
    const ops = trimTrailingWhitespace(model, this._cursors);
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      builder.addEditOperation(op.range, op.text);
    }
    this._selectionId = builder.trackSelection(this._selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
}
function trimTrailingWhitespace(model, cursors) {
  cursors.sort((a, b) => {
    if (a.lineNumber === b.lineNumber) {
      return a.column - b.column;
    }
    return a.lineNumber - b.lineNumber;
  });
  for (let i = cursors.length - 2; i >= 0; i--) {
    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
      cursors.splice(i, 1);
    }
  }
  const r = [];
  let rLen = 0;
  let cursorIndex = 0;
  const cursorLen = cursors.length;
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    const lineContent = model.getLineContent(lineNumber);
    const maxLineColumn = lineContent.length + 1;
    let minEditColumn = 0;
    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
      minEditColumn = cursors[cursorIndex].column;
      cursorIndex++;
      if (minEditColumn === maxLineColumn) {
        continue;
      }
    }
    if (lineContent.length === 0) {
      continue;
    }
    const lastNonWhitespaceIndex$1 = lastNonWhitespaceIndex(lineContent);
    let fromColumn = 0;
    if (lastNonWhitespaceIndex$1 === -1) {
      fromColumn = 1;
    } else if (lastNonWhitespaceIndex$1 !== lineContent.length - 1) {
      fromColumn = lastNonWhitespaceIndex$1 + 2;
    } else {
      continue;
    }
    fromColumn = Math.max(minEditColumn, fromColumn);
    r[rLen++] = EditOperation.delete(new Range$1(lineNumber, fromColumn, lineNumber, maxLineColumn));
  }
  return r;
}
class CopyLinesCommand {
  constructor(selection, isCopyingDown, noop) {
    this._selection = selection;
    this._isCopyingDown = isCopyingDown;
    this._noop = noop || false;
    this._selectionDirection = 0;
    this._selectionId = null;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._endLineNumberDelta = 1;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const sourceLines = [];
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      sourceLines.push(model.getLineContent(i));
    }
    const sourceText = sourceLines.join("\n");
    if (sourceText === "") {
      if (this._isCopyingDown) {
        this._startLineNumberDelta++;
        this._endLineNumberDelta++;
      }
    }
    if (this._noop) {
      builder.addEditOperation(new Range$1(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? "" : "\n");
    } else {
      if (!this._isCopyingDown) {
        builder.addEditOperation(new Range$1(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
      } else {
        builder.addEditOperation(new Range$1(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
      }
    }
    this._selectionId = builder.trackSelection(s);
    this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let startLineNumber = result.startLineNumber;
      let startColumn = result.startColumn;
      let endLineNumber = result.endLineNumber;
      let endColumn = result.endColumn;
      if (this._startLineNumberDelta !== 0) {
        startLineNumber = startLineNumber + this._startLineNumberDelta;
        startColumn = 1;
      }
      if (this._endLineNumberDelta !== 0) {
        endLineNumber = endLineNumber + this._endLineNumberDelta;
        endColumn = 1;
      }
      result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
    }
    return result;
  }
}
var __decorate$i = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$i = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let MoveLinesCommand = class MoveLinesCommand2 {
  constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {
    this._languageConfigurationService = _languageConfigurationService;
    this._selection = selection;
    this._isMovingDown = isMovingDown;
    this._autoIndent = autoIndent;
    this._selectionId = null;
    this._moveEndLineSelectionShrink = false;
  }
  getEditOperations(model, builder) {
    const modelLineCount = model.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = false;
    let s = this._selection;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
    const virtualModel = {
      tokenization: {
        getLineTokens: (lineNumber) => {
          return model.tokenization.getLineTokens(lineNumber);
        },
        getLanguageId: () => {
          return model.getLanguageId();
        },
        getLanguageIdAtPosition: (lineNumber, column) => {
          return model.getLanguageIdAtPosition(lineNumber, column);
        }
      },
      getLineContent: null
    };
    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
      const lineNumber = s.startLineNumber;
      const otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
      if (model.getLineMaxColumn(otherLineNumber) === 1) {
        builder.addEditOperation(new Range$1(1, 1, 1, 1), null);
      } else {
        builder.addEditOperation(new Range$1(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
        builder.addEditOperation(new Range$1(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
      }
      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
    } else {
      let movingLineNumber;
      let movingLineText;
      if (this._isMovingDown) {
        movingLineNumber = s.endLineNumber + 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range$1(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
        let insertingText = movingLineText;
        if (this.shouldAutoIndent(model, s)) {
          const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
          if (movingLineMatchResult !== null) {
            const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
            const newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
            const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
            insertingText = newIndentation + this.trimLeft(movingLineText);
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return model.getLineContent(movingLineNumber);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfMovingLine !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                insertingText = newIndentation + this.trimLeft(movingLineText);
              }
            }
          }
          builder.addEditOperation(new Range$1(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
          const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return insertingText;
              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                return model.getLineContent(lineNumber - 1);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);
            if (newIndentatOfMovingBlock !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        } else {
          builder.addEditOperation(new Range$1(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
        }
      } else {
        movingLineNumber = s.startLineNumber - 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range$1(movingLineNumber, 1, movingLineNumber + 1, 1), null);
        builder.addEditOperation(new Range$1(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
        if (this.shouldAutoIndent(model, s)) {
          virtualModel.getLineContent = (lineNumber) => {
            if (lineNumber === movingLineNumber) {
              return model.getLineContent(s.startLineNumber);
            } else {
              return model.getLineContent(lineNumber);
            }
          };
          const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfFirstLine !== null) {
              const oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  buildIndentConverter(tabSize, indentSize, insertSpaces) {
    return {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
  }
  parseEnterResult(model, indentConverter, tabSize, line, enter) {
    if (enter) {
      let enterPrefix = enter.indentation;
      if (enter.indentAction === IndentAction.None) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.Indent) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.IndentOutdent) {
        enterPrefix = enter.indentation;
      } else if (enter.indentAction === IndentAction.Outdent) {
        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
      }
      const movingLineText = model.getLineContent(line);
      if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {
        const oldIndentation = getLeadingWhitespace(model.getLineContent(line));
        let newIndentation = getLeadingWhitespace(enterPrefix);
        const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);
        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) {
          newIndentation = indentConverter.unshiftIndent(newIndentation);
        }
        const newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        return newSpaceCnt - oldSpaceCnt;
      }
    }
    return null;
  }
  /**
   *
   * @param model
   * @param indentConverter
   * @param tabSize
   * @param line the line moving down
   * @param futureAboveLineNumber the line which will be at the `line` position
   * @param futureAboveLineText
   */
  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {
    if (lastNonWhitespaceIndex(futureAboveLineText) >= 0) {
      const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);
      const enter = getEnterAction(this._autoIndent, model, new Range$1(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    } else {
      let validPrecedingLine = line - 1;
      while (validPrecedingLine >= 1) {
        const lineContent = model.getLineContent(validPrecedingLine);
        const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
        if (nonWhitespaceIdx >= 0) {
          break;
        }
        validPrecedingLine--;
      }
      if (validPrecedingLine < 1 || line > model.getLineCount()) {
        return null;
      }
      const maxColumn = model.getLineMaxColumn(validPrecedingLine);
      const enter = getEnterAction(this._autoIndent, model, new Range$1(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    }
  }
  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {
    let validPrecedingLine = oneLineAbove;
    while (validPrecedingLine >= 1) {
      let lineContent;
      if (validPrecedingLine === oneLineAbove && previousLineText !== void 0) {
        lineContent = previousLineText;
      } else {
        lineContent = model.getLineContent(validPrecedingLine);
      }
      const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
      if (nonWhitespaceIdx >= 0) {
        break;
      }
      validPrecedingLine--;
    }
    if (validPrecedingLine < 1 || line > model.getLineCount()) {
      return null;
    }
    const maxColumn = model.getLineMaxColumn(validPrecedingLine);
    const enter = getEnterAction(this._autoIndent, model, new Range$1(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
  }
  trimLeft(str) {
    return str.replace(/^\s+/, "");
  }
  shouldAutoIndent(model, selection) {
    if (this._autoIndent < 4) {
      return false;
    }
    if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {
      return false;
    }
    const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
    const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
    if (languageAtSelectionStart !== languageAtSelectionEnd) {
      return false;
    }
    if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {
      return false;
    }
    return true;
  }
  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      const lineContent = model.getLineContent(i);
      const originalIndent = getLeadingWhitespace(lineContent);
      const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
      const newSpacesCnt = originalSpacesCnt + offset;
      const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
      if (newIndent !== originalIndent) {
        builder.addEditOperation(new Range$1(i, 1, i, originalIndent.length + 1), newIndent);
        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") {
          this._moveEndLineSelectionShrink = true;
        }
      }
    }
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
      result = result.setEndPosition(result.endLineNumber, 2);
    }
    return result;
  }
};
MoveLinesCommand = __decorate$i([
  __param$i(3, ILanguageConfigurationService)
], MoveLinesCommand);
class SortLinesCommand {
  static getCollator() {
    if (!SortLinesCommand._COLLATOR) {
      SortLinesCommand._COLLATOR = new Intl.Collator();
    }
    return SortLinesCommand._COLLATOR;
  }
  constructor(selection, descending) {
    this.selection = selection;
    this.descending = descending;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    const op = sortLines(model, this.selection, this.descending);
    if (op) {
      builder.addEditOperation(op.range, op.text);
    }
    this.selectionId = builder.trackSelection(this.selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
  static canRun(model, selection, descending) {
    if (model === null) {
      return false;
    }
    const data = getSortData(model, selection, descending);
    if (!data) {
      return false;
    }
    for (let i = 0, len = data.before.length; i < len; i++) {
      if (data.before[i] !== data.after[i]) {
        return true;
      }
    }
    return false;
  }
}
SortLinesCommand._COLLATOR = null;
function getSortData(model, selection, descending) {
  const startLineNumber = selection.startLineNumber;
  let endLineNumber = selection.endLineNumber;
  if (selection.endColumn === 1) {
    endLineNumber--;
  }
  if (startLineNumber >= endLineNumber) {
    return null;
  }
  const linesToSort = [];
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    linesToSort.push(model.getLineContent(lineNumber));
  }
  let sorted = linesToSort.slice(0);
  sorted.sort(SortLinesCommand.getCollator().compare);
  if (descending === true) {
    sorted = sorted.reverse();
  }
  return {
    startLineNumber,
    endLineNumber,
    before: linesToSort,
    after: sorted
  };
}
function sortLines(model, selection, descending) {
  const data = getSortData(model, selection, descending);
  if (!data) {
    return null;
  }
  return EditOperation.replace(new Range$1(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}
class AbstractCopyLinesAction extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections().map((selection, index2) => ({ selection, index: index2, ignore: false }));
    selections.sort((a, b) => Range$1.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignore = true;
        } else {
          prev.ignore = true;
          prev = curr;
        }
      }
    }
    const commands2 = [];
    for (const selection of selections) {
      commands2.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class CopyLinesUpAction extends AbstractCopyLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.copyLinesUpAction",
      label: localize("lines.copyUp", "Copy Line Up"),
      alias: "Copy Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 16,
        linux: {
          primary: 2048 | 512 | 1024 | 16
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
        order: 1
      }
    });
  }
}
class CopyLinesDownAction extends AbstractCopyLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.copyLinesDownAction",
      label: localize("lines.copyDown", "Copy Line Down"),
      alias: "Copy Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 18,
        linux: {
          primary: 2048 | 512 | 1024 | 18
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
        order: 2
      }
    });
  }
}
class DuplicateSelectionAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: localize("duplicateSelection", "Duplicate Selection"),
      alias: "Duplicate Selection",
      precondition: EditorContextKeys.writable,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands2 = [];
    const selections = editor2.getSelections();
    const model = editor2.getModel();
    for (const selection of selections) {
      if (selection.isEmpty()) {
        commands2.push(new CopyLinesCommand(selection, true));
      } else {
        const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
        commands2.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class AbstractMoveLinesAction extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const commands2 = [];
    const selections = editor2.getSelections() || [];
    const autoIndent = editor2.getOption(
      11
      /* EditorOption.autoIndent */
    );
    for (const selection of selections) {
      commands2.push(new MoveLinesCommand(selection, this.down, autoIndent, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class MoveLinesUpAction extends AbstractMoveLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.moveLinesUpAction",
      label: localize("lines.moveUp", "Move Line Up"),
      alias: "Move Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 16,
        linux: {
          primary: 512 | 16
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
}
class MoveLinesDownAction extends AbstractMoveLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.moveLinesDownAction",
      label: localize("lines.moveDown", "Move Line Down"),
      alias: "Move Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 18,
        linux: {
          primary: 512 | 18
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
        order: 4
      }
    });
  }
}
class AbstractSortLinesAction extends EditorAction {
  constructor(descending, opts) {
    super(opts);
    this.descending = descending;
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections() || [];
    for (const selection of selections) {
      if (!SortLinesCommand.canRun(editor2.getModel(), selection, this.descending)) {
        return;
      }
    }
    const commands2 = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands2[i] = new SortLinesCommand(selections[i], this.descending);
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class SortLinesAscendingAction extends AbstractSortLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.sortLinesAscending",
      label: localize("lines.sortAscending", "Sort Lines Ascending"),
      alias: "Sort Lines Ascending",
      precondition: EditorContextKeys.writable
    });
  }
}
class SortLinesDescendingAction extends AbstractSortLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.sortLinesDescending",
      label: localize("lines.sortDescending", "Sort Lines Descending"),
      alias: "Sort Lines Descending",
      precondition: EditorContextKeys.writable
    });
  }
}
class DeleteDuplicateLinesAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeDuplicateLines",
      label: localize("lines.deleteDuplicates", "Delete Duplicate Lines"),
      alias: "Delete Duplicate Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let linesDeleted = 0;
    for (const selection of editor2.getSelections()) {
      const uniqueLines = /* @__PURE__ */ new Set();
      const lines = [];
      for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {
        const line = model.getLineContent(i);
        if (uniqueLines.has(line)) {
          continue;
        }
        lines.push(line);
        uniqueLines.add(line);
      }
      const selectionToReplace = new Selection(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));
      const adjustedSelectionStart = selection.startLineNumber - linesDeleted;
      const finalSelection = new Selection(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);
      edits.push(EditOperation.replace(selectionToReplace, lines.join("\n")));
      endCursorState.push(finalSelection);
      linesDeleted += selection.endLineNumber - selection.startLineNumber + 1 - lines.length;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
}
class TrimTrailingWhitespaceAction extends EditorAction {
  constructor() {
    super({
      id: TrimTrailingWhitespaceAction.ID,
      label: localize("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
      alias: "Trim Trailing Whitespace",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 54
          /* KeyCode.KeyX */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2, args) {
    let cursors = [];
    if (args.reason === "auto-save") {
      cursors = (editor2.getSelections() || []).map((s) => new Position$1(s.positionLineNumber, s.positionColumn));
    }
    const selection = editor2.getSelection();
    if (selection === null) {
      return;
    }
    const command = new TrimTrailingWhitespaceCommand(selection, cursors);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
  }
}
TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
class DeleteLinesAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: localize("lines.delete", "Delete Line"),
      alias: "Delete Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 41,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const ops = this._getLinesToRemove(editor2);
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    let linesDeleted = 0;
    const edits = [];
    const cursorState = [];
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      let startLineNumber = op.startLineNumber;
      let endLineNumber = op.endLineNumber;
      let startColumn = 1;
      let endColumn = model.getLineMaxColumn(endLineNumber);
      if (endLineNumber < model.getLineCount()) {
        endLineNumber += 1;
        endColumn = 1;
      } else if (startLineNumber > 1) {
        startLineNumber -= 1;
        startColumn = model.getLineMaxColumn(startLineNumber);
      }
      edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ""));
      cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
      linesDeleted += op.endLineNumber - op.startLineNumber + 1;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, cursorState);
    editor2.pushUndoStop();
  }
  _getLinesToRemove(editor2) {
    const operations = editor2.getSelections().map((s) => {
      let endLineNumber = s.endLineNumber;
      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
        endLineNumber -= 1;
      }
      return {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber,
        positionColumn: s.positionColumn
      };
    });
    operations.sort((a, b) => {
      if (a.startLineNumber === b.startLineNumber) {
        return a.endLineNumber - b.endLineNumber;
      }
      return a.startLineNumber - b.startLineNumber;
    });
    const mergedOperations = [];
    let previousOperation = operations[0];
    for (let i = 1; i < operations.length; i++) {
      if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {
        previousOperation.endLineNumber = operations[i].endLineNumber;
      } else {
        mergedOperations.push(previousOperation);
        previousOperation = operations[i];
      }
    }
    mergedOperations.push(previousOperation);
    return mergedOperations;
  }
}
class IndentLinesAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: localize("lines.indent", "Indent Line"),
      alias: "Indent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 94,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
    editor2.pushUndoStop();
  }
}
class OutdentLinesAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: localize("lines.outdent", "Outdent Line"),
      alias: "Outdent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 92,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor2, null);
  }
}
class InsertLineBeforeAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: localize("lines.insertBefore", "Insert Line Above"),
      alias: "Insert Line Above",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
}
class InsertLineAfterAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: localize("lines.insertAfter", "Insert Line Below"),
      alias: "Insert Line Below",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
}
class AbstractDeleteAllToBoundaryAction extends EditorAction {
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const primaryCursor = editor2.getSelection();
    const rangesToDelete = this._getRangesToDelete(editor2);
    const effectiveRanges = [];
    for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {
      const range = rangesToDelete[i];
      const nextRange = rangesToDelete[i + 1];
      if (Range$1.intersectRanges(range, nextRange) === null) {
        effectiveRanges.push(range);
      } else {
        rangesToDelete[i + 1] = Range$1.plusRange(range, nextRange);
      }
    }
    effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
    const endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
    const edits = effectiveRanges.map((range) => {
      return EditOperation.replace(range, "");
    });
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
}
class DeleteAllLeftAction extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: localize("lines.deleteAllLeft", "Delete All Left"),
      alias: "Delete All Left",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 2048 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    let deletedLines = 0;
    rangesToDelete.forEach((range) => {
      let endCursor;
      if (range.endColumn === 1 && deletedLines > 0) {
        const newStartLine = range.startLineNumber - deletedLines;
        endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);
      } else {
        endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      deletedLines += range.endLineNumber - range.startLineNumber;
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    });
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections;
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    rangesToDelete.sort(Range$1.compareRangesUsingStarts);
    rangesToDelete = rangesToDelete.map((selection) => {
      if (selection.isEmpty()) {
        if (selection.startColumn === 1) {
          const deleteFromLine = Math.max(1, selection.startLineNumber - 1);
          const deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;
          return new Range$1(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);
        } else {
          return new Range$1(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
        }
      } else {
        return new Range$1(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
      }
    });
    return rangesToDelete;
  }
}
class DeleteAllRightAction extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllRight",
      label: localize("lines.deleteAllRight", "Delete All Right"),
      alias: "Delete All Right",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 41, secondary: [
          2048 | 20
          /* KeyCode.Delete */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
      const range = rangesToDelete[i];
      const endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    }
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    const rangesToDelete = selections.map((sel) => {
      if (sel.isEmpty()) {
        const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
        if (sel.startColumn === maxColumn) {
          return new Range$1(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
        } else {
          return new Range$1(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
        }
      }
      return sel;
    });
    rangesToDelete.sort(Range$1.compareRangesUsingStarts);
    return rangesToDelete;
  }
}
class JoinLinesAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: localize("lines.joinLines", "Join Lines"),
      alias: "Join Lines",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        mac: {
          primary: 256 | 40
          /* KeyCode.KeyJ */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    let primaryCursor = editor2.getSelection();
    if (primaryCursor === null) {
      return;
    }
    selections.sort(Range$1.compareRangesUsingStarts);
    const reducedSelections = [];
    const lastSelection = selections.reduce((previousValue, currentValue) => {
      if (previousValue.isEmpty()) {
        if (previousValue.endLineNumber === currentValue.startLineNumber) {
          if (primaryCursor.equalsSelection(previousValue)) {
            primaryCursor = currentValue;
          }
          return currentValue;
        }
        if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      } else {
        if (currentValue.startLineNumber > previousValue.endLineNumber) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      }
    });
    reducedSelections.push(lastSelection);
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let endPrimaryCursor = primaryCursor;
    let lineOffset = 0;
    for (let i = 0, len = reducedSelections.length; i < len; i++) {
      const selection = reducedSelections[i];
      const startLineNumber = selection.startLineNumber;
      const startColumn = 1;
      let columnDeltaOffset = 0;
      let endLineNumber, endColumn;
      const selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
      if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
        const position = selection.getStartPosition();
        if (position.lineNumber < model.getLineCount()) {
          endLineNumber = startLineNumber + 1;
          endColumn = model.getLineMaxColumn(endLineNumber);
        } else {
          endLineNumber = position.lineNumber;
          endColumn = model.getLineMaxColumn(position.lineNumber);
        }
      } else {
        endLineNumber = selection.endLineNumber;
        endColumn = model.getLineMaxColumn(endLineNumber);
      }
      let trimmedLinesContent = model.getLineContent(startLineNumber);
      for (let i2 = startLineNumber + 1; i2 <= endLineNumber; i2++) {
        const lineText = model.getLineContent(i2);
        const firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i2);
        if (firstNonWhitespaceIdx >= 1) {
          let insertSpace = true;
          if (trimmedLinesContent === "") {
            insertSpace = false;
          }
          if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
            insertSpace = false;
            trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
          }
          const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
          trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
          if (insertSpace) {
            columnDeltaOffset = lineTextWithoutIndent.length + 1;
          } else {
            columnDeltaOffset = lineTextWithoutIndent.length;
          }
        } else {
          columnDeltaOffset = 0;
        }
      }
      const deleteSelection = new Range$1(startLineNumber, startColumn, endLineNumber, endColumn);
      if (!deleteSelection.isEmpty()) {
        let resultSelection;
        if (selection.isEmpty()) {
          edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
          resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
        } else {
          if (selection.startLineNumber === selection.endLineNumber) {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
          } else {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
          }
        }
        if (Range$1.intersectRanges(deleteSelection, primaryCursor) !== null) {
          endPrimaryCursor = resultSelection;
        } else {
          endCursorState.push(resultSelection);
        }
      }
      lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
    }
    endCursorState.unshift(endPrimaryCursor);
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
}
class TransposeAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: localize("editor.transpose", "Transpose characters around the cursor"),
      alias: "Transpose characters around the cursor",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const commands2 = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (!selection.isEmpty()) {
        continue;
      }
      const cursor = selection.getStartPosition();
      const maxColumn = model.getLineMaxColumn(cursor.lineNumber);
      if (cursor.column >= maxColumn) {
        if (cursor.lineNumber === model.getLineCount()) {
          continue;
        }
        const deleteSelection = new Range$1(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands2.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
      } else {
        const deleteSelection = new Range$1(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands2.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class AbstractCaseAction extends EditorAction {
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const wordSeparators = editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    );
    const textEdits = [];
    for (const selection of selections) {
      if (selection.isEmpty()) {
        const cursor = selection.getStartPosition();
        const word = editor2.getConfiguredWordAtPosition(cursor);
        if (!word) {
          continue;
        }
        const wordRange = new Range$1(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
        const text = model.getValueInRange(wordRange);
        textEdits.push(EditOperation.replace(wordRange, this._modifyText(text, wordSeparators)));
      } else {
        const text = model.getValueInRange(selection);
        textEdits.push(EditOperation.replace(selection, this._modifyText(text, wordSeparators)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, textEdits);
    editor2.pushUndoStop();
  }
}
class UpperCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: localize("editor.transformToUppercase", "Transform to Uppercase"),
      alias: "Transform to Uppercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleUpperCase();
  }
}
class LowerCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: localize("editor.transformToLowercase", "Transform to Lowercase"),
      alias: "Transform to Lowercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleLowerCase();
  }
}
class BackwardsCompatibleRegExp {
  constructor(_pattern, _flags) {
    this._pattern = _pattern;
    this._flags = _flags;
    this._actual = null;
    this._evaluated = false;
  }
  get() {
    if (!this._evaluated) {
      this._evaluated = true;
      try {
        this._actual = new RegExp(this._pattern, this._flags);
      } catch (err) {
      }
    }
    return this._actual;
  }
  isSupported() {
    return this.get() !== null;
  }
}
class TitleCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: localize("editor.transformToTitlecase", "Transform to Title Case"),
      alias: "Transform to Title Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const titleBoundary = TitleCaseAction.titleBoundary.get();
    if (!titleBoundary) {
      return text;
    }
    return text.toLocaleLowerCase().replace(titleBoundary, (b) => b.toLocaleUpperCase());
  }
}
TitleCaseAction.titleBoundary = new BackwardsCompatibleRegExp("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
class SnakeCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToSnakecase",
      label: localize("editor.transformToSnakecase", "Transform to Snake Case"),
      alias: "Transform to Snake Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const caseBoundary = SnakeCaseAction.caseBoundary.get();
    const singleLetters = SnakeCaseAction.singleLetters.get();
    if (!caseBoundary || !singleLetters) {
      return text;
    }
    return text.replace(caseBoundary, "$1_$2").replace(singleLetters, "$1_$2$3").toLocaleLowerCase();
  }
}
SnakeCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
SnakeCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
class CamelCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToCamelcase",
      label: localize("editor.transformToCamelcase", "Transform to Camel Case"),
      alias: "Transform to Camel Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const wordBoundary = CamelCaseAction.wordBoundary.get();
    if (!wordBoundary) {
      return text;
    }
    const words = text.split(wordBoundary);
    const firstWord = words.shift();
    return firstWord + words.map((word) => word.substring(0, 1).toLocaleUpperCase() + word.substring(1)).join("");
  }
}
CamelCaseAction.wordBoundary = new BackwardsCompatibleRegExp("[_\\s-]", "gm");
class KebabCaseAction extends AbstractCaseAction {
  static isSupported() {
    const areAllRegexpsSupported = [
      this.caseBoundary,
      this.singleLetters,
      this.underscoreBoundary
    ].every((regexp) => regexp.isSupported());
    return areAllRegexpsSupported;
  }
  constructor() {
    super({
      id: "editor.action.transformToKebabcase",
      label: localize("editor.transformToKebabcase", "Transform to Kebab Case"),
      alias: "Transform to Kebab Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, _) {
    const caseBoundary = KebabCaseAction.caseBoundary.get();
    const singleLetters = KebabCaseAction.singleLetters.get();
    const underscoreBoundary = KebabCaseAction.underscoreBoundary.get();
    if (!caseBoundary || !singleLetters || !underscoreBoundary) {
      return text;
    }
    return text.replace(underscoreBoundary, "$1-$3").replace(caseBoundary, "$1-$2").replace(singleLetters, "$1-$2").toLocaleLowerCase();
  }
}
KebabCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
KebabCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu}\\p{Ll})", "gmu");
KebabCaseAction.underscoreBoundary = new BackwardsCompatibleRegExp("(\\S)(_)(\\S)", "gm");
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(DuplicateSelectionAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(DeleteDuplicateLinesAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);
if (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) {
  registerEditorAction(SnakeCaseAction);
}
if (CamelCaseAction.wordBoundary.isSupported()) {
  registerEditorAction(CamelCaseAction);
}
if (TitleCaseAction.titleBoundary.isSupported()) {
  registerEditorAction(TitleCaseAction);
}
if (KebabCaseAction.isSupported()) {
  registerEditorAction(KebabCaseAction);
}
const linkedEditing = "";
var __decorate$h = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$h = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("LinkedEditingInputVisible", false);
const DECORATION_CLASS_NAME = "linked-editing-decoration";
let LinkedEditingContribution = class LinkedEditingContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkedEditingContribution2.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService, languageConfigurationService, languageFeatureDebounceService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._syncRangesToken = 0;
    this._localToDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._providers = languageFeaturesService.linkedEditingRangeProvider;
    this._enabled = false;
    this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._debounceInformation = languageFeatureDebounceService.for(this._providers, "Linked Editing", { max: 200 });
    this._currentDecorations = this._editor.createDecorationsCollection();
    this._languageWordPattern = null;
    this._currentWordPattern = null;
    this._ignoreChangeEvent = false;
    this._localToDispose = this._register(new DisposableStore());
    this._rangeUpdateTriggerPromise = null;
    this._rangeSyncTriggerPromise = null;
    this._currentRequest = null;
    this._currentRequestPosition = null;
    this._currentRequestModelVersion = null;
    this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        68
        /* EditorOption.linkedEditing */
      ) || e.hasChanged(
        91
        /* EditorOption.renameOnType */
      )) {
        this.reinitialize(false);
      }
    }));
    this._register(this._providers.onDidChange(() => this.reinitialize(false)));
    this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));
    this.reinitialize(true);
  }
  reinitialize(forceRefresh) {
    const model = this._editor.getModel();
    const isEnabled = model !== null && (this._editor.getOption(
      68
      /* EditorOption.linkedEditing */
    ) || this._editor.getOption(
      91
      /* EditorOption.renameOnType */
    )) && this._providers.has(model);
    if (isEnabled === this._enabled && !forceRefresh) {
      return;
    }
    this._enabled = isEnabled;
    this.clearRanges();
    this._localToDispose.clear();
    if (!isEnabled || model === null) {
      return;
    }
    this._localToDispose.add(Event.runAndSubscribe(model.onDidChangeLanguageConfiguration, () => {
      this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
    }));
    const rangeUpdateScheduler = new Delayer(this._debounceInformation.get(model));
    const triggerRangeUpdate = () => {
      var _a3;
      this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), (_a3 = this._debounceDuration) !== null && _a3 !== void 0 ? _a3 : this._debounceInformation.get(model));
    };
    const rangeSyncScheduler = new Delayer(0);
    const triggerRangeSync = (token) => {
      this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(token));
    };
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      triggerRangeUpdate();
    }));
    this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (!this._ignoreChangeEvent) {
        if (this._currentDecorations.length > 0) {
          const referenceRange = this._currentDecorations.getRange(0);
          if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
            triggerRangeSync(this._syncRangesToken);
            return;
          }
        }
      }
      triggerRangeUpdate();
    }));
    this._localToDispose.add({
      dispose: () => {
        rangeUpdateScheduler.dispose();
        rangeSyncScheduler.dispose();
      }
    });
    this.updateRanges();
  }
  _syncRanges(token) {
    if (!this._editor.hasModel() || token !== this._syncRangesToken || this._currentDecorations.length === 0) {
      return;
    }
    const model = this._editor.getModel();
    const referenceRange = this._currentDecorations.getRange(0);
    if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {
      return this.clearRanges();
    }
    const referenceValue = model.getValueInRange(referenceRange);
    if (this._currentWordPattern) {
      const match2 = referenceValue.match(this._currentWordPattern);
      const matchLength = match2 ? match2[0].length : 0;
      if (matchLength !== referenceValue.length) {
        return this.clearRanges();
      }
    }
    const edits = [];
    for (let i = 1, len = this._currentDecorations.length; i < len; i++) {
      const mirrorRange = this._currentDecorations.getRange(i);
      if (!mirrorRange) {
        continue;
      }
      if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {
        edits.push({
          range: mirrorRange,
          text: referenceValue
        });
      } else {
        let oldValue = model.getValueInRange(mirrorRange);
        let newValue = referenceValue;
        let rangeStartColumn = mirrorRange.startColumn;
        let rangeEndColumn = mirrorRange.endColumn;
        const commonPrefixLength$1 = commonPrefixLength(oldValue, newValue);
        rangeStartColumn += commonPrefixLength$1;
        oldValue = oldValue.substr(commonPrefixLength$1);
        newValue = newValue.substr(commonPrefixLength$1);
        const commonSuffixLength$1 = commonSuffixLength(oldValue, newValue);
        rangeEndColumn -= commonSuffixLength$1;
        oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength$1);
        newValue = newValue.substr(0, newValue.length - commonSuffixLength$1);
        if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {
          edits.push({
            range: new Range$1(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
            text: newValue
          });
        }
      }
    }
    if (edits.length === 0) {
      return;
    }
    try {
      this._editor.popUndoStop();
      this._ignoreChangeEvent = true;
      const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
      this._editor.executeEdits("linkedEditing", edits);
      this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
  dispose() {
    this.clearRanges();
    super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(false);
    this._currentDecorations.clear();
    if (this._currentRequest) {
      this._currentRequest.cancel();
      this._currentRequest = null;
      this._currentRequestPosition = null;
    }
  }
  get currentUpdateTriggerPromise() {
    return this._rangeUpdateTriggerPromise || Promise.resolve();
  }
  get currentSyncTriggerPromise() {
    return this._rangeSyncTriggerPromise || Promise.resolve();
  }
  updateRanges(force = false) {
    return __awaiter$e(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        this.clearRanges();
        return;
      }
      const position = this._editor.getPosition();
      if (!this._enabled && !force || this._editor.getSelections().length > 1) {
        this.clearRanges();
        return;
      }
      const model = this._editor.getModel();
      const modelVersionId = model.getVersionId();
      if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
        if (position.equals(this._currentRequestPosition)) {
          return;
        }
        if (this._currentDecorations.length > 0) {
          const range = this._currentDecorations.getRange(0);
          if (range && range.containsPosition(position)) {
            return;
          }
        }
      }
      this.clearRanges();
      this._currentRequestPosition = position;
      this._currentRequestModelVersion = modelVersionId;
      const request = createCancelablePromise((token) => __awaiter$e(this, void 0, void 0, function* () {
        try {
          const sw = new StopWatch(false);
          const response = yield getLinkedEditingRanges(this._providers, model, position, token);
          this._debounceInformation.update(model, sw.elapsed());
          if (request !== this._currentRequest) {
            return;
          }
          this._currentRequest = null;
          if (modelVersionId !== model.getVersionId()) {
            return;
          }
          let ranges = [];
          if (response === null || response === void 0 ? void 0 : response.ranges) {
            ranges = response.ranges;
          }
          this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
          let foundReferenceRange = false;
          for (let i = 0, len = ranges.length; i < len; i++) {
            if (Range$1.containsPosition(ranges[i], position)) {
              foundReferenceRange = true;
              if (i !== 0) {
                const referenceRange = ranges[i];
                ranges.splice(i, 1);
                ranges.unshift(referenceRange);
              }
              break;
            }
          }
          if (!foundReferenceRange) {
            this.clearRanges();
            return;
          }
          const decorations = ranges.map((range) => ({ range, options: LinkedEditingContribution2.DECORATION }));
          this._visibleContextKey.set(true);
          this._currentDecorations.set(decorations);
          this._syncRangesToken++;
        } catch (err) {
          if (!isCancellationError(err)) {
            onUnexpectedError(err);
          }
          if (this._currentRequest === request || !this._currentRequest) {
            this.clearRanges();
          }
        }
      }));
      this._currentRequest = request;
      return request;
    });
  }
  // for testing
  setDebounceDuration(timeInMS) {
    this._debounceDuration = timeInMS;
  }
};
LinkedEditingContribution.ID = "editor.contrib.linkedEditing";
LinkedEditingContribution.DECORATION = ModelDecorationOptions.register({
  description: "linked-editing",
  stickiness: 0,
  className: DECORATION_CLASS_NAME
});
LinkedEditingContribution = __decorate$h([
  __param$h(1, IContextKeyService),
  __param$h(2, ILanguageFeaturesService),
  __param$h(3, ILanguageConfigurationService),
  __param$h(4, ILanguageFeatureDebounceService)
], LinkedEditingContribution);
class LinkedEditingAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.linkedEditing",
      label: localize("linkedEditing.label", "Start Linked Editing"),
      alias: "Start Linked Editing",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI$1.isUri(uri) && Position$1.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(_accessor, editor2) {
    const controller = LinkedEditingContribution.get(editor2);
    if (controller) {
      return Promise.resolve(controller.updateRanges(true));
    }
    return Promise.resolve();
  }
}
const LinkedEditingCommand = EditorCommand.bindToContribution(LinkedEditingContribution.get);
registerEditorCommand(new LinkedEditingCommand({
  id: "cancelLinkedEditingInput",
  precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
  handler: (x) => x.clearRanges(),
  kbOpts: {
    kbExpr: EditorContextKeys.editorTextFocus,
    weight: 100 + 99,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
function getLinkedEditingRanges(providers, model, position, token) {
  const orderedByScore = providers.ordered(model);
  return first(orderedByScore.map((provider) => () => __awaiter$e(this, void 0, void 0, function* () {
    try {
      return yield provider.provideLinkedEditingRanges(model, position, token);
    } catch (e) {
      onUnexpectedExternalError(e);
      return void 0;
    }
  })), (result) => !!result && isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
}
registerColor("editor.linkedEditingBackground", { dark: Color$1.fromHex("#f00").transparent(0.3), light: Color$1.fromHex("#f00").transparent(0.3), hcDark: Color$1.fromHex("#f00").transparent(0.3), hcLight: Color$1.white }, localize("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
registerModelAndPositionCommand("_executeLinkedEditingProvider", (_accessor, model, position) => {
  const { linkedEditingRangeProvider } = _accessor.get(ILanguageFeaturesService);
  return getLinkedEditingRanges(linkedEditingRangeProvider, model, position, CancellationToken.None);
});
registerEditorContribution(
  LinkedEditingContribution.ID,
  LinkedEditingContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(LinkedEditingAction);
const links = "";
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Link {
  constructor(link, provider) {
    this._link = link;
    this._provider = provider;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  resolve(token) {
    return __awaiter$d(this, void 0, void 0, function* () {
      if (this._link.url) {
        return this._link.url;
      }
      if (typeof this._provider.resolveLink === "function") {
        return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
          this._link = value || this._link;
          if (this._link.url) {
            return this.resolve(token);
          }
          return Promise.reject(new Error("missing"));
        });
      }
      return Promise.reject(new Error("missing"));
    });
  }
}
class LinksList {
  constructor(tuples) {
    this._disposables = new DisposableStore();
    let links2 = [];
    for (const [list, provider] of tuples) {
      const newLinks = list.links.map((link) => new Link(link, provider));
      links2 = LinksList._union(links2, newLinks);
      if (isDisposable(list)) {
        this._disposables.add(list);
      }
    }
    this.links = links2;
  }
  dispose() {
    this._disposables.dispose();
    this.links.length = 0;
  }
  static _union(oldLinks, newLinks) {
    const result = [];
    let oldIndex;
    let oldLen;
    let newIndex;
    let newLen;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen; ) {
      const oldLink = oldLinks[oldIndex];
      const newLink = newLinks[newIndex];
      if (Range$1.areIntersectingOrTouching(oldLink.range, newLink.range)) {
        oldIndex++;
        continue;
      }
      const comparisonResult = Range$1.compareRangesUsingStarts(oldLink.range, newLink.range);
      if (comparisonResult < 0) {
        result.push(oldLink);
        oldIndex++;
      } else {
        result.push(newLink);
        newIndex++;
      }
    }
    for (; oldIndex < oldLen; oldIndex++) {
      result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
      result.push(newLinks[newIndex]);
    }
    return result;
  }
}
function getLinks(providers, model, token) {
  const lists = [];
  const promises = providers.ordered(model).reverse().map((provider, i) => {
    return Promise.resolve(provider.provideLinks(model, token)).then((result) => {
      if (result) {
        lists[i] = [result, provider];
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    const result = new LinksList(coalesce(lists));
    if (!token.isCancellationRequested) {
      return result;
    }
    result.dispose();
    return new LinksList([]);
  });
}
CommandsRegistry.registerCommand("_executeLinkProvider", (accessor, ...args) => __awaiter$d(void 0, void 0, void 0, function* () {
  let [uri, resolveCount] = args;
  assertType(uri instanceof URI$1);
  if (typeof resolveCount !== "number") {
    resolveCount = 0;
  }
  const { linkProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return [];
  }
  const list = yield getLinks(linkProvider, model, CancellationToken.None);
  if (!list) {
    return [];
  }
  for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) {
    yield list.links[i].resolve(CancellationToken.None);
  }
  const result = list.links.slice(0);
  list.dispose();
  return result;
}));
var __decorate$g = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$g = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let LinkDetector = class LinkDetector2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkDetector2.ID);
  }
  constructor(editor2, openerService, notificationService, languageFeaturesService, languageFeatureDebounceService) {
    super();
    this.editor = editor2;
    this.openerService = openerService;
    this.notificationService = notificationService;
    this.languageFeaturesService = languageFeaturesService;
    this.providers = this.languageFeaturesService.linkProvider;
    this.debounceInformation = languageFeatureDebounceService.for(this.providers, "Links", { min: 1e3, max: 4e3 });
    this.computeLinks = this._register(new RunOnceScheduler(() => this.computeLinksNow(), 1e3));
    this.computePromise = null;
    this.activeLinksList = null;
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    const clickLinkGesture = this._register(new ClickLinkGesture(editor2));
    this._register(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this._onEditorMouseMove(mouseEvent, keyboardEvent);
    }));
    this._register(clickLinkGesture.onExecute((e) => {
      this.onEditorMouseUp(e);
    }));
    this._register(clickLinkGesture.onCancel((e) => {
      this.cleanUpActiveLinkDecoration();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (!e.hasChanged(
        69
        /* EditorOption.links */
      )) {
        return;
      }
      this.updateDecorations([]);
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (!this.editor.hasModel()) {
        return;
      }
      this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelLanguage((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(this.providers.onDidChange((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this.computeLinks.schedule(0);
  }
  computeLinksNow() {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (!this.editor.hasModel() || !this.editor.getOption(
        69
        /* EditorOption.links */
      )) {
        return;
      }
      const model = this.editor.getModel();
      if (!this.providers.has(model)) {
        return;
      }
      if (this.activeLinksList) {
        this.activeLinksList.dispose();
        this.activeLinksList = null;
      }
      this.computePromise = createCancelablePromise((token) => getLinks(this.providers, model, token));
      try {
        const sw = new StopWatch(false);
        this.activeLinksList = yield this.computePromise;
        this.debounceInformation.update(model, sw.elapsed());
        if (model.isDisposed()) {
          return;
        }
        this.updateDecorations(this.activeLinksList.links);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        this.computePromise = null;
      }
    });
  }
  updateDecorations(links2) {
    const useMetaKey = this.editor.getOption(
      76
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    const oldDecorations = [];
    const keys = Object.keys(this.currentOccurrences);
    for (const decorationId of keys) {
      const occurence = this.currentOccurrences[decorationId];
      oldDecorations.push(occurence.decorationId);
    }
    const newDecorations = [];
    if (links2) {
      for (const link of links2) {
        newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
      }
    }
    this.editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      for (let i = 0, len = decorations.length; i < len; i++) {
        const occurence = new LinkOccurrence(links2[i], decorations[i]);
        this.currentOccurrences[occurence.decorationId] = occurence;
      }
    });
  }
  _onEditorMouseMove(mouseEvent, withKey) {
    const useMetaKey = this.editor.getOption(
      76
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.isEnabled(mouseEvent, withKey)) {
      this.cleanUpActiveLinkDecoration();
      const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.activate(changeAccessor, useMetaKey);
          this.activeLinkDecorationId = occurrence.decorationId;
        });
      }
    } else {
      this.cleanUpActiveLinkDecoration();
    }
  }
  cleanUpActiveLinkDecoration() {
    const useMetaKey = this.editor.getOption(
      76
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.activeLinkDecorationId) {
      const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.deactivate(changeAccessor, useMetaKey);
        });
      }
      this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(mouseEvent) {
    if (!this.isEnabled(mouseEvent)) {
      return;
    }
    const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
    if (!occurrence) {
      return;
    }
    this.openLinkOccurrence(
      occurrence,
      mouseEvent.hasSideBySideModifier,
      true
      /* from user gesture */
    );
  }
  openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
    if (!this.openerService) {
      return;
    }
    const { link } = occurrence;
    link.resolve(CancellationToken.None).then((uri) => {
      if (typeof uri === "string" && this.editor.hasModel()) {
        const modelUri = this.editor.getModel().uri;
        if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
          const parsedUri = URI$1.parse(uri);
          if (parsedUri.scheme === Schemas.file) {
            const fsPath = originalFSPath(parsedUri);
            let relativePath2 = null;
            if (fsPath.startsWith("/./")) {
              relativePath2 = `.${fsPath.substr(1)}`;
            } else if (fsPath.startsWith("//./")) {
              relativePath2 = `.${fsPath.substr(2)}`;
            }
            if (relativePath2) {
              uri = joinPath(modelUri, relativePath2);
            }
          }
        }
      }
      return this.openerService.open(uri, { openToSide, fromUserGesture, allowContributedOpeners: true, allowCommands: true, fromWorkspace: true });
    }, (err) => {
      const messageOrError = err instanceof Error ? err.message : err;
      if (messageOrError === "invalid") {
        this.notificationService.warn(localize("invalid.url", "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
      } else if (messageOrError === "missing") {
        this.notificationService.warn(localize("missing.url", "Failed to open this link because its target is missing."));
      } else {
        onUnexpectedError(err);
      }
    });
  }
  getLinkOccurrence(position) {
    if (!this.editor.hasModel() || !position) {
      return null;
    }
    const decorations = this.editor.getModel().getDecorationsInRange({
      startLineNumber: position.lineNumber,
      startColumn: position.column,
      endLineNumber: position.lineNumber,
      endColumn: position.column
    }, 0, true);
    for (const decoration2 of decorations) {
      const currentOccurrence = this.currentOccurrences[decoration2.id];
      if (currentOccurrence) {
        return currentOccurrence;
      }
    }
    return null;
  }
  isEnabled(mouseEvent, withKey) {
    return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
  }
  stop() {
    var _a3;
    this.computeLinks.cancel();
    if (this.activeLinksList) {
      (_a3 = this.activeLinksList) === null || _a3 === void 0 ? void 0 : _a3.dispose();
      this.activeLinksList = null;
    }
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    super.dispose();
    this.stop();
  }
};
LinkDetector.ID = "editor.linkDetector";
LinkDetector = __decorate$g([
  __param$g(1, IOpenerService),
  __param$g(2, INotificationService),
  __param$g(3, ILanguageFeaturesService),
  __param$g(4, ILanguageFeatureDebounceService)
], LinkDetector);
const decoration = {
  general: ModelDecorationOptions.register({
    description: "detected-link",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link"
  }),
  active: ModelDecorationOptions.register({
    description: "detected-link-active",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link-active"
  })
};
class LinkOccurrence {
  static decoration(link, useMetaKey) {
    return {
      range: link.range,
      options: LinkOccurrence._getOptions(link, useMetaKey, false)
    };
  }
  static _getOptions(link, useMetaKey, isActive) {
    const options = Object.assign({}, isActive ? decoration.active : decoration.general);
    options.hoverMessage = getHoverMessage(link, useMetaKey);
    return options;
  }
  constructor(link, decorationId) {
    this.link = link;
    this.decorationId = decorationId;
  }
  activate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));
  }
  deactivate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));
  }
}
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localize("links.navigate.executeCmd", "Execute command") : localize("links.navigate.follow", "Follow link");
  const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
  if (link.url) {
    let nativeLabel = "";
    if (/^command:/i.test(link.url.toString())) {
      const match2 = link.url.toString().match(/^command:([^?#]+)/);
      if (match2) {
        const commandId = match2[1];
        nativeLabel = localize("tooltip.explanation", "Execute command {0}", commandId);
      }
    }
    const hoverMessage = new MarkdownString("", true).appendLink(link.url.toString(true).replace(/ /g, "%20"), label, nativeLabel).appendMarkdown(` (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
class OpenLinkAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: localize("label", "Open Link"),
      alias: "Open Link",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const linkDetector = LinkDetector.get(editor2);
    if (!linkDetector) {
      return;
    }
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    for (const sel of selections) {
      const link = linkDetector.getLinkOccurrence(sel.getEndPosition());
      if (link) {
        linkDetector.openLinkOccurrence(link, false);
      }
    }
  }
}
registerEditorContribution(
  LinkDetector.ID,
  LinkDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(OpenLinkAction);
class LongLinesHelper extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LongLinesHelper.ID);
  }
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(this._editor.onMouseDown((e) => {
      const stopRenderingLineAfter = this._editor.getOption(
        115
        /* EditorOption.stopRenderingLineAfter */
      );
      if (stopRenderingLineAfter >= 0 && e.target.type === 6 && e.target.position.column >= stopRenderingLineAfter) {
        this._editor.updateOptions({
          stopRenderingLineAfter: -1
        });
      }
    }));
  }
}
LongLinesHelper.ID = "editor.contrib.longLinesHelper";
registerEditorContribution(
  LongLinesHelper.ID,
  LongLinesHelper,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
const highlightDecorations = "";
const wordHighlightBackground = registerColor("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hcDark: null, hcLight: null }, localize("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hcDark: null, hcLight: null }, localize("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightTextBackground", { light: wordHighlightBackground, dark: wordHighlightBackground, hcDark: wordHighlightBackground, hcLight: wordHighlightBackground }, localize("wordHighlightText", "Background color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), true);
const wordHighlightBorder = registerColor("editor.wordHighlightBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
registerColor("editor.wordHighlightStrongBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
registerColor("editor.wordHighlightTextBorder", { light: wordHighlightBorder, dark: wordHighlightBorder, hcDark: wordHighlightBorder, hcLight: wordHighlightBorder }, localize("wordHighlightTextBorder", "Border color of a textual occurrence for a symbol."));
const overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, localize("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
const overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hcDark: "#C0A0C0CC", hcLight: "#C0A0C0CC" }, localize("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
const overviewRulerWordHighlightTextForeground = registerColor("editorOverviewRuler.wordHighlightTextForeground", { dark: overviewRulerSelectionHighlightForeground, light: overviewRulerSelectionHighlightForeground, hcDark: overviewRulerSelectionHighlightForeground, hcLight: overviewRulerSelectionHighlightForeground }, localize("overviewRulerWordHighlightTextForeground", "Overview ruler marker color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), true);
const _WRITE_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-strong",
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
const _TEXT_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-text",
  stickiness: 1,
  className: "wordHighlightText",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightTextForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
const _SELECTION_HIGHLIGHT_OPTIONS = ModelDecorationOptions.register({
  description: "selection-highlight-overview",
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
const _SELECTION_HIGHLIGHT_OPTIONS_NO_OVERVIEW = ModelDecorationOptions.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight"
});
const _REGULAR_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight",
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
function getHighlightDecorationOptions(kind) {
  if (kind === DocumentHighlightKind$1.Write) {
    return _WRITE_OPTIONS;
  } else if (kind === DocumentHighlightKind$1.Text) {
    return _TEXT_OPTIONS;
  } else {
    return _REGULAR_OPTIONS;
  }
}
function getSelectionHighlightDecorationOptions(hasSemanticHighlights) {
  return hasSemanticHighlights ? _SELECTION_HIGHLIGHT_OPTIONS_NO_OVERVIEW : _SELECTION_HIGHLIGHT_OPTIONS;
}
registerThemingParticipant((theme, collector) => {
  const selectionHighlight = theme.getColor(editorSelectionHighlight);
  if (selectionHighlight) {
    collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);
  }
});
var __decorate$f = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$f = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function announceCursorChange(previousCursorState, cursorState) {
  const cursorDiff = cursorState.filter((cs) => !previousCursorState.find((pcs) => pcs.equals(cs)));
  if (cursorDiff.length >= 1) {
    const cursorPositions = cursorDiff.map((cs) => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(", ");
    const msg = cursorDiff.length === 1 ? localize("cursorAdded", "Cursor added: {0}", cursorPositions) : localize("cursorsAdded", "Cursors added: {0}", cursorPositions);
    status(msg);
  }
}
class InsertCursorAbove extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: localize("mutlicursor.insertAbove", "Add Cursor Above"),
      alias: "Add Cursor Above",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 16,
        linux: {
          primary: 1024 | 512 | 16,
          secondary: [
            2048 | 1024 | 16
            /* KeyCode.UpArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealTopMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
}
class InsertCursorBelow extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: localize("mutlicursor.insertBelow", "Add Cursor Below"),
      alias: "Add Cursor Below",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 18,
        linux: {
          primary: 1024 | 512 | 18,
          secondary: [
            2048 | 1024 | 18
            /* KeyCode.DownArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealBottomMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
}
class InsertCursorAtEndOfEachLineSelected extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: localize("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
      alias: "Add Cursors to Line Ends",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 39,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(selection, model, result) {
    if (selection.isEmpty()) {
      return;
    }
    for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {
      const currentLineMaxColumn = model.getLineMaxColumn(i);
      result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));
    }
    if (selection.endColumn > 1) {
      result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
    }
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    const newSelections = [];
    selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
}
class InsertCursorAtEndOfLineSelected extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: localize("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
      alias: "Add Cursors To Bottom",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const lineCount = editor2.getModel().getLineCount();
    const newSelections = [];
    for (let i = selections[0].startLineNumber; i <= lineCount; i++) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
}
class InsertCursorAtTopOfLineSelected extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: localize("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
      alias: "Add Cursors To Top",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const newSelections = [];
    for (let i = selections[0].startLineNumber; i >= 1; i--) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
}
class MultiCursorSessionResult {
  constructor(selections, revealRange, revealScrollType) {
    this.selections = selections;
    this.revealRange = revealRange;
    this.revealScrollType = revealScrollType;
  }
}
class MultiCursorSession {
  static create(editor2, findController) {
    if (!editor2.hasModel()) {
      return null;
    }
    const findState = findController.getState();
    if (!editor2.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {
      return new MultiCursorSession(editor2, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
    }
    let isDisconnectedFromFindController = false;
    let wholeWord;
    let matchCase;
    const selections = editor2.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      isDisconnectedFromFindController = true;
      wholeWord = true;
      matchCase = true;
    } else {
      wholeWord = findState.wholeWord;
      matchCase = findState.matchCase;
    }
    const s = editor2.getSelection();
    let searchText;
    let currentMatch = null;
    if (s.isEmpty()) {
      const word = editor2.getConfiguredWordAtPosition(s.getStartPosition());
      if (!word) {
        return null;
      }
      searchText = word.word;
      currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
    } else {
      searchText = editor2.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
    }
    return new MultiCursorSession(editor2, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
  }
  constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
    this._editor = _editor;
    this.findController = findController;
    this.isDisconnectedFromFindController = isDisconnectedFromFindController;
    this.searchText = searchText;
    this.wholeWord = wholeWord;
    this.matchCase = matchCase;
    this.currentMatch = currentMatch;
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.concat(nextMatch),
      nextMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.slice(0, allSelections.length - 1).concat(nextMatch),
      nextMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  _getNextMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (!nextMatch) {
      return null;
    }
    return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.concat(previousMatch),
      previousMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.slice(0, allSelections.length - 1).concat(previousMatch),
      previousMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (!previousMatch) {
      return null;
    }
    return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
  }
  selectAll(searchScope) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this.findController.highlightFindOptions();
    const editorModel = this._editor.getModel();
    if (searchScope) {
      return editorModel.findMatches(
        this.searchText,
        searchScope,
        false,
        this.matchCase,
        this.wholeWord ? this._editor.getOption(
          128
          /* EditorOption.wordSeparators */
        ) : null,
        false,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      );
    }
    return editorModel.findMatches(
      this.searchText,
      true,
      false,
      this.matchCase,
      this.wholeWord ? this._editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ) : null,
      false,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
  }
}
class MultiCursorSelectionController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(MultiCursorSelectionController.ID);
  }
  constructor(editor2) {
    super();
    this._sessionDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._ignoreSelectionChange = false;
    this._session = null;
  }
  dispose() {
    this._endSession();
    super.dispose();
  }
  _beginSessionIfNeeded(findController) {
    if (!this._session) {
      const session = MultiCursorSession.create(this._editor, findController);
      if (!session) {
        return;
      }
      this._session = session;
      const newState = { searchString: this._session.searchText };
      if (this._session.isDisconnectedFromFindController) {
        newState.wholeWordOverride = 1;
        newState.matchCaseOverride = 1;
        newState.isRegexOverride = 2;
      }
      findController.getState().change(newState, false);
      this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
        if (this._ignoreSelectionChange) {
          return;
        }
        this._endSession();
      }));
      this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      }));
      this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
        if (e.matchCase || e.wholeWord) {
          this._endSession();
        }
      }));
    }
  }
  _endSession() {
    this._sessionDispose.clear();
    if (this._session && this._session.isDisconnectedFromFindController) {
      const newState = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(newState, false);
    }
    this._session = null;
  }
  _setSelections(selections) {
    this._ignoreSelectionChange = true;
    this._editor.setSelections(selections);
    this._ignoreSelectionChange = false;
  }
  _expandEmptyToWord(model, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
    if (!word) {
      return selection;
    }
    return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
  }
  _applySessionResult(result) {
    if (!result) {
      return;
    }
    this._setSelections(result.selections);
    if (result.revealRange) {
      this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
    }
  }
  getSession(findController) {
    return this._session;
  }
  addSelectionToNextFindMatch(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._session) {
      const allSelections = this._editor.getSelections();
      if (allSelections.length > 1) {
        const findState = findController.getState();
        const matchCase = findState.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          const model = this._editor.getModel();
          const resultingSelections = [];
          for (let i = 0, len = allSelections.length; i < len; i++) {
            resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
          }
          this._editor.setSelections(resultingSelections);
          return;
        }
      }
    }
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
    }
  }
  moveSelectionToNextFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToNextFindMatch());
    }
  }
  moveSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
    }
  }
  selectAll(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    let matches = null;
    const findState = findController.getState();
    if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
      const editorModel = this._editor.getModel();
      if (findState.searchScope) {
        matches = editorModel.findMatches(
          findState.searchString,
          findState.searchScope,
          findState.isRegex,
          findState.matchCase,
          findState.wholeWord ? this._editor.getOption(
            128
            /* EditorOption.wordSeparators */
          ) : null,
          false,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        );
      } else {
        matches = editorModel.findMatches(
          findState.searchString,
          true,
          findState.isRegex,
          findState.matchCase,
          findState.wholeWord ? this._editor.getOption(
            128
            /* EditorOption.wordSeparators */
          ) : null,
          false,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        );
      }
    } else {
      this._beginSessionIfNeeded(findController);
      if (!this._session) {
        return;
      }
      matches = this._session.selectAll(findState.searchScope);
    }
    if (matches.length > 0) {
      const editorSelection = this._editor.getSelection();
      for (let i = 0, len = matches.length; i < len; i++) {
        const match2 = matches[i];
        const intersection = match2.range.intersectRanges(editorSelection);
        if (intersection) {
          matches[i] = matches[0];
          matches[0] = match2;
          break;
        }
      }
      this._setSelections(matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
    }
  }
  selectAllUsingSelections(selections) {
    if (selections.length > 0) {
      this._setSelections(selections);
    }
  }
}
MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
class MultiCursorSelectionControllerAction extends EditorAction {
  run(accessor, editor2) {
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel) {
      const previousCursorState = viewModel.getCursorStates();
      const findController = CommonFindController.get(editor2);
      if (findController) {
        this._run(multiCursorController, findController);
      } else {
        const newFindController = accessor.get(IInstantiationService).createInstance(CommonFindController, editor2);
        this._run(multiCursorController, newFindController);
        newFindController.dispose();
      }
      announceCursorChange(previousCursorState, viewModel.getCursorStates());
    }
  }
}
class AddSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: localize("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
      alias: "Add Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 34,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToNextFindMatch(findController);
  }
}
class AddSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: localize("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
      alias: "Add Selection To Previous Find Match",
      precondition: void 0,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToPreviousFindMatch(findController);
  }
}
class MoveSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: localize("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
      alias: "Move Last Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: KeyChord(
          2048 | 41,
          2048 | 34
          /* KeyCode.KeyD */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToNextFindMatch(findController);
  }
}
class MoveSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: localize("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
      alias: "Move Last Selection To Previous Find Match",
      precondition: void 0
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToPreviousFindMatch(findController);
  }
}
class SelectHighlightsAction extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: localize("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
      alias: "Select All Occurrences of Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 42,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
}
class CompatChangeAll extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: localize("changeAll.label", "Change All Occurrences"),
      alias: "Change All Occurrences",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
}
class SelectionHighlighterState {
  constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {
    this._model = _model;
    this._searchText = _searchText;
    this._matchCase = _matchCase;
    this._wordSeparators = _wordSeparators;
    this._modelVersionId = this._model.getVersionId();
    this._cachedFindMatches = null;
    if (prevState && this._model === prevState._model && this._searchText === prevState._searchText && this._matchCase === prevState._matchCase && this._wordSeparators === prevState._wordSeparators && this._modelVersionId === prevState._modelVersionId) {
      this._cachedFindMatches = prevState._cachedFindMatches;
    }
  }
  findMatches() {
    if (this._cachedFindMatches === null) {
      this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map((m) => m.range);
      this._cachedFindMatches.sort(Range$1.compareRangesUsingStarts);
    }
    return this._cachedFindMatches;
  }
}
let SelectionHighlighter = class SelectionHighlighter2 extends Disposable {
  constructor(editor2, _languageFeaturesService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this.editor = editor2;
    this._isEnabled = editor2.getOption(
      106
      /* EditorOption.selectionHighlight */
    );
    this._decorations = editor2.createDecorationsCollection();
    this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
    this.state = null;
    this._register(editor2.onDidChangeConfiguration((e) => {
      this._isEnabled = editor2.getOption(
        106
        /* EditorOption.selectionHighlight */
      );
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (!this._isEnabled) {
        return;
      }
      if (e.selection.isEmpty()) {
        if (e.reason === 3) {
          if (this.state) {
            this._setState(null);
          }
          this.updateSoon.schedule();
        } else {
          this._setState(null);
        }
      } else {
        this._update();
      }
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._setState(null);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (this._isEnabled) {
        this.updateSoon.schedule();
      }
    }));
    const findController = CommonFindController.get(editor2);
    if (findController) {
      this._register(findController.getState().onFindReplaceStateChange((e) => {
        this._update();
      }));
    }
    this.updateSoon.schedule();
  }
  _update() {
    this._setState(SelectionHighlighter2._createState(this.state, this._isEnabled, this.editor));
  }
  static _createState(oldState, isEnabled, editor2) {
    if (!isEnabled) {
      return null;
    }
    if (!editor2.hasModel()) {
      return null;
    }
    const s = editor2.getSelection();
    if (s.startLineNumber !== s.endLineNumber) {
      return null;
    }
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return null;
    }
    const findController = CommonFindController.get(editor2);
    if (!findController) {
      return null;
    }
    let r = multiCursorController.getSession(findController);
    if (!r) {
      const allSelections = editor2.getSelections();
      if (allSelections.length > 1) {
        const findState2 = findController.getState();
        const matchCase = findState2.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(editor2.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          return null;
        }
      }
      r = MultiCursorSession.create(editor2, findController);
    }
    if (!r) {
      return null;
    }
    if (r.currentMatch) {
      return null;
    }
    if (/^[ \t]+$/.test(r.searchText)) {
      return null;
    }
    if (r.searchText.length > 200) {
      return null;
    }
    const findState = findController.getState();
    const caseSensitive = findState.matchCase;
    if (findState.isRevealed) {
      let findStateSearchString = findState.searchString;
      if (!caseSensitive) {
        findStateSearchString = findStateSearchString.toLowerCase();
      }
      let mySearchString = r.searchText;
      if (!caseSensitive) {
        mySearchString = mySearchString.toLowerCase();
      }
      if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
        return null;
      }
    }
    return new SelectionHighlighterState(editor2.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ) : null, oldState);
  }
  _setState(newState) {
    this.state = newState;
    if (!this.state) {
      this._decorations.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForTokenization()) {
      return;
    }
    const allMatches = this.state.findMatches();
    const selections = this.editor.getSelections();
    selections.sort(Range$1.compareRangesUsingStarts);
    const matches = [];
    for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len; ) {
      const match2 = allMatches[i];
      if (j >= lenJ) {
        matches.push(match2);
        i++;
      } else {
        const cmp = Range$1.compareRangesUsingStarts(match2, selections[j]);
        if (cmp < 0) {
          if (selections[j].isEmpty() || !Range$1.areIntersecting(match2, selections[j])) {
            matches.push(match2);
          }
          i++;
        } else if (cmp > 0) {
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    const hasSemanticHighlights = this._languageFeaturesService.documentHighlightProvider.has(model) && this.editor.getOption(
      79
      /* EditorOption.occurrencesHighlight */
    );
    const decorations = matches.map((r) => {
      return {
        range: r,
        options: getSelectionHighlightDecorationOptions(hasSemanticHighlights)
      };
    });
    this._decorations.set(decorations);
  }
  dispose() {
    this._setState(null);
    super.dispose();
  }
};
SelectionHighlighter.ID = "editor.contrib.selectionHighlighter";
SelectionHighlighter = __decorate$f([
  __param$f(1, ILanguageFeaturesService)
], SelectionHighlighter);
function modelRangesContainSameText(model, ranges, matchCase) {
  const selectedText = getValueInRange(model, ranges[0], !matchCase);
  for (let i = 1, len = ranges.length; i < len; i++) {
    const range = ranges[i];
    if (range.isEmpty()) {
      return false;
    }
    const thisSelectedText = getValueInRange(model, range, !matchCase);
    if (selectedText !== thisSelectedText) {
      return false;
    }
  }
  return true;
}
function getValueInRange(model, range, toLowerCase) {
  const text = model.getValueInRange(range);
  return toLowerCase ? text.toLowerCase() : text;
}
class FocusNextCursor extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusNextCursor",
      label: localize("mutlicursor.focusNextCursor", "Focus Next Cursor"),
      description: {
        description: localize("mutlicursor.focusNextCursor.description", "Focuses the next cursor"),
        args: []
      },
      alias: "Focus Next Cursor",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.shift();
    if (!firstCursor) {
      return;
    }
    previousCursorState.push(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
}
class FocusPreviousCursor extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusPreviousCursor",
      label: localize("mutlicursor.focusPreviousCursor", "Focus Previous Cursor"),
      description: {
        description: localize("mutlicursor.focusPreviousCursor.description", "Focuses the previous cursor"),
        args: []
      },
      alias: "Focus Previous Cursor",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.pop();
    if (!firstCursor) {
      return;
    }
    previousCursorState.unshift(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
}
registerEditorContribution(
  MultiCursorSelectionController.ID,
  MultiCursorSelectionController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorContribution(
  SelectionHighlighter.ID,
  SelectionHighlighter,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);
registerEditorAction(InsertCursorAtEndOfLineSelected);
registerEditorAction(InsertCursorAtTopOfLineSelected);
registerEditorAction(FocusNextCursor);
registerEditorAction(FocusPreviousCursor);
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const Context = {
  Visible: new RawContextKey("parameterHintsVisible", false),
  MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
};
function provideSignatureHelp(registry, model, position, context, token) {
  return __awaiter$b(this, void 0, void 0, function* () {
    const supports = registry.ordered(model);
    for (const support of supports) {
      try {
        const result = yield support.provideSignatureHelp(model, position, token, context);
        if (result) {
          return result;
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }
    return void 0;
  });
}
CommandsRegistry.registerCommand("_executeSignatureHelpProvider", (accessor, ...args) => __awaiter$b(void 0, void 0, void 0, function* () {
  const [uri, position, triggerCharacter] = args;
  assertType(URI$1.isUri(uri));
  assertType(Position$1.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = yield provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position$1.lift(position), {
      triggerKind: SignatureHelpTriggerKind.Invoke,
      isRetrigger: false,
      triggerCharacter
    }, CancellationToken.None);
    if (!result) {
      return void 0;
    }
    setTimeout(() => result.dispose(), 0);
    return result.value;
  } finally {
    ref.dispose();
  }
}));
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ParameterHintState;
(function(ParameterHintState2) {
  ParameterHintState2.Default = {
    type: 0
    /* Type.Default */
  };
  class Pending {
    constructor(request, previouslyActiveHints) {
      this.request = request;
      this.previouslyActiveHints = previouslyActiveHints;
      this.type = 2;
    }
  }
  ParameterHintState2.Pending = Pending;
  class Active {
    constructor(hints) {
      this.hints = hints;
      this.type = 1;
    }
  }
  ParameterHintState2.Active = Active;
})(ParameterHintState || (ParameterHintState = {}));
class ParameterHintsModel extends Disposable {
  constructor(editor2, providers, delay = ParameterHintsModel.DEFAULT_DELAY) {
    super();
    this._onChangedHints = this._register(new Emitter());
    this.onChangedHints = this._onChangedHints.event;
    this.triggerOnType = false;
    this._state = ParameterHintState.Default;
    this._pendingTriggers = [];
    this._lastSignatureHelpResult = this._register(new MutableDisposable());
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    this.triggerId = 0;
    this.editor = editor2;
    this.providers = providers;
    this.throttledDelayer = new Delayer(delay);
    this._register(this.editor.onDidBlurEditorWidget(() => this.cancel()));
    this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
    this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
    this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
    this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
    this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
    this._register(this.providers.onDidChange(this.onModelChanged, this));
    this._register(this.editor.onDidType((text) => this.onDidType(text)));
    this.onEditorConfigurationChange();
    this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state.type === 2) {
      this._state.request.cancel();
    }
    this._state = value;
  }
  cancel(silent = false) {
    this.state = ParameterHintState.Default;
    this.throttledDelayer.cancel();
    if (!silent) {
      this._onChangedHints.fire(void 0);
    }
  }
  trigger(context, delay) {
    const model = this.editor.getModel();
    if (!model || !this.providers.has(model)) {
      return;
    }
    const triggerId = ++this.triggerId;
    this._pendingTriggers.push(context);
    this.throttledDelayer.trigger(() => {
      return this.doTrigger(triggerId);
    }, delay).catch(onUnexpectedError);
  }
  next() {
    if (this.state.type !== 1) {
      return;
    }
    const length2 = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const last = activeSignature % length2 === length2 - 1;
    const cycle = this.editor.getOption(
      84
      /* EditorOption.parameterHints */
    ).cycle;
    if ((length2 < 2 || last) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
  }
  previous() {
    if (this.state.type !== 1) {
      return;
    }
    const length2 = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const first2 = activeSignature === 0;
    const cycle = this.editor.getOption(
      84
      /* EditorOption.parameterHints */
    ).cycle;
    if ((length2 < 2 || first2) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(first2 && cycle ? length2 - 1 : activeSignature - 1);
  }
  updateActiveSignature(activeSignature) {
    if (this.state.type !== 1) {
      return;
    }
    this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature }));
    this._onChangedHints.fire(this.state.hints);
  }
  doTrigger(triggerId) {
    return __awaiter$a(this, void 0, void 0, function* () {
      const isRetrigger = this.state.type === 1 || this.state.type === 2;
      const activeSignatureHelp = this.getLastActiveHints();
      this.cancel(true);
      if (this._pendingTriggers.length === 0) {
        return false;
      }
      const context = this._pendingTriggers.reduce(mergeTriggerContexts);
      this._pendingTriggers = [];
      const triggerContext = {
        triggerKind: context.triggerKind,
        triggerCharacter: context.triggerCharacter,
        isRetrigger,
        activeSignatureHelp
      };
      if (!this.editor.hasModel()) {
        return false;
      }
      const model = this.editor.getModel();
      const position = this.editor.getPosition();
      this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(this.providers, model, position, triggerContext, token)), activeSignatureHelp);
      try {
        const result = yield this.state.request;
        if (triggerId !== this.triggerId) {
          result === null || result === void 0 ? void 0 : result.dispose();
          return false;
        }
        if (!result || !result.value.signatures || result.value.signatures.length === 0) {
          result === null || result === void 0 ? void 0 : result.dispose();
          this._lastSignatureHelpResult.clear();
          this.cancel();
          return false;
        } else {
          this.state = new ParameterHintState.Active(result.value);
          this._lastSignatureHelpResult.value = result;
          this._onChangedHints.fire(this.state.hints);
          return true;
        }
      } catch (error) {
        if (triggerId === this.triggerId) {
          this.state = ParameterHintState.Default;
        }
        onUnexpectedError(error);
        return false;
      }
    });
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return void 0;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel();
    this.triggerChars.clear();
    this.retriggerChars.clear();
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    for (const support of this.providers.ordered(model)) {
      for (const ch of support.signatureHelpTriggerCharacters || []) {
        if (ch.length) {
          const charCode = ch.charCodeAt(0);
          this.triggerChars.add(charCode);
          this.retriggerChars.add(charCode);
        }
      }
      for (const ch of support.signatureHelpRetriggerCharacters || []) {
        if (ch.length) {
          this.retriggerChars.add(ch.charCodeAt(0));
        }
      }
    }
  }
  onDidType(text) {
    if (!this.triggerOnType) {
      return;
    }
    const lastCharIndex = text.length - 1;
    const triggerCharCode = text.charCodeAt(lastCharIndex);
    if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {
      this.trigger({
        triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
        triggerCharacter: text.charAt(lastCharIndex)
      });
    }
  }
  onCursorChange(e) {
    if (e.source === "mouse") {
      this.cancel();
    } else if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onModelContentChange() {
    if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(
      84
      /* EditorOption.parameterHints */
    ).enabled;
    if (!this.triggerOnType) {
      this.cancel();
    }
  }
  dispose() {
    this.cancel(true);
    super.dispose();
  }
}
ParameterHintsModel.DEFAULT_DELAY = 120;
function mergeTriggerContexts(previous, current) {
  switch (current.triggerKind) {
    case SignatureHelpTriggerKind.Invoke:
      return current;
    case SignatureHelpTriggerKind.ContentChange:
      return previous;
    case SignatureHelpTriggerKind.TriggerCharacter:
    default:
      return current;
  }
}
const parameterHints = "";
var __decorate$e = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$e = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const $$1 = $$8;
const parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown, localize("parameterHintsNextIcon", "Icon for show next parameter hint."));
const parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp, localize("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
let ParameterHintsWidget = class ParameterHintsWidget2 extends Disposable {
  constructor(editor2, model, contextKeyService, openerService, languageService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.renderDisposeables = this._register(new DisposableStore());
    this.visible = false;
    this.announcedLabel = null;
    this.allowEditorOverflow = true;
    this.markdownRenderer = this._register(new MarkdownRenderer({ editor: editor2 }, languageService, openerService));
    this.keyVisible = Context.Visible.bindTo(contextKeyService);
    this.keyMultipleSignatures = Context.MultipleSignatures.bindTo(contextKeyService);
  }
  createParameterHintDOMNodes() {
    const element = $$1(".editor-widget.parameter-hints-widget");
    const wrapper = append(element, $$1(".phwrapper"));
    wrapper.tabIndex = -1;
    const controls = append(wrapper, $$1(".controls"));
    const previous = append(controls, $$1(".button" + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
    const overloads = append(controls, $$1(".overloads"));
    const next = append(controls, $$1(".button" + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
    this._register(addDisposableListener(previous, "click", (e) => {
      EventHelper.stop(e);
      this.previous();
    }));
    this._register(addDisposableListener(next, "click", (e) => {
      EventHelper.stop(e);
      this.next();
    }));
    const body = $$1(".body");
    const scrollbar = new DomScrollableElement(body, {
      alwaysConsumeMouseWheel: true
    });
    this._register(scrollbar);
    wrapper.appendChild(scrollbar.getDomNode());
    const signature = append(body, $$1(".signature"));
    const docs = append(body, $$1(".docs"));
    element.style.userSelect = "text";
    this.domNodes = {
      element,
      signature,
      overloads,
      docs,
      scrollbar
    };
    this.editor.addContentWidget(this);
    this.hide();
    this._register(this.editor.onDidChangeCursorSelection((e) => {
      if (this.visible) {
        this.editor.layoutContentWidget(this);
      }
    }));
    const updateFont = () => {
      if (!this.domNodes) {
        return;
      }
      const fontInfo = this.editor.getOption(
        49
        /* EditorOption.fontInfo */
      );
      this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
      this.domNodes.element.style.lineHeight = `${fontInfo.lineHeight / fontInfo.fontSize}`;
    };
    updateFont();
    this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(
      49
      /* EditorOption.fontInfo */
    )).on(updateFont, null));
    this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
    this.updateMaxHeight();
  }
  show() {
    if (this.visible) {
      return;
    }
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    this.keyVisible.set(true);
    this.visible = true;
    setTimeout(() => {
      var _a3;
      (_a3 = this.domNodes) === null || _a3 === void 0 ? void 0 : _a3.element.classList.add("visible");
    }, 100);
    this.editor.layoutContentWidget(this);
  }
  hide() {
    var _a3;
    this.renderDisposeables.clear();
    if (!this.visible) {
      return;
    }
    this.keyVisible.reset();
    this.visible = false;
    this.announcedLabel = null;
    (_a3 = this.domNodes) === null || _a3 === void 0 ? void 0 : _a3.element.classList.remove("visible");
    this.editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this.visible) {
      return {
        position: this.editor.getPosition(),
        preference: [
          1,
          2
          /* ContentWidgetPositionPreference.BELOW */
        ]
      };
    }
    return null;
  }
  render(hints) {
    var _a3;
    this.renderDisposeables.clear();
    if (!this.domNodes) {
      return;
    }
    const multiple = hints.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", multiple);
    this.keyMultipleSignatures.set(multiple);
    this.domNodes.signature.innerText = "";
    this.domNodes.docs.innerText = "";
    const signature = hints.signatures[hints.activeSignature];
    if (!signature) {
      return;
    }
    const code = append(this.domNodes.signature, $$1(".code"));
    const fontInfo = this.editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    code.style.fontSize = `${fontInfo.fontSize}px`;
    code.style.fontFamily = fontInfo.fontFamily;
    const hasParameters = signature.parameters.length > 0;
    const activeParameterIndex = (_a3 = signature.activeParameter) !== null && _a3 !== void 0 ? _a3 : hints.activeParameter;
    if (!hasParameters) {
      const label = append(code, $$1("span"));
      label.textContent = signature.label;
    } else {
      this.renderParameters(code, signature, activeParameterIndex);
    }
    const activeParameter = signature.parameters[activeParameterIndex];
    if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
      const documentation = $$1("span.documentation");
      if (typeof activeParameter.documentation === "string") {
        documentation.textContent = activeParameter.documentation;
      } else {
        const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
        documentation.appendChild(renderedContents.element);
      }
      append(this.domNodes.docs, $$1("p", {}, documentation));
    }
    if (signature.documentation === void 0)
      ;
    else if (typeof signature.documentation === "string") {
      append(this.domNodes.docs, $$1("p", {}, signature.documentation));
    } else {
      const renderedContents = this.renderMarkdownDocs(signature.documentation);
      append(this.domNodes.docs, renderedContents.element);
    }
    const hasDocs = this.hasDocs(signature, activeParameter);
    this.domNodes.signature.classList.toggle("has-docs", hasDocs);
    this.domNodes.docs.classList.toggle("empty", !hasDocs);
    this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, "0") + "/" + hints.signatures.length;
    if (activeParameter) {
      let labelToAnnounce = "";
      const param = signature.parameters[activeParameterIndex];
      if (Array.isArray(param.label)) {
        labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
      } else {
        labelToAnnounce = param.label;
      }
      if (param.documentation) {
        labelToAnnounce += typeof param.documentation === "string" ? `, ${param.documentation}` : `, ${param.documentation.value}`;
      }
      if (signature.documentation) {
        labelToAnnounce += typeof signature.documentation === "string" ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
      }
      if (this.announcedLabel !== labelToAnnounce) {
        alert(localize("hint", "{0}, hint", labelToAnnounce));
        this.announcedLabel = labelToAnnounce;
      }
    }
    this.editor.layoutContentWidget(this);
    this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(markdown) {
    const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
      asyncRenderCallback: () => {
        var _a3;
        (_a3 = this.domNodes) === null || _a3 === void 0 ? void 0 : _a3.scrollbar.scanDomNode();
      }
    }));
    renderedContents.element.classList.add("markdown-docs");
    return renderedContents;
  }
  hasDocs(signature, activeParameter) {
    if (activeParameter && typeof activeParameter.documentation === "string" && assertIsDefined(activeParameter.documentation).length > 0) {
      return true;
    }
    if (activeParameter && typeof activeParameter.documentation === "object" && assertIsDefined(activeParameter.documentation).value.length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "string" && assertIsDefined(signature.documentation).length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "object" && assertIsDefined(signature.documentation.value).length > 0) {
      return true;
    }
    return false;
  }
  renderParameters(parent, signature, activeParameterIndex) {
    const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
    const beforeSpan = document.createElement("span");
    beforeSpan.textContent = signature.label.substring(0, start);
    const paramSpan = document.createElement("span");
    paramSpan.textContent = signature.label.substring(start, end);
    paramSpan.className = "parameter active";
    const afterSpan = document.createElement("span");
    afterSpan.textContent = signature.label.substring(end);
    append(parent, beforeSpan, paramSpan, afterSpan);
  }
  getParameterLabelOffsets(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (!param) {
      return [0, 0];
    } else if (Array.isArray(param.label)) {
      return param.label;
    } else if (!param.label.length) {
      return [0, 0];
    } else {
      const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, "g");
      regex.test(signature.label);
      const idx = regex.lastIndex - param.label.length;
      return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
    }
  }
  next() {
    this.editor.focus();
    this.model.next();
  }
  previous() {
    this.editor.focus();
    this.model.previous();
  }
  getDomNode() {
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    return this.domNodes.element;
  }
  getId() {
    return ParameterHintsWidget2.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes) {
      return;
    }
    const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
    const maxHeight = `${height}px`;
    this.domNodes.element.style.maxHeight = maxHeight;
    const wrapper = this.domNodes.element.getElementsByClassName("phwrapper");
    if (wrapper.length) {
      wrapper[0].style.maxHeight = maxHeight;
    }
  }
};
ParameterHintsWidget.ID = "editor.widget.parameterHintsWidget";
ParameterHintsWidget = __decorate$e([
  __param$e(2, IContextKeyService),
  __param$e(3, IOpenerService),
  __param$e(4, ILanguageService)
], ParameterHintsWidget);
registerColor("editorHoverWidget.highlightForeground", { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, localize("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));
var __decorate$d = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$d = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let ParameterHintsController = class ParameterHintsController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(ParameterHintsController2.ID);
  }
  constructor(editor2, instantiationService, languageFeaturesService) {
    super();
    this.editor = editor2;
    this.model = this._register(new ParameterHintsModel(editor2, languageFeaturesService.signatureHelpProvider));
    this._register(this.model.onChangedHints((newParameterHints) => {
      var _a3;
      if (newParameterHints) {
        this.widget.value.show();
        this.widget.value.render(newParameterHints);
      } else {
        (_a3 = this.widget.rawValue) === null || _a3 === void 0 ? void 0 : _a3.hide();
      }
    }));
    this.widget = new Lazy(() => this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor, this.model)));
  }
  cancel() {
    this.model.cancel();
  }
  previous() {
    var _a3;
    (_a3 = this.widget.rawValue) === null || _a3 === void 0 ? void 0 : _a3.previous();
  }
  next() {
    var _a3;
    (_a3 = this.widget.rawValue) === null || _a3 === void 0 ? void 0 : _a3.next();
  }
  trigger(context) {
    this.model.trigger(context, 0);
  }
};
ParameterHintsController.ID = "editor.controller.parameterHints";
ParameterHintsController = __decorate$d([
  __param$d(1, IInstantiationService),
  __param$d(2, ILanguageFeaturesService)
], ParameterHintsController);
class TriggerParameterHintsAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: localize("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: EditorContextKeys.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 10,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ParameterHintsController.get(editor2);
    controller === null || controller === void 0 ? void 0 : controller.trigger({
      triggerKind: SignatureHelpTriggerKind.Invoke
    });
  }
}
registerEditorContribution(
  ParameterHintsController.ID,
  ParameterHintsController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(TriggerParameterHintsAction);
const weight$1 = 100 + 75;
const ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
  id: "closeParameterHints",
  precondition: Context.Visible,
  handler: (x) => x.cancel(),
  kbOpts: {
    weight: weight$1,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showPrevParameterHint",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
  handler: (x) => x.previous(),
  kbOpts: {
    weight: weight$1,
    kbExpr: EditorContextKeys.focus,
    primary: 16,
    secondary: [
      512 | 16
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      512 | 16,
      256 | 46
      /* KeyCode.KeyP */
    ] }
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showNextParameterHint",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
  handler: (x) => x.next(),
  kbOpts: {
    weight: weight$1,
    kbExpr: EditorContextKeys.focus,
    primary: 18,
    secondary: [
      512 | 18
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      512 | 18,
      256 | 44
      /* KeyCode.KeyN */
    ] }
  }
}));
const renameInputField = "";
var __decorate$c = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$c = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false, localize("renameInputVisible", "Whether the rename input widget is visible"));
let RenameInputField = class RenameInputField2 {
  constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
    this._editor = _editor;
    this._acceptKeybindings = _acceptKeybindings;
    this._themeService = _themeService;
    this._keybindingService = _keybindingService;
    this._disposables = new DisposableStore();
    this.allowEditorOverflow = true;
    this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._editor.addContentWidget(this);
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        49
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    if (!this._domNode) {
      this._domNode = document.createElement("div");
      this._domNode.className = "monaco-editor rename-box";
      this._input = document.createElement("input");
      this._input.className = "rename-input";
      this._input.type = "text";
      this._input.setAttribute("aria-label", localize("renameAriaLabel", "Rename input. Type new name and press Enter to commit."));
      this._domNode.appendChild(this._input);
      this._label = document.createElement("div");
      this._label.className = "rename-label";
      this._domNode.appendChild(this._label);
      this._updateFont();
      this._updateStyles(this._themeService.getColorTheme());
    }
    return this._domNode;
  }
  _updateStyles(theme) {
    var _a3, _b3, _c3, _d3;
    if (!this._input || !this._domNode) {
      return;
    }
    const widgetShadowColor = theme.getColor(widgetShadow);
    const widgetBorderColor = theme.getColor(widgetBorder);
    this._domNode.style.backgroundColor = String((_a3 = theme.getColor(editorWidgetBackground)) !== null && _a3 !== void 0 ? _a3 : "");
    this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : "";
    this._domNode.style.border = widgetBorderColor ? `1px solid ${widgetBorderColor}` : "";
    this._domNode.style.color = String((_b3 = theme.getColor(inputForeground)) !== null && _b3 !== void 0 ? _b3 : "");
    this._input.style.backgroundColor = String((_c3 = theme.getColor(inputBackground)) !== null && _c3 !== void 0 ? _c3 : "");
    const border = theme.getColor(inputBorder);
    this._input.style.borderWidth = border ? "1px" : "0px";
    this._input.style.borderStyle = border ? "solid" : "none";
    this._input.style.borderColor = (_d3 = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d3 !== void 0 ? _d3 : "none";
  }
  _updateFont() {
    if (!this._input || !this._label) {
      return;
    }
    const fontInfo = this._editor.getOption(
      49
      /* EditorOption.fontInfo */
    );
    this._input.style.fontFamily = fontInfo.fontFamily;
    this._input.style.fontWeight = fontInfo.fontWeight;
    this._input.style.fontSize = `${fontInfo.fontSize}px`;
    this._label.style.fontSize = `${fontInfo.fontSize * 0.8}px`;
  }
  getPosition() {
    if (!this._visible) {
      return null;
    }
    return {
      position: this._position,
      preference: [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  beforeRender() {
    var _a3, _b3;
    const [accept, preview] = this._acceptKeybindings;
    this._label.innerText = localize({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (_a3 = this._keybindingService.lookupKeybinding(accept)) === null || _a3 === void 0 ? void 0 : _a3.getLabel(), (_b3 = this._keybindingService.lookupKeybinding(preview)) === null || _b3 === void 0 ? void 0 : _b3.getLabel());
    return null;
  }
  afterRender(position) {
    if (!position) {
      this.cancelInput(true);
    }
  }
  acceptInput(wantsPreview) {
    var _a3;
    (_a3 = this._currentAcceptInput) === null || _a3 === void 0 ? void 0 : _a3.call(this, wantsPreview);
  }
  cancelInput(focusEditor) {
    var _a3;
    (_a3 = this._currentCancelInput) === null || _a3 === void 0 ? void 0 : _a3.call(this, focusEditor);
  }
  getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
    this._domNode.classList.toggle("preview", supportPreview);
    this._position = new Position$1(where.startLineNumber, where.startColumn);
    this._input.value = value;
    this._input.setAttribute("selectionStart", selectionStart.toString());
    this._input.setAttribute("selectionEnd", selectionEnd.toString());
    this._input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
    const disposeOnDone = new DisposableStore();
    return new Promise((resolve) => {
      this._currentCancelInput = (focusEditor) => {
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve(focusEditor);
        return true;
      };
      this._currentAcceptInput = (wantsPreview) => {
        if (this._input.value.trim().length === 0 || this._input.value === value) {
          this.cancelInput(true);
          return;
        }
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve({
          newName: this._input.value,
          wantsPreview: supportPreview && wantsPreview
        });
      };
      disposeOnDone.add(token.onCancellationRequested(() => this.cancelInput(true)));
      disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(!document.hasFocus())));
      this._show();
    }).finally(() => {
      disposeOnDone.dispose();
      this._hide();
    });
  }
  _show() {
    this._editor.revealLineInCenterIfOutsideViewport(
      this._position.lineNumber,
      0
      /* ScrollType.Smooth */
    );
    this._visible = true;
    this._visibleContextKey.set(true);
    this._editor.layoutContentWidget(this);
    setTimeout(() => {
      this._input.focus();
      this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
    }, 100);
  }
  _hide() {
    this._visible = false;
    this._visibleContextKey.reset();
    this._editor.layoutContentWidget(this);
  }
};
RenameInputField = __decorate$c([
  __param$c(2, IThemeService),
  __param$c(3, IKeybindingService),
  __param$c(4, IContextKeyService)
], RenameInputField);
var __decorate$b = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$b = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class RenameSkeleton {
  constructor(model, position, registry) {
    this.model = model;
    this.position = position;
    this._providerRenameIdx = 0;
    this._providers = registry.ordered(model);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  resolveRenameLocation(token) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const rejects = [];
      for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
        const provider = this._providers[this._providerRenameIdx];
        if (!provider.resolveRenameLocation) {
          break;
        }
        const res = yield provider.resolveRenameLocation(this.model, this.position, token);
        if (!res) {
          continue;
        }
        if (res.rejectReason) {
          rejects.push(res.rejectReason);
          continue;
        }
        return res;
      }
      const word = this.model.getWordAtPosition(this.position);
      if (!word) {
        return {
          range: Range$1.fromPositions(this.position),
          text: "",
          rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
        };
      }
      return {
        range: new Range$1(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
        text: word.word,
        rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
      };
    });
  }
  provideRenameEdits(newName, token) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
    });
  }
  _provideRenameEdits(newName, i, rejects, token) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const provider = this._providers[i];
      if (!provider) {
        return {
          edits: [],
          rejectReason: rejects.join("\n")
        };
      }
      const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
      if (!result) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(localize("no result", "No result.")), token);
      } else if (result.rejectReason) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
      }
      return result;
    });
  }
}
function rename$1(registry, model, position, newName) {
  return __awaiter$9(this, void 0, void 0, function* () {
    const skeleton = new RenameSkeleton(model, position, registry);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      return { edits: [], rejectReason: loc.rejectReason };
    }
    return skeleton.provideRenameEdits(newName, CancellationToken.None);
  });
}
let RenameController = class RenameController2 {
  static get(editor2) {
    return editor2.getContribution(RenameController2.ID);
  }
  constructor(editor2, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService) {
    this.editor = editor2;
    this._instaService = _instaService;
    this._notificationService = _notificationService;
    this._bulkEditService = _bulkEditService;
    this._progressService = _progressService;
    this._logService = _logService;
    this._configService = _configService;
    this._languageFeaturesService = _languageFeaturesService;
    this._disposableStore = new DisposableStore();
    this._cts = new CancellationTokenSource();
    this._renameInputField = this._disposableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]));
  }
  dispose() {
    this._disposableStore.dispose();
    this._cts.dispose(true);
  }
  run() {
    var _a3, _b3;
    return __awaiter$9(this, void 0, void 0, function* () {
      this._cts.dispose(true);
      this._cts = new CancellationTokenSource();
      if (!this.editor.hasModel()) {
        return void 0;
      }
      const position = this.editor.getPosition();
      const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
      if (!skeleton.hasProvider()) {
        return void 0;
      }
      const cts1 = new EditorStateCancellationTokenSource(this.editor, 4 | 1, void 0, this._cts.token);
      let loc;
      try {
        const resolveLocationOperation = skeleton.resolveRenameLocation(cts1.token);
        this._progressService.showWhile(resolveLocationOperation, 250);
        loc = yield resolveLocationOperation;
      } catch (e) {
        (_a3 = MessageController.get(this.editor)) === null || _a3 === void 0 ? void 0 : _a3.showMessage(e || localize("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), position);
        return void 0;
      } finally {
        cts1.dispose();
      }
      if (!loc) {
        return void 0;
      }
      if (loc.rejectReason) {
        (_b3 = MessageController.get(this.editor)) === null || _b3 === void 0 ? void 0 : _b3.showMessage(loc.rejectReason, position);
        return void 0;
      }
      if (cts1.token.isCancellationRequested) {
        return void 0;
      }
      const cts2 = new EditorStateCancellationTokenSource(this.editor, 4 | 1, loc.range, this._cts.token);
      const selection = this.editor.getSelection();
      let selectionStart = 0;
      let selectionEnd = loc.text.length;
      if (!Range$1.isEmpty(selection) && !Range$1.spansMultipleLines(selection) && Range$1.containsRange(loc.range, selection)) {
        selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
        selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
      }
      const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
      const inputFieldResult = yield this._renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, cts2.token);
      if (typeof inputFieldResult === "boolean") {
        if (inputFieldResult) {
          this.editor.focus();
        }
        cts2.dispose();
        return void 0;
      }
      this.editor.focus();
      const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, cts2.token), cts2.token).then((renameResult) => __awaiter$9(this, void 0, void 0, function* () {
        if (!renameResult || !this.editor.hasModel()) {
          return;
        }
        if (renameResult.rejectReason) {
          this._notificationService.info(renameResult.rejectReason);
          return;
        }
        this.editor.setSelection(Range$1.fromPositions(this.editor.getSelection().getPosition()));
        this._bulkEditService.apply(renameResult, {
          editor: this.editor,
          showPreview: inputFieldResult.wantsPreview,
          label: localize("label", "Renaming '{0}' to '{1}'", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
          code: "undoredo.rename",
          quotableLabel: localize("quotableLabel", "Renaming {0} to {1}", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
          respectAutoSaveConfig: true
        }).then((result) => {
          if (result.ariaSummary) {
            alert(localize("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
          }
        }).catch((err) => {
          this._notificationService.error(localize("rename.failedApply", "Rename failed to apply edits"));
          this._logService.error(err);
        });
      }), (err) => {
        this._notificationService.error(localize("rename.failed", "Rename failed to compute edits"));
        this._logService.error(err);
      }).finally(() => {
        cts2.dispose();
      });
      this._progressService.showWhile(renameOperation, 250);
      return renameOperation;
    });
  }
  acceptRenameInput(wantsPreview) {
    this._renameInputField.acceptInput(wantsPreview);
  }
  cancelRenameInput() {
    this._renameInputField.cancelInput(true);
  }
};
RenameController.ID = "editor.contrib.renameController";
RenameController = __decorate$b([
  __param$b(1, IInstantiationService),
  __param$b(2, INotificationService),
  __param$b(3, IBulkEditService),
  __param$b(4, IEditorProgressService),
  __param$b(5, ILogService),
  __param$b(6, ITextResourceConfigurationService),
  __param$b(7, ILanguageFeaturesService)
], RenameController);
class RenameAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.rename",
      label: localize("rename.label", "Rename Symbol"),
      alias: "Rename Symbol",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI$1.isUri(uri) && Position$1.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(accessor, editor2) {
    const controller = RenameController.get(editor2);
    if (controller) {
      return controller.run();
    }
    return Promise.resolve();
  }
}
registerEditorContribution(
  RenameController.ID,
  RenameController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(RenameAction);
const RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.acceptRenameInput(false),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInputWithPreview",
  precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
  handler: (x) => x.acceptRenameInput(true),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 1024 + 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new RenameCommand({
  id: "cancelRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.cancelRenameInput(),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerModelAndPositionCommand("_executeDocumentRenameProvider", function(accessor, model, position, ...args) {
  const [newName] = args;
  assertType(typeof newName === "string");
  const { renameProvider } = accessor.get(ILanguageFeaturesService);
  return rename$1(renameProvider, model, position, newName);
});
registerModelAndPositionCommand("_executePrepareRename", function(accessor, model, position) {
  return __awaiter$9(this, void 0, void 0, function* () {
    const { renameProvider } = accessor.get(ILanguageFeaturesService);
    const skeleton = new RenameSkeleton(model, position, renameProvider);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      throw new Error(loc.rejectReason);
    }
    return loc;
  });
});
Registry.as(Extensions.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 5,
      description: localize("enablePreview", "Enable/disable the ability to preview changes before renaming"),
      default: true,
      type: "boolean"
    }
  }
});
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function isSemanticTokens(v) {
  return v && !!v.data;
}
function isSemanticTokensEdits(v) {
  return v && Array.isArray(v.edits);
}
class DocumentSemanticTokensResult {
  constructor(provider, tokens, error) {
    this.provider = provider;
    this.tokens = tokens;
    this.error = error;
  }
}
function hasDocumentSemanticTokensProvider(registry, model) {
  return registry.has(model);
}
function getDocumentSemanticTokensProviders(registry, model) {
  const groups = registry.orderedGroups(model);
  return groups.length > 0 ? groups[0] : [];
}
function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {
  return __awaiter$8(this, void 0, void 0, function* () {
    const providers = getDocumentSemanticTokensProviders(registry, model);
    const results = yield Promise.all(providers.map((provider) => __awaiter$8(this, void 0, void 0, function* () {
      let result;
      let error = null;
      try {
        result = yield provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);
      } catch (err) {
        error = err;
        result = null;
      }
      if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {
        result = null;
      }
      return new DocumentSemanticTokensResult(provider, result, error);
    })));
    for (const result of results) {
      if (result.error) {
        throw result.error;
      }
      if (result.tokens) {
        return result;
      }
    }
    if (results.length > 0) {
      return results[0];
    }
    return null;
  });
}
function _getDocumentSemanticTokensProviderHighestGroup(registry, model) {
  const result = registry.orderedGroups(model);
  return result.length > 0 ? result[0] : null;
}
class DocumentRangeSemanticTokensResult {
  constructor(provider, tokens) {
    this.provider = provider;
    this.tokens = tokens;
  }
}
function hasDocumentRangeSemanticTokensProvider(providers, model) {
  return providers.has(model);
}
function getDocumentRangeSemanticTokensProviders(providers, model) {
  const groups = providers.orderedGroups(model);
  return groups.length > 0 ? groups[0] : [];
}
function getDocumentRangeSemanticTokens(registry, model, range, token) {
  return __awaiter$8(this, void 0, void 0, function* () {
    const providers = getDocumentRangeSemanticTokensProviders(registry, model);
    const results = yield Promise.all(providers.map((provider) => __awaiter$8(this, void 0, void 0, function* () {
      let result;
      try {
        result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);
      } catch (err) {
        onUnexpectedExternalError(err);
        result = null;
      }
      if (!result || !isSemanticTokens(result)) {
        result = null;
      }
      return new DocumentRangeSemanticTokensResult(provider, result);
    })));
    for (const result of results) {
      if (result.tokens) {
        return result;
      }
    }
    if (results.length > 0) {
      return results[0];
    }
    return null;
  });
}
CommandsRegistry.registerCommand("_provideDocumentSemanticTokensLegend", (accessor, ...args) => __awaiter$8(void 0, void 0, void 0, function* () {
  const [uri] = args;
  assertType(uri instanceof URI$1);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);
  if (!providers) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokensLegend", uri);
  }
  return providers[0].getLegend();
}));
CommandsRegistry.registerCommand("_provideDocumentSemanticTokens", (accessor, ...args) => __awaiter$8(void 0, void 0, void 0, function* () {
  const [uri] = args;
  assertType(uri instanceof URI$1);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokens", uri, model.getFullModelRange());
  }
  const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);
  if (!r) {
    return void 0;
  }
  const { provider, tokens } = r;
  if (!tokens || !isSemanticTokens(tokens)) {
    return void 0;
  }
  const buff = encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: tokens.data
  });
  if (tokens.resultId) {
    provider.releaseDocumentSemanticTokens(tokens.resultId);
  }
  return buff;
}));
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokensLegend", (accessor, ...args) => __awaiter$8(void 0, void 0, void 0, function* () {
  const [uri, range] = args;
  assertType(uri instanceof URI$1);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);
  if (providers.length === 0) {
    return void 0;
  }
  if (providers.length === 1) {
    return providers[0].getLegend();
  }
  if (!range || !Range$1.isIRange(range)) {
    console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);
    return providers[0].getLegend();
  }
  const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range$1.lift(range), CancellationToken.None);
  if (!result) {
    return void 0;
  }
  return result.provider.getLegend();
}));
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokens", (accessor, ...args) => __awaiter$8(void 0, void 0, void 0, function* () {
  const [uri, range] = args;
  assertType(uri instanceof URI$1);
  assertType(Range$1.isIRange(range));
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range$1.lift(range), CancellationToken.None);
  if (!result || !result.tokens) {
    return void 0;
  }
  return encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: result.tokens.data
  });
}));
const SEMANTIC_HIGHLIGHTING_SETTING_ID = "editor.semanticHighlighting";
function isSemanticColoringEnabled(model, themeService, configurationService) {
  var _a3;
  const setting = (_a3 = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageId(), resource: model.uri })) === null || _a3 === void 0 ? void 0 : _a3.enabled;
  if (typeof setting === "boolean") {
    return setting;
  }
  return themeService.getColorTheme().semanticHighlighting;
}
var __decorate$a = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$a = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let DocumentSemanticTokensFeature = class DocumentSemanticTokensFeature2 extends Disposable {
  constructor(semanticTokensStylingService, modelService, themeService, configurationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._watchers = /* @__PURE__ */ Object.create(null);
    const register = (model) => {
      this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService);
    };
    const deregister = (model, modelSemanticColoring) => {
      modelSemanticColoring.dispose();
      delete this._watchers[model.uri.toString()];
    };
    const handleSettingOrThemeChange = () => {
      for (const model of modelService.getModels()) {
        const curr = this._watchers[model.uri.toString()];
        if (isSemanticColoringEnabled(model, themeService, configurationService)) {
          if (!curr) {
            register(model);
          }
        } else {
          if (curr) {
            deregister(model, curr);
          }
        }
      }
    };
    this._register(modelService.onModelAdded((model) => {
      if (isSemanticColoringEnabled(model, themeService, configurationService)) {
        register(model);
      }
    }));
    this._register(modelService.onModelRemoved((model) => {
      const curr = this._watchers[model.uri.toString()];
      if (curr) {
        deregister(model, curr);
      }
    }));
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        handleSettingOrThemeChange();
      }
    }));
    this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));
  }
  dispose() {
    for (const watcher of Object.values(this._watchers)) {
      watcher.dispose();
    }
    super.dispose();
  }
};
DocumentSemanticTokensFeature = __decorate$a([
  __param$a(0, ISemanticTokensStylingService),
  __param$a(1, IModelService),
  __param$a(2, IThemeService),
  __param$a(3, IConfigurationService),
  __param$a(4, ILanguageFeatureDebounceService),
  __param$a(5, ILanguageFeaturesService)
], DocumentSemanticTokensFeature);
let ModelSemanticColoring = class ModelSemanticColoring2 extends Disposable {
  constructor(model, _semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._semanticTokensStylingService = _semanticTokensStylingService;
    this._isDisposed = false;
    this._model = model;
    this._provider = languageFeaturesService.documentSemanticTokensProvider;
    this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentSemanticTokens", { min: ModelSemanticColoring2.REQUEST_MIN_DELAY, max: ModelSemanticColoring2.REQUEST_MAX_DELAY });
    this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring2.REQUEST_MIN_DELAY));
    this._currentDocumentResponse = null;
    this._currentDocumentRequestCancellationTokenSource = null;
    this._documentProvidersChangeListeners = [];
    this._providersChangedDuringRequest = false;
    this._register(this._model.onDidChangeContent(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    }));
    this._register(this._model.onDidChangeAttached(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    }));
    this._register(this._model.onDidChangeLanguage(() => {
      if (this._currentDocumentResponse) {
        this._currentDocumentResponse.dispose();
        this._currentDocumentResponse = null;
      }
      if (this._currentDocumentRequestCancellationTokenSource) {
        this._currentDocumentRequestCancellationTokenSource.cancel();
        this._currentDocumentRequestCancellationTokenSource = null;
      }
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const bindDocumentChangeListeners = () => {
      dispose(this._documentProvidersChangeListeners);
      this._documentProvidersChangeListeners = [];
      for (const provider of this._provider.all(model)) {
        if (typeof provider.onDidChange === "function") {
          this._documentProvidersChangeListeners.push(provider.onDidChange(() => {
            if (this._currentDocumentRequestCancellationTokenSource) {
              this._providersChangedDuringRequest = true;
              return;
            }
            this._fetchDocumentSemanticTokens.schedule(0);
          }));
        }
      }
    };
    bindDocumentChangeListeners();
    this._register(this._provider.onDidChange(() => {
      bindDocumentChangeListeners();
      this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    }));
    this._register(themeService.onDidColorThemeChange((_) => {
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    }));
    this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._currentDocumentRequestCancellationTokenSource) {
      this._currentDocumentRequestCancellationTokenSource.cancel();
      this._currentDocumentRequestCancellationTokenSource = null;
    }
    dispose(this._documentProvidersChangeListeners);
    this._documentProvidersChangeListeners = [];
    this._setDocumentSemanticTokens(null, null, null, []);
    this._isDisposed = true;
    super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource) {
      return;
    }
    if (!hasDocumentSemanticTokensProvider(this._provider, this._model)) {
      if (this._currentDocumentResponse) {
        this._model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    if (!this._model.isAttachedToEditor()) {
      return;
    }
    const cancellationTokenSource = new CancellationTokenSource();
    const lastProvider = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null;
    const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;
    const request = getDocumentSemanticTokens(this._provider, this._model, lastProvider, lastResultId, cancellationTokenSource.token);
    this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;
    this._providersChangedDuringRequest = false;
    const pendingChanges = [];
    const contentChangeListener = this._model.onDidChangeContent((e) => {
      pendingChanges.push(e);
    });
    const sw = new StopWatch(false);
    request.then((res) => {
      this._debounceInformation.update(this._model, sw.elapsed());
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (!res) {
        this._setDocumentSemanticTokens(null, null, null, pendingChanges);
      } else {
        const { provider, tokens } = res;
        const styling = this._semanticTokensStylingService.getStyling(provider);
        this._setDocumentSemanticTokens(provider, tokens || null, styling, pendingChanges);
      }
    }, (err) => {
      const isExpectedError = err && (isCancellationError(err) || typeof err.message === "string" && err.message.indexOf("busy") !== -1);
      if (!isExpectedError) {
        onUnexpectedError(err);
      }
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (pendingChanges.length > 0 || this._providersChangedDuringRequest) {
        if (!this._fetchDocumentSemanticTokens.isScheduled()) {
          this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
        }
      }
    });
  }
  static _copy(src, srcOffset, dest, destOffset, length2) {
    length2 = Math.min(length2, dest.length - destOffset, src.length - srcOffset);
    for (let i = 0; i < length2; i++) {
      dest[destOffset + i] = src[srcOffset + i];
    }
  }
  _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {
    const currentResponse = this._currentDocumentResponse;
    const rescheduleIfNeeded = () => {
      if ((pendingChanges.length > 0 || this._providersChangedDuringRequest) && !this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    };
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._isDisposed) {
      if (provider && tokens) {
        provider.releaseDocumentSemanticTokens(tokens.resultId);
      }
      return;
    }
    if (!provider || !styling) {
      this._model.tokenization.setSemanticTokens(null, false);
      return;
    }
    if (!tokens) {
      this._model.tokenization.setSemanticTokens(null, true);
      rescheduleIfNeeded();
      return;
    }
    if (isSemanticTokensEdits(tokens)) {
      if (!currentResponse) {
        this._model.tokenization.setSemanticTokens(null, true);
        return;
      }
      if (tokens.edits.length === 0) {
        tokens = {
          resultId: tokens.resultId,
          data: currentResponse.data
        };
      } else {
        let deltaLength = 0;
        for (const edit of tokens.edits) {
          deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;
        }
        const srcData = currentResponse.data;
        const destData = new Uint32Array(srcData.length + deltaLength);
        let srcLastStart = srcData.length;
        let destLastStart = destData.length;
        for (let i = tokens.edits.length - 1; i >= 0; i--) {
          const edit = tokens.edits[i];
          if (edit.start > srcData.length) {
            styling.warnInvalidEditStart(currentResponse.resultId, tokens.resultId, i, edit.start, srcData.length);
            this._model.tokenization.setSemanticTokens(null, true);
            return;
          }
          const copyCount = srcLastStart - (edit.start + edit.deleteCount);
          if (copyCount > 0) {
            ModelSemanticColoring2._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);
            destLastStart -= copyCount;
          }
          if (edit.data) {
            ModelSemanticColoring2._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);
            destLastStart -= edit.data.length;
          }
          srcLastStart = edit.start;
        }
        if (srcLastStart > 0) {
          ModelSemanticColoring2._copy(srcData, 0, destData, 0, srcLastStart);
        }
        tokens = {
          resultId: tokens.resultId,
          data: destData
        };
      }
    }
    if (isSemanticTokens(tokens)) {
      this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);
      const result = toMultilineTokens2(tokens, styling, this._model.getLanguageId());
      if (pendingChanges.length > 0) {
        for (const change of pendingChanges) {
          for (const area of result) {
            for (const singleChange of change.changes) {
              area.applyEdit(singleChange.range, singleChange.text);
            }
          }
        }
      }
      this._model.tokenization.setSemanticTokens(result, true);
    } else {
      this._model.tokenization.setSemanticTokens(null, true);
    }
    rescheduleIfNeeded();
  }
};
ModelSemanticColoring.REQUEST_MIN_DELAY = 300;
ModelSemanticColoring.REQUEST_MAX_DELAY = 2e3;
ModelSemanticColoring = __decorate$a([
  __param$a(1, ISemanticTokensStylingService),
  __param$a(2, IThemeService),
  __param$a(3, ILanguageFeatureDebounceService),
  __param$a(4, ILanguageFeaturesService)
], ModelSemanticColoring);
class SemanticTokensResponse {
  constructor(provider, resultId, data) {
    this.provider = provider;
    this.resultId = resultId;
    this.data = data;
  }
  dispose() {
    this.provider.releaseDocumentSemanticTokens(this.resultId);
  }
}
registerEditorFeature(DocumentSemanticTokensFeature);
var __decorate$9 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$9 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
let ViewportSemanticTokensContribution = class ViewportSemanticTokensContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(ViewportSemanticTokensContribution2.ID);
  }
  constructor(editor2, _semanticTokensStylingService, _themeService, _configurationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._semanticTokensStylingService = _semanticTokensStylingService;
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._editor = editor2;
    this._provider = languageFeaturesService.documentRangeSemanticTokensProvider;
    this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentRangeSemanticTokens", { min: 100, max: 500 });
    this._tokenizeViewport = this._register(new RunOnceScheduler(() => this._tokenizeViewportNow(), 100));
    this._outstandingRequests = [];
    const scheduleTokenizeViewport = () => {
      if (this._editor.hasModel()) {
        this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
      }
    };
    this._register(this._editor.onDidScrollChange(() => {
      scheduleTokenizeViewport();
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._provider.onDidChange(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        this._cancelAll();
        scheduleTokenizeViewport();
      }
    }));
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    scheduleTokenizeViewport();
  }
  _cancelAll() {
    for (const request of this._outstandingRequests) {
      request.cancel();
    }
    this._outstandingRequests = [];
  }
  _removeOutstandingRequest(req) {
    for (let i = 0, len = this._outstandingRequests.length; i < len; i++) {
      if (this._outstandingRequests[i] === req) {
        this._outstandingRequests.splice(i, 1);
        return;
      }
    }
  }
  _tokenizeViewportNow() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    if (model.tokenization.hasCompleteSemanticTokens()) {
      return;
    }
    if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
      if (model.tokenization.hasSomeSemanticTokens()) {
        model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    if (!hasDocumentRangeSemanticTokensProvider(this._provider, model)) {
      if (model.tokenization.hasSomeSemanticTokens()) {
        model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range) => this._requestRange(model, range)));
  }
  _requestRange(model, range) {
    const requestVersionId = model.getVersionId();
    const request = createCancelablePromise((token) => Promise.resolve(getDocumentRangeSemanticTokens(this._provider, model, range, token)));
    const sw = new StopWatch(false);
    request.then((r) => {
      this._debounceInformation.update(model, sw.elapsed());
      if (!r || !r.tokens || model.isDisposed() || model.getVersionId() !== requestVersionId) {
        return;
      }
      const { provider, tokens: result } = r;
      const styling = this._semanticTokensStylingService.getStyling(provider);
      model.tokenization.setPartialSemanticTokens(range, toMultilineTokens2(result, styling, model.getLanguageId()));
    }).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
    return request;
  }
};
ViewportSemanticTokensContribution.ID = "editor.contrib.viewportSemanticTokens";
ViewportSemanticTokensContribution = __decorate$9([
  __param$9(1, ISemanticTokensStylingService),
  __param$9(2, IThemeService),
  __param$9(3, IConfigurationService),
  __param$9(4, ILanguageFeatureDebounceService),
  __param$9(5, ILanguageFeaturesService)
], ViewportSemanticTokensContribution);
registerEditorContribution(
  ViewportSemanticTokensContribution.ID,
  ViewportSemanticTokensContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class WordSelectionRangeProvider {
  constructor(selectSubwords = true) {
    this.selectSubwords = selectSubwords;
  }
  provideSelectionRanges(model, positions) {
    const result = [];
    for (const position of positions) {
      const bucket = [];
      result.push(bucket);
      if (this.selectSubwords) {
        this._addInWordRanges(bucket, model, position);
      }
      this._addWordRanges(bucket, model, position);
      this._addWhitespaceLine(bucket, model, position);
      bucket.push({ range: model.getFullModelRange() });
    }
    return result;
  }
  _addInWordRanges(bucket, model, pos) {
    const obj = model.getWordAtPosition(pos);
    if (!obj) {
      return;
    }
    const { word, startColumn } = obj;
    const offset = pos.column - startColumn;
    let start = offset;
    let end = offset;
    let lastCh = 0;
    for (; start >= 0; start--) {
      const ch = word.charCodeAt(start);
      if (start !== offset && (ch === 95 || ch === 45)) {
        break;
      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {
        break;
      }
      lastCh = ch;
    }
    start += 1;
    for (; end < word.length; end++) {
      const ch = word.charCodeAt(end);
      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {
        break;
      } else if (ch === 95 || ch === 45) {
        break;
      }
      lastCh = ch;
    }
    if (start < end) {
      bucket.push({ range: new Range$1(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });
    }
  }
  _addWordRanges(bucket, model, pos) {
    const word = model.getWordAtPosition(pos);
    if (word) {
      bucket.push({ range: new Range$1(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });
    }
  }
  _addWhitespaceLine(bucket, model, pos) {
    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
      bucket.push({ range: new Range$1(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });
    }
  }
}
var __decorate$8 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$8 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SelectionRanges {
  constructor(index2, ranges) {
    this.index = index2;
    this.ranges = ranges;
  }
  mov(fwd) {
    const index2 = this.index + (fwd ? 1 : -1);
    if (index2 < 0 || index2 >= this.ranges.length) {
      return this;
    }
    const res = new SelectionRanges(index2, this.ranges);
    if (res.ranges[index2].equalsRange(this.ranges[this.index])) {
      return res.mov(fwd);
    }
    return res;
  }
}
let SmartSelectController = class SmartSelectController2 {
  static get(editor2) {
    return editor2.getContribution(SmartSelectController2.ID);
  }
  constructor(_editor, _languageFeaturesService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._ignoreSelection = false;
  }
  dispose() {
    var _a3;
    (_a3 = this._selectionListener) === null || _a3 === void 0 ? void 0 : _a3.dispose();
  }
  run(forward) {
    return __awaiter$7(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return;
      }
      const selections = this._editor.getSelections();
      const model = this._editor.getModel();
      if (!this._state) {
        yield provideSelectionRanges(this._languageFeaturesService.selectionRangeProvider, model, selections.map((s) => s.getPosition()), this._editor.getOption(
          111
          /* EditorOption.smartSelect */
        ), CancellationToken.None).then((ranges) => {
          var _a3;
          if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) {
            return;
          }
          if (!this._editor.hasModel() || !equals$1(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
            return;
          }
          for (let i = 0; i < ranges.length; i++) {
            ranges[i] = ranges[i].filter((range) => {
              return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
            });
            ranges[i].unshift(selections[i]);
          }
          this._state = ranges.map((ranges2) => new SelectionRanges(0, ranges2));
          (_a3 = this._selectionListener) === null || _a3 === void 0 ? void 0 : _a3.dispose();
          this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
            var _a4;
            if (!this._ignoreSelection) {
              (_a4 = this._selectionListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();
              this._state = void 0;
            }
          });
        });
      }
      if (!this._state) {
        return;
      }
      this._state = this._state.map((state) => state.mov(forward));
      const newSelections = this._state.map((state) => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
      this._ignoreSelection = true;
      try {
        this._editor.setSelections(newSelections);
      } finally {
        this._ignoreSelection = false;
      }
    });
  }
};
SmartSelectController.ID = "editor.contrib.smartSelectController";
SmartSelectController = __decorate$8([
  __param$8(1, ILanguageFeaturesService)
], SmartSelectController);
class AbstractSmartSelect extends EditorAction {
  constructor(forward, opts) {
    super(opts);
    this._forward = forward;
  }
  run(_accessor, editor2) {
    return __awaiter$7(this, void 0, void 0, function* () {
      const controller = SmartSelectController.get(editor2);
      if (controller) {
        yield controller.run(this._forward);
      }
    });
  }
}
class GrowSelectionAction extends AbstractSmartSelect {
  constructor() {
    super(true, {
      id: "editor.action.smartSelect.expand",
      label: localize("smartSelect.expand", "Expand Selection"),
      alias: "Expand Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 17,
        mac: {
          primary: 2048 | 256 | 1024 | 17,
          secondary: [
            256 | 1024 | 17
            /* KeyCode.RightArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
        order: 2
      }
    });
  }
}
CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
class ShrinkSelectionAction extends AbstractSmartSelect {
  constructor() {
    super(false, {
      id: "editor.action.smartSelect.shrink",
      label: localize("smartSelect.shrink", "Shrink Selection"),
      alias: "Shrink Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 15,
        mac: {
          primary: 2048 | 256 | 1024 | 15,
          secondary: [
            256 | 1024 | 15
            /* KeyCode.LeftArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
        order: 3
      }
    });
  }
}
registerEditorContribution(
  SmartSelectController.ID,
  SmartSelectController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);
function provideSelectionRanges(registry, model, positions, options, token) {
  return __awaiter$7(this, void 0, void 0, function* () {
    const providers = registry.all(model).concat(new WordSelectionRangeProvider(options.selectSubwords));
    if (providers.length === 1) {
      providers.unshift(new BracketSelectionRangeProvider());
    }
    const work = [];
    const allRawRanges = [];
    for (const provider of providers) {
      work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
        if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
          for (let i = 0; i < positions.length; i++) {
            if (!allRawRanges[i]) {
              allRawRanges[i] = [];
            }
            for (const oneProviderRanges of allProviderRanges[i]) {
              if (Range$1.isIRange(oneProviderRanges.range) && Range$1.containsPosition(oneProviderRanges.range, positions[i])) {
                allRawRanges[i].push(Range$1.lift(oneProviderRanges.range));
              }
            }
          }
        }
      }, onUnexpectedExternalError));
    }
    yield Promise.all(work);
    return allRawRanges.map((oneRawRanges) => {
      if (oneRawRanges.length === 0) {
        return [];
      }
      oneRawRanges.sort((a, b) => {
        if (Position$1.isBefore(a.getStartPosition(), b.getStartPosition())) {
          return 1;
        } else if (Position$1.isBefore(b.getStartPosition(), a.getStartPosition())) {
          return -1;
        } else if (Position$1.isBefore(a.getEndPosition(), b.getEndPosition())) {
          return -1;
        } else if (Position$1.isBefore(b.getEndPosition(), a.getEndPosition())) {
          return 1;
        } else {
          return 0;
        }
      });
      const oneRanges = [];
      let last;
      for (const range of oneRawRanges) {
        if (!last || Range$1.containsRange(range, last) && !Range$1.equalsRange(range, last)) {
          oneRanges.push(range);
          last = range;
        }
      }
      if (!options.selectLeadingAndTrailingWhitespace) {
        return oneRanges;
      }
      const oneRangesWithTrivia = [oneRanges[0]];
      for (let i = 1; i < oneRanges.length; i++) {
        const prev = oneRanges[i - 1];
        const cur = oneRanges[i];
        if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
          const rangeNoWhitespace = new Range$1(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
          if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
            oneRangesWithTrivia.push(rangeNoWhitespace);
          }
          const rangeFull = new Range$1(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
          if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
            oneRangesWithTrivia.push(rangeFull);
          }
        }
        oneRangesWithTrivia.push(cur);
      }
      return oneRangesWithTrivia;
    });
  });
}
CommandsRegistry.registerCommand("_executeSelectionRangeProvider", function(accessor, ...args) {
  return __awaiter$7(this, void 0, void 0, function* () {
    const [resource, positions] = args;
    assertType(URI$1.isUri(resource));
    const registry = accessor.get(ILanguageFeaturesService).selectionRangeProvider;
    const reference2 = yield accessor.get(ITextModelService).createModelReference(resource);
    try {
      return provideSelectionRanges(registry, reference2.object.textEditorModel, positions, { selectLeadingAndTrailingWhitespace: true, selectSubwords: true }, CancellationToken.None);
    } finally {
      reference2.dispose();
    }
  });
});
const stickyScroll = "";
class StickyScrollWidgetState {
  constructor(lineNumbers, lastLineRelativePosition) {
    this.lineNumbers = lineNumbers;
    this.lastLineRelativePosition = lastLineRelativePosition;
  }
}
const _ttPolicy = createTrustedTypesPolicy("stickyScrollViewLayer", { createHTML: (value) => value });
class StickyScrollWidget extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._rootDomNode = document.createElement("div");
    this._disposableStore = this._register(new DisposableStore());
    this._lineNumbers = [];
    this._lastLineRelativePosition = 0;
    this._hoverOnLine = -1;
    this._hoverOnColumn = -1;
    this._layoutInfo = this._editor.getLayoutInfo();
    this._rootDomNode = document.createElement("div");
    this._rootDomNode.className = "sticky-widget";
    this._rootDomNode.classList.toggle("peek", _editor instanceof EmbeddedCodeEditorWidget);
    this._rootDomNode.style.width = `${this._layoutInfo.width - this._layoutInfo.minimap.minimapCanvasOuterWidth - this._layoutInfo.verticalScrollbarWidth}px`;
  }
  get hoverOnLine() {
    return this._hoverOnLine;
  }
  get hoverOnColumn() {
    return this._hoverOnColumn;
  }
  get lineNumbers() {
    return this._lineNumbers;
  }
  get codeLineCount() {
    return this._lineNumbers.length;
  }
  getCurrentLines() {
    return this._lineNumbers;
  }
  setState(state) {
    clearNode(this._rootDomNode);
    this._disposableStore.clear();
    this._lineNumbers.length = 0;
    const editorLineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    const futureWidgetHeight = state.lineNumbers.length * editorLineHeight + state.lastLineRelativePosition;
    if (futureWidgetHeight > 0) {
      this._lastLineRelativePosition = state.lastLineRelativePosition;
      this._lineNumbers = state.lineNumbers;
    } else {
      this._lastLineRelativePosition = 0;
      this._lineNumbers = [];
    }
    this._renderRootNode();
  }
  _renderRootNode() {
    if (!this._editor._getViewModel()) {
      return;
    }
    for (const [index2, line] of this._lineNumbers.entries()) {
      const childNode = this._renderChildNode(index2, line);
      this._rootDomNode.appendChild(childNode);
    }
    const editorLineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    const widgetHeight = this._lineNumbers.length * editorLineHeight + this._lastLineRelativePosition;
    this._rootDomNode.style.display = widgetHeight > 0 ? "block" : "none";
    this._rootDomNode.style.height = widgetHeight.toString() + "px";
    this._rootDomNode.setAttribute("role", "list");
    const minimapSide = this._editor.getOption(
      71
      /* EditorOption.minimap */
    ).side;
    if (minimapSide === "left") {
      this._rootDomNode.style.marginLeft = this._editor.getLayoutInfo().minimap.minimapCanvasOuterWidth + "px";
    }
  }
  _renderChildNode(index2, line) {
    const child = document.createElement("div");
    const viewModel = this._editor._getViewModel();
    const viewLineNumber = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position$1(line, 1)).lineNumber;
    const lineRenderingData = viewModel.getViewLineRenderingData(viewLineNumber);
    const layoutInfo = this._editor.getLayoutInfo();
    const width = layoutInfo.width - layoutInfo.minimap.minimapCanvasOuterWidth - layoutInfo.verticalScrollbarWidth;
    const minimapSide = this._editor.getOption(
      71
      /* EditorOption.minimap */
    ).side;
    const lineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    const lineNumberOption = this._editor.getOption(
      66
      /* EditorOption.lineNumbers */
    );
    let actualInlineDecorations;
    try {
      actualInlineDecorations = LineDecoration.filter(lineRenderingData.inlineDecorations, viewLineNumber, lineRenderingData.minColumn, lineRenderingData.maxColumn);
    } catch (err) {
      actualInlineDecorations = [];
    }
    const renderLineInput = new RenderLineInput(true, true, lineRenderingData.content, lineRenderingData.continuesWithWrappedLine, lineRenderingData.isBasicASCII, lineRenderingData.containsRTL, 0, lineRenderingData.tokens, actualInlineDecorations, lineRenderingData.tabSize, lineRenderingData.startVisibleColumn, 1, 1, 1, 500, "none", true, true, null);
    const sb = new StringBuilder(2e3);
    renderViewLine(renderLineInput, sb);
    let newLine;
    if (_ttPolicy) {
      newLine = _ttPolicy.createHTML(sb.build());
    } else {
      newLine = sb.build();
    }
    const lineHTMLNode = document.createElement("span");
    lineHTMLNode.className = "sticky-line";
    lineHTMLNode.classList.add(`stickyLine${line}`);
    lineHTMLNode.style.lineHeight = `${lineHeight}px`;
    lineHTMLNode.innerHTML = newLine;
    const lineNumberHTMLNode = document.createElement("span");
    lineNumberHTMLNode.className = "sticky-line";
    lineNumberHTMLNode.style.lineHeight = `${lineHeight}px`;
    if (minimapSide === "left") {
      lineNumberHTMLNode.style.width = `${layoutInfo.contentLeft - layoutInfo.minimap.minimapCanvasOuterWidth}px`;
    } else if (minimapSide === "right") {
      lineNumberHTMLNode.style.width = `${layoutInfo.contentLeft}px`;
    }
    const innerLineNumberHTML = document.createElement("span");
    if (lineNumberOption.renderType === 1 || lineNumberOption.renderType === 3 && line % 10 === 0) {
      innerLineNumberHTML.innerText = line.toString();
    } else if (lineNumberOption.renderType === 2) {
      innerLineNumberHTML.innerText = Math.abs(line - this._editor.getPosition().lineNumber).toString();
    }
    innerLineNumberHTML.className = "sticky-line-number";
    innerLineNumberHTML.style.lineHeight = `${lineHeight}px`;
    innerLineNumberHTML.style.width = `${layoutInfo.lineNumbersWidth}px`;
    if (minimapSide === "left") {
      innerLineNumberHTML.style.paddingLeft = `${layoutInfo.lineNumbersLeft - layoutInfo.minimap.minimapCanvasOuterWidth}px`;
    } else if (minimapSide === "right") {
      innerLineNumberHTML.style.paddingLeft = `${layoutInfo.lineNumbersLeft}px`;
    }
    lineNumberHTMLNode.appendChild(innerLineNumberHTML);
    this._editor.applyFontInfo(lineHTMLNode);
    this._editor.applyFontInfo(innerLineNumberHTML);
    child.appendChild(lineNumberHTMLNode);
    child.appendChild(lineHTMLNode);
    child.className = "sticky-line-root";
    child.setAttribute("role", "listitem");
    child.tabIndex = 0;
    child.style.lineHeight = `${lineHeight}px`;
    child.style.width = `${width}px`;
    child.style.height = `${lineHeight}px`;
    child.style.zIndex = "0";
    if (index2 === this._lineNumbers.length - 1) {
      child.style.position = "relative";
      child.style.zIndex = "-1";
      child.style.top = this._lastLineRelativePosition + "px";
    }
    this._disposableStore.add(addDisposableListener(child, "mouseover", (e) => {
      if (this._editor.hasModel()) {
        const mouseOverEvent = new StandardMouseEvent(e);
        const text = mouseOverEvent.target.innerText;
        this._hoverOnLine = line;
        this._hoverOnColumn = this._editor.getModel().getLineContent(line).indexOf(text) + 1 || -1;
      }
    }));
    return child;
  }
  getId() {
    return "editor.contrib.stickyScrollWidget";
  }
  getDomNode() {
    return this._rootDomNode;
  }
  getPosition() {
    return {
      preference: null
    };
  }
}
class StickyRange {
  constructor(startLineNumber, endLineNumber) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
  }
}
class StickyElement {
  constructor(range, children, parent) {
    this.range = range;
    this.children = children;
    this.parent = parent;
  }
}
class StickyModel {
  constructor(uri, version, element, outlineProviderId) {
    this.uri = uri;
    this.version = version;
    this.element = element;
    this.outlineProviderId = outlineProviderId;
  }
}
var __decorate$7 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$7 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ModelProvider;
(function(ModelProvider2) {
  ModelProvider2["OUTLINE_MODEL"] = "outlineModel";
  ModelProvider2["FOLDING_PROVIDER_MODEL"] = "foldingProviderModel";
  ModelProvider2["INDENTATION_MODEL"] = "indentationModel";
})(ModelProvider || (ModelProvider = {}));
var Status;
(function(Status2) {
  Status2[Status2["VALID"] = 0] = "VALID";
  Status2[Status2["INVALID"] = 1] = "INVALID";
  Status2[Status2["CANCELED"] = 2] = "CANCELED";
})(Status || (Status = {}));
let StickyModelProvider = class StickyModelProvider2 {
  constructor(_editor, _languageConfigurationService, _languageFeaturesService, defaultModel) {
    this._editor = _editor;
    this._languageConfigurationService = _languageConfigurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._modelProviders = [];
    this._modelPromise = null;
    this._updateScheduler = new Delayer(300);
    const stickyModelFromCandidateOutlineProvider = new StickyModelFromCandidateOutlineProvider(_languageFeaturesService);
    const stickyModelFromSyntaxFoldingProvider = new StickyModelFromCandidateSyntaxFoldingProvider(this._editor, _languageFeaturesService);
    const stickyModelFromIndentationFoldingProvider = new StickyModelFromCandidateIndentationFoldingProvider(this._editor, _languageConfigurationService);
    switch (defaultModel) {
      case ModelProvider.OUTLINE_MODEL:
        this._modelProviders.push(stickyModelFromCandidateOutlineProvider);
        this._modelProviders.push(stickyModelFromSyntaxFoldingProvider);
        this._modelProviders.push(stickyModelFromIndentationFoldingProvider);
        break;
      case ModelProvider.FOLDING_PROVIDER_MODEL:
        this._modelProviders.push(stickyModelFromSyntaxFoldingProvider);
        this._modelProviders.push(stickyModelFromIndentationFoldingProvider);
        break;
      case ModelProvider.INDENTATION_MODEL:
        this._modelProviders.push(stickyModelFromIndentationFoldingProvider);
        break;
    }
    this._store = new DisposableStore();
  }
  _cancelModelPromise() {
    if (this._modelPromise) {
      this._modelPromise.cancel();
      this._modelPromise = null;
    }
  }
  update(textModel, textModelVersionId, token) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._store.clear();
      this._store.add({
        dispose: () => {
          var _a3;
          this._cancelModelPromise();
          (_a3 = this._updateScheduler) === null || _a3 === void 0 ? void 0 : _a3.cancel();
        }
      });
      this._cancelModelPromise();
      return yield this._updateScheduler.trigger(() => __awaiter$6(this, void 0, void 0, function* () {
        for (const modelProvider of this._modelProviders) {
          const { statusPromise, modelPromise } = modelProvider.computeStickyModel(textModel, textModelVersionId, token);
          this._modelPromise = modelPromise;
          const status2 = yield statusPromise;
          if (this._modelPromise !== modelPromise) {
            return null;
          }
          switch (status2) {
            case Status.CANCELED:
              this._store.clear();
              return null;
            case Status.VALID:
              return modelProvider.stickyModel;
          }
        }
        return null;
      }));
    });
  }
};
StickyModelProvider = __decorate$7([
  __param$7(1, ILanguageConfigurationService),
  __param$7(2, ILanguageFeaturesService)
], StickyModelProvider);
class StickyModelCandidateProvider {
  constructor() {
    this._stickyModel = null;
  }
  get stickyModel() {
    return this._stickyModel;
  }
  _invalid() {
    this._stickyModel = null;
    return Status.INVALID;
  }
  computeStickyModel(textModel, modelVersionId, token) {
    if (token.isCancellationRequested || !this.isProviderValid(textModel)) {
      return { statusPromise: this._invalid(), modelPromise: null };
    }
    const providerModelPromise = createCancelablePromise((token2) => this.createModelFromProvider(textModel, modelVersionId, token2));
    return {
      statusPromise: providerModelPromise.then((providerModel) => {
        if (!this.isModelValid(providerModel)) {
          return this._invalid();
        }
        if (token.isCancellationRequested) {
          return Status.CANCELED;
        }
        this._stickyModel = this.createStickyModel(textModel, modelVersionId, token, providerModel);
        return Status.VALID;
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return Status.CANCELED;
      }),
      modelPromise: providerModelPromise
    };
  }
  /**
   * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.
   * This method by default returns true.
   * @param model model returned by the provider
   * @returns boolean indicating whether the model is valid
   */
  isModelValid(model) {
    return true;
  }
  /**
   * Method which checks whether the provider is valid before applying it to find the provider model.
   * This method by default returns true.
   * @param textModel text-model of the editor
   * @returns boolean indicating whether the provider is valid
   */
  isProviderValid(textModel) {
    return true;
  }
}
let StickyModelFromCandidateOutlineProvider = class StickyModelFromCandidateOutlineProvider2 extends StickyModelCandidateProvider {
  constructor(_languageFeaturesService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
  }
  get provider() {
    return this._languageFeaturesService.documentSymbolProvider;
  }
  createModelFromProvider(textModel, modelVersionId, token) {
    return OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, textModel, token);
  }
  createStickyModel(textModel, modelVersionId, token, model) {
    var _a3;
    const { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, (_a3 = this._stickyModel) === null || _a3 === void 0 ? void 0 : _a3.outlineProviderId);
    return new StickyModel(textModel.uri, modelVersionId, stickyOutlineElement, providerID);
  }
  isModelValid(model) {
    return model && model.children.size > 0;
  }
  _stickyModelFromOutlineModel(outlineModel, preferredProvider) {
    let outlineElements;
    if (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {
      const provider = Iterable.find(outlineModel.children.values(), (outlineGroupOfModel) => outlineGroupOfModel.id === preferredProvider);
      if (provider) {
        outlineElements = provider.children;
      } else {
        let tempID = "";
        let maxTotalSumOfRanges = -1;
        let optimalOutlineGroup = void 0;
        for (const [_key, outlineGroup] of outlineModel.children.entries()) {
          const totalSumRanges = this._findSumOfRangesOfGroup(outlineGroup);
          if (totalSumRanges > maxTotalSumOfRanges) {
            optimalOutlineGroup = outlineGroup;
            maxTotalSumOfRanges = totalSumRanges;
            tempID = outlineGroup.id;
          }
        }
        preferredProvider = tempID;
        outlineElements = optimalOutlineGroup.children;
      }
    } else {
      outlineElements = outlineModel.children;
    }
    const stickyChildren = [];
    const outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {
      const range1 = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);
      const range2 = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);
      return this._comparator(range1, range2);
    });
    for (const outlineElement of outlineElementsArray) {
      stickyChildren.push(this._stickyModelFromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));
    }
    const stickyOutlineElement = new StickyElement(void 0, stickyChildren, void 0);
    return {
      stickyOutlineElement,
      providerID: preferredProvider
    };
  }
  _stickyModelFromOutlineElement(outlineElement, previousStartLine) {
    const children = [];
    for (const child of outlineElement.children.values()) {
      if (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {
        if (child.symbol.selectionRange.startLineNumber !== previousStartLine) {
          children.push(this._stickyModelFromOutlineElement(child, child.symbol.selectionRange.startLineNumber));
        } else {
          for (const subchild of child.children.values()) {
            children.push(this._stickyModelFromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));
          }
        }
      }
    }
    children.sort((child1, child2) => this._comparator(child1.range, child2.range));
    const range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);
    return new StickyElement(range, children, void 0);
  }
  _comparator(range1, range2) {
    if (range1.startLineNumber !== range2.startLineNumber) {
      return range1.startLineNumber - range2.startLineNumber;
    } else {
      return range2.endLineNumber - range1.endLineNumber;
    }
  }
  _findSumOfRangesOfGroup(outline) {
    let res = 0;
    for (const child of outline.children.values()) {
      res += this._findSumOfRangesOfGroup(child);
    }
    if (outline instanceof OutlineElement) {
      return res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;
    } else {
      return res;
    }
  }
};
StickyModelFromCandidateOutlineProvider = __decorate$7([
  __param$7(0, ILanguageFeaturesService)
], StickyModelFromCandidateOutlineProvider);
class StickyModelFromCandidateFoldingProvider extends StickyModelCandidateProvider {
  constructor(editor2) {
    super();
    this._foldingLimitReporter = new RangesLimitReporter(editor2);
  }
  createStickyModel(textModel, modelVersionId, token, model) {
    const foldingElement = this._fromFoldingRegions(model);
    return new StickyModel(textModel.uri, modelVersionId, foldingElement, void 0);
  }
  isModelValid(model) {
    return model !== null;
  }
  _fromFoldingRegions(foldingRegions) {
    const length2 = foldingRegions.length;
    const orderedStickyElements = [];
    const stickyOutlineElement = new StickyElement(void 0, [], void 0);
    for (let i = 0; i < length2; i++) {
      const parentIndex = foldingRegions.getParentIndex(i);
      let parentNode;
      if (parentIndex !== -1) {
        parentNode = orderedStickyElements[parentIndex];
      } else {
        parentNode = stickyOutlineElement;
      }
      const child = new StickyElement(new StickyRange(foldingRegions.getStartLineNumber(i), foldingRegions.getEndLineNumber(i) + 1), [], parentNode);
      parentNode.children.push(child);
      orderedStickyElements.push(child);
    }
    return stickyOutlineElement;
  }
}
let StickyModelFromCandidateIndentationFoldingProvider = class StickyModelFromCandidateIndentationFoldingProvider2 extends StickyModelFromCandidateFoldingProvider {
  constructor(editor2, _languageConfigurationService) {
    super(editor2);
    this._languageConfigurationService = _languageConfigurationService;
  }
  get provider() {
    return null;
  }
  createModelFromProvider(textModel, modelVersionId, token) {
    const provider = new IndentRangeProvider(textModel, this._languageConfigurationService, this._foldingLimitReporter);
    return provider.compute(token);
  }
};
StickyModelFromCandidateIndentationFoldingProvider = __decorate$7([
  __param$7(1, ILanguageConfigurationService)
], StickyModelFromCandidateIndentationFoldingProvider);
let StickyModelFromCandidateSyntaxFoldingProvider = class StickyModelFromCandidateSyntaxFoldingProvider2 extends StickyModelFromCandidateFoldingProvider {
  constructor(editor2, _languageFeaturesService) {
    super(editor2);
    this._languageFeaturesService = _languageFeaturesService;
  }
  get provider() {
    return this._languageFeaturesService.foldingRangeProvider;
  }
  isProviderValid(textModel) {
    const selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);
    return selectedProviders.length > 0;
  }
  createModelFromProvider(textModel, modelVersionId, token) {
    const selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);
    const provider = new SyntaxRangeProvider(textModel, selectedProviders, () => this.createModelFromProvider(textModel, modelVersionId, token), this._foldingLimitReporter, void 0);
    return provider.compute(token);
  }
};
StickyModelFromCandidateSyntaxFoldingProvider = __decorate$7([
  __param$7(1, ILanguageFeaturesService)
], StickyModelFromCandidateSyntaxFoldingProvider);
var __decorate$6 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$6 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class StickyLineCandidate {
  constructor(startLineNumber, endLineNumber, nestingDepth) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
    this.nestingDepth = nestingDepth;
  }
}
let StickyLineCandidateProvider = class StickyLineCandidateProvider2 extends Disposable {
  constructor(editor2, _languageFeaturesService, _languageConfigurationService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this._languageConfigurationService = _languageConfigurationService;
    this._onDidChangeStickyScroll = this._store.add(new Emitter());
    this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event;
    this._options = null;
    this._model = null;
    this._cts = null;
    this._stickyModelProvider = null;
    this._editor = editor2;
    this._sessionStore = new DisposableStore();
    this._updateSoon = this._register(new RunOnceScheduler(() => this.update(), 50));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        113
        /* EditorOption.stickyScroll */
      )) {
        this.readConfiguration();
      }
    }));
    this.readConfiguration();
  }
  dispose() {
    super.dispose();
    this._sessionStore.dispose();
  }
  readConfiguration() {
    this._options = this._editor.getOption(
      113
      /* EditorOption.stickyScroll */
    );
    if (!this._options.enabled) {
      this._sessionStore.clear();
      return;
    }
    this._stickyModelProvider = new StickyModelProvider(this._editor, this._languageConfigurationService, this._languageFeaturesService, this._options.defaultModel);
    this._sessionStore.add(this._editor.onDidChangeModel(() => this.update()));
    this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update()));
    this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule()));
    this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => this.update()));
    this.update();
  }
  getVersionId() {
    var _a3;
    return (_a3 = this._model) === null || _a3 === void 0 ? void 0 : _a3.version;
  }
  update() {
    var _a3;
    return __awaiter$5(this, void 0, void 0, function* () {
      (_a3 = this._cts) === null || _a3 === void 0 ? void 0 : _a3.dispose(true);
      this._cts = new CancellationTokenSource();
      yield this.updateStickyModel(this._cts.token);
      this._onDidChangeStickyScroll.fire();
    });
  }
  updateStickyModel(token) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._stickyModelProvider) {
        return;
      }
      const textModel = this._editor.getModel();
      const modelVersionId = textModel.getVersionId();
      const isDifferentModel = this._model ? !isEqual(this._model.uri, textModel.uri) : false;
      const resetHandle = isDifferentModel ? setTimeout(() => {
        if (!token.isCancellationRequested) {
          this._model = new StickyModel(textModel.uri, textModel.getVersionId(), void 0, void 0);
          this._onDidChangeStickyScroll.fire();
        }
      }, 75) : void 0;
      this._model = yield this._stickyModelProvider.update(textModel, modelVersionId, token);
      clearTimeout(resetHandle);
    });
  }
  updateIndex(index2) {
    if (index2 === -1) {
      index2 = 0;
    } else if (index2 < 0) {
      index2 = -index2 - 2;
    }
    return index2;
  }
  getCandidateStickyLinesIntersectingFromStickyModel(range, outlineModel, result, depth, lastStartLineNumber) {
    if (outlineModel.children.length === 0) {
      return;
    }
    let lastLine = lastStartLineNumber;
    const childrenStartLines = [];
    for (let i = 0; i < outlineModel.children.length; i++) {
      const child = outlineModel.children[i];
      if (child.range) {
        childrenStartLines.push(child.range.startLineNumber);
      }
    }
    const lowerBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber, (a, b) => {
      return a - b;
    }));
    const upperBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber + depth, (a, b) => {
      return a - b;
    }));
    for (let i = lowerBound; i <= upperBound; i++) {
      const child = outlineModel.children[i];
      if (!child) {
        return;
      }
      if (child.range) {
        const childStartLine = child.range.startLineNumber;
        const childEndLine = child.range.endLineNumber;
        if (range.startLineNumber <= childEndLine + 1 && childStartLine - 1 <= range.endLineNumber && childStartLine !== lastLine) {
          lastLine = childStartLine;
          result.push(new StickyLineCandidate(childStartLine, childEndLine - 1, depth + 1));
          this.getCandidateStickyLinesIntersectingFromStickyModel(range, child, result, depth + 1, childStartLine);
        }
      } else {
        this.getCandidateStickyLinesIntersectingFromStickyModel(range, child, result, depth, lastStartLineNumber);
      }
    }
  }
  getCandidateStickyLinesIntersecting(range) {
    var _a3, _b3;
    if (!((_a3 = this._model) === null || _a3 === void 0 ? void 0 : _a3.element)) {
      return [];
    }
    let stickyLineCandidates = [];
    this.getCandidateStickyLinesIntersectingFromStickyModel(range, this._model.element, stickyLineCandidates, 0, -1);
    const hiddenRanges = (_b3 = this._editor._getViewModel()) === null || _b3 === void 0 ? void 0 : _b3.getHiddenAreas();
    if (hiddenRanges) {
      for (const hiddenRange of hiddenRanges) {
        stickyLineCandidates = stickyLineCandidates.filter((stickyLine) => !(stickyLine.startLineNumber >= hiddenRange.startLineNumber && stickyLine.endLineNumber <= hiddenRange.endLineNumber + 1));
      }
    }
    return stickyLineCandidates;
  }
};
StickyLineCandidateProvider.ID = "store.contrib.stickyScrollController";
StickyLineCandidateProvider = __decorate$6([
  __param$6(1, ILanguageFeaturesService),
  __param$6(2, ILanguageConfigurationService)
], StickyLineCandidateProvider);
var __decorate$5 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$5 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let StickyScrollController = class StickyScrollController2 extends Disposable {
  constructor(_editor, _contextMenuService, _languageFeaturesService, _instaService, _languageConfigurationService, _languageFeatureDebounceService, _contextKeyService) {
    super();
    this._editor = _editor;
    this._contextMenuService = _contextMenuService;
    this._languageFeaturesService = _languageFeaturesService;
    this._instaService = _instaService;
    this._contextKeyService = _contextKeyService;
    this._sessionStore = new DisposableStore();
    this._maxStickyLines = Number.MAX_SAFE_INTEGER;
    this._candidateDefinitionsLength = -1;
    this._focusedStickyElementIndex = -1;
    this._enabled = false;
    this._focused = false;
    this._positionRevealed = false;
    this._onMouseDown = false;
    this._stickyScrollWidget = new StickyScrollWidget(this._editor);
    this._stickyLineCandidateProvider = new StickyLineCandidateProvider(this._editor, _languageFeaturesService, _languageConfigurationService);
    this._register(this._stickyScrollWidget);
    this._register(this._stickyLineCandidateProvider);
    this._widgetState = new StickyScrollWidgetState([], 0);
    this._readConfiguration();
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        113
        /* EditorOption.stickyScroll */
      )) {
        this._readConfiguration();
      }
    }));
    this._register(addDisposableListener(this._stickyScrollWidget.getDomNode(), EventType.CONTEXT_MENU, (event) => __awaiter$4(this, void 0, void 0, function* () {
      this._onContextMenu(event);
    })));
    this._stickyScrollFocusedContextKey = EditorContextKeys.stickyScrollFocused.bindTo(this._contextKeyService);
    this._stickyScrollVisibleContextKey = EditorContextKeys.stickyScrollVisible.bindTo(this._contextKeyService);
    const focusTracker = this._register(trackFocus(this._stickyScrollWidget.getDomNode()));
    this._register(focusTracker.onDidBlur((_) => {
      const height = this._stickyScrollWidget.getDomNode().clientHeight;
      if (this._positionRevealed === false && height === 0) {
        this._focusedStickyElementIndex = -1;
        this.focus();
      } else {
        this._disposeFocusStickyScrollStore();
      }
    }));
    this._register(focusTracker.onDidFocus((_) => {
      this.focus();
    }));
    this._register(this._createClickLinkGesture());
    this._register(addDisposableListener(this._stickyScrollWidget.getDomNode(), EventType.MOUSE_DOWN, (e) => {
      this._onMouseDown = true;
    }));
  }
  get stickyScrollCandidateProvider() {
    return this._stickyLineCandidateProvider;
  }
  get stickyScrollWidgetState() {
    return this._widgetState;
  }
  static get(editor2) {
    return editor2.getContribution(StickyScrollController2.ID);
  }
  _disposeFocusStickyScrollStore() {
    var _a3;
    this._stickyScrollFocusedContextKey.set(false);
    (_a3 = this._focusDisposableStore) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    this._focused = false;
    this._positionRevealed = false;
    this._onMouseDown = false;
  }
  focus() {
    if (this._onMouseDown) {
      this._onMouseDown = false;
      this._editor.focus();
      return;
    }
    const focusState = this._stickyScrollFocusedContextKey.get();
    if (focusState === true) {
      return;
    }
    this._focused = true;
    this._focusDisposableStore = new DisposableStore();
    this._stickyScrollFocusedContextKey.set(true);
    const rootNode = this._stickyScrollWidget.getDomNode();
    rootNode.lastElementChild.focus();
    this._stickyElements = rootNode.children;
    this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumbers.length - 1;
  }
  focusNext() {
    if (this._focusedStickyElementIndex < this._stickyElements.length - 1) {
      this._focusNav(true);
    }
  }
  focusPrevious() {
    if (this._focusedStickyElementIndex > 0) {
      this._focusNav(false);
    }
  }
  selectEditor() {
    this._editor.focus();
  }
  // True is next, false is previous
  _focusNav(direction) {
    this._focusedStickyElementIndex = direction ? this._focusedStickyElementIndex + 1 : this._focusedStickyElementIndex - 1;
    this._stickyElements.item(this._focusedStickyElementIndex).focus();
  }
  goToFocused() {
    const lineNumbers = this._stickyScrollWidget.lineNumbers;
    this._disposeFocusStickyScrollStore();
    this._revealPosition({ lineNumber: lineNumbers[this._focusedStickyElementIndex], column: 1 });
  }
  _revealPosition(position) {
    this._positionRevealed = true;
    this._editor.revealPosition(position);
    this._editor.setSelection(Range$1.fromPositions(position));
    this._editor.focus();
  }
  _createClickLinkGesture() {
    const linkGestureStore = new DisposableStore();
    const sessionStore = new DisposableStore();
    linkGestureStore.add(sessionStore);
    const gesture = new ClickLinkGesture(this._editor, true);
    linkGestureStore.add(gesture);
    linkGestureStore.add(gesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, _keyboardEvent]) => {
      if (!this._editor.hasModel() || !mouseEvent.hasTriggerModifier) {
        sessionStore.clear();
        return;
      }
      const targetMouseEvent = mouseEvent.target;
      if (targetMouseEvent.detail === this._stickyScrollWidget.getId() && targetMouseEvent.element.innerText === targetMouseEvent.element.innerHTML) {
        const text = targetMouseEvent.element.innerText;
        if (this._stickyScrollWidget.hoverOnColumn === -1) {
          return;
        }
        const lineNumber = this._stickyScrollWidget.hoverOnLine;
        const column = this._stickyScrollWidget.hoverOnColumn;
        const stickyPositionProjectedOnEditor = new Range$1(lineNumber, column, lineNumber, column + text.length);
        if (!stickyPositionProjectedOnEditor.equalsRange(this._stickyRangeProjectedOnEditor)) {
          this._stickyRangeProjectedOnEditor = stickyPositionProjectedOnEditor;
          sessionStore.clear();
        } else if (targetMouseEvent.element.style.textDecoration === "underline") {
          return;
        }
        const cancellationToken = new CancellationTokenSource();
        sessionStore.add(toDisposable(() => cancellationToken.dispose(true)));
        let currentHTMLChild;
        getDefinitionsAtPosition(this._languageFeaturesService.definitionProvider, this._editor.getModel(), new Position$1(lineNumber, column + 1), cancellationToken.token).then((candidateDefinitions) => {
          if (cancellationToken.token.isCancellationRequested) {
            return;
          }
          if (candidateDefinitions.length !== 0) {
            this._candidateDefinitionsLength = candidateDefinitions.length;
            const childHTML = targetMouseEvent.element;
            if (currentHTMLChild !== childHTML) {
              sessionStore.clear();
              currentHTMLChild = childHTML;
              currentHTMLChild.style.textDecoration = "underline";
              sessionStore.add(toDisposable(() => {
                currentHTMLChild.style.textDecoration = "none";
              }));
            } else if (!currentHTMLChild) {
              currentHTMLChild = childHTML;
              currentHTMLChild.style.textDecoration = "underline";
              sessionStore.add(toDisposable(() => {
                currentHTMLChild.style.textDecoration = "none";
              }));
            }
          } else {
            sessionStore.clear();
          }
        });
      } else {
        sessionStore.clear();
      }
    }));
    linkGestureStore.add(gesture.onCancel(() => {
      sessionStore.clear();
    }));
    linkGestureStore.add(gesture.onExecute((e) => __awaiter$4(this, void 0, void 0, function* () {
      if (e.target.detail !== this._stickyScrollWidget.getId()) {
        return;
      }
      if (e.hasTriggerModifier) {
        if (this._candidateDefinitionsLength > 1) {
          if (this._focused) {
            this._disposeFocusStickyScrollStore();
          }
          this._revealPosition({ lineNumber: this._stickyScrollWidget.hoverOnLine, column: 1 });
        }
        this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor });
      } else if (!e.isRightClick) {
        if (this._focused) {
          this._disposeFocusStickyScrollStore();
        }
        this._revealPosition({ lineNumber: this._stickyScrollWidget.hoverOnLine, column: this._stickyScrollWidget.hoverOnColumn });
      }
    })));
    return linkGestureStore;
  }
  _onContextMenu(e) {
    const event = new StandardMouseEvent(e);
    this._contextMenuService.showContextMenu({
      menuId: MenuId.StickyScrollContext,
      getAnchor: () => event
    });
  }
  _readConfiguration() {
    const options = this._editor.getOption(
      113
      /* EditorOption.stickyScroll */
    );
    if (options.enabled === false) {
      this._editor.removeOverlayWidget(this._stickyScrollWidget);
      this._sessionStore.clear();
      this._enabled = false;
      return;
    } else if (options.enabled && !this._enabled) {
      this._editor.addOverlayWidget(this._stickyScrollWidget);
      this._sessionStore.add(this._editor.onDidScrollChange(() => this._renderStickyScroll()));
      this._sessionStore.add(this._editor.onDidLayoutChange(() => this._onDidResize()));
      this._sessionStore.add(this._editor.onDidChangeModelTokens((e) => this._onTokensChange(e)));
      this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => this._renderStickyScroll()));
      this._enabled = true;
    }
    const lineNumberOption = this._editor.getOption(
      66
      /* EditorOption.lineNumbers */
    );
    if (lineNumberOption.renderType === 2) {
      this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => this._renderStickyScroll()));
    }
  }
  _needsUpdate(event) {
    const stickyLineNumbers = this._stickyScrollWidget.getCurrentLines();
    for (const stickyLineNumber of stickyLineNumbers) {
      for (const range of event.ranges) {
        if (stickyLineNumber >= range.fromLineNumber && stickyLineNumber <= range.toLineNumber) {
          return true;
        }
      }
    }
    return false;
  }
  _onTokensChange(event) {
    if (this._needsUpdate(event)) {
      this._renderStickyScroll();
    }
  }
  _onDidResize() {
    const layoutInfo = this._editor.getLayoutInfo();
    const width = layoutInfo.width - layoutInfo.minimap.minimapCanvasOuterWidth - layoutInfo.verticalScrollbarWidth;
    this._stickyScrollWidget.getDomNode().style.width = `${width}px`;
    const theoreticalLines = layoutInfo.height / this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    this._maxStickyLines = Math.round(theoreticalLines * 0.25);
  }
  _renderStickyScroll() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const stickyLineVersion = this._stickyLineCandidateProvider.getVersionId();
    if (stickyLineVersion === void 0 || stickyLineVersion === model.getVersionId()) {
      this._widgetState = this.findScrollWidgetState();
      this._stickyScrollVisibleContextKey.set(!(this._widgetState.lineNumbers.length === 0));
      if (!this._focused) {
        this._stickyScrollWidget.setState(this._widgetState);
      } else {
        this._stickyElements = this._stickyScrollWidget.getDomNode().children;
        if (this._focusedStickyElementIndex === -1) {
          this._stickyScrollWidget.setState(this._widgetState);
          this._focusedStickyElementIndex = this._stickyElements.length - 1;
          if (this._focusedStickyElementIndex !== -1) {
            this._stickyElements.item(this._focusedStickyElementIndex).focus();
          }
        } else {
          const focusedStickyElementLineNumber = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];
          this._stickyScrollWidget.setState(this._widgetState);
          if (this._stickyElements.length === 0) {
            this._focusedStickyElementIndex = -1;
          } else {
            const previousFocusedLineNumberExists = this._stickyScrollWidget.lineNumbers.includes(focusedStickyElementLineNumber);
            if (!previousFocusedLineNumberExists) {
              this._focusedStickyElementIndex = this._stickyElements.length - 1;
            }
            this._stickyElements.item(this._focusedStickyElementIndex).focus();
          }
        }
      }
    }
  }
  findScrollWidgetState() {
    const lineHeight = this._editor.getOption(
      65
      /* EditorOption.lineHeight */
    );
    const maxNumberStickyLines = Math.min(this._maxStickyLines, this._editor.getOption(
      113
      /* EditorOption.stickyScroll */
    ).maxLineCount);
    const scrollTop = this._editor.getScrollTop();
    let lastLineRelativePosition = 0;
    const lineNumbers = [];
    const arrayVisibleRanges = this._editor.getVisibleRanges();
    if (arrayVisibleRanges.length !== 0) {
      const fullVisibleRange = new StickyRange(arrayVisibleRanges[0].startLineNumber, arrayVisibleRanges[arrayVisibleRanges.length - 1].endLineNumber);
      const candidateRanges = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(fullVisibleRange);
      for (const range of candidateRanges) {
        const start = range.startLineNumber;
        const end = range.endLineNumber;
        const depth = range.nestingDepth;
        if (end - start > 0) {
          const topOfElementAtDepth = (depth - 1) * lineHeight;
          const bottomOfElementAtDepth = depth * lineHeight;
          const bottomOfBeginningLine = this._editor.getBottomForLineNumber(start) - scrollTop;
          const topOfEndLine = this._editor.getTopForLineNumber(end) - scrollTop;
          const bottomOfEndLine = this._editor.getBottomForLineNumber(end) - scrollTop;
          if (topOfElementAtDepth > topOfEndLine && topOfElementAtDepth <= bottomOfEndLine) {
            lineNumbers.push(start);
            lastLineRelativePosition = bottomOfEndLine - bottomOfElementAtDepth;
            break;
          } else if (bottomOfElementAtDepth > bottomOfBeginningLine && bottomOfElementAtDepth <= bottomOfEndLine) {
            lineNumbers.push(start);
          }
          if (lineNumbers.length === maxNumberStickyLines) {
            break;
          }
        }
      }
    }
    return new StickyScrollWidgetState(lineNumbers, lastLineRelativePosition);
  }
  dispose() {
    super.dispose();
    this._sessionStore.dispose();
  }
};
StickyScrollController.ID = "store.contrib.stickyScrollController";
StickyScrollController = __decorate$5([
  __param$5(1, IContextMenuService),
  __param$5(2, ILanguageFeaturesService),
  __param$5(3, IInstantiationService),
  __param$5(4, ILanguageConfigurationService),
  __param$5(5, ILanguageFeatureDebounceService),
  __param$5(6, IContextKeyService)
], StickyScrollController);
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ToggleStickyScroll extends Action2 {
  constructor() {
    super({
      id: "editor.action.toggleStickyScroll",
      title: {
        value: localize("toggleStickyScroll", "Toggle Sticky Scroll"),
        mnemonicTitle: localize({ key: "mitoggleStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Toggle Sticky Scroll"),
        original: "Toggle Sticky Scroll"
      },
      category: Categories.View,
      toggled: {
        condition: ContextKeyExpr.equals("config.editor.stickyScroll.enabled", true),
        title: localize("stickyScroll", "Sticky Scroll"),
        mnemonicTitle: localize({ key: "miStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Sticky Scroll")
      },
      menu: [
        { id: MenuId.CommandPalette },
        { id: MenuId.MenubarViewMenu, group: "5_editor", order: 2 },
        { id: MenuId.StickyScrollContext }
      ]
    });
  }
  run(accessor) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const configurationService = accessor.get(IConfigurationService);
      const newValue = !configurationService.getValue("editor.stickyScroll.enabled");
      return configurationService.updateValue("editor.stickyScroll.enabled", newValue);
    });
  }
}
const weight = 100;
class FocusStickyScroll extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.focusStickyScroll",
      title: {
        value: localize("focusStickyScroll", "Focus Sticky Scroll"),
        mnemonicTitle: localize({ key: "mifocusStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Focus Sticky Scroll"),
        original: "Focus Sticky Scroll"
      },
      precondition: ContextKeyExpr.and(ContextKeyExpr.has("config.editor.stickyScroll.enabled"), EditorContextKeys.stickyScrollVisible),
      menu: [
        { id: MenuId.CommandPalette }
      ]
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a3;
    (_a3 = StickyScrollController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.focus();
  }
}
class SelectNextStickyScrollLine extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectNextStickyScrollLine",
      title: {
        value: localize("selectNextStickyScrollLine.title", "Select next sticky scroll line"),
        original: "Select next sticky scroll line"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight,
        primary: 18
        /* KeyCode.DownArrow */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a3;
    (_a3 = StickyScrollController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.focusNext();
  }
}
class SelectPreviousStickyScrollLine extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectPreviousStickyScrollLine",
      title: {
        value: localize("selectPreviousStickyScrollLine.title", "Select previous sticky scroll line"),
        original: "Select previous sticky scroll line"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight,
        primary: 16
        /* KeyCode.UpArrow */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a3;
    (_a3 = StickyScrollController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.focusPrevious();
  }
}
class GoToStickyScrollLine extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.goToFocusedStickyScrollLine",
      title: {
        value: localize("goToFocusedStickyScrollLine.title", "Go to focused sticky scroll line"),
        original: "Go to focused sticky scroll line"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight,
        primary: 3
        /* KeyCode.Enter */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a3;
    (_a3 = StickyScrollController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.goToFocused();
  }
}
class SelectEditor extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectEditor",
      title: {
        value: localize("selectEditor.title", "Select Editor"),
        original: "Select Editor"
      },
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight,
        primary: 9
        /* KeyCode.Escape */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    var _a3;
    (_a3 = StickyScrollController.get(editor2)) === null || _a3 === void 0 ? void 0 : _a3.selectEditor();
  }
}
registerEditorContribution(
  StickyScrollController.ID,
  StickyScrollController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerAction2(ToggleStickyScroll);
registerAction2(FocusStickyScroll);
registerAction2(SelectPreviousStickyScrollLine);
registerAction2(SelectNextStickyScrollLine);
registerAction2(GoToStickyScrollLine);
registerAction2(SelectEditor);
var __decorate$4 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$4 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SuggestInlineCompletion {
  constructor(range, insertText, filterText, additionalTextEdits, command, completion2) {
    this.range = range;
    this.insertText = insertText;
    this.filterText = filterText;
    this.additionalTextEdits = additionalTextEdits;
    this.command = command;
    this.completion = completion2;
  }
}
let InlineCompletionResults = class InlineCompletionResults2 extends RefCountedDisposable {
  constructor(model, line, word, completionModel, completions, _suggestMemoryService) {
    super(completions.disposable);
    this.model = model;
    this.line = line;
    this.word = word;
    this.completionModel = completionModel;
    this._suggestMemoryService = _suggestMemoryService;
  }
  canBeReused(model, line, word) {
    return this.model === model && this.line === line && this.word.word.length > 0 && this.word.startColumn === word.startColumn && this.word.endColumn < word.endColumn && this.completionModel.getIncompleteProvider().size === 0;
  }
  get items() {
    var _a3;
    const result = [];
    const { items } = this.completionModel;
    const selectedIndex = this._suggestMemoryService.select(this.model, { lineNumber: this.line, column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta }, items);
    const first2 = Iterable.slice(items, selectedIndex);
    const second = Iterable.slice(items, 0, selectedIndex);
    let resolveCount = 5;
    for (const item of Iterable.concat(first2, second)) {
      if (item.score === FuzzyScore.Default) {
        continue;
      }
      const range = new Range$1(
        item.editStart.lineNumber,
        item.editStart.column,
        item.editInsertEnd.lineNumber,
        item.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta
        // end PLUS character delta
      );
      const insertText = item.completion.insertTextRules && item.completion.insertTextRules & 4 ? { snippet: item.completion.insertText } : item.completion.insertText;
      result.push(new SuggestInlineCompletion(range, insertText, (_a3 = item.filterTextLow) !== null && _a3 !== void 0 ? _a3 : item.labelLow, item.completion.additionalTextEdits, item.completion.command, item));
      if (resolveCount-- >= 0) {
        item.resolve(CancellationToken.None);
      }
    }
    return result;
  }
};
InlineCompletionResults = __decorate$4([
  __param$4(5, ISuggestMemoryService)
], InlineCompletionResults);
let SuggestInlineCompletions = class SuggestInlineCompletions2 {
  constructor(_getEditorOption, _languageFeatureService, _clipboardService, _suggestMemoryService) {
    this._getEditorOption = _getEditorOption;
    this._languageFeatureService = _languageFeatureService;
    this._clipboardService = _clipboardService;
    this._suggestMemoryService = _suggestMemoryService;
  }
  provideInlineCompletions(model, position, context, token) {
    var _a3;
    return __awaiter$2(this, void 0, void 0, function* () {
      if (context.selectedSuggestionInfo) {
        return;
      }
      const config = this._getEditorOption(87, model);
      if (QuickSuggestionsOptions.isAllOff(config)) {
        return;
      }
      model.tokenization.tokenizeIfCheap(position.lineNumber);
      const lineTokens = model.tokenization.getLineTokens(position.lineNumber);
      const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(position.column - 1 - 1, 0)));
      if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "inline") {
        return void 0;
      }
      let wordInfo = model.getWordAtPosition(position);
      let triggerCharacterInfo;
      if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word)) {
        triggerCharacterInfo = this._getTriggerCharacterInfo(model, position);
      }
      if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word) && !triggerCharacterInfo) {
        return;
      }
      if (!wordInfo) {
        wordInfo = model.getWordUntilPosition(position);
      }
      if (wordInfo.endColumn !== position.column) {
        return;
      }
      let result;
      const leadingLineContents = model.getValueInRange(new Range$1(position.lineNumber, 1, position.lineNumber, position.column));
      if (!triggerCharacterInfo && ((_a3 = this._lastResult) === null || _a3 === void 0 ? void 0 : _a3.canBeReused(model, position.lineNumber, wordInfo))) {
        const newLineContext = new LineContext(leadingLineContents, position.column - this._lastResult.word.endColumn);
        this._lastResult.completionModel.lineContext = newLineContext;
        this._lastResult.acquire();
        result = this._lastResult;
      } else {
        const completions = yield provideSuggestionItems(this._languageFeatureService.completionProvider, model, position, new CompletionOptions(void 0, void 0, triggerCharacterInfo === null || triggerCharacterInfo === void 0 ? void 0 : triggerCharacterInfo.providers), triggerCharacterInfo && { triggerKind: 1, triggerCharacter: triggerCharacterInfo.ch }, token);
        let clipboardText;
        if (completions.needsClipboard) {
          clipboardText = yield this._clipboardService.readText();
        }
        const completionModel = new CompletionModel(completions.items, position.column, new LineContext(leadingLineContents, 0), WordDistance.None, this._getEditorOption(116, model), this._getEditorOption(110, model), { boostFullMatch: false, firstMatchCanBeWeak: false }, clipboardText);
        result = new InlineCompletionResults(model, position.lineNumber, wordInfo, completionModel, completions, this._suggestMemoryService);
      }
      this._lastResult = result;
      return result;
    });
  }
  handleItemDidShow(_completions, item) {
    item.completion.resolve(CancellationToken.None);
  }
  freeInlineCompletions(result) {
    result.release();
  }
  _getTriggerCharacterInfo(model, position) {
    var _a3;
    const ch = model.getValueInRange(Range$1.fromPositions({ lineNumber: position.lineNumber, column: position.column - 1 }, position));
    const providers = /* @__PURE__ */ new Set();
    for (const provider of this._languageFeatureService.completionProvider.all(model)) {
      if ((_a3 = provider.triggerCharacters) === null || _a3 === void 0 ? void 0 : _a3.includes(ch)) {
        providers.add(provider);
      }
    }
    if (providers.size === 0) {
      return void 0;
    }
    return { providers, ch };
  }
};
SuggestInlineCompletions = __decorate$4([
  __param$4(1, ILanguageFeaturesService),
  __param$4(2, IClipboardService),
  __param$4(3, ISuggestMemoryService)
], SuggestInlineCompletions);
let EditorContribution = class EditorContribution2 {
  constructor(_editor, languageFeatureService, editorService, instaService) {
    if (++EditorContribution2._counter === 1) {
      const provider = instaService.createInstance(SuggestInlineCompletions, (id, model) => {
        var _a3;
        const editor2 = (_a3 = editorService.listCodeEditors().find((editor3) => editor3.getModel() === model)) !== null && _a3 !== void 0 ? _a3 : _editor;
        return editor2.getOption(id);
      });
      EditorContribution2._disposable = languageFeatureService.inlineCompletionsProvider.register("*", provider);
    }
  }
  dispose() {
    var _a3;
    if (--EditorContribution2._counter === 0) {
      (_a3 = EditorContribution2._disposable) === null || _a3 === void 0 ? void 0 : _a3.dispose();
      EditorContribution2._disposable = void 0;
    }
  }
};
EditorContribution._counter = 0;
EditorContribution = __decorate$4([
  __param$4(1, ILanguageFeaturesService),
  __param$4(2, ICodeEditorService),
  __param$4(3, IInstantiationService)
], EditorContribution);
registerEditorContribution(
  "suggest.inlineCompletionsProvider",
  EditorContribution,
  0
  /* EditorContributionInstantiation.Eager */
);
class ForceRetokenizeAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: localize("forceRetokenize", "Developer: Force Retokenize"),
      alias: "Developer: Force Retokenize",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    model.tokenization.resetTokenization();
    const sw = new StopWatch();
    model.tokenization.forceTokenization(model.getLineCount());
    sw.stop();
    console.log(`tokenization took ${sw.elapsed()}`);
  }
}
registerEditorAction(ForceRetokenizeAction);
class ToggleTabFocusModeAction extends Action2 {
  constructor() {
    super({
      id: ToggleTabFocusModeAction.ID,
      title: { value: localize({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"), original: "Toggle Tab Key Moves Focus" },
      precondition: void 0,
      keybinding: {
        primary: 2048 | 43,
        mac: {
          primary: 256 | 1024 | 43
          /* KeyCode.KeyM */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: true
    });
  }
  run(accessor) {
    const context = accessor.get(IContextKeyService).getContextKeyValue("focusedView") === "terminal" ? "terminalFocus" : "editorFocus";
    const oldValue = TabFocus.getTabFocusMode(context);
    const newValue = !oldValue;
    TabFocus.setTabFocusMode(newValue, context);
    if (newValue) {
      alert(localize("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element"));
    } else {
      alert(localize("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
    }
  }
}
ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
registerAction2(ToggleTabFocusModeAction);
const unicodeHighlighter = "";
const bannerController = "";
var __decorate$3 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$3 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const BANNER_ELEMENT_HEIGHT = 26;
let BannerController = class BannerController2 extends Disposable {
  constructor(_editor, instantiationService) {
    super();
    this._editor = _editor;
    this.instantiationService = instantiationService;
    this.banner = this._register(this.instantiationService.createInstance(Banner));
  }
  hide() {
    this._editor.setBanner(null, 0);
    this.banner.clear();
  }
  show(item) {
    this.banner.show(Object.assign(Object.assign({}, item), { onClose: () => {
      var _a3;
      this.hide();
      (_a3 = item.onClose) === null || _a3 === void 0 ? void 0 : _a3.call(item);
    } }));
    this._editor.setBanner(this.banner.element, BANNER_ELEMENT_HEIGHT);
  }
};
BannerController = __decorate$3([
  __param$3(1, IInstantiationService)
], BannerController);
let Banner = class Banner2 extends Disposable {
  constructor(instantiationService) {
    super();
    this.instantiationService = instantiationService;
    this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    this.element = $$8("div.editor-banner");
    this.element.tabIndex = 0;
  }
  getAriaLabel(item) {
    if (item.ariaLabel) {
      return item.ariaLabel;
    }
    if (typeof item.message === "string") {
      return item.message;
    }
    return void 0;
  }
  getBannerMessage(message) {
    if (typeof message === "string") {
      const element = $$8("span");
      element.innerText = message;
      return element;
    }
    return this.markdownRenderer.render(message).element;
  }
  clear() {
    clearNode(this.element);
  }
  show(item) {
    clearNode(this.element);
    const ariaLabel = this.getAriaLabel(item);
    if (ariaLabel) {
      this.element.setAttribute("aria-label", ariaLabel);
    }
    const iconContainer = append(this.element, $$8("div.icon-container"));
    iconContainer.setAttribute("aria-hidden", "true");
    if (item.icon) {
      iconContainer.appendChild($$8(`div${ThemeIcon.asCSSSelector(item.icon)}`));
    }
    const messageContainer = append(this.element, $$8("div.message-container"));
    messageContainer.setAttribute("aria-hidden", "true");
    messageContainer.appendChild(this.getBannerMessage(item.message));
    this.messageActionsContainer = append(this.element, $$8("div.message-actions-container"));
    if (item.actions) {
      for (const action of item.actions) {
        this._register(this.instantiationService.createInstance(Link$1, this.messageActionsContainer, Object.assign(Object.assign({}, action), { tabIndex: -1 }), {}));
      }
    }
    const actionBarContainer = append(this.element, $$8("div.action-container"));
    this.actionBar = this._register(new ActionBar(actionBarContainer));
    this.actionBar.push(this._register(new Action("banner.close", "Close Banner", ThemeIcon.asClassName(widgetClose), true, () => {
      if (typeof item.onClose === "function") {
        item.onClose();
      }
    })), { icon: true, label: false });
    this.actionBar.setFocusable(false);
  }
};
Banner = __decorate$3([
  __param$3(0, IInstantiationService)
], Banner);
var __decorate$2 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$2 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const warningIcon = registerIcon("extensions-warning-message", Codicon.warning, localize("warningIcon", "Icon shown with a warning message in the extensions editor."));
let UnicodeHighlighter = class UnicodeHighlighter2 extends Disposable {
  constructor(_editor, _editorWorkerService, _workspaceTrustService, instantiationService) {
    super();
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._workspaceTrustService = _workspaceTrustService;
    this._highlighter = null;
    this._bannerClosed = false;
    this._updateState = (state) => {
      if (state && state.hasMore) {
        if (this._bannerClosed) {
          return;
        }
        const max = Math.max(state.ambiguousCharacterCount, state.nonBasicAsciiCharacterCount, state.invisibleCharacterCount);
        let data;
        if (state.nonBasicAsciiCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
            command: new DisableHighlightingOfNonBasicAsciiCharactersAction()
          };
        } else if (state.ambiguousCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
            command: new DisableHighlightingOfAmbiguousCharactersAction()
          };
        } else if (state.invisibleCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
            command: new DisableHighlightingOfInvisibleCharactersAction()
          };
        } else {
          throw new Error("Unreachable");
        }
        this._bannerController.show({
          id: "unicodeHighlightBanner",
          message: data.message,
          icon: warningIcon,
          actions: [
            {
              label: data.command.shortLabel,
              href: `command:${data.command.id}`
            }
          ],
          onClose: () => {
            this._bannerClosed = true;
          }
        });
      } else {
        this._bannerController.hide();
      }
    };
    this._bannerController = this._register(instantiationService.createInstance(BannerController, _editor));
    this._register(this._editor.onDidChangeModel(() => {
      this._bannerClosed = false;
      this._updateHighlighter();
    }));
    this._options = _editor.getOption(
      123
      /* EditorOption.unicodeHighlighting */
    );
    this._register(_workspaceTrustService.onDidChangeTrust((e) => {
      this._updateHighlighter();
    }));
    this._register(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        123
        /* EditorOption.unicodeHighlighting */
      )) {
        this._options = _editor.getOption(
          123
          /* EditorOption.unicodeHighlighting */
        );
        this._updateHighlighter();
      }
    }));
    this._updateHighlighter();
  }
  dispose() {
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    super.dispose();
  }
  _updateHighlighter() {
    this._updateState(null);
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const options = resolveOptions(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
    if ([
      options.nonBasicASCII,
      options.ambiguousCharacters,
      options.invisibleCharacters
    ].every((option) => option === false)) {
      return;
    }
    const highlightOptions = {
      nonBasicASCII: options.nonBasicASCII,
      ambiguousCharacters: options.ambiguousCharacters,
      invisibleCharacters: options.invisibleCharacters,
      includeComments: options.includeComments,
      includeStrings: options.includeStrings,
      allowedCodePoints: Object.keys(options.allowedCharacters).map((c) => c.codePointAt(0)),
      allowedLocales: Object.keys(options.allowedLocales).map((locale) => {
        if (locale === "_os") {
          const osLocale = new Intl.NumberFormat().resolvedOptions().locale;
          return osLocale;
        } else if (locale === "_vscode") {
          return language;
        }
        return locale;
      })
    };
    if (this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri)) {
      this._highlighter = new DocumentUnicodeHighlighter(this._editor, highlightOptions, this._updateState, this._editorWorkerService);
    } else {
      this._highlighter = new ViewportUnicodeHighlighter(this._editor, highlightOptions, this._updateState);
    }
  }
  getDecorationInfo(decoration2) {
    if (this._highlighter) {
      return this._highlighter.getDecorationInfo(decoration2);
    }
    return null;
  }
};
UnicodeHighlighter.ID = "editor.contrib.unicodeHighlighter";
UnicodeHighlighter = __decorate$2([
  __param$2(1, IEditorWorkerService),
  __param$2(2, IWorkspaceTrustManagementService),
  __param$2(3, IInstantiationService)
], UnicodeHighlighter);
function resolveOptions(trusted, options) {
  return {
    nonBasicASCII: options.nonBasicASCII === inUntrustedWorkspace ? !trusted : options.nonBasicASCII,
    ambiguousCharacters: options.ambiguousCharacters,
    invisibleCharacters: options.invisibleCharacters,
    includeComments: options.includeComments === inUntrustedWorkspace ? !trusted : options.includeComments,
    includeStrings: options.includeStrings === inUntrustedWorkspace ? !trusted : options.includeStrings,
    allowedCharacters: options.allowedCharacters,
    allowedLocales: options.allowedLocales
  };
}
let DocumentUnicodeHighlighter = class DocumentUnicodeHighlighter2 extends Disposable {
  constructor(_editor, _options, _updateState, _editorWorkerService) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._editorWorkerService = _editorWorkerService;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const modelVersionId = this._model.getVersionId();
    this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((info) => {
      if (this._model.isDisposed()) {
        return;
      }
      if (this._model.getVersionId() !== modelVersionId) {
        return;
      }
      this._updateState(info);
      const decorations = [];
      if (!info.hasMore) {
        for (const range of info.ranges) {
          decorations.push({
            range,
            options: Decorations.instance.getDecorationFromOptions(this._options)
          });
        }
      }
      this._decorations.set(decorations);
    });
  }
  getDecorationInfo(decoration2) {
    if (!this._decorations.has(decoration2)) {
      return null;
    }
    const model = this._editor.getModel();
    if (!isModelDecorationVisible(model, decoration2)) {
      return null;
    }
    const text = model.getValueInRange(decoration2.range);
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration2),
      inString: isModelDecorationInString(model, decoration2)
    };
  }
};
DocumentUnicodeHighlighter = __decorate$2([
  __param$2(3, IEditorWorkerService)
], DocumentUnicodeHighlighter);
class ViewportUnicodeHighlighter extends Disposable {
  constructor(_editor, _options, _updateState) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidLayoutChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidScrollChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeHiddenAreas(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const ranges = this._editor.getVisibleRanges();
    const decorations = [];
    const totalResult = {
      ranges: [],
      ambiguousCharacterCount: 0,
      invisibleCharacterCount: 0,
      nonBasicAsciiCharacterCount: 0,
      hasMore: false
    };
    for (const range of ranges) {
      const result = UnicodeTextModelHighlighter.computeUnicodeHighlights(this._model, this._options, range);
      for (const r of result.ranges) {
        totalResult.ranges.push(r);
      }
      totalResult.ambiguousCharacterCount += totalResult.ambiguousCharacterCount;
      totalResult.invisibleCharacterCount += totalResult.invisibleCharacterCount;
      totalResult.nonBasicAsciiCharacterCount += totalResult.nonBasicAsciiCharacterCount;
      totalResult.hasMore = totalResult.hasMore || result.hasMore;
    }
    if (!totalResult.hasMore) {
      for (const range of totalResult.ranges) {
        decorations.push({ range, options: Decorations.instance.getDecorationFromOptions(this._options) });
      }
    }
    this._updateState(totalResult);
    this._decorations.set(decorations);
  }
  getDecorationInfo(decoration2) {
    if (!this._decorations.has(decoration2)) {
      return null;
    }
    const model = this._editor.getModel();
    const text = model.getValueInRange(decoration2.range);
    if (!isModelDecorationVisible(model, decoration2)) {
      return null;
    }
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration2),
      inString: isModelDecorationInString(model, decoration2)
    };
  }
}
let UnicodeHighlighterHoverParticipant = class UnicodeHighlighterHoverParticipant2 {
  constructor(_editor, _languageService, _openerService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.hoverOrdinal = 5;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const unicodeHighlighter2 = this._editor.getContribution(UnicodeHighlighter.ID);
    if (!unicodeHighlighter2) {
      return [];
    }
    const result = [];
    const existedReason = /* @__PURE__ */ new Set();
    let index2 = 300;
    for (const d of lineDecorations) {
      const highlightInfo = unicodeHighlighter2.getDecorationInfo(d);
      if (!highlightInfo) {
        continue;
      }
      const char = model.getValueInRange(d.range);
      const codePoint = char.codePointAt(0);
      const codePointStr = formatCodePointMarkdown(codePoint);
      let reason;
      switch (highlightInfo.reason.kind) {
        case 0: {
          if (isBasicASCII(highlightInfo.reason.confusableWith)) {
            reason = localize("unicodeHighlight.characterIsAmbiguousASCII", "The character {0} could be confused with the ASCII character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
          } else {
            reason = localize("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
          }
          break;
        }
        case 1:
          reason = localize("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", codePointStr);
          break;
        case 2:
          reason = localize("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", codePointStr);
          break;
      }
      if (existedReason.has(reason)) {
        continue;
      }
      existedReason.add(reason);
      const adjustSettingsArgs = {
        codePoint,
        reason: highlightInfo.reason,
        inComment: highlightInfo.inComment,
        inString: highlightInfo.inString
      };
      const adjustSettings = localize("unicodeHighlight.adjustSettings", "Adjust settings");
      const uri = `command:${ShowExcludeOptions.ID}?${encodeURIComponent(JSON.stringify(adjustSettingsArgs))}`;
      const markdown = new MarkdownString("", true).appendMarkdown(reason).appendText(" ").appendLink(uri, adjustSettings);
      result.push(new MarkdownHover(this, d.range, [markdown], false, index2++));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
  }
};
UnicodeHighlighterHoverParticipant = __decorate$2([
  __param$2(1, ILanguageService),
  __param$2(2, IOpenerService)
], UnicodeHighlighterHoverParticipant);
function codePointToHex(codePoint) {
  return `U+${codePoint.toString(16).padStart(4, "0")}`;
}
function formatCodePointMarkdown(codePoint) {
  let value = `\`${codePointToHex(codePoint)}\``;
  if (!InvisibleCharacters.isInvisibleCharacter(codePoint)) {
    value += ` "${`${renderCodePointAsInlineCode(codePoint)}`}"`;
  }
  return value;
}
function renderCodePointAsInlineCode(codePoint) {
  if (codePoint === 96) {
    return "`` ` ``";
  }
  return "`" + String.fromCodePoint(codePoint) + "`";
}
function computeReason(char, options) {
  return UnicodeTextModelHighlighter.computeUnicodeHighlightReason(char, options);
}
class Decorations {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  getDecorationFromOptions(options) {
    return this.getDecoration(!options.includeComments, !options.includeStrings);
  }
  getDecoration(hideInComments, hideInStrings) {
    const key = `${hideInComments}${hideInStrings}`;
    let options = this.map.get(key);
    if (!options) {
      options = ModelDecorationOptions.createDynamic({
        description: "unicode-highlight",
        stickiness: 1,
        className: "unicode-highlight",
        showIfCollapsed: true,
        overviewRuler: null,
        minimap: null,
        hideInCommentTokens: hideInComments,
        hideInStringTokens: hideInStrings
      });
      this.map.set(key, options);
    }
    return options;
  }
}
Decorations.instance = new Decorations();
class DisableHighlightingInCommentsAction extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingInComments", "Disable highlighting of characters in comments"),
      alias: "Disable highlighting of characters in comments",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingInComments.shortLabel", "Disable Highlight In Comments");
  }
  run(accessor, editor2, args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.includeComments,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
}
DisableHighlightingInCommentsAction.ID = "editor.action.unicodeHighlight.disableHighlightingInComments";
class DisableHighlightingInStringsAction extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingInStrings", "Disable highlighting of characters in strings"),
      alias: "Disable highlighting of characters in strings",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingInStrings.shortLabel", "Disable Highlight In Strings");
  }
  run(accessor, editor2, args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.includeStrings,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
}
DisableHighlightingInStringsAction.ID = "editor.action.unicodeHighlight.disableHighlightingInStrings";
class DisableHighlightingOfAmbiguousCharactersAction extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
      alias: "Disable highlighting of ambiguous characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.ambiguousCharacters,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
}
DisableHighlightingOfAmbiguousCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
class DisableHighlightingOfInvisibleCharactersAction extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfInvisibleCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
      alias: "Disable highlighting of invisible characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.invisibleCharacters,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
}
DisableHighlightingOfInvisibleCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
class DisableHighlightingOfNonBasicAsciiCharactersAction extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfNonBasicAsciiCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
      alias: "Disable highlighting of non basic ASCII characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield configurationService.updateValue(
        unicodeHighlightConfigKeys.nonBasicASCII,
        false,
        2
        /* ConfigurationTarget.USER */
      );
    });
  }
}
DisableHighlightingOfNonBasicAsciiCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
class ShowExcludeOptions extends EditorAction {
  constructor() {
    super({
      id: ShowExcludeOptions.ID,
      label: localize("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
      alias: "Show Exclude Options",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const { codePoint, reason, inString, inComment } = args;
      const char = String.fromCodePoint(codePoint);
      const quickPickService = accessor.get(IQuickInputService);
      const configurationService = accessor.get(IConfigurationService);
      function getExcludeCharFromBeingHighlightedLabel(codePoint2) {
        if (InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          return localize("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", codePointToHex(codePoint2));
        }
        return localize("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `${codePointToHex(codePoint2)} "${char}"`);
      }
      const options = [];
      if (reason.kind === 0) {
        for (const locale of reason.notAmbiguousInLocales) {
          options.push({
            label: localize("unicodeHighlight.allowCommonCharactersInLanguage", 'Allow unicode characters that are more common in the language "{0}".', locale),
            run: () => __awaiter$1(this, void 0, void 0, function* () {
              excludeLocaleFromBeingHighlighted(configurationService, [locale]);
            })
          });
        }
      }
      options.push({
        label: getExcludeCharFromBeingHighlightedLabel(codePoint),
        run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
      });
      if (inComment) {
        const action = new DisableHighlightingInCommentsAction();
        options.push({ label: action.label, run: () => __awaiter$1(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (inString) {
        const action = new DisableHighlightingInStringsAction();
        options.push({ label: action.label, run: () => __awaiter$1(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      }
      if (reason.kind === 0) {
        const action = new DisableHighlightingOfAmbiguousCharactersAction();
        options.push({ label: action.label, run: () => __awaiter$1(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason.kind === 1) {
        const action = new DisableHighlightingOfInvisibleCharactersAction();
        options.push({ label: action.label, run: () => __awaiter$1(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason.kind === 2) {
        const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
        options.push({ label: action.label, run: () => __awaiter$1(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else {
        expectNever(reason);
      }
      const result = yield quickPickService.pick(options, { title: localize("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options") });
      if (result) {
        yield result.run();
      }
    });
  }
}
ShowExcludeOptions.ID = "editor.action.unicodeHighlight.showExcludeOptions";
function excludeCharFromBeingHighlighted(configurationService, charCodes) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
    let value;
    if (typeof existingValue === "object" && existingValue) {
      value = existingValue;
    } else {
      value = {};
    }
    for (const charCode of charCodes) {
      value[String.fromCodePoint(charCode)] = true;
    }
    yield configurationService.updateValue(
      unicodeHighlightConfigKeys.allowedCharacters,
      value,
      2
      /* ConfigurationTarget.USER */
    );
  });
}
function excludeLocaleFromBeingHighlighted(configurationService, locales) {
  var _a3;
  return __awaiter$1(this, void 0, void 0, function* () {
    const existingValue = (_a3 = configurationService.inspect(unicodeHighlightConfigKeys.allowedLocales).user) === null || _a3 === void 0 ? void 0 : _a3.value;
    let value;
    if (typeof existingValue === "object" && existingValue) {
      value = Object.assign({}, existingValue);
    } else {
      value = {};
    }
    for (const locale of locales) {
      value[locale] = true;
    }
    yield configurationService.updateValue(
      unicodeHighlightConfigKeys.allowedLocales,
      value,
      2
      /* ConfigurationTarget.USER */
    );
  });
}
function expectNever(value) {
  throw new Error(`Unexpected value: ${value}`);
}
registerEditorAction(DisableHighlightingOfAmbiguousCharactersAction);
registerEditorAction(DisableHighlightingOfInvisibleCharactersAction);
registerEditorAction(DisableHighlightingOfNonBasicAsciiCharactersAction);
registerEditorAction(ShowExcludeOptions);
registerEditorContribution(
  UnicodeHighlighter.ID,
  UnicodeHighlighter,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
HoverParticipantRegistry.register(UnicodeHighlighterHoverParticipant);
var __decorate$1 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$1 = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
function writeIgnoreState(codeEditorService, model, state) {
  codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
function readIgnoreState(codeEditorService, model) {
  return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
let UnusualLineTerminatorsDetector = class UnusualLineTerminatorsDetector2 extends Disposable {
  constructor(_editor, _dialogService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._dialogService = _dialogService;
    this._codeEditorService = _codeEditorService;
    this._isPresentingDialog = false;
    this._config = this._editor.getOption(
      124
      /* EditorOption.unusualLineTerminators */
    );
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        124
        /* EditorOption.unusualLineTerminators */
      )) {
        this._config = this._editor.getOption(
          124
          /* EditorOption.unusualLineTerminators */
        );
        this._checkForUnusualLineTerminators();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      if (e.isUndoing) {
        return;
      }
      this._checkForUnusualLineTerminators();
    }));
    this._checkForUnusualLineTerminators();
  }
  _checkForUnusualLineTerminators() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._config === "off") {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      if (!model.mightContainUnusualLineTerminators()) {
        return;
      }
      const ignoreState = readIgnoreState(this._codeEditorService, model);
      if (ignoreState === true) {
        return;
      }
      if (this._editor.getOption(
        89
        /* EditorOption.readOnly */
      )) {
        return;
      }
      if (this._config === "auto") {
        model.removeUnusualLineTerminators(this._editor.getSelections());
        return;
      }
      if (this._isPresentingDialog) {
        return;
      }
      let result;
      try {
        this._isPresentingDialog = true;
        result = yield this._dialogService.confirm({
          title: localize("unusualLineTerminators.title", "Unusual Line Terminators"),
          message: localize("unusualLineTerminators.message", "Detected unusual line terminators"),
          detail: localize("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename(model.uri)),
          primaryButton: localize({ key: "unusualLineTerminators.fix", comment: ["&& denotes a mnemonic"] }, "&&Remove Unusual Line Terminators"),
          cancelButton: localize("unusualLineTerminators.ignore", "Ignore")
        });
      } finally {
        this._isPresentingDialog = false;
      }
      if (!result.confirmed) {
        writeIgnoreState(this._codeEditorService, model, true);
        return;
      }
      model.removeUnusualLineTerminators(this._editor.getSelections());
    });
  }
};
UnusualLineTerminatorsDetector.ID = "editor.contrib.unusualLineTerminatorsDetector";
UnusualLineTerminatorsDetector = __decorate$1([
  __param$1(1, IDialogService),
  __param$1(2, ICodeEditorService)
], UnusualLineTerminatorsDetector);
registerEditorContribution(
  UnusualLineTerminatorsDetector.ID,
  UnusualLineTerminatorsDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = globalThis && globalThis.__param || function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
const ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
function getOccurrencesAtPosition(registry, model, position, token) {
  const orderedByScore = registry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
  }), isNonEmptyArray);
}
class OccurenceAtPositionRequest {
  constructor(_model, _selection, _wordSeparators) {
    this._model = _model;
    this._selection = _selection;
    this._wordSeparators = _wordSeparators;
    this._wordRange = this._getCurrentWordRange(_model, _selection);
    this._result = null;
  }
  get result() {
    if (!this._result) {
      this._result = createCancelablePromise((token) => this._compute(this._model, this._selection, this._wordSeparators, token));
    }
    return this._result;
  }
  _getCurrentWordRange(model, selection) {
    const word = model.getWordAtPosition(selection.getPosition());
    if (word) {
      return new Range$1(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
    }
    return null;
  }
  isValid(model, selection, decorations) {
    const lineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endColumn = selection.endColumn;
    const currentWordRange = this._getCurrentWordRange(model, selection);
    let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));
    for (let i = 0, len = decorations.length; !requestIsValid && i < len; i++) {
      const range = decorations.getRange(i);
      if (range && range.startLineNumber === lineNumber) {
        if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
          requestIsValid = true;
        }
      }
    }
    return requestIsValid;
  }
  cancel() {
    this.result.cancel();
  }
}
class SemanticOccurenceAtPositionRequest extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators, providers) {
    super(model, selection, wordSeparators);
    this._providers = providers;
  }
  _compute(model, selection, wordSeparators, token) {
    return getOccurrencesAtPosition(this._providers, model, selection.getPosition(), token).then((value) => value || []);
  }
}
class TextualOccurenceAtPositionRequest extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators) {
    super(model, selection, wordSeparators);
    this._selectionIsEmpty = selection.isEmpty();
  }
  _compute(model, selection, wordSeparators, token) {
    return timeout(250, token).then(() => {
      if (!selection.isEmpty()) {
        return [];
      }
      const word = model.getWordAtPosition(selection.getPosition());
      if (!word || word.word.length > 1e3) {
        return [];
      }
      const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);
      return matches.map((m) => {
        return {
          range: m.range,
          kind: DocumentHighlightKind$1.Text
        };
      });
    });
  }
  isValid(model, selection, decorations) {
    const currentSelectionIsEmpty = selection.isEmpty();
    if (this._selectionIsEmpty !== currentSelectionIsEmpty) {
      return false;
    }
    return super.isValid(model, selection, decorations);
  }
}
function computeOccurencesAtPosition(registry, model, selection, wordSeparators) {
  if (registry.has(model)) {
    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators, registry);
  }
  return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);
}
registerModelAndPositionCommand("_executeDocumentHighlights", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getOccurrencesAtPosition(languageFeaturesService.documentHighlightProvider, model, position, CancellationToken.None);
});
class WordHighlighter {
  constructor(editor2, providers, linkedHighlighters, contextKeyService) {
    this.toUnhook = new DisposableStore();
    this.workerRequestTokenId = 0;
    this.workerRequestCompleted = false;
    this.workerRequestValue = [];
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
    this.editor = editor2;
    this.providers = providers;
    this.linkedHighlighters = linkedHighlighters;
    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
    this._ignorePositionChangeEvent = false;
    this.occurrencesHighlight = this.editor.getOption(
      79
      /* EditorOption.occurrencesHighlight */
    );
    this.model = this.editor.getModel();
    this.toUnhook.add(editor2.onDidChangeCursorPosition((e) => {
      if (this._ignorePositionChangeEvent) {
        return;
      }
      if (!this.occurrencesHighlight) {
        return;
      }
      this._onPositionChanged(e);
    }));
    this.toUnhook.add(editor2.onDidChangeModelContent((e) => {
      this._stopAll();
    }));
    this.toUnhook.add(editor2.onDidChangeConfiguration((e) => {
      const newValue = this.editor.getOption(
        79
        /* EditorOption.occurrencesHighlight */
      );
      if (this.occurrencesHighlight !== newValue) {
        this.occurrencesHighlight = newValue;
        this._stopAll();
      }
    }));
    this.decorations = this.editor.createDecorationsCollection();
    this.workerRequestTokenId = 0;
    this.workerRequest = null;
    this.workerRequestCompleted = false;
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
  }
  hasDecorations() {
    return this.decorations.length > 0;
  }
  restore() {
    if (!this.occurrencesHighlight) {
      return;
    }
    this._run();
  }
  stop() {
    if (!this.occurrencesHighlight) {
      return;
    }
    this._stopAll();
  }
  _getSortedHighlights() {
    return this.decorations.getRanges().sort(Range$1.compareRangesUsingStarts);
  }
  moveNext() {
    const highlights = this._getSortedHighlights();
    const index2 = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index2 + 1) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  moveBack() {
    const highlights = this._getSortedHighlights();
    const index2 = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index2 - 1 + highlights.length) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  _removeDecorations() {
    if (this.decorations.length > 0) {
      this.decorations.clear();
      this._hasWordHighlights.set(false);
    }
  }
  _stopAll() {
    this._removeDecorations();
    if (this.renderDecorationsTimer !== -1) {
      clearTimeout(this.renderDecorationsTimer);
      this.renderDecorationsTimer = -1;
    }
    if (this.workerRequest !== null) {
      this.workerRequest.cancel();
      this.workerRequest = null;
    }
    if (!this.workerRequestCompleted) {
      this.workerRequestTokenId++;
      this.workerRequestCompleted = true;
    }
  }
  _onPositionChanged(e) {
    if (!this.occurrencesHighlight) {
      this._stopAll();
      return;
    }
    if (e.reason !== 3) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    const editorSelection = this.editor.getSelection();
    const lineNumber = editorSelection.startLineNumber;
    const startColumn = editorSelection.startColumn;
    return this.model.getWordAtPosition({
      lineNumber,
      column: startColumn
    });
  }
  _run() {
    const editorSelection = this.editor.getSelection();
    if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
      this._stopAll();
      return;
    }
    const startColumn = editorSelection.startColumn;
    const endColumn = editorSelection.endColumn;
    const word = this._getWord();
    if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
      this._stopAll();
      return;
    }
    const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this.decorations);
    this.lastCursorPositionChangeTime = (/* @__PURE__ */ new Date()).getTime();
    if (workerRequestIsValid) {
      if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
        clearTimeout(this.renderDecorationsTimer);
        this.renderDecorationsTimer = -1;
        this._beginRenderDecorations();
      }
    } else {
      this._stopAll();
      const myRequestId = ++this.workerRequestTokenId;
      this.workerRequestCompleted = false;
      this.workerRequest = computeOccurencesAtPosition(this.providers, this.model, this.editor.getSelection(), this.editor.getOption(
        128
        /* EditorOption.wordSeparators */
      ));
      this.workerRequest.result.then((data) => {
        if (myRequestId === this.workerRequestTokenId) {
          this.workerRequestCompleted = true;
          this.workerRequestValue = data || [];
          this._beginRenderDecorations();
        }
      }, onUnexpectedError);
    }
  }
  _beginRenderDecorations() {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const minimumRenderTime = this.lastCursorPositionChangeTime + 250;
    if (currentTime >= minimumRenderTime) {
      this.renderDecorationsTimer = -1;
      this.renderDecorations();
    } else {
      this.renderDecorationsTimer = setTimeout(() => {
        this.renderDecorations();
      }, minimumRenderTime - currentTime);
    }
  }
  renderDecorations() {
    this.renderDecorationsTimer = -1;
    const decorations = [];
    for (const info of this.workerRequestValue) {
      if (info.range) {
        decorations.push({
          range: info.range,
          options: getHighlightDecorationOptions(info.kind)
        });
      }
    }
    this.decorations.set(decorations);
    this._hasWordHighlights.set(this.hasDecorations());
    for (const other of this.linkedHighlighters()) {
      if ((other === null || other === void 0 ? void 0 : other.editor.getModel()) === this.editor.getModel()) {
        other._stopAll();
        other.decorations.set(decorations);
        other._hasWordHighlights.set(other.hasDecorations());
      }
    }
  }
  dispose() {
    this._stopAll();
    this.toUnhook.dispose();
  }
}
let WordHighlighterContribution = class WordHighlighterContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(WordHighlighterContribution2.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService) {
    super();
    this.wordHighlighter = null;
    this.linkedContributions = /* @__PURE__ */ new Set();
    const createWordHighlighterIfPossible = () => {
      if (editor2.hasModel()) {
        this.wordHighlighter = new WordHighlighter(editor2, languageFeaturesService.documentHighlightProvider, () => Iterable.map(this.linkedContributions, (c) => c.wordHighlighter), contextKeyService);
      }
    };
    this._register(editor2.onDidChangeModel((e) => {
      if (this.wordHighlighter) {
        this.wordHighlighter.dispose();
        this.wordHighlighter = null;
      }
      createWordHighlighterIfPossible();
    }));
    createWordHighlighterIfPossible();
  }
  saveViewState() {
    if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {
      return true;
    }
    return false;
  }
  moveNext() {
    var _a3;
    (_a3 = this.wordHighlighter) === null || _a3 === void 0 ? void 0 : _a3.moveNext();
  }
  moveBack() {
    var _a3;
    (_a3 = this.wordHighlighter) === null || _a3 === void 0 ? void 0 : _a3.moveBack();
  }
  restoreViewState(state) {
    if (this.wordHighlighter && state) {
      this.wordHighlighter.restore();
    }
  }
  stopHighlighting() {
    var _a3;
    (_a3 = this.wordHighlighter) === null || _a3 === void 0 ? void 0 : _a3.stop();
  }
  linkWordHighlighters(editor2) {
    const other = WordHighlighterContribution2.get(editor2);
    if (!other) {
      return Disposable.None;
    }
    this.linkedContributions.add(other);
    other.linkedContributions.add(this);
    return toDisposable(() => {
      this.linkedContributions.delete(other);
      other.linkedContributions.delete(this);
    });
  }
  dispose() {
    if (this.wordHighlighter) {
      this.wordHighlighter.dispose();
      this.wordHighlighter = null;
    }
    super.dispose();
  }
};
WordHighlighterContribution.ID = "editor.contrib.wordHighlighter";
WordHighlighterContribution = __decorate([
  __param(1, IContextKeyService),
  __param(2, ILanguageFeaturesService)
], WordHighlighterContribution);
class WordHighlightNavigationAction extends EditorAction {
  constructor(next, opts) {
    super(opts);
    this._isNext = next;
  }
  run(accessor, editor2) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    if (this._isNext) {
      controller.moveNext();
    } else {
      controller.moveBack();
    }
  }
}
class NextWordHighlightAction extends WordHighlightNavigationAction {
  constructor() {
    super(true, {
      id: "editor.action.wordHighlight.next",
      label: localize("wordHighlight.next.label", "Go to Next Symbol Highlight"),
      alias: "Go to Next Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class PrevWordHighlightAction extends WordHighlightNavigationAction {
  constructor() {
    super(false, {
      id: "editor.action.wordHighlight.prev",
      label: localize("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
      alias: "Go to Previous Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class TriggerWordHighlightAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: localize("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
      alias: "Trigger Symbol Highlight",
      precondition: ctxHasWordHighlights.toNegated(),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    controller.restoreViewState(true);
  }
}
registerEditorContribution(
  WordHighlighterContribution.ID,
  WordHighlighterContribution,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerEditorAction(TriggerWordHighlightAction);
class MoveWordCommand extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._inSelectionMode = opts.inSelectionMode;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const result = selections.map((sel) => {
      const inPosition = new Position$1(sel.positionLineNumber, sel.positionColumn);
      const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType);
      return this._moveTo(sel, outPosition, this._inSelectionMode);
    });
    model.pushStackElement();
    editor2._getViewModel().setCursorStates("moveWordCommand", 3, result.map((r) => CursorState$1.fromModelSelection(r)));
    if (result.length === 1) {
      const pos = new Position$1(result[0].positionLineNumber, result[0].positionColumn);
      editor2.revealPosition(
        pos,
        0
        /* ScrollType.Smooth */
      );
    }
  }
  _moveTo(from, to, inSelectionMode) {
    if (inSelectionMode) {
      return new Selection(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
    } else {
      return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
    }
  }
}
class WordLeftCommand extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
  }
}
class WordRightCommand extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
  }
}
class CursorWordStartLeft extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
}
class CursorWordEndLeft extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
}
class CursorWordLeft extends WordLeftCommand {
  constructor() {
    var _a3;
    super({
      inSelectionMode: false,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a3 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a3 === void 0 ? void 0 : _a3.negate()),
        primary: 2048 | 15,
        mac: {
          primary: 512 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class CursorWordStartLeftSelect extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
}
class CursorWordEndLeftSelect extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
}
class CursorWordLeftSelect extends WordLeftCommand {
  constructor() {
    var _a3;
    super({
      inSelectionMode: true,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a3 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a3 === void 0 ? void 0 : _a3.negate()),
        primary: 2048 | 1024 | 15,
        mac: {
          primary: 512 | 1024 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class CursorWordAccessibilityLeft extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
}
class CursorWordAccessibilityLeftSelect extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
}
class CursorWordStartRight extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
}
class CursorWordEndRight extends WordRightCommand {
  constructor() {
    var _a3;
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a3 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a3 === void 0 ? void 0 : _a3.negate()),
        primary: 2048 | 17,
        mac: {
          primary: 512 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class CursorWordRight extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
}
class CursorWordStartRightSelect extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
}
class CursorWordEndRightSelect extends WordRightCommand {
  constructor() {
    var _a3;
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a3 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a3 === void 0 ? void 0 : _a3.negate()),
        primary: 2048 | 1024 | 17,
        mac: {
          primary: 512 | 1024 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class CursorWordRightSelect extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
}
class CursorWordAccessibilityRight extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
}
class CursorWordAccessibilityRightSelect extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
}
class DeleteWordCommand extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._whitespaceHeuristics = opts.whitespaceHeuristics;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const autoClosingBrackets = editor2.getOption(
      6
      /* EditorOption.autoClosingBrackets */
    );
    const autoClosingQuotes = editor2.getOption(
      10
      /* EditorOption.autoClosingQuotes */
    );
    const autoClosingPairs = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getAutoClosingPairs();
    const viewModel = editor2._getViewModel();
    const commands2 = selections.map((sel) => {
      const deleteRange = this._delete({
        wordSeparators,
        model,
        selection: sel,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: editor2.getOption(
          8
          /* EditorOption.autoClosingDelete */
        ),
        autoClosingBrackets,
        autoClosingQuotes,
        autoClosingPairs,
        autoClosedCharacters: viewModel.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
class DeleteWordLeftCommand extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    return new Range$1(1, 1, 1, 1);
  }
}
class DeleteWordRightCommand extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordRight(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range$1(lineCount, maxColumn, lineCount, maxColumn);
  }
}
class DeleteWordStartLeft extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: EditorContextKeys.writable
    });
  }
}
class DeleteWordEndLeft extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: EditorContextKeys.writable
    });
  }
}
class DeleteWordLeft extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1,
        mac: {
          primary: 512 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class DeleteWordStartRight extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: EditorContextKeys.writable
    });
  }
}
class DeleteWordEndRight extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: EditorContextKeys.writable
    });
  }
}
class DeleteWordRight extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 20,
        mac: {
          primary: 512 | 20
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class DeleteInsideWord extends EditorAction {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: EditorContextKeys.writable,
      label: localize("deleteInsideWord", "Delete Word"),
      alias: "Delete Word"
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      128
      /* EditorOption.wordSeparators */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const commands2 = selections.map((sel) => {
      const deleteRange = WordOperations.deleteInsideWord(wordSeparators, model, sel);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands2);
    editor2.pushUndoStop();
  }
}
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new CursorWordAccessibilityLeft());
registerEditorCommand(new CursorWordAccessibilityLeftSelect());
registerEditorCommand(new CursorWordAccessibilityRight());
registerEditorCommand(new CursorWordAccessibilityRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());
registerEditorAction(DeleteInsideWord);
class DeleteWordPartLeft extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartLeft(ctx);
    if (r) {
      return r;
    }
    return new Range$1(1, 1, 1, 1);
  }
}
class DeleteWordPartRight extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 20
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartRight(ctx);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range$1(lineCount, maxColumn, lineCount, maxColumn);
  }
}
class WordPartLeftCommand extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartLeft(wordSeparators, model, position);
  }
}
class CursorWordPartLeft extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
class CursorWordPartLeftSelect extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1024 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
class WordPartRightCommand extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartRight(wordSeparators, model, position);
  }
}
class CursorWordPartRight extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class CursorWordPartRightSelect extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1024 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
registerEditorCommand(new DeleteWordPartLeft());
registerEditorCommand(new DeleteWordPartRight());
registerEditorCommand(new CursorWordPartLeft());
registerEditorCommand(new CursorWordPartLeftSelect());
registerEditorCommand(new CursorWordPartRight());
registerEditorCommand(new CursorWordPartRightSelect());
class ReadOnlyMessageController extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._register(this.editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
  }
  _onDidAttemptReadOnlyEdit() {
    const messageController = MessageController.get(this.editor);
    if (messageController && this.editor.hasModel()) {
      let message = this.editor.getOptions().get(
        90
        /* EditorOption.readOnlyMessage */
      );
      if (!message) {
        if (this.editor.isSimpleWidget) {
          message = new MarkdownString(localize("editor.simple.readonly", "Cannot edit in read-only input"));
        } else {
          message = new MarkdownString(localize("editor.readonly", "Cannot edit in read-only editor"));
        }
      }
      messageController.showMessage(message, this.editor.getPosition());
    }
  }
}
ReadOnlyMessageController.ID = "editor.contrib.readOnlyMessageController";
registerEditorContribution(
  ReadOnlyMessageController.ID,
  ReadOnlyMessageController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
const iPadShowKeyboard = "";
class IPadShowKeyboard extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this.widget = null;
    if (isIOS) {
      this._register(editor2.onDidChangeConfiguration(() => this.update()));
      this.update();
    }
  }
  update() {
    const shouldHaveWidget = !this.editor.getOption(
      89
      /* EditorOption.readOnly */
    );
    if (!this.widget && shouldHaveWidget) {
      this.widget = new ShowKeyboardWidget(this.editor);
    } else if (this.widget && !shouldHaveWidget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
  dispose() {
    super.dispose();
    if (this.widget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
}
IPadShowKeyboard.ID = "editor.contrib.iPadShowKeyboard";
class ShowKeyboardWidget extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._domNode = document.createElement("textarea");
    this._domNode.className = "iPadShowKeyboard";
    this._register(addDisposableListener(this._domNode, "touchstart", (e) => {
      this.editor.focus();
    }));
    this._register(addDisposableListener(this._domNode, "focus", (e) => {
      this.editor.focus();
    }));
    this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this);
    super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return ShowKeyboardWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
      /* OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER */
    };
  }
}
ShowKeyboardWidget.ID = "editor.contrib.ShowKeyboardWidget";
registerEditorContribution(
  IPadShowKeyboard.ID,
  IPadShowKeyboard,
  3
  /* EditorContributionInstantiation.Eventually */
);
class ValidatedEditorOptions {
  constructor() {
    this._values = [];
  }
  _read(option) {
    return this._values[option];
  }
  get(id) {
    return this._values[id];
  }
  _write(option, value) {
    this._values[option] = value;
  }
}
class ComputedEditorOptions {
  constructor() {
    this._values = [];
  }
  _read(id) {
    if (id >= this._values.length) {
      throw new Error("Cannot read uninitialized value");
    }
    return this._values[id];
  }
  get(id) {
    return this._read(id);
  }
  _write(id, value) {
    this._values[id] = value;
  }
}
class EditorOptionsUtil {
  static validateOptions(options) {
    const result = new ValidatedEditorOptions();
    for (const editorOption of editorOptionsRegistry) {
      const value = editorOption.name === "_never_" ? void 0 : options[editorOption.name];
      result._write(editorOption.id, editorOption.validate(value));
    }
    return result;
  }
  static computeOptions(options, env) {
    const result = new ComputedEditorOptions();
    for (const editorOption of editorOptionsRegistry) {
      result._write(editorOption.id, editorOption.compute(env, result, options._read(editorOption.id)));
    }
    return result;
  }
  static _deepEquals(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || !a || !b) {
      return a === b;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
      return Array.isArray(a) && Array.isArray(b) ? equals$1(a, b) : false;
    }
    if (Object.keys(a).length !== Object.keys(b).length) {
      return false;
    }
    for (const key in a) {
      if (!EditorOptionsUtil._deepEquals(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  static checkEquals(a, b) {
    const result = [];
    let somethingChanged = false;
    for (const editorOption of editorOptionsRegistry) {
      const changed = !EditorOptionsUtil._deepEquals(a._read(editorOption.id), b._read(editorOption.id));
      result[editorOption.id] = changed;
      if (changed) {
        somethingChanged = true;
      }
    }
    return somethingChanged ? new ConfigurationChangedEvent(result) : null;
  }
  static applyUpdate(options, update) {
    let changed = false;
    for (const editorOption of editorOptionsRegistry) {
      if (update.hasOwnProperty(editorOption.name)) {
        const result = editorOption.applyUpdate(options[editorOption.name], update[editorOption.name]);
        options[editorOption.name] = result.newValue;
        changed = changed || result.didChange;
      }
    }
    return changed;
  }
}
const configurationExtPoint$1 = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "jsonValidation",
  defaultExtensionKind: ["workspace", "web"],
  jsonSchema: {
    description: localize("contributes.jsonValidation", "Contributes json schema configuration."),
    type: "array",
    defaultSnippets: [{ body: [{ fileMatch: "${1:file.json}", url: "${2:url}" }] }],
    items: {
      type: "object",
      defaultSnippets: [{ body: { fileMatch: "${1:file.json}", url: "${2:url}" } }],
      properties: {
        fileMatch: {
          type: ["string", "array"],
          description: localize(
            "contributes.jsonValidation.fileMatch",
            `The file pattern (or an array of patterns) to match, for example "package.json" or "*.launch". Exclusion patterns start with '!'`
          ),
          items: {
            type: ["string"]
          }
        },
        url: {
          description: localize(
            "contributes.jsonValidation.url",
            "A schema URL ('http:', 'https:') or relative path to the extension folder ('./')."
          ),
          type: "string"
        }
      }
    }
  }
});
class JSONValidationExtensionPoint {
  constructor() {
    configurationExtPoint$1.setHandler((extensions) => {
      for (const extension of extensions) {
        const extensionValue = extension.value;
        const collector = extension.collector;
        const extensionLocation = extension.description.extensionLocation;
        if (!extensionValue || !Array.isArray(extensionValue)) {
          collector.error(localize("invalid.jsonValidation", "'configuration.jsonValidation' must be a array"));
          return;
        }
        extensionValue.forEach((extension2) => {
          if (!isString(extension2.fileMatch) && !(Array.isArray(extension2.fileMatch) && extension2.fileMatch.every(isString))) {
            collector.error(localize(
              "invalid.fileMatch",
              "'configuration.jsonValidation.fileMatch' must be defined as a string or an array of strings."
            ));
            return;
          }
          const uri = extension2.url;
          if (!isString(uri)) {
            collector.error(localize(
              "invalid.url",
              "'configuration.jsonValidation.url' must be a URL or relative path"
            ));
            return;
          }
          if (uri.startsWith("./")) {
            try {
              const colorThemeLocation = joinPath(extensionLocation, uri);
              if (!isEqualOrParent(colorThemeLocation, extensionLocation)) {
                collector.warn(localize(
                  "invalid.path.1",
                  "Expected `contributes.{0}.url` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.",
                  configurationExtPoint$1.name,
                  colorThemeLocation.toString(),
                  extensionLocation.path
                ));
              }
            } catch (e) {
              collector.error(localize(
                "invalid.url.fileschema",
                "'configuration.jsonValidation.url' is an invalid relative URL: {0}",
                e.message
              ));
            }
          } else if (!/^[^:/?#]+:\/\//.test(uri)) {
            collector.error(localize(
              "invalid.url.schema",
              "'configuration.jsonValidation.url' must be an absolute URL or start with './'  to reference schemas located in the extension."
            ));
            return;
          }
        });
      }
    });
  }
}
function getInjectedParameters(instantiationService, ctor) {
  return instantiationService.invokeFunction((accessor) => {
    return _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index).map((d) => accessor.get(d.id));
  });
}
function createInjectedClass(ctor) {
  const _ctor = ctor;
  return class extends _ctor {
    constructor(...args) {
      super(...args.slice(1), ...getInjectedParameters(args[0], ctor));
    }
  };
}
let WorkbenchReferencesController = class WorkbenchReferencesController2 extends ReferencesController {
  constructor(editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
    super(false, editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
  }
};
WorkbenchReferencesController = __decorate$U([
  __param$U(1, IContextKeyService),
  __param$U(2, ICodeEditorService),
  __param$U(3, INotificationService),
  __param$U(4, IInstantiationService),
  __param$U(5, IStorageService),
  __param$U(6, IConfigurationService)
], WorkbenchReferencesController);
registerEditorContribution(ReferencesController.ID, WorkbenchReferencesController, 4);
let RangeHighlightDecorations = (_a2 = class extends Disposable {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this._onHighlightRemoved = this._register(new Emitter());
    this.onHighlightRemoved = this._onHighlightRemoved.event;
    this.rangeHighlightDecorationId = null;
    this.editor = null;
    this.editorDisposables = this._register(new DisposableStore());
  }
  removeHighlightRange() {
    if (this.editor && this.rangeHighlightDecorationId) {
      const decorationId = this.rangeHighlightDecorationId;
      this.editor.changeDecorations((accessor) => {
        accessor.removeDecoration(decorationId);
      });
      this._onHighlightRemoved.fire();
    }
    this.rangeHighlightDecorationId = null;
  }
  highlightRange(range, editor2) {
    editor2 = editor2 ?? this.getEditor(range);
    if (isCodeEditor(editor2)) {
      this.doHighlightRange(editor2, range);
    } else if (isCompositeEditor(editor2) && isCodeEditor(editor2.activeCodeEditor)) {
      this.doHighlightRange(editor2.activeCodeEditor, range);
    }
  }
  doHighlightRange(editor2, selectionRange2) {
    this.removeHighlightRange();
    editor2.changeDecorations((changeAccessor) => {
      this.rangeHighlightDecorationId = changeAccessor.addDecoration(selectionRange2.range, this.createRangeHighlightDecoration(selectionRange2.isWholeLine));
    });
    this.setEditor(editor2);
  }
  getEditor(resourceRange) {
    var _a3;
    const resource = (_a3 = this.editorService.activeEditor) == null ? void 0 : _a3.resource;
    if (resource && isEqual(resource, resourceRange.resource) && isCodeEditor(this.editorService.activeTextEditorControl)) {
      return this.editorService.activeTextEditorControl;
    }
    return void 0;
  }
  setEditor(editor2) {
    if (this.editor !== editor2) {
      this.editorDisposables.clear();
      this.editor = editor2;
      this.editorDisposables.add(this.editor.onDidChangeCursorPosition((e) => {
        if (e.reason === 0 || e.reason === 3 || e.reason === 5 || e.reason === 6) {
          this.removeHighlightRange();
        }
      }));
      this.editorDisposables.add(this.editor.onDidChangeModel(() => {
        this.removeHighlightRange();
      }));
      this.editorDisposables.add(this.editor.onDidDispose(() => {
        this.removeHighlightRange();
        this.editor = null;
      }));
    }
  }
  createRangeHighlightDecoration(isWholeLine = true) {
    return isWholeLine ? _a2._WHOLE_LINE_RANGE_HIGHLIGHT : _a2._RANGE_HIGHLIGHT;
  }
  dispose() {
    var _a3;
    super.dispose();
    if ((_a3 = this.editor) == null ? void 0 : _a3.getModel()) {
      this.removeHighlightRange();
      this.editor = null;
    }
  }
}, _a2._WHOLE_LINE_RANGE_HIGHLIGHT = ModelDecorationOptions.register({
  description: "codeeditor-range-highlight-whole",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
}), _a2._RANGE_HIGHLIGHT = ModelDecorationOptions.register({
  description: "codeeditor-range-highlight",
  stickiness: 1,
  className: "rangeHighlight"
}), _a2);
RangeHighlightDecorations = __decorate$U([
  __param$U(0, IEditorService)
], RangeHighlightDecorations);
let FloatingClickWidget = class FloatingClickWidget2 extends Widget {
  constructor(editor2, label, keyBindingAction, keybindingService) {
    super();
    this.editor = editor2;
    this.label = label;
    this._onClick = this._register(new Emitter());
    this.onClick = this._onClick.event;
    this._domNode = $$8(".floating-click-widget");
    this._domNode.style.padding = "6px 11px";
    this._domNode.style.borderRadius = "2px";
    this._domNode.style.cursor = "pointer";
    this._domNode.style.zIndex = "1";
    if (keyBindingAction) {
      const keybinding = keybindingService.lookupKeybinding(keyBindingAction);
      if (keybinding) {
        this.label += ` (${keybinding.getLabel()})`;
      }
    }
  }
  getId() {
    return "editor.overlayWidget.floatingClickWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
    };
  }
  render() {
    clearNode(this._domNode);
    this._domNode.style.backgroundColor = asCssVariableWithDefault(buttonBackground, asCssVariable(editorBackground));
    this._domNode.style.color = asCssVariableWithDefault(buttonForeground, asCssVariable(editorForeground));
    this._domNode.style.border = `1px solid ${asCssVariable(contrastBorder)}`;
    append(this._domNode, $$8("")).textContent = this.label;
    this.onclick(this._domNode, (e) => this._onClick.fire());
    this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this);
    super.dispose();
  }
};
FloatingClickWidget = __decorate$U([
  __param$U(3, IKeybindingService)
], FloatingClickWidget);
let FloatingClickMenu = (_b2 = class extends Disposable {
  constructor(editor2, instantiationService, menuService, contextKeyService) {
    super();
    if (!(editor2 instanceof EmbeddedCodeEditorWidget)) {
      const menu = menuService.createMenu(MenuId.EditorContent, contextKeyService);
      const menuDisposables = new DisposableStore();
      const renderMenuAsFloatingClickBtn = () => {
        menuDisposables.clear();
        if (!editor2.hasModel() || editor2.getOption(60)) {
          return;
        }
        const actions = [];
        createAndFillInActionBarActions(menu, { renderShortTitle: true, shouldForwardArgs: true }, actions);
        if (actions.length === 0) {
          return;
        }
        const [first2] = actions;
        const widget = instantiationService.createInstance(FloatingClickWidget, editor2, first2.label, first2.id);
        menuDisposables.add(widget);
        menuDisposables.add(widget.onClick(() => first2.run(editor2.getModel().uri)));
        widget.render();
      };
      this._store.add(menu);
      this._store.add(menuDisposables);
      this._store.add(menu.onDidChange(renderMenuAsFloatingClickBtn));
      renderMenuAsFloatingClickBtn();
    }
  }
}, _b2.ID = "editor.contrib.floatingClickMenu", _b2);
FloatingClickMenu = __decorate$U([
  __param$U(1, IInstantiationService),
  __param$U(2, IMenuService),
  __param$U(3, IContextKeyService)
], FloatingClickMenu);
let DiffEditorHelperContribution = (_c2 = class extends Disposable {
  constructor(_diffEditor, _instantiationService, _configurationService, _notificationService) {
    super();
    this._diffEditor = _diffEditor;
    this._instantiationService = _instantiationService;
    this._configurationService = _configurationService;
    this._notificationService = _notificationService;
    this._register(createScreenReaderHelp());
    const isEmbeddedDiffEditor = this._diffEditor instanceof EmbeddedDiffEditorWidget || this._diffEditor instanceof EmbeddedDiffEditorWidget2;
    if (!isEmbeddedDiffEditor) {
      const computationResult = observableFromEvent((e) => this._diffEditor.onDidUpdateDiff(e), () => this._diffEditor.getDiffComputationResult());
      const onlyWhiteSpaceChange = computationResult.map((r) => r && !r.identical && r.changes2.length === 0);
      this._register(autorunWithStore2("update state", (reader, store) => {
        if (onlyWhiteSpaceChange.read(reader)) {
          const helperWidget = store.add(this._instantiationService.createInstance(FloatingClickWidget, this._diffEditor.getModifiedEditor(), localize("hintWhitespace", "Show Whitespace Differences"), null));
          store.add(helperWidget.onClick(() => {
            this._configurationService.updateValue("diffEditor.ignoreTrimWhitespace", false);
          }));
          helperWidget.render();
        }
      }));
      this._register(this._diffEditor.onDidUpdateDiff(() => {
        const diffComputationResult = this._diffEditor.getDiffComputationResult();
        if (diffComputationResult && diffComputationResult.quitEarly) {
          this._notificationService.prompt(Severity$1.Warning, localize(
            "hintTimeout",
            "The diff algorithm was stopped early (after {0} ms.)",
            this._diffEditor.maxComputationTime
          ), [{
            label: localize("removeTimeout", "Remove Limit"),
            run: () => {
              this._configurationService.updateValue("diffEditor.maxComputationTime", 0);
            }
          }], {});
        }
      }));
    }
  }
}, _c2.ID = "editor.contrib.diffEditorHelper", _c2);
DiffEditorHelperContribution = __decorate$U([
  __param$U(1, IInstantiationService),
  __param$U(2, IConfigurationService),
  __param$U(3, INotificationService)
], DiffEditorHelperContribution);
function createScreenReaderHelp() {
  return AccessibilityHelpAction.addImplementation(105, "diff-editor", async (accessor) => {
    var _a3, _b3;
    const accessibleViewService = accessor.get(IAccessibleViewService);
    const editorService = accessor.get(IEditorService);
    const codeEditorService = accessor.get(ICodeEditorService);
    const keybindingService = accessor.get(IKeybindingService);
    const next = (_a3 = keybindingService.lookupKeybinding(AccessibleDiffViewerNext.id)) == null ? void 0 : _a3.getAriaLabel();
    const previous = (_b3 = keybindingService.lookupKeybinding(AccessibleDiffViewerPrev.id)) == null ? void 0 : _b3.getAriaLabel();
    if (!(editorService.activeTextEditorControl instanceof DiffEditorWidget2)) {
      return;
    }
    const codeEditor = codeEditorService.getActiveCodeEditor() || codeEditorService.getFocusedCodeEditor();
    if (!codeEditor) {
      return;
    }
    const keys = ["audioCues.diffLineDeleted", "audioCues.diffLineInserted", "audioCues.diffLineModified"];
    accessibleViewService.show({
      verbositySettingKey: "accessibility.verbosity.diffEditor",
      provideContent: () => [
        localize("msg1", "You are in a diff editor."),
        localize(
          "msg2",
          "Press {0} or {1} to view the next or previous diff in the diff review mode that is optimized for screen readers.",
          next,
          previous
        ),
        localize(
          "msg3",
          "To control which audio cues should be played, the following settings can be configured: {0}.",
          keys.join(", ")
        )
      ].join("\n"),
      onClose: () => {
        codeEditor.focus();
      },
      options: { type: "help", ariaLabel: localize("chat-help-label", "Diff editor accessibility help") }
    });
  }, ContextKeyExpr.and(
    ContextKeyEqualsExpr.create("diffEditorVersion", 2),
    ContextKeyEqualsExpr.create("isInDiffEditor", true)
  ));
}
registerDiffEditorContribution(DiffEditorHelperContribution.ID, DiffEditorHelperContribution);
let LargeFileOptimizationsWarner = (_d2 = class extends Disposable {
  constructor(_editor, _notificationService, _configurationService) {
    super();
    this._editor = _editor;
    this._notificationService = _notificationService;
    this._configurationService = _configurationService;
    this._register(this._editor.onDidChangeModel((e) => this._update()));
    this._update();
  }
  _update() {
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (model.isTooLargeForTokenization()) {
      const message = localize({
        key: "largeFile",
        comment: [
          "Variable 0 will be a file name."
        ]
      }, "{0}: tokenization, wrapping and folding have been turned off for this large file in order to reduce memory usage and avoid freezing or crashing.", basename$1(model.uri.path));
      this._notificationService.prompt(Severity$1.Info, message, [
        {
          label: localize("removeOptimizations", "Forcefully Enable Features"),
          run: () => {
            this._configurationService.updateValue(`editor.largeFileOptimizations`, false).then(() => {
              this._notificationService.info(localize(
                "reopenFilePrompt",
                "Please reopen file in order for this setting to take effect."
              ));
            }, (err) => {
              this._notificationService.error(err);
            });
          }
        }
      ], { neverShowAgain: { id: "editor.contrib.largeFileOptimizationsWarner" } });
    }
  }
}, _d2.ID = "editor.contrib.largeFileOptimizationsWarner", _d2);
LargeFileOptimizationsWarner = __decorate$U([
  __param$U(1, INotificationService),
  __param$U(2, IConfigurationService)
], LargeFileOptimizationsWarner);
registerEditorContribution(LargeFileOptimizationsWarner.ID, LargeFileOptimizationsWarner, 1);
var css$1 = ".token-inspect-widget{border:1px solid var(--vscode-editorHoverWidget-border);padding:10px;user-select:text;-webkit-user-select:text;z-index:50}.hc-black .tokens-inspect-widget,.hc-light .tokens-inspect-widget{border-width:2px}.monaco-editor .token-inspect-widget{background-color:var(--vscode-editorHoverWidget-background)}.monaco-editor .token-inspect-widget .tiw-metadata-separator{background-color:var(--vscode-editorHoverWidget-border)}.tiw-token{font-family:var(--monaco-monospace-font)}.tiw-metadata-separator{border:0;height:1px}.tiw-token-length{float:right;font-size:60%;font-weight:400}.tiw-metadata-table{width:100%}.tiw-metadata-value{font-family:var(--monaco-monospace-font);word-break:break-word}.tiw-metadata-values{list-style:none;margin-right:-10px;max-height:300px;overflow-y:auto;padding-left:0}.tiw-metadata-values>.tiw-metadata-value{margin-right:10px}.tiw-metadata-key{min-width:150px;padding-right:10px;vertical-align:top;white-space:nowrap;width:1px}.tiw-metadata-semantic{font-style:italic}.tiw-metadata-scopes{line-height:normal}.tiw-theme-selector{font-family:var(--monaco-monospace-font)}";
n(css$1, {});
function findMatchingThemeRule(theme, scopes, onlyColorRules = true) {
  for (let i = scopes.length - 1; i >= 0; i--) {
    const parentScopes = scopes.slice(0, i);
    const scope = scopes[i];
    const r = findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules);
    if (r) {
      return r;
    }
  }
  return null;
}
function findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules) {
  let result = null;
  for (let i = theme.tokenColors.length - 1; i >= 0; i--) {
    const rule = theme.tokenColors[i];
    if (onlyColorRules && !rule.settings.foreground) {
      continue;
    }
    let selectors;
    if (typeof rule.scope === "string") {
      selectors = rule.scope.split(/,/).map((scope2) => scope2.trim());
    } else if (Array.isArray(rule.scope)) {
      selectors = rule.scope;
    } else {
      continue;
    }
    for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
      const rawSelector = selectors[j];
      const themeRule = new ThemeRule(rawSelector, rule.settings);
      if (themeRule.matches(scope, parentScopes)) {
        if (themeRule.isMoreSpecific(result)) {
          result = themeRule;
        }
      }
    }
  }
  return result;
}
class ThemeRule {
  constructor(rawSelector, settings) {
    this.rawSelector = rawSelector;
    this.settings = settings;
    const rawSelectorPieces = this.rawSelector.split(/ /);
    this.scope = rawSelectorPieces[rawSelectorPieces.length - 1];
    this.parentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
  }
  matches(scope, parentScopes) {
    return ThemeRule._matches(this.scope, this.parentScopes, scope, parentScopes);
  }
  static _cmp(a, b) {
    if (a === null && b === null) {
      return 0;
    }
    if (a === null) {
      return -1;
    }
    if (b === null) {
      return 1;
    }
    if (a.scope.length !== b.scope.length) {
      return a.scope.length - b.scope.length;
    }
    const aParentScopesLen = a.parentScopes.length;
    const bParentScopesLen = b.parentScopes.length;
    if (aParentScopesLen !== bParentScopesLen) {
      return aParentScopesLen - bParentScopesLen;
    }
    for (let i = 0; i < aParentScopesLen; i++) {
      const aLen = a.parentScopes[i].length;
      const bLen = b.parentScopes[i].length;
      if (aLen !== bLen) {
        return aLen - bLen;
      }
    }
    return 0;
  }
  isMoreSpecific(other) {
    return ThemeRule._cmp(this, other) > 0;
  }
  static _matchesOne(selectorScope, scope) {
    const selectorPrefix = selectorScope + ".";
    if (selectorScope === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {
      return true;
    }
    return false;
  }
  static _matches(selectorScope, selectorParentScopes, scope, parentScopes) {
    if (!this._matchesOne(selectorScope, scope)) {
      return false;
    }
    let selectorParentIndex = selectorParentScopes.length - 1;
    let parentIndex = parentScopes.length - 1;
    while (selectorParentIndex >= 0 && parentIndex >= 0) {
      if (this._matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {
        selectorParentIndex--;
      }
      parentIndex--;
    }
    if (selectorParentIndex === -1) {
      return true;
    }
    return false;
  }
}
const IWorkbenchThemeService = refineServiceDecorator(IThemeService);
const VS_LIGHT_THEME = "vs";
const VS_DARK_THEME = "vs-dark";
const VS_HC_THEME = "hc-black";
const VS_HC_LIGHT_THEME = "hc-light";
const THEME_SCOPE_OPEN_PAREN = "[";
const THEME_SCOPE_CLOSE_PAREN = "]";
const THEME_SCOPE_WILDCARD = "*";
const themeScopeRegex = /\[(.+?)\]/g;
var ThemeSettings;
(function(ThemeSettings2) {
  ThemeSettings2["COLOR_THEME"] = "workbench.colorTheme";
  ThemeSettings2["FILE_ICON_THEME"] = "workbench.iconTheme";
  ThemeSettings2["PRODUCT_ICON_THEME"] = "workbench.productIconTheme";
  ThemeSettings2["COLOR_CUSTOMIZATIONS"] = "workbench.colorCustomizations";
  ThemeSettings2["TOKEN_COLOR_CUSTOMIZATIONS"] = "editor.tokenColorCustomizations";
  ThemeSettings2["SEMANTIC_TOKEN_COLOR_CUSTOMIZATIONS"] = "editor.semanticTokenColorCustomizations";
  ThemeSettings2["PREFERRED_DARK_THEME"] = "workbench.preferredDarkColorTheme";
  ThemeSettings2["PREFERRED_LIGHT_THEME"] = "workbench.preferredLightColorTheme";
  ThemeSettings2["PREFERRED_HC_DARK_THEME"] = "workbench.preferredHighContrastColorTheme";
  ThemeSettings2["PREFERRED_HC_LIGHT_THEME"] = "workbench.preferredHighContrastLightColorTheme";
  ThemeSettings2["DETECT_COLOR_SCHEME"] = "window.autoDetectColorScheme";
  ThemeSettings2["DETECT_HC"] = "window.autoDetectHighContrast";
})(ThemeSettings || (ThemeSettings = {}));
var ThemeSettingDefaults;
(function(ThemeSettingDefaults2) {
  ThemeSettingDefaults2["COLOR_THEME_DARK"] = "Default Dark Modern";
  ThemeSettingDefaults2["COLOR_THEME_LIGHT"] = "Default Light Modern";
  ThemeSettingDefaults2["COLOR_THEME_HC_DARK"] = "Default High Contrast";
  ThemeSettingDefaults2["COLOR_THEME_HC_LIGHT"] = "Default High Contrast Light";
  ThemeSettingDefaults2["COLOR_THEME_DARK_OLD"] = "Default Dark+";
  ThemeSettingDefaults2["COLOR_THEME_LIGHT_OLD"] = "Default Light+";
  ThemeSettingDefaults2["FILE_ICON_THEME"] = "vs-seti";
  ThemeSettingDefaults2["PRODUCT_ICON_THEME"] = "Default";
})(ThemeSettingDefaults || (ThemeSettingDefaults = {}));
const COLOR_THEME_DARK_INITIAL_COLORS = {
  "activityBar.background": "#181818",
  "statusBar.background": "#181818",
  "statusBar.noFolderBackground": "#1f1f1f"
};
const COLOR_THEME_LIGHT_INITIAL_COLORS = {
  "activityBar.background": "#f8f8f8",
  "statusBar.background": "#f8f8f8",
  "statusBar.noFolderBackground": "#f8f8f8"
};
var ExtensionData;
(function(ExtensionData2) {
  function toJSONObject(d) {
    return d && { _extensionId: d.extensionId, _extensionIsBuiltin: d.extensionIsBuiltin, _extensionName: d.extensionName, _extensionPublisher: d.extensionPublisher };
  }
  ExtensionData2.toJSONObject = toJSONObject;
  function fromJSONObject(o) {
    if (o && isString(o._extensionId) && isBoolean(o._extensionIsBuiltin) && isString(o._extensionName) && isString(o._extensionPublisher)) {
      return { extensionId: o._extensionId, extensionIsBuiltin: o._extensionIsBuiltin, extensionName: o._extensionName, extensionPublisher: o._extensionPublisher };
    }
    return void 0;
  }
  ExtensionData2.fromJSONObject = fromJSONObject;
  function fromName(publisher, name, isBuiltin = false) {
    return { extensionPublisher: publisher, extensionId: `${publisher}.${name}`, extensionName: name, extensionIsBuiltin: isBuiltin };
  }
  ExtensionData2.fromName = fromName;
})(ExtensionData || (ExtensionData = {}));
const $ = $$8;
let InspectEditorTokensController = (_e2 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_e2.ID);
  }
  constructor(editor2, textMateService, languageService, themeService, notificationService, configurationService, languageFeaturesService) {
    super();
    this._editor = editor2;
    this._textMateService = textMateService;
    this._themeService = themeService;
    this._languageService = languageService;
    this._notificationService = notificationService;
    this._configurationService = configurationService;
    this._languageFeaturesService = languageFeaturesService;
    this._widget = null;
    this._register(this._editor.onDidChangeModel((e) => this.stop()));
    this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
    this._register(this._editor.onKeyUp((e) => e.keyCode === 9 && this.stop()));
  }
  dispose() {
    this.stop();
    super.dispose();
  }
  launch() {
    if (this._widget) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._editor.getModel().uri.scheme === Schemas.vscodeNotebookCell) {
      return;
    }
    this._widget = new InspectEditorTokensWidget(
      this._editor,
      this._textMateService,
      this._languageService,
      this._themeService,
      this._notificationService,
      this._configurationService,
      this._languageFeaturesService
    );
  }
  stop() {
    if (this._widget) {
      this._widget.dispose();
      this._widget = null;
    }
  }
  toggle() {
    if (!this._widget) {
      this.launch();
    } else {
      this.stop();
    }
  }
}, _e2.ID = "editor.contrib.inspectEditorTokens", _e2);
InspectEditorTokensController = __decorate$U([
  __param$U(1, ITextMateTokenizationService),
  __param$U(2, ILanguageService),
  __param$U(3, IWorkbenchThemeService),
  __param$U(4, INotificationService),
  __param$U(5, IConfigurationService),
  __param$U(6, ILanguageFeaturesService)
], InspectEditorTokensController);
class InspectEditorTokens extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inspectTMScopes",
      label: localize("inspectEditorTokens", "Developer: Inspect Editor Tokens and Scopes"),
      alias: "Developer: Inspect Editor Tokens and Scopes",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const controller = InspectEditorTokensController.get(editor2);
    controller == null ? void 0 : controller.toggle();
  }
}
function renderTokenText(tokenText) {
  if (tokenText.length > 40) {
    tokenText = tokenText.substr(0, 20) + "…" + tokenText.substr(tokenText.length - 20);
  }
  let result = "";
  for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
    const charCode = tokenText.charCodeAt(charIndex);
    switch (charCode) {
      case 9:
        result += "→";
        break;
      case 32:
        result += "·";
        break;
      default:
        result += String.fromCharCode(charCode);
    }
  }
  return result;
}
const _InspectEditorTokensWidget = class _InspectEditorTokensWidget extends Disposable {
  constructor(editor2, textMateService, languageService, themeService, notificationService, configurationService, languageFeaturesService) {
    super();
    this.allowEditorOverflow = true;
    this._isDisposed = false;
    this._editor = editor2;
    this._languageService = languageService;
    this._themeService = themeService;
    this._textMateService = textMateService;
    this._notificationService = notificationService;
    this._configurationService = configurationService;
    this._languageFeaturesService = languageFeaturesService;
    this._model = this._editor.getModel();
    this._domNode = document.createElement("div");
    this._domNode.className = "token-inspect-widget";
    this._currentRequestCancellationTokenSource = new CancellationTokenSource();
    this._beginCompute(this._editor.getPosition());
    this._register(this._editor.onDidChangeCursorPosition((e) => this._beginCompute(this._editor.getPosition())));
    this._register(themeService.onDidColorThemeChange((_) => this._beginCompute(this._editor.getPosition())));
    this._register(configurationService.onDidChangeConfiguration((e) => e.affectsConfiguration("editor.semanticHighlighting.enabled") && this._beginCompute(this._editor.getPosition())));
    this._editor.addContentWidget(this);
  }
  dispose() {
    this._isDisposed = true;
    this._editor.removeContentWidget(this);
    this._currentRequestCancellationTokenSource.cancel();
    super.dispose();
  }
  getId() {
    return _InspectEditorTokensWidget._ID;
  }
  _beginCompute(position) {
    const grammar = this._textMateService.createTokenizer(this._model.getLanguageId());
    const semanticTokens2 = this._computeSemanticTokens(position);
    clearNode(this._domNode);
    this._domNode.appendChild(document.createTextNode(localize("inspectTMScopesWidget.loading", "Loading...")));
    Promise.all([grammar, semanticTokens2]).then(([grammar2, semanticTokens3]) => {
      if (this._isDisposed) {
        return;
      }
      this._compute(grammar2, semanticTokens3, position);
      this._domNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;
      this._editor.layoutContentWidget(this);
    }, (err) => {
      this._notificationService.warn(err);
      setTimeout(() => {
        var _a3;
        (_a3 = InspectEditorTokensController.get(this._editor)) == null ? void 0 : _a3.stop();
      });
    });
  }
  _isSemanticColoringEnabled() {
    var _a3;
    const setting = (_a3 = this._configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: this._model.getLanguageId(), resource: this._model.uri })) == null ? void 0 : _a3.enabled;
    if (typeof setting === "boolean") {
      return setting;
    }
    return this._themeService.getColorTheme().semanticHighlighting;
  }
  _compute(grammar, semanticTokens2, position) {
    var _a3;
    const textMateTokenInfo = grammar && this._getTokensAtPosition(grammar, position);
    const semanticTokenInfo = semanticTokens2 && this._getSemanticTokenAtPosition(semanticTokens2, position);
    if (!textMateTokenInfo && !semanticTokenInfo) {
      reset(this._domNode, "No grammar or semantic tokens available.");
      return;
    }
    const tmMetadata = textMateTokenInfo == null ? void 0 : textMateTokenInfo.metadata;
    const semMetadata = semanticTokenInfo == null ? void 0 : semanticTokenInfo.metadata;
    const semTokenText = semanticTokenInfo && renderTokenText(this._model.getValueInRange(semanticTokenInfo.range));
    const tmTokenText = textMateTokenInfo && renderTokenText(this._model.getLineContent(position.lineNumber).substring(textMateTokenInfo.token.startIndex, textMateTokenInfo.token.endIndex));
    const tokenText = semTokenText || tmTokenText || "";
    reset(this._domNode, $("h2.tiw-token", void 0, tokenText, $("span.tiw-token-length", void 0, `${tokenText.length} ${tokenText.length === 1 ? "char" : "chars"}`)));
    append(this._domNode, $("hr.tiw-metadata-separator", { "style": "clear:both" }));
    append(this._domNode, $("table.tiw-metadata-table", void 0, $("tbody", void 0, $("tr", void 0, $("td.tiw-metadata-key", void 0, "language"), $("td.tiw-metadata-value", void 0, (tmMetadata == null ? void 0 : tmMetadata.languageId) || "")), $("tr", void 0, $("td.tiw-metadata-key", void 0, "standard token type"), $("td.tiw-metadata-value", void 0, this._tokenTypeToString((tmMetadata == null ? void 0 : tmMetadata.tokenType) || 0))), ...this._formatMetadata(semMetadata, tmMetadata))));
    if (semanticTokenInfo) {
      append(this._domNode, $("hr.tiw-metadata-separator"));
      const table = append(this._domNode, $("table.tiw-metadata-table", void 0));
      const tbody = append(table, $("tbody", void 0, $("tr", void 0, $("td.tiw-metadata-key", void 0, "semantic token type"), $("td.tiw-metadata-value", void 0, semanticTokenInfo.type))));
      if (semanticTokenInfo.modifiers.length) {
        append(tbody, $("tr", void 0, $("td.tiw-metadata-key", void 0, "modifiers"), $("td.tiw-metadata-value", void 0, semanticTokenInfo.modifiers.join(" "))));
      }
      if (semanticTokenInfo.metadata) {
        const properties = ["foreground", "bold", "italic", "underline", "strikethrough"];
        const propertiesByDefValue = {};
        const allDefValues = new Array();
        for (const property of properties) {
          if (semanticTokenInfo.metadata[property] !== void 0) {
            const definition2 = semanticTokenInfo.definitions[property];
            const defValue = this._renderTokenStyleDefinition(definition2, property);
            const defValueStr = defValue.map((el) => el instanceof HTMLElement ? el.outerHTML : el).join();
            let properties2 = propertiesByDefValue[defValueStr];
            if (!properties2) {
              propertiesByDefValue[defValueStr] = properties2 = [];
              allDefValues.push([defValue, defValueStr]);
            }
            properties2.push(property);
          }
        }
        for (const [defValue, defValueStr] of allDefValues) {
          append(tbody, $("tr", void 0, $("td.tiw-metadata-key", void 0, propertiesByDefValue[defValueStr].join(", ")), $("td.tiw-metadata-value", void 0, ...defValue)));
        }
      }
    }
    if (textMateTokenInfo) {
      const theme = this._themeService.getColorTheme();
      append(this._domNode, $("hr.tiw-metadata-separator"));
      const table = append(this._domNode, $("table.tiw-metadata-table"));
      const tbody = append(table, $("tbody"));
      if (tmTokenText && tmTokenText !== tokenText) {
        append(tbody, $("tr", void 0, $("td.tiw-metadata-key", void 0, "textmate token"), $("td.tiw-metadata-value", void 0, `${tmTokenText} (${tmTokenText.length})`)));
      }
      const scopes = new Array();
      for (let i = textMateTokenInfo.token.scopes.length - 1; i >= 0; i--) {
        scopes.push(textMateTokenInfo.token.scopes[i]);
        if (i > 0) {
          scopes.push($("br"));
        }
      }
      append(tbody, $("tr", void 0, $("td.tiw-metadata-key", void 0, "textmate scopes"), $("td.tiw-metadata-value.tiw-metadata-scopes", void 0, ...scopes)));
      const matchingRule = findMatchingThemeRule(theme, textMateTokenInfo.token.scopes, false);
      const semForeground = (_a3 = semanticTokenInfo == null ? void 0 : semanticTokenInfo.metadata) == null ? void 0 : _a3.foreground;
      if (matchingRule) {
        if (semForeground !== textMateTokenInfo.metadata.foreground) {
          let defValue = $("code.tiw-theme-selector", void 0, matchingRule.rawSelector, $("br"), JSON.stringify(matchingRule.settings, null, "	"));
          if (semForeground) {
            defValue = $("s", void 0, defValue);
          }
          append(tbody, $("tr", void 0, $("td.tiw-metadata-key", void 0, "foreground"), $("td.tiw-metadata-value", void 0, defValue)));
        }
      } else if (!semForeground) {
        append(tbody, $("tr", void 0, $("td.tiw-metadata-key", void 0, "foreground"), $("td.tiw-metadata-value", void 0, "No theme selector")));
      }
    }
  }
  _formatMetadata(semantic, tm) {
    const elements = new Array();
    function render(property) {
      const value = (semantic == null ? void 0 : semantic[property]) || (tm == null ? void 0 : tm[property]);
      if (value !== void 0) {
        const semanticStyle = (semantic == null ? void 0 : semantic[property]) ? "tiw-metadata-semantic" : "";
        elements.push($("tr", void 0, $("td.tiw-metadata-key", void 0, property), $(`td.tiw-metadata-value.${semanticStyle}`, void 0, value)));
      }
      return value;
    }
    const foreground = render("foreground");
    const background = render("background");
    if (foreground && background) {
      const backgroundColor = Color$1.fromHex(background), foregroundColor = Color$1.fromHex(foreground);
      if (backgroundColor.isOpaque()) {
        elements.push($("tr", void 0, $("td.tiw-metadata-key", void 0, "contrast ratio"), $("td.tiw-metadata-value", void 0, backgroundColor.getContrastRatio(foregroundColor.makeOpaque(backgroundColor)).toFixed(2))));
      } else {
        elements.push($("tr", void 0, $("td.tiw-metadata-key", void 0, "Contrast ratio cannot be precise for background colors that use transparency"), $("td.tiw-metadata-value")));
      }
    }
    const fontStyleLabels = new Array();
    function addStyle(key) {
      let label;
      if (semantic && semantic[key]) {
        label = $("span.tiw-metadata-semantic", void 0, key);
      } else if (tm && tm[key]) {
        label = key;
      }
      if (label) {
        if (fontStyleLabels.length) {
          fontStyleLabels.push(" ");
        }
        fontStyleLabels.push(label);
      }
    }
    addStyle("bold");
    addStyle("italic");
    addStyle("underline");
    addStyle("strikethrough");
    if (fontStyleLabels.length) {
      elements.push($("tr", void 0, $("td.tiw-metadata-key", void 0, "font style"), $("td.tiw-metadata-value", void 0, ...fontStyleLabels)));
    }
    return elements;
  }
  _decodeMetadata(metadata) {
    const colorMap = this._themeService.getColorTheme().tokenColorMap;
    const languageId = TokenMetadata.getLanguageId(metadata);
    const tokenType = TokenMetadata.getTokenType(metadata);
    const fontStyle = TokenMetadata.getFontStyle(metadata);
    const foreground = TokenMetadata.getForeground(metadata);
    const background = TokenMetadata.getBackground(metadata);
    return {
      languageId: this._languageService.languageIdCodec.decodeLanguageId(languageId),
      tokenType,
      bold: fontStyle & 2 ? true : void 0,
      italic: fontStyle & 1 ? true : void 0,
      underline: fontStyle & 4 ? true : void 0,
      strikethrough: fontStyle & 8 ? true : void 0,
      foreground: colorMap[foreground],
      background: colorMap[background]
    };
  }
  _tokenTypeToString(tokenType) {
    switch (tokenType) {
      case 0:
        return "Other";
      case 1:
        return "Comment";
      case 2:
        return "String";
      case 3:
        return "RegEx";
      default:
        return "??";
    }
  }
  _getTokensAtPosition(grammar, position) {
    const lineNumber = position.lineNumber;
    const stateBeforeLine = this._getStateBeforeLine(grammar, lineNumber);
    const tokenizationResult1 = grammar.tokenizeLine(this._model.getLineContent(lineNumber), stateBeforeLine);
    const tokenizationResult2 = grammar.tokenizeLine2(this._model.getLineContent(lineNumber), stateBeforeLine);
    let token1Index = 0;
    for (let i = tokenizationResult1.tokens.length - 1; i >= 0; i--) {
      const t = tokenizationResult1.tokens[i];
      if (position.column - 1 >= t.startIndex) {
        token1Index = i;
        break;
      }
    }
    let token2Index = 0;
    for (let i = tokenizationResult2.tokens.length >>> 1; i >= 0; i--) {
      if (position.column - 1 >= tokenizationResult2.tokens[i << 1]) {
        token2Index = i;
        break;
      }
    }
    return {
      token: tokenizationResult1.tokens[token1Index],
      metadata: this._decodeMetadata(tokenizationResult2.tokens[(token2Index << 1) + 1])
    };
  }
  _getStateBeforeLine(grammar, lineNumber) {
    let state = null;
    for (let i = 1; i < lineNumber; i++) {
      const tokenizationResult = grammar.tokenizeLine(this._model.getLineContent(i), state);
      state = tokenizationResult.ruleStack;
    }
    return state;
  }
  isSemanticTokens(token) {
    return token && token.data;
  }
  async _computeSemanticTokens(position) {
    if (!this._isSemanticColoringEnabled()) {
      return null;
    }
    const tokenProviders = this._languageFeaturesService.documentSemanticTokensProvider.ordered(this._model);
    if (tokenProviders.length) {
      const provider = tokenProviders[0];
      const tokens = await Promise.resolve(provider.provideDocumentSemanticTokens(this._model, null, this._currentRequestCancellationTokenSource.token));
      if (this.isSemanticTokens(tokens)) {
        return { tokens, legend: provider.getLegend() };
      }
    }
    const rangeTokenProviders = this._languageFeaturesService.documentRangeSemanticTokensProvider.ordered(this._model);
    if (rangeTokenProviders.length) {
      const provider = rangeTokenProviders[0];
      const lineNumber = position.lineNumber;
      const range = new Range$1(lineNumber, 1, lineNumber, this._model.getLineMaxColumn(lineNumber));
      const tokens = await Promise.resolve(provider.provideDocumentRangeSemanticTokens(this._model, range, this._currentRequestCancellationTokenSource.token));
      if (this.isSemanticTokens(tokens)) {
        return { tokens, legend: provider.getLegend() };
      }
    }
    return null;
  }
  _getSemanticTokenAtPosition(semanticTokens2, pos) {
    const tokenData = semanticTokens2.tokens.data;
    const defaultLanguage = this._model.getLanguageId();
    let lastLine = 0;
    let lastCharacter = 0;
    const posLine = pos.lineNumber - 1, posCharacter = pos.column - 1;
    for (let i = 0; i < tokenData.length; i += 5) {
      const lineDelta = tokenData[i], charDelta = tokenData[i + 1], len = tokenData[i + 2], typeIdx = tokenData[i + 3], modSet = tokenData[i + 4];
      const line = lastLine + lineDelta;
      const character = lineDelta === 0 ? lastCharacter + charDelta : charDelta;
      if (posLine === line && character <= posCharacter && posCharacter < character + len) {
        const type = semanticTokens2.legend.tokenTypes[typeIdx] || "not in legend (ignored)";
        const modifiers = [];
        let modifierSet = modSet;
        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < semanticTokens2.legend.tokenModifiers.length; modifierIndex++) {
          if (modifierSet & 1) {
            modifiers.push(semanticTokens2.legend.tokenModifiers[modifierIndex]);
          }
          modifierSet = modifierSet >> 1;
        }
        if (modifierSet > 0) {
          modifiers.push("not in legend (ignored)");
        }
        const range = new Range$1(line + 1, character + 1, line + 1, character + 1 + len);
        const definitions = {};
        const colorMap = this._themeService.getColorTheme().tokenColorMap;
        const theme = this._themeService.getColorTheme();
        const tokenStyle = theme.getTokenStyleMetadata(type, modifiers, defaultLanguage, true, definitions);
        let metadata = void 0;
        if (tokenStyle) {
          metadata = {
            languageId: void 0,
            tokenType: 0,
            bold: tokenStyle == null ? void 0 : tokenStyle.bold,
            italic: tokenStyle == null ? void 0 : tokenStyle.italic,
            underline: tokenStyle == null ? void 0 : tokenStyle.underline,
            strikethrough: tokenStyle == null ? void 0 : tokenStyle.strikethrough,
            foreground: colorMap[(tokenStyle == null ? void 0 : tokenStyle.foreground) || 0],
            background: void 0
          };
        }
        return { type, modifiers, range, metadata, definitions };
      }
      lastLine = line;
      lastCharacter = character;
    }
    return null;
  }
  _renderTokenStyleDefinition(definition2, property) {
    const elements = new Array();
    if (definition2 === void 0) {
      return elements;
    }
    const theme = this._themeService.getColorTheme();
    if (Array.isArray(definition2)) {
      const scopesDefinition = {};
      theme.resolveScopes(definition2, scopesDefinition);
      const matchingRule = scopesDefinition[property];
      if (matchingRule && scopesDefinition.scope) {
        const scopes = $("ul.tiw-metadata-values");
        const strScopes = Array.isArray(matchingRule.scope) ? matchingRule.scope : [String(matchingRule.scope)];
        for (const strScope of strScopes) {
          scopes.appendChild($("li.tiw-metadata-value.tiw-metadata-scopes", void 0, strScope));
        }
        elements.push(scopesDefinition.scope.join(" "), scopes, $("code.tiw-theme-selector", void 0, JSON.stringify(matchingRule.settings, null, "	")));
        return elements;
      }
      return elements;
    } else if (SemanticTokenRule.is(definition2)) {
      const scope = theme.getTokenStylingRuleScope(definition2);
      if (scope === "setting") {
        elements.push(`User settings: ${definition2.selector.id} - ${this._renderStyleProperty(definition2.style, property)}`);
        return elements;
      } else if (scope === "theme") {
        elements.push(`Color theme: ${definition2.selector.id} - ${this._renderStyleProperty(definition2.style, property)}`);
        return elements;
      }
      return elements;
    } else {
      const style = theme.resolveTokenStyleValue(definition2);
      elements.push(`Default: ${style ? this._renderStyleProperty(style, property) : ""}`);
      return elements;
    }
  }
  _renderStyleProperty(style, property) {
    switch (property) {
      case "foreground":
        return style.foreground ? Color$1.Format.CSS.formatHexA(style.foreground, true) : "";
      default:
        return style[property] !== void 0 ? String(style[property]) : "";
    }
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._editor.getPosition(),
      preference: [2, 1]
    };
  }
};
_InspectEditorTokensWidget._ID = "editor.contrib.inspectEditorTokensWidget";
let InspectEditorTokensWidget = _InspectEditorTokensWidget;
registerEditorContribution(InspectEditorTokensController.ID, InspectEditorTokensController, 4);
registerEditorAction(InspectEditorTokens);
var css = '.monaco-editor .dirty-diff-glyph{margin-left:5px;z-index:5}.monaco-editor .dirty-diff-glyph:before{content:"";height:100%;left:-2px;position:absolute;width:0}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-glyph:before{transition:width 80ms linear,left 80ms linear,transform 80ms linear}.monaco-editor.modified-in-monaco-diff-editor .margin-view-overlays>div>.dirty-diff-glyph{display:none}.monaco-editor .dirty-diff-added{border-left-color:var(--vscode-editorGutter-addedBackground);border-left-style:solid}.monaco-editor .dirty-diff-added:before{background:var(--vscode-editorGutter-addedBackground)}.monaco-editor .dirty-diff-added-pattern{background-repeat:repeat-y}.monaco-editor .dirty-diff-added-pattern,.monaco-editor .dirty-diff-added-pattern:before{background-image:linear-gradient(-45deg,var(--vscode-editorGutter-addedBackground) 25%,var(--vscode-editorGutter-background) 25%,var(--vscode-editorGutter-background) 50%,var(--vscode-editorGutter-addedBackground) 50%,var(--vscode-editorGutter-addedBackground) 75%,var(--vscode-editorGutter-background) 75%,var(--vscode-editorGutter-background))}.monaco-editor .dirty-diff-added-pattern:before{transform:translateX(3px)}.monaco-editor .dirty-diff-modified{border-left-color:var(--vscode-editorGutter-modifiedBackground);border-left-style:solid}.monaco-editor .dirty-diff-modified:before{background:var(--vscode-editorGutter-modifiedBackground)}.monaco-editor .dirty-diff-modified-pattern{background-image:linear-gradient(-45deg,var(--vscode-editorGutter-modifiedBackground) 25%,var(--vscode-editorGutter-background) 25%,var(--vscode-editorGutter-background) 50%,var(--vscode-editorGutter-modifiedBackground) 50%,var(--vscode-editorGutter-modifiedBackground) 75%,var(--vscode-editorGutter-background) 75%,var(--vscode-editorGutter-background));background-repeat:repeat-y}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-added,.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-added-pattern,.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-modified,.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-modified-pattern{transition:opacity .5s}.monaco-editor .dirty-diff-modified-pattern:before{background-image:linear-gradient(-45deg,var(--vscode-editorGutter-modifiedBackground) 25%,var(--vscode-editorGutter-background) 25%,var(--vscode-editorGutter-background) 50%,var(--vscode-editorGutter-modifiedBackground) 50%,var(--vscode-editorGutter-modifiedBackground) 75%,var(--vscode-editorGutter-background) 75%,var(--vscode-editorGutter-background));transform:translateX(3px)}.monaco-editor .margin:hover .dirty-diff-added,.monaco-editor .margin:hover .dirty-diff-added-pattern,.monaco-editor .margin:hover .dirty-diff-modified,.monaco-editor .margin:hover .dirty-diff-modified-pattern{opacity:1}.monaco-editor .dirty-diff-deleted:after{border-bottom:4px solid transparent;border-left:4px solid var(--vscode-editorGutter-deletedBackground);border-top:4px solid transparent;bottom:-4px;box-sizing:border-box;content:"";height:0;pointer-events:none;position:absolute;width:4px;z-index:9}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-deleted:after{transition:border-top-width 80ms linear,border-bottom-width 80ms linear,bottom 80ms linear,opacity .5s}.monaco-editor .dirty-diff-deleted:before{background:var(--vscode-editorGutter-deletedBackground);bottom:0;height:0;margin-left:3px}.monaco-workbench:not(.reduce-motion) .monaco-editor .dirty-diff-deleted:before{transition:height 80ms linear}.dirty-diff .peekview-title .dropdown{margin-right:10px}.dirty-diff .peekview-title .dropdown.select-container{cursor:default}.dirty-diff .peekview-title .dropdown .monaco-select-box{cursor:pointer;min-height:18px;min-width:100px;padding:0 23px 0 8px}';
n(css, {});
let SwitchQuickDiffViewItem = class SwitchQuickDiffViewItem2 extends SelectActionViewItem {
  constructor(action, providers, selected, contextViewService, themeService) {
    const items = providers.map((provider) => ({ provider, text: provider }));
    let startingSelection = providers.indexOf(selected);
    if (startingSelection === -1) {
      startingSelection = 0;
    }
    const styles = { ...defaultSelectBoxStyles };
    const theme = themeService.getColorTheme();
    const editorBackgroundColor = theme.getColor(editorBackground);
    const peekTitleColor = theme.getColor(peekViewTitleBackground);
    const opaqueTitleColor = (peekTitleColor == null ? void 0 : peekTitleColor.makeOpaque(editorBackgroundColor)) ?? editorBackgroundColor;
    styles.selectBackground = opaqueTitleColor.lighten(0.6).toString();
    super(null, action, items, startingSelection, contextViewService, styles, { ariaLabel: localize("remotes", "Switch quick diff base") });
    this.optionsItems = items;
  }
  setSelection(provider) {
    const index2 = this.optionsItems.findIndex((item) => item.provider === provider);
    this.select(index2);
  }
  getActionContext(_, index2) {
    return this.optionsItems[index2];
  }
  render(container) {
    super.render(container);
    this.setFocusable(true);
  }
};
SwitchQuickDiffViewItem = __decorate$U([
  __param$U(3, IContextViewService),
  __param$U(4, IThemeService)
], SwitchQuickDiffViewItem);
const _SwitchQuickDiffBaseAction = class _SwitchQuickDiffBaseAction extends Action {
  constructor(callback) {
    super(_SwitchQuickDiffBaseAction.ID, _SwitchQuickDiffBaseAction.LABEL, void 0, void 0);
    this.callback = callback;
  }
  async run(event) {
    return this.callback(event);
  }
};
_SwitchQuickDiffBaseAction.ID = "quickDiff.base.switch";
_SwitchQuickDiffBaseAction.LABEL = localize("quickDiff.base.switch", "Switch Quick Diff Base");
let SwitchQuickDiffBaseAction = _SwitchQuickDiffBaseAction;
class DiffActionRunner extends ActionRunner {
  runAction(action, context) {
    if (action instanceof MenuItemAction) {
      return action.run(...context);
    }
    return super.runAction(action, context);
  }
}
const isDirtyDiffVisible = new RawContextKey("dirtyDiffVisible", false);
function getChangeHeight(change) {
  const modified = change.modifiedEndLineNumber - change.modifiedStartLineNumber + 1;
  const original = change.originalEndLineNumber - change.originalStartLineNumber + 1;
  if (change.originalEndLineNumber === 0) {
    return modified;
  } else if (change.modifiedEndLineNumber === 0) {
    return original;
  } else {
    return modified + original;
  }
}
function getModifiedEndLineNumber(change) {
  if (change.modifiedEndLineNumber === 0) {
    return change.modifiedStartLineNumber === 0 ? 1 : change.modifiedStartLineNumber;
  } else {
    return change.modifiedEndLineNumber;
  }
}
function lineIntersectsChange(lineNumber, change) {
  if (lineNumber === 1 && change.modifiedStartLineNumber === 0 && change.modifiedEndLineNumber === 0) {
    return true;
  }
  return lineNumber >= change.modifiedStartLineNumber && lineNumber <= (change.modifiedEndLineNumber || change.modifiedStartLineNumber);
}
let UIEditorAction = class UIEditorAction2 extends Action {
  constructor(editor2, action, cssClass, keybindingService, instantiationService) {
    const keybinding = keybindingService.lookupKeybinding(action.id);
    const label = action.label + (keybinding ? ` (${keybinding.getLabel()})` : "");
    super(action.id, label, cssClass);
    this.instantiationService = instantiationService;
    this.action = action;
    this.editor = editor2;
  }
  run() {
    return Promise.resolve(this.instantiationService.invokeFunction((accessor) => this.action.run(accessor, this.editor, null)));
  }
};
UIEditorAction = __decorate$U([
  __param$U(3, IKeybindingService),
  __param$U(4, IInstantiationService)
], UIEditorAction);
var ChangeType;
(function(ChangeType2) {
  ChangeType2[ChangeType2["Modify"] = 0] = "Modify";
  ChangeType2[ChangeType2["Add"] = 1] = "Add";
  ChangeType2[ChangeType2["Delete"] = 2] = "Delete";
})(ChangeType || (ChangeType = {}));
function getChangeType(change) {
  if (change.originalEndLineNumber === 0) {
    return ChangeType.Add;
  } else if (change.modifiedEndLineNumber === 0) {
    return ChangeType.Delete;
  } else {
    return ChangeType.Modify;
  }
}
function getChangeTypeColor(theme, changeType) {
  switch (changeType) {
    case ChangeType.Modify:
      return theme.getColor(editorGutterModifiedBackground);
    case ChangeType.Add:
      return theme.getColor(editorGutterAddedBackground);
    case ChangeType.Delete:
      return theme.getColor(editorGutterDeletedBackground);
  }
}
function getOuterEditorFromDiffEditor(accessor) {
  const diffEditors = accessor.get(ICodeEditorService).listDiffEditors();
  for (const diffEditor of diffEditors) {
    if (diffEditor.hasTextFocus() && diffEditor instanceof EmbeddedDiffEditorWidget) {
      return diffEditor.getParentEditor();
    }
  }
  return getOuterEditor(accessor);
}
let DirtyDiffWidget = class DirtyDiffWidget2 extends PeekViewWidget {
  constructor(editor2, model, themeService, instantiationService, menuService, contextKeyService) {
    super(editor2, { isResizeable: true, frameWidth: 1, keepEditorSelection: true, className: "dirty-diff" }, instantiationService);
    this.model = model;
    this.themeService = themeService;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this._index = 0;
    this._provider = "";
    this.height = void 0;
    this._disposables.add(themeService.onDidColorThemeChange(this._applyTheme, this));
    this._applyTheme(themeService.getColorTheme());
    if (this.model.original.length > 0) {
      contextKeyService = contextKeyService.createOverlay([["originalResourceScheme", this.model.original[0].uri.scheme], ["originalResourceSchemes", this.model.original.map((original) => original.uri.scheme)]]);
    }
    this.create();
    if (editor2.hasModel()) {
      this.title = basename(editor2.getModel().uri);
    } else {
      this.title = "";
    }
    this.setTitle(this.title);
  }
  get provider() {
    return this._provider;
  }
  get index() {
    return this._index;
  }
  get visibleRange() {
    const visibleRanges = this.diffEditor.getModifiedEditor().getVisibleRanges();
    return visibleRanges.length >= 0 ? visibleRanges[0] : void 0;
  }
  showChange(index2, usePosition = true) {
    var _a3;
    const labeledChange = this.model.changes[index2];
    const change = labeledChange.change;
    this._index = index2;
    this.contextKeyService.createKey("originalResourceScheme", this.model.changes[index2].uri.scheme);
    this.updateActions();
    this._provider = labeledChange.label;
    this.change = change;
    const originalModel = this.model.original;
    if (!originalModel) {
      return;
    }
    const onFirstDiffUpdate = Event.once(this.diffEditor.onDidUpdateDiff);
    onFirstDiffUpdate(() => setTimeout(() => this.revealChange(change), 0));
    const diffEditorModel = this.model.getDiffEditorModel(labeledChange.uri.toString());
    if (!diffEditorModel) {
      return;
    }
    this.diffEditor.setModel(diffEditorModel);
    (_a3 = this.dropdown) == null ? void 0 : _a3.setSelection(labeledChange.label);
    const position = new Position$1(getModifiedEndLineNumber(change), 1);
    const lineHeight = this.editor.getOption(65);
    const editorHeight = this.editor.getLayoutInfo().height;
    const editorHeightInLines = Math.floor(editorHeight / lineHeight);
    const height = Math.min(getChangeHeight(change) + 8, Math.floor(editorHeightInLines / 3));
    this.renderTitle(labeledChange.label);
    const changeType = getChangeType(change);
    const changeTypeColor = getChangeTypeColor(this.themeService.getColorTheme(), changeType);
    this.style({ frameColor: changeTypeColor, arrowColor: changeTypeColor });
    const providerSpecificChanges = [];
    let contextIndex = index2;
    for (const change2 of this.model.changes) {
      if (change2.label === this.model.changes[this._index].label) {
        providerSpecificChanges.push(change2.change);
        if (labeledChange === change2) {
          contextIndex = providerSpecificChanges.length - 1;
        }
      }
    }
    this._actionbarWidget.context = [diffEditorModel.modified.uri, providerSpecificChanges, contextIndex];
    if (usePosition) {
      this.show(position, height);
    }
    this.editor.focus();
  }
  renderTitle(label) {
    const providerChanges = this.model.mapChanges.get(label);
    const providerIndex = providerChanges.indexOf(this._index);
    let detail;
    if (!this.shouldUseDropdown()) {
      detail = this.model.changes.length > 1 ? localize(
        "changes",
        "{0} - {1} of {2} changes",
        label,
        providerIndex + 1,
        providerChanges.length
      ) : localize(
        "change",
        "{0} - {1} of {2} change",
        label,
        providerIndex + 1,
        providerChanges.length
      );
      this.dropdownContainer.style.display = "none";
    } else {
      detail = this.model.changes.length > 1 ? localize(
        "multiChanges",
        "{0} of {1} changes",
        providerIndex + 1,
        providerChanges.length
      ) : localize(
        "multiChange",
        "{0} of {1} change",
        providerIndex + 1,
        providerChanges.length
      );
      this.dropdownContainer.style.display = "inherit";
    }
    this.setTitle(this.title, detail);
  }
  switchQuickDiff(event) {
    const newProvider = event == null ? void 0 : event.provider;
    if (newProvider === this.model.changes[this._index].label) {
      return;
    }
    let closestGreaterIndex = this._index < this.model.changes.length - 1 ? this._index + 1 : 0;
    for (let i = closestGreaterIndex; i !== this._index; i < this.model.changes.length - 1 ? i++ : i = 0) {
      if (this.model.changes[i].label === newProvider) {
        closestGreaterIndex = i;
        break;
      }
    }
    let closestLesserIndex = this._index > 0 ? this._index - 1 : this.model.changes.length - 1;
    for (let i = closestLesserIndex; i !== this._index; i >= 0 ? i-- : i = this.model.changes.length - 1) {
      if (this.model.changes[i].label === newProvider) {
        closestLesserIndex = i;
        break;
      }
    }
    const closestIndex = Math.abs(this.model.changes[closestGreaterIndex].change.modifiedEndLineNumber - this.model.changes[this._index].change.modifiedEndLineNumber) < Math.abs(this.model.changes[closestLesserIndex].change.modifiedEndLineNumber - this.model.changes[this._index].change.modifiedEndLineNumber) ? closestGreaterIndex : closestLesserIndex;
    this.showChange(closestIndex, false);
  }
  shouldUseDropdown() {
    let providersWithChangesCount = 0;
    if (this.model.mapChanges.size > 1) {
      const keys = Array.from(this.model.mapChanges.keys());
      for (let i = 0; i < keys.length && providersWithChangesCount <= 1; i++) {
        if (this.model.mapChanges.get(keys[i]).length > 0) {
          providersWithChangesCount++;
        }
      }
    }
    return providersWithChangesCount >= 2;
  }
  updateActions() {
    if (!this._actionbarWidget) {
      return;
    }
    const previous = this.instantiationService.createInstance(UIEditorAction, this.editor, new ShowPreviousChangeAction(this.editor), ThemeIcon.asClassName(gotoPreviousLocation));
    const next = this.instantiationService.createInstance(UIEditorAction, this.editor, new ShowNextChangeAction(this.editor), ThemeIcon.asClassName(gotoNextLocation));
    this._disposables.add(previous);
    this._disposables.add(next);
    const actions = [];
    if (this.menu) {
      this.menu.dispose();
    }
    this.menu = this.menuService.createMenu(MenuId.SCMChangeContext, this.contextKeyService);
    createAndFillInActionBarActions(this.menu, { shouldForwardArgs: true }, actions);
    this._actionbarWidget.clear();
    this._actionbarWidget.push(actions.reverse(), { label: false, icon: true });
    this._actionbarWidget.push([next, previous], { label: false, icon: true });
    this._actionbarWidget.push(new Action("peekview.close", localize("label.close", "Close"), ThemeIcon.asClassName(Codicon.close), true, () => this.dispose()), { label: false, icon: true });
  }
  _fillHead(container) {
    super._fillHead(container, true);
    this.dropdownContainer = prepend(this._titleElement, $$8(".dropdown"));
    this.dropdown = this.instantiationService.createInstance(SwitchQuickDiffViewItem, new SwitchQuickDiffBaseAction((event) => this.switchQuickDiff(event)), this.model.quickDiffs.map((quickDiffer) => quickDiffer.label), this.model.changes[this._index].label);
    this.dropdown.render(this.dropdownContainer);
    this.updateActions();
  }
  _getActionBarOptions() {
    const actionRunner = new DiffActionRunner();
    actionRunner.onDidRun((e) => {
      if (!(e.action instanceof UIEditorAction) && !e.error) {
        this.dispose();
      }
    });
    return {
      ...super._getActionBarOptions(),
      actionRunner
    };
  }
  _fillBody(container) {
    const options = {
      scrollBeyondLastLine: true,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: { enabled: false },
      renderSideBySide: false,
      readOnly: false,
      renderIndicators: false,
      diffAlgorithm: "advanced",
      stickyScroll: { enabled: false }
    };
    this.diffEditor = this.instantiationService.createInstance(EmbeddedDiffEditorWidget, container, options, {}, this.editor);
    this._disposables.add(this.diffEditor);
  }
  _onWidth(width) {
    if (typeof this.height === "undefined") {
      return;
    }
    this.diffEditor.layout({ height: this.height, width });
  }
  _doLayoutBody(height, width) {
    super._doLayoutBody(height, width);
    this.diffEditor.layout({ height, width });
    if (typeof this.height === "undefined" && this.change) {
      this.revealChange(this.change);
    }
    this.height = height;
  }
  revealChange(change) {
    let start, end;
    if (change.modifiedEndLineNumber === 0) {
      start = change.modifiedStartLineNumber;
      end = change.modifiedStartLineNumber + 1;
    } else if (change.originalEndLineNumber > 0) {
      start = change.modifiedStartLineNumber - 1;
      end = change.modifiedEndLineNumber + 1;
    } else {
      start = change.modifiedStartLineNumber;
      end = change.modifiedEndLineNumber;
    }
    this.diffEditor.revealLinesInCenter(start, end, 1);
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color$1.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color$1.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  revealRange(range) {
    this.editor.revealLineInCenterIfOutsideViewport(range.endLineNumber, 0);
  }
  hasFocus() {
    return this.diffEditor.hasTextFocus();
  }
  dispose() {
    var _a3;
    super.dispose();
    (_a3 = this.menu) == null ? void 0 : _a3.dispose();
  }
};
DirtyDiffWidget = __decorate$U([
  __param$U(2, IThemeService),
  __param$U(3, IInstantiationService),
  __param$U(4, IMenuService),
  __param$U(5, IContextKeyService)
], DirtyDiffWidget);
class ShowPreviousChangeAction extends EditorAction {
  constructor(outerEditor) {
    super({
      id: "editor.action.dirtydiff.previous",
      label: localize("show previous change", "Show Previous Change"),
      alias: "Show Previous Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 1024 | 512 | 61, weight: 100 }
    });
    this.outerEditor = outerEditor;
  }
  run(accessor) {
    const outerEditor = this.outerEditor ?? getOuterEditorFromDiffEditor(accessor);
    if (!outerEditor) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller) {
      return;
    }
    if (!controller.canNavigate()) {
      return;
    }
    controller.previous();
  }
}
registerEditorAction(ShowPreviousChangeAction);
class ShowNextChangeAction extends EditorAction {
  constructor(outerEditor) {
    super({
      id: "editor.action.dirtydiff.next",
      label: localize("show next change", "Show Next Change"),
      alias: "Show Next Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 512 | 61, weight: 100 }
    });
    this.outerEditor = outerEditor;
  }
  run(accessor) {
    const outerEditor = this.outerEditor ?? getOuterEditorFromDiffEditor(accessor);
    if (!outerEditor) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller) {
      return;
    }
    if (!controller.canNavigate()) {
      return;
    }
    controller.next();
  }
}
registerEditorAction(ShowNextChangeAction);
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "7_change_nav",
  command: {
    id: "editor.action.dirtydiff.next",
    title: localize(
      { key: "miGotoNextChange", comment: ["&& denotes a mnemonic"] },
      "Next &&Change"
    )
  },
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "7_change_nav",
  command: {
    id: "editor.action.dirtydiff.previous",
    title: localize(
      { key: "miGotoPreviousChange", comment: ["&& denotes a mnemonic"] },
      "Previous &&Change"
    )
  },
  order: 2
});
class GotoPreviousChangeAction extends EditorAction {
  constructor() {
    super({
      id: "workbench.action.editor.previousChange",
      label: localize("move to previous change", "Go to Previous Change"),
      alias: "Go to Previous Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 1024 | 512 | 63, weight: 100 }
    });
  }
  async run(accessor) {
    const outerEditor = getOuterEditorFromDiffEditor(accessor);
    const audioCueService = accessor.get(IAudioCueService);
    const accessibilityService = accessor.get(IAccessibilityService);
    const codeEditorService = accessor.get(ICodeEditorService);
    if (!outerEditor || !outerEditor.hasModel()) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller || !controller.modelRegistry) {
      return;
    }
    const lineNumber = outerEditor.getPosition().lineNumber;
    const model = controller.modelRegistry.getModel(outerEditor.getModel());
    if (!model || model.changes.length === 0) {
      return;
    }
    const index2 = model.findPreviousClosestChange(lineNumber, false);
    const change = model.changes[index2];
    await playAudioCueForChange(change.change, audioCueService);
    setPositionAndSelection(change.change, outerEditor, accessibilityService, codeEditorService);
  }
}
registerEditorAction(GotoPreviousChangeAction);
class GotoNextChangeAction extends EditorAction {
  constructor() {
    super({
      id: "workbench.action.editor.nextChange",
      label: localize("move to next change", "Go to Next Change"),
      alias: "Go to Next Change",
      precondition: TextCompareEditorActiveContext.toNegated(),
      kbOpts: { kbExpr: EditorContextKeys.editorTextFocus, primary: 512 | 63, weight: 100 }
    });
  }
  async run(accessor) {
    const audioCueService = accessor.get(IAudioCueService);
    const outerEditor = getOuterEditorFromDiffEditor(accessor);
    const accessibilityService = accessor.get(IAccessibilityService);
    const codeEditorService = accessor.get(ICodeEditorService);
    if (!outerEditor || !outerEditor.hasModel()) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller || !controller.modelRegistry) {
      return;
    }
    const lineNumber = outerEditor.getPosition().lineNumber;
    const model = controller.modelRegistry.getModel(outerEditor.getModel());
    if (!model || model.changes.length === 0) {
      return;
    }
    const index2 = model.findNextClosestChange(lineNumber, false);
    const change = model.changes[index2].change;
    await playAudioCueForChange(change, audioCueService);
    setPositionAndSelection(change, outerEditor, accessibilityService, codeEditorService);
  }
}
function setPositionAndSelection(change, editor2, accessibilityService, codeEditorService) {
  var _a3;
  const position = new Position$1(change.modifiedStartLineNumber, 1);
  editor2.setPosition(position);
  editor2.revealPositionInCenter(position);
  if (accessibilityService.isScreenReaderOptimized()) {
    editor2.setSelection({ startLineNumber: change.modifiedStartLineNumber, startColumn: 0, endLineNumber: change.modifiedStartLineNumber, endColumn: Number.MAX_VALUE });
    (_a3 = codeEditorService.getActiveCodeEditor()) == null ? void 0 : _a3.writeScreenReaderContent("diff-navigation");
  }
}
async function playAudioCueForChange(change, audioCueService) {
  const changeType = getChangeType(change);
  switch (changeType) {
    case ChangeType.Add:
      audioCueService.playAudioCue(AudioCue.diffLineInserted, true);
      break;
    case ChangeType.Delete:
      audioCueService.playAudioCue(AudioCue.diffLineDeleted, true);
      break;
    case ChangeType.Modify:
      audioCueService.playAudioCue(AudioCue.diffLineModified, true);
      break;
  }
}
registerEditorAction(GotoNextChangeAction);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "closeDirtyDiff",
  weight: 100 + 50,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(isDirtyDiffVisible),
  handler: (accessor) => {
    const outerEditor = getOuterEditorFromDiffEditor(accessor);
    if (!outerEditor) {
      return;
    }
    const controller = DirtyDiffController.get(outerEditor);
    if (!controller) {
      return;
    }
    controller.close();
  }
});
let DirtyDiffController = (_f2 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_f2.ID);
  }
  constructor(editor2, contextKeyService, configurationService, instantiationService) {
    super();
    this.editor = editor2;
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.modelRegistry = null;
    this.model = null;
    this.widget = null;
    this.session = Disposable.None;
    this.mouseDownInfo = null;
    this.enabled = false;
    this.gutterActionDisposables = new DisposableStore();
    this.enabled = !contextKeyService.getContextKeyValue("isInDiffEditor");
    this.stylesheet = createStyleSheet();
    this._register(toDisposable(() => this.stylesheet.remove()));
    if (this.enabled) {
      this.isDirtyDiffVisible = isDirtyDiffVisible.bindTo(contextKeyService);
      this._register(editor2.onDidChangeModel(() => this.close()));
      const onDidChangeGutterAction = Event.filter(configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration("scm.diffDecorationsGutterAction"));
      this._register(onDidChangeGutterAction(this.onDidChangeGutterAction, this));
      this.onDidChangeGutterAction();
    }
  }
  onDidChangeGutterAction() {
    const gutterAction = this.configurationService.getValue("scm.diffDecorationsGutterAction");
    this.gutterActionDisposables.dispose();
    this.gutterActionDisposables = new DisposableStore();
    if (gutterAction === "diff") {
      this.gutterActionDisposables.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
      this.gutterActionDisposables.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
      this.stylesheet.textContent = `
				.monaco-editor .dirty-diff-glyph {
					cursor: pointer;
				}

				.monaco-editor .margin-view-overlays .dirty-diff-glyph:hover::before {
					height: 100%;
					width: 6px;
					left: -6px;
				}

				.monaco-editor .margin-view-overlays .dirty-diff-deleted:hover::after {
					bottom: 0;
					border-top-width: 0;
					border-bottom-width: 0;
				}
			`;
    } else {
      this.stylesheet.textContent = ``;
    }
  }
  canNavigate() {
    var _a3;
    return !this.widget || ((_a3 = this.widget) == null ? void 0 : _a3.index) === -1 || !!this.model && this.model.changes.length > 1;
  }
  refresh() {
    var _a3;
    (_a3 = this.widget) == null ? void 0 : _a3.showChange(this.widget.index, false);
  }
  next(lineNumber) {
    if (!this.assertWidget()) {
      return;
    }
    if (!this.widget || !this.model) {
      return;
    }
    let index2;
    if (this.editor.hasModel() && (typeof lineNumber === "number" || !this.widget.provider)) {
      index2 = this.model.findNextClosestChange(typeof lineNumber === "number" ? lineNumber : this.editor.getPosition().lineNumber, true, this.widget.provider);
    } else {
      const providerChanges = this.model.mapChanges.get(this.widget.provider) ?? this.model.mapChanges.values().next().value;
      const mapIndex = providerChanges.findIndex((value) => value === this.widget.index);
      index2 = providerChanges[rot(mapIndex + 1, providerChanges.length)];
    }
    this.widget.showChange(index2);
  }
  previous(lineNumber) {
    if (!this.assertWidget()) {
      return;
    }
    if (!this.widget || !this.model) {
      return;
    }
    let index2;
    if (this.editor.hasModel() && typeof lineNumber === "number") {
      index2 = this.model.findPreviousClosestChange(typeof lineNumber === "number" ? lineNumber : this.editor.getPosition().lineNumber, true, this.widget.provider);
    } else {
      const providerChanges = this.model.mapChanges.get(this.widget.provider) ?? this.model.mapChanges.values().next().value;
      const mapIndex = providerChanges.findIndex((value) => value === this.widget.index);
      index2 = providerChanges[rot(mapIndex - 1, providerChanges.length)];
    }
    this.widget.showChange(index2);
  }
  close() {
    this.session.dispose();
    this.session = Disposable.None;
  }
  assertWidget() {
    if (!this.enabled) {
      return false;
    }
    if (this.widget) {
      if (!this.model || this.model.changes.length === 0) {
        this.close();
        return false;
      }
      return true;
    }
    if (!this.modelRegistry) {
      return false;
    }
    const editorModel = this.editor.getModel();
    if (!editorModel) {
      return false;
    }
    const model = this.modelRegistry.getModel(editorModel);
    if (!model) {
      return false;
    }
    if (model.changes.length === 0) {
      return false;
    }
    this.model = model;
    this.widget = this.instantiationService.createInstance(DirtyDiffWidget, this.editor, model);
    this.isDirtyDiffVisible.set(true);
    const disposables = new DisposableStore();
    disposables.add(Event.once(this.widget.onDidClose)(this.close, this));
    Event.chain(model.onDidChange).filter((e) => e.diff.length > 0).map((e) => e.diff).event(this.onDidModelChange, this, disposables);
    disposables.add(this.widget);
    disposables.add(toDisposable(() => {
      this.model = null;
      this.widget = null;
      this.isDirtyDiffVisible.set(false);
      this.editor.focus();
    }));
    this.session = disposables;
    return true;
  }
  onDidModelChange(splices) {
    if (!this.model || !this.widget || this.widget.hasFocus()) {
      return;
    }
    for (const splice of splices) {
      if (splice.start <= this.widget.index) {
        this.next();
        return;
      }
    }
    this.refresh();
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = null;
    const range = e.target.range;
    if (!range) {
      return;
    }
    if (!e.event.leftButton) {
      return;
    }
    if (e.target.type !== 4) {
      return;
    }
    if (!e.target.element) {
      return;
    }
    if (e.target.element.className.indexOf("dirty-diff-glyph") < 0) {
      return;
    }
    const data = e.target.detail;
    const offsetLeftInGutter = e.target.element.offsetLeft;
    const gutterOffsetX = data.offsetX - offsetLeftInGutter;
    if (gutterOffsetX < -3 || gutterOffsetX > 3) {
      return;
    }
    this.mouseDownInfo = { lineNumber: range.startLineNumber };
  }
  onEditorMouseUp(e) {
    var _a3;
    if (!this.mouseDownInfo) {
      return;
    }
    const { lineNumber } = this.mouseDownInfo;
    this.mouseDownInfo = null;
    const range = e.target.range;
    if (!range || range.startLineNumber !== lineNumber) {
      return;
    }
    if (e.target.type !== 4) {
      return;
    }
    if (!this.modelRegistry) {
      return;
    }
    const editorModel = this.editor.getModel();
    if (!editorModel) {
      return;
    }
    const model = this.modelRegistry.getModel(editorModel);
    if (!model) {
      return;
    }
    const index2 = model.changes.findIndex((change) => lineIntersectsChange(lineNumber, change.change));
    if (index2 < 0) {
      return;
    }
    if (index2 === ((_a3 = this.widget) == null ? void 0 : _a3.index)) {
      this.close();
    } else {
      this.next(lineNumber);
    }
  }
  getChanges() {
    if (!this.modelRegistry) {
      return [];
    }
    if (!this.editor.hasModel()) {
      return [];
    }
    const model = this.modelRegistry.getModel(this.editor.getModel());
    if (!model) {
      return [];
    }
    return model.changes.map((change) => change.change);
  }
  dispose() {
    this.gutterActionDisposables.dispose();
    super.dispose();
  }
}, _f2.ID = "editor.contrib.dirtydiff", _f2);
DirtyDiffController = __decorate$U([
  __param$U(1, IContextKeyService),
  __param$U(2, IConfigurationService),
  __param$U(3, IInstantiationService)
], DirtyDiffController);
const editorGutterModifiedBackground = registerColor("editorGutter.modifiedBackground", {
  dark: "#1B81A8",
  light: "#2090D3",
  hcDark: "#1B81A8",
  hcLight: "#2090D3"
}, localize(
  "editorGutterModifiedBackground",
  "Editor gutter background color for lines that are modified."
));
const editorGutterAddedBackground = registerColor("editorGutter.addedBackground", {
  dark: "#487E02",
  light: "#48985D",
  hcDark: "#487E02",
  hcLight: "#48985D"
}, localize(
  "editorGutterAddedBackground",
  "Editor gutter background color for lines that are added."
));
const editorGutterDeletedBackground = registerColor("editorGutter.deletedBackground", {
  dark: editorErrorForeground,
  light: editorErrorForeground,
  hcDark: editorErrorForeground,
  hcLight: editorErrorForeground
}, localize(
  "editorGutterDeletedBackground",
  "Editor gutter background color for lines that are deleted."
));
registerColor("minimapGutter.modifiedBackground", {
  dark: editorGutterModifiedBackground,
  light: editorGutterModifiedBackground,
  hcDark: editorGutterModifiedBackground,
  hcLight: editorGutterModifiedBackground
}, localize(
  "minimapGutterModifiedBackground",
  "Minimap gutter background color for lines that are modified."
));
registerColor("minimapGutter.addedBackground", {
  dark: editorGutterAddedBackground,
  light: editorGutterAddedBackground,
  hcDark: editorGutterAddedBackground,
  hcLight: editorGutterAddedBackground
}, localize(
  "minimapGutterAddedBackground",
  "Minimap gutter background color for lines that are added."
));
registerColor("minimapGutter.deletedBackground", {
  dark: editorGutterDeletedBackground,
  light: editorGutterDeletedBackground,
  hcDark: editorGutterDeletedBackground,
  hcLight: editorGutterDeletedBackground
}, localize(
  "minimapGutterDeletedBackground",
  "Minimap gutter background color for lines that are deleted."
));
registerColor("editorOverviewRuler.modifiedForeground", { dark: transparent(editorGutterModifiedBackground, 0.6), light: transparent(editorGutterModifiedBackground, 0.6), hcDark: transparent(editorGutterModifiedBackground, 0.6), hcLight: transparent(editorGutterModifiedBackground, 0.6) }, localize(
  "overviewRulerModifiedForeground",
  "Overview ruler marker color for modified content."
));
registerColor("editorOverviewRuler.addedForeground", { dark: transparent(editorGutterAddedBackground, 0.6), light: transparent(editorGutterAddedBackground, 0.6), hcDark: transparent(editorGutterAddedBackground, 0.6), hcLight: transparent(editorGutterAddedBackground, 0.6) }, localize(
  "overviewRulerAddedForeground",
  "Overview ruler marker color for added content."
));
registerColor("editorOverviewRuler.deletedForeground", { dark: transparent(editorGutterDeletedBackground, 0.6), light: transparent(editorGutterDeletedBackground, 0.6), hcDark: transparent(editorGutterDeletedBackground, 0.6), hcLight: transparent(editorGutterDeletedBackground, 0.6) }, localize(
  "overviewRulerDeletedForeground",
  "Overview ruler marker color for deleted content."
));
async function getOriginalResource(quickDiffService, uri, language2, isSynchronized) {
  const quickDiffs = await quickDiffService.getQuickDiffs(uri, language2, isSynchronized);
  return quickDiffs.length > 0 ? quickDiffs[0].originalResource : null;
}
registerEditorContribution(DirtyDiffController.ID, DirtyDiffController, 1);
registerEditorAction(class FormatModifiedAction extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatChanges",
      label: localize("formatChanges", "Format Modified Lines"),
      alias: "Format Modified Lines",
      precondition: ContextKeyExpr.and(
        EditorContextKeys.writable,
        EditorContextKeys.hasDocumentSelectionFormattingProvider
      )
    });
  }
  async run(accessor, editor2) {
    const instaService = accessor.get(IInstantiationService);
    if (!editor2.hasModel()) {
      return;
    }
    const ranges = await instaService.invokeFunction(getModifiedRanges, editor2.getModel());
    if (isNonEmptyArray(ranges)) {
      return instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor2, ranges, 1, Progress.None, CancellationToken.None);
    }
  }
});
async function getModifiedRanges(accessor, modified) {
  const quickDiffService = accessor.get(IQuickDiffService);
  const workerService = accessor.get(IEditorWorkerService);
  const modelService = accessor.get(ITextModelService);
  const original = await getOriginalResource(quickDiffService, modified.uri, modified.getLanguageId(), shouldSynchronizeModel(modified));
  if (!original) {
    return null;
  }
  const ranges = [];
  const ref = await modelService.createModelReference(original);
  try {
    if (!workerService.canComputeDirtyDiff(original, modified.uri)) {
      return void 0;
    }
    const changes = await workerService.computeDirtyDiff(original, modified.uri, false);
    if (!isNonEmptyArray(changes)) {
      return void 0;
    }
    for (const change of changes) {
      ranges.push(modified.validateRange(new Range$1(
        change.modifiedStartLineNumber,
        1,
        change.modifiedEndLineNumber || change.modifiedStartLineNumber,
        Number.MAX_SAFE_INTEGER
      )));
    }
  } finally {
    ref.dispose();
  }
  return ranges;
}
let TrimWhitespaceParticipant = class TrimWhitespaceParticipant2 {
  constructor(configurationService, codeEditorService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
  }
  async participate(model, env) {
    if (!model.textEditorModel) {
      return;
    }
    if (this.configurationService.getValue("files.trimTrailingWhitespace", { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
      this.doTrimTrailingWhitespace(model.textEditorModel, env.reason === 2);
    }
  }
  doTrimTrailingWhitespace(model, isAutoSaved) {
    var _a3;
    let prevSelection = [];
    let cursors = [];
    const editor2 = findEditor(model, this.codeEditorService);
    if (editor2) {
      prevSelection = editor2.getSelections();
      if (isAutoSaved) {
        cursors = prevSelection.map((s) => s.getPosition());
        const snippetsRange = (_a3 = SnippetController2.get(editor2)) == null ? void 0 : _a3.getSessionEnclosingRange();
        if (snippetsRange) {
          for (let lineNumber = snippetsRange.startLineNumber; lineNumber <= snippetsRange.endLineNumber; lineNumber++) {
            cursors.push(new Position$1(lineNumber, model.getLineMaxColumn(lineNumber)));
          }
        }
      }
    }
    const ops = trimTrailingWhitespace(model, cursors);
    if (!ops.length) {
      return;
    }
    model.pushEditOperations(prevSelection, ops, (_edits) => prevSelection);
  }
};
TrimWhitespaceParticipant = __decorate$U([
  __param$U(0, IConfigurationService),
  __param$U(1, ICodeEditorService)
], TrimWhitespaceParticipant);
function findEditor(model, codeEditorService) {
  let candidate = null;
  if (model.isAttachedToEditor()) {
    for (const editor2 of codeEditorService.listCodeEditors()) {
      if (editor2.hasModel() && editor2.getModel() === model) {
        if (editor2.hasTextFocus()) {
          return editor2;
        }
        candidate = editor2;
      }
    }
  }
  return candidate;
}
let FinalNewLineParticipant = class FinalNewLineParticipant2 {
  constructor(configurationService, codeEditorService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
  }
  async participate(model, _env) {
    if (!model.textEditorModel) {
      return;
    }
    if (this.configurationService.getValue("files.insertFinalNewline", { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
      this.doInsertFinalNewLine(model.textEditorModel);
    }
  }
  doInsertFinalNewLine(model) {
    const lineCount = model.getLineCount();
    const lastLine = model.getLineContent(lineCount);
    const lastLineIsEmptyOrWhitespace = lastNonWhitespaceIndex(lastLine) === -1;
    if (!lineCount || lastLineIsEmptyOrWhitespace) {
      return;
    }
    const edits = [EditOperation.insert(new Position$1(lineCount, model.getLineMaxColumn(lineCount)), model.getEOL())];
    const editor2 = findEditor(model, this.codeEditorService);
    if (editor2) {
      editor2.executeEdits("insertFinalNewLine", edits, editor2.getSelections());
    } else {
      model.pushEditOperations([], edits, () => null);
    }
  }
};
FinalNewLineParticipant = __decorate$U([
  __param$U(0, IConfigurationService),
  __param$U(1, ICodeEditorService)
], FinalNewLineParticipant);
let TrimFinalNewLinesParticipant = class TrimFinalNewLinesParticipant2 {
  constructor(configurationService, codeEditorService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
  }
  async participate(model, env) {
    if (!model.textEditorModel) {
      return;
    }
    if (this.configurationService.getValue("files.trimFinalNewlines", { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
      this.doTrimFinalNewLines(model.textEditorModel, env.reason === 2);
    }
  }
  findLastNonEmptyLine(model) {
    for (let lineNumber = model.getLineCount(); lineNumber >= 1; lineNumber--) {
      const lineContent = model.getLineContent(lineNumber);
      if (lineContent.length > 0) {
        return lineNumber;
      }
    }
    return 0;
  }
  doTrimFinalNewLines(model, isAutoSaved) {
    const lineCount = model.getLineCount();
    if (lineCount === 1) {
      return;
    }
    let prevSelection = [];
    let cannotTouchLineNumber = 0;
    const editor2 = findEditor(model, this.codeEditorService);
    if (editor2) {
      prevSelection = editor2.getSelections();
      if (isAutoSaved) {
        for (let i = 0, len = prevSelection.length; i < len; i++) {
          const positionLineNumber = prevSelection[i].positionLineNumber;
          if (positionLineNumber > cannotTouchLineNumber) {
            cannotTouchLineNumber = positionLineNumber;
          }
        }
      }
    }
    const lastNonEmptyLine = this.findLastNonEmptyLine(model);
    const deleteFromLineNumber = Math.max(lastNonEmptyLine + 1, cannotTouchLineNumber + 1);
    const deletionRange = model.validateRange(new Range$1(deleteFromLineNumber, 1, lineCount, model.getLineMaxColumn(lineCount)));
    if (deletionRange.isEmpty()) {
      return;
    }
    model.pushEditOperations(prevSelection, [EditOperation.delete(deletionRange)], (_edits) => prevSelection);
    editor2 == null ? void 0 : editor2.setSelections(prevSelection);
  }
};
TrimFinalNewLinesParticipant = __decorate$U([
  __param$U(0, IConfigurationService),
  __param$U(1, ICodeEditorService)
], TrimFinalNewLinesParticipant);
let FormatOnSaveParticipant = class FormatOnSaveParticipant2 {
  constructor(configurationService, codeEditorService, instantiationService) {
    this.configurationService = configurationService;
    this.codeEditorService = codeEditorService;
    this.instantiationService = instantiationService;
  }
  async participate(model, env, progress2, token) {
    if (!model.textEditorModel) {
      return;
    }
    if (env.reason === 2) {
      return void 0;
    }
    const textEditorModel = model.textEditorModel;
    const overrides = { overrideIdentifier: textEditorModel.getLanguageId(), resource: textEditorModel.uri };
    const nestedProgress = new Progress((provider) => {
      progress2.report({
        message: localize(
          { key: "formatting2", comment: ["[configure]({1}) is a link. Only translate `configure`. Do not change brackets and parentheses or {1}"] },
          "Running '{0}' Formatter ([configure]({1})).",
          provider.displayName || provider.extensionId && provider.extensionId.value || "???",
          "command:workbench.action.openSettings?%5B%22editor.formatOnSave%22%5D"
        )
      });
    });
    const enabled = this.configurationService.getValue("editor.formatOnSave", overrides);
    if (!enabled) {
      return void 0;
    }
    const editorOrModel = findEditor(textEditorModel, this.codeEditorService) || textEditorModel;
    const mode = this.configurationService.getValue("editor.formatOnSaveMode", overrides);
    if (mode === "file") {
      await this.instantiationService.invokeFunction(formatDocumentWithSelectedProvider, editorOrModel, 2, nestedProgress, token);
    } else {
      const ranges = await this.instantiationService.invokeFunction(getModifiedRanges, isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel);
      if (ranges === null && mode === "modificationsIfAvailable") {
        await this.instantiationService.invokeFunction(formatDocumentWithSelectedProvider, editorOrModel, 2, nestedProgress, token);
      } else if (ranges) {
        await this.instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, editorOrModel, ranges, 2, nestedProgress, token);
      }
    }
  }
};
FormatOnSaveParticipant = __decorate$U([
  __param$U(0, IConfigurationService),
  __param$U(1, ICodeEditorService),
  __param$U(2, IInstantiationService)
], FormatOnSaveParticipant);
let CodeActionOnSaveParticipant = class CodeActionOnSaveParticipant2 {
  constructor(configurationService, instantiationService, languageFeaturesService) {
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.languageFeaturesService = languageFeaturesService;
  }
  async participate(model, env, progress2, token) {
    if (!model.textEditorModel) {
      return;
    }
    if (env.reason !== 1) {
      return void 0;
    }
    const textEditorModel = model.textEditorModel;
    const settingsOverrides = { overrideIdentifier: textEditorModel.getLanguageId(), resource: model.resource };
    const setting = this.configurationService.getValue("editor.codeActionsOnSave", settingsOverrides);
    if (!setting) {
      return void 0;
    }
    const settingItems = Array.isArray(setting) ? setting : Object.keys(setting).filter((x) => setting[x]);
    const codeActionsOnSave = this.createCodeActionsOnSave(settingItems);
    if (!Array.isArray(setting)) {
      codeActionsOnSave.sort((a, b) => {
        if (CodeActionKind$1.SourceFixAll.contains(a)) {
          if (CodeActionKind$1.SourceFixAll.contains(b)) {
            return 0;
          }
          return -1;
        }
        if (CodeActionKind$1.SourceFixAll.contains(b)) {
          return 1;
        }
        return 0;
      });
    }
    if (!codeActionsOnSave.length) {
      return void 0;
    }
    const excludedActions = Array.isArray(setting) ? [] : Object.keys(setting).filter((x) => setting[x] === false).map((x) => new CodeActionKind$1(x));
    progress2.report({ message: localize("codeaction", "Quick Fixes") });
    await this.applyOnSaveActions(textEditorModel, codeActionsOnSave, excludedActions, progress2, token);
  }
  createCodeActionsOnSave(settingItems) {
    const kinds = settingItems.map((x) => new CodeActionKind$1(x));
    return kinds.filter((kind) => {
      return kinds.every((otherKind) => otherKind.equals(kind) || !otherKind.contains(kind));
    });
  }
  async applyOnSaveActions(model, codeActionsOnSave, excludes, progress2, token) {
    const getActionProgress = new class {
      constructor() {
        this._names = /* @__PURE__ */ new Set();
      }
      _report() {
        progress2.report({
          message: localize(
            { key: "codeaction.get2", comment: ["[configure]({1}) is a link. Only translate `configure`. Do not change brackets and parentheses or {1}"] },
            "Getting code actions from '{0}' ([configure]({1})).",
            [...this._names].map((name) => `'${name}'`).join(", "),
            "command:workbench.action.openSettings?%5B%22editor.codeActionsOnSave%22%5D"
          )
        });
      }
      report(provider) {
        if (provider.displayName && !this._names.has(provider.displayName)) {
          this._names.add(provider.displayName);
          this._report();
        }
      }
    }();
    for (const codeActionKind of codeActionsOnSave) {
      const actionsToRun = await this.getActionsToRun(model, codeActionKind, excludes, getActionProgress, token);
      if (token.isCancellationRequested) {
        actionsToRun.dispose();
        return;
      }
      try {
        for (const action of actionsToRun.validActions) {
          progress2.report({ message: localize("codeAction.apply", "Applying code action '{0}'.", action.action.title) });
          await this.instantiationService.invokeFunction(applyCodeAction, action, ApplyCodeActionReason.OnSave, {}, token);
          if (token.isCancellationRequested) {
            return;
          }
        }
      } catch {
      } finally {
        actionsToRun.dispose();
      }
    }
  }
  getActionsToRun(model, codeActionKind, excludes, progress2, token) {
    return getCodeActions(this.languageFeaturesService.codeActionProvider, model, model.getFullModelRange(), {
      type: 2,
      triggerAction: CodeActionTriggerSource.OnSave,
      filter: { include: codeActionKind, excludes, includeSourceActions: true }
    }, progress2, token);
  }
};
CodeActionOnSaveParticipant = __decorate$U([
  __param$U(0, IConfigurationService),
  __param$U(1, IInstantiationService),
  __param$U(2, ILanguageFeaturesService)
], CodeActionOnSaveParticipant);
let SaveParticipantsContribution = class SaveParticipantsContribution2 extends Disposable {
  constructor(instantiationService, textFileService) {
    super();
    this.instantiationService = instantiationService;
    this.textFileService = textFileService;
    this.registerSaveParticipants();
  }
  registerSaveParticipants() {
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimWhitespaceParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(CodeActionOnSaveParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FormatOnSaveParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FinalNewLineParticipant)));
    this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimFinalNewLinesParticipant)));
  }
};
SaveParticipantsContribution = __decorate$U([
  __param$U(0, IInstantiationService),
  __param$U(1, ITextFileService)
], SaveParticipantsContribution);
const workbenchContributionsRegistry$1 = Registry.as(Extensions$1.Workbench);
workbenchContributionsRegistry$1.registerWorkbenchContribution(SaveParticipantsContribution, 3);
const _ToggleMinimapAction = class _ToggleMinimapAction extends Action2 {
  constructor() {
    super({
      id: _ToggleMinimapAction.ID,
      title: {
        value: localize("toggleMinimap", "Toggle Minimap"),
        original: "Toggle Minimap",
        mnemonicTitle: localize({ key: "miMinimap", comment: ["&& denotes a mnemonic"] }, "&&Minimap")
      },
      category: Categories.View,
      f1: true,
      toggled: ContextKeyExpr.equals("config.editor.minimap.enabled", true),
      menu: {
        id: MenuId.MenubarAppearanceMenu,
        group: "4_editor",
        order: 1
      }
    });
  }
  async run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const newValue = !configurationService.getValue("editor.minimap.enabled");
    return configurationService.updateValue("editor.minimap.enabled", newValue);
  }
};
_ToggleMinimapAction.ID = "editor.action.toggleMinimap";
let ToggleMinimapAction = _ToggleMinimapAction;
registerAction2(ToggleMinimapAction);
const _ToggleMultiCursorModifierAction = class _ToggleMultiCursorModifierAction extends Action2 {
  constructor() {
    super({
      id: _ToggleMultiCursorModifierAction.ID,
      title: { value: localize("toggleLocation", "Toggle Multi-Cursor Modifier"), original: "Toggle Multi-Cursor Modifier" },
      f1: true
    });
  }
  run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const editorConf = configurationService.getValue("editor");
    const newValue = editorConf.multiCursorModifier === "ctrlCmd" ? "alt" : "ctrlCmd";
    return configurationService.updateValue(_ToggleMultiCursorModifierAction.multiCursorModifierConfigurationKey, newValue);
  }
};
_ToggleMultiCursorModifierAction.ID = "workbench.action.toggleMultiCursorModifier";
_ToggleMultiCursorModifierAction.multiCursorModifierConfigurationKey = "editor.multiCursorModifier";
let ToggleMultiCursorModifierAction = _ToggleMultiCursorModifierAction;
const multiCursorModifier = new RawContextKey("multiCursorModifier", "altKey");
let MultiCursorModifierContextKeyController = class MultiCursorModifierContextKeyController2 {
  constructor(configurationService, contextKeyService) {
    this.configurationService = configurationService;
    this._multiCursorModifier = multiCursorModifier.bindTo(contextKeyService);
    this._update();
    configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.multiCursorModifier")) {
        this._update();
      }
    });
  }
  _update() {
    const editorConf = this.configurationService.getValue("editor");
    const value = editorConf.multiCursorModifier === "ctrlCmd" ? "ctrlCmd" : "altKey";
    this._multiCursorModifier.set(value);
  }
};
MultiCursorModifierContextKeyController = __decorate$U([
  __param$U(0, IConfigurationService),
  __param$U(1, IContextKeyService)
], MultiCursorModifierContextKeyController);
Registry.as(Extensions$1.Workbench).registerWorkbenchContribution(MultiCursorModifierContextKeyController, 3);
registerAction2(ToggleMultiCursorModifierAction);
MenuRegistry.appendMenuItem(MenuId.MenubarSelectionMenu, {
  group: "4_config",
  command: {
    id: ToggleMultiCursorModifierAction.ID,
    title: localize("miMultiCursorAlt", "Switch to Alt+Click for Multi-Cursor")
  },
  when: multiCursorModifier.isEqualTo("ctrlCmd"),
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.MenubarSelectionMenu, {
  group: "4_config",
  command: {
    id: ToggleMultiCursorModifierAction.ID,
    title: isMacintosh ? localize("miMultiCursorCmd", "Switch to Cmd+Click for Multi-Cursor") : localize("miMultiCursorCtrl", "Switch to Ctrl+Click for Multi-Cursor")
  },
  when: multiCursorModifier.isEqualTo("altKey"),
  order: 1
});
const _ToggleRenderControlCharacterAction = class _ToggleRenderControlCharacterAction extends Action2 {
  constructor() {
    super({
      id: _ToggleRenderControlCharacterAction.ID,
      title: {
        value: localize("toggleRenderControlCharacters", "Toggle Control Characters"),
        mnemonicTitle: localize(
          { key: "miToggleRenderControlCharacters", comment: ["&& denotes a mnemonic"] },
          "Render &&Control Characters"
        ),
        original: "Toggle Control Characters"
      },
      category: Categories.View,
      f1: true,
      toggled: ContextKeyExpr.equals("config.editor.renderControlCharacters", true),
      menu: {
        id: MenuId.MenubarAppearanceMenu,
        group: "4_editor",
        order: 4
      }
    });
  }
  run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const newRenderControlCharacters = !configurationService.getValue("editor.renderControlCharacters");
    return configurationService.updateValue("editor.renderControlCharacters", newRenderControlCharacters);
  }
};
_ToggleRenderControlCharacterAction.ID = "editor.action.toggleRenderControlCharacter";
let ToggleRenderControlCharacterAction = _ToggleRenderControlCharacterAction;
registerAction2(ToggleRenderControlCharacterAction);
const transientWordWrapState = "transientWordWrapState";
const isWordWrapMinifiedKey = "isWordWrapMinified";
const isDominatedByLongLinesKey = "isDominatedByLongLines";
const CAN_TOGGLE_WORD_WRAP = new RawContextKey("canToggleWordWrap", false, true);
const EDITOR_WORD_WRAP = new RawContextKey("editorWordWrap", false, localize("editorWordWrap", "Whether the editor is currently using word wrapping."));
function writeTransientState(model, state, codeEditorService) {
  codeEditorService.setTransientModelProperty(model, transientWordWrapState, state);
}
function readTransientState(model, codeEditorService) {
  return codeEditorService.getTransientModelProperty(model, transientWordWrapState);
}
const TOGGLE_WORD_WRAP_ID = "editor.action.toggleWordWrap";
class ToggleWordWrapAction extends EditorAction {
  constructor() {
    super({
      id: TOGGLE_WORD_WRAP_ID,
      label: localize("toggle.wordwrap", "View: Toggle Word Wrap"),
      alias: "View: Toggle Word Wrap",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 512 | 56,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const codeEditorService = accessor.get(ICodeEditorService);
    if (!canToggleWordWrap(codeEditorService, editor2)) {
      return;
    }
    const model = editor2.getModel();
    const transientState = readTransientState(model, codeEditorService);
    let newState;
    if (transientState) {
      newState = null;
    } else {
      const actualWrappingInfo = editor2.getOption(143);
      const wordWrapOverride = actualWrappingInfo.wrappingColumn === -1 ? "on" : "off";
      newState = { wordWrapOverride };
    }
    writeTransientState(model, newState, codeEditorService);
    const diffEditor = findDiffEditorContainingCodeEditor(editor2, codeEditorService);
    if (diffEditor) {
      const originalEditor = diffEditor.getOriginalEditor();
      const modifiedEditor = diffEditor.getModifiedEditor();
      const otherEditor = originalEditor === editor2 ? modifiedEditor : originalEditor;
      if (canToggleWordWrap(codeEditorService, otherEditor)) {
        writeTransientState(otherEditor.getModel(), newState, codeEditorService);
        diffEditor.updateOptions({});
      }
    }
  }
}
function findDiffEditorContainingCodeEditor(editor2, codeEditorService) {
  if (!editor2.getOption(60)) {
    return null;
  }
  for (const diffEditor of codeEditorService.listDiffEditors()) {
    const originalEditor = diffEditor.getOriginalEditor();
    const modifiedEditor = diffEditor.getModifiedEditor();
    if (originalEditor === editor2 || modifiedEditor === editor2) {
      return diffEditor;
    }
  }
  return null;
}
let ToggleWordWrapController = (_g2 = class extends Disposable {
  constructor(_editor, _contextKeyService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._contextKeyService = _contextKeyService;
    this._codeEditorService = _codeEditorService;
    const options = this._editor.getOptions();
    const wrappingInfo = options.get(143);
    const isWordWrapMinified = this._contextKeyService.createKey(isWordWrapMinifiedKey, wrappingInfo.isWordWrapMinified);
    const isDominatedByLongLines = this._contextKeyService.createKey(isDominatedByLongLinesKey, wrappingInfo.isDominatedByLongLines);
    let currentlyApplyingEditorConfig = false;
    this._register(_editor.onDidChangeConfiguration((e) => {
      if (!e.hasChanged(143)) {
        return;
      }
      const options2 = this._editor.getOptions();
      const wrappingInfo2 = options2.get(143);
      isWordWrapMinified.set(wrappingInfo2.isWordWrapMinified);
      isDominatedByLongLines.set(wrappingInfo2.isDominatedByLongLines);
      if (!currentlyApplyingEditorConfig) {
        ensureWordWrapSettings();
      }
    }));
    this._register(_editor.onDidChangeModel((e) => {
      ensureWordWrapSettings();
    }));
    this._register(_codeEditorService.onDidChangeTransientModelProperty(() => {
      ensureWordWrapSettings();
    }));
    const ensureWordWrapSettings = () => {
      if (!canToggleWordWrap(this._codeEditorService, this._editor)) {
        return;
      }
      const transientState = readTransientState(this._editor.getModel(), this._codeEditorService);
      try {
        currentlyApplyingEditorConfig = true;
        this._applyWordWrapState(transientState);
      } finally {
        currentlyApplyingEditorConfig = false;
      }
    };
  }
  _applyWordWrapState(state) {
    const wordWrapOverride2 = state ? state.wordWrapOverride : "inherit";
    this._editor.updateOptions({
      wordWrapOverride2
    });
  }
}, _g2.ID = "editor.contrib.toggleWordWrapController", _g2);
ToggleWordWrapController = __decorate$U([
  __param$U(1, IContextKeyService),
  __param$U(2, ICodeEditorService)
], ToggleWordWrapController);
let DiffToggleWordWrapController = (_h2 = class extends Disposable {
  constructor(_diffEditor, _codeEditorService) {
    super();
    this._diffEditor = _diffEditor;
    this._codeEditorService = _codeEditorService;
    this._register(this._diffEditor.onDidChangeModel(() => {
      this._ensureSyncedWordWrapToggle();
    }));
  }
  _ensureSyncedWordWrapToggle() {
    const originalEditor = this._diffEditor.getOriginalEditor();
    const modifiedEditor = this._diffEditor.getModifiedEditor();
    if (!originalEditor.hasModel() || !modifiedEditor.hasModel()) {
      return;
    }
    const originalTransientState = readTransientState(originalEditor.getModel(), this._codeEditorService);
    const modifiedTransientState = readTransientState(modifiedEditor.getModel(), this._codeEditorService);
    if (originalTransientState && !modifiedTransientState && canToggleWordWrap(this._codeEditorService, originalEditor)) {
      writeTransientState(modifiedEditor.getModel(), originalTransientState, this._codeEditorService);
      this._diffEditor.updateOptions({});
    }
    if (!originalTransientState && modifiedTransientState && canToggleWordWrap(this._codeEditorService, modifiedEditor)) {
      writeTransientState(originalEditor.getModel(), modifiedTransientState, this._codeEditorService);
      this._diffEditor.updateOptions({});
    }
  }
}, _h2.ID = "diffeditor.contrib.toggleWordWrapController", _h2);
DiffToggleWordWrapController = __decorate$U([
  __param$U(1, ICodeEditorService)
], DiffToggleWordWrapController);
function canToggleWordWrap(codeEditorService, editor2) {
  if (!editor2) {
    return false;
  }
  if (editor2.isSimpleWidget) {
    return false;
  }
  const model = editor2.getModel();
  if (!model) {
    return false;
  }
  if (model.uri.scheme === "output") {
    return false;
  }
  if (editor2.getOption(60)) {
    for (const diffEditor of codeEditorService.listDiffEditors()) {
      if (diffEditor.getOriginalEditor() === editor2 && !diffEditor.renderSideBySide) {
        return false;
      }
    }
  }
  return true;
}
let EditorWordWrapContextKeyTracker = class EditorWordWrapContextKeyTracker2 {
  constructor(_editorService, _codeEditorService, _contextService) {
    this._editorService = _editorService;
    this._codeEditorService = _codeEditorService;
    this._contextService = _contextService;
    window.addEventListener("focus", () => this._update(), true);
    window.addEventListener("blur", () => this._update(), true);
    this._editorService.onDidActiveEditorChange(() => this._update());
    this._canToggleWordWrap = CAN_TOGGLE_WORD_WRAP.bindTo(this._contextService);
    this._editorWordWrap = EDITOR_WORD_WRAP.bindTo(this._contextService);
    this._activeEditor = null;
    this._activeEditorListener = new DisposableStore();
    this._update();
  }
  _update() {
    const activeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
    if (this._activeEditor === activeEditor) {
      return;
    }
    this._activeEditorListener.clear();
    this._activeEditor = activeEditor;
    if (activeEditor) {
      this._activeEditorListener.add(activeEditor.onDidChangeModel(() => this._updateFromCodeEditor()));
      this._activeEditorListener.add(activeEditor.onDidChangeConfiguration((e) => {
        if (e.hasChanged(143)) {
          this._updateFromCodeEditor();
        }
      }));
      this._updateFromCodeEditor();
    }
  }
  _updateFromCodeEditor() {
    if (!canToggleWordWrap(this._codeEditorService, this._activeEditor)) {
      return this._setValues(false, false);
    } else {
      const wrappingInfo = this._activeEditor.getOption(143);
      this._setValues(true, wrappingInfo.wrappingColumn !== -1);
    }
  }
  _setValues(canToggleWordWrap2, isWordWrap) {
    this._canToggleWordWrap.set(canToggleWordWrap2);
    this._editorWordWrap.set(isWordWrap);
  }
};
EditorWordWrapContextKeyTracker = __decorate$U([
  __param$U(0, IEditorService),
  __param$U(1, ICodeEditorService),
  __param$U(2, IContextKeyService)
], EditorWordWrapContextKeyTracker);
const workbenchRegistry = Registry.as(Extensions$1.Workbench);
workbenchRegistry.registerWorkbenchContribution(EditorWordWrapContextKeyTracker, 2);
registerEditorContribution(ToggleWordWrapController.ID, ToggleWordWrapController, 0);
registerDiffEditorContribution(DiffToggleWordWrapController.ID, DiffToggleWordWrapController);
registerEditorAction(ToggleWordWrapAction);
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
  command: {
    id: TOGGLE_WORD_WRAP_ID,
    title: localize("unwrapMinified", "Disable wrapping for this file"),
    icon: Codicon.wordWrap
  },
  group: "navigation",
  order: 1,
  when: ContextKeyExpr.and(ContextKeyExpr.has(isDominatedByLongLinesKey), ContextKeyExpr.has(isWordWrapMinifiedKey))
});
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
  command: {
    id: TOGGLE_WORD_WRAP_ID,
    title: localize("wrapMinified", "Enable wrapping for this file"),
    icon: Codicon.wordWrap
  },
  group: "navigation",
  order: 1,
  when: ContextKeyExpr.and(EditorContextKeys.inDiffEditor.negate(), ContextKeyExpr.has(isDominatedByLongLinesKey), ContextKeyExpr.not(isWordWrapMinifiedKey))
});
MenuRegistry.appendMenuItem(MenuId.MenubarViewMenu, {
  command: {
    id: TOGGLE_WORD_WRAP_ID,
    title: localize(
      { key: "miToggleWordWrap", comment: ["&& denotes a mnemonic"] },
      "&&Word Wrap"
    ),
    toggled: EDITOR_WORD_WRAP,
    precondition: CAN_TOGGLE_WORD_WRAP
  },
  order: 1,
  group: "5_editor"
});
const _ToggleRenderWhitespaceAction = class _ToggleRenderWhitespaceAction extends Action2 {
  constructor() {
    super({
      id: _ToggleRenderWhitespaceAction.ID,
      title: {
        value: localize("toggleRenderWhitespace", "Toggle Render Whitespace"),
        mnemonicTitle: localize(
          { key: "miToggleRenderWhitespace", comment: ["&& denotes a mnemonic"] },
          "&&Render Whitespace"
        ),
        original: "Toggle Render Whitespace"
      },
      category: Categories.View,
      f1: true,
      toggled: ContextKeyExpr.notEquals("config.editor.renderWhitespace", "none"),
      menu: {
        id: MenuId.MenubarAppearanceMenu,
        group: "4_editor",
        order: 3
      }
    });
  }
  run(accessor) {
    const configurationService = accessor.get(IConfigurationService);
    const renderWhitespace = configurationService.getValue("editor.renderWhitespace");
    let newRenderWhitespace;
    if (renderWhitespace === "none") {
      newRenderWhitespace = "all";
    } else {
      newRenderWhitespace = "none";
    }
    return configurationService.updateValue("editor.renderWhitespace", newRenderWhitespace);
  }
};
_ToggleRenderWhitespaceAction.ID = "editor.action.toggleRenderWhitespace";
let ToggleRenderWhitespaceAction = _ToggleRenderWhitespaceAction;
registerAction2(ToggleRenderWhitespaceAction);
class GutterActionsRegistryImpl {
  constructor() {
    this._registeredGutterActionsGenerators = /* @__PURE__ */ new Set();
  }
  registerGutterActionsGenerator(gutterActionsGenerator) {
    this._registeredGutterActionsGenerators.add(gutterActionsGenerator);
    return {
      dispose: () => {
        this._registeredGutterActionsGenerators.delete(gutterActionsGenerator);
      }
    };
  }
  getGutterActionsGenerators() {
    return Array.from(this._registeredGutterActionsGenerators.values());
  }
}
Registry.add("gutterActionsRegistry", new GutterActionsRegistryImpl());
const GutterActionsRegistry = Registry.as("gutterActionsRegistry");
let EditorLineNumberContextMenu = (_i = class extends Disposable {
  constructor(editor2, contextMenuService, menuService, contextKeyService, instantiationService) {
    super();
    this.editor = editor2;
    this.contextMenuService = contextMenuService;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this.instantiationService = instantiationService;
    this._register(this.editor.onMouseDown((e) => this.doShow(e, false)));
  }
  show(e) {
    this.doShow(e, true);
  }
  doShow(e, force) {
    const model = this.editor.getModel();
    if (!e.event.rightButton && !(isMacintosh && e.event.leftButton && e.event.ctrlKey) && !force || e.target.type !== 3 && e.target.type !== 2 || !e.target.position || !model) {
      return;
    }
    const lineNumber = e.target.position.lineNumber;
    const contextKeyService = this.contextKeyService.createOverlay([["editorLineNumber", lineNumber]]);
    const menu = this.menuService.createMenu(MenuId.EditorLineNumberContext, contextKeyService);
    const allActions = [];
    this.instantiationService.invokeFunction((accessor) => {
      for (const generator of GutterActionsRegistry.getGutterActionsGenerators()) {
        const collectedActions = /* @__PURE__ */ new Map();
        generator({ lineNumber, editor: this.editor, accessor }, {
          push: (action, group = "navigation") => {
            const actions = collectedActions.get(group) ?? [];
            actions.push(action);
            collectedActions.set(group, actions);
          }
        });
        for (const [group, actions] of collectedActions.entries()) {
          allActions.push([group, actions]);
        }
      }
      allActions.sort((a, b) => a[0].localeCompare(b[0]));
      const menuActions = menu.getActions({ arg: { lineNumber, uri: model.uri }, shouldForwardArgs: true });
      allActions.push(...menuActions);
      if (e.target.type === 3) {
        const currentSelections = this.editor.getSelections();
        const lineRange = {
          startLineNumber: lineNumber,
          endLineNumber: lineNumber,
          startColumn: 1,
          endColumn: model.getLineLength(lineNumber) + 1
        };
        const containsSelection = currentSelections == null ? void 0 : currentSelections.some((selection) => !selection.isEmpty() && selection.intersectRanges(lineRange) !== null);
        if (!containsSelection) {
          this.editor.setSelection(lineRange, "api");
        }
      }
      this.contextMenuService.showContextMenu({
        getAnchor: () => e.event,
        getActions: () => Separator.join(...allActions.map((a) => a[1])),
        onHide: () => menu.dispose()
      });
    });
  }
}, _i.ID = "workbench.contrib.editorLineNumberContextMenu", _i);
EditorLineNumberContextMenu = __decorate$U([
  __param$U(1, IContextMenuService),
  __param$U(2, IMenuService),
  __param$U(3, IContextKeyService),
  __param$U(4, IInstantiationService)
], EditorLineNumberContextMenu);
registerEditorContribution(EditorLineNumberContextMenu.ID, EditorLineNumberContextMenu, 1);
let DefaultFoldingRangeProvider = (_j = class extends Disposable {
  constructor(_extensionService, _configurationService) {
    super();
    this._extensionService = _extensionService;
    this._configurationService = _configurationService;
    this._store.add(this._extensionService.onDidChangeExtensions(this._updateConfigValues, this));
    this._store.add(FoldingController.setFoldingRangeProviderSelector(this._selectFoldingRangeProvider.bind(this)));
    this._updateConfigValues();
  }
  async _updateConfigValues() {
    var _a3;
    await this._extensionService.whenInstalledExtensionsRegistered();
    _j.extensionIds.length = 0;
    _j.extensionItemLabels.length = 0;
    _j.extensionDescriptions.length = 0;
    _j.extensionIds.push(null);
    _j.extensionItemLabels.push(localize("null", "All"));
    _j.extensionDescriptions.push(localize("nullFormatterDescription", "All active folding range providers"));
    const languageExtensions = [];
    const otherExtensions = [];
    for (const extension of this._extensionService.extensions) {
      if (extension.main || extension.browser) {
        if ((_a3 = extension.categories) == null ? void 0 : _a3.find((cat) => cat === "Programming Languages")) {
          languageExtensions.push(extension);
        } else {
          otherExtensions.push(extension);
        }
      }
    }
    const sorter = (a, b) => a.name.localeCompare(b.name);
    for (const extension of languageExtensions.sort(sorter)) {
      _j.extensionIds.push(extension.identifier.value);
      _j.extensionItemLabels.push(extension.displayName ?? "");
      _j.extensionDescriptions.push(extension.description ?? "");
    }
    for (const extension of otherExtensions.sort(sorter)) {
      _j.extensionIds.push(extension.identifier.value);
      _j.extensionItemLabels.push(extension.displayName ?? "");
      _j.extensionDescriptions.push(extension.description ?? "");
    }
  }
  _selectFoldingRangeProvider(providers, document2) {
    const value = this._configurationService.getValue(_j.configName, { overrideIdentifier: document2.getLanguageId() });
    if (value) {
      return providers.filter((p) => p.id === value);
    }
    return void 0;
  }
}, _j.configName = "editor.defaultFoldingRangeProvider", _j.extensionIds = [], _j.extensionItemLabels = [], _j.extensionDescriptions = [], _j);
DefaultFoldingRangeProvider = __decorate$U([
  __param$U(0, IExtensionService),
  __param$U(1, IConfigurationService)
], DefaultFoldingRangeProvider);
Registry.as(Extensions.Configuration).registerConfiguration({
  ...editorConfigurationBaseNode,
  properties: {
    [DefaultFoldingRangeProvider.configName]: {
      description: localize(
        "formatter.default",
        "Defines a default folding range provider that takes precedence over all other folding range providers. Must be the identifier of an extension contributing a folding range provider."
      ),
      type: ["string", "null"],
      default: null,
      enum: DefaultFoldingRangeProvider.extensionIds,
      enumItemLabels: DefaultFoldingRangeProvider.extensionItemLabels,
      markdownEnumDescriptions: DefaultFoldingRangeProvider.extensionDescriptions
    }
  }
});
Registry.as(Extensions$1.Workbench).registerWorkbenchContribution(DefaultFoldingRangeProvider, 3);
let InlayHintsAccessibility = (_k = class {
  static get(editor2) {
    return editor2.getContribution(_k.ID) ?? void 0;
  }
  constructor(_editor, contextKeyService, _audioCueService, _instaService) {
    this._editor = _editor;
    this._audioCueService = _audioCueService;
    this._instaService = _instaService;
    this._sessionDispoosables = new DisposableStore();
    this._ariaElement = document.createElement("span");
    this._ariaElement.style.position = "fixed";
    this._ariaElement.className = "inlayhint-accessibility-element";
    this._ariaElement.tabIndex = 0;
    this._ariaElement.setAttribute("aria-description", localize("description", "Code with Inlay Hint Information"));
    this._ctxIsReading = _k.IsReading.bindTo(contextKeyService);
  }
  dispose() {
    this._sessionDispoosables.dispose();
    this._ctxIsReading.reset();
    this._ariaElement.remove();
  }
  _reset() {
    clearNode(this._ariaElement);
    this._sessionDispoosables.clear();
    this._ctxIsReading.reset();
  }
  async _read(line, hints) {
    var _a3;
    this._sessionDispoosables.clear();
    if (!this._ariaElement.isConnected) {
      (_a3 = this._editor.getDomNode()) == null ? void 0 : _a3.appendChild(this._ariaElement);
    }
    if (!this._editor.hasModel() || !this._ariaElement.isConnected) {
      this._ctxIsReading.set(false);
      return;
    }
    const cts = new CancellationTokenSource();
    this._sessionDispoosables.add(cts);
    for (const hint of hints) {
      await hint.resolve(cts.token);
    }
    if (cts.token.isCancellationRequested) {
      return;
    }
    const model = this._editor.getModel();
    const newChildren = [];
    let start = 0;
    let tooLongToRead = false;
    for (const item of hints) {
      const part = model.getValueInRange({ startLineNumber: line, startColumn: start + 1, endLineNumber: line, endColumn: item.hint.position.column });
      if (part.length > 0) {
        newChildren.push(part);
        start = item.hint.position.column - 1;
      }
      if (start > 750) {
        newChildren.push("…");
        tooLongToRead = true;
        break;
      }
      const em = document.createElement("em");
      const { label } = item.hint;
      if (typeof label === "string") {
        em.innerText = label;
      } else {
        for (const part2 of label) {
          if (part2.command) {
            const link = this._instaService.createInstance(Link$1, em, { href: asCommandLink(part2.command), label: part2.label, title: part2.command.title }, void 0);
            this._sessionDispoosables.add(link);
          } else {
            em.innerText += part2.label;
          }
        }
      }
      newChildren.push(em);
    }
    if (!tooLongToRead) {
      newChildren.push(model.getValueInRange({ startLineNumber: line, startColumn: start + 1, endLineNumber: line, endColumn: Number.MAX_SAFE_INTEGER }));
    }
    reset(this._ariaElement, ...newChildren);
    this._ariaElement.focus();
    this._ctxIsReading.set(true);
    this._sessionDispoosables.add(addDisposableListener(this._ariaElement, "focusout", () => {
      this._reset();
    }));
  }
  startInlayHintsReading() {
    var _a3;
    if (!this._editor.hasModel()) {
      return;
    }
    const line = this._editor.getPosition().lineNumber;
    const hints = (_a3 = InlayHintsController.get(this._editor)) == null ? void 0 : _a3.getInlayHintsForLine(line);
    if (!hints || hints.length === 0) {
      this._audioCueService.playAudioCue(AudioCue.noInlayHints);
    } else {
      this._read(line, hints);
    }
  }
  stopInlayHintsReading() {
    this._reset();
    this._editor.focus();
  }
}, _k.IsReading = new RawContextKey(
  "isReadingLineWithInlayHints",
  false,
  { type: "boolean", description: localize(
    "isReadingLineWithInlayHints",
    "Whether the current line and its inlay hints are currently focused"
  ) }
), _k.ID = "editor.contrib.InlayHintsAccessibility", _k);
InlayHintsAccessibility = __decorate$U([
  __param$U(1, IContextKeyService),
  __param$U(2, IAudioCueService),
  __param$U(3, IInstantiationService)
], InlayHintsAccessibility);
registerAction2(class StartReadHints extends EditorAction2 {
  constructor() {
    super({
      id: "inlayHints.startReadingLineWithHint",
      title: {
        value: localize("read.title", "Read Line With Inline Hints"),
        original: "Read Line With Inline Hints"
      },
      precondition: EditorContextKeys.hasInlayHintsProvider,
      f1: true
    });
  }
  runEditorCommand(_accessor, editor2) {
    const ctrl = InlayHintsAccessibility.get(editor2);
    ctrl == null ? void 0 : ctrl.startInlayHintsReading();
  }
});
registerAction2(class StopReadHints extends EditorAction2 {
  constructor() {
    super({
      id: "inlayHints.stopReadingLineWithHint",
      title: {
        value: localize("stop.title", "Stop Inlay Hints Reading"),
        original: "Stop Inlay Hints Reading"
      },
      precondition: InlayHintsAccessibility.IsReading,
      f1: true,
      keybinding: {
        weight: 100,
        primary: 9
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    const ctrl = InlayHintsAccessibility.get(editor2);
    ctrl == null ? void 0 : ctrl.stopInlayHintsReading();
  }
});
registerEditorContribution(InlayHintsAccessibility.ID, InlayHintsAccessibility, 4);
var CodeActionExtensionPointFields;
(function(CodeActionExtensionPointFields2) {
  CodeActionExtensionPointFields2["languages"] = "languages";
  CodeActionExtensionPointFields2["actions"] = "actions";
  CodeActionExtensionPointFields2["kind"] = "kind";
  CodeActionExtensionPointFields2["title"] = "title";
  CodeActionExtensionPointFields2["description"] = "description";
})(CodeActionExtensionPointFields || (CodeActionExtensionPointFields = {}));
const codeActionsExtensionPointSchema = Object.freeze({
  type: "array",
  markdownDescription: localize("contributes.codeActions", "Configure which editor to use for a resource."),
  items: {
    type: "object",
    required: [CodeActionExtensionPointFields.languages, CodeActionExtensionPointFields.actions],
    properties: {
      [CodeActionExtensionPointFields.languages]: {
        type: "array",
        description: localize(
          "contributes.codeActions.languages",
          "Language modes that the code actions are enabled for."
        ),
        items: { type: "string" }
      },
      [CodeActionExtensionPointFields.actions]: {
        type: "object",
        required: [CodeActionExtensionPointFields.kind, CodeActionExtensionPointFields.title],
        properties: {
          [CodeActionExtensionPointFields.kind]: {
            type: "string",
            markdownDescription: localize(
              "contributes.codeActions.kind",
              "`CodeActionKind` of the contributed code action."
            )
          },
          [CodeActionExtensionPointFields.title]: {
            type: "string",
            description: localize(
              "contributes.codeActions.title",
              "Label for the code action used in the UI."
            )
          },
          [CodeActionExtensionPointFields.description]: {
            type: "string",
            description: localize(
              "contributes.codeActions.description",
              "Description of what the code action does."
            )
          }
        }
      }
    }
  }
});
const codeActionsExtensionPointDescriptor = {
  extensionPoint: "codeActions",
  deps: [languagesExtPoint],
  jsonSchema: codeActionsExtensionPointSchema
};
var DocumentationExtensionPointFields;
(function(DocumentationExtensionPointFields2) {
  DocumentationExtensionPointFields2["when"] = "when";
  DocumentationExtensionPointFields2["title"] = "title";
  DocumentationExtensionPointFields2["command"] = "command";
})(
  DocumentationExtensionPointFields || (DocumentationExtensionPointFields = {})
);
const documentationExtensionPointSchema = Object.freeze({
  type: "object",
  description: localize("contributes.documentation", "Contributed documentation."),
  properties: {
    "refactoring": {
      type: "array",
      description: localize(
        "contributes.documentation.refactorings",
        "Contributed documentation for refactorings."
      ),
      items: {
        type: "object",
        description: localize(
          "contributes.documentation.refactoring",
          "Contributed documentation for refactoring."
        ),
        required: [
          DocumentationExtensionPointFields.title,
          DocumentationExtensionPointFields.when,
          DocumentationExtensionPointFields.command
        ],
        properties: {
          [DocumentationExtensionPointFields.title]: {
            type: "string",
            description: localize(
              "contributes.documentation.refactoring.title",
              "Label for the documentation used in the UI."
            )
          },
          [DocumentationExtensionPointFields.when]: {
            type: "string",
            description: localize("contributes.documentation.refactoring.when", "When clause.")
          },
          [DocumentationExtensionPointFields.command]: {
            type: "string",
            description: localize("contributes.documentation.refactoring.command", "Command executed.")
          }
        }
      }
    }
  }
});
const documentationExtensionPointDescriptor = {
  extensionPoint: "documentation",
  deps: [languagesExtPoint],
  jsonSchema: documentationExtensionPointSchema
};
const codeActionsOnSaveDefaultProperties = Object.freeze({
  "source.fixAll": {
    type: "boolean",
    description: localize(
      "codeActionsOnSave.fixAll",
      "Controls whether auto fix action should be run on file save."
    )
  }
});
const codeActionsOnSaveSchema = {
  oneOf: [
    {
      type: "object",
      properties: codeActionsOnSaveDefaultProperties,
      additionalProperties: {
        type: "boolean"
      }
    },
    {
      type: "array",
      items: { type: "string" }
    }
  ],
  default: {},
  description: localize("codeActionsOnSave", "Code Action kinds to be run on save."),
  scope: 5
};
const editorConfiguration = Object.freeze({
  ...editorConfigurationBaseNode,
  properties: {
    "editor.codeActionsOnSave": codeActionsOnSaveSchema
  }
});
let CodeActionsContribution = class CodeActionsContribution2 extends Disposable {
  constructor(codeActionsExtensionPoint2, keybindingService) {
    super();
    this._contributedCodeActions = [];
    this._onDidChangeContributions = this._register(new Emitter());
    codeActionsExtensionPoint2.setHandler((extensionPoints) => {
      this._contributedCodeActions = extensionPoints.map((x) => x.value).flat();
      this.updateConfigurationSchema(this._contributedCodeActions);
      this._onDidChangeContributions.fire();
    });
    keybindingService.registerSchemaContribution({
      getSchemaAdditions: () => this.getSchemaAdditions(),
      onDidChange: this._onDidChangeContributions.event
    });
  }
  updateConfigurationSchema(codeActionContributions) {
    const newProperties = { ...codeActionsOnSaveDefaultProperties };
    for (const [sourceAction, props] of this.getSourceActions(codeActionContributions)) {
      newProperties[sourceAction] = {
        type: "boolean",
        description: localize(
          "codeActionsOnSave.generic",
          "Controls whether '{0}' actions should be run on file save.",
          props.title
        )
      };
    }
    codeActionsOnSaveSchema.properties = newProperties;
    Registry.as(Extensions.Configuration).notifyConfigurationSchemaUpdated(editorConfiguration);
  }
  getSourceActions(contributions) {
    const defaultKinds = Object.keys(codeActionsOnSaveDefaultProperties).map((value) => new CodeActionKind$1(value));
    const sourceActions = /* @__PURE__ */ new Map();
    for (const contribution of contributions) {
      for (const action of contribution.actions) {
        const kind = new CodeActionKind$1(action.kind);
        if (CodeActionKind$1.Source.contains(kind) && !defaultKinds.some((defaultKind) => defaultKind.contains(kind))) {
          sourceActions.set(kind.value, action);
        }
      }
    }
    return sourceActions;
  }
  getSchemaAdditions() {
    const conditionalSchema = (command, actions) => {
      return {
        if: {
          required: ["command"],
          properties: {
            "command": { const: command }
          }
        },
        then: {
          properties: {
            "args": {
              required: ["kind"],
              properties: {
                "kind": {
                  anyOf: [
                    {
                      enum: actions.map((action) => action.kind),
                      enumDescriptions: actions.map((action) => action.description ?? action.title)
                    },
                    { type: "string" }
                  ]
                }
              }
            }
          }
        }
      };
    };
    const getActions = (ofKind) => {
      const allActions = this._contributedCodeActions.map((desc) => desc.actions).flat();
      const out = /* @__PURE__ */ new Map();
      for (const action of allActions) {
        if (!out.has(action.kind) && ofKind.contains(new CodeActionKind$1(action.kind))) {
          out.set(action.kind, action);
        }
      }
      return Array.from(out.values());
    };
    return [
      conditionalSchema(codeActionCommandId, getActions(CodeActionKind$1.Empty)),
      conditionalSchema(refactorCommandId, getActions(CodeActionKind$1.Refactor)),
      conditionalSchema(sourceActionCommandId, getActions(CodeActionKind$1.Source))
    ];
  }
};
CodeActionsContribution = __decorate$U([
  __param$U(1, IKeybindingService)
], CodeActionsContribution);
let CodeActionDocumentationContribution = class CodeActionDocumentationContribution2 extends Disposable {
  constructor(extensionPoint, contextKeyService, languageFeaturesService) {
    super();
    this.contextKeyService = contextKeyService;
    this.contributions = [];
    this.emptyCodeActionsList = {
      actions: [],
      dispose: () => {
      }
    };
    this._register(languageFeaturesService.codeActionProvider.register("*", this));
    extensionPoint.setHandler((points) => {
      this.contributions = [];
      for (const documentation of points) {
        if (!documentation.value.refactoring) {
          continue;
        }
        for (const contribution of documentation.value.refactoring) {
          const precondition = ContextKeyExpr.deserialize(contribution.when);
          if (!precondition) {
            continue;
          }
          this.contributions.push({
            title: contribution.title,
            when: precondition,
            command: contribution.command
          });
        }
      }
    });
  }
  async provideCodeActions(_model, _range, context, _token) {
    return this.emptyCodeActionsList;
  }
  _getAdditionalMenuItems(context, actions) {
    if (context.only !== CodeActionKind$1.Refactor.value) {
      if (!actions.some((action) => action.kind && CodeActionKind$1.Refactor.contains(new CodeActionKind$1(action.kind)))) {
        return [];
      }
    }
    return this.contributions.filter((contribution) => this.contextKeyService.contextMatchesRules(contribution.when)).map((contribution) => {
      return {
        id: contribution.command,
        title: contribution.title
      };
    });
  }
};
CodeActionDocumentationContribution = __decorate$U([
  __param$U(1, IContextKeyService),
  __param$U(2, ILanguageFeaturesService)
], CodeActionDocumentationContribution);
const codeActionsExtensionPoint = ExtensionsRegistry.registerExtensionPoint(codeActionsExtensionPointDescriptor);
const documentationExtensionPoint = ExtensionsRegistry.registerExtensionPoint(documentationExtensionPointDescriptor);
Registry.as(Extensions.Configuration).registerConfiguration(editorConfiguration);
let WorkbenchConfigurationContribution = class WorkbenchConfigurationContribution2 {
  constructor(instantiationService) {
    instantiationService.createInstance(CodeActionsContribution, codeActionsExtensionPoint);
    instantiationService.createInstance(CodeActionDocumentationContribution, documentationExtensionPoint);
  }
};
WorkbenchConfigurationContribution = __decorate$U([
  __param$U(0, IInstantiationService)
], WorkbenchConfigurationContribution);
Registry.as(Extensions$1.Workbench).registerWorkbenchContribution(WorkbenchConfigurationContribution, 4);
let ListContext = class ListContext2 {
  constructor(contextKeyService) {
    contextKeyService.createKey("listSupportsTypeNavigation", true);
    contextKeyService.createKey("listSupportsKeyboardNavigation", true);
  }
};
ListContext = __decorate$U([
  __param$U(0, IContextKeyService)
], ListContext);
Registry.as(Extensions$1.Workbench).registerWorkbenchContribution(ListContext, 1);
let ExtensionPoints = class ExtensionPoints2 {
  constructor(instantiationService) {
    this.instantiationService = instantiationService;
    this.instantiationService.createInstance(JSONValidationExtensionPoint);
    this.instantiationService.createInstance(ColorExtensionPoint);
  }
};
ExtensionPoints = __decorate$U([
  __param$U(0, IInstantiationService)
], ExtensionPoints);
Registry.as(Extensions$1.Workbench).registerWorkbenchContribution(ExtensionPoints, 1);
function computeConfiguration(configuration2, isDiffEditor, overrides) {
  const editorConfiguration2 = isObject(configuration2.editor) ? deepClone(configuration2.editor) : /* @__PURE__ */ Object.create(null);
  if (isDiffEditor && isObject(configuration2.diffEditor)) {
    Object.assign(editorConfiguration2, deepClone(configuration2.diffEditor));
  }
  Object.assign(editorConfiguration2, deepClone(overrides));
  return editorConfiguration2;
}
let ConfiguredStandaloneEditor = class ConfiguredStandaloneEditor2 extends createInjectedClass(StandaloneEditor) {
  constructor(domElement, isDiffEditor, _options = {}, instantiationService, textResourceConfigurationService) {
    var _a3;
    const { theme, autoDetectHighContrast, model, value, language: language2, accessibilityHelpUrl, ariaContainerElement, overflowWidgetsDomNode, dimension, ...options } = _options;
    const computedOptions = computeConfiguration(textResourceConfigurationService.getValue((_a3 = _options.model) == null ? void 0 : _a3.uri), isDiffEditor, options);
    super(instantiationService, domElement, { ...computedOptions, overflowWidgetsDomNode, dimension, theme, autoDetectHighContrast, model, value, language: language2, accessibilityHelpUrl, ariaContainerElement });
    this.isDiffEditor = isDiffEditor;
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.optionsOverrides = {};
    this.lastAppliedEditorOptions = computedOptions;
    this.optionsOverrides = options;
    this._register(textResourceConfigurationService.onDidChangeConfiguration(() => this.updateEditorConfiguration()));
    this._register(this.onDidChangeModelLanguage(() => this.updateEditorConfiguration()));
    this._register(this.onDidChangeModel(() => this.updateEditorConfiguration()));
    this.updateEditorConfiguration();
  }
  updateEditorConfiguration() {
    if (!this.hasModel() || this.textResourceConfigurationService == null) {
      return;
    }
    const resource = this.getModel().uri;
    const configuration2 = this.textResourceConfigurationService.getValue(resource);
    if (configuration2 == null) {
      return;
    }
    const editorConfiguration2 = computeConfiguration(configuration2, this.isDiffEditor, this.optionsOverrides);
    let editorSettingsToApply = editorConfiguration2;
    if (this.lastAppliedEditorOptions != null) {
      editorSettingsToApply = distinct(this.lastAppliedEditorOptions, editorSettingsToApply);
    }
    if (Object.keys(editorSettingsToApply).length > 0) {
      this.lastAppliedEditorOptions = editorConfiguration2;
      super.updateOptions(editorSettingsToApply);
    }
  }
  updateOptions(newOptions) {
    this.optionsOverrides ?? (this.optionsOverrides = {});
    const didChange = EditorOptionsUtil.applyUpdate(this.optionsOverrides, newOptions);
    if (!didChange) {
      return;
    }
    this.updateEditorConfiguration();
  }
};
ConfiguredStandaloneEditor = __decorate$U([
  __param$U(3, IInstantiationService),
  __param$U(4, ITextResourceConfigurationService)
], ConfiguredStandaloneEditor);
class ConfiguredStandaloneDiffEditor extends StandaloneDiffEditor {
  _createInnerEditor(instantiationService, container, options) {
    return instantiationService.createInstance(ConfiguredStandaloneEditor, container, true, options);
  }
}
async function writeFile(uri, content) {
  await StandaloneServices.get(IFileService).writeFile(uri, VSBuffer.fromString(content));
}
async function createModelReference(resource, content) {
  if (content != null) {
    await writeFile(resource, content);
  }
  return await StandaloneServices.get(ITextModelService).createModelReference(resource);
}
function isDynamicKeybindingService(keybindingService) {
  return keybindingService.registerKeybindingProvider != null;
}
let DelegateStandaloneKeybindingService = class DelegateStandaloneKeybindingService2 extends StandaloneKeybindingService {
  constructor(delegate, contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {
    super(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService);
    this.delegate = delegate;
    this._register(delegate.registerKeybindingProvider(() => this.getUserKeybindingItems()));
  }
  _getResolver() {
    return this.delegate._getResolver();
  }
};
DelegateStandaloneKeybindingService = __decorate$U([
  __param$U(1, IContextKeyService),
  __param$U(2, ICommandService),
  __param$U(3, ITelemetryService),
  __param$U(4, INotificationService),
  __param$U(5, ILogService),
  __param$U(6, ICodeEditorService)
], DelegateStandaloneKeybindingService);
let standaloneEditorInstantiationService = null;
function getStandaloneEditorInstantiationService() {
  if (standaloneEditorInstantiationService == null) {
    const serviceCollection = new ServiceCollection();
    serviceCollection.set(IQuickInputService, new SyncDescriptor(StandaloneQuickInputService, void 0, true));
    const keybindingService = StandaloneServices.get(IKeybindingService);
    if (!(keybindingService instanceof StandaloneKeybindingService) && isDynamicKeybindingService(keybindingService)) {
      serviceCollection.set(IKeybindingService, new SyncDescriptor(DelegateStandaloneKeybindingService, [keybindingService], true));
    }
    standaloneEditorInstantiationService = StandaloneServices.get(IInstantiationService).createChild(serviceCollection);
  }
  return standaloneEditorInstantiationService;
}
const createConfiguredEditor = (domElement, options, override) => {
  StandaloneServices.initialize(override ?? {});
  return getStandaloneEditorInstantiationService().createInstance(ConfiguredStandaloneEditor, domElement, false, options);
};
const createConfiguredDiffEditor = (domElement, options, override) => {
  StandaloneServices.initialize(override ?? {});
  return getStandaloneEditorInstantiationService().createInstance(ConfiguredStandaloneDiffEditor, domElement, options);
};
class EditorAppBase {
  constructor(id) {
    __publicField(this, "id");
    __publicField(this, "editor");
    __publicField(this, "diffEditor");
    __publicField(this, "modelRef");
    __publicField(this, "modelOriginalRef");
    this.id = id;
  }
  buildConfig(userConfig) {
    const userAppConfig = userConfig.wrapperConfig.editorAppConfig;
    return {
      languageId: userAppConfig.languageId,
      code: userAppConfig.code ?? "",
      codeOriginal: userAppConfig.codeOriginal ?? "",
      useDiffEditor: userAppConfig.useDiffEditor === true,
      codeUri: userAppConfig.codeUri ?? void 0,
      codeOriginalUri: userAppConfig.codeOriginalUri ?? void 0,
      readOnly: userAppConfig.readOnly ?? false,
      domReadOnly: userAppConfig.domReadOnly ?? false,
      automaticLayout: userAppConfig.automaticLayout ?? true
    };
  }
  haveEditor() {
    return this.editor !== void 0 || this.diffEditor !== void 0;
  }
  getEditor() {
    return this.editor;
  }
  getDiffEditor() {
    return this.diffEditor;
  }
  async createEditor(container, editorOptions) {
    this.editor = createConfiguredEditor(container, editorOptions);
    await this.updateEditorModel();
  }
  async createDiffEditor(container, diffEditorOptions) {
    this.diffEditor = createConfiguredDiffEditor(container, diffEditorOptions);
    await this.updateDiffEditorModel();
  }
  disposeEditor() {
    var _a3;
    if (this.editor) {
      (_a3 = this.modelRef) == null ? void 0 : _a3.dispose();
      this.editor.dispose();
      this.editor = void 0;
    }
  }
  disposeDiffEditor() {
    var _a3, _b3;
    if (this.diffEditor) {
      (_a3 = this.modelRef) == null ? void 0 : _a3.dispose();
      (_b3 = this.modelOriginalRef) == null ? void 0 : _b3.dispose();
      this.diffEditor.dispose();
      this.diffEditor = void 0;
    }
  }
  getModel(original) {
    var _a3, _b3, _c3;
    if (this.getConfig().useDiffEditor) {
      return (original === true ? (_a3 = this.modelOriginalRef) == null ? void 0 : _a3.object.textEditorModel : (_b3 = this.modelRef) == null ? void 0 : _b3.object.textEditorModel) ?? void 0;
    } else {
      return ((_c3 = this.modelRef) == null ? void 0 : _c3.object.textEditorModel) ?? void 0;
    }
  }
  async updateModel(modelUpdate) {
    if (!this.editor) {
      return Promise.reject(new Error("You cannot update the editor model, because the regular editor is not configured."));
    }
    this.updateAppConfig(modelUpdate);
    await this.updateEditorModel();
  }
  async updateEditorModel() {
    var _a3;
    const config = this.getConfig();
    (_a3 = this.modelRef) == null ? void 0 : _a3.dispose();
    const uri = this.getEditorUri("code");
    this.modelRef = await createModelReference(uri, config.code);
    this.modelRef.object.setLanguageId(config.languageId);
    if (this.editor) {
      this.editor.setModel(this.modelRef.object.textEditorModel);
    }
  }
  async updateDiffModel(modelUpdate) {
    if (!this.diffEditor) {
      return Promise.reject(new Error("You cannot update the diff editor models, because the diffEditor is not configured."));
    }
    this.updateAppConfig(modelUpdate);
    return this.updateDiffEditorModel();
  }
  async updateDiffEditorModel() {
    var _a3, _b3, _c3;
    const config = this.getConfig();
    (_a3 = this.modelRef) == null ? void 0 : _a3.dispose();
    (_b3 = this.modelOriginalRef) == null ? void 0 : _b3.dispose();
    const uri = this.getEditorUri("code");
    const uriOriginal = this.getEditorUri("codeOriginal");
    const promises = [];
    promises.push(createModelReference(uri, config.code));
    promises.push(createModelReference(uriOriginal, config.codeOriginal));
    const refs = await Promise.all(promises);
    this.modelRef = refs[0];
    this.modelRef.object.setLanguageId(config.languageId);
    this.modelOriginalRef = refs[1];
    this.modelOriginalRef.object.setLanguageId(config.languageId);
    if (this.diffEditor && this.modelRef.object.textEditorModel !== null && this.modelOriginalRef.object.textEditorModel !== null) {
      (_c3 = this.diffEditor) == null ? void 0 : _c3.setModel({
        original: this.modelOriginalRef.object.textEditorModel,
        modified: this.modelRef.object.textEditorModel
      });
    }
  }
  updateAppConfig(modelUpdate) {
    const config = this.getConfig();
    if (modelUpdate.code !== void 0) {
      config.code = modelUpdate.code;
    }
    if (modelUpdate.languageId !== void 0) {
      config.languageId = modelUpdate.languageId;
    }
    if (modelUpdate.uri !== void 0) {
      config.codeUri = modelUpdate.uri;
    }
    if (modelUpdate.codeOriginal !== void 0) {
      config.codeOriginal = modelUpdate.codeOriginal;
    }
    if (modelUpdate.codeOriginalUri !== void 0) {
      config.codeOriginalUri = modelUpdate.codeOriginalUri;
    }
  }
  getEditorUri(uriType) {
    const config = this.getConfig();
    const uri = uriType === "code" ? config.codeUri : config.codeOriginalUri;
    if (uri) {
      return Uri.parse(uri);
    } else {
      return Uri.parse(`/tmp/model${uriType === "codeOriginal" ? "Original" : ""}${this.id}.${config.languageId}`);
    }
  }
  updateLayout() {
    var _a3, _b3;
    if (this.getConfig().useDiffEditor) {
      (_a3 = this.diffEditor) == null ? void 0 : _a3.layout();
    } else {
      (_b3 = this.editor) == null ? void 0 : _b3.layout();
    }
  }
  updateMonacoEditorOptions(options) {
    var _a3;
    (_a3 = this.editor) == null ? void 0 : _a3.updateOptions(options);
  }
}
const isVscodeApiEditorApp = (wrapperConfig) => {
  var _a3;
  return ((_a3 = wrapperConfig.editorAppConfig) == null ? void 0 : _a3.$type) === "vscodeApi";
};
class EditorAppClassic extends EditorAppBase {
  constructor(id, userConfig, logger) {
    super(id);
    __publicField(this, "editorOptions");
    __publicField(this, "diffEditorOptions");
    __publicField(this, "config");
    __publicField(this, "logger");
    this.logger = logger;
    this.config = this.buildConfig(userConfig);
    const userInput = userConfig.wrapperConfig.editorAppConfig;
    this.config.theme = userInput.theme ?? "vs-light";
    this.config.automaticLayout = userInput.automaticLayout ?? true;
    this.editorOptions = userInput.editorOptions ?? {};
    this.editorOptions.automaticLayout = userInput.automaticLayout ?? true;
    this.diffEditorOptions = userInput.diffEditorOptions ?? {};
    this.diffEditorOptions.automaticLayout = userInput.automaticLayout ?? true;
    this.config.languageExtensionConfig = userInput.languageExtensionConfig ?? void 0;
    this.config.languageDef = userInput.languageDef ?? void 0;
    this.config.themeData = userInput.themeData ?? void 0;
  }
  getAppType() {
    return "classic";
  }
  getConfig() {
    return this.config;
  }
  async createEditors(container) {
    if (this.config.useDiffEditor) {
      await this.createDiffEditor(container, this.diffEditorOptions);
    } else {
      await this.createEditor(container, this.editorOptions);
    }
  }
  async init() {
    var _a3;
    const extLang = this.config.languageExtensionConfig;
    if (extLang) {
      languages.register(extLang);
    }
    const languageRegistered = languages.getLanguages().filter((x) => x.id === this.config.languageId);
    if (languageRegistered.length === 0) {
      languages.register({
        id: this.config.languageId
      });
    }
    const tokenProvider = this.config.languageDef;
    if (tokenProvider) {
      languages.setMonarchTokensProvider(this.config.languageId, tokenProvider);
    }
    const themeData = this.config.themeData;
    if (themeData) {
      editor.defineTheme(this.config.theme, themeData);
    }
    editor.setTheme(this.config.theme);
    (_a3 = this.logger) == null ? void 0 : _a3.info("Init of MonacoConfig was completed.");
    return Promise.resolve();
  }
  async updateEditorOptions(options) {
    this.updateMonacoEditorOptions(options);
  }
  disposeApp() {
    this.disposeEditor();
    this.disposeDiffEditor();
  }
}
class WorkspaceConfigurationModelParser extends ConfigurationModelParser {
  constructor(name) {
    super(name);
    this._folders = [];
    this._transient = false;
    this._settingsModelParser = new ConfigurationModelParser(name);
    this._launchModel = new ConfigurationModel();
    this._tasksModel = new ConfigurationModel();
  }
  get folders() {
    return this._folders;
  }
  get transient() {
    return this._transient;
  }
  get settingsModel() {
    return this._settingsModelParser.configurationModel;
  }
  get launchModel() {
    return this._launchModel;
  }
  get tasksModel() {
    return this._tasksModel;
  }
  reparseWorkspaceSettings(configurationParseOptions) {
    this._settingsModelParser.reparse(configurationParseOptions);
  }
  getRestrictedWorkspaceSettings() {
    return this._settingsModelParser.restrictedConfigurations;
  }
  doParseRaw(raw, configurationParseOptions) {
    this._folders = raw["folders"] || [];
    this._transient = isBoolean(raw["transient"]) && raw["transient"];
    this._settingsModelParser.parseRaw(raw["settings"], configurationParseOptions);
    this._launchModel = this.createConfigurationModelFrom(raw, "launch");
    this._tasksModel = this.createConfigurationModelFrom(raw, "tasks");
    return super.doParseRaw(raw, configurationParseOptions);
  }
  createConfigurationModelFrom(raw, key) {
    const data = raw[key];
    if (data) {
      const contents = toValuesTree(data, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
      const scopedContents = /* @__PURE__ */ Object.create(null);
      scopedContents[key] = contents;
      const keys = Object.keys(data).map((k) => `${key}.${k}`);
      return new ConfigurationModel(scopedContents, keys, []);
    }
    return new ConfigurationModel();
  }
}
class StandaloneConfigurationModelParser extends ConfigurationModelParser {
  constructor(name, scope) {
    super(name);
    this.scope = scope;
  }
  doParseRaw(raw, configurationParseOptions) {
    const contents = toValuesTree(raw, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
    const scopedContents = /* @__PURE__ */ Object.create(null);
    scopedContents[this.scope] = contents;
    const keys = Object.keys(raw).map((key) => `${this.scope}.${key}`);
    return { contents: scopedContents, keys, overrides: [] };
  }
}
class Configuration extends Configuration$1 {
  constructor(defaults, policy, application, localUser, remoteUser, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource, _workspace) {
    super(defaults, policy, application, localUser, remoteUser, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource);
    this._workspace = _workspace;
  }
  getValue(key, overrides = {}) {
    return super.getValue(key, overrides, this._workspace);
  }
  inspect(key, overrides = {}) {
    return super.inspect(key, overrides, this._workspace);
  }
  keys() {
    return super.keys(this._workspace);
  }
  compareAndDeleteFolderConfiguration(folder) {
    if (this._workspace && this._workspace.folders.length > 0 && this._workspace.folders[0].uri.toString() === folder.toString()) {
      return { keys: [], overrides: [] };
    }
    return super.compareAndDeleteFolderConfiguration(folder);
  }
  compare(other) {
    const compare2 = (fromKeys, toKeys, overrideIdentifier) => {
      const keys2 = [];
      keys2.push(...toKeys.filter((key) => fromKeys.indexOf(key) === -1));
      keys2.push(...fromKeys.filter((key) => toKeys.indexOf(key) === -1));
      keys2.push(...fromKeys.filter((key) => {
        if (toKeys.indexOf(key) === -1) {
          return false;
        }
        if (!equals$2(this.getValue(key, { overrideIdentifier }), other.getValue(key, { overrideIdentifier }))) {
          return true;
        }
        return this._workspace && this._workspace.folders.some(
          (folder) => !equals$2(this.getValue(key, { resource: folder.uri, overrideIdentifier }), other.getValue(key, { resource: folder.uri, overrideIdentifier }))
        );
      }));
      return keys2;
    };
    const keys = compare2(this.allKeys(), other.allKeys());
    const overrides = [];
    const allOverrideIdentifiers = distinct$1([...this.allOverrideIdentifiers(), ...other.allOverrideIdentifiers()]);
    for (const overrideIdentifier of allOverrideIdentifiers) {
      const keys2 = compare2(this.getAllKeysForOverrideIdentifier(overrideIdentifier), other.getAllKeysForOverrideIdentifier(overrideIdentifier), overrideIdentifier);
      if (keys2.length) {
        overrides.push([overrideIdentifier, keys2]);
      }
    }
    return { keys, overrides };
  }
}
const FOLDER_CONFIG_FOLDER_NAME = ".vscode";
const FOLDER_SETTINGS_NAME = "settings";
const FOLDER_SETTINGS_PATH = `${FOLDER_CONFIG_FOLDER_NAME}/${FOLDER_SETTINGS_NAME}.json`;
const defaultSettingsSchemaId = "vscode://schemas/settings/default";
const userSettingsSchemaId = "vscode://schemas/settings/user";
const profileSettingsSchemaId = "vscode://schemas/settings/profile";
const machineSettingsSchemaId = "vscode://schemas/settings/machine";
const workspaceSettingsSchemaId = "vscode://schemas/settings/workspace";
const folderSettingsSchemaId = "vscode://schemas/settings/folder";
const launchSchemaId = "vscode://schemas/launch";
const tasksSchemaId = "vscode://schemas/tasks";
const APPLICATION_SCOPES = [1];
const PROFILE_SCOPES = [2, 3, 4, 5, 6];
const LOCAL_MACHINE_PROFILE_SCOPES = [3, 4, 5];
const LOCAL_MACHINE_SCOPES = [1, ...LOCAL_MACHINE_PROFILE_SCOPES];
const REMOTE_MACHINE_SCOPES = [2, 3, 4, 5, 6];
const WORKSPACE_SCOPES = [3, 4, 5, 6];
const FOLDER_SCOPES = [4, 5, 6];
const TASKS_CONFIGURATION_KEY = "tasks";
const LAUNCH_CONFIGURATION_KEY = "launch";
const WORKSPACE_STANDALONE_CONFIGURATIONS = /* @__PURE__ */ Object.create(null);
WORKSPACE_STANDALONE_CONFIGURATIONS[TASKS_CONFIGURATION_KEY] = `${FOLDER_CONFIG_FOLDER_NAME}/${TASKS_CONFIGURATION_KEY}.json`;
WORKSPACE_STANDALONE_CONFIGURATIONS[LAUNCH_CONFIGURATION_KEY] = `${FOLDER_CONFIG_FOLDER_NAME}/${LAUNCH_CONFIGURATION_KEY}.json`;
const USER_STANDALONE_CONFIGURATIONS = /* @__PURE__ */ Object.create(null);
USER_STANDALONE_CONFIGURATIONS[TASKS_CONFIGURATION_KEY] = `${TASKS_CONFIGURATION_KEY}.json`;
const IWorkbenchConfigurationService = refineServiceDecorator(IConfigurationService);
const TASKS_DEFAULT = '{\n	"version": "2.0.0",\n	"tasks": []\n}';
const APPLY_ALL_PROFILES_SETTING = "workbench.settings.applyToAllProfiles";
class ConfigurationEditingError extends ErrorNoTelemetry {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}
let ConfigurationEditing = class ConfigurationEditing2 {
  constructor(remoteSettingsResource, configurationService, contextService, userDataProfileService, userDataProfilesService, fileService, textModelResolverService, textFileService, notificationService, preferencesService, editorService, uriIdentityService) {
    this.remoteSettingsResource = remoteSettingsResource;
    this.configurationService = configurationService;
    this.contextService = contextService;
    this.userDataProfileService = userDataProfileService;
    this.userDataProfilesService = userDataProfilesService;
    this.fileService = fileService;
    this.textModelResolverService = textModelResolverService;
    this.textFileService = textFileService;
    this.notificationService = notificationService;
    this.preferencesService = preferencesService;
    this.editorService = editorService;
    this.uriIdentityService = uriIdentityService;
    this.queue = new Queue();
  }
  async writeConfiguration(target, value, options = {}) {
    const operation = this.getConfigurationEditOperation(target, value, options.scopes || {});
    return this.queue.queue(async () => {
      try {
        await this.doWriteConfiguration(operation, options);
      } catch (error) {
        if (options.donotNotifyError) {
          throw error;
        }
        await this.onError(error, operation, options.scopes);
      }
    });
  }
  async doWriteConfiguration(operation, options) {
    await this.validate(operation.target, operation, !options.handleDirtyFile, options.scopes || {});
    const resource = operation.resource;
    const reference2 = await this.resolveModelReference(resource);
    try {
      const formattingOptions = this.getFormattingOptions(reference2.object.textEditorModel);
      await this.updateConfiguration(operation, reference2.object.textEditorModel, formattingOptions, options);
    } finally {
      reference2.dispose();
    }
  }
  async updateConfiguration(operation, model, formattingOptions, options) {
    if (this.hasParseErrors(model.getValue(), operation)) {
      throw this.toConfigurationEditingError(11, operation.target, operation);
    }
    if (this.textFileService.isDirty(model.uri) && options.handleDirtyFile) {
      switch (options.handleDirtyFile) {
        case "save":
          await this.save(model, operation);
          break;
        case "revert":
          await this.textFileService.revert(model.uri);
          break;
      }
    }
    const edit = this.getEdits(operation, model.getValue(), formattingOptions)[0];
    if (edit && this.applyEditsToBuffer(edit, model)) {
      await this.save(model, operation);
    }
  }
  async save(model, operation) {
    try {
      await this.textFileService.save(model.uri, { ignoreErrorHandler: true });
    } catch (error) {
      if (error.fileOperationResult === 3) {
        throw this.toConfigurationEditingError(10, operation.target, operation);
      }
      throw new ConfigurationEditingError(localize("fsError", "Error while writing to {0}. {1}", this.stringifyTarget(operation.target), error.message), 13);
    }
  }
  applyEditsToBuffer(edit, model) {
    const startPosition = model.getPositionAt(edit.offset);
    const endPosition = model.getPositionAt(edit.offset + edit.length);
    const range = new Range$1(
      startPosition.lineNumber,
      startPosition.column,
      endPosition.lineNumber,
      endPosition.column
    );
    const currentText = model.getValueInRange(range);
    if (edit.content !== currentText) {
      const editOperation = currentText ? EditOperation.replace(range, edit.content) : EditOperation.insert(startPosition, edit.content);
      model.pushEditOperations([new Selection(
        startPosition.lineNumber,
        startPosition.column,
        startPosition.lineNumber,
        startPosition.column
      )], [editOperation], () => []);
      return true;
    }
    return false;
  }
  getEdits({ value, jsonPath }, modelContent, formattingOptions) {
    if (jsonPath.length) {
      return setProperty(modelContent, jsonPath, value, formattingOptions);
    }
    const content = JSON.stringify(value, null, formattingOptions.insertSpaces && formattingOptions.tabSize ? " ".repeat(formattingOptions.tabSize) : "	");
    return [{
      content,
      length: modelContent.length,
      offset: 0
    }];
  }
  getFormattingOptions(model) {
    const { insertSpaces, tabSize } = model.getOptions();
    const eol = model.getEOL();
    return { insertSpaces, tabSize, eol };
  }
  async onError(error, operation, scopes) {
    switch (error.code) {
      case 11:
        this.onInvalidConfigurationError(error, operation);
        break;
      case 9:
        this.onConfigurationFileDirtyError(error, operation, scopes);
        break;
      case 10:
        return this.doWriteConfiguration(operation, { scopes, handleDirtyFile: "revert" });
      default:
        this.notificationService.error(error.message);
    }
  }
  onInvalidConfigurationError(error, operation) {
    const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY ? localize("openTasksConfiguration", "Open Tasks Configuration") : operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY ? localize("openLaunchConfiguration", "Open Launch Configuration") : null;
    if (openStandAloneConfigurationActionLabel) {
      this.notificationService.prompt(Severity$1.Error, error.message, [{
        label: openStandAloneConfigurationActionLabel,
        run: () => this.openFile(operation.resource)
      }]);
    } else {
      this.notificationService.prompt(Severity$1.Error, error.message, [{
        label: localize("open", "Open Settings"),
        run: () => this.openSettings(operation)
      }]);
    }
  }
  onConfigurationFileDirtyError(error, operation, scopes) {
    const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY ? localize("openTasksConfiguration", "Open Tasks Configuration") : operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY ? localize("openLaunchConfiguration", "Open Launch Configuration") : null;
    if (openStandAloneConfigurationActionLabel) {
      this.notificationService.prompt(Severity$1.Error, error.message, [
        {
          label: localize("saveAndRetry", "Save and Retry"),
          run: () => {
            const key = operation.key ? `${operation.workspaceStandAloneConfigurationKey}.${operation.key}` : operation.workspaceStandAloneConfigurationKey;
            this.writeConfiguration(operation.target, { key, value: operation.value }, { handleDirtyFile: "save", scopes });
          }
        },
        {
          label: openStandAloneConfigurationActionLabel,
          run: () => this.openFile(operation.resource)
        }
      ]);
    } else {
      this.notificationService.prompt(Severity$1.Error, error.message, [
        {
          label: localize("saveAndRetry", "Save and Retry"),
          run: () => this.writeConfiguration(operation.target, { key: operation.key, value: operation.value }, { handleDirtyFile: "save", scopes })
        },
        {
          label: localize("open", "Open Settings"),
          run: () => this.openSettings(operation)
        }
      ]);
    }
  }
  openSettings(operation) {
    const options = { jsonEditor: true };
    switch (operation.target) {
      case 1:
        this.preferencesService.openUserSettings(options);
        break;
      case 2:
        this.preferencesService.openRemoteSettings(options);
        break;
      case 3:
        this.preferencesService.openWorkspaceSettings(options);
        break;
      case 4:
        if (operation.resource) {
          const workspaceFolder2 = this.contextService.getWorkspaceFolder(operation.resource);
          if (workspaceFolder2) {
            this.preferencesService.openFolderSettings({ folderUri: workspaceFolder2.uri, jsonEditor: true });
          }
        }
        break;
    }
  }
  openFile(resource) {
    this.editorService.openEditor({ resource, options: { pinned: true } });
  }
  toConfigurationEditingError(code, target, operation) {
    const message = this.toErrorMessage(code, target, operation);
    return new ConfigurationEditingError(message, code);
  }
  toErrorMessage(error, target, operation) {
    switch (error) {
      case 12:
        return localize(
          "errorPolicyConfiguration",
          "Unable to write {0} because it is configured in system policy.",
          operation.key
        );
      case 0:
        return localize(
          "errorUnknownKey",
          "Unable to write to {0} because {1} is not a registered configuration.",
          this.stringifyTarget(target),
          operation.key
        );
      case 1:
        return localize(
          "errorInvalidWorkspaceConfigurationApplication",
          "Unable to write {0} to Workspace Settings. This setting can be written only into User settings.",
          operation.key
        );
      case 2:
        return localize(
          "errorInvalidWorkspaceConfigurationMachine",
          "Unable to write {0} to Workspace Settings. This setting can be written only into User settings.",
          operation.key
        );
      case 3:
        return localize(
          "errorInvalidFolderConfiguration",
          "Unable to write to Folder Settings because {0} does not support the folder resource scope.",
          operation.key
        );
      case 4:
        return localize(
          "errorInvalidUserTarget",
          "Unable to write to User Settings because {0} does not support for global scope.",
          operation.key
        );
      case 5:
        return localize(
          "errorInvalidWorkspaceTarget",
          "Unable to write to Workspace Settings because {0} does not support for workspace scope in a multi folder workspace.",
          operation.key
        );
      case 6:
        return localize(
          "errorInvalidFolderTarget",
          "Unable to write to Folder Settings because no resource is provided."
        );
      case 7:
        return localize(
          "errorInvalidResourceLanguageConfiguration",
          "Unable to write to Language Settings because {0} is not a resource language setting.",
          operation.key
        );
      case 8:
        return localize(
          "errorNoWorkspaceOpened",
          "Unable to write to {0} because no workspace is opened. Please open a workspace first and try again.",
          this.stringifyTarget(target)
        );
      case 11: {
        if (operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY) {
          return localize(
            "errorInvalidTaskConfiguration",
            "Unable to write into the tasks configuration file. Please open it to correct errors/warnings in it and try again."
          );
        }
        if (operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY) {
          return localize(
            "errorInvalidLaunchConfiguration",
            "Unable to write into the launch configuration file. Please open it to correct errors/warnings in it and try again."
          );
        }
        switch (target) {
          case 1:
            return localize(
              "errorInvalidConfiguration",
              "Unable to write into user settings. Please open the user settings to correct errors/warnings in it and try again."
            );
          case 2:
            return localize(
              "errorInvalidRemoteConfiguration",
              "Unable to write into remote user settings. Please open the remote user settings to correct errors/warnings in it and try again."
            );
          case 3:
            return localize(
              "errorInvalidConfigurationWorkspace",
              "Unable to write into workspace settings. Please open the workspace settings to correct errors/warnings in the file and try again."
            );
          case 4: {
            let workspaceFolderName = "<<unknown>>";
            if (operation.resource) {
              const folder = this.contextService.getWorkspaceFolder(operation.resource);
              if (folder) {
                workspaceFolderName = folder.name;
              }
            }
            return localize(
              "errorInvalidConfigurationFolder",
              "Unable to write into folder settings. Please open the '{0}' folder settings to correct errors/warnings in it and try again.",
              workspaceFolderName
            );
          }
          default:
            return "";
        }
      }
      case 9: {
        if (operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY) {
          return localize(
            "errorTasksConfigurationFileDirty",
            "Unable to write into tasks configuration file because the file has unsaved changes. Please save it first and then try again."
          );
        }
        if (operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY) {
          return localize(
            "errorLaunchConfigurationFileDirty",
            "Unable to write into launch configuration file because the file has unsaved changes. Please save it first and then try again."
          );
        }
        switch (target) {
          case 1:
            return localize(
              "errorConfigurationFileDirty",
              "Unable to write into user settings because the file has unsaved changes. Please save the user settings file first and then try again."
            );
          case 2:
            return localize(
              "errorRemoteConfigurationFileDirty",
              "Unable to write into remote user settings because the file has unsaved changes. Please save the remote user settings file first and then try again."
            );
          case 3:
            return localize(
              "errorConfigurationFileDirtyWorkspace",
              "Unable to write into workspace settings because the file has unsaved changes. Please save the workspace settings file first and then try again."
            );
          case 4: {
            let workspaceFolderName = "<<unknown>>";
            if (operation.resource) {
              const folder = this.contextService.getWorkspaceFolder(operation.resource);
              if (folder) {
                workspaceFolderName = folder.name;
              }
            }
            return localize(
              "errorConfigurationFileDirtyFolder",
              "Unable to write into folder settings because the file has unsaved changes. Please save the '{0}' folder settings file first and then try again.",
              workspaceFolderName
            );
          }
          default:
            return "";
        }
      }
      case 10:
        if (operation.workspaceStandAloneConfigurationKey === TASKS_CONFIGURATION_KEY) {
          return localize(
            "errorTasksConfigurationFileModifiedSince",
            "Unable to write into tasks configuration file because the content of the file is newer."
          );
        }
        if (operation.workspaceStandAloneConfigurationKey === LAUNCH_CONFIGURATION_KEY) {
          return localize(
            "errorLaunchConfigurationFileModifiedSince",
            "Unable to write into launch configuration file because the content of the file is newer."
          );
        }
        switch (target) {
          case 1:
            return localize(
              "errorConfigurationFileModifiedSince",
              "Unable to write into user settings because the content of the file is newer."
            );
          case 2:
            return localize(
              "errorRemoteConfigurationFileModifiedSince",
              "Unable to write into remote user settings because the content of the file is newer."
            );
          case 3:
            return localize(
              "errorConfigurationFileModifiedSinceWorkspace",
              "Unable to write into workspace settings because the content of the file is newer."
            );
          case 4:
            return localize(
              "errorConfigurationFileModifiedSinceFolder",
              "Unable to write into folder settings because the content of the file is newer."
            );
        }
      case 13:
        return localize(
          "errorUnknown",
          "Unable to write to {0} because of an internal error.",
          this.stringifyTarget(target)
        );
    }
  }
  stringifyTarget(target) {
    switch (target) {
      case 1:
        return localize("userTarget", "User Settings");
      case 2:
        return localize("remoteUserTarget", "Remote User Settings");
      case 3:
        return localize("workspaceTarget", "Workspace Settings");
      case 4:
        return localize("folderTarget", "Folder Settings");
      default:
        return "";
    }
  }
  defaultResourceValue(resource) {
    const basename2 = this.uriIdentityService.extUri.basename(resource);
    const configurationValue = basename2.substr(0, basename2.length - this.uriIdentityService.extUri.extname(resource).length);
    switch (configurationValue) {
      case TASKS_CONFIGURATION_KEY:
        return TASKS_DEFAULT;
      default:
        return "{}";
    }
  }
  async resolveModelReference(resource) {
    const exists = await this.fileService.exists(resource);
    if (!exists) {
      await this.textFileService.write(resource, this.defaultResourceValue(resource), { encoding: "utf8" });
    }
    return this.textModelResolverService.createModelReference(resource);
  }
  hasParseErrors(content, operation) {
    if (operation.workspaceStandAloneConfigurationKey && !operation.key) {
      return false;
    }
    const parseErrors = [];
    parse(content, parseErrors, { allowTrailingComma: true, allowEmptyContent: true });
    return parseErrors.length > 0;
  }
  async validate(target, operation, checkDirty, overrides) {
    var _a3, _b3;
    if (this.configurationService.inspect(operation.key).policyValue !== void 0) {
      throw this.toConfigurationEditingError(12, target, operation);
    }
    const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
    const configurationScope = (_a3 = configurationProperties[operation.key]) == null ? void 0 : _a3.scope;
    if (!operation.workspaceStandAloneConfigurationKey) {
      const validKeys = this.configurationService.keys().default;
      if (validKeys.indexOf(operation.key) < 0 && !OVERRIDE_PROPERTY_REGEX.test(operation.key) && operation.value !== void 0) {
        throw this.toConfigurationEditingError(0, target, operation);
      }
    }
    if (operation.workspaceStandAloneConfigurationKey) {
      if (operation.workspaceStandAloneConfigurationKey !== TASKS_CONFIGURATION_KEY && (target === 1 || target === 2)) {
        throw this.toConfigurationEditingError(4, target, operation);
      }
    }
    if ((target === 3 || target === 4) && this.contextService.getWorkbenchState() === 1) {
      throw this.toConfigurationEditingError(8, target, operation);
    }
    if (target === 3) {
      if (!operation.workspaceStandAloneConfigurationKey && !OVERRIDE_PROPERTY_REGEX.test(operation.key)) {
        if (configurationScope === 1) {
          throw this.toConfigurationEditingError(1, target, operation);
        }
        if (configurationScope === 2) {
          throw this.toConfigurationEditingError(2, target, operation);
        }
      }
    }
    if (target === 4) {
      if (!operation.resource) {
        throw this.toConfigurationEditingError(6, target, operation);
      }
      if (!operation.workspaceStandAloneConfigurationKey && !OVERRIDE_PROPERTY_REGEX.test(operation.key)) {
        if (configurationScope !== void 0 && !FOLDER_SCOPES.includes(configurationScope)) {
          throw this.toConfigurationEditingError(3, target, operation);
        }
      }
    }
    if ((_b3 = overrides.overrideIdentifiers) == null ? void 0 : _b3.length) {
      if (configurationScope !== 5) {
        throw this.toConfigurationEditingError(7, target, operation);
      }
    }
    if (!operation.resource) {
      throw this.toConfigurationEditingError(6, target, operation);
    }
    if (checkDirty && this.textFileService.isDirty(operation.resource)) {
      throw this.toConfigurationEditingError(9, target, operation);
    }
  }
  getConfigurationEditOperation(target, config, overrides) {
    var _a3, _b3;
    if (config.key) {
      const standaloneConfigurationMap = target === 1 ? USER_STANDALONE_CONFIGURATIONS : WORKSPACE_STANDALONE_CONFIGURATIONS;
      const standaloneConfigurationKeys = Object.keys(standaloneConfigurationMap);
      for (const key2 of standaloneConfigurationKeys) {
        const resource2 = this.getConfigurationFileResource(target, key2, standaloneConfigurationMap[key2], overrides.resource, void 0);
        if (config.key === key2) {
          const jsonPath2 = this.isWorkspaceConfigurationResource(resource2) ? [key2] : [];
          return { key: jsonPath2[jsonPath2.length - 1], jsonPath: jsonPath2, value: config.value, resource: withNullAsUndefined(resource2), workspaceStandAloneConfigurationKey: key2, target };
        }
        const keyPrefix = `${key2}.`;
        if (config.key.indexOf(keyPrefix) === 0) {
          const jsonPath2 = this.isWorkspaceConfigurationResource(resource2) ? [key2, config.key.substr(keyPrefix.length)] : [config.key.substr(keyPrefix.length)];
          return { key: jsonPath2[jsonPath2.length - 1], jsonPath: jsonPath2, value: config.value, resource: withNullAsUndefined(resource2), workspaceStandAloneConfigurationKey: key2, target };
        }
      }
    }
    const key = config.key;
    const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
    const configurationScope = (_a3 = configurationProperties[key]) == null ? void 0 : _a3.scope;
    let jsonPath = ((_b3 = overrides.overrideIdentifiers) == null ? void 0 : _b3.length) ? [keyFromOverrideIdentifiers(overrides.overrideIdentifiers), key] : [key];
    if (target === 1 || target === 2) {
      return { key, jsonPath, value: config.value, resource: withNullAsUndefined(this.getConfigurationFileResource(target, key, "", null, configurationScope)), target };
    }
    const resource = this.getConfigurationFileResource(target, key, FOLDER_SETTINGS_PATH, overrides.resource, configurationScope);
    if (this.isWorkspaceConfigurationResource(resource)) {
      jsonPath = ["settings", ...jsonPath];
    }
    return { key, jsonPath, value: config.value, resource: withNullAsUndefined(resource), target };
  }
  isWorkspaceConfigurationResource(resource) {
    const workspace = this.contextService.getWorkspace();
    return !!(workspace.configuration && resource && workspace.configuration.fsPath === resource.fsPath);
  }
  getConfigurationFileResource(target, key, relativePath2, resource, scope) {
    if (target === 1) {
      if (key === TASKS_CONFIGURATION_KEY) {
        return this.userDataProfileService.currentProfile.tasksResource;
      } else {
        if (!this.userDataProfileService.currentProfile.isDefault && this.configurationService.isSettingAppliedForAllProfiles(key)) {
          return this.userDataProfilesService.defaultProfile.settingsResource;
        }
        return this.userDataProfileService.currentProfile.settingsResource;
      }
    }
    if (target === 2) {
      return this.remoteSettingsResource;
    }
    const workbenchState = this.contextService.getWorkbenchState();
    if (workbenchState !== 1) {
      const workspace = this.contextService.getWorkspace();
      if (target === 3) {
        if (workbenchState === 3) {
          return withUndefinedAsNull(workspace.configuration);
        }
        if (workbenchState === 2) {
          return workspace.folders[0].toResource(relativePath2);
        }
      }
      if (target === 4) {
        if (resource) {
          const folder = this.contextService.getWorkspaceFolder(resource);
          if (folder) {
            return folder.toResource(relativePath2);
          }
        }
      }
    }
    return null;
  }
};
ConfigurationEditing = __decorate$U([
  __param$U(1, IWorkbenchConfigurationService),
  __param$U(2, IWorkspaceContextService),
  __param$U(3, IUserDataProfileService),
  __param$U(4, IUserDataProfilesService),
  __param$U(5, IFileService),
  __param$U(6, ITextModelService),
  __param$U(7, ITextFileService),
  __param$U(8, INotificationService),
  __param$U(9, IPreferencesService),
  __param$U(10, IEditorService),
  __param$U(11, IUriIdentityService)
], ConfigurationEditing);
const _DefaultConfiguration = class _DefaultConfiguration extends DefaultConfiguration$1 {
  constructor(configurationCache, environmentService) {
    var _a3;
    super();
    this.configurationCache = configurationCache;
    this.configurationRegistry = Registry.as(Extensions.Configuration);
    this.cachedConfigurationDefaultsOverrides = {};
    this.cacheKey = { type: "defaults", key: "configurationDefaultsOverrides" };
    this.updateCache = false;
    if ((_a3 = environmentService.options) == null ? void 0 : _a3.configurationDefaults) {
      this.configurationRegistry.registerDefaultConfigurations([{ overrides: environmentService.options.configurationDefaults }]);
    }
  }
  getConfigurationDefaultOverrides() {
    return this.cachedConfigurationDefaultsOverrides;
  }
  async initialize() {
    await this.initializeCachedConfigurationDefaultsOverrides();
    return super.initialize();
  }
  reload() {
    this.updateCache = true;
    this.cachedConfigurationDefaultsOverrides = {};
    this.updateCachedConfigurationDefaultsOverrides();
    return super.reload();
  }
  hasCachedConfigurationDefaultsOverrides() {
    return !isEmptyObject(this.cachedConfigurationDefaultsOverrides);
  }
  initializeCachedConfigurationDefaultsOverrides() {
    if (!this.initiaizeCachedConfigurationDefaultsOverridesPromise) {
      this.initiaizeCachedConfigurationDefaultsOverridesPromise = (async () => {
        try {
          if (window.localStorage.getItem(_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY)) {
            const content = await this.configurationCache.read(this.cacheKey);
            if (content) {
              this.cachedConfigurationDefaultsOverrides = JSON.parse(content);
            }
          }
        } catch (error) {
        }
        this.cachedConfigurationDefaultsOverrides = isObject(this.cachedConfigurationDefaultsOverrides) ? this.cachedConfigurationDefaultsOverrides : {};
      })();
    }
    return this.initiaizeCachedConfigurationDefaultsOverridesPromise;
  }
  onDidUpdateConfiguration(properties, defaultsOverrides) {
    super.onDidUpdateConfiguration(properties, defaultsOverrides);
    if (defaultsOverrides) {
      this.updateCachedConfigurationDefaultsOverrides();
    }
  }
  async updateCachedConfigurationDefaultsOverrides() {
    if (!this.updateCache) {
      return;
    }
    const cachedConfigurationDefaultsOverrides = {};
    const configurationDefaultsOverrides = this.configurationRegistry.getConfigurationDefaultsOverrides();
    for (const [key, value] of configurationDefaultsOverrides) {
      if (!OVERRIDE_PROPERTY_REGEX.test(key) && value.value !== void 0) {
        cachedConfigurationDefaultsOverrides[key] = value.value;
      }
    }
    try {
      if (Object.keys(cachedConfigurationDefaultsOverrides).length) {
        window.localStorage.setItem(_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY, "yes");
        await this.configurationCache.write(this.cacheKey, JSON.stringify(cachedConfigurationDefaultsOverrides));
      } else {
        window.localStorage.removeItem(_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY);
        await this.configurationCache.remove(this.cacheKey);
      }
    } catch (error) {
    }
  }
};
_DefaultConfiguration.DEFAULT_OVERRIDES_CACHE_EXISTS_KEY = "DefaultOverridesCacheExists";
let DefaultConfiguration = _DefaultConfiguration;
class ApplicationConfiguration extends UserSettings {
  constructor(userDataProfilesService, fileService, uriIdentityService) {
    super(userDataProfilesService.defaultProfile.settingsResource, { scopes: [1] }, uriIdentityService.extUri, fileService);
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._register(this.onDidChange(() => this.reloadConfigurationScheduler.schedule()));
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(
      () => this.loadConfiguration().then((configurationModel) => this._onDidChangeConfiguration.fire(configurationModel)),
      50
    ));
  }
  async initialize() {
    return this.loadConfiguration();
  }
  async loadConfiguration() {
    const model = await super.loadConfiguration();
    const value = model.getValue(APPLY_ALL_PROFILES_SETTING);
    const allProfilesSettings = Array.isArray(value) ? value : [];
    return this.parseOptions.include || allProfilesSettings.length ? this.reparse({ ...this.parseOptions, include: allProfilesSettings }) : model;
  }
}
class UserConfiguration extends Disposable {
  get hasTasksLoaded() {
    return this.userConfiguration.value instanceof FileServiceBasedConfiguration;
  }
  constructor(settingsResource, tasksResource, configurationParseOptions, fileService, uriIdentityService, logService) {
    super();
    this.settingsResource = settingsResource;
    this.tasksResource = tasksResource;
    this.configurationParseOptions = configurationParseOptions;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this.userConfiguration = this._register(new MutableDisposable());
    this.userConfigurationChangeDisposable = this._register(new MutableDisposable());
    this.userConfiguration.value = new UserSettings(
      settingsResource,
      this.configurationParseOptions,
      uriIdentityService.extUri,
      this.fileService
    );
    this.userConfigurationChangeDisposable.value = this.userConfiguration.value.onDidChange(() => this.reloadConfigurationScheduler.schedule());
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(
      () => this.userConfiguration.value.loadConfiguration().then((configurationModel) => this._onDidChangeConfiguration.fire(configurationModel)),
      50
    ));
  }
  async reset(settingsResource, tasksResource, configurationParseOptions) {
    this.settingsResource = settingsResource;
    this.tasksResource = tasksResource;
    this.configurationParseOptions = configurationParseOptions;
    const folder = this.uriIdentityService.extUri.dirname(this.settingsResource);
    const standAloneConfigurationResources = this.tasksResource ? [[TASKS_CONFIGURATION_KEY, this.tasksResource]] : [];
    const fileServiceBasedConfiguration = new FileServiceBasedConfiguration(
      folder.toString(),
      this.settingsResource,
      standAloneConfigurationResources,
      this.configurationParseOptions,
      this.fileService,
      this.uriIdentityService,
      this.logService
    );
    const configurationModel = await fileServiceBasedConfiguration.loadConfiguration();
    this.userConfiguration.value = fileServiceBasedConfiguration;
    if (this.userConfigurationChangeDisposable.value) {
      this.userConfigurationChangeDisposable.value = this.userConfiguration.value.onDidChange(() => this.reloadConfigurationScheduler.schedule());
    }
    return configurationModel;
  }
  async initialize() {
    return this.userConfiguration.value.loadConfiguration();
  }
  async reload() {
    if (this.hasTasksLoaded) {
      return this.userConfiguration.value.loadConfiguration();
    }
    return this.reset(this.settingsResource, this.tasksResource, this.configurationParseOptions);
  }
  reparse(parseOptions) {
    this.configurationParseOptions = { ...this.configurationParseOptions, ...parseOptions };
    return this.userConfiguration.value.reparse(this.configurationParseOptions);
  }
  getRestrictedSettings() {
    return this.userConfiguration.value.getRestrictedSettings();
  }
}
class FileServiceBasedConfiguration extends Disposable {
  constructor(name, settingsResource, standAloneConfigurationResources, configurationParseOptions, fileService, uriIdentityService, logService) {
    super();
    this.settingsResource = settingsResource;
    this.standAloneConfigurationResources = standAloneConfigurationResources;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.allResources = [this.settingsResource, ...this.standAloneConfigurationResources.map(([, resource]) => resource)];
    this._register(combinedDisposable(...this.allResources.map(
      (resource) => combinedDisposable(
        this.fileService.watch(uriIdentityService.extUri.dirname(resource)),
        this.fileService.watch(resource)
      )
    )));
    this._folderSettingsModelParser = new ConfigurationModelParser(name);
    this._folderSettingsParseOptions = configurationParseOptions;
    this._standAloneConfigurations = [];
    this._cache = new ConfigurationModel();
    this._register(Event.debounce(Event.any(Event.filter(this.fileService.onDidFilesChange, (e) => this.handleFileChangesEvent(e)), Event.filter(this.fileService.onDidRunOperation, (e) => this.handleFileOperationEvent(e))), () => void 0, 100)(() => this._onDidChange.fire()));
  }
  async resolveContents() {
    const resolveContents = async (resources) => {
      return Promise.all(resources.map(async (resource) => {
        try {
          const content = (await this.fileService.readFile(resource)).value.toString();
          return content;
        } catch (error) {
          this.logService.trace(`Error while resolving configuration file '${resource.toString()}': ${getErrorMessage(error)}`);
          if (error.fileOperationResult !== 1 && error.fileOperationResult !== 9) {
            this.logService.error(error);
          }
        }
        return "{}";
      }));
    };
    const [[settingsContent], standAloneConfigurationContents] = await Promise.all([
      resolveContents([this.settingsResource]),
      resolveContents(this.standAloneConfigurationResources.map(([, resource]) => resource))
    ]);
    return [settingsContent, standAloneConfigurationContents.map(
      (content, index2) => [this.standAloneConfigurationResources[index2][0], content]
    )];
  }
  async loadConfiguration() {
    const [settingsContent, standAloneConfigurationContents] = await this.resolveContents();
    this._standAloneConfigurations = [];
    this._folderSettingsModelParser.parse("", this._folderSettingsParseOptions);
    if (settingsContent !== void 0) {
      this._folderSettingsModelParser.parse(settingsContent, this._folderSettingsParseOptions);
    }
    for (let index2 = 0; index2 < standAloneConfigurationContents.length; index2++) {
      const contents = standAloneConfigurationContents[index2][1];
      if (contents !== void 0) {
        const standAloneConfigurationModelParser = new StandaloneConfigurationModelParser(
          this.standAloneConfigurationResources[index2][1].toString(),
          this.standAloneConfigurationResources[index2][0]
        );
        standAloneConfigurationModelParser.parse(contents);
        this._standAloneConfigurations.push(standAloneConfigurationModelParser.configurationModel);
      }
    }
    this.consolidate();
    return this._cache;
  }
  getRestrictedSettings() {
    return this._folderSettingsModelParser.restrictedConfigurations;
  }
  reparse(configurationParseOptions) {
    const oldContents = this._folderSettingsModelParser.configurationModel.contents;
    this._folderSettingsParseOptions = configurationParseOptions;
    this._folderSettingsModelParser.reparse(this._folderSettingsParseOptions);
    if (!equals$2(oldContents, this._folderSettingsModelParser.configurationModel.contents)) {
      this.consolidate();
    }
    return this._cache;
  }
  consolidate() {
    this._cache = this._folderSettingsModelParser.configurationModel.merge(...this._standAloneConfigurations);
  }
  handleFileChangesEvent(event) {
    if (this.allResources.some((resource) => event.contains(resource))) {
      return true;
    }
    if (this.allResources.some(
      (resource) => event.contains(this.uriIdentityService.extUri.dirname(resource), 2)
    )) {
      return true;
    }
    return false;
  }
  handleFileOperationEvent(event) {
    if ((event.isOperation(0) || event.isOperation(3) || event.isOperation(1) || event.isOperation(4)) && this.allResources.some(
      (resource) => this.uriIdentityService.extUri.isEqual(event.resource, resource)
    )) {
      return true;
    }
    if (event.isOperation(1) && this.allResources.some(
      (resource) => this.uriIdentityService.extUri.isEqual(event.resource, this.uriIdentityService.extUri.dirname(resource))
    )) {
      return true;
    }
    return false;
  }
}
class RemoteUserConfiguration extends Disposable {
  constructor(remoteAuthority, configurationCache, fileService, uriIdentityService, remoteAgentService) {
    super();
    this._userConfigurationInitializationPromise = null;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._onDidInitialize = this._register(new Emitter());
    this.onDidInitialize = this._onDidInitialize.event;
    this._fileService = fileService;
    this._userConfiguration = this._cachedConfiguration = new CachedRemoteUserConfiguration(remoteAuthority, configurationCache, { scopes: REMOTE_MACHINE_SCOPES });
    remoteAgentService.getEnvironment().then(async (environment) => {
      if (environment) {
        const userConfiguration = this._register(new FileServiceBasedRemoteUserConfiguration(
          environment.settingsPath,
          { scopes: REMOTE_MACHINE_SCOPES },
          this._fileService,
          uriIdentityService
        ));
        this._register(userConfiguration.onDidChangeConfiguration((configurationModel2) => this.onDidUserConfigurationChange(configurationModel2)));
        this._userConfigurationInitializationPromise = userConfiguration.initialize();
        const configurationModel = await this._userConfigurationInitializationPromise;
        this._userConfiguration.dispose();
        this._userConfiguration = userConfiguration;
        this.onDidUserConfigurationChange(configurationModel);
        this._onDidInitialize.fire(configurationModel);
      }
    });
  }
  async initialize() {
    if (this._userConfiguration instanceof FileServiceBasedRemoteUserConfiguration) {
      return this._userConfiguration.initialize();
    }
    let configurationModel = await this._userConfiguration.initialize();
    if (this._userConfigurationInitializationPromise) {
      configurationModel = await this._userConfigurationInitializationPromise;
      this._userConfigurationInitializationPromise = null;
    }
    return configurationModel;
  }
  reload() {
    return this._userConfiguration.reload();
  }
  reparse() {
    return this._userConfiguration.reparse({ scopes: REMOTE_MACHINE_SCOPES });
  }
  getRestrictedSettings() {
    return this._userConfiguration.getRestrictedSettings();
  }
  onDidUserConfigurationChange(configurationModel) {
    this.updateCache();
    this._onDidChangeConfiguration.fire(configurationModel);
  }
  async updateCache() {
    if (this._userConfiguration instanceof FileServiceBasedRemoteUserConfiguration) {
      let content;
      try {
        content = await this._userConfiguration.resolveContent();
      } catch (error) {
        if (error.fileOperationResult !== 1) {
          return;
        }
      }
      await this._cachedConfiguration.updateConfiguration(content);
    }
  }
}
class FileServiceBasedRemoteUserConfiguration extends Disposable {
  constructor(configurationResource, configurationParseOptions, fileService, uriIdentityService) {
    super();
    this.configurationResource = configurationResource;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this.fileWatcherDisposable = Disposable.None;
    this.directoryWatcherDisposable = Disposable.None;
    this.parser = new ConfigurationModelParser(this.configurationResource.toString());
    this.parseOptions = configurationParseOptions;
    this._register(fileService.onDidFilesChange((e) => this.handleFileChangesEvent(e)));
    this._register(fileService.onDidRunOperation((e) => this.handleFileOperationEvent(e)));
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(
      () => this.reload().then((configurationModel) => this._onDidChangeConfiguration.fire(configurationModel)),
      50
    ));
    this._register(toDisposable(() => {
      this.stopWatchingResource();
      this.stopWatchingDirectory();
    }));
  }
  watchResource() {
    this.fileWatcherDisposable = this.fileService.watch(this.configurationResource);
  }
  stopWatchingResource() {
    this.fileWatcherDisposable.dispose();
    this.fileWatcherDisposable = Disposable.None;
  }
  watchDirectory() {
    const directory = this.uriIdentityService.extUri.dirname(this.configurationResource);
    this.directoryWatcherDisposable = this.fileService.watch(directory);
  }
  stopWatchingDirectory() {
    this.directoryWatcherDisposable.dispose();
    this.directoryWatcherDisposable = Disposable.None;
  }
  async initialize() {
    const exists = await this.fileService.exists(this.configurationResource);
    this.onResourceExists(exists);
    return this.reload();
  }
  async resolveContent() {
    const content = await this.fileService.readFile(this.configurationResource);
    return content.value.toString();
  }
  async reload() {
    try {
      const content = await this.resolveContent();
      this.parser.parse(content, this.parseOptions);
      return this.parser.configurationModel;
    } catch (e) {
      return new ConfigurationModel();
    }
  }
  reparse(configurationParseOptions) {
    this.parseOptions = configurationParseOptions;
    this.parser.reparse(this.parseOptions);
    return this.parser.configurationModel;
  }
  getRestrictedSettings() {
    return this.parser.restrictedConfigurations;
  }
  handleFileChangesEvent(event) {
    let affectedByChanges = event.contains(this.configurationResource, 0);
    if (event.contains(this.configurationResource, 1)) {
      affectedByChanges = true;
      this.onResourceExists(true);
    } else if (event.contains(this.configurationResource, 2)) {
      affectedByChanges = true;
      this.onResourceExists(false);
    }
    if (affectedByChanges) {
      this.reloadConfigurationScheduler.schedule();
    }
  }
  handleFileOperationEvent(event) {
    if ((event.isOperation(0) || event.isOperation(3) || event.isOperation(1) || event.isOperation(4)) && this.uriIdentityService.extUri.isEqual(event.resource, this.configurationResource)) {
      this.reloadConfigurationScheduler.schedule();
    }
  }
  onResourceExists(exists) {
    if (exists) {
      this.stopWatchingDirectory();
      this.watchResource();
    } else {
      this.stopWatchingResource();
      this.watchDirectory();
    }
  }
}
class CachedRemoteUserConfiguration extends Disposable {
  constructor(remoteAuthority, configurationCache, configurationParseOptions) {
    super();
    this.configurationCache = configurationCache;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.key = { type: "user", key: remoteAuthority };
    this.parser = new ConfigurationModelParser("CachedRemoteUserConfiguration");
    this.parseOptions = configurationParseOptions;
    this.configurationModel = new ConfigurationModel();
  }
  getConfigurationModel() {
    return this.configurationModel;
  }
  initialize() {
    return this.reload();
  }
  reparse(configurationParseOptions) {
    this.parseOptions = configurationParseOptions;
    this.parser.reparse(this.parseOptions);
    this.configurationModel = this.parser.configurationModel;
    return this.configurationModel;
  }
  getRestrictedSettings() {
    return this.parser.restrictedConfigurations;
  }
  async reload() {
    try {
      const content = await this.configurationCache.read(this.key);
      const parsed = JSON.parse(content);
      if (parsed.content) {
        this.parser.parse(parsed.content, this.parseOptions);
        this.configurationModel = this.parser.configurationModel;
      }
    } catch (e) {
    }
    return this.configurationModel;
  }
  async updateConfiguration(content) {
    if (content) {
      return this.configurationCache.write(this.key, JSON.stringify({ content }));
    } else {
      return this.configurationCache.remove(this.key);
    }
  }
}
class WorkspaceConfiguration extends Disposable {
  get initialized() {
    return this._initialized;
  }
  constructor(configurationCache, fileService, uriIdentityService, logService) {
    super();
    this.configurationCache = configurationCache;
    this.fileService = fileService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._workspaceConfigurationDisposables = this._register(new DisposableStore());
    this._workspaceIdentifier = null;
    this._isWorkspaceTrusted = false;
    this._onDidUpdateConfiguration = this._register(new Emitter());
    this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
    this._initialized = false;
    this.fileService = fileService;
    this._workspaceConfiguration = this._cachedConfiguration = new CachedWorkspaceConfiguration(configurationCache);
  }
  async initialize(workspaceIdentifier, workspaceTrusted) {
    this._workspaceIdentifier = workspaceIdentifier;
    this._isWorkspaceTrusted = workspaceTrusted;
    if (!this._initialized) {
      if (this.configurationCache.needsCaching(this._workspaceIdentifier.configPath)) {
        this._workspaceConfiguration = this._cachedConfiguration;
        this.waitAndInitialize(this._workspaceIdentifier);
      } else {
        this.doInitialize(new FileServiceBasedWorkspaceConfiguration(this.fileService, this.uriIdentityService, this.logService));
      }
    }
    await this.reload();
  }
  async reload() {
    if (this._workspaceIdentifier) {
      await this._workspaceConfiguration.load(this._workspaceIdentifier, { scopes: WORKSPACE_SCOPES, skipRestricted: this.isUntrusted() });
    }
  }
  getFolders() {
    return this._workspaceConfiguration.getFolders();
  }
  setFolders(folders, jsonEditingService) {
    if (this._workspaceIdentifier) {
      return jsonEditingService.write(this._workspaceIdentifier.configPath, [{ path: ["folders"], value: folders }], true).then(() => this.reload());
    }
    return Promise.resolve();
  }
  isTransient() {
    return this._workspaceConfiguration.isTransient();
  }
  getConfiguration() {
    return this._workspaceConfiguration.getWorkspaceSettings();
  }
  updateWorkspaceTrust(trusted) {
    this._isWorkspaceTrusted = trusted;
    return this.reparseWorkspaceSettings();
  }
  reparseWorkspaceSettings() {
    this._workspaceConfiguration.reparseWorkspaceSettings({ scopes: WORKSPACE_SCOPES, skipRestricted: this.isUntrusted() });
    return this.getConfiguration();
  }
  getRestrictedSettings() {
    return this._workspaceConfiguration.getRestrictedSettings();
  }
  async waitAndInitialize(workspaceIdentifier) {
    await whenProviderRegistered(workspaceIdentifier.configPath, this.fileService);
    if (!(this._workspaceConfiguration instanceof FileServiceBasedWorkspaceConfiguration)) {
      const fileServiceBasedWorkspaceConfiguration = this._register(new FileServiceBasedWorkspaceConfiguration(this.fileService, this.uriIdentityService, this.logService));
      await fileServiceBasedWorkspaceConfiguration.load(workspaceIdentifier, { scopes: WORKSPACE_SCOPES, skipRestricted: this.isUntrusted() });
      this.doInitialize(fileServiceBasedWorkspaceConfiguration);
      this.onDidWorkspaceConfigurationChange(false, true);
    }
  }
  doInitialize(fileServiceBasedWorkspaceConfiguration) {
    this._workspaceConfigurationDisposables.clear();
    this._workspaceConfiguration = this._workspaceConfigurationDisposables.add(fileServiceBasedWorkspaceConfiguration);
    this._workspaceConfigurationDisposables.add(this._workspaceConfiguration.onDidChange((e) => this.onDidWorkspaceConfigurationChange(true, false)));
    this._initialized = true;
  }
  isUntrusted() {
    return !this._isWorkspaceTrusted;
  }
  async onDidWorkspaceConfigurationChange(reload, fromCache) {
    if (reload) {
      await this.reload();
    }
    this.updateCache();
    this._onDidUpdateConfiguration.fire(fromCache);
  }
  async updateCache() {
    if (this._workspaceIdentifier && this.configurationCache.needsCaching(this._workspaceIdentifier.configPath) && this._workspaceConfiguration instanceof FileServiceBasedWorkspaceConfiguration) {
      const content = await this._workspaceConfiguration.resolveContent(this._workspaceIdentifier);
      await this._cachedConfiguration.updateWorkspace(this._workspaceIdentifier, content);
    }
  }
}
class FileServiceBasedWorkspaceConfiguration extends Disposable {
  constructor(fileService, uriIdentityService, logService) {
    super();
    this.fileService = fileService;
    this.logService = logService;
    this._workspaceIdentifier = null;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser("");
    this.workspaceSettings = new ConfigurationModel();
    this._register(Event.any(Event.filter(this.fileService.onDidFilesChange, (e) => !!this._workspaceIdentifier && e.contains(this._workspaceIdentifier.configPath)), Event.filter(this.fileService.onDidRunOperation, (e) => !!this._workspaceIdentifier && (e.isOperation(0) || e.isOperation(3) || e.isOperation(1) || e.isOperation(4)) && uriIdentityService.extUri.isEqual(e.resource, this._workspaceIdentifier.configPath)))(() => this.reloadConfigurationScheduler.schedule()));
    this.reloadConfigurationScheduler = this._register(new RunOnceScheduler(() => this._onDidChange.fire(), 50));
    this.workspaceConfigWatcher = this._register(this.watchWorkspaceConfigurationFile());
  }
  get workspaceIdentifier() {
    return this._workspaceIdentifier;
  }
  async resolveContent(workspaceIdentifier) {
    const content = await this.fileService.readFile(workspaceIdentifier.configPath);
    return content.value.toString();
  }
  async load(workspaceIdentifier, configurationParseOptions) {
    if (!this._workspaceIdentifier || this._workspaceIdentifier.id !== workspaceIdentifier.id) {
      this._workspaceIdentifier = workspaceIdentifier;
      this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser(this._workspaceIdentifier.id);
      dispose(this.workspaceConfigWatcher);
      this.workspaceConfigWatcher = this._register(this.watchWorkspaceConfigurationFile());
    }
    let contents = "";
    try {
      contents = await this.resolveContent(this._workspaceIdentifier);
    } catch (error) {
      const exists = await this.fileService.exists(this._workspaceIdentifier.configPath);
      if (exists) {
        this.logService.error(error);
      }
    }
    this.workspaceConfigurationModelParser.parse(contents, configurationParseOptions);
    this.consolidate();
  }
  getConfigurationModel() {
    return this.workspaceConfigurationModelParser.configurationModel;
  }
  getFolders() {
    return this.workspaceConfigurationModelParser.folders;
  }
  isTransient() {
    return this.workspaceConfigurationModelParser.transient;
  }
  getWorkspaceSettings() {
    return this.workspaceSettings;
  }
  reparseWorkspaceSettings(configurationParseOptions) {
    this.workspaceConfigurationModelParser.reparseWorkspaceSettings(configurationParseOptions);
    this.consolidate();
    return this.getWorkspaceSettings();
  }
  getRestrictedSettings() {
    return this.workspaceConfigurationModelParser.getRestrictedWorkspaceSettings();
  }
  consolidate() {
    this.workspaceSettings = this.workspaceConfigurationModelParser.settingsModel.merge(this.workspaceConfigurationModelParser.launchModel, this.workspaceConfigurationModelParser.tasksModel);
  }
  watchWorkspaceConfigurationFile() {
    return this._workspaceIdentifier ? this.fileService.watch(this._workspaceIdentifier.configPath) : Disposable.None;
  }
}
class CachedWorkspaceConfiguration {
  constructor(configurationCache) {
    this.configurationCache = configurationCache;
    this.onDidChange = Event.None;
    this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser("");
    this.workspaceSettings = new ConfigurationModel();
  }
  async load(workspaceIdentifier, configurationParseOptions) {
    try {
      const key = this.getKey(workspaceIdentifier);
      const contents = await this.configurationCache.read(key);
      const parsed = JSON.parse(contents);
      if (parsed.content) {
        this.workspaceConfigurationModelParser = new WorkspaceConfigurationModelParser(key.key);
        this.workspaceConfigurationModelParser.parse(parsed.content, configurationParseOptions);
        this.consolidate();
      }
    } catch (e) {
    }
  }
  get workspaceIdentifier() {
    return null;
  }
  getConfigurationModel() {
    return this.workspaceConfigurationModelParser.configurationModel;
  }
  getFolders() {
    return this.workspaceConfigurationModelParser.folders;
  }
  isTransient() {
    return this.workspaceConfigurationModelParser.transient;
  }
  getWorkspaceSettings() {
    return this.workspaceSettings;
  }
  reparseWorkspaceSettings(configurationParseOptions) {
    this.workspaceConfigurationModelParser.reparseWorkspaceSettings(configurationParseOptions);
    this.consolidate();
    return this.getWorkspaceSettings();
  }
  getRestrictedSettings() {
    return this.workspaceConfigurationModelParser.getRestrictedWorkspaceSettings();
  }
  consolidate() {
    this.workspaceSettings = this.workspaceConfigurationModelParser.settingsModel.merge(this.workspaceConfigurationModelParser.launchModel, this.workspaceConfigurationModelParser.tasksModel);
  }
  async updateWorkspace(workspaceIdentifier, content) {
    try {
      const key = this.getKey(workspaceIdentifier);
      if (content) {
        await this.configurationCache.write(key, JSON.stringify({ content }));
      } else {
        await this.configurationCache.remove(key);
      }
    } catch (error) {
    }
  }
  getKey(workspaceIdentifier) {
    return {
      type: "workspaces",
      key: workspaceIdentifier.id
    };
  }
}
class CachedFolderConfiguration {
  constructor(folder, configFolderRelativePath, configurationParseOptions, configurationCache) {
    this.configurationCache = configurationCache;
    this.onDidChange = Event.None;
    this.key = { type: "folder", key: hash(joinPath(folder, configFolderRelativePath).toString()).toString(16) };
    this._folderSettingsModelParser = new ConfigurationModelParser("CachedFolderConfiguration");
    this._folderSettingsParseOptions = configurationParseOptions;
    this._standAloneConfigurations = [];
    this.configurationModel = new ConfigurationModel();
  }
  async loadConfiguration() {
    try {
      const contents = await this.configurationCache.read(this.key);
      const { content: configurationContents } = JSON.parse(contents.toString());
      if (configurationContents) {
        for (const key of Object.keys(configurationContents)) {
          if (key === FOLDER_SETTINGS_NAME) {
            this._folderSettingsModelParser.parse(configurationContents[key], this._folderSettingsParseOptions);
          } else {
            const standAloneConfigurationModelParser = new StandaloneConfigurationModelParser(key, key);
            standAloneConfigurationModelParser.parse(configurationContents[key]);
            this._standAloneConfigurations.push(standAloneConfigurationModelParser.configurationModel);
          }
        }
      }
      this.consolidate();
    } catch (e) {
    }
    return this.configurationModel;
  }
  async updateConfiguration(settingsContent, standAloneConfigurationContents) {
    const content = {};
    if (settingsContent) {
      content[FOLDER_SETTINGS_NAME] = settingsContent;
    }
    standAloneConfigurationContents.forEach(([key, contents]) => {
      if (contents) {
        content[key] = contents;
      }
    });
    if (Object.keys(content).length) {
      await this.configurationCache.write(this.key, JSON.stringify({ content }));
    } else {
      await this.configurationCache.remove(this.key);
    }
  }
  getRestrictedSettings() {
    return this._folderSettingsModelParser.restrictedConfigurations;
  }
  reparse(configurationParseOptions) {
    this._folderSettingsParseOptions = configurationParseOptions;
    this._folderSettingsModelParser.reparse(this._folderSettingsParseOptions);
    this.consolidate();
    return this.configurationModel;
  }
  consolidate() {
    this.configurationModel = this._folderSettingsModelParser.configurationModel.merge(...this._standAloneConfigurations);
  }
  getUnsupportedKeys() {
    return [];
  }
}
class FolderConfiguration extends Disposable {
  constructor(useCache, workspaceFolder2, configFolderRelativePath, workbenchState, workspaceTrusted, fileService, uriIdentityService, logService, configurationCache) {
    super();
    this.workspaceFolder = workspaceFolder2;
    this.workbenchState = workbenchState;
    this.workspaceTrusted = workspaceTrusted;
    this.configurationCache = configurationCache;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.scopes = 3 === this.workbenchState ? FOLDER_SCOPES : WORKSPACE_SCOPES;
    this.configurationFolder = uriIdentityService.extUri.joinPath(workspaceFolder2.uri, configFolderRelativePath);
    this.cachedFolderConfiguration = new CachedFolderConfiguration(
      workspaceFolder2.uri,
      configFolderRelativePath,
      { scopes: this.scopes, skipRestricted: this.isUntrusted() },
      configurationCache
    );
    if (useCache && this.configurationCache.needsCaching(workspaceFolder2.uri)) {
      this.folderConfiguration = this.cachedFolderConfiguration;
      whenProviderRegistered(workspaceFolder2.uri, fileService).then(() => {
        this.folderConfiguration = this._register(this.createFileServiceBasedConfiguration(fileService, uriIdentityService, logService));
        this._register(this.folderConfiguration.onDidChange((e) => this.onDidFolderConfigurationChange()));
        this.onDidFolderConfigurationChange();
      });
    } else {
      this.folderConfiguration = this._register(this.createFileServiceBasedConfiguration(fileService, uriIdentityService, logService));
      this._register(this.folderConfiguration.onDidChange((e) => this.onDidFolderConfigurationChange()));
    }
  }
  loadConfiguration() {
    return this.folderConfiguration.loadConfiguration();
  }
  updateWorkspaceTrust(trusted) {
    this.workspaceTrusted = trusted;
    return this.reparse();
  }
  reparse() {
    const configurationModel = this.folderConfiguration.reparse({ scopes: this.scopes, skipRestricted: this.isUntrusted() });
    this.updateCache();
    return configurationModel;
  }
  getRestrictedSettings() {
    return this.folderConfiguration.getRestrictedSettings();
  }
  isUntrusted() {
    return !this.workspaceTrusted;
  }
  onDidFolderConfigurationChange() {
    this.updateCache();
    this._onDidChange.fire();
  }
  createFileServiceBasedConfiguration(fileService, uriIdentityService, logService) {
    const settingsResource = uriIdentityService.extUri.joinPath(this.configurationFolder, `${FOLDER_SETTINGS_NAME}.json`);
    const standAloneConfigurationResources = [TASKS_CONFIGURATION_KEY, LAUNCH_CONFIGURATION_KEY].map(
      (name) => [name, uriIdentityService.extUri.joinPath(this.configurationFolder, `${name}.json`)]
    );
    return new FileServiceBasedConfiguration(
      this.configurationFolder.toString(),
      settingsResource,
      standAloneConfigurationResources,
      { scopes: this.scopes, skipRestricted: this.isUntrusted() },
      fileService,
      uriIdentityService,
      logService
    );
  }
  async updateCache() {
    if (this.configurationCache.needsCaching(this.configurationFolder) && this.folderConfiguration instanceof FileServiceBasedConfiguration) {
      const [settingsContent, standAloneConfigurationContents] = await this.folderConfiguration.resolveContents();
      this.cachedFolderConfiguration.updateConfiguration(settingsContent, standAloneConfigurationContents);
    }
  }
}
function getLocalUserConfigurationScopes(userDataProfile, hasRemote) {
  return userDataProfile.isDefault ? hasRemote ? LOCAL_MACHINE_SCOPES : void 0 : hasRemote ? LOCAL_MACHINE_PROFILE_SCOPES : PROFILE_SCOPES;
}
class Workspace extends Workspace$1 {
  constructor() {
    super(...arguments);
    this.initialized = false;
  }
}
class WorkspaceService extends Disposable {
  get restrictedSettings() {
    return this._restrictedSettings;
  }
  constructor({ remoteAuthority, configurationCache }, environmentService, userDataProfileService, userDataProfilesService, fileService, remoteAgentService, uriIdentityService, logService, policyService) {
    super();
    this.userDataProfileService = userDataProfileService;
    this.userDataProfilesService = userDataProfilesService;
    this.fileService = fileService;
    this.remoteAgentService = remoteAgentService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this.initialized = false;
    this.applicationConfiguration = null;
    this.remoteUserConfiguration = null;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._onWillChangeWorkspaceFolders = this._register(new Emitter());
    this.onWillChangeWorkspaceFolders = this._onWillChangeWorkspaceFolders.event;
    this._onDidChangeWorkspaceFolders = this._register(new Emitter());
    this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
    this._onDidChangeWorkspaceName = this._register(new Emitter());
    this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;
    this._onDidChangeWorkbenchState = this._register(new Emitter());
    this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;
    this.isWorkspaceTrusted = true;
    this._restrictedSettings = { default: [] };
    this._onDidChangeRestrictedSettings = this._register(new Emitter());
    this.onDidChangeRestrictedSettings = this._onDidChangeRestrictedSettings.event;
    this.configurationRegistry = Registry.as(Extensions.Configuration);
    this.initRemoteUserConfigurationBarrier = new Barrier();
    this.completeWorkspaceBarrier = new Barrier();
    this.defaultConfiguration = this._register(new DefaultConfiguration(configurationCache, environmentService));
    this.policyConfiguration = policyService instanceof NullPolicyService ? new NullPolicyConfiguration() : this._register(new PolicyConfiguration(this.defaultConfiguration, policyService, logService));
    this.configurationCache = configurationCache;
    this._configuration = new Configuration(
      this.defaultConfiguration.configurationModel,
      this.policyConfiguration.configurationModel,
      new ConfigurationModel(),
      new ConfigurationModel(),
      new ConfigurationModel(),
      new ConfigurationModel(),
      new ResourceMap(),
      new ConfigurationModel(),
      new ResourceMap(),
      this.workspace
    );
    this.applicationConfigurationDisposables = this._register(new DisposableStore());
    this.createApplicationConfiguration();
    this.localUserConfiguration = this._register(new UserConfiguration(
      userDataProfileService.currentProfile.settingsResource,
      userDataProfileService.currentProfile.tasksResource,
      { scopes: getLocalUserConfigurationScopes(userDataProfileService.currentProfile, !!remoteAuthority) },
      fileService,
      uriIdentityService,
      logService
    ));
    this.cachedFolderConfigs = new ResourceMap();
    this._register(this.localUserConfiguration.onDidChangeConfiguration((userConfiguration) => this.onLocalUserConfigurationChanged(userConfiguration)));
    if (remoteAuthority) {
      const remoteUserConfiguration = this.remoteUserConfiguration = this._register(new RemoteUserConfiguration(
        remoteAuthority,
        configurationCache,
        fileService,
        uriIdentityService,
        remoteAgentService
      ));
      this._register(remoteUserConfiguration.onDidInitialize((remoteUserConfigurationModel) => {
        this._register(remoteUserConfiguration.onDidChangeConfiguration((remoteUserConfigurationModel2) => this.onRemoteUserConfigurationChanged(remoteUserConfigurationModel2)));
        this.onRemoteUserConfigurationChanged(remoteUserConfigurationModel);
        this.initRemoteUserConfigurationBarrier.open();
      }));
    } else {
      this.initRemoteUserConfigurationBarrier.open();
    }
    this.workspaceConfiguration = this._register(new WorkspaceConfiguration(configurationCache, fileService, uriIdentityService, logService));
    this._register(this.workspaceConfiguration.onDidUpdateConfiguration((fromCache) => {
      this.onWorkspaceConfigurationChanged(fromCache).then(() => {
        this.workspace.initialized = this.workspaceConfiguration.initialized;
        this.checkAndMarkWorkspaceComplete(fromCache);
      });
    }));
    this._register(this.defaultConfiguration.onDidChangeConfiguration(({ properties, defaults }) => this.onDefaultConfigurationChanged(defaults, properties)));
    this._register(this.policyConfiguration.onDidChangeConfiguration((configurationModel) => this.onPolicyConfigurationChanged(configurationModel)));
    this._register(userDataProfileService.onDidChangeCurrentProfile((e) => this.onUserDataProfileChanged(e)));
    this.workspaceEditingQueue = new Queue();
  }
  createApplicationConfiguration() {
    var _a3;
    this.applicationConfigurationDisposables.clear();
    if (this.userDataProfileService.currentProfile.isDefault || ((_a3 = this.userDataProfileService.currentProfile.useDefaultFlags) == null ? void 0 : _a3.settings)) {
      this.applicationConfiguration = null;
    } else {
      this.applicationConfiguration = this.applicationConfigurationDisposables.add(this._register(new ApplicationConfiguration(this.userDataProfilesService, this.fileService, this.uriIdentityService)));
      this.applicationConfigurationDisposables.add(this.applicationConfiguration.onDidChangeConfiguration((configurationModel) => this.onApplicationConfigurationChanged(configurationModel)));
    }
  }
  async getCompleteWorkspace() {
    await this.completeWorkspaceBarrier.wait();
    return this.getWorkspace();
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkbenchState() {
    if (this.workspace.configuration) {
      return 3;
    }
    if (this.workspace.folders.length === 1) {
      return 2;
    }
    return 1;
  }
  getWorkspaceFolder(resource) {
    return this.workspace.getFolder(resource);
  }
  addFolders(foldersToAdd, index2) {
    return this.updateFolders(foldersToAdd, [], index2);
  }
  removeFolders(foldersToRemove) {
    return this.updateFolders([], foldersToRemove);
  }
  async updateFolders(foldersToAdd, foldersToRemove, index2) {
    return this.workspaceEditingQueue.queue(() => this.doUpdateFolders(foldersToAdd, foldersToRemove, index2));
  }
  isInsideWorkspace(resource) {
    return !!this.getWorkspaceFolder(resource);
  }
  isCurrentWorkspace(workspaceIdOrFolder) {
    switch (this.getWorkbenchState()) {
      case 2: {
        let folderUri = void 0;
        if (URI$1.isUri(workspaceIdOrFolder)) {
          folderUri = workspaceIdOrFolder;
        } else if (isSingleFolderWorkspaceIdentifier(workspaceIdOrFolder)) {
          folderUri = workspaceIdOrFolder.uri;
        }
        return URI$1.isUri(folderUri) && this.uriIdentityService.extUri.isEqual(folderUri, this.workspace.folders[0].uri);
      }
      case 3:
        return isWorkspaceIdentifier(workspaceIdOrFolder) && this.workspace.id === workspaceIdOrFolder.id;
    }
    return false;
  }
  async doUpdateFolders(foldersToAdd, foldersToRemove, index2) {
    if (this.getWorkbenchState() !== 3) {
      return Promise.resolve(void 0);
    }
    if (foldersToAdd.length + foldersToRemove.length === 0) {
      return Promise.resolve(void 0);
    }
    let foldersHaveChanged = false;
    let currentWorkspaceFolders = this.getWorkspace().folders;
    let newStoredFolders = currentWorkspaceFolders.map((f) => f.raw).filter((folder, index3) => {
      if (!isStoredWorkspaceFolder(folder)) {
        return true;
      }
      return !this.contains(foldersToRemove, currentWorkspaceFolders[index3].uri);
    });
    foldersHaveChanged = currentWorkspaceFolders.length !== newStoredFolders.length;
    if (foldersToAdd.length) {
      const workspaceConfigPath = this.getWorkspace().configuration;
      const workspaceConfigFolder = this.uriIdentityService.extUri.dirname(workspaceConfigPath);
      currentWorkspaceFolders = toWorkspaceFolders(newStoredFolders, workspaceConfigPath, this.uriIdentityService.extUri);
      const currentWorkspaceFolderUris = currentWorkspaceFolders.map((folder) => folder.uri);
      const storedFoldersToAdd = [];
      for (const folderToAdd of foldersToAdd) {
        const folderURI = folderToAdd.uri;
        if (this.contains(currentWorkspaceFolderUris, folderURI)) {
          continue;
        }
        try {
          const result = await this.fileService.stat(folderURI);
          if (!result.isDirectory) {
            continue;
          }
        } catch (e) {
        }
        storedFoldersToAdd.push(getStoredWorkspaceFolder(folderURI, false, folderToAdd.name, workspaceConfigFolder, this.uriIdentityService.extUri));
      }
      if (storedFoldersToAdd.length > 0) {
        foldersHaveChanged = true;
        if (typeof index2 === "number" && index2 >= 0 && index2 < newStoredFolders.length) {
          newStoredFolders = newStoredFolders.slice(0);
          newStoredFolders.splice(index2, 0, ...storedFoldersToAdd);
        } else {
          newStoredFolders = [...newStoredFolders, ...storedFoldersToAdd];
        }
      }
    }
    if (foldersHaveChanged) {
      return this.setFolders(newStoredFolders);
    }
    return Promise.resolve(void 0);
  }
  async setFolders(folders) {
    if (!this.instantiationService) {
      throw new Error("Cannot update workspace folders because workspace service is not yet ready to accept writes.");
    }
    await this.instantiationService.invokeFunction((accessor) => this.workspaceConfiguration.setFolders(folders, accessor.get(IJSONEditingService)));
    return this.onWorkspaceConfigurationChanged(false);
  }
  contains(resources, toCheck) {
    return resources.some((resource) => this.uriIdentityService.extUri.isEqual(resource, toCheck));
  }
  getConfigurationData() {
    return this._configuration.toData();
  }
  getValue(arg1, arg2) {
    const section = typeof arg1 === "string" ? arg1 : void 0;
    const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : void 0;
    return this._configuration.getValue(section, overrides);
  }
  async updateValue(key, value, arg3, arg4, options) {
    const overrides = isConfigurationUpdateOverrides(arg3) ? arg3 : isConfigurationOverrides(arg3) ? { resource: arg3.resource, overrideIdentifiers: arg3.overrideIdentifier ? [arg3.overrideIdentifier] : void 0 } : void 0;
    const target = overrides ? arg4 : arg3;
    const targets = target ? [target] : [];
    if (overrides == null ? void 0 : overrides.overrideIdentifiers) {
      overrides.overrideIdentifiers = distinct$1(overrides.overrideIdentifiers);
      overrides.overrideIdentifiers = overrides.overrideIdentifiers.length ? overrides.overrideIdentifiers : void 0;
    }
    if (!targets.length) {
      if ((overrides == null ? void 0 : overrides.overrideIdentifiers) && overrides.overrideIdentifiers.length > 1) {
        throw new Error("Configuration Target is required while updating the value for multiple override identifiers");
      }
      const inspect = this.inspect(key, { resource: overrides == null ? void 0 : overrides.resource, overrideIdentifier: (overrides == null ? void 0 : overrides.overrideIdentifiers) ? overrides.overrideIdentifiers[0] : void 0 });
      targets.push(...this.deriveConfigurationTargets(key, value, inspect));
      if (equals$2(value, inspect.defaultValue) && targets.length === 1 && (targets[0] === 2 || targets[0] === 3)) {
        value = void 0;
      }
    }
    await Promises.settled(targets.map(
      (target2) => this.writeConfigurationValue(key, value, target2, overrides, options)
    ));
  }
  async reloadConfiguration(target) {
    if (target === void 0) {
      this.reloadDefaultConfiguration();
      const application = await this.reloadApplicationConfiguration(true);
      const { local, remote } = await this.reloadUserConfiguration();
      await this.reloadWorkspaceConfiguration();
      await this.loadConfiguration(application, local, remote, true);
      return;
    }
    if (isWorkspaceFolder(target)) {
      await this.reloadWorkspaceFolderConfiguration(target);
      return;
    }
    switch (target) {
      case 7:
        this.reloadDefaultConfiguration();
        return;
      case 2: {
        const { local, remote } = await this.reloadUserConfiguration();
        await this.loadConfiguration(this._configuration.applicationConfiguration, local, remote, true);
        return;
      }
      case 3:
        await this.reloadLocalUserConfiguration();
        return;
      case 4:
        await this.reloadRemoteUserConfiguration();
        return;
      case 5:
      case 6:
        await this.reloadWorkspaceConfiguration();
        return;
    }
  }
  hasCachedConfigurationDefaultsOverrides() {
    return this.defaultConfiguration.hasCachedConfigurationDefaultsOverrides();
  }
  inspect(key, overrides) {
    return this._configuration.inspect(key, overrides);
  }
  keys() {
    return this._configuration.keys();
  }
  async whenRemoteConfigurationLoaded() {
    await this.initRemoteUserConfigurationBarrier.wait();
  }
  async initialize(arg) {
    mark("code/willInitWorkspaceService");
    const trigger = this.initialized;
    this.initialized = false;
    const workspace = await this.createWorkspace(arg);
    await this.updateWorkspaceAndInitializeConfiguration(workspace, trigger);
    this.checkAndMarkWorkspaceComplete(false);
    mark("code/didInitWorkspaceService");
  }
  updateWorkspaceTrust(trusted) {
    var _a3;
    if (this.isWorkspaceTrusted !== trusted) {
      this.isWorkspaceTrusted = trusted;
      const data = this._configuration.toData();
      const folderConfigurationModels = [];
      for (const folder of this.workspace.folders) {
        const folderConfiguration = this.cachedFolderConfigs.get(folder.uri);
        let configurationModel;
        if (folderConfiguration) {
          configurationModel = folderConfiguration.updateWorkspaceTrust(this.isWorkspaceTrusted);
          this._configuration.updateFolderConfiguration(folder.uri, configurationModel);
        }
        folderConfigurationModels.push(configurationModel);
      }
      if (this.getWorkbenchState() === 2) {
        if (folderConfigurationModels[0]) {
          this._configuration.updateWorkspaceConfiguration(folderConfigurationModels[0]);
        }
      } else {
        this._configuration.updateWorkspaceConfiguration(this.workspaceConfiguration.updateWorkspaceTrust(this.isWorkspaceTrusted));
      }
      this.updateRestrictedSettings();
      let keys = [];
      if (this.restrictedSettings.userLocal) {
        keys.push(...this.restrictedSettings.userLocal);
      }
      if (this.restrictedSettings.userRemote) {
        keys.push(...this.restrictedSettings.userRemote);
      }
      if (this.restrictedSettings.workspace) {
        keys.push(...this.restrictedSettings.workspace);
      }
      (_a3 = this.restrictedSettings.workspaceFolder) == null ? void 0 : _a3.forEach((value) => keys.push(...value));
      keys = distinct$1(keys);
      if (keys.length) {
        this.triggerConfigurationChange({ keys, overrides: [] }, { data, workspace: this.workspace }, 5);
      }
    }
  }
  acquireInstantiationService(instantiationService) {
    this.instantiationService = instantiationService;
  }
  isSettingAppliedForAllProfiles(key) {
    var _a3;
    if (((_a3 = this.configurationRegistry.getConfigurationProperties()[key]) == null ? void 0 : _a3.scope) === 1) {
      return true;
    }
    const allProfilesSettings = this.getValue(APPLY_ALL_PROFILES_SETTING) ?? [];
    return Array.isArray(allProfilesSettings) && allProfilesSettings.includes(key);
  }
  async createWorkspace(arg) {
    if (isWorkspaceIdentifier(arg)) {
      return this.createMultiFolderWorkspace(arg);
    }
    if (isSingleFolderWorkspaceIdentifier(arg)) {
      return this.createSingleFolderWorkspace(arg);
    }
    return this.createEmptyWorkspace(arg);
  }
  async createMultiFolderWorkspace(workspaceIdentifier) {
    await this.workspaceConfiguration.initialize({ id: workspaceIdentifier.id, configPath: workspaceIdentifier.configPath }, this.isWorkspaceTrusted);
    const workspaceConfigPath = workspaceIdentifier.configPath;
    const workspaceFolders = toWorkspaceFolders(this.workspaceConfiguration.getFolders(), workspaceConfigPath, this.uriIdentityService.extUri);
    const workspaceId = workspaceIdentifier.id;
    const workspace = new Workspace(
      workspaceId,
      workspaceFolders,
      this.workspaceConfiguration.isTransient(),
      workspaceConfigPath,
      (uri) => this.uriIdentityService.extUri.ignorePathCasing(uri)
    );
    workspace.initialized = this.workspaceConfiguration.initialized;
    return workspace;
  }
  createSingleFolderWorkspace(singleFolderWorkspaceIdentifier) {
    const workspace = new Workspace(
      singleFolderWorkspaceIdentifier.id,
      [toWorkspaceFolder(singleFolderWorkspaceIdentifier.uri)],
      false,
      null,
      (uri) => this.uriIdentityService.extUri.ignorePathCasing(uri)
    );
    workspace.initialized = true;
    return workspace;
  }
  createEmptyWorkspace(emptyWorkspaceIdentifier) {
    const workspace = new Workspace(
      emptyWorkspaceIdentifier.id,
      [],
      false,
      null,
      (uri) => this.uriIdentityService.extUri.ignorePathCasing(uri)
    );
    workspace.initialized = true;
    return Promise.resolve(workspace);
  }
  checkAndMarkWorkspaceComplete(fromCache) {
    if (!this.completeWorkspaceBarrier.isOpen() && this.workspace.initialized) {
      this.completeWorkspaceBarrier.open();
      this.validateWorkspaceFoldersAndReload(fromCache);
    }
  }
  async updateWorkspaceAndInitializeConfiguration(workspace, trigger) {
    const hasWorkspaceBefore = !!this.workspace;
    let previousState;
    let previousWorkspacePath;
    let previousFolders = [];
    if (hasWorkspaceBefore) {
      previousState = this.getWorkbenchState();
      previousWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : void 0;
      previousFolders = this.workspace.folders;
      this.workspace.update(workspace);
    } else {
      this.workspace = workspace;
    }
    await this.initializeConfiguration(trigger);
    if (hasWorkspaceBefore) {
      const newState = this.getWorkbenchState();
      if (previousState && newState !== previousState) {
        this._onDidChangeWorkbenchState.fire(newState);
      }
      const newWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : void 0;
      if (previousWorkspacePath && newWorkspacePath !== previousWorkspacePath || newState !== previousState) {
        this._onDidChangeWorkspaceName.fire();
      }
      const folderChanges = this.compareFolders(previousFolders, this.workspace.folders);
      if (folderChanges && (folderChanges.added.length || folderChanges.removed.length || folderChanges.changed.length)) {
        await this.handleWillChangeWorkspaceFolders(folderChanges, false);
        this._onDidChangeWorkspaceFolders.fire(folderChanges);
      }
    }
    if (!this.localUserConfiguration.hasTasksLoaded) {
      this._register(runWhenIdle(() => this.reloadLocalUserConfiguration()));
    }
  }
  compareFolders(currentFolders, newFolders) {
    const result = { added: [], removed: [], changed: [] };
    result.added = newFolders.filter((newFolder) => !currentFolders.some(
      (currentFolder) => newFolder.uri.toString() === currentFolder.uri.toString()
    ));
    for (let currentIndex = 0; currentIndex < currentFolders.length; currentIndex++) {
      const currentFolder = currentFolders[currentIndex];
      let newIndex = 0;
      for (newIndex = 0; newIndex < newFolders.length && currentFolder.uri.toString() !== newFolders[newIndex].uri.toString(); newIndex++) {
      }
      if (newIndex < newFolders.length) {
        if (currentIndex !== newIndex || currentFolder.name !== newFolders[newIndex].name) {
          result.changed.push(currentFolder);
        }
      } else {
        result.removed.push(currentFolder);
      }
    }
    return result;
  }
  async initializeConfiguration(trigger) {
    await this.defaultConfiguration.initialize();
    const initPolicyConfigurationPromise = this.policyConfiguration.initialize();
    const initApplicationConfigurationPromise = this.applicationConfiguration ? this.applicationConfiguration.initialize() : Promise.resolve(new ConfigurationModel());
    const initUserConfiguration = async () => {
      mark("code/willInitUserConfiguration");
      const result = await Promise.all([this.localUserConfiguration.initialize(), this.remoteUserConfiguration ? this.remoteUserConfiguration.initialize() : Promise.resolve(new ConfigurationModel())]);
      if (this.applicationConfiguration) {
        const applicationConfigurationModel = await initApplicationConfigurationPromise;
        result[0] = this.localUserConfiguration.reparse({ exclude: applicationConfigurationModel.getValue(APPLY_ALL_PROFILES_SETTING) });
      }
      mark("code/didInitUserConfiguration");
      return result;
    };
    const [, application, [local, remote]] = await Promise.all([
      initPolicyConfigurationPromise,
      initApplicationConfigurationPromise,
      initUserConfiguration()
    ]);
    mark("code/willInitWorkspaceConfiguration");
    await this.loadConfiguration(application, local, remote, trigger);
    mark("code/didInitWorkspaceConfiguration");
  }
  reloadDefaultConfiguration() {
    this.onDefaultConfigurationChanged(this.defaultConfiguration.reload());
  }
  async reloadApplicationConfiguration(donotTrigger) {
    if (!this.applicationConfiguration) {
      return new ConfigurationModel();
    }
    const model = await this.applicationConfiguration.loadConfiguration();
    if (!donotTrigger) {
      this.onApplicationConfigurationChanged(model);
    }
    return model;
  }
  async reloadUserConfiguration() {
    const [local, remote] = await Promise.all([this.reloadLocalUserConfiguration(true), this.reloadRemoteUserConfiguration(true)]);
    return { local, remote };
  }
  async reloadLocalUserConfiguration(donotTrigger) {
    const model = await this.localUserConfiguration.reload();
    if (!donotTrigger) {
      this.onLocalUserConfigurationChanged(model);
    }
    return model;
  }
  async reloadRemoteUserConfiguration(donotTrigger) {
    if (this.remoteUserConfiguration) {
      const model = await this.remoteUserConfiguration.reload();
      if (!donotTrigger) {
        this.onRemoteUserConfigurationChanged(model);
      }
      return model;
    }
    return new ConfigurationModel();
  }
  async reloadWorkspaceConfiguration() {
    const workbenchState = this.getWorkbenchState();
    if (workbenchState === 2) {
      return this.onWorkspaceFolderConfigurationChanged(this.workspace.folders[0]);
    }
    if (workbenchState === 3) {
      return this.workspaceConfiguration.reload().then(() => this.onWorkspaceConfigurationChanged(false));
    }
  }
  reloadWorkspaceFolderConfiguration(folder) {
    return this.onWorkspaceFolderConfigurationChanged(folder);
  }
  async loadConfiguration(applicationConfigurationModel, userConfigurationModel, remoteUserConfigurationModel, trigger) {
    this.cachedFolderConfigs = new ResourceMap();
    const folders = this.workspace.folders;
    const folderConfigurations = await this.loadFolderConfigurations(folders);
    const workspaceConfiguration = this.getWorkspaceConfigurationModel(folderConfigurations);
    const folderConfigurationModels = new ResourceMap();
    folderConfigurations.forEach((folderConfiguration, index2) => folderConfigurationModels.set(folders[index2].uri, folderConfiguration));
    const currentConfiguration = this._configuration;
    this._configuration = new Configuration(
      this.defaultConfiguration.configurationModel,
      this.policyConfiguration.configurationModel,
      applicationConfigurationModel,
      userConfigurationModel,
      remoteUserConfigurationModel,
      workspaceConfiguration,
      folderConfigurationModels,
      new ConfigurationModel(),
      new ResourceMap(),
      this.workspace
    );
    this.initialized = true;
    if (trigger) {
      const change = this._configuration.compare(currentConfiguration);
      this.triggerConfigurationChange(change, { data: currentConfiguration.toData(), workspace: this.workspace }, 5);
    }
    this.updateRestrictedSettings();
  }
  getWorkspaceConfigurationModel(folderConfigurations) {
    switch (this.getWorkbenchState()) {
      case 2:
        return folderConfigurations[0];
      case 3:
        return this.workspaceConfiguration.getConfiguration();
      default:
        return new ConfigurationModel();
    }
  }
  onUserDataProfileChanged(e) {
    e.join((async () => {
      var _a3, _b3;
      const promises = [];
      promises.push(this.localUserConfiguration.reset(e.profile.settingsResource, e.profile.tasksResource, { scopes: getLocalUserConfigurationScopes(e.profile, !!this.remoteUserConfiguration) }));
      if (e.previous.isDefault !== e.profile.isDefault || !!((_a3 = e.previous.useDefaultFlags) == null ? void 0 : _a3.settings) !== !!((_b3 = e.profile.useDefaultFlags) == null ? void 0 : _b3.settings)) {
        this.createApplicationConfiguration();
        if (this.applicationConfiguration) {
          promises.push(this.reloadApplicationConfiguration(true));
        }
      }
      let [localUser, application] = await Promise.all(promises);
      application = application ?? this._configuration.applicationConfiguration;
      if (this.applicationConfiguration) {
        localUser = this.localUserConfiguration.reparse({ exclude: application.getValue(APPLY_ALL_PROFILES_SETTING) });
      }
      await this.loadConfiguration(application, localUser, this._configuration.remoteUserConfiguration, true);
    })());
  }
  onDefaultConfigurationChanged(configurationModel, properties) {
    if (this.workspace) {
      const previousData = this._configuration.toData();
      const change = this._configuration.compareAndUpdateDefaultConfiguration(configurationModel, properties);
      if (this.applicationConfiguration) {
        this._configuration.updateApplicationConfiguration(this.applicationConfiguration.reparse());
      }
      if (this.remoteUserConfiguration) {
        this._configuration.updateLocalUserConfiguration(this.localUserConfiguration.reparse());
        this._configuration.updateRemoteUserConfiguration(this.remoteUserConfiguration.reparse());
      }
      if (this.getWorkbenchState() === 2) {
        const folderConfiguration = this.cachedFolderConfigs.get(this.workspace.folders[0].uri);
        if (folderConfiguration) {
          this._configuration.updateWorkspaceConfiguration(folderConfiguration.reparse());
          this._configuration.updateFolderConfiguration(this.workspace.folders[0].uri, folderConfiguration.reparse());
        }
      } else {
        this._configuration.updateWorkspaceConfiguration(this.workspaceConfiguration.reparseWorkspaceSettings());
        for (const folder of this.workspace.folders) {
          const folderConfiguration = this.cachedFolderConfigs.get(folder.uri);
          if (folderConfiguration) {
            this._configuration.updateFolderConfiguration(folder.uri, folderConfiguration.reparse());
          }
        }
      }
      this.triggerConfigurationChange(change, { data: previousData, workspace: this.workspace }, 7);
      this.updateRestrictedSettings();
    }
  }
  onPolicyConfigurationChanged(policyConfiguration) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdatePolicyConfiguration(policyConfiguration);
    this.triggerConfigurationChange(change, previous, 7);
  }
  onApplicationConfigurationChanged(applicationConfiguration) {
    var _a3;
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const previousAllProfilesSettings = this._configuration.applicationConfiguration.getValue(APPLY_ALL_PROFILES_SETTING) ?? [];
    const change = this._configuration.compareAndUpdateApplicationConfiguration(applicationConfiguration);
    const currentAllProfilesSettings = this.getValue(APPLY_ALL_PROFILES_SETTING) ?? [];
    const configurationProperties = this.configurationRegistry.getConfigurationProperties();
    const changedKeys = [];
    for (const changedKey of change.keys) {
      if (((_a3 = configurationProperties[changedKey]) == null ? void 0 : _a3.scope) === 1) {
        changedKeys.push(changedKey);
        if (changedKey === APPLY_ALL_PROFILES_SETTING) {
          for (const previousAllProfileSetting of previousAllProfilesSettings) {
            if (!currentAllProfilesSettings.includes(previousAllProfileSetting)) {
              changedKeys.push(previousAllProfileSetting);
            }
          }
          for (const currentAllProfileSetting of currentAllProfilesSettings) {
            if (!previousAllProfilesSettings.includes(currentAllProfileSetting)) {
              changedKeys.push(currentAllProfileSetting);
            }
          }
        }
      } else if (currentAllProfilesSettings.includes(changedKey)) {
        changedKeys.push(changedKey);
      }
    }
    change.keys = changedKeys;
    if (change.keys.includes(APPLY_ALL_PROFILES_SETTING)) {
      this._configuration.updateLocalUserConfiguration(this.localUserConfiguration.reparse({ exclude: currentAllProfilesSettings }));
    }
    this.triggerConfigurationChange(change, previous, 2);
  }
  onLocalUserConfigurationChanged(userConfiguration) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdateLocalUserConfiguration(userConfiguration);
    this.triggerConfigurationChange(change, previous, 2);
  }
  onRemoteUserConfigurationChanged(userConfiguration) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdateRemoteUserConfiguration(userConfiguration);
    this.triggerConfigurationChange(change, previous, 2);
  }
  async onWorkspaceConfigurationChanged(fromCache) {
    if (this.workspace && this.workspace.configuration) {
      let newFolders = toWorkspaceFolders(this.workspaceConfiguration.getFolders(), this.workspace.configuration, this.uriIdentityService.extUri);
      if (this.workspace.initialized) {
        const { added, removed, changed } = this.compareFolders(this.workspace.folders, newFolders);
        if (added.length || removed.length || changed.length) {
          newFolders = await this.toValidWorkspaceFolders(newFolders);
        } else {
          newFolders = this.workspace.folders;
        }
      }
      await this.updateWorkspaceConfiguration(newFolders, this.workspaceConfiguration.getConfiguration(), fromCache);
    }
  }
  updateRestrictedSettings() {
    var _a3, _b3, _c3;
    const changed = [];
    const allProperties = this.configurationRegistry.getConfigurationProperties();
    const defaultRestrictedSettings = Object.keys(allProperties).filter((key) => allProperties[key].restricted).sort((a, b) => a.localeCompare(b));
    const defaultDelta = delta(defaultRestrictedSettings, this._restrictedSettings.default, (a, b) => a.localeCompare(b));
    changed.push(...defaultDelta.added, ...defaultDelta.removed);
    const application = (((_a3 = this.applicationConfiguration) == null ? void 0 : _a3.getRestrictedSettings()) || []).sort((a, b) => a.localeCompare(b));
    const applicationDelta = delta(application, this._restrictedSettings.application || [], (a, b) => a.localeCompare(b));
    changed.push(...applicationDelta.added, ...applicationDelta.removed);
    const userLocal = this.localUserConfiguration.getRestrictedSettings().sort((a, b) => a.localeCompare(b));
    const userLocalDelta = delta(userLocal, this._restrictedSettings.userLocal || [], (a, b) => a.localeCompare(b));
    changed.push(...userLocalDelta.added, ...userLocalDelta.removed);
    const userRemote = (((_b3 = this.remoteUserConfiguration) == null ? void 0 : _b3.getRestrictedSettings()) || []).sort((a, b) => a.localeCompare(b));
    const userRemoteDelta = delta(userRemote, this._restrictedSettings.userRemote || [], (a, b) => a.localeCompare(b));
    changed.push(...userRemoteDelta.added, ...userRemoteDelta.removed);
    const workspaceFolderMap = new ResourceMap();
    for (const workspaceFolder2 of this.workspace.folders) {
      const cachedFolderConfig = this.cachedFolderConfigs.get(workspaceFolder2.uri);
      const folderRestrictedSettings = ((cachedFolderConfig == null ? void 0 : cachedFolderConfig.getRestrictedSettings()) || []).sort((a, b) => a.localeCompare(b));
      if (folderRestrictedSettings.length) {
        workspaceFolderMap.set(workspaceFolder2.uri, folderRestrictedSettings);
      }
      const previous = ((_c3 = this._restrictedSettings.workspaceFolder) == null ? void 0 : _c3.get(workspaceFolder2.uri)) || [];
      const workspaceFolderDelta = delta(folderRestrictedSettings, previous, (a, b) => a.localeCompare(b));
      changed.push(...workspaceFolderDelta.added, ...workspaceFolderDelta.removed);
    }
    const workspace = this.getWorkbenchState() === 3 ? this.workspaceConfiguration.getRestrictedSettings().sort((a, b) => a.localeCompare(b)) : this.workspace.folders[0] ? workspaceFolderMap.get(this.workspace.folders[0].uri) || [] : [];
    const workspaceDelta = delta(workspace, this._restrictedSettings.workspace || [], (a, b) => a.localeCompare(b));
    changed.push(...workspaceDelta.added, ...workspaceDelta.removed);
    if (changed.length) {
      this._restrictedSettings = {
        default: defaultRestrictedSettings,
        application: application.length ? application : void 0,
        userLocal: userLocal.length ? userLocal : void 0,
        userRemote: userRemote.length ? userRemote : void 0,
        workspace: workspace.length ? workspace : void 0,
        workspaceFolder: workspaceFolderMap.size ? workspaceFolderMap : void 0
      };
      this._onDidChangeRestrictedSettings.fire(this.restrictedSettings);
    }
  }
  async updateWorkspaceConfiguration(workspaceFolders, configuration2, fromCache) {
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const change = this._configuration.compareAndUpdateWorkspaceConfiguration(configuration2);
    const changes = this.compareFolders(this.workspace.folders, workspaceFolders);
    if (changes.added.length || changes.removed.length || changes.changed.length) {
      this.workspace.folders = workspaceFolders;
      const change2 = await this.onFoldersChanged();
      await this.handleWillChangeWorkspaceFolders(changes, fromCache);
      this.triggerConfigurationChange(change2, previous, 6);
      this._onDidChangeWorkspaceFolders.fire(changes);
    } else {
      this.triggerConfigurationChange(change, previous, 5);
    }
    this.updateRestrictedSettings();
  }
  async handleWillChangeWorkspaceFolders(changes, fromCache) {
    const joiners = [];
    this._onWillChangeWorkspaceFolders.fire({
      join(updateWorkspaceTrustStatePromise) {
        joiners.push(updateWorkspaceTrustStatePromise);
      },
      changes,
      fromCache
    });
    try {
      await Promises.settled(joiners);
    } catch (error) {
    }
  }
  async onWorkspaceFolderConfigurationChanged(folder) {
    const [folderConfiguration] = await this.loadFolderConfigurations([folder]);
    const previous = { data: this._configuration.toData(), workspace: this.workspace };
    const folderConfigurationChange = this._configuration.compareAndUpdateFolderConfiguration(folder.uri, folderConfiguration);
    if (this.getWorkbenchState() === 2) {
      const workspaceConfigurationChange = this._configuration.compareAndUpdateWorkspaceConfiguration(folderConfiguration);
      this.triggerConfigurationChange(mergeChanges(folderConfigurationChange, workspaceConfigurationChange), previous, 5);
    } else {
      this.triggerConfigurationChange(folderConfigurationChange, previous, 6);
    }
    this.updateRestrictedSettings();
  }
  async onFoldersChanged() {
    const changes = [];
    for (const key of this.cachedFolderConfigs.keys()) {
      if (!this.workspace.folders.filter((folder) => folder.uri.toString() === key.toString())[0]) {
        const folderConfiguration = this.cachedFolderConfigs.get(key);
        folderConfiguration.dispose();
        this.cachedFolderConfigs.delete(key);
        changes.push(this._configuration.compareAndDeleteFolderConfiguration(key));
      }
    }
    const toInitialize = this.workspace.folders.filter((folder) => !this.cachedFolderConfigs.has(folder.uri));
    if (toInitialize.length) {
      const folderConfigurations = await this.loadFolderConfigurations(toInitialize);
      folderConfigurations.forEach((folderConfiguration, index2) => {
        changes.push(this._configuration.compareAndUpdateFolderConfiguration(toInitialize[index2].uri, folderConfiguration));
      });
    }
    return mergeChanges(...changes);
  }
  loadFolderConfigurations(folders) {
    return Promise.all([...folders.map((folder) => {
      let folderConfiguration = this.cachedFolderConfigs.get(folder.uri);
      if (!folderConfiguration) {
        folderConfiguration = new FolderConfiguration(
          !this.initialized,
          folder,
          FOLDER_CONFIG_FOLDER_NAME,
          this.getWorkbenchState(),
          this.isWorkspaceTrusted,
          this.fileService,
          this.uriIdentityService,
          this.logService,
          this.configurationCache
        );
        this._register(folderConfiguration.onDidChange(() => this.onWorkspaceFolderConfigurationChanged(folder)));
        this.cachedFolderConfigs.set(folder.uri, this._register(folderConfiguration));
      }
      return folderConfiguration.loadConfiguration();
    })]);
  }
  async validateWorkspaceFoldersAndReload(fromCache) {
    const validWorkspaceFolders = await this.toValidWorkspaceFolders(this.workspace.folders);
    const { removed } = this.compareFolders(this.workspace.folders, validWorkspaceFolders);
    if (removed.length) {
      await this.updateWorkspaceConfiguration(validWorkspaceFolders, this.workspaceConfiguration.getConfiguration(), fromCache);
    }
  }
  async toValidWorkspaceFolders(workspaceFolders) {
    const validWorkspaceFolders = [];
    for (const workspaceFolder2 of workspaceFolders) {
      try {
        const result = await this.fileService.stat(workspaceFolder2.uri);
        if (!result.isDirectory) {
          continue;
        }
      } catch (e) {
        this.logService.warn(`Ignoring the error while validating workspace folder ${workspaceFolder2.uri.toString()} - ${toErrorMessage(e)}`);
      }
      validWorkspaceFolders.push(workspaceFolder2);
    }
    return validWorkspaceFolders;
  }
  async writeConfigurationValue(key, value, target, overrides, options) {
    var _a3, _b3, _c3;
    if (!this.instantiationService) {
      throw new Error("Cannot write configuration because the configuration service is not yet ready to accept writes.");
    }
    if (target === 7) {
      throw new Error("Invalid configuration target");
    }
    if (target === 8) {
      const previous = { data: this._configuration.toData(), workspace: this.workspace };
      this._configuration.updateValue(key, value, overrides);
      this.triggerConfigurationChange({ keys: ((_a3 = overrides == null ? void 0 : overrides.overrideIdentifiers) == null ? void 0 : _a3.length) ? [keyFromOverrideIdentifiers(overrides.overrideIdentifiers), key] : [key], overrides: ((_b3 = overrides == null ? void 0 : overrides.overrideIdentifiers) == null ? void 0 : _b3.length) ? overrides.overrideIdentifiers.map((overrideIdentifier) => [overrideIdentifier, [key]]) : [] }, previous, target);
      return;
    }
    const editableConfigurationTarget = this.toEditableConfigurationTarget(target, key);
    if (!editableConfigurationTarget) {
      throw new Error("Invalid configuration target");
    }
    if (editableConfigurationTarget === 2 && !this.remoteUserConfiguration) {
      throw new Error("Invalid configuration target");
    }
    this.configurationEditing = this.configurationEditing ?? this.instantiationService.createInstance(ConfigurationEditing, ((_c3 = await this.remoteAgentService.getEnvironment()) == null ? void 0 : _c3.settingsPath) ?? null);
    await this.configurationEditing.writeConfiguration(editableConfigurationTarget, { key, value }, { scopes: overrides, ...options });
    switch (editableConfigurationTarget) {
      case 1:
        if (this.applicationConfiguration && this.isSettingAppliedForAllProfiles(key)) {
          await this.reloadApplicationConfiguration();
        } else {
          await this.reloadLocalUserConfiguration();
        }
        return;
      case 2:
        return this.reloadRemoteUserConfiguration().then(() => void 0);
      case 3:
        return this.reloadWorkspaceConfiguration();
      case 4: {
        const workspaceFolder2 = overrides && overrides.resource ? this.workspace.getFolder(overrides.resource) : null;
        if (workspaceFolder2) {
          return this.reloadWorkspaceFolderConfiguration(workspaceFolder2);
        }
      }
    }
  }
  deriveConfigurationTargets(key, value, inspect) {
    if (equals$2(value, inspect.value)) {
      return [];
    }
    const definedTargets = [];
    if (inspect.workspaceFolderValue !== void 0) {
      definedTargets.push(6);
    }
    if (inspect.workspaceValue !== void 0) {
      definedTargets.push(5);
    }
    if (inspect.userRemoteValue !== void 0) {
      definedTargets.push(4);
    }
    if (inspect.userLocalValue !== void 0) {
      definedTargets.push(3);
    }
    if (value === void 0) {
      return definedTargets;
    }
    return [definedTargets[0] || 2];
  }
  triggerConfigurationChange(change, previous, target) {
    if (change.keys.length) {
      if (target !== 7) {
        this.logService.debug(`Configuration keys changed in ${ConfigurationTargetToString(target)} target`, ...change.keys);
      }
      const configurationChangeEvent = new ConfigurationChangeEvent(change, previous, this._configuration, this.workspace);
      configurationChangeEvent.source = target;
      configurationChangeEvent.sourceConfig = this.getTargetConfiguration(target);
      this._onDidChangeConfiguration.fire(configurationChangeEvent);
    }
  }
  getTargetConfiguration(target) {
    switch (target) {
      case 7:
        return this._configuration.defaults.contents;
      case 2:
        return this._configuration.userConfiguration.contents;
      case 5:
        return this._configuration.workspaceConfiguration.contents;
    }
    return {};
  }
  toEditableConfigurationTarget(target, key) {
    var _a3;
    if (target === 2) {
      if (this.remoteUserConfiguration) {
        const scope = (_a3 = this.configurationRegistry.getConfigurationProperties()[key]) == null ? void 0 : _a3.scope;
        if (scope === 2 || scope === 6) {
          return 2;
        }
        if (this.inspect(key).userRemoteValue !== void 0) {
          return 2;
        }
      }
      return 1;
    }
    if (target === 3) {
      return 1;
    }
    if (target === 4) {
      return 2;
    }
    if (target === 5) {
      return 3;
    }
    if (target === 6) {
      return 4;
    }
    return null;
  }
}
let RegisterConfigurationSchemasContribution = class RegisterConfigurationSchemasContribution2 extends Disposable {
  constructor(workspaceContextService, environmentService, workspaceTrustManagementService, extensionService, lifecycleService) {
    super();
    this.workspaceContextService = workspaceContextService;
    this.environmentService = environmentService;
    this.workspaceTrustManagementService = workspaceTrustManagementService;
    extensionService.whenInstalledExtensionsRegistered().then(() => {
      this.registerConfigurationSchemas();
      const configurationRegistry2 = Registry.as(Extensions.Configuration);
      const delayer = this._register(new Delayer(50));
      this._register(Event.any(configurationRegistry2.onDidUpdateConfiguration, configurationRegistry2.onDidSchemaChange, workspaceTrustManagementService.onDidChangeTrust)(() => delayer.trigger(() => this.registerConfigurationSchemas(), lifecycleService.phase === 4 ? void 0 : 2500)));
    });
  }
  registerConfigurationSchemas() {
    const allSettingsSchema = {
      properties: allSettings.properties,
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const userSettingsSchema = this.environmentService.remoteAuthority ? {
      properties: Object.assign({}, applicationSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    } : allSettingsSchema;
    const profileSettingsSchema = {
      properties: Object.assign({}, machineSettings.properties, machineOverridableSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const machineSettingsSchema = {
      properties: Object.assign({}, machineSettings.properties, machineOverridableSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const workspaceSettingsSchema = {
      properties: Object.assign({}, this.checkAndFilterPropertiesRequiringTrust(machineOverridableSettings.properties), this.checkAndFilterPropertiesRequiringTrust(windowSettings.properties), this.checkAndFilterPropertiesRequiringTrust(resourceSettings.properties)),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const defaultSettingsSchema = {
      properties: Object.keys(allSettings.properties).reduce((result, key) => {
        result[key] = Object.assign({ deprecationMessage: void 0 }, allSettings.properties[key]);
        return result;
      }, {}),
      patternProperties: Object.keys(allSettings.patternProperties).reduce((result, key) => {
        result[key] = Object.assign({ deprecationMessage: void 0 }, allSettings.patternProperties[key]);
        return result;
      }, {}),
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    };
    const folderSettingsSchema = 3 === this.workspaceContextService.getWorkbenchState() ? {
      properties: Object.assign({}, this.checkAndFilterPropertiesRequiringTrust(machineOverridableSettings.properties), this.checkAndFilterPropertiesRequiringTrust(resourceSettings.properties)),
      patternProperties: allSettings.patternProperties,
      additionalProperties: true,
      allowTrailingCommas: true,
      allowComments: true
    } : workspaceSettingsSchema;
    const configDefaultsSchema = {
      type: "object",
      description: localize(
        "configurationDefaults.description",
        "Contribute defaults for configurations"
      ),
      properties: Object.assign({}, machineOverridableSettings.properties, windowSettings.properties, resourceSettings.properties),
      patternProperties: {
        [OVERRIDE_PROPERTY_PATTERN]: {
          type: "object",
          default: {},
          $ref: resourceLanguageSettingsSchemaId
        }
      },
      additionalProperties: false
    };
    this.registerSchemas({
      defaultSettingsSchema,
      userSettingsSchema,
      profileSettingsSchema,
      machineSettingsSchema,
      workspaceSettingsSchema,
      folderSettingsSchema,
      configDefaultsSchema
    });
  }
  registerSchemas(schemas) {
    const jsonRegistry2 = Registry.as(Extensions$2.JSONContribution);
    jsonRegistry2.registerSchema(defaultSettingsSchemaId, schemas.defaultSettingsSchema);
    jsonRegistry2.registerSchema(userSettingsSchemaId, schemas.userSettingsSchema);
    jsonRegistry2.registerSchema(profileSettingsSchemaId, schemas.profileSettingsSchema);
    jsonRegistry2.registerSchema(machineSettingsSchemaId, schemas.machineSettingsSchema);
    jsonRegistry2.registerSchema(workspaceSettingsSchemaId, schemas.workspaceSettingsSchema);
    jsonRegistry2.registerSchema(folderSettingsSchemaId, schemas.folderSettingsSchema);
    jsonRegistry2.registerSchema(configurationDefaultsSchemaId, schemas.configDefaultsSchema);
  }
  checkAndFilterPropertiesRequiringTrust(properties) {
    if (this.workspaceTrustManagementService.isWorkspaceTrusted()) {
      return properties;
    }
    const result = {};
    Object.entries(properties).forEach(([key, value]) => {
      if (!value.restricted) {
        result[key] = value;
      }
    });
    return result;
  }
};
RegisterConfigurationSchemasContribution = __decorate$U([
  __param$U(0, IWorkspaceContextService),
  __param$U(1, IWorkbenchEnvironmentService),
  __param$U(2, IWorkspaceTrustManagementService),
  __param$U(3, IExtensionService),
  __param$U(4, ILifecycleService)
], RegisterConfigurationSchemasContribution);
let UpdateExperimentalSettingsDefaults = class UpdateExperimentalSettingsDefaults2 extends Disposable {
  constructor(workbenchAssignmentService) {
    super();
    this.workbenchAssignmentService = workbenchAssignmentService;
    this.processedExperimentalSettings = /* @__PURE__ */ new Set();
    this.configurationRegistry = Registry.as(Extensions.Configuration);
    this.processExperimentalSettings(Object.keys(this.configurationRegistry.getConfigurationProperties()));
    this._register(this.configurationRegistry.onDidUpdateConfiguration(({ properties }) => this.processExperimentalSettings(properties)));
  }
  async processExperimentalSettings(properties) {
    var _a3;
    const overrides = {};
    const allProperties = this.configurationRegistry.getConfigurationProperties();
    for (const property of properties) {
      const schema = allProperties[property];
      if (!((_a3 = schema == null ? void 0 : schema.tags) == null ? void 0 : _a3.includes("experimental"))) {
        continue;
      }
      if (this.processedExperimentalSettings.has(property)) {
        continue;
      }
      this.processedExperimentalSettings.add(property);
      try {
        const value = await this.workbenchAssignmentService.getTreatment(`config.${property}`);
        if (!isUndefined(value) && !equals$2(value, schema.default)) {
          overrides[property] = value;
        }
      } catch (error) {
      }
    }
    if (Object.keys(overrides).length) {
      this.configurationRegistry.registerDefaultConfigurations([{ overrides, source: localize("experimental", "Experiments") }]);
    }
  }
};
UpdateExperimentalSettingsDefaults = __decorate$U([
  __param$U(0, IWorkbenchAssignmentService)
], UpdateExperimentalSettingsDefaults);
const workbenchContributionsRegistry = Registry.as(Extensions$1.Workbench);
workbenchContributionsRegistry.registerWorkbenchContribution(RegisterConfigurationSchemasContribution, 3);
workbenchContributionsRegistry.registerWorkbenchContribution(UpdateExperimentalSettingsDefaults, 3);
const configurationRegistry$2 = Registry.as(Extensions.Configuration);
configurationRegistry$2.registerConfiguration({
  ...workbenchConfigurationNodeBase,
  properties: {
    [APPLY_ALL_PROFILES_SETTING]: {
      "type": "array",
      description: localize(
        "setting description",
        "Configure settings to be applied for all profiles."
      ),
      "default": [],
      "scope": 1,
      additionalProperties: true,
      uniqueItems: true
    }
  }
});
let TextResourceConfigurationService = class TextResourceConfigurationService2 extends Disposable {
  constructor(configurationService, modelService, languageService) {
    super();
    this.configurationService = configurationService;
    this.modelService = modelService;
    this.languageService = languageService;
    this._onDidChangeConfiguration = this._register(new Emitter());
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this._register(this.configurationService.onDidChangeConfiguration((e) => this._onDidChangeConfiguration.fire(this.toResourceConfigurationChangeEvent(e))));
  }
  getValue(resource, arg2, arg3) {
    if (typeof arg3 === "string") {
      return this._getValue(resource, Position$1.isIPosition(arg2) ? arg2 : null, arg3);
    }
    return this._getValue(resource, null, typeof arg2 === "string" ? arg2 : void 0);
  }
  updateValue(resource, key, value, configurationTarget) {
    var _a3, _b3, _c3, _d3, _e3;
    const language2 = this.getLanguage(resource, null);
    const configurationValue = this.configurationService.inspect(key, { resource, overrideIdentifier: language2 });
    if (configurationTarget === void 0) {
      configurationTarget = this.deriveConfigurationTarget(configurationValue, language2);
    }
    switch (configurationTarget) {
      case 8:
        return this._updateValue(key, value, configurationTarget, (_a3 = configurationValue.memory) == null ? void 0 : _a3.override, resource, language2);
      case 6:
        return this._updateValue(key, value, configurationTarget, (_b3 = configurationValue.workspaceFolder) == null ? void 0 : _b3.override, resource, language2);
      case 5:
        return this._updateValue(key, value, configurationTarget, (_c3 = configurationValue.workspace) == null ? void 0 : _c3.override, resource, language2);
      case 4:
        return this._updateValue(key, value, configurationTarget, (_d3 = configurationValue.userRemote) == null ? void 0 : _d3.override, resource, language2);
      default:
        return this._updateValue(key, value, configurationTarget, (_e3 = configurationValue.userLocal) == null ? void 0 : _e3.override, resource, language2);
    }
  }
  _updateValue(key, value, configurationTarget, overriddenValue, resource, language2) {
    if (language2 && overriddenValue !== void 0) {
      return this.configurationService.updateValue(key, value, { resource, overrideIdentifier: language2 }, configurationTarget);
    } else {
      return this.configurationService.updateValue(key, value, { resource }, configurationTarget);
    }
  }
  deriveConfigurationTarget(configurationValue, language2) {
    var _a3, _b3, _c3, _d3, _e3, _f3, _g3, _h3, _i2;
    if (language2) {
      if (((_a3 = configurationValue.memory) == null ? void 0 : _a3.override) !== void 0) {
        return 8;
      }
      if (((_b3 = configurationValue.workspaceFolder) == null ? void 0 : _b3.override) !== void 0) {
        return 6;
      }
      if (((_c3 = configurationValue.workspace) == null ? void 0 : _c3.override) !== void 0) {
        return 5;
      }
      if (((_d3 = configurationValue.userRemote) == null ? void 0 : _d3.override) !== void 0) {
        return 4;
      }
      if (((_e3 = configurationValue.userLocal) == null ? void 0 : _e3.override) !== void 0) {
        return 3;
      }
    }
    if (((_f3 = configurationValue.memory) == null ? void 0 : _f3.value) !== void 0) {
      return 8;
    }
    if (((_g3 = configurationValue.workspaceFolder) == null ? void 0 : _g3.value) !== void 0) {
      return 6;
    }
    if (((_h3 = configurationValue.workspace) == null ? void 0 : _h3.value) !== void 0) {
      return 5;
    }
    if (((_i2 = configurationValue.userRemote) == null ? void 0 : _i2.value) !== void 0) {
      return 4;
    }
    return 3;
  }
  _getValue(resource, position, section) {
    const language2 = resource ? this.getLanguage(resource, position) : void 0;
    if (typeof section === "undefined") {
      return this.configurationService.getValue({ resource, overrideIdentifier: language2 });
    }
    return this.configurationService.getValue(section, { resource, overrideIdentifier: language2 });
  }
  inspect(resource, position, section) {
    const language2 = resource ? this.getLanguage(resource, position) : void 0;
    return this.configurationService.inspect(section, { resource, overrideIdentifier: language2 });
  }
  getLanguage(resource, position) {
    const model = this.modelService.getModel(resource);
    if (model) {
      return position ? model.getLanguageIdAtPosition(position.lineNumber, position.column) : model.getLanguageId();
    }
    return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
  }
  toResourceConfigurationChangeEvent(configurationChangeEvent) {
    return {
      affectedKeys: configurationChangeEvent.affectedKeys,
      affectsConfiguration: (resource, configuration2) => {
        const overrideIdentifier = resource ? this.getLanguage(resource, null) : void 0;
        return configurationChangeEvent.affectsConfiguration(configuration2, { resource, overrideIdentifier });
      }
    };
  }
};
TextResourceConfigurationService = __decorate$U([
  __param$U(0, IConfigurationService),
  __param$U(1, IModelService),
  __param$U(2, ILanguageService)
], TextResourceConfigurationService);
var ConfigurationScope;
(function(ConfigurationScope2) {
  ConfigurationScope2[ConfigurationScope2["APPLICATION"] = 1] = "APPLICATION";
  ConfigurationScope2[ConfigurationScope2["MACHINE"] = 2] = "MACHINE";
  ConfigurationScope2[ConfigurationScope2["WINDOW"] = 3] = "WINDOW";
  ConfigurationScope2[ConfigurationScope2["RESOURCE"] = 4] = "RESOURCE";
  ConfigurationScope2[ConfigurationScope2["LANGUAGE_OVERRIDABLE"] = 5] = "LANGUAGE_OVERRIDABLE";
  ConfigurationScope2[ConfigurationScope2["MACHINE_OVERRIDABLE"] = 6] = "MACHINE_OVERRIDABLE";
})(ConfigurationScope || (ConfigurationScope = {}));
class ConfigurationCache {
  constructor(donotCacheResourcesWithSchemes, environmentService, fileService) {
    this.donotCacheResourcesWithSchemes = donotCacheResourcesWithSchemes;
    this.fileService = fileService;
    this.cachedConfigurations = /* @__PURE__ */ new Map();
    this.cacheHome = environmentService.cacheHome;
  }
  needsCaching(resource) {
    return !this.donotCacheResourcesWithSchemes.includes(resource.scheme);
  }
  read(key) {
    return this.getCachedConfiguration(key).read();
  }
  write(key, content) {
    return this.getCachedConfiguration(key).save(content);
  }
  remove(key) {
    return this.getCachedConfiguration(key).remove();
  }
  getCachedConfiguration({ type, key }) {
    const k = `${type}:${key}`;
    let cachedConfiguration = this.cachedConfigurations.get(k);
    if (!cachedConfiguration) {
      cachedConfiguration = new CachedConfiguration({ type, key }, this.cacheHome, this.fileService);
      this.cachedConfigurations.set(k, cachedConfiguration);
    }
    return cachedConfiguration;
  }
}
class CachedConfiguration {
  constructor({ type, key }, cacheHome, fileService) {
    this.fileService = fileService;
    this.cachedConfigurationFolderResource = joinPath(cacheHome, "CachedConfigurations", type, key);
    this.cachedConfigurationFileResource = joinPath(this.cachedConfigurationFolderResource, type === "workspaces" ? "workspace.json" : "configuration.json");
    this.queue = new Queue();
  }
  async read() {
    try {
      const content = await this.fileService.readFile(this.cachedConfigurationFileResource);
      return content.value.toString();
    } catch (e) {
      return "";
    }
  }
  async save(content) {
    const created = await this.createCachedFolder();
    if (created) {
      await this.queue.queue(async () => {
        await this.fileService.writeFile(this.cachedConfigurationFileResource, VSBuffer.fromString(content));
      });
    }
  }
  async remove() {
    try {
      await this.queue.queue(() => this.fileService.del(this.cachedConfigurationFolderResource, { recursive: true, useTrash: false }));
    } catch (error) {
      if (error.fileOperationResult !== 1) {
        throw error;
      }
    }
  }
  async createCachedFolder() {
    if (await this.fileService.exists(this.cachedConfigurationFolderResource)) {
      return true;
    }
    try {
      await this.fileService.createFolder(this.cachedConfigurationFolderResource);
      return true;
    } catch (error) {
      return false;
    }
  }
}
const resourceLabelFormattersExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "resourceLabelFormatters",
  jsonSchema: {
    description: localize(
      "vscode.extension.contributes.resourceLabelFormatters",
      "Contributes resource label formatting rules."
    ),
    type: "array",
    items: {
      type: "object",
      required: ["scheme", "formatting"],
      properties: {
        scheme: {
          type: "string",
          description: localize(
            "vscode.extension.contributes.resourceLabelFormatters.scheme",
            'URI scheme on which to match the formatter on. For example "file". Simple glob patterns are supported.'
          )
        },
        authority: {
          type: "string",
          description: localize(
            "vscode.extension.contributes.resourceLabelFormatters.authority",
            "URI authority on which to match the formatter on. Simple glob patterns are supported."
          )
        },
        formatting: {
          description: localize(
            "vscode.extension.contributes.resourceLabelFormatters.formatting",
            "Rules for formatting uri resource labels."
          ),
          type: "object",
          properties: {
            label: {
              type: "string",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.label",
                "Label rules to display. For example: myLabel:/${path}. ${path}, ${scheme}, ${authority} and ${authoritySuffix} are supported as variables."
              )
            },
            separator: {
              type: "string",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.separator",
                "Separator to be used in the uri label display. '/' or '' as an example."
              )
            },
            stripPathStartingSeparator: {
              type: "boolean",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.stripPathStartingSeparator",
                "Controls whether `${path}` substitutions should have starting separator characters stripped."
              )
            },
            tildify: {
              type: "boolean",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.tildify",
                "Controls if the start of the uri label should be tildified when possible."
              )
            },
            workspaceSuffix: {
              type: "string",
              description: localize(
                "vscode.extension.contributes.resourceLabelFormatters.formatting.workspaceSuffix",
                "Suffix appended to the workspace label."
              )
            }
          }
        }
      }
    }
  }
});
const sepRegexp = /\//g;
const labelMatchingRegexp = /\$\{(scheme|authoritySuffix|authority|path|(query)\.(.+?))\}/g;
function hasDriveLetterIgnorePlatform(path2) {
  return !!(path2 && path2[2] === ":");
}
let ResourceLabelFormattersHandler = class ResourceLabelFormattersHandler2 {
  constructor(labelService) {
    this.formattersDisposables = /* @__PURE__ */ new Map();
    resourceLabelFormattersExtPoint.setHandler((extensions, delta2) => {
      for (const added of delta2.added) {
        for (const untrustedFormatter of added.value) {
          const formatter = { ...untrustedFormatter };
          if (typeof formatter.formatting.label !== "string") {
            formatter.formatting.label = "${authority}${path}";
          }
          if (typeof formatter.formatting.separator !== `string`) {
            formatter.formatting.separator = sep;
          }
          if (!isProposedApiEnabled(added.description, "contribLabelFormatterWorkspaceTooltip") && formatter.formatting.workspaceTooltip) {
            formatter.formatting.workspaceTooltip = void 0;
          }
          this.formattersDisposables.set(formatter, labelService.registerFormatter(formatter));
        }
      }
      for (const removed of delta2.removed) {
        for (const formatter of removed.value) {
          dispose(this.formattersDisposables.get(formatter));
        }
      }
    });
  }
};
ResourceLabelFormattersHandler = __decorate$U([
  __param$U(0, ILabelService)
], ResourceLabelFormattersHandler);
Registry.as(Extensions$1.Workbench).registerWorkbenchContribution(ResourceLabelFormattersHandler, 3);
const FORMATTER_CACHE_SIZE = 50;
let LabelService = class LabelService2 extends Disposable {
  constructor(environmentService, contextService, pathService, remoteAgentService, storageService, lifecycleService) {
    var _a3, _b3;
    super();
    this.environmentService = environmentService;
    this.contextService = contextService;
    this.pathService = pathService;
    this.remoteAgentService = remoteAgentService;
    this._onDidChangeFormatters = this._register(new Emitter({ leakWarningThreshold: 400 }));
    this.onDidChangeFormatters = this._onDidChangeFormatters.event;
    this.os = OS;
    this.userHome = pathService.defaultUriScheme === Schemas.file ? this.pathService.userHome({ preferLocal: true }) : void 0;
    const memento = this.storedFormattersMemento = new Memento("cachedResourceLabelFormatters2", storageService);
    this.storedFormatters = memento.getMemento(0, 1);
    this.formatters = ((_b3 = (_a3 = this.storedFormatters) == null ? void 0 : _a3.formatters) == null ? void 0 : _b3.slice()) || [];
    this.resolveRemoteEnvironment();
  }
  async resolveRemoteEnvironment() {
    const env = await this.remoteAgentService.getEnvironment();
    this.os = (env == null ? void 0 : env.os) ?? OS;
    this.userHome = await this.pathService.userHome();
  }
  findFormatting(resource) {
    let bestResult;
    for (const formatter of this.formatters) {
      if (formatter.scheme === resource.scheme) {
        if (!formatter.authority && (!bestResult || formatter.priority)) {
          bestResult = formatter;
          continue;
        }
        if (!formatter.authority) {
          continue;
        }
        if (match(formatter.authority.toLowerCase(), resource.authority.toLowerCase()) && (!bestResult || !bestResult.authority || formatter.authority.length > bestResult.authority.length || formatter.authority.length === bestResult.authority.length && formatter.priority)) {
          bestResult = formatter;
        }
      }
    }
    return bestResult ? bestResult.formatting : void 0;
  }
  getUriLabel(resource, options = {}) {
    let formatting2 = this.findFormatting(resource);
    if (formatting2 && options.separator) {
      formatting2 = { ...formatting2, separator: options.separator };
    }
    const label = this.doGetUriLabel(resource, formatting2, options);
    if (!formatting2 && options.separator) {
      return label.replace(sepRegexp, options.separator);
    }
    return label;
  }
  doGetUriLabel(resource, formatting2, options = {}) {
    if (!formatting2) {
      return getPathLabel(resource, {
        os: this.os,
        tildify: this.userHome ? { userHome: this.userHome } : void 0,
        relative: options.relative ? {
          noPrefix: options.noPrefix,
          getWorkspace: () => this.contextService.getWorkspace(),
          getWorkspaceFolder: (resource2) => this.contextService.getWorkspaceFolder(resource2)
        } : void 0
      });
    }
    if (options.relative && this.contextService) {
      let folder = this.contextService.getWorkspaceFolder(resource);
      if (!folder) {
        const workspace = this.contextService.getWorkspace();
        const firstFolder = firstOrDefault(workspace.folders);
        if (firstFolder && resource.scheme !== firstFolder.uri.scheme && resource.path.startsWith(posix.sep)) {
          folder = this.contextService.getWorkspaceFolder(firstFolder.uri.with({ path: resource.path }));
        }
      }
      if (folder) {
        const folderLabel = this.formatUri(folder.uri, formatting2, options.noPrefix);
        let relativeLabel = this.formatUri(resource, formatting2, options.noPrefix);
        let overlap = 0;
        while (relativeLabel[overlap] && relativeLabel[overlap] === folderLabel[overlap]) {
          overlap++;
        }
        if (!relativeLabel[overlap] || relativeLabel[overlap] === formatting2.separator) {
          relativeLabel = relativeLabel.substring(1 + overlap);
        } else if (overlap === folderLabel.length && folder.uri.path === posix.sep) {
          relativeLabel = relativeLabel.substring(overlap);
        }
        const hasMultipleRoots = this.contextService.getWorkspace().folders.length > 1;
        if (hasMultipleRoots && !options.noPrefix) {
          const rootName = (folder == null ? void 0 : folder.name) ?? basenameOrAuthority(folder.uri);
          relativeLabel = relativeLabel ? `${rootName} • ${relativeLabel}` : rootName;
        }
        return relativeLabel;
      }
    }
    return this.formatUri(resource, formatting2, options.noPrefix);
  }
  getUriBasenameLabel(resource) {
    const formatting2 = this.findFormatting(resource);
    const label = this.doGetUriLabel(resource, formatting2);
    let pathLib;
    if ((formatting2 == null ? void 0 : formatting2.separator) === win32.sep) {
      pathLib = win32;
    } else if ((formatting2 == null ? void 0 : formatting2.separator) === posix.sep) {
      pathLib = posix;
    } else {
      pathLib = this.os === 1 ? win32 : posix;
    }
    return pathLib.basename(label);
  }
  getWorkspaceLabel(workspace, options) {
    if (isWorkspace(workspace)) {
      const identifier = toWorkspaceIdentifier(workspace);
      if (isSingleFolderWorkspaceIdentifier(identifier) || isWorkspaceIdentifier(identifier)) {
        return this.getWorkspaceLabel(identifier, options);
      }
      return "";
    }
    if (URI$1.isUri(workspace)) {
      return this.doGetSingleFolderWorkspaceLabel(workspace, options);
    }
    if (isSingleFolderWorkspaceIdentifier(workspace)) {
      return this.doGetSingleFolderWorkspaceLabel(workspace.uri, options);
    }
    if (isWorkspaceIdentifier(workspace)) {
      return this.doGetWorkspaceLabel(workspace.configPath, options);
    }
    return "";
  }
  doGetWorkspaceLabel(workspaceUri, options) {
    if (isUntitledWorkspace(workspaceUri, this.environmentService)) {
      return localize("untitledWorkspace", "Untitled (Workspace)");
    }
    if (isTemporaryWorkspace(workspaceUri)) {
      return localize("temporaryWorkspace", "Workspace");
    }
    let filename = basename(workspaceUri);
    if (filename.endsWith(WORKSPACE_EXTENSION)) {
      filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
    }
    let label;
    switch (options == null ? void 0 : options.verbose) {
      case 0:
        label = filename;
        break;
      case 2:
        label = localize(
          "workspaceNameVerbose",
          "{0} (Workspace)",
          this.getUriLabel(joinPath(dirname(workspaceUri), filename))
        );
        break;
      case 1:
      default:
        label = localize("workspaceName", "{0} (Workspace)", filename);
        break;
    }
    if ((options == null ? void 0 : options.verbose) === 0) {
      return label;
    }
    return this.appendWorkspaceSuffix(label, workspaceUri);
  }
  doGetSingleFolderWorkspaceLabel(folderUri, options) {
    let label;
    switch (options == null ? void 0 : options.verbose) {
      case 2:
        label = this.getUriLabel(folderUri);
        break;
      case 0:
      case 1:
      default:
        label = basename(folderUri) || posix.sep;
        break;
    }
    if ((options == null ? void 0 : options.verbose) === 0) {
      return label;
    }
    return this.appendWorkspaceSuffix(label, folderUri);
  }
  getSeparator(scheme, authority) {
    const formatter = this.findFormatting(URI$1.from({ scheme, authority }));
    return (formatter == null ? void 0 : formatter.separator) || posix.sep;
  }
  getHostLabel(scheme, authority) {
    const formatter = this.findFormatting(URI$1.from({ scheme, authority }));
    return (formatter == null ? void 0 : formatter.workspaceSuffix) || authority || "";
  }
  getHostTooltip(scheme, authority) {
    const formatter = this.findFormatting(URI$1.from({ scheme, authority }));
    return formatter == null ? void 0 : formatter.workspaceTooltip;
  }
  registerCachedFormatter(formatter) {
    var _a3;
    const list = (_a3 = this.storedFormatters).formatters ?? (_a3.formatters = []);
    let replace = list.findIndex((f) => f.scheme === formatter.scheme && f.authority === formatter.authority);
    if (replace === -1 && list.length >= FORMATTER_CACHE_SIZE) {
      replace = FORMATTER_CACHE_SIZE - 1;
    }
    if (replace === -1) {
      list.unshift(formatter);
    } else {
      for (let i = replace; i > 0; i--) {
        list[i] = list[i - 1];
      }
      list[0] = formatter;
    }
    this.storedFormattersMemento.saveMemento();
    return this.registerFormatter(formatter);
  }
  registerFormatter(formatter) {
    this.formatters.push(formatter);
    this._onDidChangeFormatters.fire({ scheme: formatter.scheme });
    return {
      dispose: () => {
        this.formatters = this.formatters.filter((f) => f !== formatter);
        this._onDidChangeFormatters.fire({ scheme: formatter.scheme });
      }
    };
  }
  formatUri(resource, formatting2, forceNoTildify) {
    let label = formatting2.label.replace(labelMatchingRegexp, (match2, token, qsToken, qsValue) => {
      switch (token) {
        case "scheme":
          return resource.scheme;
        case "authority":
          return resource.authority;
        case "authoritySuffix": {
          const i = resource.authority.indexOf("+");
          return i === -1 ? resource.authority : resource.authority.slice(i + 1);
        }
        case "path":
          return formatting2.stripPathStartingSeparator ? resource.path.slice(resource.path[0] === formatting2.separator ? 1 : 0) : resource.path;
        default: {
          if (qsToken === "query") {
            const { query } = resource;
            if (query && query[0] === "{" && query[query.length - 1] === "}") {
              try {
                return JSON.parse(query)[qsValue] || "";
              } catch {
              }
            }
          }
          return "";
        }
      }
    });
    if (formatting2.normalizeDriveLetter && hasDriveLetterIgnorePlatform(label)) {
      label = label.charAt(1).toUpperCase() + label.substr(2);
    }
    if (formatting2.tildify && !forceNoTildify) {
      if (this.userHome) {
        label = tildify(label, this.userHome.fsPath, this.os);
      }
    }
    if (formatting2.authorityPrefix && resource.authority) {
      label = formatting2.authorityPrefix + label;
    }
    return label.replace(sepRegexp, formatting2.separator);
  }
  appendWorkspaceSuffix(label, uri) {
    const formatting2 = this.findFormatting(uri);
    const suffix = formatting2 && typeof formatting2.workspaceSuffix === "string" ? formatting2.workspaceSuffix : void 0;
    return suffix ? `${label} [${suffix}]` : label;
  }
};
LabelService = __decorate$U([
  __param$U(0, IWorkbenchEnvironmentService),
  __param$U(1, IWorkspaceContextService),
  __param$U(2, IPathService),
  __param$U(3, IRemoteAgentService),
  __param$U(4, IStorageService),
  __param$U(5, ILifecycleService)
], LabelService);
function getWorkspaceIdentifier(workspaceUri) {
  return {
    id: getWorkspaceId(workspaceUri),
    configPath: workspaceUri
  };
}
function getWorkspaceId(uri) {
  return hash(uri.toString()).toString(16);
}
let BrowserWorkspacesService = (_l = class extends Disposable {
  constructor(storageService, contextService, logService, fileService, environmentService, uriIdentityService) {
    super();
    this.storageService = storageService;
    this.contextService = contextService;
    this.logService = logService;
    this.fileService = fileService;
    this.environmentService = environmentService;
    this.uriIdentityService = uriIdentityService;
    this._onRecentlyOpenedChange = this._register(new Emitter());
    this.onDidChangeRecentlyOpened = this._onRecentlyOpenedChange.event;
    this.addWorkspaceToRecentlyOpened();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.storageService.onDidChangeValue((e) => this.onDidChangeStorage(e)));
    this._register(this.contextService.onDidChangeWorkspaceFolders((e) => this.onDidChangeWorkspaceFolders(e)));
  }
  onDidChangeStorage(e) {
    if (e.key === _l.RECENTLY_OPENED_KEY && e.scope === -1) {
      this._onRecentlyOpenedChange.fire();
    }
  }
  onDidChangeWorkspaceFolders(e) {
    if (!isTemporaryWorkspace(this.contextService.getWorkspace())) {
      return;
    }
    for (const folder of e.added) {
      this.addRecentlyOpened([{ folderUri: folder.uri }]);
    }
  }
  addWorkspaceToRecentlyOpened() {
    const workspace = this.contextService.getWorkspace();
    const remoteAuthority = this.environmentService.remoteAuthority;
    switch (this.contextService.getWorkbenchState()) {
      case 2:
        this.addRecentlyOpened([{ folderUri: workspace.folders[0].uri, remoteAuthority }]);
        break;
      case 3:
        this.addRecentlyOpened([{ workspace: { id: workspace.id, configPath: workspace.configuration }, remoteAuthority }]);
        break;
    }
  }
  async getRecentlyOpened() {
    const recentlyOpenedRaw = this.storageService.get(_l.RECENTLY_OPENED_KEY, -1);
    if (recentlyOpenedRaw) {
      const recentlyOpened = restoreRecentlyOpened(JSON.parse(recentlyOpenedRaw), this.logService);
      recentlyOpened.workspaces = recentlyOpened.workspaces.filter((recent) => {
        if (isRecentFolder(recent) && recent.folderUri.scheme === Schemas.file && !isTemporaryWorkspace(this.contextService.getWorkspace())) {
          return false;
        }
        if (isRecentWorkspace(recent) && isTemporaryWorkspace(recent.workspace.configPath)) {
          return false;
        }
        return true;
      });
      return recentlyOpened;
    }
    return { workspaces: [], files: [] };
  }
  async addRecentlyOpened(recents) {
    const recentlyOpened = await this.getRecentlyOpened();
    for (const recent of recents) {
      if (isRecentFile(recent)) {
        this.doRemoveRecentlyOpened(recentlyOpened, [recent.fileUri]);
        recentlyOpened.files.unshift(recent);
      } else if (isRecentFolder(recent)) {
        this.doRemoveRecentlyOpened(recentlyOpened, [recent.folderUri]);
        recentlyOpened.workspaces.unshift(recent);
      } else {
        this.doRemoveRecentlyOpened(recentlyOpened, [recent.workspace.configPath]);
        recentlyOpened.workspaces.unshift(recent);
      }
    }
    return this.saveRecentlyOpened(recentlyOpened);
  }
  async removeRecentlyOpened(paths) {
    const recentlyOpened = await this.getRecentlyOpened();
    this.doRemoveRecentlyOpened(recentlyOpened, paths);
    return this.saveRecentlyOpened(recentlyOpened);
  }
  doRemoveRecentlyOpened(recentlyOpened, paths) {
    recentlyOpened.files = recentlyOpened.files.filter((file) => {
      return !paths.some((path2) => path2.toString() === file.fileUri.toString());
    });
    recentlyOpened.workspaces = recentlyOpened.workspaces.filter((workspace) => {
      return !paths.some((path2) => path2.toString() === (isRecentFolder(workspace) ? workspace.folderUri.toString() : workspace.workspace.configPath.toString()));
    });
  }
  async saveRecentlyOpened(data) {
    return this.storageService.store(_l.RECENTLY_OPENED_KEY, JSON.stringify(toStoreData(data)), -1, 0);
  }
  async clearRecentlyOpened() {
    this.storageService.remove(_l.RECENTLY_OPENED_KEY, -1);
  }
  async enterWorkspace(workspaceUri) {
    return { workspace: await this.getWorkspaceIdentifier(workspaceUri) };
  }
  async createUntitledWorkspace(folders, remoteAuthority) {
    const randomId = (Date.now() + Math.round(Math.random() * 1e3)).toString();
    const newUntitledWorkspacePath = joinPath(this.environmentService.untitledWorkspacesHome, `Untitled-${randomId}.${WORKSPACE_EXTENSION}`);
    const storedWorkspaceFolder = [];
    if (folders) {
      for (const folder of folders) {
        storedWorkspaceFolder.push(getStoredWorkspaceFolder(folder.uri, true, folder.name, this.environmentService.untitledWorkspacesHome, this.uriIdentityService.extUri));
      }
    }
    const storedWorkspace = { folders: storedWorkspaceFolder, remoteAuthority };
    await this.fileService.writeFile(newUntitledWorkspacePath, VSBuffer.fromString(JSON.stringify(storedWorkspace, null, "	")));
    return this.getWorkspaceIdentifier(newUntitledWorkspacePath);
  }
  async deleteUntitledWorkspace(workspace) {
    try {
      await this.fileService.del(workspace.configPath);
    } catch (error) {
      if (error.fileOperationResult !== 1) {
        throw error;
      }
    }
  }
  async getWorkspaceIdentifier(workspaceUri) {
    return getWorkspaceIdentifier(workspaceUri);
  }
  async getDirtyWorkspaces() {
    return [];
  }
}, _l.RECENTLY_OPENED_KEY = "recently.opened", _l);
BrowserWorkspacesService = __decorate$U([
  __param$U(0, IStorageService),
  __param$U(1, IWorkspaceContextService),
  __param$U(2, ILogService),
  __param$U(3, IFileService),
  __param$U(4, IWorkbenchEnvironmentService),
  __param$U(5, IUriIdentityService)
], BrowserWorkspacesService);
let AbstractWorkspaceEditingService = class AbstractWorkspaceEditingService2 {
  constructor(jsonEditingService, contextService, configurationService, notificationService, commandService, fileService, textFileService, workspacesService, environmentService, fileDialogService, dialogService, hostService, uriIdentityService, workspaceTrustManagementService, userDataProfilesService, userDataProfileService) {
    this.jsonEditingService = jsonEditingService;
    this.contextService = contextService;
    this.configurationService = configurationService;
    this.notificationService = notificationService;
    this.commandService = commandService;
    this.fileService = fileService;
    this.textFileService = textFileService;
    this.workspacesService = workspacesService;
    this.environmentService = environmentService;
    this.fileDialogService = fileDialogService;
    this.dialogService = dialogService;
    this.hostService = hostService;
    this.uriIdentityService = uriIdentityService;
    this.workspaceTrustManagementService = workspaceTrustManagementService;
    this.userDataProfilesService = userDataProfilesService;
    this.userDataProfileService = userDataProfileService;
  }
  async pickNewWorkspacePath() {
    const availableFileSystems = [Schemas.file];
    if (this.environmentService.remoteAuthority) {
      availableFileSystems.unshift(Schemas.vscodeRemote);
    }
    let workspacePath = await this.fileDialogService.showSaveDialog({
      saveLabel: mnemonicButtonLabel(localize("save", "Save")),
      title: localize("saveWorkspace", "Save Workspace"),
      filters: WORKSPACE_FILTER,
      defaultUri: joinPath(await this.fileDialogService.defaultWorkspacePath(), this.getNewWorkspaceName()),
      availableFileSystems
    });
    if (!workspacePath) {
      return;
    }
    if (!hasWorkspaceFileExtension(workspacePath)) {
      workspacePath = workspacePath.with({ path: `${workspacePath.path}.${WORKSPACE_EXTENSION}` });
    }
    return workspacePath;
  }
  getNewWorkspaceName() {
    var _a3;
    const configPathURI = (_a3 = this.getCurrentWorkspaceIdentifier()) == null ? void 0 : _a3.configPath;
    if (configPathURI && isSavedWorkspace(configPathURI, this.environmentService)) {
      return basename(configPathURI);
    }
    const folder = firstOrDefault(this.contextService.getWorkspace().folders);
    if (folder) {
      return `${basename(folder.uri)}.${WORKSPACE_EXTENSION}`;
    }
    return `workspace.${WORKSPACE_EXTENSION}`;
  }
  async updateFolders(index2, deleteCount, foldersToAddCandidates, donotNotifyError) {
    const folders = this.contextService.getWorkspace().folders;
    let foldersToDelete = [];
    if (typeof deleteCount === "number") {
      foldersToDelete = folders.slice(index2, index2 + deleteCount).map((folder) => folder.uri);
    }
    let foldersToAdd = [];
    if (Array.isArray(foldersToAddCandidates)) {
      foldersToAdd = foldersToAddCandidates.map(
        (folderToAdd) => ({ uri: removeTrailingPathSeparator(folderToAdd.uri), name: folderToAdd.name })
      );
    }
    const wantsToDelete = foldersToDelete.length > 0;
    const wantsToAdd = foldersToAdd.length > 0;
    if (!wantsToAdd && !wantsToDelete) {
      return;
    }
    if (wantsToAdd && !wantsToDelete) {
      return this.doAddFolders(foldersToAdd, index2, donotNotifyError);
    }
    if (wantsToDelete && !wantsToAdd) {
      return this.removeFolders(foldersToDelete);
    } else {
      if (this.includesSingleFolderWorkspace(foldersToDelete)) {
        return this.createAndEnterWorkspace(foldersToAdd);
      }
      if (this.contextService.getWorkbenchState() !== 3) {
        return this.doAddFolders(foldersToAdd, index2, donotNotifyError);
      }
      return this.doUpdateFolders(foldersToAdd, foldersToDelete, index2, donotNotifyError);
    }
  }
  async doUpdateFolders(foldersToAdd, foldersToDelete, index2, donotNotifyError = false) {
    try {
      await this.contextService.updateFolders(foldersToAdd, foldersToDelete, index2);
    } catch (error) {
      if (donotNotifyError) {
        throw error;
      }
      this.handleWorkspaceConfigurationEditingError(error);
    }
  }
  addFolders(foldersToAddCandidates, donotNotifyError = false) {
    const foldersToAdd = foldersToAddCandidates.map(
      (folderToAdd) => ({ uri: removeTrailingPathSeparator(folderToAdd.uri), name: folderToAdd.name })
    );
    return this.doAddFolders(foldersToAdd, void 0, donotNotifyError);
  }
  async doAddFolders(foldersToAdd, index2, donotNotifyError = false) {
    const state = this.contextService.getWorkbenchState();
    const remoteAuthority = this.environmentService.remoteAuthority;
    if (remoteAuthority) {
      foldersToAdd = foldersToAdd.filter((folder) => folder.uri.scheme !== Schemas.file && (folder.uri.scheme !== Schemas.vscodeRemote || isEqualAuthority(folder.uri.authority, remoteAuthority)));
    }
    if (state !== 3) {
      let newWorkspaceFolders = this.contextService.getWorkspace().folders.map((folder) => ({ uri: folder.uri }));
      newWorkspaceFolders.splice(typeof index2 === "number" ? index2 : newWorkspaceFolders.length, 0, ...foldersToAdd);
      newWorkspaceFolders = distinct$1(newWorkspaceFolders, (folder) => this.uriIdentityService.extUri.getComparisonKey(folder.uri));
      if (state === 1 && newWorkspaceFolders.length === 0 || state === 2 && newWorkspaceFolders.length === 1) {
        return;
      }
      return this.createAndEnterWorkspace(newWorkspaceFolders);
    }
    try {
      await this.contextService.addFolders(foldersToAdd, index2);
    } catch (error) {
      if (donotNotifyError) {
        throw error;
      }
      this.handleWorkspaceConfigurationEditingError(error);
    }
  }
  async removeFolders(foldersToRemove, donotNotifyError = false) {
    if (this.includesSingleFolderWorkspace(foldersToRemove)) {
      return this.createAndEnterWorkspace([]);
    }
    try {
      await this.contextService.removeFolders(foldersToRemove);
    } catch (error) {
      if (donotNotifyError) {
        throw error;
      }
      this.handleWorkspaceConfigurationEditingError(error);
    }
  }
  includesSingleFolderWorkspace(folders) {
    if (this.contextService.getWorkbenchState() === 2) {
      const workspaceFolder2 = this.contextService.getWorkspace().folders[0];
      return folders.some(
        (folder) => this.uriIdentityService.extUri.isEqual(folder, workspaceFolder2.uri)
      );
    }
    return false;
  }
  async createAndEnterWorkspace(folders, path2) {
    if (path2 && !await this.isValidTargetWorkspacePath(path2)) {
      return;
    }
    const remoteAuthority = this.environmentService.remoteAuthority;
    const untitledWorkspace = await this.workspacesService.createUntitledWorkspace(folders, remoteAuthority);
    if (path2) {
      try {
        await this.saveWorkspaceAs(untitledWorkspace, path2);
      } finally {
        await this.workspacesService.deleteUntitledWorkspace(untitledWorkspace);
      }
    } else {
      path2 = untitledWorkspace.configPath;
      if (!this.userDataProfileService.currentProfile.isDefault) {
        await this.userDataProfilesService.setProfileForWorkspace(untitledWorkspace, this.userDataProfileService.currentProfile);
      }
    }
    return this.enterWorkspace(path2);
  }
  async saveAndEnterWorkspace(workspaceUri) {
    const workspaceIdentifier = this.getCurrentWorkspaceIdentifier();
    if (!workspaceIdentifier) {
      return;
    }
    if (isEqual(workspaceIdentifier.configPath, workspaceUri)) {
      return this.saveWorkspace(workspaceIdentifier);
    }
    if (!await this.isValidTargetWorkspacePath(workspaceUri)) {
      return;
    }
    await this.saveWorkspaceAs(workspaceIdentifier, workspaceUri);
    return this.enterWorkspace(workspaceUri);
  }
  async isValidTargetWorkspacePath(workspaceUri) {
    return true;
  }
  async saveWorkspaceAs(workspace, targetConfigPathURI) {
    const configPathURI = workspace.configPath;
    const isNotUntitledWorkspace = !isUntitledWorkspace(targetConfigPathURI, this.environmentService);
    if (isNotUntitledWorkspace && !this.userDataProfileService.currentProfile.isDefault) {
      const newWorkspace = await this.workspacesService.getWorkspaceIdentifier(targetConfigPathURI);
      await this.userDataProfilesService.setProfileForWorkspace(newWorkspace, this.userDataProfileService.currentProfile);
    }
    if (this.uriIdentityService.extUri.isEqual(configPathURI, targetConfigPathURI)) {
      return;
    }
    const isFromUntitledWorkspace = isUntitledWorkspace(configPathURI, this.environmentService);
    const raw = await this.fileService.readFile(configPathURI);
    const newRawWorkspaceContents = rewriteWorkspaceFileForNewLocation(raw.value.toString(), configPathURI, isFromUntitledWorkspace, targetConfigPathURI, this.uriIdentityService.extUri);
    await this.textFileService.create([{ resource: targetConfigPathURI, value: newRawWorkspaceContents, options: { overwrite: true } }]);
    await this.trustWorkspaceConfiguration(targetConfigPathURI);
  }
  async saveWorkspace(workspace) {
    const configPathURI = workspace.configPath;
    const existingModel = this.textFileService.files.get(configPathURI);
    if (existingModel) {
      await existingModel.save({ force: true, reason: 1 });
      return;
    }
    const workspaceFileExists = await this.fileService.exists(configPathURI);
    if (workspaceFileExists) {
      return;
    }
    const newWorkspace = { folders: [] };
    const newRawWorkspaceContents = rewriteWorkspaceFileForNewLocation(JSON.stringify(newWorkspace, null, "	"), configPathURI, false, configPathURI, this.uriIdentityService.extUri);
    await this.textFileService.create([{ resource: configPathURI, value: newRawWorkspaceContents }]);
  }
  handleWorkspaceConfigurationEditingError(error) {
    switch (error.code) {
      case 0:
        this.onInvalidWorkspaceConfigurationFileError();
        break;
      default:
        this.notificationService.error(error.message);
    }
  }
  onInvalidWorkspaceConfigurationFileError() {
    const message = localize(
      "errorInvalidTaskConfiguration",
      "Unable to write into workspace configuration file. Please open the file to correct errors/warnings in it and try again."
    );
    this.askToOpenWorkspaceConfigurationFile(message);
  }
  askToOpenWorkspaceConfigurationFile(message) {
    this.notificationService.prompt(Severity$1.Error, message, [{
      label: localize("openWorkspaceConfigurationFile", "Open Workspace Configuration"),
      run: () => this.commandService.executeCommand("workbench.action.openWorkspaceConfigFile")
    }]);
  }
  async doEnterWorkspace(workspaceUri) {
    if (!!this.environmentService.extensionTestsLocationURI) {
      throw new Error("Entering a new workspace is not possible in tests.");
    }
    const workspace = await this.workspacesService.getWorkspaceIdentifier(workspaceUri);
    if (this.contextService.getWorkbenchState() === 2) {
      await this.migrateWorkspaceSettings(workspace);
    }
    await this.configurationService.initialize(workspace);
    return this.workspacesService.enterWorkspace(workspaceUri);
  }
  migrateWorkspaceSettings(toWorkspace) {
    return this.doCopyWorkspaceSettings(toWorkspace, (setting) => setting.scope === 3);
  }
  copyWorkspaceSettings(toWorkspace) {
    return this.doCopyWorkspaceSettings(toWorkspace);
  }
  doCopyWorkspaceSettings(toWorkspace, filter) {
    const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
    const targetWorkspaceConfiguration = {};
    for (const key of this.configurationService.keys().workspace) {
      if (configurationProperties[key]) {
        if (filter && !filter(configurationProperties[key])) {
          continue;
        }
        targetWorkspaceConfiguration[key] = this.configurationService.inspect(key).workspaceValue;
      }
    }
    return this.jsonEditingService.write(toWorkspace.configPath, [{ path: ["settings"], value: targetWorkspaceConfiguration }], true);
  }
  async trustWorkspaceConfiguration(configPathURI) {
    if (this.contextService.getWorkbenchState() !== 1 && this.workspaceTrustManagementService.isWorkspaceTrusted()) {
      await this.workspaceTrustManagementService.setUrisTrust([configPathURI], true);
    }
  }
  getCurrentWorkspaceIdentifier() {
    const identifier = toWorkspaceIdentifier(this.contextService.getWorkspace());
    if (isWorkspaceIdentifier(identifier)) {
      return identifier;
    }
    return void 0;
  }
};
AbstractWorkspaceEditingService = __decorate$U([
  __param$U(0, IJSONEditingService),
  __param$U(1, IWorkspaceContextService),
  __param$U(2, IWorkbenchConfigurationService),
  __param$U(3, INotificationService),
  __param$U(4, ICommandService),
  __param$U(5, IFileService),
  __param$U(6, ITextFileService),
  __param$U(7, IWorkspacesService),
  __param$U(8, IWorkbenchEnvironmentService),
  __param$U(9, IFileDialogService),
  __param$U(10, IDialogService$1),
  __param$U(11, IHostService),
  __param$U(12, IUriIdentityService),
  __param$U(13, IWorkspaceTrustManagementService),
  __param$U(14, IUserDataProfilesService),
  __param$U(15, IUserDataProfileService)
], AbstractWorkspaceEditingService);
const jsonRegistry = Registry.as(Extensions$2.JSONContribution);
const configurationRegistry$1 = Registry.as(Extensions.Configuration);
const configurationEntrySchema = {
  type: "object",
  defaultSnippets: [{ body: { title: "", properties: {} } }],
  properties: {
    title: {
      description: localize(
        "vscode.extension.contributes.configuration.title",
        "A title for the current category of settings. This label will be rendered in the Settings editor as a subheading. If the title is the same as the extension display name, then the category will be grouped under the main extension heading."
      ),
      type: "string"
    },
    order: {
      description: localize(
        "vscode.extension.contributes.configuration.order",
        "When specified, gives the order of this category of settings relative to other categories."
      ),
      type: "integer"
    },
    properties: {
      description: localize(
        "vscode.extension.contributes.configuration.properties",
        "Description of the configuration properties."
      ),
      type: "object",
      propertyNames: {
        pattern: "\\S+",
        patternErrorMessage: localize(
          "vscode.extension.contributes.configuration.property.empty",
          "Property should not be empty."
        )
      },
      additionalProperties: {
        anyOf: [
          {
            title: localize(
              "vscode.extension.contributes.configuration.properties.schema",
              "Schema of the configuration property."
            ),
            $ref: "http://json-schema.org/draft-07/schema#"
          },
          {
            type: "object",
            properties: {
              scope: {
                type: "string",
                enum: ["application", "machine", "window", "resource", "language-overridable", "machine-overridable"],
                default: "window",
                enumDescriptions: [
                  localize(
                    "scope.application.description",
                    "Configuration that can be configured only in the user settings."
                  ),
                  localize(
                    "scope.machine.description",
                    "Configuration that can be configured only in the user settings or only in the remote settings."
                  ),
                  localize(
                    "scope.window.description",
                    "Configuration that can be configured in the user, remote or workspace settings."
                  ),
                  localize(
                    "scope.resource.description",
                    "Configuration that can be configured in the user, remote, workspace or folder settings."
                  ),
                  localize(
                    "scope.language-overridable.description",
                    "Resource configuration that can be configured in language specific settings."
                  ),
                  localize(
                    "scope.machine-overridable.description",
                    "Machine configuration that can be configured also in workspace or folder settings."
                  )
                ],
                markdownDescription: localize(
                  "scope.description",
                  "Scope in which the configuration is applicable. Available scopes are `application`, `machine`, `window`, `resource`, and `machine-overridable`."
                )
              },
              enumDescriptions: {
                type: "array",
                items: {
                  type: "string"
                },
                description: localize("scope.enumDescriptions", "Descriptions for enum values")
              },
              markdownEnumDescriptions: {
                type: "array",
                items: {
                  type: "string"
                },
                description: localize(
                  "scope.markdownEnumDescriptions",
                  "Descriptions for enum values in the markdown format."
                )
              },
              enumItemLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                markdownDescription: localize(
                  "scope.enumItemLabels",
                  "Labels for enum values to be displayed in the Settings editor. When specified, the {0} values still show after the labels, but less prominently.",
                  "`enum`"
                )
              },
              markdownDescription: {
                type: "string",
                description: localize("scope.markdownDescription", "The description in the markdown format.")
              },
              deprecationMessage: {
                type: "string",
                description: localize(
                  "scope.deprecationMessage",
                  "If set, the property is marked as deprecated and the given message is shown as an explanation."
                )
              },
              markdownDeprecationMessage: {
                type: "string",
                description: localize(
                  "scope.markdownDeprecationMessage",
                  "If set, the property is marked as deprecated and the given message is shown as an explanation in the markdown format."
                )
              },
              editPresentation: {
                type: "string",
                enum: ["singlelineText", "multilineText"],
                enumDescriptions: [
                  localize(
                    "scope.singlelineText.description",
                    "The value will be shown in an inputbox."
                  ),
                  localize(
                    "scope.multilineText.description",
                    "The value will be shown in a textarea."
                  )
                ],
                default: "singlelineText",
                description: localize(
                  "scope.editPresentation",
                  "When specified, controls the presentation format of the string setting."
                )
              },
              order: {
                type: "integer",
                description: localize(
                  "scope.order",
                  "When specified, gives the order of this setting relative to other settings within the same category. Settings with an order property will be placed before settings without this property set."
                )
              },
              ignoreSync: {
                type: "boolean",
                description: localize(
                  "scope.ignoreSync",
                  "When enabled, Settings Sync will not sync the user value of this configuration by default."
                )
              }
            }
          }
        ]
      }
    }
  }
};
let _configDelta;
const defaultConfigurationExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "configurationDefaults",
  jsonSchema: {
    $ref: configurationDefaultsSchemaId
  }
});
defaultConfigurationExtPoint.setHandler((extensions, { added, removed }) => {
  if (_configDelta) {
    configurationRegistry$1.deltaConfiguration(_configDelta);
  }
  const configNow = _configDelta = {};
  queueMicrotask(() => {
    if (_configDelta === configNow) {
      configurationRegistry$1.deltaConfiguration(_configDelta);
      _configDelta = void 0;
    }
  });
  if (removed.length) {
    const removedDefaultConfigurations = removed.map(
      (extension) => ({ overrides: deepClone(extension.value), source: { id: extension.description.identifier.value, displayName: extension.description.displayName } })
    );
    _configDelta.removedDefaults = removedDefaultConfigurations;
  }
  if (added.length) {
    const registeredProperties = configurationRegistry$1.getConfigurationProperties();
    const allowedScopes = [6, 3, 4, 5];
    const addedDefaultConfigurations = added.map((extension) => {
      const overrides = deepClone(extension.value);
      for (const key of Object.keys(overrides)) {
        if (!OVERRIDE_PROPERTY_REGEX.test(key)) {
          const registeredPropertyScheme = registeredProperties[key];
          if ((registeredPropertyScheme == null ? void 0 : registeredPropertyScheme.scope) && !allowedScopes.includes(registeredPropertyScheme.scope)) {
            extension.collector.warn(localize(
              "config.property.defaultConfiguration.warning",
              "Cannot register configuration defaults for '{0}'. Only defaults for machine-overridable, window, resource and language overridable scoped settings are supported.",
              key
            ));
            delete overrides[key];
          }
        }
      }
      return { overrides, source: { id: extension.description.identifier.value, displayName: extension.description.displayName } };
    });
    _configDelta.addedDefaults = addedDefaultConfigurations;
  }
});
const configurationExtPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "configuration",
  deps: [defaultConfigurationExtPoint],
  jsonSchema: {
    description: localize(
      "vscode.extension.contributes.configuration",
      "Contributes configuration settings."
    ),
    oneOf: [
      configurationEntrySchema,
      {
        type: "array",
        items: configurationEntrySchema
      }
    ]
  }
});
const extensionConfigurations = new ExtensionIdentifierMap();
configurationExtPoint.setHandler((extensions, { added, removed }) => {
  _configDelta ?? (_configDelta = {});
  if (removed.length) {
    const removedConfigurations = [];
    for (const extension of removed) {
      removedConfigurations.push(...extensionConfigurations.get(extension.description.identifier) || []);
      extensionConfigurations.delete(extension.description.identifier);
    }
    _configDelta.removedConfigurations = removedConfigurations;
  }
  const seenProperties = /* @__PURE__ */ new Set();
  function handleConfiguration(node, extension) {
    var _a3, _b3, _c3;
    const configurations = [];
    const configuration2 = deepClone(node);
    if (configuration2.title && typeof configuration2.title !== "string") {
      extension.collector.error(localize("invalid.title", "'configuration.title' must be a string"));
    }
    validateProperties(configuration2, extension);
    configuration2.id = node.id || extension.description.identifier.value;
    configuration2.extensionInfo = { id: extension.description.identifier.value, displayName: extension.description.displayName };
    configuration2.restrictedProperties = ((_b3 = (_a3 = extension.description.capabilities) == null ? void 0 : _a3.untrustedWorkspaces) == null ? void 0 : _b3.supported) === "limited" ? (_c3 = extension.description.capabilities) == null ? void 0 : _c3.untrustedWorkspaces.restrictedConfigurations : void 0;
    configuration2.title = configuration2.title || extension.description.displayName || extension.description.identifier.value;
    configurations.push(configuration2);
    return configurations;
  }
  function validateProperties(configuration2, extension) {
    const properties = configuration2.properties;
    if (properties) {
      if (typeof properties !== "object") {
        extension.collector.error(localize("invalid.properties", "'configuration.properties' must be an object"));
        configuration2.properties = {};
      }
      for (const key in properties) {
        const propertyConfiguration = properties[key];
        const message = validateProperty(key, propertyConfiguration);
        if (message) {
          delete properties[key];
          extension.collector.warn(message);
          continue;
        }
        if (seenProperties.has(key)) {
          delete properties[key];
          extension.collector.warn(localize(
            "config.property.duplicate",
            "Cannot register '{0}'. This property is already registered.",
            key
          ));
          continue;
        }
        if (!isObject(propertyConfiguration)) {
          delete properties[key];
          extension.collector.error(localize(
            "invalid.property",
            "configuration.properties property '{0}' must be an object",
            key
          ));
          continue;
        }
        seenProperties.add(key);
        if (propertyConfiguration.scope) {
          if (propertyConfiguration.scope.toString() === "application") {
            propertyConfiguration.scope = 1;
          } else if (propertyConfiguration.scope.toString() === "machine") {
            propertyConfiguration.scope = 2;
          } else if (propertyConfiguration.scope.toString() === "resource") {
            propertyConfiguration.scope = 4;
          } else if (propertyConfiguration.scope.toString() === "machine-overridable") {
            propertyConfiguration.scope = 6;
          } else if (propertyConfiguration.scope.toString() === "language-overridable") {
            propertyConfiguration.scope = 5;
          } else {
            propertyConfiguration.scope = 3;
          }
        } else {
          propertyConfiguration.scope = 3;
        }
      }
    }
    const subNodes = configuration2.allOf;
    if (subNodes) {
      extension.collector.error(localize(
        "invalid.allOf",
        "'configuration.allOf' is deprecated and should no longer be used. Instead, pass multiple configuration sections as an array to the 'configuration' contribution point."
      ));
      for (const node of subNodes) {
        validateProperties(node, extension);
      }
    }
  }
  if (added.length) {
    const addedConfigurations = [];
    for (const extension of added) {
      const configurations = [];
      const value = extension.value;
      if (Array.isArray(value)) {
        value.forEach((v) => configurations.push(...handleConfiguration(v, extension)));
      } else {
        configurations.push(...handleConfiguration(value, extension));
      }
      extensionConfigurations.set(extension.description.identifier, configurations);
      addedConfigurations.push(...configurations);
    }
    _configDelta.addedConfigurations = addedConfigurations;
  }
  configurationRegistry$1.deltaConfiguration(_configDelta);
  _configDelta = void 0;
});
jsonRegistry.registerSchema("vscode://schemas/workspaceConfig", {
  allowComments: true,
  allowTrailingCommas: true,
  default: {
    folders: [
      {
        path: ""
      }
    ],
    settings: {}
  },
  required: ["folders"],
  properties: {
    "folders": {
      minItems: 0,
      uniqueItems: true,
      description: localize(
        "workspaceConfig.folders.description",
        "List of folders to be loaded in the workspace."
      ),
      items: {
        type: "object",
        defaultSnippets: [{ body: { path: "$1" } }],
        oneOf: [{
          properties: {
            path: {
              type: "string",
              description: localize(
                "workspaceConfig.path.description",
                "A file path. e.g. `/root/folderA` or `./folderA` for a relative path that will be resolved against the location of the workspace file."
              )
            },
            name: {
              type: "string",
              description: localize("workspaceConfig.name.description", "An optional name for the folder. ")
            }
          },
          required: ["path"]
        }, {
          properties: {
            uri: {
              type: "string",
              description: localize("workspaceConfig.uri.description", "URI of the folder")
            },
            name: {
              type: "string",
              description: localize("workspaceConfig.name.description", "An optional name for the folder. ")
            }
          },
          required: ["uri"]
        }]
      }
    },
    "settings": {
      type: "object",
      default: {},
      description: localize("workspaceConfig.settings.description", "Workspace settings"),
      $ref: workspaceSettingsSchemaId
    },
    "launch": {
      type: "object",
      default: { configurations: [], compounds: [] },
      description: localize("workspaceConfig.launch.description", "Workspace launch configurations"),
      $ref: launchSchemaId
    },
    "tasks": {
      type: "object",
      default: { version: "2.0.0", tasks: [] },
      description: localize("workspaceConfig.tasks.description", "Workspace task configurations"),
      $ref: tasksSchemaId
    },
    "extensions": {
      type: "object",
      default: {},
      description: localize("workspaceConfig.extensions.description", "Workspace extensions"),
      $ref: "vscode://schemas/extensions"
    },
    "remoteAuthority": {
      type: "string",
      doNotSuggest: true,
      description: localize(
        "workspaceConfig.remoteAuthority",
        "The remote server where the workspace is located."
      )
    },
    "transient": {
      type: "boolean",
      doNotSuggest: true,
      description: localize(
        "workspaceConfig.transient",
        "A transient workspace will disappear when restarting or reloading."
      )
    }
  },
  errorMessage: localize("unknownWorkspaceProperty", "Unknown workspace configuration property")
});
async function updateUserConfiguration(configurationJson) {
  const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
  await StandaloneServices.get(IFileService).writeFile(userDataProfilesService.defaultProfile.settingsResource, VSBuffer.fromString(configurationJson));
}
async function getUserConfiguration() {
  const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
  return (await StandaloneServices.get(IFileService).readFile(userDataProfilesService.defaultProfile.settingsResource)).value.toString();
}
function onUserConfigurationChange(callback) {
  const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
  return StandaloneServices.get(IFileService).onDidFilesChange((e) => {
    if (e.affects(userDataProfilesService.defaultProfile.settingsResource)) {
      callback();
    }
  });
}
const configurationRegistry = Registry.as(Extensions.Configuration);
let InjectedConfigurationService = class InjectedConfigurationService2 extends WorkspaceService {
  constructor(workbenchEnvironmentService, userDataProfileService, userDataProfilesService, fileService, remoteAgentService, uriIdentityService, logService, policyService) {
    const configurationCache = new ConfigurationCache([Schemas.file, Schemas.vscodeUserData, Schemas.tmp], workbenchEnvironmentService, fileService);
    super({ configurationCache }, workbenchEnvironmentService, userDataProfileService, userDataProfilesService, fileService, remoteAgentService, uriIdentityService, logService, policyService);
  }
};
InjectedConfigurationService = __decorate$U([
  __param$U(0, IWorkbenchEnvironmentService),
  __param$U(1, IUserDataProfileService),
  __param$U(2, IUserDataProfilesService),
  __param$U(3, IFileService),
  __param$U(4, IRemoteAgentService),
  __param$U(5, IUriIdentityService),
  __param$U(6, ILogService),
  __param$U(7, IPolicyService)
], InjectedConfigurationService);
class MonacoWorkspaceEditingService extends AbstractWorkspaceEditingService {
  constructor() {
    super(...arguments);
    this.enterWorkspace = unsupported;
  }
}
let _defaultWorkspaceUri = URI$1.file("/workspace");
registerServiceInitializePreParticipant(async (accessor) => {
  const workspaceService = accessor.get(IWorkspaceContextService);
  workspaceService.acquireInstantiationService(accessor.get(IInstantiationService));
  const configPath = _defaultWorkspaceUri.with({ path: "/workspace.code-workspace" });
  try {
    const fileService = accessor.get(IFileService);
    await fileService.createFolder(_defaultWorkspaceUri);
    await fileService.writeFile(configPath, VSBuffer.fromString(JSON.stringify({
      folders: [
        {
          path: _defaultWorkspaceUri.path
        }
      ]
    })));
  } catch (err) {
  }
  await workspaceService.initialize({
    id: generateUuid(),
    configPath
  });
});
const MemoizedInjectedConfigurationService = memoizedConstructor(InjectedConfigurationService);
function getServiceOverride(defaultWorkspaceUri) {
  _defaultWorkspaceUri = defaultWorkspaceUri;
  return {
    ...getServiceOverride$1(),
    [ILabelService.toString()]: new SyncDescriptor(LabelService, void 0, true),
    [IConfigurationService.toString()]: new SyncDescriptor(MemoizedInjectedConfigurationService, [], true),
    [IWorkspaceContextService.toString()]: new SyncDescriptor(MemoizedInjectedConfigurationService, [], true),
    [ITextResourceConfigurationService.toString()]: new SyncDescriptor(TextResourceConfigurationService, [], true),
    [IWorkspaceEditingService.toString()]: new SyncDescriptor(MonacoWorkspaceEditingService, [], true),
    [IWorkspacesService.toString()]: new SyncDescriptor(BrowserWorkspacesService, void 0, true)
  };
}
const configuration$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ConfigurationScope() {
    return ConfigurationScope;
  },
  configurationRegistry,
  default: getServiceOverride,
  getUserConfiguration,
  onUserConfigurationChange,
  updateUserConfiguration
}, Symbol.toStringTag, { value: "Module" }));
const createUrl = (config) => {
  let buildUrl = "";
  if (config.url) {
    const options = config;
    if (!options.url.startsWith("ws://") && !options.url.startsWith("wss://")) {
      throw new Error(`This is not a proper websocket url: ${options.url}`);
    }
    buildUrl = options.url;
  } else {
    const options = config;
    const protocol2 = options.secured ? "wss" : "ws";
    buildUrl = `${protocol2}://${options.host}`;
    if (options.port) {
      if (options.port !== 80) {
        buildUrl += `:${options.port}`;
      }
    }
    if (options.path) {
      buildUrl += `/${options.path}`;
    }
    if (options.extraParams) {
      const url = new URL(buildUrl);
      for (const [key, value] of Object.entries(options.extraParams)) {
        if (value) {
          url.searchParams.set(key, value instanceof Array ? value.join(",") : value.toString());
        }
      }
      buildUrl = url.toString();
    }
  }
  return buildUrl;
};
const verifyUrlorCreateDataUrl = (input) => {
  return input instanceof URL ? input.href : new URL(`data:text/plain;base64,${btoa(input)}`).href;
};
class EditorAppVscodeApi extends EditorAppBase {
  constructor(id, userConfig, logger) {
    super(id);
    __publicField(this, "config");
    __publicField(this, "extensionResult");
    __publicField(this, "logger");
    this.logger = logger;
    this.config = this.buildConfig(userConfig);
    const userInput = userConfig.wrapperConfig.editorAppConfig;
    this.config.userConfiguration = userInput.userConfiguration ?? void 0;
    this.config.extension = userInput.extension ?? void 0;
    this.config.extensionFilesOrContents = userInput.extensionFilesOrContents ?? void 0;
  }
  getAppType() {
    return "vscodeApi";
  }
  getConfig() {
    return this.config;
  }
  async createEditors(container) {
    if (this.config.useDiffEditor) {
      await this.createDiffEditor(container, this.getConfig());
    } else {
      await this.createEditor(container, this.getConfig());
    }
  }
  async init() {
    var _a3;
    if (this.config.extension) {
      const extension = this.config.extension;
      this.extensionResult = registerExtension(
        extension,
        1
        /* ExtensionHostKind.LocalProcess */
      );
      const extensionFilesOrContents = this.config.extensionFilesOrContents;
      if (extensionFilesOrContents) {
        for (const entry of extensionFilesOrContents) {
          this.extensionResult.registerFileUrl(entry[0], verifyUrlorCreateDataUrl(entry[1]));
        }
      }
    }
    await this.updateEditorOptions(this.config.userConfiguration ?? {});
    (_a3 = this.logger) == null ? void 0 : _a3.info("Init of VscodeApiConfig was completed.");
  }
  async updateEditorOptions(config) {
    if (config.json) {
      return updateUserConfiguration(config.json);
    }
  }
  disposeApp() {
    this.disposeEditor();
    this.disposeDiffEditor();
    this.extensionResult.dispose();
  }
}
var client = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(api$2);
var main$2 = {};
var main$1 = {};
var ril = {};
var api$1 = {};
var messages$1 = {};
var is$2 = {};
var hasRequiredIs$2;
function requireIs$2() {
  if (hasRequiredIs$2)
    return is$2;
  hasRequiredIs$2 = 1;
  Object.defineProperty(is$2, "__esModule", { value: true });
  is$2.stringArray = is$2.array = is$2.func = is$2.error = is$2.number = is$2.string = is$2.boolean = void 0;
  function boolean(value) {
    return value === true || value === false;
  }
  is$2.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  is$2.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  is$2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  is$2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  is$2.func = func;
  function array2(value) {
    return Array.isArray(value);
  }
  is$2.array = array2;
  function stringArray(value) {
    return array2(value) && value.every((elem) => string(elem));
  }
  is$2.stringArray = stringArray;
  return is$2;
}
var hasRequiredMessages$1;
function requireMessages$1() {
  if (hasRequiredMessages$1)
    return messages$1;
  hasRequiredMessages$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    const is2 = requireIs$2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
    class ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is2.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    }
    exports.ResponseError = ResponseError;
    class ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    }
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    class AbstractMessageSignature {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    }
    exports.AbstractMessageSignature = AbstractMessageSignature;
    class RequestType0 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    }
    exports.RequestType0 = RequestType0;
    class RequestType extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    exports.RequestType = RequestType;
    class RequestType1 extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    exports.RequestType1 = RequestType1;
    class RequestType2 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    }
    exports.RequestType2 = RequestType2;
    class RequestType3 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    }
    exports.RequestType3 = RequestType3;
    class RequestType4 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    }
    exports.RequestType4 = RequestType4;
    class RequestType5 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    }
    exports.RequestType5 = RequestType5;
    class RequestType6 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    }
    exports.RequestType6 = RequestType6;
    class RequestType7 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    }
    exports.RequestType7 = RequestType7;
    class RequestType8 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    }
    exports.RequestType8 = RequestType8;
    class RequestType9 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    }
    exports.RequestType9 = RequestType9;
    class NotificationType extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    exports.NotificationType = NotificationType;
    class NotificationType0 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    }
    exports.NotificationType0 = NotificationType0;
    class NotificationType1 extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    }
    exports.NotificationType1 = NotificationType1;
    class NotificationType2 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    }
    exports.NotificationType2 = NotificationType2;
    class NotificationType3 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    }
    exports.NotificationType3 = NotificationType3;
    class NotificationType4 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    }
    exports.NotificationType4 = NotificationType4;
    class NotificationType5 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    }
    exports.NotificationType5 = NotificationType5;
    class NotificationType6 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    }
    exports.NotificationType6 = NotificationType6;
    class NotificationType7 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    }
    exports.NotificationType7 = NotificationType7;
    class NotificationType8 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    }
    exports.NotificationType8 = NotificationType8;
    class NotificationType9 extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    }
    exports.NotificationType9 = NotificationType9;
    (function(Message) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is2.string(candidate.method) && (is2.string(candidate.id) || is2.number(candidate.id));
      }
      Message.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is2.string(candidate.method) && message.id === void 0;
      }
      Message.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is2.string(candidate.id) || is2.number(candidate.id) || candidate.id === null);
      }
      Message.isResponse = isResponse;
    })(exports.Message || (exports.Message = {}));
  })(messages$1);
  return messages$1;
}
var linkedMap = {};
var hasRequiredLinkedMap;
function requireLinkedMap() {
  if (hasRequiredLinkedMap)
    return linkedMap;
  hasRequiredLinkedMap = 1;
  (function(exports) {
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports.Touch || (exports.Touch = {}));
    class LinkedMap {
      constructor() {
        this[_a3] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a4;
        return (_a4 = this._head) == null ? void 0 : _a4.value;
      }
      get last() {
        var _a4;
        return (_a4 = this._tail) == null ? void 0 : _a4.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a3 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    }
    exports.LinkedMap = LinkedMap;
    class LRUCache2 extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    }
    exports.LRUCache = LRUCache2;
  })(linkedMap);
  return linkedMap;
}
var disposable = {};
var hasRequiredDisposable;
function requireDisposable() {
  if (hasRequiredDisposable)
    return disposable;
  hasRequiredDisposable = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(exports.Disposable || (exports.Disposable = {}));
  })(disposable);
  return disposable;
}
var events = {};
var ral = {};
var hasRequiredRal;
function requireRal() {
  if (hasRequiredRal)
    return ral;
  hasRequiredRal = 1;
  Object.defineProperty(ral, "__esModule", { value: true });
  let _ral;
  function RAL() {
    if (_ral === void 0) {
      throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
  }
  (function(RAL2) {
    function install(ral2) {
      if (ral2 === void 0) {
        throw new Error(`No runtime abstraction layer provided`);
      }
      _ral = ral2;
    }
    RAL2.install = install;
  })(RAL || (RAL = {}));
  ral.default = RAL;
  return ral;
}
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents)
    return events;
  hasRequiredEvents = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    const ral_1 = requireRal();
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(exports.Event || (exports.Event = {}));
    class CallbackList {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    }
    class Emitter2 {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter2._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    }
    exports.Emitter = Emitter2;
    Emitter2._noop = function() {
    };
  })(events);
  return events;
}
var cancellation = {};
var hasRequiredCancellation;
function requireCancellation() {
  if (hasRequiredCancellation)
    return cancellation;
  hasRequiredCancellation = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    const ral_1 = requireRal();
    const Is2 = requireIs$2();
    const events_1 = requireEvents();
    var CancellationToken2;
    (function(CancellationToken3) {
      CancellationToken3.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken3.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is2(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken3.None || candidate === CancellationToken3.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken3.is = is2;
    })(CancellationToken2 = exports.CancellationToken || (exports.CancellationToken = {}));
    const shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    class MutableToken {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    }
    class CancellationTokenSource2 {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken2.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken2.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    }
    exports.CancellationTokenSource = CancellationTokenSource2;
  })(cancellation);
  return cancellation;
}
var sharedArrayCancellation = {};
var hasRequiredSharedArrayCancellation;
function requireSharedArrayCancellation() {
  if (hasRequiredSharedArrayCancellation)
    return sharedArrayCancellation;
  hasRequiredSharedArrayCancellation = 1;
  Object.defineProperty(sharedArrayCancellation, "__esModule", { value: true });
  sharedArrayCancellation.SharedArrayReceiverStrategy = sharedArrayCancellation.SharedArraySenderStrategy = void 0;
  const cancellation_1 = requireCancellation();
  var CancellationState;
  (function(CancellationState2) {
    CancellationState2.Continue = 0;
    CancellationState2.Cancelled = 1;
  })(CancellationState || (CancellationState = {}));
  class SharedArraySenderStrategy {
    constructor() {
      this.buffers = /* @__PURE__ */ new Map();
    }
    enableCancellation(request) {
      if (request.id === null) {
        return;
      }
      const buffer = new SharedArrayBuffer(4);
      const data = new Int32Array(buffer, 0, 1);
      data[0] = CancellationState.Continue;
      this.buffers.set(request.id, buffer);
      request.$cancellationData = buffer;
    }
    async sendCancellation(_conn, id) {
      const buffer = this.buffers.get(id);
      if (buffer === void 0) {
        return;
      }
      const data = new Int32Array(buffer, 0, 1);
      Atomics.store(data, 0, CancellationState.Cancelled);
    }
    cleanup(id) {
      this.buffers.delete(id);
    }
    dispose() {
      this.buffers.clear();
    }
  }
  sharedArrayCancellation.SharedArraySenderStrategy = SharedArraySenderStrategy;
  class SharedArrayBufferCancellationToken {
    constructor(buffer) {
      this.data = new Int32Array(buffer, 0, 1);
    }
    get isCancellationRequested() {
      return Atomics.load(this.data, 0) === CancellationState.Cancelled;
    }
    get onCancellationRequested() {
      throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
    }
  }
  class SharedArrayBufferCancellationTokenSource {
    constructor(buffer) {
      this.token = new SharedArrayBufferCancellationToken(buffer);
    }
    cancel() {
    }
    dispose() {
    }
  }
  class SharedArrayReceiverStrategy {
    constructor() {
      this.kind = "request";
    }
    createCancellationTokenSource(request) {
      const buffer = request.$cancellationData;
      if (buffer === void 0) {
        return new cancellation_1.CancellationTokenSource();
      }
      return new SharedArrayBufferCancellationTokenSource(buffer);
    }
  }
  sharedArrayCancellation.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  return sharedArrayCancellation;
}
var messageReader = {};
var semaphore = {};
var hasRequiredSemaphore;
function requireSemaphore() {
  if (hasRequiredSemaphore)
    return semaphore;
  hasRequiredSemaphore = 1;
  Object.defineProperty(semaphore, "__esModule", { value: true });
  semaphore.Semaphore = void 0;
  const ral_1 = requireRal();
  class Semaphore {
    constructor(capacity = 1) {
      if (capacity <= 0) {
        throw new Error("Capacity must be greater than 0");
      }
      this._capacity = capacity;
      this._active = 0;
      this._waiting = [];
    }
    lock(thunk) {
      return new Promise((resolve, reject) => {
        this._waiting.push({ thunk, resolve, reject });
        this.runNext();
      });
    }
    get active() {
      return this._active;
    }
    runNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      const next = this._waiting.shift();
      this._active++;
      if (this._active > this._capacity) {
        throw new Error(`To many thunks active`);
      }
      try {
        const result = next.thunk();
        if (result instanceof Promise) {
          result.then((value) => {
            this._active--;
            next.resolve(value);
            this.runNext();
          }, (err) => {
            this._active--;
            next.reject(err);
            this.runNext();
          });
        } else {
          this._active--;
          next.resolve(result);
          this.runNext();
        }
      } catch (err) {
        this._active--;
        next.reject(err);
        this.runNext();
      }
    }
  }
  semaphore.Semaphore = Semaphore;
  return semaphore;
}
var hasRequiredMessageReader;
function requireMessageReader() {
  if (hasRequiredMessageReader)
    return messageReader;
  hasRequiredMessageReader = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    const ral_1 = requireRal();
    const Is2 = requireIs$2();
    const events_1 = requireEvents();
    const semaphore_1 = requireSemaphore();
    (function(MessageReader) {
      function is2(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader.is = is2;
    })(exports.MessageReader || (exports.MessageReader = {}));
    class AbstractMessageReader {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    }
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    class ReadableStreamMessageReader extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout2) {
        this._partialMessageTimeout = timeout2;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders(true);
            if (!headers) {
              return;
            }
            const contentLength = headers.get("content-length");
            if (!contentLength) {
              this.fireError(new Error("Header must provide a Content-Length property."));
              return;
            }
            const length2 = parseInt(contentLength);
            if (isNaN(length2)) {
              this.fireError(new Error("Content-Length value must be a number."));
              return;
            }
            this.nextMessageLength = length2;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          this.readSemaphore.lock(async () => {
            const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
            const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
            this.callback(message);
          }).catch((error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout2) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout2 });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    }
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  })(messageReader);
  return messageReader;
}
var messageWriter = {};
var hasRequiredMessageWriter;
function requireMessageWriter() {
  if (hasRequiredMessageWriter)
    return messageWriter;
  hasRequiredMessageWriter = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    const ral_1 = requireRal();
    const Is2 = requireIs$2();
    const semaphore_1 = requireSemaphore();
    const events_1 = requireEvents();
    const ContentLength = "Content-Length: ";
    const CRLF = "\r\n";
    (function(MessageWriter) {
      function is2(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter.is = is2;
    })(exports.MessageWriter || (exports.MessageWriter = {}));
    class AbstractMessageWriter {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    }
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    class WriteableStreamMessageWriter extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    }
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  })(messageWriter);
  return messageWriter;
}
var messageBuffer = {};
var hasRequiredMessageBuffer;
function requireMessageBuffer() {
  if (hasRequiredMessageBuffer)
    return messageBuffer;
  hasRequiredMessageBuffer = 1;
  Object.defineProperty(messageBuffer, "__esModule", { value: true });
  messageBuffer.AbstractMessageBuffer = void 0;
  const CR = 13;
  const LF = 10;
  const CRLF = "\r\n";
  class AbstractMessageBuffer {
    constructor(encoding = "utf-8") {
      this._encoding = encoding;
      this._chunks = [];
      this._totalLength = 0;
    }
    get encoding() {
      return this._encoding;
    }
    append(chunk) {
      const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
      this._chunks.push(toAppend);
      this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders(lowerCaseKeys = false) {
      if (this._chunks.length === 0) {
        return void 0;
      }
      let state = 0;
      let chunkIndex = 0;
      let offset = 0;
      let chunkBytesRead = 0;
      row:
        while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
      if (state !== 4) {
        return void 0;
      }
      const buffer = this._read(chunkBytesRead + offset);
      const result = /* @__PURE__ */ new Map();
      const headers = this.toString(buffer, "ascii").split(CRLF);
      if (headers.length < 2) {
        return result;
      }
      for (let i = 0; i < headers.length - 2; i++) {
        const header = headers[i];
        const index2 = header.indexOf(":");
        if (index2 === -1) {
          throw new Error("Message header must separate key and value using :");
        }
        const key = header.substr(0, index2);
        const value = header.substr(index2 + 1).trim();
        result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
      }
      return result;
    }
    tryReadBody(length2) {
      if (this._totalLength < length2) {
        return void 0;
      }
      return this._read(length2);
    }
    get numberOfBytes() {
      return this._totalLength;
    }
    _read(byteCount) {
      if (byteCount === 0) {
        return this.emptyBuffer();
      }
      if (byteCount > this._totalLength) {
        throw new Error(`Cannot read so many bytes!`);
      }
      if (this._chunks[0].byteLength === byteCount) {
        const chunk = this._chunks[0];
        this._chunks.shift();
        this._totalLength -= byteCount;
        return this.asNative(chunk);
      }
      if (this._chunks[0].byteLength > byteCount) {
        const chunk = this._chunks[0];
        const result2 = this.asNative(chunk, byteCount);
        this._chunks[0] = chunk.slice(byteCount);
        this._totalLength -= byteCount;
        return result2;
      }
      const result = this.allocNative(byteCount);
      let resultOffset = 0;
      let chunkIndex = 0;
      while (byteCount > 0) {
        const chunk = this._chunks[chunkIndex];
        if (chunk.byteLength > byteCount) {
          const chunkPart = chunk.slice(0, byteCount);
          result.set(chunkPart, resultOffset);
          resultOffset += byteCount;
          this._chunks[chunkIndex] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          byteCount -= byteCount;
        } else {
          result.set(chunk, resultOffset);
          resultOffset += chunk.byteLength;
          this._chunks.shift();
          this._totalLength -= chunk.byteLength;
          byteCount -= chunk.byteLength;
        }
      }
      return result;
    }
  }
  messageBuffer.AbstractMessageBuffer = AbstractMessageBuffer;
  return messageBuffer;
}
var connection$1 = {};
var hasRequiredConnection$1;
function requireConnection$1() {
  if (hasRequiredConnection$1)
    return connection$1;
  hasRequiredConnection$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
    const ral_1 = requireRal();
    const Is2 = requireIs$2();
    const messages_1 = requireMessages$1();
    const linkedMap_1 = requireLinkedMap();
    const events_1 = requireEvents();
    const cancellation_1 = requireCancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is2(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is2;
    })(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    class ProgressType {
      constructor() {
      }
    }
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is2(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is2;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace = exports.Trace || (exports.Trace = {}));
    (function(TraceValues) {
      TraceValues.Off = "off";
      TraceValues.Messages = "messages";
      TraceValues.Compact = "compact";
      TraceValues.Verbose = "verbose";
    })(exports.TraceValues || (exports.TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports.Trace || (exports.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
    class ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    }
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is2(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is2;
    })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is2(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is2;
    })(IdCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is2(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is2;
    })(RequestCancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is2(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is2;
    })(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is2(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is2;
    })(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is2(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is2;
    })(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is2(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is2;
    })(MessageStrategy = exports.MessageStrategy || (exports.MessageStrategy = {}));
    (function(ConnectionOptions) {
      function is2(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions.is = is2;
    })(exports.ConnectionOptions || (exports.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader2, messageWriter2, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader2.onClose(closeHandler);
      messageReader2.onError(readErrorHandler);
      messageWriter2.onClose(closeHandler);
      messageWriter2.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options == null ? void 0 : options.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options == null ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter2.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type)) {
            method = type;
            const first2 = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first2)) {
              paramStart = 1;
              parameterStructures = first2;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter2.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is2.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type)) {
            method = type;
            const first2 = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first2)) {
              paramStart = 1;
              parameterStructures = first2;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable2;
          if (token) {
            disposable2 = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable2 == null ? void 0 : disposable2.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable2 == null ? void 0 : disposable2.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter2.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is2.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter2.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter2.dispose)) {
            messageWriter2.dispose();
          }
          if (Is2.func(messageReader2.dispose)) {
            messageReader2.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader2.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports.createMessageConnection = createMessageConnection;
  })(connection$1);
  return connection$1;
}
var hasRequiredApi$1;
function requireApi$1() {
  if (hasRequiredApi$1)
    return api$1;
  hasRequiredApi$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
    exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
    const messages_1 = requireMessages$1();
    Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    const linkedMap_1 = requireLinkedMap();
    Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    const disposable_1 = requireDisposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    const events_1 = requireEvents();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    const cancellation_1 = requireCancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    const sharedArrayCancellation_1 = requireSharedArrayCancellation();
    Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    const messageReader_1 = requireMessageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    const messageWriter_1 = requireMessageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    const messageBuffer_1 = requireMessageBuffer();
    Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    const connection_1 = requireConnection$1();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    const ral_1 = requireRal();
    exports.RAL = ral_1.default;
  })(api$1);
  return api$1;
}
var hasRequiredRil;
function requireRil() {
  if (hasRequiredRil)
    return ril;
  hasRequiredRil = 1;
  Object.defineProperty(ril, "__esModule", { value: true });
  const api_1 = requireApi$1();
  class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = "utf-8") {
      super(encoding);
      this.asciiDecoder = new TextDecoder("ascii");
    }
    emptyBuffer() {
      return MessageBuffer.emptyBuffer;
    }
    fromString(value, _encoding) {
      return new TextEncoder().encode(value);
    }
    toString(value, encoding) {
      if (encoding === "ascii") {
        return this.asciiDecoder.decode(value);
      } else {
        return new TextDecoder(encoding).decode(value);
      }
    }
    asNative(buffer, length2) {
      if (length2 === void 0) {
        return buffer;
      } else {
        return buffer.slice(0, length2);
      }
    }
    allocNative(length2) {
      return new Uint8Array(length2);
    }
  }
  MessageBuffer.emptyBuffer = new Uint8Array(0);
  class ReadableStreamWrapper {
    constructor(socket) {
      this.socket = socket;
      this._onData = new api_1.Emitter();
      this._messageListener = (event) => {
        const blob = event.data;
        blob.arrayBuffer().then((buffer) => {
          this._onData.fire(new Uint8Array(buffer));
        }, () => {
          (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
        });
      };
      this.socket.addEventListener("message", this._messageListener);
    }
    onClose(listener) {
      this.socket.addEventListener("close", listener);
      return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
    }
    onError(listener) {
      this.socket.addEventListener("error", listener);
      return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
    }
    onEnd(listener) {
      this.socket.addEventListener("end", listener);
      return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
    }
    onData(listener) {
      return this._onData.event(listener);
    }
  }
  class WritableStreamWrapper {
    constructor(socket) {
      this.socket = socket;
    }
    onClose(listener) {
      this.socket.addEventListener("close", listener);
      return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
    }
    onError(listener) {
      this.socket.addEventListener("error", listener);
      return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
    }
    onEnd(listener) {
      this.socket.addEventListener("end", listener);
      return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
    }
    write(data, encoding) {
      if (typeof data === "string") {
        if (encoding !== void 0 && encoding !== "utf-8") {
          throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
        }
        this.socket.send(data);
      } else {
        this.socket.send(data);
      }
      return Promise.resolve();
    }
    end() {
      this.socket.close();
    }
  }
  const _textEncoder = new TextEncoder();
  const _ril = Object.freeze({
    messageBuffer: Object.freeze({
      create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
      encoder: Object.freeze({
        name: "application/json",
        encode: (msg, options) => {
          if (options.charset !== "utf-8") {
            throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
          }
          return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
        }
      }),
      decoder: Object.freeze({
        name: "application/json",
        decode: (buffer, options) => {
          if (!(buffer instanceof Uint8Array)) {
            throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
          }
          return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
        }
      })
    }),
    stream: Object.freeze({
      asReadableStream: (socket) => new ReadableStreamWrapper(socket),
      asWritableStream: (socket) => new WritableStreamWrapper(socket)
    }),
    console,
    timer: Object.freeze({
      setTimeout(callback, ms, ...args) {
        const handle = setTimeout(callback, ms, ...args);
        return { dispose: () => clearTimeout(handle) };
      },
      setImmediate(callback, ...args) {
        const handle = setTimeout(callback, 0, ...args);
        return { dispose: () => clearTimeout(handle) };
      },
      setInterval(callback, ms, ...args) {
        const handle = setInterval(callback, ms, ...args);
        return { dispose: () => clearInterval(handle) };
      }
    })
  });
  function RIL() {
    return _ril;
  }
  (function(RIL2) {
    function install() {
      api_1.RAL.install(_ril);
    }
    RIL2.install = install;
  })(RIL || (RIL = {}));
  ril.default = RIL;
  return ril;
}
var hasRequiredMain$1;
function requireMain$1() {
  if (hasRequiredMain$1)
    return main$1;
  hasRequiredMain$1 = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
    const ril_1 = requireRil();
    ril_1.default.install();
    const api_1 = requireApi$1();
    __exportStar(requireApi$1(), exports);
    class BrowserMessageReader extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
          this._onData.fire(event.data);
        };
        port.addEventListener("error", (event) => this.fireError(event));
        port.onmessage = this._messageListener;
      }
      listen(callback) {
        return this._onData.event(callback);
      }
    }
    exports.BrowserMessageReader = BrowserMessageReader;
    class BrowserMessageWriter extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.addEventListener("error", (event) => this.fireError(event));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    }
    exports.BrowserMessageWriter = BrowserMessageWriter;
    function createMessageConnection(reader, writer, logger, options) {
      if (logger === void 0) {
        logger = api_1.NullLogger;
      }
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  })(main$1);
  return main$1;
}
var browser$1;
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$1;
  hasRequiredBrowser$1 = 1;
  browser$1 = requireMain$1();
  return browser$1;
}
var api = {};
var DocumentUri;
(function(DocumentUri2) {
  function is2(value) {
    return typeof value === "string";
  }
  DocumentUri2.is = is2;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function(URI2) {
  function is2(value) {
    return typeof value === "string";
  }
  URI2.is = is2;
})(URI || (URI = {}));
var integer;
(function(integer2) {
  integer2.MIN_VALUE = -2147483648;
  integer2.MAX_VALUE = 2147483647;
  function is2(value) {
    return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
  }
  integer2.is = is2;
})(integer || (integer = {}));
var uinteger;
(function(uinteger2) {
  uinteger2.MIN_VALUE = 0;
  uinteger2.MAX_VALUE = 2147483647;
  function is2(value) {
    return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
  }
  uinteger2.is = is2;
})(uinteger || (uinteger = {}));
var Position;
(function(Position2) {
  function create(line, character) {
    if (line === Number.MAX_VALUE) {
      line = uinteger.MAX_VALUE;
    }
    if (character === Number.MAX_VALUE) {
      character = uinteger.MAX_VALUE;
    }
    return { line, character };
  }
  Position2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
  }
  Position2.is = is2;
})(Position || (Position = {}));
var Range;
(function(Range2) {
  function create(one, two, three, four) {
    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
      return { start: Position.create(one, two), end: Position.create(three, four) };
    } else if (Position.is(one) && Position.is(two)) {
      return { start: one, end: two };
    } else {
      throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
    }
  }
  Range2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
  }
  Range2.is = is2;
})(Range || (Range = {}));
var Location;
(function(Location2) {
  function create(uri, range) {
    return { uri, range };
  }
  Location2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
  }
  Location2.is = is2;
})(Location || (Location = {}));
var LocationLink;
(function(LocationLink2) {
  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
  }
  LocationLink2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
  }
  LocationLink2.is = is2;
})(LocationLink || (LocationLink = {}));
var Color;
(function(Color2) {
  function create(red, green, blue, alpha) {
    return {
      red,
      green,
      blue,
      alpha
    };
  }
  Color2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
  }
  Color2.is = is2;
})(Color || (Color = {}));
var ColorInformation;
(function(ColorInformation2) {
  function create(range, color) {
    return {
      range,
      color
    };
  }
  ColorInformation2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
  }
  ColorInformation2.is = is2;
})(ColorInformation || (ColorInformation = {}));
var ColorPresentation;
(function(ColorPresentation2) {
  function create(label, textEdit, additionalTextEdits) {
    return {
      label,
      textEdit,
      additionalTextEdits
    };
  }
  ColorPresentation2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
  }
  ColorPresentation2.is = is2;
})(ColorPresentation || (ColorPresentation = {}));
var FoldingRangeKind;
(function(FoldingRangeKind2) {
  FoldingRangeKind2.Comment = "comment";
  FoldingRangeKind2.Imports = "imports";
  FoldingRangeKind2.Region = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
var FoldingRange;
(function(FoldingRange2) {
  function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
    var result = {
      startLine,
      endLine
    };
    if (Is.defined(startCharacter)) {
      result.startCharacter = startCharacter;
    }
    if (Is.defined(endCharacter)) {
      result.endCharacter = endCharacter;
    }
    if (Is.defined(kind)) {
      result.kind = kind;
    }
    if (Is.defined(collapsedText)) {
      result.collapsedText = collapsedText;
    }
    return result;
  }
  FoldingRange2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
  }
  FoldingRange2.is = is2;
})(FoldingRange || (FoldingRange = {}));
var DiagnosticRelatedInformation;
(function(DiagnosticRelatedInformation2) {
  function create(location, message) {
    return {
      location,
      message
    };
  }
  DiagnosticRelatedInformation2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
  }
  DiagnosticRelatedInformation2.is = is2;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
var DiagnosticSeverity;
(function(DiagnosticSeverity2) {
  DiagnosticSeverity2.Error = 1;
  DiagnosticSeverity2.Warning = 2;
  DiagnosticSeverity2.Information = 3;
  DiagnosticSeverity2.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var DiagnosticTag;
(function(DiagnosticTag2) {
  DiagnosticTag2.Unnecessary = 1;
  DiagnosticTag2.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
var CodeDescription;
(function(CodeDescription2) {
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.href);
  }
  CodeDescription2.is = is2;
})(CodeDescription || (CodeDescription = {}));
var Diagnostic;
(function(Diagnostic2) {
  function create(range, message, severity, code, source, relatedInformation) {
    var result = { range, message };
    if (Is.defined(severity)) {
      result.severity = severity;
    }
    if (Is.defined(code)) {
      result.code = code;
    }
    if (Is.defined(source)) {
      result.source = source;
    }
    if (Is.defined(relatedInformation)) {
      result.relatedInformation = relatedInformation;
    }
    return result;
  }
  Diagnostic2.create = create;
  function is2(value) {
    var _a3;
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a3 = candidate.codeDescription) === null || _a3 === void 0 ? void 0 : _a3.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
  }
  Diagnostic2.is = is2;
})(Diagnostic || (Diagnostic = {}));
var Command;
(function(Command2) {
  function create(title, command) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    var result = { title, command };
    if (Is.defined(args) && args.length > 0) {
      result.arguments = args;
    }
    return result;
  }
  Command2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
  }
  Command2.is = is2;
})(Command || (Command = {}));
var TextEdit;
(function(TextEdit2) {
  function replace(range, newText) {
    return { range, newText };
  }
  TextEdit2.replace = replace;
  function insert(position, newText) {
    return { range: { start: position, end: position }, newText };
  }
  TextEdit2.insert = insert;
  function del(range) {
    return { range, newText: "" };
  }
  TextEdit2.del = del;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
  }
  TextEdit2.is = is2;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function(ChangeAnnotation2) {
  function create(label, needsConfirmation, description) {
    var result = { label };
    if (needsConfirmation !== void 0) {
      result.needsConfirmation = needsConfirmation;
    }
    if (description !== void 0) {
      result.description = description;
    }
    return result;
  }
  ChangeAnnotation2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
  }
  ChangeAnnotation2.is = is2;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function(ChangeAnnotationIdentifier2) {
  function is2(value) {
    var candidate = value;
    return Is.string(candidate);
  }
  ChangeAnnotationIdentifier2.is = is2;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function(AnnotatedTextEdit2) {
  function replace(range, newText, annotation) {
    return { range, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.replace = replace;
  function insert(position, newText, annotation) {
    return { range: { start: position, end: position }, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.insert = insert;
  function del(range, annotation) {
    return { range, newText: "", annotationId: annotation };
  }
  AnnotatedTextEdit2.del = del;
  function is2(value) {
    var candidate = value;
    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  AnnotatedTextEdit2.is = is2;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
var TextDocumentEdit;
(function(TextDocumentEdit2) {
  function create(textDocument, edits) {
    return { textDocument, edits };
  }
  TextDocumentEdit2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
  }
  TextDocumentEdit2.is = is2;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function(CreateFile2) {
  function create(uri, options, annotation) {
    var result = {
      kind: "create",
      uri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  CreateFile2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  CreateFile2.is = is2;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function(RenameFile2) {
  function create(oldUri, newUri, options, annotation) {
    var result = {
      kind: "rename",
      oldUri,
      newUri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  RenameFile2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  RenameFile2.is = is2;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function(DeleteFile2) {
  function create(uri, options, annotation) {
    var result = {
      kind: "delete",
      uri
    };
    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  DeleteFile2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  DeleteFile2.is = is2;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function(WorkspaceEdit2) {
  function is2(value) {
    var candidate = value;
    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
      if (Is.string(change.kind)) {
        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
      } else {
        return TextDocumentEdit.is(change);
      }
    }));
  }
  WorkspaceEdit2.is = is2;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = (
  /** @class */
  function() {
    function TextEditChangeImpl2(edits, changeAnnotations) {
      this.edits = edits;
      this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
      var edit;
      var id;
      if (annotation === void 0) {
        edit = TextEdit.insert(position, newText);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.insert(position, newText, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.insert(position, newText, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    };
    TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
      var edit;
      var id;
      if (annotation === void 0) {
        edit = TextEdit.replace(range, newText);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.replace(range, newText, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.replace(range, newText, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    };
    TextEditChangeImpl2.prototype.delete = function(range, annotation) {
      var edit;
      var id;
      if (annotation === void 0) {
        edit = TextEdit.del(range);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.del(range, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.del(range, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    };
    TextEditChangeImpl2.prototype.add = function(edit) {
      this.edits.push(edit);
    };
    TextEditChangeImpl2.prototype.all = function() {
      return this.edits;
    };
    TextEditChangeImpl2.prototype.clear = function() {
      this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
      if (value === void 0) {
        throw new Error("Text edit change is not configured to manage change annotations.");
      }
    };
    return TextEditChangeImpl2;
  }()
);
var ChangeAnnotations = (
  /** @class */
  function() {
    function ChangeAnnotations2(annotations) {
      this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
      this._counter = 0;
      this._size = 0;
    }
    ChangeAnnotations2.prototype.all = function() {
      return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations2.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
      var id;
      if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
        id = idOrAnnotation;
      } else {
        id = this.nextId();
        annotation = idOrAnnotation;
      }
      if (this._annotations[id] !== void 0) {
        throw new Error("Id ".concat(id, " is already in use."));
      }
      if (annotation === void 0) {
        throw new Error("No annotation provided for id ".concat(id));
      }
      this._annotations[id] = annotation;
      this._size++;
      return id;
    };
    ChangeAnnotations2.prototype.nextId = function() {
      this._counter++;
      return this._counter.toString();
    };
    return ChangeAnnotations2;
  }()
);
var WorkspaceChange = (
  /** @class */
  function() {
    function WorkspaceChange2(workspaceEdit) {
      var _this = this;
      this._textEditChanges = /* @__PURE__ */ Object.create(null);
      if (workspaceEdit !== void 0) {
        this._workspaceEdit = workspaceEdit;
        if (workspaceEdit.documentChanges) {
          this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
          workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          workspaceEdit.documentChanges.forEach(function(change) {
            if (TextDocumentEdit.is(change)) {
              var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
              _this._textEditChanges[change.textDocument.uri] = textEditChange;
            }
          });
        } else if (workspaceEdit.changes) {
          Object.keys(workspaceEdit.changes).forEach(function(key) {
            var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
            _this._textEditChanges[key] = textEditChange;
          });
        }
      } else {
        this._workspaceEdit = {};
      }
    }
    Object.defineProperty(WorkspaceChange2.prototype, "edit", {
      /**
       * Returns the underlying {@link WorkspaceEdit} literal
       * use to be returned from a workspace edit operation like rename.
       */
      get: function() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== void 0) {
          if (this._changeAnnotations.size === 0) {
            this._workspaceEdit.changeAnnotations = void 0;
          } else {
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        return this._workspaceEdit;
      },
      enumerable: false,
      configurable: true
    });
    WorkspaceChange2.prototype.getTextEditChange = function(key) {
      if (OptionalVersionedTextDocumentIdentifier.is(key)) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var textDocument = { uri: key.uri, version: key.version };
        var result = this._textEditChanges[textDocument.uri];
        if (!result) {
          var edits = [];
          var textDocumentEdit = {
            textDocument,
            edits
          };
          this._workspaceEdit.documentChanges.push(textDocumentEdit);
          result = new TextEditChangeImpl(edits, this._changeAnnotations);
          this._textEditChanges[textDocument.uri] = result;
        }
        return result;
      } else {
        this.initChanges();
        if (this._workspaceEdit.changes === void 0) {
          throw new Error("Workspace edit is not configured for normal text edit changes.");
        }
        var result = this._textEditChanges[key];
        if (!result) {
          var edits = [];
          this._workspaceEdit.changes[key] = edits;
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[key] = result;
        }
        return result;
      }
    };
    WorkspaceChange2.prototype.initDocumentChanges = function() {
      if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
        this._changeAnnotations = new ChangeAnnotations();
        this._workspaceEdit.documentChanges = [];
        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
      }
    };
    WorkspaceChange2.prototype.initChanges = function() {
      if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
        this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
      }
    };
    WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      var operation;
      var id;
      if (annotation === void 0) {
        operation = CreateFile.create(uri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = CreateFile.create(uri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    };
    WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      var operation;
      var id;
      if (annotation === void 0) {
        operation = RenameFile.create(oldUri, newUri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = RenameFile.create(oldUri, newUri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    };
    WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      var operation;
      var id;
      if (annotation === void 0) {
        operation = DeleteFile.create(uri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = DeleteFile.create(uri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    };
    return WorkspaceChange2;
  }()
);
var TextDocumentIdentifier;
(function(TextDocumentIdentifier2) {
  function create(uri) {
    return { uri };
  }
  TextDocumentIdentifier2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri);
  }
  TextDocumentIdentifier2.is = is2;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
var VersionedTextDocumentIdentifier;
(function(VersionedTextDocumentIdentifier2) {
  function create(uri, version) {
    return { uri, version };
  }
  VersionedTextDocumentIdentifier2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
  }
  VersionedTextDocumentIdentifier2.is = is2;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
var OptionalVersionedTextDocumentIdentifier;
(function(OptionalVersionedTextDocumentIdentifier2) {
  function create(uri, version) {
    return { uri, version };
  }
  OptionalVersionedTextDocumentIdentifier2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
  }
  OptionalVersionedTextDocumentIdentifier2.is = is2;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
var TextDocumentItem;
(function(TextDocumentItem2) {
  function create(uri, languageId, version, text) {
    return { uri, languageId, version, text };
  }
  TextDocumentItem2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
  }
  TextDocumentItem2.is = is2;
})(TextDocumentItem || (TextDocumentItem = {}));
var MarkupKind;
(function(MarkupKind2) {
  MarkupKind2.PlainText = "plaintext";
  MarkupKind2.Markdown = "markdown";
  function is2(value) {
    var candidate = value;
    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
  }
  MarkupKind2.is = is2;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function(MarkupContent2) {
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
  }
  MarkupContent2.is = is2;
})(MarkupContent || (MarkupContent = {}));
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2.Text = 1;
  CompletionItemKind2.Method = 2;
  CompletionItemKind2.Function = 3;
  CompletionItemKind2.Constructor = 4;
  CompletionItemKind2.Field = 5;
  CompletionItemKind2.Variable = 6;
  CompletionItemKind2.Class = 7;
  CompletionItemKind2.Interface = 8;
  CompletionItemKind2.Module = 9;
  CompletionItemKind2.Property = 10;
  CompletionItemKind2.Unit = 11;
  CompletionItemKind2.Value = 12;
  CompletionItemKind2.Enum = 13;
  CompletionItemKind2.Keyword = 14;
  CompletionItemKind2.Snippet = 15;
  CompletionItemKind2.Color = 16;
  CompletionItemKind2.File = 17;
  CompletionItemKind2.Reference = 18;
  CompletionItemKind2.Folder = 19;
  CompletionItemKind2.EnumMember = 20;
  CompletionItemKind2.Constant = 21;
  CompletionItemKind2.Struct = 22;
  CompletionItemKind2.Event = 23;
  CompletionItemKind2.Operator = 24;
  CompletionItemKind2.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
var InsertTextFormat;
(function(InsertTextFormat2) {
  InsertTextFormat2.PlainText = 1;
  InsertTextFormat2.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
var InsertReplaceEdit;
(function(InsertReplaceEdit2) {
  function create(newText, insert, replace) {
    return { newText, insert, replace };
  }
  InsertReplaceEdit2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
  }
  InsertReplaceEdit2.is = is2;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
var InsertTextMode;
(function(InsertTextMode2) {
  InsertTextMode2.asIs = 1;
  InsertTextMode2.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function(CompletionItemLabelDetails2) {
  function is2(value) {
    var candidate = value;
    return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
  }
  CompletionItemLabelDetails2.is = is2;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
var CompletionItem;
(function(CompletionItem2) {
  function create(label) {
    return { label };
  }
  CompletionItem2.create = create;
})(CompletionItem || (CompletionItem = {}));
var CompletionList;
(function(CompletionList2) {
  function create(items, isIncomplete) {
    return { items: items ? items : [], isIncomplete: !!isIncomplete };
  }
  CompletionList2.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function(MarkedString2) {
  function fromPlainText(plainText) {
    return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  MarkedString2.fromPlainText = fromPlainText;
  function is2(value) {
    var candidate = value;
    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
  }
  MarkedString2.is = is2;
})(MarkedString || (MarkedString = {}));
var Hover;
(function(Hover2) {
  function is2(value) {
    var candidate = value;
    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
  }
  Hover2.is = is2;
})(Hover || (Hover = {}));
var ParameterInformation;
(function(ParameterInformation2) {
  function create(label, documentation) {
    return documentation ? { label, documentation } : { label };
  }
  ParameterInformation2.create = create;
})(ParameterInformation || (ParameterInformation = {}));
var SignatureInformation;
(function(SignatureInformation2) {
  function create(label, documentation) {
    var parameters = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      parameters[_i2 - 2] = arguments[_i2];
    }
    var result = { label };
    if (Is.defined(documentation)) {
      result.documentation = documentation;
    }
    if (Is.defined(parameters)) {
      result.parameters = parameters;
    } else {
      result.parameters = [];
    }
    return result;
  }
  SignatureInformation2.create = create;
})(SignatureInformation || (SignatureInformation = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind2) {
  DocumentHighlightKind2.Text = 1;
  DocumentHighlightKind2.Read = 2;
  DocumentHighlightKind2.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var DocumentHighlight;
(function(DocumentHighlight2) {
  function create(range, kind) {
    var result = { range };
    if (Is.number(kind)) {
      result.kind = kind;
    }
    return result;
  }
  DocumentHighlight2.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2.File = 1;
  SymbolKind2.Module = 2;
  SymbolKind2.Namespace = 3;
  SymbolKind2.Package = 4;
  SymbolKind2.Class = 5;
  SymbolKind2.Method = 6;
  SymbolKind2.Property = 7;
  SymbolKind2.Field = 8;
  SymbolKind2.Constructor = 9;
  SymbolKind2.Enum = 10;
  SymbolKind2.Interface = 11;
  SymbolKind2.Function = 12;
  SymbolKind2.Variable = 13;
  SymbolKind2.Constant = 14;
  SymbolKind2.String = 15;
  SymbolKind2.Number = 16;
  SymbolKind2.Boolean = 17;
  SymbolKind2.Array = 18;
  SymbolKind2.Object = 19;
  SymbolKind2.Key = 20;
  SymbolKind2.Null = 21;
  SymbolKind2.EnumMember = 22;
  SymbolKind2.Struct = 23;
  SymbolKind2.Event = 24;
  SymbolKind2.Operator = 25;
  SymbolKind2.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function(SymbolInformation2) {
  function create(name, kind, range, uri, containerName) {
    var result = {
      name,
      kind,
      location: { uri, range }
    };
    if (containerName) {
      result.containerName = containerName;
    }
    return result;
  }
  SymbolInformation2.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function(WorkspaceSymbol2) {
  function create(name, kind, uri, range) {
    return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
  }
  WorkspaceSymbol2.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function(DocumentSymbol2) {
  function create(name, detail, kind, range, selectionRange2, children) {
    var result = {
      name,
      detail,
      kind,
      range,
      selectionRange: selectionRange2
    };
    if (children !== void 0) {
      result.children = children;
    }
    return result;
  }
  DocumentSymbol2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
  }
  DocumentSymbol2.is = is2;
})(DocumentSymbol || (DocumentSymbol = {}));
var CodeActionKind;
(function(CodeActionKind2) {
  CodeActionKind2.Empty = "";
  CodeActionKind2.QuickFix = "quickfix";
  CodeActionKind2.Refactor = "refactor";
  CodeActionKind2.RefactorExtract = "refactor.extract";
  CodeActionKind2.RefactorInline = "refactor.inline";
  CodeActionKind2.RefactorRewrite = "refactor.rewrite";
  CodeActionKind2.Source = "source";
  CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
  CodeActionKind2.SourceFixAll = "source.fixAll";
})(CodeActionKind || (CodeActionKind = {}));
var CodeActionTriggerKind;
(function(CodeActionTriggerKind2) {
  CodeActionTriggerKind2.Invoked = 1;
  CodeActionTriggerKind2.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
var CodeActionContext;
(function(CodeActionContext2) {
  function create(diagnostics, only, triggerKind) {
    var result = { diagnostics };
    if (only !== void 0 && only !== null) {
      result.only = only;
    }
    if (triggerKind !== void 0 && triggerKind !== null) {
      result.triggerKind = triggerKind;
    }
    return result;
  }
  CodeActionContext2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
  }
  CodeActionContext2.is = is2;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function(CodeAction2) {
  function create(title, kindOrCommandOrEdit, kind) {
    var result = { title };
    var checkKind = true;
    if (typeof kindOrCommandOrEdit === "string") {
      checkKind = false;
      result.kind = kindOrCommandOrEdit;
    } else if (Command.is(kindOrCommandOrEdit)) {
      result.command = kindOrCommandOrEdit;
    } else {
      result.edit = kindOrCommandOrEdit;
    }
    if (checkKind && kind !== void 0) {
      result.kind = kind;
    }
    return result;
  }
  CodeAction2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
  }
  CodeAction2.is = is2;
})(CodeAction || (CodeAction = {}));
var CodeLens;
(function(CodeLens2) {
  function create(range, data) {
    var result = { range };
    if (Is.defined(data)) {
      result.data = data;
    }
    return result;
  }
  CodeLens2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
  }
  CodeLens2.is = is2;
})(CodeLens || (CodeLens = {}));
var FormattingOptions;
(function(FormattingOptions2) {
  function create(tabSize, insertSpaces) {
    return { tabSize, insertSpaces };
  }
  FormattingOptions2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
  }
  FormattingOptions2.is = is2;
})(FormattingOptions || (FormattingOptions = {}));
var DocumentLink;
(function(DocumentLink2) {
  function create(range, target, data) {
    return { range, target, data };
  }
  DocumentLink2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
  }
  DocumentLink2.is = is2;
})(DocumentLink || (DocumentLink = {}));
var SelectionRange;
(function(SelectionRange2) {
  function create(range, parent) {
    return { range, parent };
  }
  SelectionRange2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
  }
  SelectionRange2.is = is2;
})(SelectionRange || (SelectionRange = {}));
var SemanticTokenTypes;
(function(SemanticTokenTypes2) {
  SemanticTokenTypes2["namespace"] = "namespace";
  SemanticTokenTypes2["type"] = "type";
  SemanticTokenTypes2["class"] = "class";
  SemanticTokenTypes2["enum"] = "enum";
  SemanticTokenTypes2["interface"] = "interface";
  SemanticTokenTypes2["struct"] = "struct";
  SemanticTokenTypes2["typeParameter"] = "typeParameter";
  SemanticTokenTypes2["parameter"] = "parameter";
  SemanticTokenTypes2["variable"] = "variable";
  SemanticTokenTypes2["property"] = "property";
  SemanticTokenTypes2["enumMember"] = "enumMember";
  SemanticTokenTypes2["event"] = "event";
  SemanticTokenTypes2["function"] = "function";
  SemanticTokenTypes2["method"] = "method";
  SemanticTokenTypes2["macro"] = "macro";
  SemanticTokenTypes2["keyword"] = "keyword";
  SemanticTokenTypes2["modifier"] = "modifier";
  SemanticTokenTypes2["comment"] = "comment";
  SemanticTokenTypes2["string"] = "string";
  SemanticTokenTypes2["number"] = "number";
  SemanticTokenTypes2["regexp"] = "regexp";
  SemanticTokenTypes2["operator"] = "operator";
  SemanticTokenTypes2["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
var SemanticTokenModifiers;
(function(SemanticTokenModifiers2) {
  SemanticTokenModifiers2["declaration"] = "declaration";
  SemanticTokenModifiers2["definition"] = "definition";
  SemanticTokenModifiers2["readonly"] = "readonly";
  SemanticTokenModifiers2["static"] = "static";
  SemanticTokenModifiers2["deprecated"] = "deprecated";
  SemanticTokenModifiers2["abstract"] = "abstract";
  SemanticTokenModifiers2["async"] = "async";
  SemanticTokenModifiers2["modification"] = "modification";
  SemanticTokenModifiers2["documentation"] = "documentation";
  SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
var SemanticTokens;
(function(SemanticTokens2) {
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
  }
  SemanticTokens2.is = is2;
})(SemanticTokens || (SemanticTokens = {}));
var InlineValueText;
(function(InlineValueText2) {
  function create(range, text) {
    return { range, text };
  }
  InlineValueText2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
  }
  InlineValueText2.is = is2;
})(InlineValueText || (InlineValueText = {}));
var InlineValueVariableLookup;
(function(InlineValueVariableLookup2) {
  function create(range, variableName, caseSensitiveLookup) {
    return { range, variableName, caseSensitiveLookup };
  }
  InlineValueVariableLookup2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
  }
  InlineValueVariableLookup2.is = is2;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
var InlineValueEvaluatableExpression;
(function(InlineValueEvaluatableExpression2) {
  function create(range, expression) {
    return { range, expression };
  }
  InlineValueEvaluatableExpression2.create = create;
  function is2(value) {
    var candidate = value;
    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
  }
  InlineValueEvaluatableExpression2.is = is2;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
var InlineValueContext;
(function(InlineValueContext2) {
  function create(frameId, stoppedLocation) {
    return { frameId, stoppedLocation };
  }
  InlineValueContext2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(value.stoppedLocation);
  }
  InlineValueContext2.is = is2;
})(InlineValueContext || (InlineValueContext = {}));
var InlayHintKind;
(function(InlayHintKind2) {
  InlayHintKind2.Type = 1;
  InlayHintKind2.Parameter = 2;
  function is2(value) {
    return value === 1 || value === 2;
  }
  InlayHintKind2.is = is2;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function(InlayHintLabelPart2) {
  function create(value) {
    return { value };
  }
  InlayHintLabelPart2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
  }
  InlayHintLabelPart2.is = is2;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function(InlayHint2) {
  function create(position, label, kind) {
    var result = { position, label };
    if (kind !== void 0) {
      result.kind = kind;
    }
    return result;
  }
  InlayHint2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
  }
  InlayHint2.is = is2;
})(InlayHint || (InlayHint = {}));
var WorkspaceFolder;
(function(WorkspaceFolder2) {
  function is2(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
  }
  WorkspaceFolder2.is = is2;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var EOL = ["\n", "\r\n", "\r"];
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument(uri, languageId, version, content);
  }
  TextDocument2.create = create;
  function is2(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
  }
  TextDocument2.is = is2;
  function applyEdits2(document2, edits) {
    var text = document2.getText();
    var sortedEdits = mergeSort(edits, function(a, b) {
      var diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    var lastModifiedOffset = text.length;
    for (var i = sortedEdits.length - 1; i >= 0; i--) {
      var e = sortedEdits[i];
      var startOffset = document2.offsetAt(e.range.start);
      var endOffset = document2.offsetAt(e.range.end);
      if (endOffset <= lastModifiedOffset) {
        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
      } else {
        throw new Error("Overlapping edit");
      }
      lastModifiedOffset = startOffset;
    }
    return text;
  }
  TextDocument2.applyEdits = applyEdits2;
  function mergeSort(data, compare2) {
    if (data.length <= 1) {
      return data;
    }
    var p = data.length / 2 | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare2);
    mergeSort(right, compare2);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      var ret = compare2(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
})(TextDocument || (TextDocument = {}));
var FullTextDocument = (
  /** @class */
  function() {
    function FullTextDocument2(uri, languageId, version, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version;
      this._content = content;
      this._lineOffsets = void 0;
    }
    Object.defineProperty(FullTextDocument2.prototype, "uri", {
      get: function() {
        return this._uri;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "languageId", {
      get: function() {
        return this._languageId;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "version", {
      get: function() {
        return this._version;
      },
      enumerable: false,
      configurable: true
    });
    FullTextDocument2.prototype.getText = function(range) {
      if (range) {
        var start = this.offsetAt(range.start);
        var end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    };
    FullTextDocument2.prototype.update = function(event, version) {
      this._content = event.text;
      this._version = version;
      this._lineOffsets = void 0;
    };
    FullTextDocument2.prototype.getLineOffsets = function() {
      if (this._lineOffsets === void 0) {
        var lineOffsets = [];
        var text = this._content;
        var isLineStart = true;
        for (var i = 0; i < text.length; i++) {
          if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
          }
          var ch = text.charAt(i);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
            i++;
          }
        }
        if (isLineStart && text.length > 0) {
          lineOffsets.push(text.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    };
    FullTextDocument2.prototype.positionAt = function(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      var lineOffsets = this.getLineOffsets();
      var low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position.create(0, offset);
      }
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      var line = low - 1;
      return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument2.prototype.offsetAt = function(position) {
      var lineOffsets = this.getLineOffsets();
      if (position.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position.line < 0) {
        return 0;
      }
      var lineOffset = lineOffsets[position.line];
      var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
      get: function() {
        return this.getLineOffsets().length;
      },
      enumerable: false,
      configurable: true
    });
    return FullTextDocument2;
  }()
);
var Is;
(function(Is2) {
  var toString = Object.prototype.toString;
  function defined(value) {
    return typeof value !== "undefined";
  }
  Is2.defined = defined;
  function undefined$1(value) {
    return typeof value === "undefined";
  }
  Is2.undefined = undefined$1;
  function boolean(value) {
    return value === true || value === false;
  }
  Is2.boolean = boolean;
  function string(value) {
    return toString.call(value) === "[object String]";
  }
  Is2.string = string;
  function number(value) {
    return toString.call(value) === "[object Number]";
  }
  Is2.number = number;
  function numberRange(value, min, max) {
    return toString.call(value) === "[object Number]" && min <= value && value <= max;
  }
  Is2.numberRange = numberRange;
  function integer2(value) {
    return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
  }
  Is2.integer = integer2;
  function uinteger2(value) {
    return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
  }
  Is2.uinteger = uinteger2;
  function func(value) {
    return toString.call(value) === "[object Function]";
  }
  Is2.func = func;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  Is2.objectLiteral = objectLiteral;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  Is2.typedArray = typedArray;
})(Is || (Is = {}));
const main = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get AnnotatedTextEdit() {
    return AnnotatedTextEdit;
  },
  get ChangeAnnotation() {
    return ChangeAnnotation;
  },
  get ChangeAnnotationIdentifier() {
    return ChangeAnnotationIdentifier;
  },
  get CodeAction() {
    return CodeAction;
  },
  get CodeActionContext() {
    return CodeActionContext;
  },
  get CodeActionKind() {
    return CodeActionKind;
  },
  get CodeActionTriggerKind() {
    return CodeActionTriggerKind;
  },
  get CodeDescription() {
    return CodeDescription;
  },
  get CodeLens() {
    return CodeLens;
  },
  get Color() {
    return Color;
  },
  get ColorInformation() {
    return ColorInformation;
  },
  get ColorPresentation() {
    return ColorPresentation;
  },
  get Command() {
    return Command;
  },
  get CompletionItem() {
    return CompletionItem;
  },
  get CompletionItemKind() {
    return CompletionItemKind;
  },
  get CompletionItemLabelDetails() {
    return CompletionItemLabelDetails;
  },
  get CompletionItemTag() {
    return CompletionItemTag;
  },
  get CompletionList() {
    return CompletionList;
  },
  get CreateFile() {
    return CreateFile;
  },
  get DeleteFile() {
    return DeleteFile;
  },
  get Diagnostic() {
    return Diagnostic;
  },
  get DiagnosticRelatedInformation() {
    return DiagnosticRelatedInformation;
  },
  get DiagnosticSeverity() {
    return DiagnosticSeverity;
  },
  get DiagnosticTag() {
    return DiagnosticTag;
  },
  get DocumentHighlight() {
    return DocumentHighlight;
  },
  get DocumentHighlightKind() {
    return DocumentHighlightKind;
  },
  get DocumentLink() {
    return DocumentLink;
  },
  get DocumentSymbol() {
    return DocumentSymbol;
  },
  get DocumentUri() {
    return DocumentUri;
  },
  EOL,
  get FoldingRange() {
    return FoldingRange;
  },
  get FoldingRangeKind() {
    return FoldingRangeKind;
  },
  get FormattingOptions() {
    return FormattingOptions;
  },
  get Hover() {
    return Hover;
  },
  get InlayHint() {
    return InlayHint;
  },
  get InlayHintKind() {
    return InlayHintKind;
  },
  get InlayHintLabelPart() {
    return InlayHintLabelPart;
  },
  get InlineValueContext() {
    return InlineValueContext;
  },
  get InlineValueEvaluatableExpression() {
    return InlineValueEvaluatableExpression;
  },
  get InlineValueText() {
    return InlineValueText;
  },
  get InlineValueVariableLookup() {
    return InlineValueVariableLookup;
  },
  get InsertReplaceEdit() {
    return InsertReplaceEdit;
  },
  get InsertTextFormat() {
    return InsertTextFormat;
  },
  get InsertTextMode() {
    return InsertTextMode;
  },
  get Location() {
    return Location;
  },
  get LocationLink() {
    return LocationLink;
  },
  get MarkedString() {
    return MarkedString;
  },
  get MarkupContent() {
    return MarkupContent;
  },
  get MarkupKind() {
    return MarkupKind;
  },
  get OptionalVersionedTextDocumentIdentifier() {
    return OptionalVersionedTextDocumentIdentifier;
  },
  get ParameterInformation() {
    return ParameterInformation;
  },
  get Position() {
    return Position;
  },
  get Range() {
    return Range;
  },
  get RenameFile() {
    return RenameFile;
  },
  get SelectionRange() {
    return SelectionRange;
  },
  get SemanticTokenModifiers() {
    return SemanticTokenModifiers;
  },
  get SemanticTokenTypes() {
    return SemanticTokenTypes;
  },
  get SemanticTokens() {
    return SemanticTokens;
  },
  get SignatureInformation() {
    return SignatureInformation;
  },
  get SymbolInformation() {
    return SymbolInformation;
  },
  get SymbolKind() {
    return SymbolKind;
  },
  get SymbolTag() {
    return SymbolTag;
  },
  get TextDocument() {
    return TextDocument;
  },
  get TextDocumentEdit() {
    return TextDocumentEdit;
  },
  get TextDocumentIdentifier() {
    return TextDocumentIdentifier;
  },
  get TextDocumentItem() {
    return TextDocumentItem;
  },
  get TextEdit() {
    return TextEdit;
  },
  get URI() {
    return URI;
  },
  get VersionedTextDocumentIdentifier() {
    return VersionedTextDocumentIdentifier;
  },
  WorkspaceChange,
  get WorkspaceEdit() {
    return WorkspaceEdit;
  },
  get WorkspaceFolder() {
    return WorkspaceFolder;
  },
  get WorkspaceSymbol() {
    return WorkspaceSymbol;
  },
  get integer() {
    return integer;
  },
  get uinteger() {
    return uinteger;
  }
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(main);
var messages = {};
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages)
    return messages;
  hasRequiredMessages = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
    const vscode_jsonrpc_1 = requireMain$1();
    (function(MessageDirection) {
      MessageDirection["clientToServer"] = "clientToServer";
      MessageDirection["serverToClient"] = "serverToClient";
      MessageDirection["both"] = "both";
    })(exports.MessageDirection || (exports.MessageDirection = {}));
    class RegistrationType {
      constructor(method) {
        this.method = method;
      }
    }
    exports.RegistrationType = RegistrationType;
    class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    }
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    }
    exports.ProtocolRequestType = ProtocolRequestType;
    class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    }
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    }
    exports.ProtocolNotificationType = ProtocolNotificationType;
  })(messages);
  return messages;
}
var protocol = {};
var is$1 = {};
var hasRequiredIs$1;
function requireIs$1() {
  if (hasRequiredIs$1)
    return is$1;
  hasRequiredIs$1 = 1;
  Object.defineProperty(is$1, "__esModule", { value: true });
  is$1.objectLiteral = is$1.typedArray = is$1.stringArray = is$1.array = is$1.func = is$1.error = is$1.number = is$1.string = is$1.boolean = void 0;
  function boolean(value) {
    return value === true || value === false;
  }
  is$1.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  is$1.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  is$1.number = number;
  function error(value) {
    return value instanceof Error;
  }
  is$1.error = error;
  function func(value) {
    return typeof value === "function";
  }
  is$1.func = func;
  function array2(value) {
    return Array.isArray(value);
  }
  is$1.array = array2;
  function stringArray(value) {
    return array2(value) && value.every((elem) => string(elem));
  }
  is$1.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  is$1.typedArray = typedArray;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  is$1.objectLiteral = objectLiteral;
  return is$1;
}
var protocol_implementation = {};
var hasRequiredProtocol_implementation;
function requireProtocol_implementation() {
  if (hasRequiredProtocol_implementation)
    return protocol_implementation;
  hasRequiredProtocol_implementation = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    const messages_1 = requireMessages();
    (function(ImplementationRequest) {
      ImplementationRequest.method = "textDocument/implementation";
      ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
    })(exports.ImplementationRequest || (exports.ImplementationRequest = {}));
  })(protocol_implementation);
  return protocol_implementation;
}
var protocol_typeDefinition = {};
var hasRequiredProtocol_typeDefinition;
function requireProtocol_typeDefinition() {
  if (hasRequiredProtocol_typeDefinition)
    return protocol_typeDefinition;
  hasRequiredProtocol_typeDefinition = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    const messages_1 = requireMessages();
    (function(TypeDefinitionRequest) {
      TypeDefinitionRequest.method = "textDocument/typeDefinition";
      TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
    })(exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
  })(protocol_typeDefinition);
  return protocol_typeDefinition;
}
var protocol_workspaceFolder = {};
var hasRequiredProtocol_workspaceFolder;
function requireProtocol_workspaceFolder() {
  if (hasRequiredProtocol_workspaceFolder)
    return protocol_workspaceFolder;
  hasRequiredProtocol_workspaceFolder = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    const messages_1 = requireMessages();
    (function(WorkspaceFoldersRequest) {
      WorkspaceFoldersRequest.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
    })(exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
    (function(DidChangeWorkspaceFoldersNotification) {
      DidChangeWorkspaceFoldersNotification.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
    })(exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
  })(protocol_workspaceFolder);
  return protocol_workspaceFolder;
}
var protocol_configuration = {};
var hasRequiredProtocol_configuration;
function requireProtocol_configuration() {
  if (hasRequiredProtocol_configuration)
    return protocol_configuration;
  hasRequiredProtocol_configuration = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    const messages_1 = requireMessages();
    (function(ConfigurationRequest) {
      ConfigurationRequest.method = "workspace/configuration";
      ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
    })(exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
  })(protocol_configuration);
  return protocol_configuration;
}
var protocol_colorProvider = {};
var hasRequiredProtocol_colorProvider;
function requireProtocol_colorProvider() {
  if (hasRequiredProtocol_colorProvider)
    return protocol_colorProvider;
  hasRequiredProtocol_colorProvider = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    const messages_1 = requireMessages();
    (function(DocumentColorRequest) {
      DocumentColorRequest.method = "textDocument/documentColor";
      DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
    })(exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
    (function(ColorPresentationRequest) {
      ColorPresentationRequest.method = "textDocument/colorPresentation";
      ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
    })(exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
  })(protocol_colorProvider);
  return protocol_colorProvider;
}
var protocol_foldingRange = {};
var hasRequiredProtocol_foldingRange;
function requireProtocol_foldingRange() {
  if (hasRequiredProtocol_foldingRange)
    return protocol_foldingRange;
  hasRequiredProtocol_foldingRange = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRequest = void 0;
    const messages_1 = requireMessages();
    (function(FoldingRangeRequest) {
      FoldingRangeRequest.method = "textDocument/foldingRange";
      FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
    })(exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
  })(protocol_foldingRange);
  return protocol_foldingRange;
}
var protocol_declaration = {};
var hasRequiredProtocol_declaration;
function requireProtocol_declaration() {
  if (hasRequiredProtocol_declaration)
    return protocol_declaration;
  hasRequiredProtocol_declaration = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    const messages_1 = requireMessages();
    (function(DeclarationRequest) {
      DeclarationRequest.method = "textDocument/declaration";
      DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
    })(exports.DeclarationRequest || (exports.DeclarationRequest = {}));
  })(protocol_declaration);
  return protocol_declaration;
}
var protocol_selectionRange = {};
var hasRequiredProtocol_selectionRange;
function requireProtocol_selectionRange() {
  if (hasRequiredProtocol_selectionRange)
    return protocol_selectionRange;
  hasRequiredProtocol_selectionRange = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    const messages_1 = requireMessages();
    (function(SelectionRangeRequest) {
      SelectionRangeRequest.method = "textDocument/selectionRange";
      SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
    })(exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
  })(protocol_selectionRange);
  return protocol_selectionRange;
}
var protocol_progress = {};
var hasRequiredProtocol_progress;
function requireProtocol_progress() {
  if (hasRequiredProtocol_progress)
    return protocol_progress;
  hasRequiredProtocol_progress = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    const vscode_jsonrpc_1 = requireMain$1();
    const messages_1 = requireMessages();
    (function(WorkDoneProgress) {
      WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
      function is2(value) {
        return value === WorkDoneProgress.type;
      }
      WorkDoneProgress.is = is2;
    })(exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
    (function(WorkDoneProgressCreateRequest) {
      WorkDoneProgressCreateRequest.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
    })(exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
    (function(WorkDoneProgressCancelNotification) {
      WorkDoneProgressCancelNotification.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
    })(exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
  })(protocol_progress);
  return protocol_progress;
}
var protocol_callHierarchy = {};
var hasRequiredProtocol_callHierarchy;
function requireProtocol_callHierarchy() {
  if (hasRequiredProtocol_callHierarchy)
    return protocol_callHierarchy;
  hasRequiredProtocol_callHierarchy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    const messages_1 = requireMessages();
    (function(CallHierarchyPrepareRequest) {
      CallHierarchyPrepareRequest.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
    })(exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
    (function(CallHierarchyIncomingCallsRequest) {
      CallHierarchyIncomingCallsRequest.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
    })(exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
    (function(CallHierarchyOutgoingCallsRequest) {
      CallHierarchyOutgoingCallsRequest.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
    })(exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
  })(protocol_callHierarchy);
  return protocol_callHierarchy;
}
var protocol_semanticTokens = {};
var hasRequiredProtocol_semanticTokens;
function requireProtocol_semanticTokens() {
  if (hasRequiredProtocol_semanticTokens)
    return protocol_semanticTokens;
  hasRequiredProtocol_semanticTokens = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
    const messages_1 = requireMessages();
    (function(TokenFormat) {
      TokenFormat.Relative = "relative";
    })(exports.TokenFormat || (exports.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
    (function(SemanticTokensRequest) {
      SemanticTokensRequest.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
      SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
    })(exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
    (function(SemanticTokensDeltaRequest) {
      SemanticTokensDeltaRequest.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
      SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
    })(exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
    (function(SemanticTokensRangeRequest) {
      SemanticTokensRangeRequest.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
      SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
    })(exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
    (function(SemanticTokensRefreshRequest) {
      SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
    })(exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
  })(protocol_semanticTokens);
  return protocol_semanticTokens;
}
var protocol_showDocument = {};
var hasRequiredProtocol_showDocument;
function requireProtocol_showDocument() {
  if (hasRequiredProtocol_showDocument)
    return protocol_showDocument;
  hasRequiredProtocol_showDocument = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    const messages_1 = requireMessages();
    (function(ShowDocumentRequest) {
      ShowDocumentRequest.method = "window/showDocument";
      ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
    })(exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
  })(protocol_showDocument);
  return protocol_showDocument;
}
var protocol_linkedEditingRange = {};
var hasRequiredProtocol_linkedEditingRange;
function requireProtocol_linkedEditingRange() {
  if (hasRequiredProtocol_linkedEditingRange)
    return protocol_linkedEditingRange;
  hasRequiredProtocol_linkedEditingRange = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    const messages_1 = requireMessages();
    (function(LinkedEditingRangeRequest) {
      LinkedEditingRangeRequest.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
    })(exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
  })(protocol_linkedEditingRange);
  return protocol_linkedEditingRange;
}
var protocol_fileOperations = {};
var hasRequiredProtocol_fileOperations;
function requireProtocol_fileOperations() {
  if (hasRequiredProtocol_fileOperations)
    return protocol_fileOperations;
  hasRequiredProtocol_fileOperations = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    const messages_1 = requireMessages();
    (function(FileOperationPatternKind) {
      FileOperationPatternKind.file = "file";
      FileOperationPatternKind.folder = "folder";
    })(exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
    (function(WillCreateFilesRequest) {
      WillCreateFilesRequest.method = "workspace/willCreateFiles";
      WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
    })(exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
    (function(DidCreateFilesNotification) {
      DidCreateFilesNotification.method = "workspace/didCreateFiles";
      DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
    })(exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
    (function(WillRenameFilesRequest) {
      WillRenameFilesRequest.method = "workspace/willRenameFiles";
      WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
    })(exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
    (function(DidRenameFilesNotification) {
      DidRenameFilesNotification.method = "workspace/didRenameFiles";
      DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
    })(exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
    (function(DidDeleteFilesNotification) {
      DidDeleteFilesNotification.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
    })(exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
    (function(WillDeleteFilesRequest) {
      WillDeleteFilesRequest.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
    })(exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
  })(protocol_fileOperations);
  return protocol_fileOperations;
}
var protocol_moniker = {};
var hasRequiredProtocol_moniker;
function requireProtocol_moniker() {
  if (hasRequiredProtocol_moniker)
    return protocol_moniker;
  hasRequiredProtocol_moniker = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    const messages_1 = requireMessages();
    (function(UniquenessLevel) {
      UniquenessLevel.document = "document";
      UniquenessLevel.project = "project";
      UniquenessLevel.group = "group";
      UniquenessLevel.scheme = "scheme";
      UniquenessLevel.global = "global";
    })(exports.UniquenessLevel || (exports.UniquenessLevel = {}));
    (function(MonikerKind) {
      MonikerKind.$import = "import";
      MonikerKind.$export = "export";
      MonikerKind.local = "local";
    })(exports.MonikerKind || (exports.MonikerKind = {}));
    (function(MonikerRequest) {
      MonikerRequest.method = "textDocument/moniker";
      MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
    })(exports.MonikerRequest || (exports.MonikerRequest = {}));
  })(protocol_moniker);
  return protocol_moniker;
}
var protocol_typeHierarchy = {};
var hasRequiredProtocol_typeHierarchy;
function requireProtocol_typeHierarchy() {
  if (hasRequiredProtocol_typeHierarchy)
    return protocol_typeHierarchy;
  hasRequiredProtocol_typeHierarchy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    const messages_1 = requireMessages();
    (function(TypeHierarchyPrepareRequest) {
      TypeHierarchyPrepareRequest.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
    })(exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));
    (function(TypeHierarchySupertypesRequest) {
      TypeHierarchySupertypesRequest.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
    })(exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));
    (function(TypeHierarchySubtypesRequest) {
      TypeHierarchySubtypesRequest.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
    })(exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));
  })(protocol_typeHierarchy);
  return protocol_typeHierarchy;
}
var protocol_inlineValue = {};
var hasRequiredProtocol_inlineValue;
function requireProtocol_inlineValue() {
  if (hasRequiredProtocol_inlineValue)
    return protocol_inlineValue;
  hasRequiredProtocol_inlineValue = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
    const messages_1 = requireMessages();
    (function(InlineValueRequest) {
      InlineValueRequest.method = "textDocument/inlineValue";
      InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
    })(exports.InlineValueRequest || (exports.InlineValueRequest = {}));
    (function(InlineValueRefreshRequest) {
      InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
    })(exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));
  })(protocol_inlineValue);
  return protocol_inlineValue;
}
var protocol_inlayHint = {};
var hasRequiredProtocol_inlayHint;
function requireProtocol_inlayHint() {
  if (hasRequiredProtocol_inlayHint)
    return protocol_inlayHint;
  hasRequiredProtocol_inlayHint = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
    const messages_1 = requireMessages();
    (function(InlayHintRequest) {
      InlayHintRequest.method = "textDocument/inlayHint";
      InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
    })(exports.InlayHintRequest || (exports.InlayHintRequest = {}));
    (function(InlayHintResolveRequest) {
      InlayHintResolveRequest.method = "inlayHint/resolve";
      InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
    })(exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));
    (function(InlayHintRefreshRequest) {
      InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
    })(exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));
  })(protocol_inlayHint);
  return protocol_inlayHint;
}
var protocol_diagnostic = {};
var hasRequiredProtocol_diagnostic;
function requireProtocol_diagnostic() {
  if (hasRequiredProtocol_diagnostic)
    return protocol_diagnostic;
  hasRequiredProtocol_diagnostic = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
    const vscode_jsonrpc_1 = requireMain$1();
    const Is2 = requireIs$1();
    const messages_1 = requireMessages();
    (function(DiagnosticServerCancellationData) {
      function is2(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData.is = is2;
    })(exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
    (function(DocumentDiagnosticReportKind) {
      DocumentDiagnosticReportKind.Full = "full";
      DocumentDiagnosticReportKind.Unchanged = "unchanged";
    })(exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
    (function(DocumentDiagnosticRequest) {
      DocumentDiagnosticRequest.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
      DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
    (function(WorkspaceDiagnosticRequest) {
      WorkspaceDiagnosticRequest.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
      WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
    (function(DiagnosticRefreshRequest) {
      DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
    })(exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
  })(protocol_diagnostic);
  return protocol_diagnostic;
}
var protocol_notebook = {};
var hasRequiredProtocol_notebook;
function requireProtocol_notebook() {
  if (hasRequiredProtocol_notebook)
    return protocol_notebook;
  hasRequiredProtocol_notebook = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
    const vscode_languageserver_types_1 = require$$1;
    const Is2 = requireIs$1();
    const messages_1 = requireMessages();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is2(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is2;
    })(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
      }
      ExecutionSummary2.is = is2;
      function equals2(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals2;
    })(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document2) {
        return { kind, document: document2 };
      }
      NotebookCell2.create = create;
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is2;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));
    (function(NotebookDocument) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument.create = create;
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument.is = is2;
    })(exports.NotebookDocument || (exports.NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));
    (function(DidOpenNotebookDocumentNotification) {
      DidOpenNotebookDocumentNotification.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
      DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));
    (function(NotebookCellArrayChange) {
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange.is = is2;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange.create = create;
    })(exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));
    (function(DidChangeNotebookDocumentNotification) {
      DidChangeNotebookDocumentNotification.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
      DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));
    (function(DidSaveNotebookDocumentNotification) {
      DidSaveNotebookDocumentNotification.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
      DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));
    (function(DidCloseNotebookDocumentNotification) {
      DidCloseNotebookDocumentNotification.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
      DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));
  })(protocol_notebook);
  return protocol_notebook;
}
var hasRequiredProtocol;
function requireProtocol() {
  if (hasRequiredProtocol)
    return protocol;
  hasRequiredProtocol = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;
    const messages_1 = requireMessages();
    const vscode_languageserver_types_1 = require$$1;
    const Is2 = requireIs$1();
    const protocol_implementation_1 = requireProtocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    const protocol_typeDefinition_1 = requireProtocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    const protocol_workspaceFolder_1 = requireProtocol_workspaceFolder();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    const protocol_configuration_1 = requireProtocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    const protocol_colorProvider_1 = requireProtocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    const protocol_foldingRange_1 = requireProtocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    const protocol_declaration_1 = requireProtocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    const protocol_selectionRange_1 = requireProtocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    const protocol_progress_1 = requireProtocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    const protocol_callHierarchy_1 = requireProtocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    const protocol_semanticTokens_1 = requireProtocol_semanticTokens();
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    const protocol_showDocument_1 = requireProtocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    const protocol_linkedEditingRange_1 = requireProtocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    const protocol_fileOperations_1 = requireProtocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    const protocol_moniker_1 = requireProtocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    const protocol_typeHierarchy_1 = requireProtocol_typeHierarchy();
    Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    const protocol_inlineValue_1 = requireProtocol_inlineValue();
    Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    const protocol_inlayHint_1 = requireProtocol_inlayHint();
    Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    const protocol_diagnostic_1 = requireProtocol_diagnostic();
    Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    const protocol_notebook_1 = requireProtocol_notebook();
    Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is2(value) {
        const candidate = value;
        return Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern);
      }
      TextDocumentFilter2.is = is2;
    })(TextDocumentFilter = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is2;
    })(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is2;
    })(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is2(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is2;
    })(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
    (function(RegistrationRequest) {
      RegistrationRequest.method = "client/registerCapability";
      RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
    })(exports.RegistrationRequest || (exports.RegistrationRequest = {}));
    (function(UnregistrationRequest) {
      UnregistrationRequest.method = "client/unregisterCapability";
      UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
    })(exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
    (function(ResourceOperationKind) {
      ResourceOperationKind.Create = "create";
      ResourceOperationKind.Rename = "rename";
      ResourceOperationKind.Delete = "delete";
    })(exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
    (function(FailureHandlingKind) {
      FailureHandlingKind.Abort = "abort";
      FailureHandlingKind.Transactional = "transactional";
      FailureHandlingKind.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind.Undo = "undo";
    })(exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
    (function(PositionEncodingKind) {
      PositionEncodingKind.UTF8 = "utf-8";
      PositionEncodingKind.UTF16 = "utf-16";
      PositionEncodingKind.UTF32 = "utf-32";
    })(exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));
    (function(StaticRegistrationOptions) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions.hasId = hasId;
    })(exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
    (function(TextDocumentRegistrationOptions) {
      function is2(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions.is = is2;
    })(exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
    (function(WorkDoneProgressOptions) {
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions.is = is2;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
    })(exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
    (function(InitializeRequest) {
      InitializeRequest.method = "initialize";
      InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
    })(exports.InitializeRequest || (exports.InitializeRequest = {}));
    (function(InitializeErrorCodes) {
      InitializeErrorCodes.unknownProtocolVersion = 1;
    })(exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));
    (function(InitializedNotification) {
      InitializedNotification.method = "initialized";
      InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
    })(exports.InitializedNotification || (exports.InitializedNotification = {}));
    (function(ShutdownRequest) {
      ShutdownRequest.method = "shutdown";
      ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
    })(exports.ShutdownRequest || (exports.ShutdownRequest = {}));
    (function(ExitNotification) {
      ExitNotification.method = "exit";
      ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
    })(exports.ExitNotification || (exports.ExitNotification = {}));
    (function(DidChangeConfigurationNotification) {
      DidChangeConfigurationNotification.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
    })(exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
    (function(MessageType) {
      MessageType.Error = 1;
      MessageType.Warning = 2;
      MessageType.Info = 3;
      MessageType.Log = 4;
    })(exports.MessageType || (exports.MessageType = {}));
    (function(ShowMessageNotification) {
      ShowMessageNotification.method = "window/showMessage";
      ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
    })(exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
    (function(ShowMessageRequest) {
      ShowMessageRequest.method = "window/showMessageRequest";
      ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
    })(exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
    (function(LogMessageNotification) {
      LogMessageNotification.method = "window/logMessage";
      LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
    })(exports.LogMessageNotification || (exports.LogMessageNotification = {}));
    (function(TelemetryEventNotification) {
      TelemetryEventNotification.method = "telemetry/event";
      TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
    })(exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
    (function(TextDocumentSyncKind) {
      TextDocumentSyncKind.None = 0;
      TextDocumentSyncKind.Full = 1;
      TextDocumentSyncKind.Incremental = 2;
    })(exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
    (function(DidOpenTextDocumentNotification) {
      DidOpenTextDocumentNotification.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
    })(exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
    (function(TextDocumentContentChangeEvent) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent.isFull = isFull;
    })(exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
    (function(DidChangeTextDocumentNotification) {
      DidChangeTextDocumentNotification.method = "textDocument/didChange";
      DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
    })(exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
    (function(DidCloseTextDocumentNotification) {
      DidCloseTextDocumentNotification.method = "textDocument/didClose";
      DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
    })(exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
    (function(DidSaveTextDocumentNotification) {
      DidSaveTextDocumentNotification.method = "textDocument/didSave";
      DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
    })(exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
    (function(TextDocumentSaveReason) {
      TextDocumentSaveReason.Manual = 1;
      TextDocumentSaveReason.AfterDelay = 2;
      TextDocumentSaveReason.FocusOut = 3;
    })(exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    (function(WillSaveTextDocumentNotification) {
      WillSaveTextDocumentNotification.method = "textDocument/willSave";
      WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
    })(exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
    (function(WillSaveTextDocumentWaitUntilRequest) {
      WillSaveTextDocumentWaitUntilRequest.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
    })(exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
    (function(DidChangeWatchedFilesNotification) {
      DidChangeWatchedFilesNotification.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
    })(exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
    (function(FileChangeType) {
      FileChangeType.Created = 1;
      FileChangeType.Changed = 2;
      FileChangeType.Deleted = 3;
    })(exports.FileChangeType || (exports.FileChangeType = {}));
    (function(RelativePattern) {
      function is2(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
      }
      RelativePattern.is = is2;
    })(exports.RelativePattern || (exports.RelativePattern = {}));
    (function(WatchKind) {
      WatchKind.Create = 1;
      WatchKind.Change = 2;
      WatchKind.Delete = 4;
    })(exports.WatchKind || (exports.WatchKind = {}));
    (function(PublishDiagnosticsNotification) {
      PublishDiagnosticsNotification.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
    })(exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
    (function(CompletionTriggerKind) {
      CompletionTriggerKind.Invoked = 1;
      CompletionTriggerKind.TriggerCharacter = 2;
      CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
    })(exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    (function(CompletionRequest) {
      CompletionRequest.method = "textDocument/completion";
      CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
    })(exports.CompletionRequest || (exports.CompletionRequest = {}));
    (function(CompletionResolveRequest) {
      CompletionResolveRequest.method = "completionItem/resolve";
      CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
    })(exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
    (function(HoverRequest) {
      HoverRequest.method = "textDocument/hover";
      HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
    })(exports.HoverRequest || (exports.HoverRequest = {}));
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
    (function(SignatureHelpRequest) {
      SignatureHelpRequest.method = "textDocument/signatureHelp";
      SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
    })(exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
    (function(DefinitionRequest) {
      DefinitionRequest.method = "textDocument/definition";
      DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
    })(exports.DefinitionRequest || (exports.DefinitionRequest = {}));
    (function(ReferencesRequest) {
      ReferencesRequest.method = "textDocument/references";
      ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
    })(exports.ReferencesRequest || (exports.ReferencesRequest = {}));
    (function(DocumentHighlightRequest) {
      DocumentHighlightRequest.method = "textDocument/documentHighlight";
      DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
    })(exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
    (function(DocumentSymbolRequest) {
      DocumentSymbolRequest.method = "textDocument/documentSymbol";
      DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
    })(exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
    (function(CodeActionRequest) {
      CodeActionRequest.method = "textDocument/codeAction";
      CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
    })(exports.CodeActionRequest || (exports.CodeActionRequest = {}));
    (function(CodeActionResolveRequest) {
      CodeActionResolveRequest.method = "codeAction/resolve";
      CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
    })(exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
    (function(WorkspaceSymbolRequest) {
      WorkspaceSymbolRequest.method = "workspace/symbol";
      WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
    })(exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
    (function(WorkspaceSymbolResolveRequest) {
      WorkspaceSymbolResolveRequest.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
    })(exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));
    (function(CodeLensRequest) {
      CodeLensRequest.method = "textDocument/codeLens";
      CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
    })(exports.CodeLensRequest || (exports.CodeLensRequest = {}));
    (function(CodeLensResolveRequest) {
      CodeLensResolveRequest.method = "codeLens/resolve";
      CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
    })(exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
    (function(CodeLensRefreshRequest) {
      CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
    })(exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
    (function(DocumentLinkRequest) {
      DocumentLinkRequest.method = "textDocument/documentLink";
      DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
    })(exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
    (function(DocumentLinkResolveRequest) {
      DocumentLinkResolveRequest.method = "documentLink/resolve";
      DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
    })(exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
    (function(DocumentFormattingRequest) {
      DocumentFormattingRequest.method = "textDocument/formatting";
      DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
    })(exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
    (function(DocumentRangeFormattingRequest) {
      DocumentRangeFormattingRequest.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
    })(exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
    (function(DocumentOnTypeFormattingRequest) {
      DocumentOnTypeFormattingRequest.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
    })(exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
    (function(PrepareSupportDefaultBehavior) {
      PrepareSupportDefaultBehavior.Identifier = 1;
    })(exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
    (function(RenameRequest) {
      RenameRequest.method = "textDocument/rename";
      RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
    })(exports.RenameRequest || (exports.RenameRequest = {}));
    (function(PrepareRenameRequest) {
      PrepareRenameRequest.method = "textDocument/prepareRename";
      PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
    })(exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
    (function(ExecuteCommandRequest) {
      ExecuteCommandRequest.method = "workspace/executeCommand";
      ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
    })(exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
    (function(ApplyWorkspaceEditRequest) {
      ApplyWorkspaceEditRequest.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
  })(protocol);
  return protocol;
}
var connection = {};
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection)
    return connection;
  hasRequiredConnection = 1;
  Object.defineProperty(connection, "__esModule", { value: true });
  connection.createProtocolConnection = void 0;
  const vscode_jsonrpc_1 = requireMain$1();
  function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
      options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
  }
  connection.createProtocolConnection = createProtocolConnection;
  return connection;
}
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi)
    return api;
  hasRequiredApi = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(requireMain$1(), exports);
    __exportStar(require$$1, exports);
    __exportStar(requireMessages(), exports);
    __exportStar(requireProtocol(), exports);
    var connection_1 = requireConnection();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    (function(LSPErrorCodes) {
      LSPErrorCodes.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes.RequestFailed = -32803;
      LSPErrorCodes.ServerCancelled = -32802;
      LSPErrorCodes.ContentModified = -32801;
      LSPErrorCodes.RequestCancelled = -32800;
      LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
    })(exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
  })(api);
  return api;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain)
    return main$2;
  hasRequiredMain = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    const browser_1 = requireBrowser$1();
    __exportStar(requireBrowser$1(), exports);
    __exportStar(requireApi(), exports);
    function createProtocolConnection(reader, writer, logger, options) {
      return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  })(main$2);
  return main$2;
}
var codeConverter = {};
var is = {};
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs)
    return is;
  hasRequiredIs = 1;
  Object.defineProperty(is, "__esModule", { value: true });
  is.asPromise = is.thenable = is.typedArray = is.stringArray = is.array = is.func = is.error = is.number = is.string = is.boolean = void 0;
  function boolean(value) {
    return value === true || value === false;
  }
  is.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  is.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  is.number = number;
  function error(value) {
    return value instanceof Error;
  }
  is.error = error;
  function func(value) {
    return typeof value === "function";
  }
  is.func = func;
  function array2(value) {
    return Array.isArray(value);
  }
  is.array = array2;
  function stringArray(value) {
    return array2(value) && value.every((elem) => string(elem));
  }
  is.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  is.typedArray = typedArray;
  function thenable(value) {
    return value && func(value.then);
  }
  is.thenable = thenable;
  function asPromise(value) {
    if (value instanceof Promise) {
      return value;
    } else if (thenable(value)) {
      return new Promise((resolve, reject) => {
        value.then((resolved) => resolve(resolved), (error2) => reject(error2));
      });
    } else {
      return Promise.resolve(value);
    }
  }
  is.asPromise = asPromise;
  return is;
}
var async = {};
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync)
    return async;
  hasRequiredAsync = 1;
  Object.defineProperty(async, "__esModule", { value: true });
  async.forEach = async.mapAsync = async.map = async.clearTestMode = async.setTestMode = async.Semaphore = async.Delayer = void 0;
  const vscode_languageserver_protocol_1 = requireMain();
  class Delayer2 {
    constructor(defaultDelay) {
      this.defaultDelay = defaultDelay;
      this.timeout = void 0;
      this.completionPromise = void 0;
      this.onSuccess = void 0;
      this.task = void 0;
    }
    trigger(task, delay = this.defaultDelay) {
      this.task = task;
      if (delay >= 0) {
        this.cancelTimeout();
      }
      if (!this.completionPromise) {
        this.completionPromise = new Promise((resolve) => {
          this.onSuccess = resolve;
        }).then(() => {
          this.completionPromise = void 0;
          this.onSuccess = void 0;
          var result = this.task();
          this.task = void 0;
          return result;
        });
      }
      if (delay >= 0 || this.timeout === void 0) {
        this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
          this.timeout = void 0;
          this.onSuccess(void 0);
        }, delay >= 0 ? delay : this.defaultDelay);
      }
      return this.completionPromise;
    }
    forceDelivery() {
      if (!this.completionPromise) {
        return void 0;
      }
      this.cancelTimeout();
      let result = this.task();
      this.completionPromise = void 0;
      this.onSuccess = void 0;
      this.task = void 0;
      return result;
    }
    isTriggered() {
      return this.timeout !== void 0;
    }
    cancel() {
      this.cancelTimeout();
      this.completionPromise = void 0;
    }
    cancelTimeout() {
      if (this.timeout !== void 0) {
        this.timeout.dispose();
        this.timeout = void 0;
      }
    }
  }
  async.Delayer = Delayer2;
  class Semaphore {
    constructor(capacity = 1) {
      if (capacity <= 0) {
        throw new Error("Capacity must be greater than 0");
      }
      this._capacity = capacity;
      this._active = 0;
      this._waiting = [];
    }
    lock(thunk) {
      return new Promise((resolve, reject) => {
        this._waiting.push({ thunk, resolve, reject });
        this.runNext();
      });
    }
    get active() {
      return this._active;
    }
    runNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      const next = this._waiting.shift();
      this._active++;
      if (this._active > this._capacity) {
        throw new Error(`To many thunks active`);
      }
      try {
        const result = next.thunk();
        if (result instanceof Promise) {
          result.then((value) => {
            this._active--;
            next.resolve(value);
            this.runNext();
          }, (err) => {
            this._active--;
            next.reject(err);
            this.runNext();
          });
        } else {
          this._active--;
          next.resolve(result);
          this.runNext();
        }
      } catch (err) {
        this._active--;
        next.reject(err);
        this.runNext();
      }
    }
  }
  async.Semaphore = Semaphore;
  let $test = false;
  function setTestMode() {
    $test = true;
  }
  async.setTestMode = setTestMode;
  function clearTestMode() {
    $test = false;
  }
  async.clearTestMode = clearTestMode;
  const defaultYieldTimeout = 15;
  class Timer {
    constructor(yieldAfter = defaultYieldTimeout) {
      this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);
      this.startTime = Date.now();
      this.counter = 0;
      this.total = 0;
      this.counterInterval = 1;
    }
    start() {
      this.counter = 0;
      this.total = 0;
      this.counterInterval = 1;
      this.startTime = Date.now();
    }
    shouldYield() {
      if (++this.counter >= this.counterInterval) {
        const timeTaken = Date.now() - this.startTime;
        const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
        this.total += this.counter;
        this.counter = 0;
        if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
          this.counterInterval = 1;
          this.total = 0;
          return true;
        } else {
          switch (timeTaken) {
            case 0:
            case 1:
              this.counterInterval = this.total * 2;
              break;
          }
        }
      }
      return false;
    }
  }
  async function map(items, func, token, options) {
    if (items.length === 0) {
      return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options == null ? void 0 : options.yieldAfter);
    function convertBatch(start) {
      timer.start();
      for (let i = start; i < items.length; i++) {
        result[i] = func(items[i]);
        if (timer.shouldYield()) {
          (options == null ? void 0 : options.yieldCallback) && options.yieldCallback();
          return i + 1;
        }
      }
      return -1;
    }
    let index2 = convertBatch(0);
    while (index2 !== -1) {
      if (token !== void 0 && token.isCancellationRequested) {
        break;
      }
      index2 = await new Promise((resolve) => {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
          resolve(convertBatch(index2));
        });
      });
    }
    return result;
  }
  async.map = map;
  async function mapAsync(items, func, token, options) {
    if (items.length === 0) {
      return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options == null ? void 0 : options.yieldAfter);
    async function convertBatch(start) {
      timer.start();
      for (let i = start; i < items.length; i++) {
        result[i] = await func(items[i], token);
        if (timer.shouldYield()) {
          (options == null ? void 0 : options.yieldCallback) && options.yieldCallback();
          return i + 1;
        }
      }
      return -1;
    }
    let index2 = await convertBatch(0);
    while (index2 !== -1) {
      if (token !== void 0 && token.isCancellationRequested) {
        break;
      }
      index2 = await new Promise((resolve) => {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
          resolve(convertBatch(index2));
        });
      });
    }
    return result;
  }
  async.mapAsync = mapAsync;
  async function forEach(items, func, token, options) {
    if (items.length === 0) {
      return;
    }
    const timer = new Timer(options == null ? void 0 : options.yieldAfter);
    function runBatch(start) {
      timer.start();
      for (let i = start; i < items.length; i++) {
        func(items[i]);
        if (timer.shouldYield()) {
          (options == null ? void 0 : options.yieldCallback) && options.yieldCallback();
          return i + 1;
        }
      }
      return -1;
    }
    let index2 = runBatch(0);
    while (index2 !== -1) {
      if (token !== void 0 && token.isCancellationRequested) {
        break;
      }
      index2 = await new Promise((resolve) => {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
          resolve(runBatch(index2));
        });
      });
    }
  }
  async.forEach = forEach;
  return async;
}
var protocolCompletionItem = {};
var hasRequiredProtocolCompletionItem;
function requireProtocolCompletionItem() {
  if (hasRequiredProtocolCompletionItem)
    return protocolCompletionItem;
  hasRequiredProtocolCompletionItem = 1;
  Object.defineProperty(protocolCompletionItem, "__esModule", { value: true });
  const code = require$$0;
  class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
      super(label);
    }
  }
  protocolCompletionItem.default = ProtocolCompletionItem;
  return protocolCompletionItem;
}
var protocolCodeLens = {};
var hasRequiredProtocolCodeLens;
function requireProtocolCodeLens() {
  if (hasRequiredProtocolCodeLens)
    return protocolCodeLens;
  hasRequiredProtocolCodeLens = 1;
  Object.defineProperty(protocolCodeLens, "__esModule", { value: true });
  const code = require$$0;
  class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
      super(range);
    }
  }
  protocolCodeLens.default = ProtocolCodeLens;
  return protocolCodeLens;
}
var protocolDocumentLink = {};
var hasRequiredProtocolDocumentLink;
function requireProtocolDocumentLink() {
  if (hasRequiredProtocolDocumentLink)
    return protocolDocumentLink;
  hasRequiredProtocolDocumentLink = 1;
  Object.defineProperty(protocolDocumentLink, "__esModule", { value: true });
  const code = require$$0;
  class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
      super(range, target);
    }
  }
  protocolDocumentLink.default = ProtocolDocumentLink;
  return protocolDocumentLink;
}
var protocolCodeAction = {};
var hasRequiredProtocolCodeAction;
function requireProtocolCodeAction() {
  if (hasRequiredProtocolCodeAction)
    return protocolCodeAction;
  hasRequiredProtocolCodeAction = 1;
  Object.defineProperty(protocolCodeAction, "__esModule", { value: true });
  const vscode = require$$0;
  class ProtocolCodeAction extends vscode.CodeAction {
    constructor(title, data) {
      super(title);
      this.data = data;
    }
  }
  protocolCodeAction.default = ProtocolCodeAction;
  return protocolCodeAction;
}
var protocolDiagnostic = {};
var hasRequiredProtocolDiagnostic;
function requireProtocolDiagnostic() {
  if (hasRequiredProtocolDiagnostic)
    return protocolDiagnostic;
  hasRequiredProtocolDiagnostic = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
    const vscode = require$$0;
    const Is2 = requireIs();
    (function(DiagnosticCode) {
      function is2(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && (Is2.number(candidate.value) || Is2.string(candidate.value)) && Is2.string(candidate.target);
      }
      DiagnosticCode.is = is2;
    })(exports.DiagnosticCode || (exports.DiagnosticCode = {}));
    class ProtocolDiagnostic extends vscode.Diagnostic {
      constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
      }
    }
    exports.ProtocolDiagnostic = ProtocolDiagnostic;
  })(protocolDiagnostic);
  return protocolDiagnostic;
}
var protocolCallHierarchyItem = {};
var hasRequiredProtocolCallHierarchyItem;
function requireProtocolCallHierarchyItem() {
  if (hasRequiredProtocolCallHierarchyItem)
    return protocolCallHierarchyItem;
  hasRequiredProtocolCallHierarchyItem = 1;
  Object.defineProperty(protocolCallHierarchyItem, "__esModule", { value: true });
  const code = require$$0;
  class ProtocolCallHierarchyItem extends code.CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange2, data) {
      super(kind, name, detail, uri, range, selectionRange2);
      if (data !== void 0) {
        this.data = data;
      }
    }
  }
  protocolCallHierarchyItem.default = ProtocolCallHierarchyItem;
  return protocolCallHierarchyItem;
}
var protocolTypeHierarchyItem = {};
var hasRequiredProtocolTypeHierarchyItem;
function requireProtocolTypeHierarchyItem() {
  if (hasRequiredProtocolTypeHierarchyItem)
    return protocolTypeHierarchyItem;
  hasRequiredProtocolTypeHierarchyItem = 1;
  Object.defineProperty(protocolTypeHierarchyItem, "__esModule", { value: true });
  const code = require$$0;
  class ProtocolTypeHierarchyItem extends code.TypeHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange2, data) {
      super(kind, name, detail, uri, range, selectionRange2);
      if (data !== void 0) {
        this.data = data;
      }
    }
  }
  protocolTypeHierarchyItem.default = ProtocolTypeHierarchyItem;
  return protocolTypeHierarchyItem;
}
var protocolWorkspaceSymbol = {};
var hasRequiredProtocolWorkspaceSymbol;
function requireProtocolWorkspaceSymbol() {
  if (hasRequiredProtocolWorkspaceSymbol)
    return protocolWorkspaceSymbol;
  hasRequiredProtocolWorkspaceSymbol = 1;
  Object.defineProperty(protocolWorkspaceSymbol, "__esModule", { value: true });
  const code = require$$0;
  class WorkspaceSymbol2 extends code.SymbolInformation {
    constructor(name, kind, containerName, locationOrUri, data) {
      const hasRange = !(locationOrUri instanceof code.Uri);
      super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
      this.hasRange = hasRange;
      if (data !== void 0) {
        this.data = data;
      }
    }
  }
  protocolWorkspaceSymbol.default = WorkspaceSymbol2;
  return protocolWorkspaceSymbol;
}
var protocolInlayHint = {};
var hasRequiredProtocolInlayHint;
function requireProtocolInlayHint() {
  if (hasRequiredProtocolInlayHint)
    return protocolInlayHint;
  hasRequiredProtocolInlayHint = 1;
  Object.defineProperty(protocolInlayHint, "__esModule", { value: true });
  const code = require$$0;
  class ProtocolInlayHint extends code.InlayHint {
    constructor(position, label, kind) {
      super(position, label, kind);
    }
  }
  protocolInlayHint.default = ProtocolInlayHint;
  return protocolInlayHint;
}
var hasRequiredCodeConverter;
function requireCodeConverter() {
  if (hasRequiredCodeConverter)
    return codeConverter;
  hasRequiredCodeConverter = 1;
  Object.defineProperty(codeConverter, "__esModule", { value: true });
  codeConverter.createConverter = void 0;
  const code = require$$0;
  const proto = requireMain();
  const Is2 = requireIs();
  const async2 = requireAsync();
  const protocolCompletionItem_1 = requireProtocolCompletionItem();
  const protocolCodeLens_1 = requireProtocolCodeLens();
  const protocolDocumentLink_1 = requireProtocolDocumentLink();
  const protocolCodeAction_1 = requireProtocolCodeAction();
  const protocolDiagnostic_1 = requireProtocolDiagnostic();
  const protocolCallHierarchyItem_1 = requireProtocolCallHierarchyItem();
  const protocolTypeHierarchyItem_1 = requireProtocolTypeHierarchyItem();
  const protocolWorkspaceSymbol_1 = requireProtocolWorkspaceSymbol();
  const protocolInlayHint_1 = requireProtocolInlayHint();
  var InsertReplaceRange;
  (function(InsertReplaceRange2) {
    function is2(value) {
      const candidate = value;
      return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    InsertReplaceRange2.is = is2;
  })(InsertReplaceRange || (InsertReplaceRange = {}));
  function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
      return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
      return {
        uri: _uriConverter(textDocument.uri)
      };
    }
    function asTextDocumentItem(textDocument) {
      return {
        uri: _uriConverter(textDocument.uri),
        languageId: textDocument.languageId,
        version: textDocument.version,
        text: textDocument.getText()
      };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
      return {
        uri: _uriConverter(textDocument.uri),
        version: textDocument.version
      };
    }
    function asOpenTextDocumentParams(textDocument) {
      return {
        textDocument: asTextDocumentItem(textDocument)
      };
    }
    function isTextDocumentChangeEvent(value) {
      const candidate = value;
      return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
      const candidate = value;
      return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg0, arg1, arg2) {
      if (isTextDocument(arg0)) {
        const result = {
          textDocument: {
            uri: _uriConverter(arg0.uri),
            version: arg0.version
          },
          contentChanges: [{ text: arg0.getText() }]
        };
        return result;
      } else if (isTextDocumentChangeEvent(arg0)) {
        const uri = arg1;
        const version = arg2;
        const result = {
          textDocument: {
            uri: _uriConverter(uri),
            version
          },
          contentChanges: arg0.contentChanges.map((change) => {
            const range = change.range;
            return {
              range: {
                start: { line: range.start.line, character: range.start.character },
                end: { line: range.end.line, character: range.end.character }
              },
              rangeLength: change.rangeLength,
              text: change.text
            };
          })
        };
        return result;
      } else {
        throw Error("Unsupported text document change parameter");
      }
    }
    function asCloseTextDocumentParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
      let result = {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
      if (includeContent) {
        result.text = textDocument.getText();
      }
      return result;
    }
    function asTextDocumentSaveReason(reason) {
      switch (reason) {
        case code.TextDocumentSaveReason.Manual:
          return proto.TextDocumentSaveReason.Manual;
        case code.TextDocumentSaveReason.AfterDelay:
          return proto.TextDocumentSaveReason.AfterDelay;
        case code.TextDocumentSaveReason.FocusOut:
          return proto.TextDocumentSaveReason.FocusOut;
      }
      return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
      return {
        textDocument: asTextDocumentIdentifier(event.document),
        reason: asTextDocumentSaveReason(event.reason)
      };
    }
    function asDidCreateFilesParams(event) {
      return {
        files: event.files.map((fileUri) => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    function asDidRenameFilesParams(event) {
      return {
        files: event.files.map((file) => ({
          oldUri: _uriConverter(file.oldUri),
          newUri: _uriConverter(file.newUri)
        }))
      };
    }
    function asDidDeleteFilesParams(event) {
      return {
        files: event.files.map((fileUri) => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    function asWillCreateFilesParams(event) {
      return {
        files: event.files.map((fileUri) => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    function asWillRenameFilesParams(event) {
      return {
        files: event.files.map((file) => ({
          oldUri: _uriConverter(file.oldUri),
          newUri: _uriConverter(file.newUri)
        }))
      };
    }
    function asWillDeleteFilesParams(event) {
      return {
        files: event.files.map((fileUri) => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    function asTextDocumentPositionParams(textDocument, position) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position)
      };
    }
    function asCompletionTriggerKind(triggerKind) {
      switch (triggerKind) {
        case code.CompletionTriggerKind.TriggerCharacter:
          return proto.CompletionTriggerKind.TriggerCharacter;
        case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
          return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
        default:
          return proto.CompletionTriggerKind.Invoked;
      }
    }
    function asCompletionParams(textDocument, position, context) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position),
        context: {
          triggerKind: asCompletionTriggerKind(context.triggerKind),
          triggerCharacter: context.triggerCharacter
        }
      };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
      switch (triggerKind) {
        case code.SignatureHelpTriggerKind.Invoke:
          return proto.SignatureHelpTriggerKind.Invoked;
        case code.SignatureHelpTriggerKind.TriggerCharacter:
          return proto.SignatureHelpTriggerKind.TriggerCharacter;
        case code.SignatureHelpTriggerKind.ContentChange:
          return proto.SignatureHelpTriggerKind.ContentChange;
      }
    }
    function asParameterInformation(value) {
      return {
        label: value.label
      };
    }
    function asParameterInformations(values) {
      return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
      return {
        label: value.label,
        parameters: asParameterInformations(value.parameters)
      };
    }
    function asSignatureInformations(values) {
      return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
      if (value === void 0) {
        return value;
      }
      return {
        signatures: asSignatureInformations(value.signatures),
        activeSignature: value.activeSignature,
        activeParameter: value.activeParameter
      };
    }
    function asSignatureHelpParams(textDocument, position, context) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position),
        context: {
          isRetrigger: context.isRetrigger,
          triggerCharacter: context.triggerCharacter,
          triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
          activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
        }
      };
    }
    function asWorkerPosition(position) {
      return { line: position.line, character: position.character };
    }
    function asPosition(value) {
      if (value === void 0 || value === null) {
        return value;
      }
      return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
    }
    function asPositions(value, token) {
      return async2.map(value, asPosition, token);
    }
    function asRange(value) {
      if (value === void 0 || value === null) {
        return value;
      }
      return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
      if (value === void 0 || value === null) {
        return value;
      }
      return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
      switch (value) {
        case code.DiagnosticSeverity.Error:
          return proto.DiagnosticSeverity.Error;
        case code.DiagnosticSeverity.Warning:
          return proto.DiagnosticSeverity.Warning;
        case code.DiagnosticSeverity.Information:
          return proto.DiagnosticSeverity.Information;
        case code.DiagnosticSeverity.Hint:
          return proto.DiagnosticSeverity.Hint;
      }
    }
    function asDiagnosticTags(tags) {
      if (!tags) {
        return void 0;
      }
      let result = [];
      for (let tag of tags) {
        let converted = asDiagnosticTag(tag);
        if (converted !== void 0) {
          result.push(converted);
        }
      }
      return result.length > 0 ? result : void 0;
    }
    function asDiagnosticTag(tag) {
      switch (tag) {
        case code.DiagnosticTag.Unnecessary:
          return proto.DiagnosticTag.Unnecessary;
        case code.DiagnosticTag.Deprecated:
          return proto.DiagnosticTag.Deprecated;
        default:
          return void 0;
      }
    }
    function asRelatedInformation(item) {
      return {
        message: item.message,
        location: asLocation(item.location)
      };
    }
    function asRelatedInformations(items) {
      return items.map(asRelatedInformation);
    }
    function asDiagnosticCode(value) {
      if (value === void 0 || value === null) {
        return void 0;
      }
      if (Is2.number(value) || Is2.string(value)) {
        return value;
      }
      return { value: value.value, target: asUri(value.target) };
    }
    function asDiagnostic(item) {
      const result = proto.Diagnostic.create(asRange(item.range), item.message);
      const protocolDiagnostic2 = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
      if (protocolDiagnostic2 !== void 0 && protocolDiagnostic2.data !== void 0) {
        result.data = protocolDiagnostic2.data;
      }
      const code2 = asDiagnosticCode(item.code);
      if (protocolDiagnostic_1.DiagnosticCode.is(code2)) {
        if (protocolDiagnostic2 !== void 0 && protocolDiagnostic2.hasDiagnosticCode) {
          result.code = code2;
        } else {
          result.code = code2.value;
          result.codeDescription = { href: code2.target };
        }
      } else {
        result.code = code2;
      }
      if (Is2.number(item.severity)) {
        result.severity = asDiagnosticSeverity(item.severity);
      }
      if (Array.isArray(item.tags)) {
        result.tags = asDiagnosticTags(item.tags);
      }
      if (item.relatedInformation) {
        result.relatedInformation = asRelatedInformations(item.relatedInformation);
      }
      if (item.source) {
        result.source = item.source;
      }
      return result;
    }
    function asDiagnostics(items, token) {
      if (items === void 0 || items === null) {
        return items;
      }
      return async2.map(items, asDiagnostic, token);
    }
    function asDocumentation(format2, documentation) {
      switch (format2) {
        case "$string":
          return documentation;
        case proto.MarkupKind.PlainText:
          return { kind: format2, value: documentation };
        case proto.MarkupKind.Markdown:
          return { kind: format2, value: documentation.value };
        default:
          return `Unsupported Markup content received. Kind is: ${format2}`;
      }
    }
    function asCompletionItemTag(tag) {
      switch (tag) {
        case code.CompletionItemTag.Deprecated:
          return proto.CompletionItemTag.Deprecated;
      }
      return void 0;
    }
    function asCompletionItemTags(tags) {
      if (tags === void 0) {
        return tags;
      }
      const result = [];
      for (let tag of tags) {
        const converted = asCompletionItemTag(tag);
        if (converted !== void 0) {
          result.push(converted);
        }
      }
      return result;
    }
    function asCompletionItemKind(value, original) {
      if (original !== void 0) {
        return original;
      }
      return value + 1;
    }
    function asCompletionItem(item, labelDetailsSupport = false) {
      let label;
      let labelDetails;
      if (Is2.string(item.label)) {
        label = item.label;
      } else {
        label = item.label.label;
        if (labelDetailsSupport && (item.label.detail !== void 0 || item.label.description !== void 0)) {
          labelDetails = { detail: item.label.detail, description: item.label.description };
        }
      }
      let result = { label };
      if (labelDetails !== void 0) {
        result.labelDetails = labelDetails;
      }
      let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
      if (item.detail) {
        result.detail = item.detail;
      }
      if (item.documentation) {
        if (!protocolItem || protocolItem.documentationFormat === "$string") {
          result.documentation = item.documentation;
        } else {
          result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
        }
      }
      if (item.filterText) {
        result.filterText = item.filterText;
      }
      fillPrimaryInsertText(result, item);
      if (Is2.number(item.kind)) {
        result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
      }
      if (item.sortText) {
        result.sortText = item.sortText;
      }
      if (item.additionalTextEdits) {
        result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
      }
      if (item.commitCharacters) {
        result.commitCharacters = item.commitCharacters.slice();
      }
      if (item.command) {
        result.command = asCommand(item.command);
      }
      if (item.preselect === true || item.preselect === false) {
        result.preselect = item.preselect;
      }
      const tags = asCompletionItemTags(item.tags);
      if (protocolItem) {
        if (protocolItem.data !== void 0) {
          result.data = protocolItem.data;
        }
        if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
          if (protocolItem.deprecated === true && tags !== void 0 && tags.length > 0) {
            const index2 = tags.indexOf(code.CompletionItemTag.Deprecated);
            if (index2 !== -1) {
              tags.splice(index2, 1);
            }
          }
          result.deprecated = protocolItem.deprecated;
        }
        if (protocolItem.insertTextMode !== void 0) {
          result.insertTextMode = protocolItem.insertTextMode;
        }
      }
      if (tags !== void 0 && tags.length > 0) {
        result.tags = tags;
      }
      if (result.insertTextMode === void 0 && item.keepWhitespace === true) {
        result.insertTextMode = proto.InsertTextMode.adjustIndentation;
      }
      return result;
    }
    function fillPrimaryInsertText(target, source) {
      let format2 = proto.InsertTextFormat.PlainText;
      let text = void 0;
      let range = void 0;
      if (source.textEdit) {
        text = source.textEdit.newText;
        range = source.textEdit.range;
      } else if (source.insertText instanceof code.SnippetString) {
        format2 = proto.InsertTextFormat.Snippet;
        text = source.insertText.value;
      } else {
        text = source.insertText;
      }
      if (source.range) {
        range = source.range;
      }
      target.insertTextFormat = format2;
      if (source.fromEdit && text !== void 0 && range !== void 0) {
        target.textEdit = asCompletionTextEdit(text, range);
      } else {
        target.insertText = text;
      }
    }
    function asCompletionTextEdit(newText, range) {
      if (InsertReplaceRange.is(range)) {
        return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
      } else {
        return { newText, range: asRange(range) };
      }
    }
    function asTextEdit(edit) {
      return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
      if (edits === void 0 || edits === null) {
        return edits;
      }
      return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
      if (item <= code.SymbolKind.TypeParameter) {
        return item + 1;
      }
      return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
      return item;
    }
    function asSymbolTags(items) {
      return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position),
        context: { includeDeclaration: options.includeDeclaration }
      };
    }
    async function asCodeAction(item, token) {
      let result = proto.CodeAction.create(item.title);
      if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
        result.data = item.data;
      }
      if (item.kind !== void 0) {
        result.kind = asCodeActionKind(item.kind);
      }
      if (item.diagnostics !== void 0) {
        result.diagnostics = await asDiagnostics(item.diagnostics, token);
      }
      if (item.edit !== void 0) {
        throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
      }
      if (item.command !== void 0) {
        result.command = asCommand(item.command);
      }
      if (item.isPreferred !== void 0) {
        result.isPreferred = item.isPreferred;
      }
      if (item.disabled !== void 0) {
        result.disabled = { reason: item.disabled.reason };
      }
      return result;
    }
    async function asCodeActionContext(context, token) {
      if (context === void 0 || context === null) {
        return context;
      }
      let only;
      if (context.only && Is2.string(context.only.value)) {
        only = [context.only.value];
      }
      return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
    }
    function asCodeActionTriggerKind(kind) {
      switch (kind) {
        case code.CodeActionTriggerKind.Invoke:
          return proto.CodeActionTriggerKind.Invoked;
        case code.CodeActionTriggerKind.Automatic:
          return proto.CodeActionTriggerKind.Automatic;
        default:
          return void 0;
      }
    }
    function asCodeActionKind(item) {
      if (item === void 0 || item === null) {
        return void 0;
      }
      return item.value;
    }
    function asInlineValueContext(context) {
      if (context === void 0 || context === null) {
        return context;
      }
      return proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
    }
    function asCommand(item) {
      let result = proto.Command.create(item.title, item.command);
      if (item.arguments) {
        result.arguments = item.arguments;
      }
      return result;
    }
    function asCodeLens(item) {
      let result = proto.CodeLens.create(asRange(item.range));
      if (item.command) {
        result.command = asCommand(item.command);
      }
      if (item instanceof protocolCodeLens_1.default) {
        if (item.data) {
          result.data = item.data;
        }
      }
      return result;
    }
    function asFormattingOptions(options, fileOptions) {
      const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
      if (fileOptions.trimTrailingWhitespace) {
        result.trimTrailingWhitespace = true;
      }
      if (fileOptions.trimFinalNewlines) {
        result.trimFinalNewlines = true;
      }
      if (fileOptions.insertFinalNewline) {
        result.insertFinalNewline = true;
      }
      return result;
    }
    function asDocumentSymbolParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    function asCodeLensParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    function asDocumentLink(item) {
      let result = proto.DocumentLink.create(asRange(item.range));
      if (item.target) {
        result.target = asUri(item.target);
      }
      if (item.tooltip !== void 0) {
        result.tooltip = item.tooltip;
      }
      let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
      if (protocolItem && protocolItem.data) {
        result.data = protocolItem.data;
      }
      return result;
    }
    function asDocumentLinkParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    function asCallHierarchyItem(value) {
      const result = {
        name: value.name,
        kind: asSymbolKind(value.kind),
        uri: asUri(value.uri),
        range: asRange(value.range),
        selectionRange: asRange(value.selectionRange)
      };
      if (value.detail !== void 0 && value.detail.length > 0) {
        result.detail = value.detail;
      }
      if (value.tags !== void 0) {
        result.tags = asSymbolTags(value.tags);
      }
      if (value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0) {
        result.data = value.data;
      }
      return result;
    }
    function asTypeHierarchyItem(value) {
      const result = {
        name: value.name,
        kind: asSymbolKind(value.kind),
        uri: asUri(value.uri),
        range: asRange(value.range),
        selectionRange: asRange(value.selectionRange)
      };
      if (value.detail !== void 0 && value.detail.length > 0) {
        result.detail = value.detail;
      }
      if (value.tags !== void 0) {
        result.tags = asSymbolTags(value.tags);
      }
      if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== void 0) {
        result.data = value.data;
      }
      return result;
    }
    function asWorkspaceSymbol(item) {
      const result = item instanceof protocolWorkspaceSymbol_1.default ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data } : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
      if (item.tags !== void 0) {
        result.tags = asSymbolTags(item.tags);
      }
      if (item.containerName !== "") {
        result.containerName = item.containerName;
      }
      return result;
    }
    function asInlayHint(item) {
      const label = typeof item.label === "string" ? item.label : item.label.map(asInlayHintLabelPart);
      const result = proto.InlayHint.create(asPosition(item.position), label);
      if (item.kind !== void 0) {
        result.kind = item.kind;
      }
      if (item.textEdits !== void 0) {
        result.textEdits = asTextEdits(item.textEdits);
      }
      if (item.tooltip !== void 0) {
        result.tooltip = asTooltip(item.tooltip);
      }
      if (item.paddingLeft !== void 0) {
        result.paddingLeft = item.paddingLeft;
      }
      if (item.paddingRight !== void 0) {
        result.paddingRight = item.paddingRight;
      }
      if (item instanceof protocolInlayHint_1.default && item.data !== void 0) {
        result.data = item.data;
      }
      return result;
    }
    function asInlayHintLabelPart(item) {
      const result = proto.InlayHintLabelPart.create(item.value);
      if (item.location !== void 0) {
        result.location = asLocation(item.location);
      }
      if (item.command !== void 0) {
        result.command = asCommand(item.command);
      }
      if (item.tooltip !== void 0) {
        result.tooltip = asTooltip(item.tooltip);
      }
      return result;
    }
    function asTooltip(value) {
      if (typeof value === "string") {
        return value;
      }
      const result = {
        kind: proto.MarkupKind.Markdown,
        value: value.value
      };
      return result;
    }
    return {
      asUri,
      asTextDocumentIdentifier,
      asTextDocumentItem,
      asVersionedTextDocumentIdentifier,
      asOpenTextDocumentParams,
      asChangeTextDocumentParams,
      asCloseTextDocumentParams,
      asSaveTextDocumentParams,
      asWillSaveTextDocumentParams,
      asDidCreateFilesParams,
      asDidRenameFilesParams,
      asDidDeleteFilesParams,
      asWillCreateFilesParams,
      asWillRenameFilesParams,
      asWillDeleteFilesParams,
      asTextDocumentPositionParams,
      asCompletionParams,
      asSignatureHelpParams,
      asWorkerPosition,
      asRange,
      asPosition,
      asPositions,
      asLocation,
      asDiagnosticSeverity,
      asDiagnosticTag,
      asDiagnostic,
      asDiagnostics,
      asCompletionItem,
      asTextEdit,
      asSymbolKind,
      asSymbolTag,
      asSymbolTags,
      asReferenceParams,
      asCodeAction,
      asCodeActionContext,
      asInlineValueContext,
      asCommand,
      asCodeLens,
      asFormattingOptions,
      asDocumentSymbolParams,
      asCodeLensParams,
      asDocumentLink,
      asDocumentLinkParams,
      asCallHierarchyItem,
      asTypeHierarchyItem,
      asInlayHint,
      asWorkspaceSymbol
    };
  }
  codeConverter.createConverter = createConverter;
  return codeConverter;
}
var protocolConverter = {};
var hasRequiredProtocolConverter;
function requireProtocolConverter() {
  if (hasRequiredProtocolConverter)
    return protocolConverter;
  hasRequiredProtocolConverter = 1;
  Object.defineProperty(protocolConverter, "__esModule", { value: true });
  protocolConverter.createConverter = void 0;
  const code = require$$0;
  const ls = requireMain();
  const Is2 = requireIs();
  const async2 = requireAsync();
  const protocolCompletionItem_1 = requireProtocolCompletionItem();
  const protocolCodeLens_1 = requireProtocolCodeLens();
  const protocolDocumentLink_1 = requireProtocolDocumentLink();
  const protocolCodeAction_1 = requireProtocolCodeAction();
  const protocolDiagnostic_1 = requireProtocolDiagnostic();
  const protocolCallHierarchyItem_1 = requireProtocolCallHierarchyItem();
  const protocolTypeHierarchyItem_1 = requireProtocolTypeHierarchyItem();
  const protocolWorkspaceSymbol_1 = requireProtocolWorkspaceSymbol();
  const protocolInlayHint_1 = requireProtocolInlayHint();
  const vscode_languageserver_protocol_1 = requireMain();
  var CodeBlock;
  (function(CodeBlock2) {
    function is2(value) {
      let candidate = value;
      return candidate && Is2.string(candidate.language) && Is2.string(candidate.value);
    }
    CodeBlock2.is = is2;
  })(CodeBlock || (CodeBlock = {}));
  function createConverter(uriConverter, trustMarkdown, supportHtml) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
      return _uriConverter(value);
    }
    function asDocumentSelector(selector) {
      const result = [];
      for (const filter of selector) {
        if (typeof filter === "string") {
          result.push(filter);
        } else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
          if (typeof filter.notebook === "string") {
            result.push({ notebookType: filter.notebook, language: filter.language });
          } else {
            const notebookType = filter.notebook.notebookType ?? "*";
            result.push({ notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
          }
        } else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
          result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
        }
      }
      return result;
    }
    async function asDiagnostics(diagnostics, token) {
      return async2.map(diagnostics, asDiagnostic, token);
    }
    function asDiagnosticsSync(diagnostics) {
      const result = new Array(diagnostics.length);
      for (let i = 0; i < diagnostics.length; i++) {
        result[i] = asDiagnostic(diagnostics[i]);
      }
      return result;
    }
    function asDiagnostic(diagnostic2) {
      let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic2.range), diagnostic2.message, asDiagnosticSeverity(diagnostic2.severity), diagnostic2.data);
      if (diagnostic2.code !== void 0) {
        if (typeof diagnostic2.code === "string" || typeof diagnostic2.code === "number") {
          if (ls.CodeDescription.is(diagnostic2.codeDescription)) {
            result.code = {
              value: diagnostic2.code,
              target: asUri(diagnostic2.codeDescription.href)
            };
          } else {
            result.code = diagnostic2.code;
          }
        } else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic2.code)) {
          result.hasDiagnosticCode = true;
          const diagnosticCode = diagnostic2.code;
          result.code = {
            value: diagnosticCode.value,
            target: asUri(diagnosticCode.target)
          };
        }
      }
      if (diagnostic2.source) {
        result.source = diagnostic2.source;
      }
      if (diagnostic2.relatedInformation) {
        result.relatedInformation = asRelatedInformation(diagnostic2.relatedInformation);
      }
      if (Array.isArray(diagnostic2.tags)) {
        result.tags = asDiagnosticTags(diagnostic2.tags);
      }
      return result;
    }
    function asRelatedInformation(relatedInformation) {
      const result = new Array(relatedInformation.length);
      for (let i = 0; i < relatedInformation.length; i++) {
        const info = relatedInformation[i];
        result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
      }
      return result;
    }
    function asDiagnosticTags(tags) {
      if (!tags) {
        return void 0;
      }
      let result = [];
      for (let tag of tags) {
        let converted = asDiagnosticTag(tag);
        if (converted !== void 0) {
          result.push(converted);
        }
      }
      return result.length > 0 ? result : void 0;
    }
    function asDiagnosticTag(tag) {
      switch (tag) {
        case ls.DiagnosticTag.Unnecessary:
          return code.DiagnosticTag.Unnecessary;
        case ls.DiagnosticTag.Deprecated:
          return code.DiagnosticTag.Deprecated;
        default:
          return void 0;
      }
    }
    function asPosition(value) {
      return value ? new code.Position(value.line, value.character) : void 0;
    }
    function asRange(value) {
      return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : void 0;
    }
    async function asRanges(items, token) {
      return async2.map(items, (range) => {
        return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
      }, token);
    }
    function asDiagnosticSeverity(value) {
      if (value === void 0 || value === null) {
        return code.DiagnosticSeverity.Error;
      }
      switch (value) {
        case ls.DiagnosticSeverity.Error:
          return code.DiagnosticSeverity.Error;
        case ls.DiagnosticSeverity.Warning:
          return code.DiagnosticSeverity.Warning;
        case ls.DiagnosticSeverity.Information:
          return code.DiagnosticSeverity.Information;
        case ls.DiagnosticSeverity.Hint:
          return code.DiagnosticSeverity.Hint;
      }
      return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
      if (Is2.string(value)) {
        return asMarkdownString(value);
      } else if (CodeBlock.is(value)) {
        let result = asMarkdownString();
        return result.appendCodeblock(value.value, value.language);
      } else if (Array.isArray(value)) {
        let result = [];
        for (let element of value) {
          let item = asMarkdownString();
          if (CodeBlock.is(element)) {
            item.appendCodeblock(element.value, element.language);
          } else {
            item.appendMarkdown(element);
          }
          result.push(item);
        }
        return result;
      } else {
        return asMarkdownString(value);
      }
    }
    function asDocumentation(value) {
      if (Is2.string(value)) {
        return value;
      } else {
        switch (value.kind) {
          case ls.MarkupKind.Markdown:
            return asMarkdownString(value.value);
          case ls.MarkupKind.PlainText:
            return value.value;
          default:
            return `Unsupported Markup content received. Kind is: ${value.kind}`;
        }
      }
    }
    function asMarkdownString(value) {
      let result;
      if (value === void 0 || typeof value === "string") {
        result = new code.MarkdownString(value);
      } else {
        switch (value.kind) {
          case ls.MarkupKind.Markdown:
            result = new code.MarkdownString(value.value);
            break;
          case ls.MarkupKind.PlainText:
            result = new code.MarkdownString();
            result.appendText(value.value);
            break;
          default:
            result = new code.MarkdownString();
            result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
            break;
        }
      }
      result.isTrusted = trustMarkdown;
      result.supportHtml = supportHtml;
      return result;
    }
    function asHover(hover2) {
      if (!hover2) {
        return void 0;
      }
      return new code.Hover(asHoverContent(hover2.contents), asRange(hover2.range));
    }
    async function asCompletionResult(value, allCommitCharacters, token) {
      if (!value) {
        return void 0;
      }
      if (Array.isArray(value)) {
        return async2.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
      }
      const list = value;
      const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
      const converted = await async2.map(list.items, (item) => {
        var _a3, _b3, _c3;
        return asCompletionItem(item, commitCharacters, defaultRange, (_a3 = list.itemDefaults) == null ? void 0 : _a3.insertTextMode, (_b3 = list.itemDefaults) == null ? void 0 : _b3.insertTextFormat, (_c3 = list.itemDefaults) == null ? void 0 : _c3.data);
      }, token);
      return new code.CompletionList(converted, list.isIncomplete);
    }
    function getCompletionItemDefaults(list, allCommitCharacters) {
      var _a3, _b3;
      const rangeDefaults = (_a3 = list.itemDefaults) == null ? void 0 : _a3.editRange;
      const commitCharacters = ((_b3 = list.itemDefaults) == null ? void 0 : _b3.commitCharacters) ?? allCommitCharacters;
      return ls.Range.is(rangeDefaults) ? { defaultRange: asRange(rangeDefaults), commitCharacters } : rangeDefaults !== void 0 ? { defaultRange: { inserting: asRange(rangeDefaults.insert), replacing: asRange(rangeDefaults.replace) }, commitCharacters } : { defaultRange: void 0, commitCharacters };
    }
    function asCompletionItemKind(value) {
      if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
        return [value - 1, void 0];
      }
      return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
      switch (tag) {
        case ls.CompletionItemTag.Deprecated:
          return code.CompletionItemTag.Deprecated;
      }
      return void 0;
    }
    function asCompletionItemTags(tags) {
      if (tags === void 0 || tags === null) {
        return [];
      }
      const result = [];
      for (const tag of tags) {
        const converted = asCompletionItemTag(tag);
        if (converted !== void 0) {
          result.push(converted);
        }
      }
      return result;
    }
    function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
      const tags = asCompletionItemTags(item.tags);
      const label = asCompletionItemLabel(item);
      const result = new protocolCompletionItem_1.default(label);
      if (item.detail) {
        result.detail = item.detail;
      }
      if (item.documentation) {
        result.documentation = asDocumentation(item.documentation);
        result.documentationFormat = Is2.string(item.documentation) ? "$string" : item.documentation.kind;
      }
      if (item.filterText) {
        result.filterText = item.filterText;
      }
      const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
      if (insertText) {
        result.insertText = insertText.text;
        result.range = insertText.range;
        result.fromEdit = insertText.fromEdit;
      }
      if (Is2.number(item.kind)) {
        let [itemKind, original] = asCompletionItemKind(item.kind);
        result.kind = itemKind;
        if (original) {
          result.originalItemKind = original;
        }
      }
      if (item.sortText) {
        result.sortText = item.sortText;
      }
      if (item.additionalTextEdits) {
        result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
      }
      const commitCharacters = item.commitCharacters !== void 0 ? Is2.stringArray(item.commitCharacters) ? item.commitCharacters : void 0 : defaultCommitCharacters;
      if (commitCharacters) {
        result.commitCharacters = commitCharacters.slice();
      }
      if (item.command) {
        result.command = asCommand(item.command);
      }
      if (item.deprecated === true || item.deprecated === false) {
        result.deprecated = item.deprecated;
        if (item.deprecated === true) {
          tags.push(code.CompletionItemTag.Deprecated);
        }
      }
      if (item.preselect === true || item.preselect === false) {
        result.preselect = item.preselect;
      }
      const data = item.data ?? defaultData;
      if (data !== void 0) {
        result.data = data;
      }
      if (tags.length > 0) {
        result.tags = tags;
      }
      const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
      if (insertTextMode !== void 0) {
        result.insertTextMode = insertTextMode;
        if (insertTextMode === ls.InsertTextMode.asIs) {
          result.keepWhitespace = true;
        }
      }
      return result;
    }
    function asCompletionItemLabel(item) {
      if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
        return {
          label: item.label,
          detail: item.labelDetails.detail,
          description: item.labelDetails.description
        };
      } else {
        return item.label;
      }
    }
    function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
      const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
      if (item.textEdit !== void 0 || defaultRange !== void 0) {
        const [range, newText] = item.textEdit !== void 0 ? getCompletionRangeAndText(item.textEdit) : [defaultRange, item.textEditText ?? item.label];
        if (insertTextFormat === ls.InsertTextFormat.Snippet) {
          return { text: new code.SnippetString(newText), range, fromEdit: true };
        } else {
          return { text: newText, range, fromEdit: true };
        }
      } else if (item.insertText) {
        if (insertTextFormat === ls.InsertTextFormat.Snippet) {
          return { text: new code.SnippetString(item.insertText), fromEdit: false };
        } else {
          return { text: item.insertText, fromEdit: false };
        }
      } else {
        return void 0;
      }
    }
    function getCompletionRangeAndText(value) {
      if (ls.InsertReplaceEdit.is(value)) {
        return [{ inserting: asRange(value.insert), replacing: asRange(value.replace) }, value.newText];
      } else {
        return [asRange(value.range), value.newText];
      }
    }
    function asTextEdit(edit) {
      if (!edit) {
        return void 0;
      }
      return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    async function asTextEdits(items, token) {
      if (!items) {
        return void 0;
      }
      return async2.map(items, asTextEdit, token);
    }
    function asTextEditsSync(items) {
      if (!items) {
        return void 0;
      }
      const result = new Array(items.length);
      for (let i = 0; i < items.length; i++) {
        result[i] = asTextEdit(items[i]);
      }
      return result;
    }
    async function asSignatureHelp(item, token) {
      if (!item) {
        return void 0;
      }
      let result = new code.SignatureHelp();
      if (Is2.number(item.activeSignature)) {
        result.activeSignature = item.activeSignature;
      } else {
        result.activeSignature = 0;
      }
      if (Is2.number(item.activeParameter)) {
        result.activeParameter = item.activeParameter;
      } else {
        result.activeParameter = 0;
      }
      if (item.signatures) {
        result.signatures = await asSignatureInformations(item.signatures, token);
      }
      return result;
    }
    async function asSignatureInformations(items, token) {
      return async2.mapAsync(items, asSignatureInformation, token);
    }
    async function asSignatureInformation(item, token) {
      let result = new code.SignatureInformation(item.label);
      if (item.documentation !== void 0) {
        result.documentation = asDocumentation(item.documentation);
      }
      if (item.parameters !== void 0) {
        result.parameters = await asParameterInformations(item.parameters, token);
      }
      if (item.activeParameter !== void 0) {
        result.activeParameter = item.activeParameter;
      }
      {
        return result;
      }
    }
    function asParameterInformations(items, token) {
      return async2.map(items, asParameterInformation, token);
    }
    function asParameterInformation(item) {
      let result = new code.ParameterInformation(item.label);
      if (item.documentation) {
        result.documentation = asDocumentation(item.documentation);
      }
      return result;
    }
    function asLocation(item) {
      return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : void 0;
    }
    async function asDeclarationResult(item, token) {
      if (!item) {
        return void 0;
      }
      return asLocationResult(item, token);
    }
    async function asDefinitionResult(item, token) {
      if (!item) {
        return void 0;
      }
      return asLocationResult(item, token);
    }
    function asLocationLink(item) {
      if (!item) {
        return void 0;
      }
      let result = {
        targetUri: _uriConverter(item.targetUri),
        targetRange: asRange(item.targetRange),
        originSelectionRange: asRange(item.originSelectionRange),
        targetSelectionRange: asRange(item.targetSelectionRange)
      };
      if (!result.targetSelectionRange) {
        throw new Error(`targetSelectionRange must not be undefined or null`);
      }
      return result;
    }
    async function asLocationResult(item, token) {
      if (!item) {
        return void 0;
      }
      if (Is2.array(item)) {
        if (item.length === 0) {
          return [];
        } else if (ls.LocationLink.is(item[0])) {
          const links2 = item;
          return async2.map(links2, asLocationLink, token);
        } else {
          const locations = item;
          return async2.map(locations, asLocation, token);
        }
      } else if (ls.LocationLink.is(item)) {
        return [asLocationLink(item)];
      } else {
        return asLocation(item);
      }
    }
    async function asReferences(values, token) {
      if (!values) {
        return void 0;
      }
      return async2.map(values, asLocation, token);
    }
    async function asDocumentHighlights(values, token) {
      if (!values) {
        return void 0;
      }
      return async2.map(values, asDocumentHighlight, token);
    }
    function asDocumentHighlight(item) {
      let result = new code.DocumentHighlight(asRange(item.range));
      if (Is2.number(item.kind)) {
        result.kind = asDocumentHighlightKind(item.kind);
      }
      return result;
    }
    function asDocumentHighlightKind(item) {
      switch (item) {
        case ls.DocumentHighlightKind.Text:
          return code.DocumentHighlightKind.Text;
        case ls.DocumentHighlightKind.Read:
          return code.DocumentHighlightKind.Read;
        case ls.DocumentHighlightKind.Write:
          return code.DocumentHighlightKind.Write;
      }
      return code.DocumentHighlightKind.Text;
    }
    async function asSymbolInformations(values, token) {
      if (!values) {
        return void 0;
      }
      return async2.map(values, asSymbolInformation, token);
    }
    function asSymbolKind(item) {
      if (item <= ls.SymbolKind.TypeParameter) {
        return item - 1;
      }
      return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
      switch (value) {
        case ls.SymbolTag.Deprecated:
          return code.SymbolTag.Deprecated;
        default:
          return void 0;
      }
    }
    function asSymbolTags(items) {
      if (items === void 0 || items === null) {
        return void 0;
      }
      const result = [];
      for (const item of items) {
        const converted = asSymbolTag(item);
        if (converted !== void 0) {
          result.push(converted);
        }
      }
      return result.length === 0 ? void 0 : result;
    }
    function asSymbolInformation(item) {
      const data = item.data;
      const location = item.location;
      const result = location.range === void 0 || data !== void 0 ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? "", location.range === void 0 ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data) : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? "", new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
      fillTags(result, item);
      return result;
    }
    async function asDocumentSymbols(values, token) {
      if (values === void 0 || values === null) {
        return void 0;
      }
      return async2.map(values, asDocumentSymbol, token);
    }
    function asDocumentSymbol(value) {
      let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
      fillTags(result, value);
      if (value.children !== void 0 && value.children.length > 0) {
        let children = [];
        for (let child of value.children) {
          children.push(asDocumentSymbol(child));
        }
        result.children = children;
      }
      return result;
    }
    function fillTags(result, value) {
      result.tags = asSymbolTags(value.tags);
      if (value.deprecated) {
        if (!result.tags) {
          result.tags = [code.SymbolTag.Deprecated];
        } else {
          if (!result.tags.includes(code.SymbolTag.Deprecated)) {
            result.tags = result.tags.concat(code.SymbolTag.Deprecated);
          }
        }
      }
    }
    function asCommand(item) {
      let result = { title: item.title, command: item.command };
      if (item.arguments) {
        result.arguments = item.arguments;
      }
      return result;
    }
    async function asCommands(items, token) {
      if (!items) {
        return void 0;
      }
      return async2.map(items, asCommand, token);
    }
    const kindMapping = /* @__PURE__ */ new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
      if (item === void 0 || item === null) {
        return void 0;
      }
      let result = kindMapping.get(item);
      if (result) {
        return result;
      }
      let parts = item.split(".");
      result = code.CodeActionKind.Empty;
      for (let part of parts) {
        result = result.append(part);
      }
      return result;
    }
    function asCodeActionKinds(items) {
      if (items === void 0 || items === null) {
        return void 0;
      }
      return items.map((kind) => asCodeActionKind(kind));
    }
    async function asCodeAction(item, token) {
      if (item === void 0 || item === null) {
        return void 0;
      }
      let result = new protocolCodeAction_1.default(item.title, item.data);
      if (item.kind !== void 0) {
        result.kind = asCodeActionKind(item.kind);
      }
      if (item.diagnostics !== void 0) {
        result.diagnostics = asDiagnosticsSync(item.diagnostics);
      }
      if (item.edit !== void 0) {
        result.edit = await asWorkspaceEdit(item.edit, token);
      }
      if (item.command !== void 0) {
        result.command = asCommand(item.command);
      }
      if (item.isPreferred !== void 0) {
        result.isPreferred = item.isPreferred;
      }
      if (item.disabled !== void 0) {
        result.disabled = { reason: item.disabled.reason };
      }
      return result;
    }
    function asCodeActionResult(items, token) {
      return async2.mapAsync(items, async (item) => {
        if (ls.Command.is(item)) {
          return asCommand(item);
        } else {
          return asCodeAction(item, token);
        }
      }, token);
    }
    function asCodeLens(item) {
      if (!item) {
        return void 0;
      }
      let result = new protocolCodeLens_1.default(asRange(item.range));
      if (item.command) {
        result.command = asCommand(item.command);
      }
      if (item.data !== void 0 && item.data !== null) {
        result.data = item.data;
      }
      return result;
    }
    async function asCodeLenses(items, token) {
      if (!items) {
        return void 0;
      }
      return async2.map(items, asCodeLens, token);
    }
    async function asWorkspaceEdit(item, token) {
      if (!item) {
        return void 0;
      }
      const sharedMetadata = /* @__PURE__ */ new Map();
      if (item.changeAnnotations !== void 0) {
        const changeAnnotations = item.changeAnnotations;
        await async2.forEach(Object.keys(changeAnnotations), (key) => {
          const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
          sharedMetadata.set(key, metaData);
        }, token);
      }
      const asMetadata = (annotation) => {
        if (annotation === void 0) {
          return void 0;
        } else {
          return sharedMetadata.get(annotation);
        }
      };
      const result = new code.WorkspaceEdit();
      if (item.documentChanges) {
        const documentChanges = item.documentChanges;
        await async2.forEach(documentChanges, (change) => {
          if (ls.CreateFile.is(change)) {
            result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
          } else if (ls.RenameFile.is(change)) {
            result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
          } else if (ls.DeleteFile.is(change)) {
            result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
          } else if (ls.TextDocumentEdit.is(change)) {
            const uri = _uriConverter(change.textDocument.uri);
            for (const edit of change.edits) {
              if (ls.AnnotatedTextEdit.is(edit)) {
                result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
              } else {
                result.replace(uri, asRange(edit.range), edit.newText);
              }
            }
          } else {
            throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
          }
        }, token);
      } else if (item.changes) {
        const changes = item.changes;
        await async2.forEach(Object.keys(changes), (key) => {
          result.set(_uriConverter(key), asTextEditsSync(changes[key]));
        }, token);
      }
      return result;
    }
    function asWorkspaceEditEntryMetadata(annotation) {
      if (annotation === void 0) {
        return void 0;
      }
      return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
    }
    function asDocumentLink(item) {
      let range = asRange(item.range);
      let target = item.target ? asUri(item.target) : void 0;
      let link = new protocolDocumentLink_1.default(range, target);
      if (item.tooltip !== void 0) {
        link.tooltip = item.tooltip;
      }
      if (item.data !== void 0 && item.data !== null) {
        link.data = item.data;
      }
      return link;
    }
    async function asDocumentLinks(items, token) {
      if (!items) {
        return void 0;
      }
      return async2.map(items, asDocumentLink, token);
    }
    function asColor(color) {
      return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
      return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    async function asColorInformations(colorInformation, token) {
      if (!colorInformation) {
        return void 0;
      }
      return async2.map(colorInformation, asColorInformation, token);
    }
    function asColorPresentation(cp) {
      let presentation = new code.ColorPresentation(cp.label);
      presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits);
      if (cp.textEdit) {
        presentation.textEdit = asTextEdit(cp.textEdit);
      }
      return presentation;
    }
    async function asColorPresentations(colorPresentations, token) {
      if (!colorPresentations) {
        return void 0;
      }
      return async2.map(colorPresentations, asColorPresentation, token);
    }
    function asFoldingRangeKind(kind) {
      if (kind) {
        switch (kind) {
          case ls.FoldingRangeKind.Comment:
            return code.FoldingRangeKind.Comment;
          case ls.FoldingRangeKind.Imports:
            return code.FoldingRangeKind.Imports;
          case ls.FoldingRangeKind.Region:
            return code.FoldingRangeKind.Region;
        }
      }
      return void 0;
    }
    function asFoldingRange(r) {
      return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    async function asFoldingRanges(foldingRanges, token) {
      if (!foldingRanges) {
        return void 0;
      }
      return async2.map(foldingRanges, asFoldingRange, token);
    }
    function asSelectionRange(selectionRange2) {
      return new code.SelectionRange(asRange(selectionRange2.range), selectionRange2.parent ? asSelectionRange(selectionRange2.parent) : void 0);
    }
    async function asSelectionRanges(selectionRanges, token) {
      if (!Array.isArray(selectionRanges)) {
        return [];
      }
      return async2.map(selectionRanges, asSelectionRange, token);
    }
    function asInlineValue(inlineValue2) {
      if (ls.InlineValueText.is(inlineValue2)) {
        return new code.InlineValueText(asRange(inlineValue2.range), inlineValue2.text);
      } else if (ls.InlineValueVariableLookup.is(inlineValue2)) {
        return new code.InlineValueVariableLookup(asRange(inlineValue2.range), inlineValue2.variableName, inlineValue2.caseSensitiveLookup);
      } else {
        return new code.InlineValueEvaluatableExpression(asRange(inlineValue2.range), inlineValue2.expression);
      }
    }
    async function asInlineValues(inlineValues, token) {
      if (!Array.isArray(inlineValues)) {
        return [];
      }
      return async2.map(inlineValues, asInlineValue, token);
    }
    async function asInlayHint(value, token) {
      const label = typeof value.label === "string" ? value.label : await async2.map(value.label, asInlayHintLabelPart, token);
      const result = new protocolInlayHint_1.default(asPosition(value.position), label);
      if (value.kind !== void 0) {
        result.kind = value.kind;
      }
      if (value.textEdits !== void 0) {
        result.textEdits = await asTextEdits(value.textEdits, token);
      }
      if (value.tooltip !== void 0) {
        result.tooltip = asTooltip(value.tooltip);
      }
      if (value.paddingLeft !== void 0) {
        result.paddingLeft = value.paddingLeft;
      }
      if (value.paddingRight !== void 0) {
        result.paddingRight = value.paddingRight;
      }
      if (value.data !== void 0) {
        result.data = value.data;
      }
      return result;
    }
    function asInlayHintLabelPart(part) {
      const result = new code.InlayHintLabelPart(part.value);
      if (part.location !== void 0) {
        result.location = asLocation(part.location);
      }
      if (part.tooltip !== void 0) {
        result.tooltip = asTooltip(part.tooltip);
      }
      if (part.command !== void 0) {
        result.command = asCommand(part.command);
      }
      return result;
    }
    function asTooltip(value) {
      if (typeof value === "string") {
        return value;
      }
      return asMarkdownString(value);
    }
    async function asInlayHints(values, token) {
      if (!Array.isArray(values)) {
        return void 0;
      }
      return async2.mapAsync(values, asInlayHint, token);
    }
    function asCallHierarchyItem(item) {
      if (item === null) {
        return void 0;
      }
      const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
      if (item.tags !== void 0) {
        result.tags = asSymbolTags(item.tags);
      }
      return result;
    }
    async function asCallHierarchyItems(items, token) {
      if (items === null) {
        return void 0;
      }
      return async2.map(items, asCallHierarchyItem, token);
    }
    async function asCallHierarchyIncomingCall(item, token) {
      return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyIncomingCalls(items, token) {
      if (items === null) {
        return void 0;
      }
      return async2.mapAsync(items, asCallHierarchyIncomingCall, token);
    }
    async function asCallHierarchyOutgoingCall(item, token) {
      return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyOutgoingCalls(items, token) {
      if (items === null) {
        return void 0;
      }
      return async2.mapAsync(items, asCallHierarchyOutgoingCall, token);
    }
    async function asSemanticTokens(value, _token) {
      if (value === void 0 || value === null) {
        return void 0;
      }
      return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    function asSemanticTokensEdit(value) {
      return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
    }
    async function asSemanticTokensEdits(value, _token) {
      if (value === void 0 || value === null) {
        return void 0;
      }
      return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    function asSemanticTokensLegend(value) {
      return value;
    }
    async function asLinkedEditingRanges(value, token) {
      if (value === null || value === void 0) {
        return void 0;
      }
      return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
    }
    function asRegularExpression(value) {
      if (value === null || value === void 0) {
        return void 0;
      }
      return new RegExp(value);
    }
    function asTypeHierarchyItem(item) {
      if (item === null) {
        return void 0;
      }
      let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
      if (item.tags !== void 0) {
        result.tags = asSymbolTags(item.tags);
      }
      return result;
    }
    async function asTypeHierarchyItems(items, token) {
      if (items === null) {
        return void 0;
      }
      return async2.map(items, asTypeHierarchyItem, token);
    }
    function asGlobPattern(pattern) {
      if (Is2.string(pattern)) {
        return pattern;
      }
      if (ls.RelativePattern.is(pattern)) {
        if (ls.URI.is(pattern.baseUri)) {
          return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
        } else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
          const workspaceFolder2 = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
          return workspaceFolder2 !== void 0 ? new code.RelativePattern(workspaceFolder2, pattern.pattern) : void 0;
        }
      }
      return void 0;
    }
    return {
      asUri,
      asDocumentSelector,
      asDiagnostics,
      asDiagnostic,
      asRange,
      asRanges,
      asPosition,
      asDiagnosticSeverity,
      asDiagnosticTag,
      asHover,
      asCompletionResult,
      asCompletionItem,
      asTextEdit,
      asTextEdits,
      asSignatureHelp,
      asSignatureInformations,
      asSignatureInformation,
      asParameterInformations,
      asParameterInformation,
      asDeclarationResult,
      asDefinitionResult,
      asLocation,
      asReferences,
      asDocumentHighlights,
      asDocumentHighlight,
      asDocumentHighlightKind,
      asSymbolKind,
      asSymbolTag,
      asSymbolTags,
      asSymbolInformations,
      asSymbolInformation,
      asDocumentSymbols,
      asDocumentSymbol,
      asCommand,
      asCommands,
      asCodeAction,
      asCodeActionKind,
      asCodeActionKinds,
      asCodeActionResult,
      asCodeLens,
      asCodeLenses,
      asWorkspaceEdit,
      asDocumentLink,
      asDocumentLinks,
      asFoldingRangeKind,
      asFoldingRange,
      asFoldingRanges,
      asColor,
      asColorInformation,
      asColorInformations,
      asColorPresentation,
      asColorPresentations,
      asSelectionRange,
      asSelectionRanges,
      asInlineValue,
      asInlineValues,
      asInlayHint,
      asInlayHints,
      asSemanticTokensLegend,
      asSemanticTokens,
      asSemanticTokensEdit,
      asSemanticTokensEdits,
      asCallHierarchyItem,
      asCallHierarchyItems,
      asCallHierarchyIncomingCall,
      asCallHierarchyIncomingCalls,
      asCallHierarchyOutgoingCall,
      asCallHierarchyOutgoingCalls,
      asLinkedEditingRanges,
      asTypeHierarchyItem,
      asTypeHierarchyItems,
      asGlobPattern
    };
  }
  protocolConverter.createConverter = createConverter;
  return protocolConverter;
}
var uuid = {};
var hasRequiredUuid;
function requireUuid() {
  if (hasRequiredUuid)
    return uuid;
  hasRequiredUuid = 1;
  Object.defineProperty(uuid, "__esModule", { value: true });
  uuid.generateUuid = uuid.parse = uuid.isUUID = uuid.v4 = uuid.empty = void 0;
  class ValueUUID {
    constructor(_value) {
      this._value = _value;
    }
    asHex() {
      return this._value;
    }
    equals(other) {
      return this.asHex() === other.asHex();
    }
  }
  class V4UUID extends ValueUUID {
    constructor() {
      super([
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        "4",
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        V4UUID._oneOf(V4UUID._timeHighBits),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex()
      ].join(""));
    }
    static _oneOf(array2) {
      return array2[Math.floor(array2.length * Math.random())];
    }
    static _randomHex() {
      return V4UUID._oneOf(V4UUID._chars);
    }
  }
  V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
  V4UUID._timeHighBits = ["8", "9", "a", "b"];
  uuid.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
  function v4() {
    return new V4UUID();
  }
  uuid.v4 = v4;
  const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  function isUUID(value) {
    return _UUIDPattern.test(value);
  }
  uuid.isUUID = isUUID;
  function parse2(value) {
    if (!isUUID(value)) {
      throw new Error("invalid uuid");
    }
    return new ValueUUID(value);
  }
  uuid.parse = parse2;
  function generateUuid2() {
    return v4().asHex();
  }
  uuid.generateUuid = generateUuid2;
  return uuid;
}
var progressPart = {};
var hasRequiredProgressPart;
function requireProgressPart() {
  if (hasRequiredProgressPart)
    return progressPart;
  hasRequiredProgressPart = 1;
  Object.defineProperty(progressPart, "__esModule", { value: true });
  progressPart.ProgressPart = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const Is2 = requireIs();
  class ProgressPart {
    constructor(_client, _token, done) {
      this._client = _client;
      this._token = _token;
      this._reported = 0;
      this._infinite = false;
      this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
        switch (value.kind) {
          case "begin":
            this.begin(value);
            break;
          case "report":
            this.report(value);
            break;
          case "end":
            this.done();
            done && done(this);
            break;
        }
      });
    }
    begin(params) {
      this._infinite = params.percentage === void 0;
      if (this._lspProgressDisposable === void 0) {
        return;
      }
      void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress2, cancellationToken) => {
        if (this._lspProgressDisposable === void 0) {
          return;
        }
        this._progress = progress2;
        this._cancellationToken = cancellationToken;
        this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
          this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
        });
        this.report(params);
        return new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      });
    }
    report(params) {
      if (this._infinite && Is2.string(params.message)) {
        this._progress !== void 0 && this._progress.report({ message: params.message });
      } else if (Is2.number(params.percentage)) {
        const percentage = Math.max(0, Math.min(params.percentage, 100));
        const delta2 = Math.max(0, percentage - this._reported);
        this._reported += delta2;
        this._progress !== void 0 && this._progress.report({ message: params.message, increment: delta2 });
      }
    }
    cancel() {
      this.cleanup();
      if (this._reject !== void 0) {
        this._reject();
        this._resolve = void 0;
        this._reject = void 0;
      }
    }
    done() {
      this.cleanup();
      if (this._resolve !== void 0) {
        this._resolve();
        this._resolve = void 0;
        this._reject = void 0;
      }
    }
    cleanup() {
      if (this._lspProgressDisposable !== void 0) {
        this._lspProgressDisposable.dispose();
        this._lspProgressDisposable = void 0;
      }
      if (this._tokenDisposable !== void 0) {
        this._tokenDisposable.dispose();
        this._tokenDisposable = void 0;
      }
      this._progress = void 0;
      this._cancellationToken = void 0;
    }
  }
  progressPart.ProgressPart = ProgressPart;
  return progressPart;
}
var features = {};
var hasRequiredFeatures;
function requireFeatures() {
  if (hasRequiredFeatures)
    return features;
  hasRequiredFeatures = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceFeature = exports.TextDocumentLanguageFeature = exports.TextDocumentEventFeature = exports.DynamicDocumentFeature = exports.DynamicFeature = exports.StaticFeature = exports.ensure = exports.LSPCancellationError = void 0;
    const vscode_1 = require$$0;
    const vscode_languageserver_protocol_1 = requireMain();
    const Is2 = requireIs();
    const UUID = requireUuid();
    class LSPCancellationError extends vscode_1.CancellationError {
      constructor(data) {
        super();
        this.data = data;
      }
    }
    exports.LSPCancellationError = LSPCancellationError;
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    exports.ensure = ensure;
    (function(StaticFeature) {
      function is2(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Is2.func(candidate.fillClientCapabilities) && Is2.func(candidate.initialize) && Is2.func(candidate.getState) && Is2.func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || Is2.func(candidate.fillInitializeParams));
      }
      StaticFeature.is = is2;
    })(exports.StaticFeature || (exports.StaticFeature = {}));
    (function(DynamicFeature) {
      function is2(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Is2.func(candidate.fillClientCapabilities) && Is2.func(candidate.initialize) && Is2.func(candidate.getState) && Is2.func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || Is2.func(candidate.fillInitializeParams)) && Is2.func(candidate.register) && Is2.func(candidate.unregister) && candidate.registrationType !== void 0;
      }
      DynamicFeature.is = is2;
    })(exports.DynamicFeature || (exports.DynamicFeature = {}));
    class DynamicDocumentFeature {
      constructor(client2) {
        this._client = client2;
      }
      /**
       * Returns the state the feature is in.
       */
      getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
          count++;
          for (const document2 of vscode_1.workspace.textDocuments) {
            if (vscode_1.languages.match(selector, document2) > 0) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
        }
        const registrations = count > 0;
        return { kind: "document", id: this.registrationType.method, registrations, matches: false };
      }
    }
    exports.DynamicDocumentFeature = DynamicDocumentFeature;
    class TextDocumentEventFeature extends DynamicDocumentFeature {
      constructor(client2, event, type, middleware, createParams, textDocument, selectorFilter) {
        super(client2);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._textDocument = textDocument;
        this._selectorFilter = selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
      }
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (vscode_1.languages.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      getStateInfo() {
        return [this._selectors.values(), false];
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event((data2) => {
            this.callback(data2).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed.`, error);
            });
          });
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
      }
      async callback(data) {
        const doSend = async (data2) => {
          const params = this._createParams(data2);
          await this._client.sendNotification(this._type, params);
          this.notificationSent(this.getTextDocument(data2), this._type, params);
        };
        if (this.matches(data)) {
          const middleware = this._middleware();
          return middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data);
        }
      }
      matches(data) {
        if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
          return false;
        }
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(textDocument, type, params) {
        this._onNotificationSent.fire({ textDocument, type, params });
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const selector of this._selectors.values()) {
          if (vscode_1.languages.match(selector, document2) > 0) {
            return {
              send: (data) => {
                return this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    }
    exports.TextDocumentEventFeature = TextDocumentEventFeature;
    class TextDocumentLanguageFeature extends DynamicDocumentFeature {
      constructor(client2, registrationType) {
        super(client2);
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
          const selector = registration.data.registerOptions.documentSelector;
          if (selector === null) {
            continue;
          }
          yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
        }
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability) {
          return [void 0, void 0];
        } else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
          const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
          const selector = capability.documentSelector ?? documentSelector;
          if (selector) {
            return [id, Object.assign({}, capability, { documentSelector: selector })];
          }
        } else if (Is2.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
          if (!documentSelector) {
            return [void 0, void 0];
          }
          const options = Is2.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
          return [UUID.generateUuid(), options];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return Is2.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    }
    exports.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
    class WorkspaceFeature {
      constructor(client2, registrationType) {
        this._client = client2;
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      getState() {
        const registrations = this._registrations.size > 0;
        return { kind: "workspace", id: this._registrationType.method, registrations };
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((registration) => {
          registration.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    }
    exports.WorkspaceFeature = WorkspaceFeature;
  })(features);
  return features;
}
var diagnostic = {};
var path;
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath)
    return path;
  hasRequiredPath = 1;
  const isWindows2 = typeof process === "object" && process && process.platform === "win32";
  path = isWindows2 ? { sep: "\\" } : { sep: "/" };
  return path;
}
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch)
    return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion)
    return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m)
      return [str];
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    if (/\$$/.test(m.pre)) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n2;
      if (isSequence) {
        n2 = m.body.split(/\.\./);
      } else {
        n2 = parseCommaParts(m.body);
        if (n2.length === 1) {
          n2 = expand(n2[0], false).map(embrace);
          if (n2.length === 1) {
            return post.map(function(p) {
              return m.pre + n2[0] + p;
            });
          }
        }
      }
      var N;
      if (isSequence) {
        var x = numeric(n2[0]);
        var y = numeric(n2[1]);
        var width = Math.max(n2[0].length, n2[1].length);
        var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n2.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0; j < n2.length; j++) {
          N.push.apply(N, expand(n2[j], false));
        }
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch)
    return minimatch_1;
  hasRequiredMinimatch = 1;
  const minimatch = minimatch_1 = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  minimatch_1 = minimatch;
  const path2 = requirePath();
  minimatch.sep = path2.sep;
  const GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  const expand = requireBraceExpansion();
  const plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  const qmark = "[^/]";
  const star = qmark + "*?";
  const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  const charSet = (s) => s.split("").reduce((set, c) => {
    set[c] = true;
    return set;
  }, {});
  const reSpecials = charSet("().*{}+?[]^$\\!");
  const addPatternStartSet = charSet("[.(");
  const slashSplit = /\/+/;
  minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
  const ext = (a, b = {}) => {
    const t = {};
    Object.keys(a).forEach((k) => t[k] = a[k]);
    Object.keys(b).forEach((k) => t[k] = b[k]);
    return t;
  };
  minimatch.defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
    m.Minimatch = class Minimatch extends orig.Minimatch {
      constructor(pattern, options) {
        super(pattern, ext(def, options));
      }
    };
    m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
    m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
    m.defaults = (options) => orig.defaults(ext(def, options));
    m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
    m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
    m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
    return m;
  };
  minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
  const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  };
  const MAX_PATTERN_LENGTH = 1024 * 64;
  const assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  const SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
  minimatch.match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  const globUnescape = (s) => s.replace(/\\(.)/g, "$1");
  const charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
  const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  const braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
  class Minimatch {
    constructor(pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    debug() {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      let set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, set);
      set = this.globParts = set.map((s) => s.split(slashSplit));
      this.debug(this.pattern, set);
      set = set.map((s, si, set2) => s.map(this.parse, this));
      this.debug(this.pattern, set);
      set = set.filter((s) => s.indexOf(false) === -1);
      this.debug(this.pattern, set);
      this.set = set;
    }
    parseNegate() {
      if (this.options.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      let re = "";
      let hasMagic = false;
      let escaping = false;
      const patternListStack = [];
      const negativeLists = [];
      let stateChar;
      let inClass = false;
      let reClassStart = -1;
      let classStart = -1;
      let cs;
      let pl;
      let sp;
      let dotTravAllowed = pattern.charAt(0) === ".";
      let dotFileAllowed = options.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      };
      for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping) {
          if (c === "/") {
            return false;
          }
          if (reSpecials[c]) {
            re += "\\";
          }
          re += c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c;
              continue;
            }
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "	", plEntry);
            patternListStack.push(plEntry);
            re += plEntry.open;
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            patternListStack.pop();
            clearStateChar();
            hasMagic = true;
            pl = plEntry;
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            }
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            clearStateChar();
            re += "|";
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            continue;
          }
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
              re += c;
            } catch (er) {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic = true;
            inClass = false;
            continue;
          default:
            clearStateChar();
            if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
            break;
        }
      }
      if (inClass) {
        cs = pattern.slice(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substring(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      const addPatternStart = addPatternStartSet[re.charAt(0)];
      for (let n2 = negativeLists.length - 1; n2 > -1; n2--) {
        const nl = negativeLists[n2];
        const nlBefore = re.slice(0, nl.reStart);
        const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        let nlAfter = re.slice(nl.reEnd);
        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
        const closeParensBefore = nlBefore.split(")").length;
        const openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart() + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (options.nocase && !hasMagic) {
        hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      const flags = options.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch (er) {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      const flags = options.nocase ? "i" : "";
      let re = set.map((pattern) => {
        pattern = pattern.map(
          (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
        ).reduce((set2, p) => {
          if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
            set2.push(p);
          }
          return set2;
        }, []);
        pattern.forEach((p, i) => {
          if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
            return;
          }
          if (i === 0) {
            if (pattern.length > 1) {
              pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
            } else {
              pattern[i] = twoStar;
            }
          } else if (i === pattern.length - 1) {
            pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
          } else {
            pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
            pattern[i + 1] = GLOBSTAR;
          }
        });
        return pattern.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      const options = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename;
      for (let i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (let i = 0; i < set.length; i++) {
        const pattern = set[i];
        let file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  }
  minimatch.Minimatch = Minimatch;
  return minimatch_1;
}
var hasRequiredDiagnostic;
function requireDiagnostic() {
  if (hasRequiredDiagnostic)
    return diagnostic;
  hasRequiredDiagnostic = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;
    const minimatch = requireMinimatch();
    const vscode_1 = require$$0;
    const vscode_languageserver_protocol_1 = requireMain();
    const uuid_1 = requireUuid();
    const features_1 = requireFeatures();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var vsdiag;
    (function(vsdiag2) {
      (function(DocumentDiagnosticReportKind) {
        DocumentDiagnosticReportKind["full"] = "full";
        DocumentDiagnosticReportKind["unChanged"] = "unChanged";
      })(vsdiag2.DocumentDiagnosticReportKind || (vsdiag2.DocumentDiagnosticReportKind = {}));
    })(vsdiag = exports.vsdiag || (exports.vsdiag = {}));
    var DiagnosticPullMode;
    (function(DiagnosticPullMode2) {
      DiagnosticPullMode2["onType"] = "onType";
      DiagnosticPullMode2["onSave"] = "onSave";
    })(DiagnosticPullMode = exports.DiagnosticPullMode || (exports.DiagnosticPullMode = {}));
    var RequestStateKind;
    (function(RequestStateKind2) {
      RequestStateKind2["active"] = "open";
      RequestStateKind2["reschedule"] = "reschedule";
      RequestStateKind2["outDated"] = "drop";
    })(RequestStateKind || (RequestStateKind = {}));
    class Tabs {
      constructor() {
        this.open = /* @__PURE__ */ new Set();
        this._onOpen = new vscode_1.EventEmitter();
        this._onClose = new vscode_1.EventEmitter();
        Tabs.fillTabResources(this.open);
        const openTabsHandler = (event) => {
          if (event.closed.length === 0 && event.opened.length === 0) {
            return;
          }
          const oldTabs = this.open;
          const currentTabs = /* @__PURE__ */ new Set();
          Tabs.fillTabResources(currentTabs);
          const closed = /* @__PURE__ */ new Set();
          const opened = new Set(currentTabs);
          for (const tab of oldTabs.values()) {
            if (currentTabs.has(tab)) {
              opened.delete(tab);
            } else {
              closed.add(tab);
            }
          }
          this.open = currentTabs;
          if (closed.size > 0) {
            const toFire = /* @__PURE__ */ new Set();
            for (const item of closed) {
              toFire.add(vscode_1.Uri.parse(item));
            }
            this._onClose.fire(toFire);
          }
          if (opened.size > 0) {
            const toFire = /* @__PURE__ */ new Set();
            for (const item of opened) {
              toFire.add(vscode_1.Uri.parse(item));
            }
            this._onOpen.fire(toFire);
          }
        };
        if (vscode_1.window.tabGroups.onDidChangeTabs !== void 0) {
          this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);
        } else {
          this.disposable = { dispose: () => {
          } };
        }
      }
      get onClose() {
        return this._onClose.event;
      }
      get onOpen() {
        return this._onOpen.event;
      }
      dispose() {
        this.disposable.dispose();
      }
      isActive(document2) {
        var _a3, _b3;
        return document2 instanceof vscode_1.Uri ? ((_a3 = vscode_1.window.activeTextEditor) == null ? void 0 : _a3.document.uri) === document2 : ((_b3 = vscode_1.window.activeTextEditor) == null ? void 0 : _b3.document) === document2;
      }
      isVisible(document2) {
        const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
        return this.open.has(uri.toString());
      }
      getTabResources() {
        const result = /* @__PURE__ */ new Set();
        Tabs.fillTabResources(/* @__PURE__ */ new Set(), result);
        return result;
      }
      static fillTabResources(strings, uris) {
        const seen = strings ?? /* @__PURE__ */ new Set();
        for (const group of vscode_1.window.tabGroups.all) {
          for (const tab of group.tabs) {
            const input = tab.input;
            let uri;
            if (input instanceof vscode_1.TabInputText) {
              uri = input.uri;
            } else if (input instanceof vscode_1.TabInputTextDiff) {
              uri = input.modified;
            }
            if (uri !== void 0 && !seen.has(uri.toString())) {
              seen.add(uri.toString());
              uris !== void 0 && uris.add(uri);
            }
          }
        }
      }
    }
    var PullState;
    (function(PullState2) {
      PullState2[PullState2["document"] = 1] = "document";
      PullState2[PullState2["workspace"] = 2] = "workspace";
    })(PullState || (PullState = {}));
    var DocumentOrUri;
    (function(DocumentOrUri2) {
      function asKey(document2) {
        return document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
      }
      DocumentOrUri2.asKey = asKey;
    })(DocumentOrUri || (DocumentOrUri = {}));
    class DocumentPullStateTracker {
      constructor() {
        this.documentPullStates = /* @__PURE__ */ new Map();
        this.workspacePullStates = /* @__PURE__ */ new Map();
      }
      track(kind, document2, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = document2 instanceof vscode_1.Uri ? [document2.toString(), document2, arg1] : [document2.uri.toString(), document2.uri, document2.version];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId: void 0 };
          states.set(key, state);
        }
        return state;
      }
      update(kind, document2, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = document2 instanceof vscode_1.Uri ? [document2.toString(), document2, arg1, arg2] : [document2.uri.toString(), document2.uri, document2.version, arg1];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId };
          states.set(key, state);
        } else {
          state.pulledVersion = version;
          state.resultId = resultId;
        }
      }
      unTrack(kind, document2) {
        const key = DocumentOrUri.asKey(document2);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
      }
      tracks(kind, document2) {
        const key = DocumentOrUri.asKey(document2);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
      }
      getResultId(kind, document2) {
        var _a3;
        const key = DocumentOrUri.asKey(document2);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return (_a3 = states.get(key)) == null ? void 0 : _a3.resultId;
      }
      getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
          if (this.documentPullStates.has(uri)) {
            value = this.documentPullStates.get(uri);
          }
          if (value.resultId !== void 0) {
            result.push({ uri, value: value.resultId });
          }
        }
        return result;
      }
    }
    class DiagnosticRequestor {
      constructor(client2, tabs, options) {
        this.client = client2;
        this.tabs = tabs;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = /* @__PURE__ */ new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
      }
      knows(kind, document2) {
        const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
        return this.documentStates.tracks(kind, document2) || this.openRequests.has(uri.toString());
      }
      forget(kind, document2) {
        this.documentStates.unTrack(kind, document2);
      }
      pull(document2, cb) {
        if (this.isDisposed) {
          return;
        }
        const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
        this.pullAsync(document2).then(() => {
          if (cb) {
            cb();
          }
        }, (error) => {
          this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
        });
      }
      async pullAsync(document2, version) {
        if (this.isDisposed) {
          return;
        }
        const isUri = document2 instanceof vscode_1.Uri;
        const uri = isUri ? document2 : document2.uri;
        const key = uri.toString();
        version = isUri ? version : document2.version;
        const currentRequestState = this.openRequests.get(key);
        const documentState = isUri ? this.documentStates.track(PullState.document, document2, version) : this.documentStates.track(PullState.document, document2);
        if (currentRequestState === void 0) {
          const tokenSource = new vscode_1.CancellationTokenSource();
          this.openRequests.set(key, { state: RequestStateKind.active, document: document2, version, tokenSource });
          let report;
          let afterState;
          try {
            report = await this.provider.provideDiagnostics(document2, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
          } catch (error) {
            if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
              afterState = { state: RequestStateKind.outDated, document: document2 };
            }
            if (afterState === void 0 && error instanceof vscode_1.CancellationError) {
              afterState = { state: RequestStateKind.reschedule, document: document2 };
            } else {
              throw error;
            }
          }
          afterState = afterState ?? this.openRequests.get(key);
          if (afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
            this.diagnostics.delete(uri);
            return;
          }
          this.openRequests.delete(key);
          if (!this.tabs.isVisible(document2)) {
            this.documentStates.unTrack(PullState.document, document2);
            return;
          }
          if (afterState.state === RequestStateKind.outDated) {
            return;
          }
          if (report !== void 0) {
            if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              this.diagnostics.set(uri, report.items);
            }
            documentState.pulledVersion = version;
            documentState.resultId = report.resultId;
          }
          if (afterState.state === RequestStateKind.reschedule) {
            this.pull(document2);
          }
        } else {
          if (currentRequestState.state === RequestStateKind.active) {
            currentRequestState.tokenSource.cancel();
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
          } else if (currentRequestState.state === RequestStateKind.outDated) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
          }
        }
      }
      forgetDocument(document2) {
        const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
        const key = uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics) {
          if (request !== void 0) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document: document2 });
          } else {
            this.pull(document2, () => {
              this.forget(PullState.document, document2);
            });
          }
        } else {
          if (request !== void 0) {
            if (request.state === RequestStateKind.active) {
              request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document: document2 });
          }
          this.diagnostics.delete(uri);
          this.forget(PullState.document, document2);
        }
      }
      pullWorkspace() {
        if (this.isDisposed) {
          return;
        }
        this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, 2e3);
        }, (error) => {
          if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
            this.client.error(`Workspace diagnostic pull failed.`, error, false);
            this.workspaceErrorCounter++;
          }
          if (this.workspaceErrorCounter <= 5) {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, 2e3);
          }
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
          return;
        }
        if (this.workspaceCancellation !== void 0) {
          this.workspaceCancellation.cancel();
          this.workspaceCancellation = void 0;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
          return {
            uri: this.client.protocol2CodeConverter.asUri(item.uri),
            value: item.value
          };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
          if (!chunk || this.isDisposed) {
            return;
          }
          for (const item of chunk.items) {
            if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              if (!this.documentStates.tracks(PullState.document, item.uri)) {
                this.diagnostics.set(item.uri, item.items);
              }
            }
            this.documentStates.update(PullState.workspace, item.uri, item.version ?? void 0, item.resultId);
          }
        });
      }
      createProvider() {
        const result = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: (document2, previousResultId, token) => {
            const provideDiagnostics = (document3, previousResultId2, token2) => {
              const params = {
                identifier: this.options.identifier,
                textDocument: { uri: this.client.code2ProtocolConverter.asUri(document3 instanceof vscode_1.Uri ? document3 : document3.uri) },
                previousResultId: previousResultId2
              };
              if (this.isDisposed === true || !this.client.isRunning()) {
                return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
              }
              return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token2).then(async (result2) => {
                if (result2 === void 0 || result2 === null || this.isDisposed || token2.isCancellationRequested) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                }
                if (result2.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result2.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result2.items, token2) };
                } else {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result2.resultId };
                }
              }, (error) => {
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(document2, previousResultId, token, provideDiagnostics) : provideDiagnostics(document2, previousResultId, token);
          }
        };
        if (this.options.workspaceDiagnostics) {
          result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
            const convertReport = async (report) => {
              if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version,
                  items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                };
              } else {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version
                };
              }
            };
            const convertPreviousResultIds = (resultIds2) => {
              const converted = [];
              for (const item of resultIds2) {
                converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
              }
              return converted;
            };
            const provideDiagnostics = (resultIds2, token2) => {
              const partialResultToken = (0, uuid_1.generateUuid)();
              const disposable2 = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                if (partialResult === void 0 || partialResult === null) {
                  resultReporter(null);
                  return;
                }
                const converted = {
                  items: []
                };
                for (const item of partialResult.items) {
                  try {
                    converted.items.push(await convertReport(item));
                  } catch (error) {
                    this.client.error(`Converting workspace diagnostics failed.`, error);
                  }
                }
                resultReporter(converted);
              });
              const params = {
                identifier: this.options.identifier,
                previousResultIds: convertPreviousResultIds(resultIds2),
                partialResultToken
              };
              if (this.isDisposed === true || !this.client.isRunning()) {
                return { items: [] };
              }
              return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token2).then(async (result2) => {
                if (token2.isCancellationRequested) {
                  return { items: [] };
                }
                const converted = {
                  items: []
                };
                for (const item of result2.items) {
                  converted.items.push(await convertReport(item));
                }
                disposable2.dispose();
                resultReporter(converted);
                return { items: [] };
              }, (error) => {
                disposable2.dispose();
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { items: [] });
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token);
          };
        }
        return result;
      }
      dispose() {
        var _a3, _b3;
        this.isDisposed = true;
        (_a3 = this.workspaceCancellation) == null ? void 0 : _a3.cancel();
        (_b3 = this.workspaceTimeout) == null ? void 0 : _b3.dispose();
        for (const [key, request] of this.openRequests) {
          if (request.state === RequestStateKind.active) {
            request.tokenSource.cancel();
          }
          this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
        }
        this.diagnostics.dispose();
      }
    }
    class BackgroundScheduler {
      constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
        this.isDisposed = false;
      }
      add(document2) {
        if (this.isDisposed === true) {
          return;
        }
        const key = DocumentOrUri.asKey(document2);
        if (this.documents.has(key)) {
          return;
        }
        this.documents.set(key, document2, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
      }
      remove(document2) {
        const key = DocumentOrUri.asKey(document2);
        this.documents.delete(key);
        if (this.documents.size === 0) {
          this.stop();
        } else if (key === this.endDocumentKey()) {
          this.endDocument = this.documents.last;
        }
      }
      trigger() {
        if (this.isDisposed === true) {
          return;
        }
        if (this.intervalHandle !== void 0) {
          this.endDocument = this.documents.last;
          return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
          const document2 = this.documents.first;
          if (document2 !== void 0) {
            const key = DocumentOrUri.asKey(document2);
            this.diagnosticRequestor.pull(document2);
            this.documents.set(key, document2, vscode_languageserver_protocol_1.Touch.Last);
            if (key === this.endDocumentKey()) {
              this.stop();
            }
          }
        }, 200);
      }
      dispose() {
        this.isDisposed = true;
        this.stop();
        this.documents.clear();
      }
      stop() {
        var _a3;
        (_a3 = this.intervalHandle) == null ? void 0 : _a3.dispose();
        this.intervalHandle = void 0;
        this.endDocument = void 0;
      }
      endDocumentKey() {
        return this.endDocument !== void 0 ? DocumentOrUri.asKey(this.endDocument) : void 0;
      }
    }
    class DiagnosticFeatureProviderImpl {
      constructor(client2, tabs, options) {
        var _a3;
        const diagnosticPullOptions = client2.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
        const documentSelector = client2.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        const disposables = [];
        const matchResource = (resource) => {
          const selector = options.documentSelector;
          if (diagnosticPullOptions.match !== void 0) {
            return diagnosticPullOptions.match(selector, resource);
          }
          for (const filter of selector) {
            if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
              continue;
            }
            if (typeof filter === "string") {
              return false;
            }
            if (filter.language !== void 0 && filter.language !== "*") {
              return false;
            }
            if (filter.scheme !== void 0 && filter.scheme !== "*" && filter.scheme !== resource.scheme) {
              return false;
            }
            if (filter.pattern !== void 0) {
              const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
              if (!matcher.makeRe()) {
                return false;
              }
              if (!matcher.match(resource.fsPath)) {
                return false;
              }
            }
          }
          return true;
        };
        const matches = (document2) => {
          return document2 instanceof vscode_1.Uri ? matchResource(document2) : vscode_1.languages.match(documentSelector, document2) > 0 && tabs.isVisible(document2);
        };
        const isActiveDocument = (document2) => {
          var _a4;
          return document2 instanceof vscode_1.Uri ? ((_a4 = this.activeTextDocument) == null ? void 0 : _a4.uri.toString()) === document2.toString() : this.activeTextDocument === document2;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client2, tabs, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document2) => {
          if (!matches(document2) || !options.interFileDependencies || isActiveDocument(document2)) {
            return;
          }
          this.backgroundScheduler.add(document2);
        };
        this.activeTextDocument = (_a3 = vscode_1.window.activeTextEditor) == null ? void 0 : _a3.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor2) => {
          const oldActive = this.activeTextDocument;
          this.activeTextDocument = editor2 == null ? void 0 : editor2.document;
          if (oldActive !== void 0) {
            addToBackgroundIfNeeded(oldActive);
          }
          if (this.activeTextDocument !== void 0) {
            this.backgroundScheduler.remove(this.activeTextDocument);
          }
        });
        const openFeature = client2.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
          const textDocument = event.textDocument;
          if (this.diagnosticRequestor.knows(PullState.document, textDocument)) {
            return;
          }
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        tabs.onOpen((opened) => {
          for (const resource of opened) {
            if (this.diagnosticRequestor.knows(PullState.document, resource)) {
              continue;
            }
            const uriStr = resource.toString();
            let textDocument;
            for (const item of vscode_1.workspace.textDocuments) {
              if (uriStr === item.uri.toString()) {
                textDocument = item;
                break;
              }
            }
            if (textDocument !== void 0 && matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            } else if (matches(resource)) {
              this.diagnosticRequestor.pull(resource, () => {
                addToBackgroundIfNeeded(resource);
              });
            }
          }
        });
        const pulledTextDocuments = /* @__PURE__ */ new Set();
        for (const textDocument of vscode_1.workspace.textDocuments) {
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
            pulledTextDocuments.add(textDocument.uri.toString());
          }
        }
        if (diagnosticPullOptions.onTabs === true) {
          for (const resource of tabs.getTabResources()) {
            if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {
              this.diagnosticRequestor.pull(resource, () => {
                addToBackgroundIfNeeded(resource);
              });
            }
          }
        }
        if (diagnosticPullOptions.onChange === true) {
          const changeFeature = client2.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async (event) => {
            const textDocument = event.textDocument;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        if (diagnosticPullOptions.onSave === true) {
          const saveFeature = client2.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent((event) => {
            const textDocument = event.textDocument;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
              this.diagnosticRequestor.pull(event.textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        const closeFeature = client2.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
          this.cleanUpDocument(event.textDocument);
        }));
        tabs.onClose((closed) => {
          for (const document2 of closed) {
            this.cleanUpDocument(document2);
          }
        });
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        });
        if (options.workspaceDiagnostics === true && options.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
          this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
      cleanUpDocument(document2) {
        if (this.diagnosticRequestor.knows(PullState.document, document2)) {
          this.diagnosticRequestor.forgetDocument(document2);
          this.backgroundScheduler.remove(document2);
        }
      }
    }
    class DiagnosticFeature extends features_1.TextDocumentLanguageFeature {
      constructor(client2) {
        super(client2, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = false;
        ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client2 = this._client;
        client2.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeDiagnosticsEmitter.fire();
          }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      dispose() {
        if (this.tabs !== void 0) {
          this.tabs.dispose();
          this.tabs = void 0;
        }
        super.dispose();
      }
      registerLanguageProvider(options) {
        if (this.tabs === void 0) {
          this.tabs = new Tabs();
        }
        const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
        return [provider.disposable, provider];
      }
    }
    exports.DiagnosticFeature = DiagnosticFeature;
  })(diagnostic);
  return diagnostic;
}
var notebook = {};
var hasRequiredNotebook;
function requireNotebook() {
  if (hasRequiredNotebook)
    return notebook;
  hasRequiredNotebook = 1;
  Object.defineProperty(notebook, "__esModule", { value: true });
  notebook.NotebookDocumentSyncFeature = void 0;
  const vscode = require$$0;
  const minimatch = requireMinimatch();
  const proto = requireMain();
  const UUID = requireUuid();
  const Is2 = requireIs();
  function ensure(target, key) {
    if (target[key] === void 0) {
      target[key] = {};
    }
    return target[key];
  }
  var Converter;
  (function(Converter2) {
    (function(c2p) {
      function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
        return {
          version: notebookDocument.version,
          uri: base.asUri(notebookDocument.uri)
        };
      }
      c2p.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
      function asNotebookDocument(notebookDocument, cells, base) {
        const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
        if (Object.keys(notebookDocument.metadata).length > 0) {
          result.metadata = asMetadata(notebookDocument.metadata);
        }
        return result;
      }
      c2p.asNotebookDocument = asNotebookDocument;
      function asNotebookCells(cells, base) {
        return cells.map((cell) => asNotebookCell(cell, base));
      }
      c2p.asNotebookCells = asNotebookCells;
      function asMetadata(metadata) {
        const seen = /* @__PURE__ */ new Set();
        return deepCopy(seen, metadata);
      }
      c2p.asMetadata = asMetadata;
      function asNotebookCell(cell, base) {
        const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
        if (Object.keys(cell.metadata).length > 0) {
          result.metadata = asMetadata(cell.metadata);
        }
        if (cell.executionSummary !== void 0 && (Is2.number(cell.executionSummary.executionOrder) && Is2.boolean(cell.executionSummary.success))) {
          result.executionSummary = {
            executionOrder: cell.executionSummary.executionOrder,
            success: cell.executionSummary.success
          };
        }
        return result;
      }
      c2p.asNotebookCell = asNotebookCell;
      function asNotebookCellKind(kind) {
        switch (kind) {
          case vscode.NotebookCellKind.Markup:
            return proto.NotebookCellKind.Markup;
          case vscode.NotebookCellKind.Code:
            return proto.NotebookCellKind.Code;
        }
      }
      function deepCopy(seen, value) {
        if (seen.has(value)) {
          throw new Error(`Can't deep copy cyclic structures.`);
        }
        if (Array.isArray(value)) {
          const result = [];
          for (const elem of value) {
            if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
              result.push(deepCopy(seen, elem));
            } else {
              if (elem instanceof RegExp) {
                throw new Error(`Can't transfer regular expressions to the server`);
              }
              result.push(elem);
            }
          }
          return result;
        } else {
          const props = Object.keys(value);
          const result = /* @__PURE__ */ Object.create(null);
          for (const prop of props) {
            const elem = value[prop];
            if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
              result[prop] = deepCopy(seen, elem);
            } else {
              if (elem instanceof RegExp) {
                throw new Error(`Can't transfer regular expressions to the server`);
              }
              result[prop] = elem;
            }
          }
          return result;
        }
      }
      function asTextContentChange(event, base) {
        const params = base.asChangeTextDocumentParams(event, event.document.uri, event.document.version);
        return { document: params.textDocument, changes: params.contentChanges };
      }
      c2p.asTextContentChange = asTextContentChange;
      function asNotebookDocumentChangeEvent(event, base) {
        const result = /* @__PURE__ */ Object.create(null);
        if (event.metadata) {
          result.metadata = Converter2.c2p.asMetadata(event.metadata);
        }
        if (event.cells !== void 0) {
          const cells = /* @__PURE__ */ Object.create(null);
          const changedCells = event.cells;
          if (changedCells.structure) {
            cells.structure = {
              array: {
                start: changedCells.structure.array.start,
                deleteCount: changedCells.structure.array.deleteCount,
                cells: changedCells.structure.array.cells !== void 0 ? changedCells.structure.array.cells.map((cell) => Converter2.c2p.asNotebookCell(cell, base)) : void 0
              },
              didOpen: changedCells.structure.didOpen !== void 0 ? changedCells.structure.didOpen.map((cell) => base.asOpenTextDocumentParams(cell.document).textDocument) : void 0,
              didClose: changedCells.structure.didClose !== void 0 ? changedCells.structure.didClose.map((cell) => base.asCloseTextDocumentParams(cell.document).textDocument) : void 0
            };
          }
          if (changedCells.data !== void 0) {
            cells.data = changedCells.data.map((cell) => Converter2.c2p.asNotebookCell(cell, base));
          }
          if (changedCells.textContent !== void 0) {
            cells.textContent = changedCells.textContent.map((event2) => Converter2.c2p.asTextContentChange(event2, base));
          }
          if (Object.keys(cells).length > 0) {
            result.cells = cells;
          }
        }
        return result;
      }
      c2p.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
    })(Converter2.c2p || (Converter2.c2p = {}));
  })(Converter || (Converter = {}));
  var $NotebookCell;
  (function($NotebookCell2) {
    function computeDiff(originalCells, modifiedCells, compareMetadata) {
      const originalLength = originalCells.length;
      const modifiedLength = modifiedCells.length;
      let startIndex = 0;
      while (startIndex < modifiedLength && startIndex < originalLength && equals2(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
        startIndex++;
      }
      if (startIndex < modifiedLength && startIndex < originalLength) {
        let originalEndIndex = originalLength - 1;
        let modifiedEndIndex = modifiedLength - 1;
        while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals2(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
          originalEndIndex--;
          modifiedEndIndex--;
        }
        const deleteCount = originalEndIndex + 1 - startIndex;
        const newCells = startIndex === modifiedEndIndex + 1 ? void 0 : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
        return newCells !== void 0 ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
      } else if (startIndex < modifiedLength) {
        return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
      } else if (startIndex < originalLength) {
        return { start: startIndex, deleteCount: originalLength - startIndex };
      } else {
        return void 0;
      }
    }
    $NotebookCell2.computeDiff = computeDiff;
    function equals2(one, other, compareMetaData = true) {
      if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId || !equalsExecution(one.executionSummary, other.executionSummary)) {
        return false;
      }
      return !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);
    }
    function equalsExecution(one, other) {
      if (one === other) {
        return true;
      }
      if (one === void 0 || other === void 0) {
        return false;
      }
      return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
    }
    function equalsTiming(one, other) {
      if (one === other) {
        return true;
      }
      if (one === void 0 || other === void 0) {
        return false;
      }
      return one.startTime === other.startTime && one.endTime === other.endTime;
    }
    function equalsMetadata(one, other) {
      if (one === other) {
        return true;
      }
      if (one === null || one === void 0 || other === null || other === void 0) {
        return false;
      }
      if (typeof one !== typeof other) {
        return false;
      }
      if (typeof one !== "object") {
        return false;
      }
      const oneArray = Array.isArray(one);
      const otherArray = Array.isArray(other);
      if (oneArray !== otherArray) {
        return false;
      }
      if (oneArray && otherArray) {
        if (one.length !== other.length) {
          return false;
        }
        for (let i = 0; i < one.length; i++) {
          if (!equalsMetadata(one[i], other[i])) {
            return false;
          }
        }
      }
      if (isObjectLiteral(one) && isObjectLiteral(other)) {
        const oneKeys = Object.keys(one);
        const otherKeys = Object.keys(other);
        if (oneKeys.length !== otherKeys.length) {
          return false;
        }
        oneKeys.sort();
        otherKeys.sort();
        if (!equalsMetadata(oneKeys, otherKeys)) {
          return false;
        }
        for (let i = 0; i < oneKeys.length; i++) {
          const prop = oneKeys[i];
          if (!equalsMetadata(one[prop], other[prop])) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    function isObjectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    $NotebookCell2.isObjectLiteral = isObjectLiteral;
  })($NotebookCell || ($NotebookCell = {}));
  var $NotebookDocumentFilter;
  (function($NotebookDocumentFilter2) {
    function matchNotebook(filter, notebookDocument) {
      if (typeof filter === "string") {
        return filter === "*" || notebookDocument.notebookType === filter;
      }
      if (filter.notebookType !== void 0 && filter.notebookType !== "*" && notebookDocument.notebookType !== filter.notebookType) {
        return false;
      }
      const uri = notebookDocument.uri;
      if (filter.scheme !== void 0 && filter.scheme !== "*" && uri.scheme !== filter.scheme) {
        return false;
      }
      if (filter.pattern !== void 0) {
        const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
        if (!matcher.makeRe()) {
          return false;
        }
        if (!matcher.match(uri.fsPath)) {
          return false;
        }
      }
      return true;
    }
    $NotebookDocumentFilter2.matchNotebook = matchNotebook;
  })($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
  var $NotebookDocumentSyncOptions;
  (function($NotebookDocumentSyncOptions2) {
    function asDocumentSelector(options) {
      var _a3, _b3, _c3;
      const selector = options.notebookSelector;
      const result = [];
      for (const element of selector) {
        const notebookType = (typeof element.notebook === "string" ? element.notebook : (_a3 = element.notebook) == null ? void 0 : _a3.notebookType) ?? "*";
        const scheme = typeof element.notebook === "string" ? void 0 : (_b3 = element.notebook) == null ? void 0 : _b3.scheme;
        const pattern = typeof element.notebook === "string" ? void 0 : (_c3 = element.notebook) == null ? void 0 : _c3.pattern;
        if (element.cells !== void 0) {
          for (const cell of element.cells) {
            result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
          }
        } else {
          result.push(asDocumentFilter(notebookType, scheme, pattern, void 0));
        }
      }
      return result;
    }
    $NotebookDocumentSyncOptions2.asDocumentSelector = asDocumentSelector;
    function asDocumentFilter(notebookType, scheme, pattern, language2) {
      return scheme === void 0 && pattern === void 0 ? { notebook: notebookType, language: language2 } : { notebook: { notebookType, scheme, pattern }, language: language2 };
    }
  })($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
  var SyncInfo;
  (function(SyncInfo2) {
    function create(cells) {
      return {
        cells,
        uris: new Set(cells.map((cell) => cell.document.uri.toString()))
      };
    }
    SyncInfo2.create = create;
  })(SyncInfo || (SyncInfo = {}));
  class NotebookDocumentSyncFeatureProvider {
    constructor(client2, options) {
      this.client = client2;
      this.options = options;
      this.notebookSyncInfo = /* @__PURE__ */ new Map();
      this.notebookDidOpen = /* @__PURE__ */ new Set();
      this.disposables = [];
      this.selector = client2.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
      vscode.workspace.onDidOpenNotebookDocument((notebookDocument) => {
        this.notebookDidOpen.add(notebookDocument.uri.toString());
        this.didOpen(notebookDocument);
      }, void 0, this.disposables);
      for (const notebookDocument of vscode.workspace.notebookDocuments) {
        this.notebookDidOpen.add(notebookDocument.uri.toString());
        this.didOpen(notebookDocument);
      }
      vscode.workspace.onDidChangeNotebookDocument((event) => this.didChangeNotebookDocument(event), void 0, this.disposables);
      if (this.options.save === true) {
        vscode.workspace.onDidSaveNotebookDocument((notebookDocument) => this.didSave(notebookDocument), void 0, this.disposables);
      }
      vscode.workspace.onDidCloseNotebookDocument((notebookDocument) => {
        this.didClose(notebookDocument);
        this.notebookDidOpen.delete(notebookDocument.uri.toString());
      }, void 0, this.disposables);
    }
    getState() {
      for (const notebook2 of vscode.workspace.notebookDocuments) {
        const matchingCells = this.getMatchingCells(notebook2);
        if (matchingCells !== void 0) {
          return { kind: "document", id: "$internal", registrations: true, matches: true };
        }
      }
      return { kind: "document", id: "$internal", registrations: true, matches: false };
    }
    get mode() {
      return "notebook";
    }
    handles(textDocument) {
      return vscode.languages.match(this.selector, textDocument) > 0;
    }
    didOpenNotebookCellTextDocument(notebookDocument, cell) {
      if (vscode.languages.match(this.selector, cell.document) === 0) {
        return;
      }
      if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
        return;
      }
      const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
      const cellMatches = this.cellMatches(notebookDocument, cell);
      if (syncInfo !== void 0) {
        const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
        if (cellMatches && cellIsSynced || !cellMatches && !cellIsSynced) {
          return;
        }
        if (cellMatches) {
          const matchingCells = this.getMatchingCells(notebookDocument);
          if (matchingCells !== void 0) {
            const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
            if (event !== void 0) {
              this.doSendChange(event, matchingCells).catch(() => {
              });
            }
          }
        }
      } else {
        if (cellMatches) {
          this.doSendOpen(notebookDocument, [cell]).catch(() => {
          });
        }
      }
    }
    didChangeNotebookCellTextDocument(notebookDocument, event) {
      if (vscode.languages.match(this.selector, event.document) === 0) {
        return;
      }
      this.doSendChange({
        notebook: notebookDocument,
        cells: { textContent: [event] }
      }, void 0).catch(() => {
      });
    }
    didCloseNotebookCellTextDocument(notebookDocument, cell) {
      const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
      if (syncInfo === void 0) {
        return;
      }
      const cellUri = cell.document.uri;
      const index2 = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
      if (index2 === -1) {
        return;
      }
      if (index2 === 0 && syncInfo.cells.length === 1) {
        this.doSendClose(notebookDocument, syncInfo.cells).catch(() => {
        });
      } else {
        const newCells = syncInfo.cells.slice();
        const deleted = newCells.splice(index2, 1);
        this.doSendChange({
          notebook: notebookDocument,
          cells: {
            structure: {
              array: { start: index2, deleteCount: 1 },
              didClose: deleted
            }
          }
        }, newCells).catch(() => {
        });
      }
    }
    dispose() {
      for (const disposable2 of this.disposables) {
        disposable2.dispose();
      }
    }
    didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
      if (syncInfo !== void 0) {
        if (matchingCells !== void 0) {
          const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
          if (event !== void 0) {
            this.doSendChange(event, matchingCells).catch(() => {
            });
          }
        } else {
          this.doSendClose(notebookDocument, []).catch(() => {
          });
        }
      } else {
        if (matchingCells === void 0) {
          return;
        }
        this.doSendOpen(notebookDocument, matchingCells).catch(() => {
        });
      }
    }
    didChangeNotebookDocument(event) {
      const notebookDocument = event.notebook;
      const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
      if (syncInfo === void 0) {
        if (event.contentChanges.length === 0) {
          return;
        }
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === void 0) {
          return;
        }
        this.didOpen(notebookDocument, cells, syncInfo);
      } else {
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === void 0) {
          this.didClose(notebookDocument, syncInfo);
          return;
        }
        const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
        if (newEvent !== void 0) {
          this.doSendChange(newEvent, cells).catch(() => {
          });
        }
      }
    }
    didSave(notebookDocument) {
      const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
      if (syncInfo === void 0) {
        return;
      }
      this.doSendSave(notebookDocument).catch(() => {
      });
    }
    didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
      if (syncInfo === void 0) {
        return;
      }
      const syncedCells = notebookDocument.getCells().filter((cell) => syncInfo.uris.has(cell.document.uri.toString()));
      this.doSendClose(notebookDocument, syncedCells).catch(() => {
      });
    }
    async sendDidOpenNotebookDocument(notebookDocument) {
      const cells = this.getMatchingCells(notebookDocument);
      if (cells === void 0) {
        return;
      }
      return this.doSendOpen(notebookDocument, cells);
    }
    async doSendOpen(notebookDocument, cells) {
      var _a3;
      const send = async (notebookDocument2, cells2) => {
        const nb = Converter.c2p.asNotebookDocument(notebookDocument2, cells2, this.client.code2ProtocolConverter);
        const cellDocuments = cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
        try {
          await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
            notebookDocument: nb,
            cellTextDocuments: cellDocuments
          });
        } catch (error) {
          this.client.error("Sending DidOpenNotebookDocumentNotification failed", error);
          throw error;
        }
      };
      const middleware = (_a3 = this.client.middleware) == null ? void 0 : _a3.notebooks;
      this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
      return (middleware == null ? void 0 : middleware.didOpen) !== void 0 ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    async sendDidChangeNotebookDocument(event) {
      return this.doSendChange(event, void 0);
    }
    async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
      var _a3, _b3;
      const send = async (event2) => {
        try {
          await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
            notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event2.notebook, this.client.code2ProtocolConverter),
            change: Converter.c2p.asNotebookDocumentChangeEvent(event2, this.client.code2ProtocolConverter)
          });
        } catch (error) {
          this.client.error("Sending DidChangeNotebookDocumentNotification failed", error);
          throw error;
        }
      };
      const middleware = (_a3 = this.client.middleware) == null ? void 0 : _a3.notebooks;
      if (((_b3 = event.cells) == null ? void 0 : _b3.structure) !== void 0) {
        this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
      }
      return (middleware == null ? void 0 : middleware.didChange) !== void 0 ? middleware == null ? void 0 : middleware.didChange(event, send) : send(event);
    }
    async sendDidSaveNotebookDocument(notebookDocument) {
      return this.doSendSave(notebookDocument);
    }
    async doSendSave(notebookDocument) {
      var _a3;
      const send = async (notebookDocument2) => {
        try {
          await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
            notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) }
          });
        } catch (error) {
          this.client.error("Sending DidSaveNotebookDocumentNotification failed", error);
          throw error;
        }
      };
      const middleware = (_a3 = this.client.middleware) == null ? void 0 : _a3.notebooks;
      return (middleware == null ? void 0 : middleware.didSave) !== void 0 ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
    }
    async sendDidCloseNotebookDocument(notebookDocument) {
      return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
    }
    async doSendClose(notebookDocument, cells) {
      var _a3;
      const send = async (notebookDocument2, cells2) => {
        try {
          await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
            notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) },
            cellTextDocuments: cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
          });
        } catch (error) {
          this.client.error("Sending DidCloseNotebookDocumentNotification failed", error);
          throw error;
        }
      };
      const middleware = (_a3 = this.client.middleware) == null ? void 0 : _a3.notebooks;
      this.notebookSyncInfo.delete(notebookDocument.uri.toString());
      return (middleware == null ? void 0 : middleware.didClose) !== void 0 ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    asNotebookDocumentChangeEvent(notebook2, event, syncInfo, matchingCells) {
      if (event !== void 0 && event.notebook !== notebook2) {
        throw new Error("Notebook must be identical");
      }
      const result = {
        notebook: notebook2
      };
      if ((event == null ? void 0 : event.metadata) !== void 0) {
        result.metadata = Converter.c2p.asMetadata(event.metadata);
      }
      let matchingCellsSet;
      if ((event == null ? void 0 : event.cellChanges) !== void 0 && event.cellChanges.length > 0) {
        const data = [];
        matchingCellsSet = new Set(matchingCells.map((cell) => cell.document.uri.toString()));
        for (const cellChange of event.cellChanges) {
          if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== void 0 || cellChange.metadata !== void 0)) {
            data.push(cellChange.cell);
          }
        }
        if (data.length > 0) {
          result.cells = result.cells ?? {};
          result.cells.data = data;
        }
      }
      if (((event == null ? void 0 : event.contentChanges) !== void 0 && event.contentChanges.length > 0 || event === void 0) && syncInfo !== void 0 && matchingCells !== void 0) {
        const oldCells = syncInfo.cells;
        const newCells = matchingCells;
        const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
        let addedCells;
        let removedCells;
        if (diff !== void 0) {
          addedCells = diff.cells === void 0 ? /* @__PURE__ */ new Map() : new Map(diff.cells.map((cell) => [cell.document.uri.toString(), cell]));
          removedCells = diff.deleteCount === 0 ? /* @__PURE__ */ new Map() : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map((cell) => [cell.document.uri.toString(), cell]));
          for (const key of Array.from(removedCells.keys())) {
            if (addedCells.has(key)) {
              removedCells.delete(key);
              addedCells.delete(key);
            }
          }
          result.cells = result.cells ?? {};
          const didOpen = [];
          const didClose = [];
          if (addedCells.size > 0 || removedCells.size > 0) {
            for (const cell of addedCells.values()) {
              didOpen.push(cell);
            }
            for (const cell of removedCells.values()) {
              didClose.push(cell);
            }
          }
          result.cells.structure = {
            array: diff,
            didOpen,
            didClose
          };
        }
      }
      return Object.keys(result).length > 1 ? result : void 0;
    }
    getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
      if (this.options.notebookSelector === void 0) {
        return void 0;
      }
      for (const item of this.options.notebookSelector) {
        if (item.notebook === void 0 || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
          const filtered = this.filterCells(notebookDocument, cells, item.cells);
          return filtered.length === 0 ? void 0 : filtered;
        }
      }
      return void 0;
    }
    cellMatches(notebookDocument, cell) {
      const cells = this.getMatchingCells(notebookDocument, [cell]);
      return cells !== void 0 && cells[0] === cell;
    }
    filterCells(notebookDocument, cells, cellSelector) {
      var _a3;
      const filtered = cellSelector !== void 0 ? cells.filter((cell) => {
        const cellLanguage = cell.document.languageId;
        return cellSelector.some((filter) => filter.language === "*" || cellLanguage === filter.language);
      }) : cells;
      return typeof ((_a3 = this.client.clientOptions.notebookDocumentOptions) == null ? void 0 : _a3.filterCells) === "function" ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered) : filtered;
    }
  }
  class NotebookDocumentSyncFeature {
    constructor(client2) {
      this.client = client2;
      this.registrations = /* @__PURE__ */ new Map();
      this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
      vscode.workspace.onDidOpenTextDocument((textDocument) => {
        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
          return;
        }
        const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
        if (notebookDocument === void 0 || notebookCell === void 0) {
          return;
        }
        for (const provider of this.registrations.values()) {
          if (provider instanceof NotebookDocumentSyncFeatureProvider) {
            provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
          }
        }
      });
      vscode.workspace.onDidChangeTextDocument((event) => {
        if (event.contentChanges.length === 0) {
          return;
        }
        const textDocument = event.document;
        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
          return;
        }
        const [notebookDocument] = this.findNotebookDocumentAndCell(textDocument);
        if (notebookDocument === void 0) {
          return;
        }
        for (const provider of this.registrations.values()) {
          if (provider instanceof NotebookDocumentSyncFeatureProvider) {
            provider.didChangeNotebookCellTextDocument(notebookDocument, event);
          }
        }
      });
      vscode.workspace.onDidCloseTextDocument((textDocument) => {
        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
          return;
        }
        const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
        if (notebookDocument === void 0 || notebookCell === void 0) {
          return;
        }
        for (const provider of this.registrations.values()) {
          if (provider instanceof NotebookDocumentSyncFeatureProvider) {
            provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
          }
        }
      });
    }
    getState() {
      if (this.registrations.size === 0) {
        return { kind: "document", id: this.registrationType.method, registrations: false, matches: false };
      }
      for (const provider of this.registrations.values()) {
        const state = provider.getState();
        if (state.kind === "document" && state.registrations === true && state.matches === true) {
          return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
        }
      }
      return { kind: "document", id: this.registrationType.method, registrations: true, matches: false };
    }
    fillClientCapabilities(capabilities) {
      const synchronization = ensure(ensure(capabilities, "notebookDocument"), "synchronization");
      synchronization.dynamicRegistration = true;
      synchronization.executionSummarySupport = true;
    }
    preInitialize(capabilities) {
      const options = capabilities.notebookDocumentSync;
      if (options === void 0) {
        return;
      }
      this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
    }
    initialize(capabilities) {
      const options = capabilities.notebookDocumentSync;
      if (options === void 0) {
        return;
      }
      const id = options.id ?? UUID.generateUuid();
      this.register({ id, registerOptions: options });
    }
    register(data) {
      const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
      this.registrations.set(data.id, provider);
    }
    unregister(id) {
      const provider = this.registrations.get(id);
      provider && provider.dispose();
    }
    dispose() {
      for (const provider of this.registrations.values()) {
        provider.dispose();
      }
      this.registrations.clear();
    }
    handles(textDocument) {
      if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
        return false;
      }
      if (this.dedicatedChannel !== void 0 && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {
        return true;
      }
      for (const provider of this.registrations.values()) {
        if (provider.handles(textDocument)) {
          return true;
        }
      }
      return false;
    }
    getProvider(notebookCell) {
      for (const provider of this.registrations.values()) {
        if (provider.handles(notebookCell.document)) {
          return provider;
        }
      }
      return void 0;
    }
    findNotebookDocumentAndCell(textDocument) {
      const uri = textDocument.uri.toString();
      for (const notebookDocument of vscode.workspace.notebookDocuments) {
        for (const cell of notebookDocument.getCells()) {
          if (cell.document.uri.toString() === uri) {
            return [notebookDocument, cell];
          }
        }
      }
      return [void 0, void 0];
    }
  }
  notebook.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
  NotebookDocumentSyncFeature.CellScheme = "vscode-notebook-cell";
  return notebook;
}
var configuration = {};
var hasRequiredConfiguration;
function requireConfiguration() {
  if (hasRequiredConfiguration)
    return configuration;
  hasRequiredConfiguration = 1;
  Object.defineProperty(configuration, "__esModule", { value: true });
  configuration.SyncConfigurationFeature = configuration.toJSONObject = configuration.ConfigurationFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const Is2 = requireIs();
  const UUID = requireUuid();
  const features_1 = requireFeatures();
  class ConfigurationFeature {
    constructor(client2) {
      this._client = client2;
    }
    getState() {
      return { kind: "static" };
    }
    fillClientCapabilities(capabilities) {
      capabilities.workspace = capabilities.workspace || {};
      capabilities.workspace.configuration = true;
    }
    initialize() {
      let client2 = this._client;
      client2.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
        let configuration2 = (params2) => {
          let result = [];
          for (let item of params2.items) {
            let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
            result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
          }
          return result;
        };
        let middleware = client2.middleware.workspace;
        return middleware && middleware.configuration ? middleware.configuration(params, token, configuration2) : configuration2(params);
      });
    }
    getConfiguration(resource, section) {
      let result = null;
      if (section) {
        let index2 = section.lastIndexOf(".");
        if (index2 === -1) {
          result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));
        } else {
          let config = vscode_1.workspace.getConfiguration(section.substr(0, index2), resource);
          if (config) {
            result = toJSONObject(config.get(section.substr(index2 + 1)));
          }
        }
      } else {
        let config = vscode_1.workspace.getConfiguration(void 0, resource);
        result = {};
        for (let key of Object.keys(config)) {
          if (config.has(key)) {
            result[key] = toJSONObject(config.get(key));
          }
        }
      }
      if (result === void 0) {
        result = null;
      }
      return result;
    }
    dispose() {
    }
  }
  configuration.ConfigurationFeature = ConfigurationFeature;
  function toJSONObject(obj) {
    if (obj) {
      if (Array.isArray(obj)) {
        return obj.map(toJSONObject);
      } else if (typeof obj === "object") {
        const res = /* @__PURE__ */ Object.create(null);
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            res[key] = toJSONObject(obj[key]);
          }
        }
        return res;
      }
    }
    return obj;
  }
  configuration.toJSONObject = toJSONObject;
  class SyncConfigurationFeature {
    constructor(_client) {
      this._client = _client;
      this.isDisposed = false;
      this._listeners = /* @__PURE__ */ new Map();
    }
    getState() {
      return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
    }
    initialize() {
      var _a3;
      let section = (_a3 = this._client.clientOptions.synchronize) == null ? void 0 : _a3.configurationSection;
      if (section !== void 0) {
        this.register({
          id: UUID.generateUuid(),
          registerOptions: {
            section
          }
        });
      }
    }
    register(data) {
      let disposable2 = vscode_1.workspace.onDidChangeConfiguration((event) => {
        this.onDidChangeConfiguration(data.registerOptions.section, event);
      });
      this._listeners.set(data.id, disposable2);
      if (data.registerOptions.section !== void 0) {
        this.onDidChangeConfiguration(data.registerOptions.section, void 0);
      }
    }
    unregister(id) {
      let disposable2 = this._listeners.get(id);
      if (disposable2) {
        this._listeners.delete(id);
        disposable2.dispose();
      }
    }
    dispose() {
      for (const disposable2 of this._listeners.values()) {
        disposable2.dispose();
      }
      this._listeners.clear();
      this.isDisposed = true;
    }
    onDidChangeConfiguration(configurationSection, event) {
      var _a3;
      if (this.isDisposed) {
        return;
      }
      let sections;
      if (Is2.string(configurationSection)) {
        sections = [configurationSection];
      } else {
        sections = configurationSection;
      }
      if (sections !== void 0 && event !== void 0) {
        let affected = sections.some((section) => event.affectsConfiguration(section));
        if (!affected) {
          return;
        }
      }
      const didChangeConfiguration = async (sections2) => {
        if (sections2 === void 0) {
          return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
        } else {
          return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections2) });
        }
      };
      let middleware = (_a3 = this._client.middleware.workspace) == null ? void 0 : _a3.didChangeConfiguration;
      (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
        this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
      });
    }
    extractSettingsInformation(keys) {
      function ensurePath(config, path2) {
        let current = config;
        for (let i = 0; i < path2.length - 1; i++) {
          let obj = current[path2[i]];
          if (!obj) {
            obj = /* @__PURE__ */ Object.create(null);
            current[path2[i]] = obj;
          }
          current = obj;
        }
        return current;
      }
      let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0;
      let result = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        let index2 = key.indexOf(".");
        let config = null;
        if (index2 >= 0) {
          config = vscode_1.workspace.getConfiguration(key.substr(0, index2), resource).get(key.substr(index2 + 1));
        } else {
          config = vscode_1.workspace.getConfiguration(void 0, resource).get(key);
        }
        if (config) {
          let path2 = keys[i].split(".");
          ensurePath(result, path2)[path2[path2.length - 1]] = toJSONObject(config);
        }
      }
      return result;
    }
  }
  configuration.SyncConfigurationFeature = SyncConfigurationFeature;
  return configuration;
}
var textSynchronization = {};
var hasRequiredTextSynchronization;
function requireTextSynchronization() {
  if (hasRequiredTextSynchronization)
    return textSynchronization;
  hasRequiredTextSynchronization = 1;
  Object.defineProperty(textSynchronization, "__esModule", { value: true });
  textSynchronization.DidSaveTextDocumentFeature = textSynchronization.WillSaveWaitUntilFeature = textSynchronization.WillSaveFeature = textSynchronization.DidChangeTextDocumentFeature = textSynchronization.DidCloseTextDocumentFeature = textSynchronization.DidOpenTextDocumentFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  class DidOpenTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client2, syncedDocuments) {
      super(client2, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client2.middleware.didOpen, (textDocument) => client2.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
      this._syncedDocuments = syncedDocuments;
    }
    get openDocuments() {
      return this._syncedDocuments.values();
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
        this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
      }
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    register(data) {
      super.register(data);
      if (!data.registerOptions.documentSelector) {
        return;
      }
      const documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
      vscode_1.workspace.textDocuments.forEach((textDocument) => {
        const uri = textDocument.uri.toString();
        if (this._syncedDocuments.has(uri)) {
          return;
        }
        if (vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
          const middleware = this._client.middleware;
          const didOpen = (textDocument2) => {
            return this._client.sendNotification(this._type, this._createParams(textDocument2));
          };
          (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
            this._client.error(`Sending document notification ${this._type.method} failed`, error);
          });
          this._syncedDocuments.set(uri, textDocument);
        }
      });
    }
    getTextDocument(data) {
      return data;
    }
    notificationSent(textDocument, type, params) {
      this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      super.notificationSent(textDocument, type, params);
    }
  }
  textSynchronization.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
  class DidCloseTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client2, syncedDocuments, pendingTextDocumentChanges) {
      super(client2, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client2.middleware.didClose, (textDocument) => client2.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
      this._syncedDocuments = syncedDocuments;
      this._pendingTextDocumentChanges = pendingTextDocumentChanges;
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
        this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
      }
    }
    async callback(data) {
      await super.callback(data);
      this._pendingTextDocumentChanges.delete(data.uri.toString());
    }
    getTextDocument(data) {
      return data;
    }
    notificationSent(textDocument, type, params) {
      this._syncedDocuments.delete(textDocument.uri.toString());
      super.notificationSent(textDocument, type, params);
    }
    unregister(id) {
      const selector = this._selectors.get(id);
      super.unregister(id);
      const selectors = this._selectors.values();
      this._syncedDocuments.forEach((textDocument) => {
        if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
          let middleware = this._client.middleware;
          let didClose = (textDocument2) => {
            return this._client.sendNotification(this._type, this._createParams(textDocument2));
          };
          this._syncedDocuments.delete(textDocument.uri.toString());
          (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
            this._client.error(`Sending document notification ${this._type.method} failed`, error);
          });
        }
      });
    }
  }
  textSynchronization.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
  class DidChangeTextDocumentFeature extends features_1.DynamicDocumentFeature {
    constructor(client2, pendingTextDocumentChanges) {
      super(client2);
      this._changeData = /* @__PURE__ */ new Map();
      this._onNotificationSent = new vscode_1.EventEmitter();
      this._onPendingChangeAdded = new vscode_1.EventEmitter();
      this._pendingTextDocumentChanges = pendingTextDocumentChanges;
      this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
    }
    get onNotificationSent() {
      return this._onNotificationSent.event;
    }
    get onPendingChangeAdded() {
      return this._onPendingChangeAdded.event;
    }
    get syncKind() {
      return this._syncKind;
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
        this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
        });
      }
    }
    register(data) {
      if (!data.registerOptions.documentSelector) {
        return;
      }
      if (!this._listener) {
        this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
      }
      this._changeData.set(data.id, {
        syncKind: data.registerOptions.syncKind,
        documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector)
      });
      this.updateSyncKind(data.registerOptions.syncKind);
    }
    *getDocumentSelectors() {
      for (const data of this._changeData.values()) {
        yield data.documentSelector;
      }
    }
    async callback(event) {
      if (event.contentChanges.length === 0) {
        return;
      }
      const uri = event.document.uri;
      const version = event.document.version;
      const promises = [];
      for (const changeData of this._changeData.values()) {
        if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
          const middleware = this._client.middleware;
          if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
            const didChange = async (event2) => {
              const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2, uri, version);
              await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              this.notificationSent(event2.document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
            };
            promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
          } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
            const didChange = async (event2) => {
              const eventUri = event2.document.uri.toString();
              this._pendingTextDocumentChanges.set(eventUri, event2.document);
              this._onPendingChangeAdded.fire();
            };
            promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
          }
        }
      }
      return Promise.all(promises).then(void 0, (error) => {
        this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
        throw error;
      });
    }
    notificationSent(textDocument, type, params) {
      this._onNotificationSent.fire({ textDocument, type, params });
    }
    unregister(id) {
      this._changeData.delete(id);
      if (this._changeData.size === 0) {
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
      } else {
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        for (const changeData of this._changeData.values()) {
          this.updateSyncKind(changeData.syncKind);
          if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
            break;
          }
        }
      }
    }
    dispose() {
      this._pendingTextDocumentChanges.clear();
      this._changeData.clear();
      this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
      if (this._listener) {
        this._listener.dispose();
        this._listener = void 0;
      }
    }
    getPendingDocumentChanges(excludes) {
      if (this._pendingTextDocumentChanges.size === 0) {
        return [];
      }
      let result;
      if (excludes.size === 0) {
        result = Array.from(this._pendingTextDocumentChanges.values());
        this._pendingTextDocumentChanges.clear();
      } else {
        result = [];
        for (const entry of this._pendingTextDocumentChanges) {
          if (!excludes.has(entry[0])) {
            result.push(entry[1]);
            this._pendingTextDocumentChanges.delete(entry[0]);
          }
        }
      }
      return result;
    }
    getProvider(document2) {
      for (const changeData of this._changeData.values()) {
        if (vscode_1.languages.match(changeData.documentSelector, document2) > 0) {
          return {
            send: (event) => {
              return this.callback(event);
            }
          };
        }
      }
      return void 0;
    }
    updateSyncKind(syncKind) {
      if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
        return;
      }
      switch (syncKind) {
        case vscode_languageserver_protocol_1.TextDocumentSyncKind.Full:
          this._syncKind = syncKind;
          break;
        case vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental:
          if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
          }
          break;
      }
    }
  }
  textSynchronization.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
  class WillSaveFeature extends features_1.TextDocumentEventFeature {
    constructor(client2) {
      super(client2, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client2.middleware.willSave, (willSaveEvent) => client2.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
      value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
        this.register({
          id: UUID.generateUuid(),
          registerOptions: { documentSelector }
        });
      }
    }
    getTextDocument(data) {
      return data.document;
    }
  }
  textSynchronization.WillSaveFeature = WillSaveFeature;
  class WillSaveWaitUntilFeature extends features_1.DynamicDocumentFeature {
    constructor(client2) {
      super(client2);
      this._selectors = /* @__PURE__ */ new Map();
    }
    getDocumentSelectors() {
      return this._selectors.values();
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
      let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
      value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
        this.register({
          id: UUID.generateUuid(),
          registerOptions: { documentSelector }
        });
      }
    }
    register(data) {
      if (!data.registerOptions.documentSelector) {
        return;
      }
      if (!this._listener) {
        this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
      }
      this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
    }
    callback(event) {
      if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
        let middleware = this._client.middleware;
        let willSaveWaitUntil = (event2) => {
          return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2)).then(async (edits) => {
            let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
            return vEdits === void 0 ? [] : vEdits;
          });
        };
        event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
      }
    }
    unregister(id) {
      this._selectors.delete(id);
      if (this._selectors.size === 0 && this._listener) {
        this._listener.dispose();
        this._listener = void 0;
      }
    }
    dispose() {
      this._selectors.clear();
      if (this._listener) {
        this._listener.dispose();
        this._listener = void 0;
      }
    }
  }
  textSynchronization.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
  class DidSaveTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client2) {
      super(client2, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client2.middleware.didSave, (textDocument) => client2.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
      this._includeText = false;
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").didSave = true;
    }
    initialize(capabilities, documentSelector) {
      const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
        const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
        this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, { documentSelector }, saveOptions)
        });
      }
    }
    register(data) {
      this._includeText = !!data.registerOptions.includeText;
      super.register(data);
    }
    getTextDocument(data) {
      return data;
    }
  }
  textSynchronization.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
  return textSynchronization;
}
var completion = {};
var hasRequiredCompletion;
function requireCompletion() {
  if (hasRequiredCompletion)
    return completion;
  hasRequiredCompletion = 1;
  Object.defineProperty(completion, "__esModule", { value: true });
  completion.CompletionItemFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
  ];
  class CompletionItemFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.CompletionRequest.type);
      this.labelDetailsSupport = /* @__PURE__ */ new Map();
    }
    fillClientCapabilities(capabilities) {
      let completion2 = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "completion");
      completion2.dynamicRegistration = true;
      completion2.contextSupport = true;
      completion2.completionItem = {
        snippetSupport: true,
        commitCharactersSupport: true,
        documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
        deprecatedSupport: true,
        preselectSupport: true,
        tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
        insertReplaceSupport: true,
        resolveSupport: {
          properties: ["documentation", "detail", "additionalTextEdits"]
        },
        insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
        labelDetailsSupport: true
      };
      completion2.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
      completion2.completionItemKind = { valueSet: SupportedCompletionItemKinds };
      completion2.completionList = {
        itemDefaults: [
          "commitCharacters",
          "editRange",
          "insertTextFormat",
          "insertTextMode"
        ]
      };
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
      if (!options) {
        return;
      }
      this.register({
        id: UUID.generateUuid(),
        registerOptions: options
      });
    }
    registerLanguageProvider(options, id) {
      var _a3;
      this.labelDetailsSupport.set(id, !!((_a3 = options.completionItem) == null ? void 0 : _a3.labelDetailsSupport));
      const triggerCharacters = options.triggerCharacters ?? [];
      const defaultCommitCharacters = options.allCommitCharacters;
      const selector = options.documentSelector;
      const provider = {
        provideCompletionItems: (document2, position, token, context) => {
          const client2 = this._client;
          const middleware = this._client.middleware;
          const provideCompletionItems = (document3, position2, context2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client2.code2ProtocolConverter.asCompletionParams(document3, position2, context2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token2, error, null);
            });
          };
          return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
        },
        resolveCompletionItem: options.resolveProvider ? (item, token) => {
          const client2 = this._client;
          const middleware = this._client.middleware;
          const resolveCompletionItem = (item2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client2.code2ProtocolConverter.asCompletionItem(item2, !!this.labelDetailsSupport.get(id)), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asCompletionItem(result);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token2, error, item2);
            });
          };
          return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
        } : void 0
      };
      return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, ...triggerCharacters), provider];
    }
  }
  completion.CompletionItemFeature = CompletionItemFeature;
  return completion;
}
var hover = {};
var hasRequiredHover;
function requireHover() {
  if (hasRequiredHover)
    return hover;
  hasRequiredHover = 1;
  Object.defineProperty(hover, "__esModule", { value: true });
  hover.HoverFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  class HoverFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const hoverCapability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "hover");
      hoverCapability.dynamicRegistration = true;
      hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
      if (!options) {
        return;
      }
      this.register({
        id: UUID.generateUuid(),
        registerOptions: options
      });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideHover: (document2, position, token) => {
          const client2 = this._client;
          const provideHover = (document3, position2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asHover(result);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  hover.HoverFeature = HoverFeature;
  return hover;
}
var definition = {};
var hasRequiredDefinition;
function requireDefinition() {
  if (hasRequiredDefinition)
    return definition;
  hasRequiredDefinition = 1;
  Object.defineProperty(definition, "__esModule", { value: true });
  definition.DefinitionFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  class DefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
      let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "definition");
      definitionSupport.dynamicRegistration = true;
      definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideDefinition: (document2, position, token) => {
          const client2 = this._client;
          const provideDefinition = (document3, position2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asDefinitionResult(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  definition.DefinitionFeature = DefinitionFeature;
  return definition;
}
var signatureHelp = {};
var hasRequiredSignatureHelp;
function requireSignatureHelp() {
  if (hasRequiredSignatureHelp)
    return signatureHelp;
  hasRequiredSignatureHelp = 1;
  Object.defineProperty(signatureHelp, "__esModule", { value: true });
  signatureHelp.SignatureHelpFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  class SignatureHelpFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilities) {
      let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "signatureHelp");
      config.dynamicRegistration = true;
      config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
      config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
      config.signatureInformation.activeParameterSupport = true;
      config.contextSupport = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
      if (!options) {
        return;
      }
      this.register({
        id: UUID.generateUuid(),
        registerOptions: options
      });
    }
    registerLanguageProvider(options) {
      const provider = {
        provideSignatureHelp: (document2, position, token, context) => {
          const client2 = this._client;
          const providerSignatureHelp = (document3, position2, context2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client2.code2ProtocolConverter.asSignatureHelpParams(document3, position2, context2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asSignatureHelp(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
        }
      };
      return [this.registerProvider(options, provider), provider];
    }
    registerProvider(options, provider) {
      const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
      if (options.retriggerCharacters === void 0) {
        const triggerCharacters = options.triggerCharacters || [];
        return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
      } else {
        const metaData = {
          triggerCharacters: options.triggerCharacters || [],
          retriggerCharacters: options.retriggerCharacters || []
        };
        return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
      }
    }
  }
  signatureHelp.SignatureHelpFeature = SignatureHelpFeature;
  return signatureHelp;
}
var documentHighlight = {};
var hasRequiredDocumentHighlight;
function requireDocumentHighlight() {
  if (hasRequiredDocumentHighlight)
    return documentHighlight;
  hasRequiredDocumentHighlight = 1;
  Object.defineProperty(documentHighlight, "__esModule", { value: true });
  documentHighlight.DocumentHighlightFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  class DocumentHighlightFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideDocumentHighlights: (document2, position, token) => {
          const client2 = this._client;
          const _provideDocumentHighlights = (document3, position2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asDocumentHighlights(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
        }
      };
      return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  }
  documentHighlight.DocumentHighlightFeature = DocumentHighlightFeature;
  return documentHighlight;
}
var documentSymbol = {};
var hasRequiredDocumentSymbol;
function requireDocumentSymbol() {
  if (hasRequiredDocumentSymbol)
    return documentSymbol;
  hasRequiredDocumentSymbol = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentSymbolFeature = exports.SupportedSymbolTags = exports.SupportedSymbolKinds = void 0;
    const vscode_1 = require$$0;
    const vscode_languageserver_protocol_1 = requireMain();
    const features_1 = requireFeatures();
    const UUID = requireUuid();
    exports.SupportedSymbolKinds = [
      vscode_languageserver_protocol_1.SymbolKind.File,
      vscode_languageserver_protocol_1.SymbolKind.Module,
      vscode_languageserver_protocol_1.SymbolKind.Namespace,
      vscode_languageserver_protocol_1.SymbolKind.Package,
      vscode_languageserver_protocol_1.SymbolKind.Class,
      vscode_languageserver_protocol_1.SymbolKind.Method,
      vscode_languageserver_protocol_1.SymbolKind.Property,
      vscode_languageserver_protocol_1.SymbolKind.Field,
      vscode_languageserver_protocol_1.SymbolKind.Constructor,
      vscode_languageserver_protocol_1.SymbolKind.Enum,
      vscode_languageserver_protocol_1.SymbolKind.Interface,
      vscode_languageserver_protocol_1.SymbolKind.Function,
      vscode_languageserver_protocol_1.SymbolKind.Variable,
      vscode_languageserver_protocol_1.SymbolKind.Constant,
      vscode_languageserver_protocol_1.SymbolKind.String,
      vscode_languageserver_protocol_1.SymbolKind.Number,
      vscode_languageserver_protocol_1.SymbolKind.Boolean,
      vscode_languageserver_protocol_1.SymbolKind.Array,
      vscode_languageserver_protocol_1.SymbolKind.Object,
      vscode_languageserver_protocol_1.SymbolKind.Key,
      vscode_languageserver_protocol_1.SymbolKind.Null,
      vscode_languageserver_protocol_1.SymbolKind.EnumMember,
      vscode_languageserver_protocol_1.SymbolKind.Struct,
      vscode_languageserver_protocol_1.SymbolKind.Event,
      vscode_languageserver_protocol_1.SymbolKind.Operator,
      vscode_languageserver_protocol_1.SymbolKind.TypeParameter
    ];
    exports.SupportedSymbolTags = [
      vscode_languageserver_protocol_1.SymbolTag.Deprecated
    ];
    class DocumentSymbolFeature extends features_1.TextDocumentLanguageFeature {
      constructor(client2) {
        super(client2, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: exports.SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: exports.SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentSymbols: (document2, token) => {
            const client2 = this._client;
            const _provideDocumentSymbols = async (document3, token2) => {
              try {
                const data = await client2.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client2.code2ProtocolConverter.asDocumentSymbolParams(document3), token2);
                if (token2.isCancellationRequested || data === void 0 || data === null) {
                  return null;
                }
                if (data.length === 0) {
                  return [];
                } else {
                  const first2 = data[0];
                  if (vscode_languageserver_protocol_1.DocumentSymbol.is(first2)) {
                    return await client2.protocol2CodeConverter.asDocumentSymbols(data, token2);
                  } else {
                    return await client2.protocol2CodeConverter.asSymbolInformations(data, token2);
                  }
                }
              } catch (error) {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token2, error, null);
              }
            };
            const middleware = client2.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
          }
        };
        const metaData = options.label !== void 0 ? { label: options.label } : void 0;
        return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, metaData), provider];
      }
    }
    exports.DocumentSymbolFeature = DocumentSymbolFeature;
  })(documentSymbol);
  return documentSymbol;
}
var workspaceSymbol = {};
var hasRequiredWorkspaceSymbol;
function requireWorkspaceSymbol() {
  if (hasRequiredWorkspaceSymbol)
    return workspaceSymbol;
  hasRequiredWorkspaceSymbol = 1;
  Object.defineProperty(workspaceSymbol, "__esModule", { value: true });
  workspaceSymbol.WorkspaceSymbolFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const documentSymbol_1 = requireDocumentSymbol();
  const UUID = requireUuid();
  class WorkspaceSymbolFeature extends features_1.WorkspaceFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
      let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "symbol");
      symbolCapabilities.dynamicRegistration = true;
      symbolCapabilities.symbolKind = {
        valueSet: documentSymbol_1.SupportedSymbolKinds
      };
      symbolCapabilities.tagSupport = {
        valueSet: documentSymbol_1.SupportedSymbolTags
      };
      symbolCapabilities.resolveSupport = { properties: ["location.range"] };
    }
    initialize(capabilities) {
      if (!capabilities.workspaceSymbolProvider) {
        return;
      }
      this.register({
        id: UUID.generateUuid(),
        registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
      });
    }
    registerLanguageProvider(options) {
      const provider = {
        provideWorkspaceSymbols: (query, token) => {
          const client2 = this._client;
          const provideWorkspaceSymbols = (query2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query2 }, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asSymbolInformations(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
        },
        resolveWorkspaceSymbol: options.resolveProvider === true ? (item, token) => {
          const client2 = this._client;
          const resolveWorkspaceSymbol = (item2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client2.code2ProtocolConverter.asWorkspaceSymbol(item2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asSymbolInformation(result);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
        } : void 0
      };
      return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
    }
  }
  workspaceSymbol.WorkspaceSymbolFeature = WorkspaceSymbolFeature;
  return workspaceSymbol;
}
var reference = {};
var hasRequiredReference;
function requireReference() {
  if (hasRequiredReference)
    return reference;
  hasRequiredReference = 1;
  Object.defineProperty(reference, "__esModule", { value: true });
  reference.ReferencesFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  class ReferencesFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "references").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideReferences: (document2, position, options2, token) => {
          const client2 = this._client;
          const _providerReferences = (document3, position2, options3, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client2.code2ProtocolConverter.asReferenceParams(document3, position2, options3), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asReferences(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideReferences ? middleware.provideReferences(document2, position, options2, token, _providerReferences) : _providerReferences(document2, position, options2, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  reference.ReferencesFeature = ReferencesFeature;
  return reference;
}
var codeAction = {};
var hasRequiredCodeAction;
function requireCodeAction() {
  if (hasRequiredCodeAction)
    return codeAction;
  hasRequiredCodeAction = 1;
  Object.defineProperty(codeAction, "__esModule", { value: true });
  codeAction.CodeActionFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const UUID = requireUuid();
  const features_1 = requireFeatures();
  class CodeActionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeAction");
      cap.dynamicRegistration = true;
      cap.isPreferredSupport = true;
      cap.disabledSupport = true;
      cap.dataSupport = true;
      cap.resolveSupport = {
        properties: ["edit"]
      };
      cap.codeActionLiteralSupport = {
        codeActionKind: {
          valueSet: [
            vscode_languageserver_protocol_1.CodeActionKind.Empty,
            vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
            vscode_languageserver_protocol_1.CodeActionKind.Refactor,
            vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
            vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
            vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
            vscode_languageserver_protocol_1.CodeActionKind.Source,
            vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
          ]
        }
      };
      cap.honorsChangeAnnotations = false;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideCodeActions: (document2, range, context, token) => {
          const client2 = this._client;
          const _provideCodeActions = async (document3, range2, context2, token2) => {
            const params = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              range: client2.code2ProtocolConverter.asRange(range2),
              context: await client2.code2ProtocolConverter.asCodeActionContext(context2, token2)
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token2).then((values) => {
              if (token2.isCancellationRequested || values === null || values === void 0) {
                return null;
              }
              return client2.protocol2CodeConverter.asCodeActionResult(values, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
        },
        resolveCodeAction: options.resolveProvider ? (item, token) => {
          const client2 = this._client;
          const middleware = this._client.middleware;
          const resolveCodeAction = async (item2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, await client2.code2ProtocolConverter.asCodeAction(item2, token2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return item2;
              }
              return client2.protocol2CodeConverter.asCodeAction(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token2, error, item2);
            });
          };
          return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
        } : void 0
      };
      return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.codeActionKinds ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) } : void 0), provider];
    }
  }
  codeAction.CodeActionFeature = CodeActionFeature;
  return codeAction;
}
var codeLens = {};
var hasRequiredCodeLens;
function requireCodeLens() {
  if (hasRequiredCodeLens)
    return codeLens;
  hasRequiredCodeLens = 1;
  Object.defineProperty(codeLens, "__esModule", { value: true });
  codeLens.CodeLensFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const UUID = requireUuid();
  const features_1 = requireFeatures();
  class CodeLensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "codeLens").refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
      const client2 = this._client;
      client2.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
        for (const provider of this.getAllProviders()) {
          provider.onDidChangeCodeLensEmitter.fire();
        }
      });
      const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const eventEmitter = new vscode_1.EventEmitter();
      const provider = {
        onDidChangeCodeLenses: eventEmitter.event,
        provideCodeLenses: (document2, token) => {
          const client2 = this._client;
          const provideCodeLenses = (document3, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client2.code2ProtocolConverter.asCodeLensParams(document3), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asCodeLenses(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
        },
        resolveCodeLens: options.resolveProvider ? (codeLens2, token) => {
          const client2 = this._client;
          const resolveCodeLens = (codeLens3, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client2.code2ProtocolConverter.asCodeLens(codeLens3), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return codeLens3;
              }
              return client2.protocol2CodeConverter.asCodeLens(result);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token2, error, codeLens3);
            });
          };
          const middleware = client2.middleware;
          return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens2, token, resolveCodeLens) : resolveCodeLens(codeLens2, token);
        } : void 0
      };
      return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
    }
  }
  codeLens.CodeLensFeature = CodeLensFeature;
  return codeLens;
}
var formatting = {};
var hasRequiredFormatting;
function requireFormatting() {
  if (hasRequiredFormatting)
    return formatting;
  hasRequiredFormatting = 1;
  Object.defineProperty(formatting, "__esModule", { value: true });
  formatting.DocumentOnTypeFormattingFeature = formatting.DocumentRangeFormattingFeature = formatting.DocumentFormattingFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const UUID = requireUuid();
  const features_1 = requireFeatures();
  var FileFormattingOptions;
  (function(FileFormattingOptions2) {
    function fromConfiguration(document2) {
      const filesConfig = vscode_1.workspace.getConfiguration("files", document2);
      return {
        trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
        trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
        insertFinalNewline: filesConfig.get("insertFinalNewline")
      };
    }
    FileFormattingOptions2.fromConfiguration = fromConfiguration;
  })(FileFormattingOptions || (FileFormattingOptions = {}));
  class DocumentFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideDocumentFormattingEdits: (document2, options2, token) => {
          const client2 = this._client;
          const provideDocumentFormattingEdits = (document3, options3, token2) => {
            const params = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              options: client2.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asTextEdits(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options2, token);
        }
      };
      return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  }
  formatting.DocumentFormattingFeature = DocumentFormattingFeature;
  class DocumentRangeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rangeFormatting").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideDocumentRangeFormattingEdits: (document2, range, options2, token) => {
          const client2 = this._client;
          const provideDocumentRangeFormattingEdits = (document3, range2, options3, token2) => {
            const params = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              range: client2.code2ProtocolConverter.asRange(range2),
              options: client2.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asTextEdits(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options2, token);
        }
      };
      return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  }
  formatting.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
  class DocumentOnTypeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideOnTypeFormattingEdits: (document2, position, ch, options2, token) => {
          const client2 = this._client;
          const provideOnTypeFormattingEdits = (document3, position2, ch2, options3, token2) => {
            let params = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              position: client2.code2ProtocolConverter.asPosition(position2),
              ch: ch2,
              options: client2.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asTextEdits(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options2, token);
        }
      };
      const moreTriggerCharacter = options.moreTriggerCharacter || [];
      return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
  }
  formatting.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
  return formatting;
}
var rename = {};
var hasRequiredRename;
function requireRename() {
  if (hasRequiredRename)
    return rename;
  hasRequiredRename = 1;
  Object.defineProperty(rename, "__esModule", { value: true });
  rename.RenameFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const UUID = requireUuid();
  const Is2 = requireIs();
  const features_1 = requireFeatures();
  class RenameFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilities) {
      let rename2 = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rename");
      rename2.dynamicRegistration = true;
      rename2.prepareSupport = true;
      rename2.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
      rename2.honorsChangeAnnotations = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
      if (!options) {
        return;
      }
      if (Is2.boolean(capabilities.renameProvider)) {
        options.prepareProvider = false;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideRenameEdits: (document2, position, newName, token) => {
          const client2 = this._client;
          const provideRenameEdits = (document3, position2, newName2, token2) => {
            let params = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              position: client2.code2ProtocolConverter.asPosition(position2),
              newName: newName2
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asWorkspaceEdit(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token2, error, null, false);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
        },
        prepareRename: options.prepareProvider ? (document2, position, token) => {
          const client2 = this._client;
          const prepareRename = (document3, position2, token2) => {
            let params = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              position: client2.code2ProtocolConverter.asPosition(position2)
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              if (vscode_languageserver_protocol_1.Range.is(result)) {
                return client2.protocol2CodeConverter.asRange(result);
              } else if (this.isDefaultBehavior(result)) {
                return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
              } else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                return {
                  range: client2.protocol2CodeConverter.asRange(result.range),
                  placeholder: result.placeholder
                };
              }
              return Promise.reject(new Error(`The element can't be renamed.`));
            }, (error) => {
              if (typeof error.message === "string") {
                throw new Error(error.message);
              } else {
                throw new Error(`The element can't be renamed.`);
              }
            });
          };
          const middleware = client2.middleware;
          return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
        } : void 0
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
    isDefaultBehavior(value) {
      const candidate = value;
      return candidate && Is2.boolean(candidate.defaultBehavior);
    }
  }
  rename.RenameFeature = RenameFeature;
  return rename;
}
var documentLink = {};
var hasRequiredDocumentLink;
function requireDocumentLink() {
  if (hasRequiredDocumentLink)
    return documentLink;
  hasRequiredDocumentLink = 1;
  Object.defineProperty(documentLink, "__esModule", { value: true });
  documentLink.DocumentLinkFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const UUID = requireUuid();
  class DocumentLinkFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentLink");
      documentLinkCapabilities.dynamicRegistration = true;
      documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
      const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
      if (!options) {
        return;
      }
      this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideDocumentLinks: (document2, token) => {
          const client2 = this._client;
          const provideDocumentLinks = (document3, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client2.code2ProtocolConverter.asDocumentLinkParams(document3), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asDocumentLinks(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
        },
        resolveDocumentLink: options.resolveProvider ? (link, token) => {
          const client2 = this._client;
          let resolveDocumentLink = (link2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client2.code2ProtocolConverter.asDocumentLink(link2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return link2;
              }
              return client2.protocol2CodeConverter.asDocumentLink(result);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token2, error, link2);
            });
          };
          const middleware = client2.middleware;
          return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
        } : void 0
      };
      return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  }
  documentLink.DocumentLinkFeature = DocumentLinkFeature;
  return documentLink;
}
var executeCommand = {};
var hasRequiredExecuteCommand;
function requireExecuteCommand() {
  if (hasRequiredExecuteCommand)
    return executeCommand;
  hasRequiredExecuteCommand = 1;
  Object.defineProperty(executeCommand, "__esModule", { value: true });
  executeCommand.ExecuteCommandFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const UUID = requireUuid();
  const features_1 = requireFeatures();
  class ExecuteCommandFeature {
    constructor(client2) {
      this._client = client2;
      this._commands = /* @__PURE__ */ new Map();
    }
    getState() {
      return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
    }
    initialize(capabilities) {
      if (!capabilities.executeCommandProvider) {
        return;
      }
      this.register({
        id: UUID.generateUuid(),
        registerOptions: Object.assign({}, capabilities.executeCommandProvider)
      });
    }
    register(data) {
      const client2 = this._client;
      const middleware = client2.middleware;
      const executeCommand2 = (command, args) => {
        let params = {
          command,
          arguments: args
        };
        return client2.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, (error) => {
          return client2.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, void 0, error, void 0);
        });
      };
      if (data.registerOptions.commands) {
        const disposables = [];
        for (const command of data.registerOptions.commands) {
          disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
            return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand2) : executeCommand2(command, args);
          }));
        }
        this._commands.set(data.id, disposables);
      }
    }
    unregister(id) {
      let disposables = this._commands.get(id);
      if (disposables) {
        disposables.forEach((disposable2) => disposable2.dispose());
      }
    }
    dispose() {
      this._commands.forEach((value) => {
        value.forEach((disposable2) => disposable2.dispose());
      });
      this._commands.clear();
    }
  }
  executeCommand.ExecuteCommandFeature = ExecuteCommandFeature;
  return executeCommand;
}
var fileSystemWatcher = {};
var hasRequiredFileSystemWatcher;
function requireFileSystemWatcher() {
  if (hasRequiredFileSystemWatcher)
    return fileSystemWatcher;
  hasRequiredFileSystemWatcher = 1;
  Object.defineProperty(fileSystemWatcher, "__esModule", { value: true });
  fileSystemWatcher.FileSystemWatcherFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class FileSystemWatcherFeature {
    constructor(client2, notifyFileEvent) {
      this._client = client2;
      this._notifyFileEvent = notifyFileEvent;
      this._watchers = /* @__PURE__ */ new Map();
    }
    getState() {
      return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(data) {
      if (!Array.isArray(data.registerOptions.watchers)) {
        return;
      }
      const disposables = [];
      for (const watcher of data.registerOptions.watchers) {
        const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
        if (globPattern === void 0) {
          continue;
        }
        let watchCreate = true, watchChange = true, watchDelete = true;
        if (watcher.kind !== void 0 && watcher.kind !== null) {
          watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
          watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
          watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
        }
        const fileSystemWatcher2 = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
        this.hookListeners(fileSystemWatcher2, watchCreate, watchChange, watchDelete, disposables);
        disposables.push(fileSystemWatcher2);
      }
      this._watchers.set(data.id, disposables);
    }
    registerRaw(id, fileSystemWatchers) {
      let disposables = [];
      for (let fileSystemWatcher2 of fileSystemWatchers) {
        this.hookListeners(fileSystemWatcher2, true, true, true, disposables);
      }
      this._watchers.set(id, disposables);
    }
    hookListeners(fileSystemWatcher2, watchCreate, watchChange, watchDelete, listeners) {
      if (watchCreate) {
        fileSystemWatcher2.onDidCreate((resource) => this._notifyFileEvent({
          uri: this._client.code2ProtocolConverter.asUri(resource),
          type: vscode_languageserver_protocol_1.FileChangeType.Created
        }), null, listeners);
      }
      if (watchChange) {
        fileSystemWatcher2.onDidChange((resource) => this._notifyFileEvent({
          uri: this._client.code2ProtocolConverter.asUri(resource),
          type: vscode_languageserver_protocol_1.FileChangeType.Changed
        }), null, listeners);
      }
      if (watchDelete) {
        fileSystemWatcher2.onDidDelete((resource) => this._notifyFileEvent({
          uri: this._client.code2ProtocolConverter.asUri(resource),
          type: vscode_languageserver_protocol_1.FileChangeType.Deleted
        }), null, listeners);
      }
    }
    unregister(id) {
      let disposables = this._watchers.get(id);
      if (disposables) {
        for (let disposable2 of disposables) {
          disposable2.dispose();
        }
      }
    }
    dispose() {
      this._watchers.forEach((disposables) => {
        for (let disposable2 of disposables) {
          disposable2.dispose();
        }
      });
      this._watchers.clear();
    }
  }
  fileSystemWatcher.FileSystemWatcherFeature = FileSystemWatcherFeature;
  return fileSystemWatcher;
}
var colorProvider = {};
var hasRequiredColorProvider;
function requireColorProvider() {
  if (hasRequiredColorProvider)
    return colorProvider;
  hasRequiredColorProvider = 1;
  Object.defineProperty(colorProvider, "__esModule", { value: true });
  colorProvider.ColorProviderFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class ColorProviderFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideColorPresentations: (color, context, token) => {
          const client2 = this._client;
          const provideColorPresentations = (color2, context2, token2) => {
            const requestParams = {
              color: color2,
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
              range: client2.code2ProtocolConverter.asRange(context2.range)
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return this._client.protocol2CodeConverter.asColorPresentations(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
        },
        provideDocumentColors: (document2, token) => {
          const client2 = this._client;
          const provideDocumentColors = (document3, token2) => {
            const requestParams = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3)
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return this._client.protocol2CodeConverter.asColorInformations(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
        }
      };
      return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  }
  colorProvider.ColorProviderFeature = ColorProviderFeature;
  return colorProvider;
}
var implementation = {};
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  Object.defineProperty(implementation, "__esModule", { value: true });
  implementation.ImplementationFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class ImplementationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilities) {
      let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "implementation");
      implementationSupport.dynamicRegistration = true;
      implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
      let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideImplementation: (document2, position, token) => {
          const client2 = this._client;
          const provideImplementation = (document3, position2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asDefinitionResult(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  implementation.ImplementationFeature = ImplementationFeature;
  return implementation;
}
var typeDefinition = {};
var hasRequiredTypeDefinition;
function requireTypeDefinition() {
  if (hasRequiredTypeDefinition)
    return typeDefinition;
  hasRequiredTypeDefinition = 1;
  Object.defineProperty(typeDefinition, "__esModule", { value: true });
  typeDefinition.TypeDefinitionFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class TypeDefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition").dynamicRegistration = true;
      let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition");
      typeDefinitionSupport.dynamicRegistration = true;
      typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
      let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideTypeDefinition: (document2, position, token) => {
          const client2 = this._client;
          const provideTypeDefinition = (document3, position2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asDefinitionResult(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  typeDefinition.TypeDefinitionFeature = TypeDefinitionFeature;
  return typeDefinition;
}
var workspaceFolder = {};
var hasRequiredWorkspaceFolder;
function requireWorkspaceFolder() {
  if (hasRequiredWorkspaceFolder)
    return workspaceFolder;
  hasRequiredWorkspaceFolder = 1;
  Object.defineProperty(workspaceFolder, "__esModule", { value: true });
  workspaceFolder.WorkspaceFoldersFeature = workspaceFolder.arrayDiff = void 0;
  const UUID = requireUuid();
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  function access(target, key) {
    if (target === void 0 || target === null) {
      return void 0;
    }
    return target[key];
  }
  function arrayDiff(left, right) {
    return left.filter((element) => right.indexOf(element) < 0);
  }
  workspaceFolder.arrayDiff = arrayDiff;
  class WorkspaceFoldersFeature {
    constructor(client2) {
      this._client = client2;
      this._listeners = /* @__PURE__ */ new Map();
    }
    getState() {
      return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
      const folders = vscode_1.workspace.workspaceFolders;
      this.initializeWithFolders(folders);
      if (folders === void 0) {
        params.workspaceFolders = null;
      } else {
        params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
      }
    }
    initializeWithFolders(currentWorkspaceFolders) {
      this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
      capabilities.workspace = capabilities.workspace || {};
      capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
      const client2 = this._client;
      client2.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
        const workspaceFolders = () => {
          const folders = vscode_1.workspace.workspaceFolders;
          if (folders === void 0) {
            return null;
          }
          const result = folders.map((folder) => {
            return this.asProtocol(folder);
          });
          return result;
        };
        const middleware = client2.middleware.workspace;
        return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders();
      });
      const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
      let id;
      if (typeof value === "string") {
        id = value;
      } else if (value === true) {
        id = UUID.generateUuid();
      }
      if (id) {
        this.register({ id, registerOptions: void 0 });
      }
    }
    sendInitialEvent(currentWorkspaceFolders) {
      let promise;
      if (this._initialFolders && currentWorkspaceFolders) {
        const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
        const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
        if (added.length > 0 || removed.length > 0) {
          promise = this.doSendEvent(added, removed);
        }
      } else if (this._initialFolders) {
        promise = this.doSendEvent([], this._initialFolders);
      } else if (currentWorkspaceFolders) {
        promise = this.doSendEvent(currentWorkspaceFolders, []);
      }
      if (promise !== void 0) {
        promise.catch((error) => {
          this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
        });
      }
    }
    doSendEvent(addedFolders, removedFolders) {
      let params = {
        event: {
          added: addedFolders.map((folder) => this.asProtocol(folder)),
          removed: removedFolders.map((folder) => this.asProtocol(folder))
        }
      };
      return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(data) {
      let id = data.id;
      let client2 = this._client;
      let disposable2 = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
        let didChangeWorkspaceFolders = (event2) => {
          return this.doSendEvent(event2.added, event2.removed);
        };
        let middleware = client2.middleware.workspace;
        const promise = middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
        promise.catch((error) => {
          this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
        });
      });
      this._listeners.set(id, disposable2);
      this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
      let disposable2 = this._listeners.get(id);
      if (disposable2 === void 0) {
        return;
      }
      this._listeners.delete(id);
      disposable2.dispose();
    }
    dispose() {
      for (let disposable2 of this._listeners.values()) {
        disposable2.dispose();
      }
      this._listeners.clear();
    }
    asProtocol(workspaceFolder2) {
      if (workspaceFolder2 === void 0) {
        return null;
      }
      return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder2.uri), name: workspaceFolder2.name };
    }
  }
  workspaceFolder.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  return workspaceFolder;
}
var foldingRange = {};
var hasRequiredFoldingRange;
function requireFoldingRange() {
  if (hasRequiredFoldingRange)
    return foldingRange;
  hasRequiredFoldingRange = 1;
  Object.defineProperty(foldingRange, "__esModule", { value: true });
  foldingRange.FoldingRangeFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class FoldingRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
      let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "foldingRange");
      capability.dynamicRegistration = true;
      capability.rangeLimit = 5e3;
      capability.lineFoldingOnly = true;
      capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
      capability.foldingRange = { collapsedText: false };
    }
    initialize(capabilities, documentSelector) {
      let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideFoldingRanges: (document2, context, token) => {
          const client2 = this._client;
          const provideFoldingRanges = (document3, _, token2) => {
            const requestParams = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3)
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asFoldingRanges(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
        }
      };
      return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  }
  foldingRange.FoldingRangeFeature = FoldingRangeFeature;
  return foldingRange;
}
var declaration = {};
var hasRequiredDeclaration;
function requireDeclaration() {
  if (hasRequiredDeclaration)
    return declaration;
  hasRequiredDeclaration = 1;
  Object.defineProperty(declaration, "__esModule", { value: true });
  declaration.DeclarationFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class DeclarationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "declaration");
      declarationSupport.dynamicRegistration = true;
      declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
      const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideDeclaration: (document2, position, token) => {
          const client2 = this._client;
          const provideDeclaration = (document3, position2, token2) => {
            return client2.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asDeclarationResult(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  declaration.DeclarationFeature = DeclarationFeature;
  return declaration;
}
var selectionRange = {};
var hasRequiredSelectionRange;
function requireSelectionRange() {
  if (hasRequiredSelectionRange)
    return selectionRange;
  hasRequiredSelectionRange = 1;
  Object.defineProperty(selectionRange, "__esModule", { value: true });
  selectionRange.SelectionRangeFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class SelectionRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "selectionRange");
      capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideSelectionRanges: (document2, positions, token) => {
          const client2 = this._client;
          const provideSelectionRanges2 = async (document3, positions2, token2) => {
            const requestParams = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              positions: await client2.code2ProtocolConverter.asPositions(positions2, token2)
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token2).then((ranges) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asSelectionRanges(ranges, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions, token, provideSelectionRanges2) : provideSelectionRanges2(document2, positions, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  selectionRange.SelectionRangeFeature = SelectionRangeFeature;
  return selectionRange;
}
var progress = {};
var hasRequiredProgress;
function requireProgress() {
  if (hasRequiredProgress)
    return progress;
  hasRequiredProgress = 1;
  Object.defineProperty(progress, "__esModule", { value: true });
  progress.ProgressFeature = void 0;
  const vscode_languageserver_protocol_1 = requireMain();
  const progressPart_1 = requireProgressPart();
  function ensure(target, key) {
    if (target[key] === void 0) {
      target[key] = /* @__PURE__ */ Object.create(null);
    }
    return target[key];
  }
  class ProgressFeature {
    constructor(_client) {
      this._client = _client;
      this.activeParts = /* @__PURE__ */ new Set();
    }
    getState() {
      return { kind: "window", id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
    }
    fillClientCapabilities(capabilities) {
      ensure(capabilities, "window").workDoneProgress = true;
    }
    initialize() {
      const client2 = this._client;
      const deleteHandler = (part) => {
        this.activeParts.delete(part);
      };
      const createHandler = (params) => {
        this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
      };
      client2.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
    }
    dispose() {
      for (const part of this.activeParts) {
        part.done();
      }
      this.activeParts.clear();
    }
  }
  progress.ProgressFeature = ProgressFeature;
  return progress;
}
var callHierarchy = {};
var hasRequiredCallHierarchy;
function requireCallHierarchy() {
  if (hasRequiredCallHierarchy)
    return callHierarchy;
  hasRequiredCallHierarchy = 1;
  Object.defineProperty(callHierarchy, "__esModule", { value: true });
  callHierarchy.CallHierarchyFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class CallHierarchyProvider {
    constructor(client2) {
      this.client = client2;
      this.middleware = client2.middleware;
    }
    prepareCallHierarchy(document2, position, token) {
      const client2 = this.client;
      const middleware = this.middleware;
      const prepareCallHierarchy = (document3, position2, token2) => {
        const params = client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
        return client2.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token2).then((result) => {
          if (token2.isCancellationRequested) {
            return null;
          }
          return client2.protocol2CodeConverter.asCallHierarchyItems(result, token2);
        }, (error) => {
          return client2.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token2, error, null);
        });
      };
      return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
    }
    provideCallHierarchyIncomingCalls(item, token) {
      const client2 = this.client;
      const middleware = this.middleware;
      const provideCallHierarchyIncomingCalls = (item2, token2) => {
        const params = {
          item: client2.code2ProtocolConverter.asCallHierarchyItem(item2)
        };
        return client2.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token2).then((result) => {
          if (token2.isCancellationRequested) {
            return null;
          }
          return client2.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token2);
        }, (error) => {
          return client2.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token2, error, null);
        });
      };
      return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
    }
    provideCallHierarchyOutgoingCalls(item, token) {
      const client2 = this.client;
      const middleware = this.middleware;
      const provideCallHierarchyOutgoingCalls = (item2, token2) => {
        const params = {
          item: client2.code2ProtocolConverter.asCallHierarchyItem(item2)
        };
        return client2.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token2).then((result) => {
          if (token2.isCancellationRequested) {
            return null;
          }
          return client2.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token2);
        }, (error) => {
          return client2.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token2, error, null);
        });
      };
      return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
    }
  }
  class CallHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(cap) {
      const capabilities = cap;
      const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "callHierarchy");
      capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const client2 = this._client;
      const provider = new CallHierarchyProvider(client2);
      return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
  }
  callHierarchy.CallHierarchyFeature = CallHierarchyFeature;
  return callHierarchy;
}
var semanticTokens = {};
var hasRequiredSemanticTokens;
function requireSemanticTokens() {
  if (hasRequiredSemanticTokens)
    return semanticTokens;
  hasRequiredSemanticTokens = 1;
  Object.defineProperty(semanticTokens, "__esModule", { value: true });
  semanticTokens.SemanticTokensFeature = void 0;
  const vscode = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  const Is2 = requireIs();
  class SemanticTokensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
    }
    fillClientCapabilities(capabilities) {
      const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "semanticTokens");
      capability.dynamicRegistration = true;
      capability.tokenTypes = [
        vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
        vscode_languageserver_protocol_1.SemanticTokenTypes.type,
        vscode_languageserver_protocol_1.SemanticTokenTypes.class,
        vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
        vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
        vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
        vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
        vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
        vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
        vscode_languageserver_protocol_1.SemanticTokenTypes.property,
        vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
        vscode_languageserver_protocol_1.SemanticTokenTypes.event,
        vscode_languageserver_protocol_1.SemanticTokenTypes.function,
        vscode_languageserver_protocol_1.SemanticTokenTypes.method,
        vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
        vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
        vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
        vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
        vscode_languageserver_protocol_1.SemanticTokenTypes.string,
        vscode_languageserver_protocol_1.SemanticTokenTypes.number,
        vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
        vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
        vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
      ];
      capability.tokenModifiers = [
        vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
        vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
      ];
      capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
      capability.requests = {
        range: true,
        full: {
          delta: true
        }
      };
      capability.multilineTokenSupport = false;
      capability.overlappingTokenSupport = false;
      capability.serverCancelSupport = true;
      capability.augmentsSyntaxTokens = true;
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
      const client2 = this._client;
      client2.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
        for (const provider of this.getAllProviders()) {
          provider.onDidChangeSemanticTokensEmitter.fire();
        }
      });
      const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const fullProvider = Is2.boolean(options.full) ? options.full : options.full !== void 0;
      const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
      const eventEmitter = new vscode.EventEmitter();
      const documentProvider = fullProvider ? {
        onDidChangeSemanticTokens: eventEmitter.event,
        provideDocumentSemanticTokens: (document2, token) => {
          const client3 = this._client;
          const middleware = client3.middleware;
          const provideDocumentSemanticTokens = (document3, token2) => {
            const params = {
              textDocument: client3.code2ProtocolConverter.asTextDocumentIdentifier(document3)
            };
            return client3.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client3.protocol2CodeConverter.asSemanticTokens(result, token2);
            }, (error) => {
              return client3.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token2, error, null);
            });
          };
          return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
        },
        provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
          const client3 = this._client;
          const middleware = client3.middleware;
          const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
            const params = {
              textDocument: client3.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              previousResultId: previousResultId2
            };
            return client3.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token2).then(async (result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                return await client3.protocol2CodeConverter.asSemanticTokens(result, token2);
              } else {
                return await client3.protocol2CodeConverter.asSemanticTokensEdits(result, token2);
              }
            }, (error) => {
              return client3.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token2, error, null);
            });
          };
          return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
        } : void 0
      } : void 0;
      const hasRangeProvider = options.range === true;
      const rangeProvider = hasRangeProvider ? {
        provideDocumentRangeSemanticTokens: (document2, range, token) => {
          const client3 = this._client;
          const middleware = client3.middleware;
          const provideDocumentRangeSemanticTokens = (document3, range2, token2) => {
            const params = {
              textDocument: client3.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              range: client3.code2ProtocolConverter.asRange(range2)
            };
            return client3.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client3.protocol2CodeConverter.asSemanticTokens(result, token2);
            }, (error) => {
              return client3.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token2, error, null);
            });
          };
          return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range, token);
        }
      } : void 0;
      const disposables = [];
      const client2 = this._client;
      const legend = client2.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
      const documentSelector = client2.protocol2CodeConverter.asDocumentSelector(selector);
      if (documentProvider !== void 0) {
        disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend));
      }
      if (rangeProvider !== void 0) {
        disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend));
      }
      return [new vscode.Disposable(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
    }
  }
  semanticTokens.SemanticTokensFeature = SemanticTokensFeature;
  return semanticTokens;
}
var fileOperations = {};
var hasRequiredFileOperations;
function requireFileOperations() {
  if (hasRequiredFileOperations)
    return fileOperations;
  hasRequiredFileOperations = 1;
  Object.defineProperty(fileOperations, "__esModule", { value: true });
  fileOperations.WillDeleteFilesFeature = fileOperations.WillRenameFilesFeature = fileOperations.WillCreateFilesFeature = fileOperations.DidDeleteFilesFeature = fileOperations.DidRenameFilesFeature = fileOperations.DidCreateFilesFeature = void 0;
  const code = require$$0;
  const minimatch = requireMinimatch();
  const proto = requireMain();
  const UUID = requireUuid();
  function ensure(target, key) {
    if (target[key] === void 0) {
      target[key] = {};
    }
    return target[key];
  }
  function access(target, key) {
    return target[key];
  }
  function assign(target, key, value) {
    target[key] = value;
  }
  class FileOperationFeature {
    constructor(client2, event, registrationType, clientCapability, serverCapability) {
      this._client = client2;
      this._event = event;
      this._registrationType = registrationType;
      this._clientCapability = clientCapability;
      this._serverCapability = serverCapability;
      this._filters = /* @__PURE__ */ new Map();
    }
    getState() {
      return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
    }
    filterSize() {
      return this._filters.size;
    }
    get registrationType() {
      return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
      const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
      assign(value, "dynamicRegistration", true);
      assign(value, this._clientCapability, true);
    }
    initialize(capabilities) {
      var _a3;
      const options = (_a3 = capabilities.workspace) == null ? void 0 : _a3.fileOperations;
      const capability = options !== void 0 ? access(options, this._serverCapability) : void 0;
      if ((capability == null ? void 0 : capability.filters) !== void 0) {
        try {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { filters: capability.filters }
          });
        } catch (e) {
          this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
        }
      }
    }
    register(data) {
      if (!this._listener) {
        this._listener = this._event(this.send, this);
      }
      const minimatchFilter = data.registerOptions.filters.map((filter) => {
        const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
        if (!matcher.makeRe()) {
          throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
        }
        return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
      });
      this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
      this._filters.delete(id);
      if (this._filters.size === 0 && this._listener) {
        this._listener.dispose();
        this._listener = void 0;
      }
    }
    dispose() {
      this._filters.clear();
      if (this._listener) {
        this._listener.dispose();
        this._listener = void 0;
      }
    }
    getFileType(uri) {
      return FileOperationFeature.getFileType(uri);
    }
    async filter(event, prop) {
      const fileMatches = await Promise.all(event.files.map(async (item) => {
        const uri = prop(item);
        const path2 = uri.fsPath.replace(/\\/g, "/");
        for (const filters of this._filters.values()) {
          for (const filter of filters) {
            if (filter.scheme !== void 0 && filter.scheme !== uri.scheme) {
              continue;
            }
            if (filter.matcher.match(path2)) {
              if (filter.kind === void 0) {
                return true;
              }
              const fileType = await this.getFileType(uri);
              if (fileType === void 0) {
                this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                return true;
              }
              if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) {
                return true;
              }
            } else if (filter.kind === proto.FileOperationPatternKind.folder) {
              const fileType = await FileOperationFeature.getFileType(uri);
              if (fileType === code.FileType.Directory && filter.matcher.match(`${path2}/`)) {
                return true;
              }
            }
          }
        }
        return false;
      }));
      const files = event.files.filter((_, index2) => fileMatches[index2]);
      return { ...event, files };
    }
    static async getFileType(uri) {
      try {
        return (await code.workspace.fs.stat(uri)).type;
      } catch (e) {
        return void 0;
      }
    }
    static asMinimatchOptions(options) {
      if (options === void 0) {
        return void 0;
      }
      if (options.ignoreCase === true) {
        return { nocase: true };
      }
      return void 0;
    }
  }
  class NotificationFileOperationFeature extends FileOperationFeature {
    constructor(client2, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
      super(client2, event, notificationType, clientCapability, serverCapability);
      this._notificationType = notificationType;
      this._accessUri = accessUri;
      this._createParams = createParams;
    }
    async send(originalEvent) {
      const filteredEvent = await this.filter(originalEvent, this._accessUri);
      if (filteredEvent.files.length) {
        const next = async (event) => {
          return this._client.sendNotification(this._notificationType, this._createParams(event));
        };
        return this.doSend(filteredEvent, next);
      }
    }
  }
  class CachingNotificationFileOperationFeature extends NotificationFileOperationFeature {
    constructor() {
      super(...arguments);
      this._fsPathFileTypes = /* @__PURE__ */ new Map();
    }
    async getFileType(uri) {
      const fsPath = uri.fsPath;
      if (this._fsPathFileTypes.has(fsPath)) {
        return this._fsPathFileTypes.get(fsPath);
      }
      const type = await FileOperationFeature.getFileType(uri);
      if (type) {
        this._fsPathFileTypes.set(fsPath, type);
      }
      return type;
    }
    async cacheFileTypes(event, prop) {
      await this.filter(event, prop);
    }
    clearFileTypeCache() {
      this._fsPathFileTypes.clear();
    }
    unregister(id) {
      super.unregister(id);
      if (this.filterSize() === 0 && this._willListener) {
        this._willListener.dispose();
        this._willListener = void 0;
      }
    }
    dispose() {
      super.dispose();
      if (this._willListener) {
        this._willListener.dispose();
        this._willListener = void 0;
      }
    }
  }
  class DidCreateFilesFeature extends NotificationFileOperationFeature {
    constructor(client2) {
      super(client2, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, client2.code2ProtocolConverter.asDidCreateFilesParams);
    }
    doSend(event, next) {
      const middleware = this._client.middleware.workspace;
      return (middleware == null ? void 0 : middleware.didCreateFiles) ? middleware.didCreateFiles(event, next) : next(event);
    }
  }
  fileOperations.DidCreateFilesFeature = DidCreateFilesFeature;
  class DidRenameFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client2) {
      super(client2, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, client2.code2ProtocolConverter.asDidRenameFilesParams);
    }
    register(data) {
      if (!this._willListener) {
        this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
      }
      super.register(data);
    }
    willRename(e) {
      e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
    }
    doSend(event, next) {
      this.clearFileTypeCache();
      const middleware = this._client.middleware.workspace;
      return (middleware == null ? void 0 : middleware.didRenameFiles) ? middleware.didRenameFiles(event, next) : next(event);
    }
  }
  fileOperations.DidRenameFilesFeature = DidRenameFilesFeature;
  class DidDeleteFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client2) {
      super(client2, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, client2.code2ProtocolConverter.asDidDeleteFilesParams);
    }
    register(data) {
      if (!this._willListener) {
        this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
      }
      super.register(data);
    }
    willDelete(e) {
      e.waitUntil(this.cacheFileTypes(e, (i) => i));
    }
    doSend(event, next) {
      this.clearFileTypeCache();
      const middleware = this._client.middleware.workspace;
      return (middleware == null ? void 0 : middleware.didDeleteFiles) ? middleware.didDeleteFiles(event, next) : next(event);
    }
  }
  fileOperations.DidDeleteFilesFeature = DidDeleteFilesFeature;
  class RequestFileOperationFeature extends FileOperationFeature {
    constructor(client2, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
      super(client2, event, requestType, clientCapability, serverCapability);
      this._requestType = requestType;
      this._accessUri = accessUri;
      this._createParams = createParams;
    }
    async send(originalEvent) {
      const waitUntil = this.waitUntil(originalEvent);
      originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
      const filteredEvent = await this.filter(originalEvent, this._accessUri);
      if (filteredEvent.files.length) {
        const next = (event) => {
          return this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit);
        };
        return this.doSend(filteredEvent, next);
      } else {
        return void 0;
      }
    }
  }
  class WillCreateFilesFeature extends RequestFileOperationFeature {
    constructor(client2) {
      super(client2, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, client2.code2ProtocolConverter.asWillCreateFilesParams);
    }
    doSend(event, next) {
      const middleware = this._client.middleware.workspace;
      return (middleware == null ? void 0 : middleware.willCreateFiles) ? middleware.willCreateFiles(event, next) : next(event);
    }
  }
  fileOperations.WillCreateFilesFeature = WillCreateFilesFeature;
  class WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client2) {
      super(client2, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, client2.code2ProtocolConverter.asWillRenameFilesParams);
    }
    doSend(event, next) {
      const middleware = this._client.middleware.workspace;
      return (middleware == null ? void 0 : middleware.willRenameFiles) ? middleware.willRenameFiles(event, next) : next(event);
    }
  }
  fileOperations.WillRenameFilesFeature = WillRenameFilesFeature;
  class WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client2) {
      super(client2, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, client2.code2ProtocolConverter.asWillDeleteFilesParams);
    }
    doSend(event, next) {
      const middleware = this._client.middleware.workspace;
      return (middleware == null ? void 0 : middleware.willDeleteFiles) ? middleware.willDeleteFiles(event, next) : next(event);
    }
  }
  fileOperations.WillDeleteFilesFeature = WillDeleteFilesFeature;
  return fileOperations;
}
var linkedEditingRange = {};
var hasRequiredLinkedEditingRange;
function requireLinkedEditingRange() {
  if (hasRequiredLinkedEditingRange)
    return linkedEditingRange;
  hasRequiredLinkedEditingRange = 1;
  Object.defineProperty(linkedEditingRange, "__esModule", { value: true });
  linkedEditingRange.LinkedEditingFeature = void 0;
  const code = require$$0;
  const proto = requireMain();
  const features_1 = requireFeatures();
  class LinkedEditingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, proto.LinkedEditingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "linkedEditingRange");
      linkedEditingSupport.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const provider = {
        provideLinkedEditingRanges: (document2, position, token) => {
          const client2 = this._client;
          const provideLinkedEditing = (document3, position2, token2) => {
            return client2.sendRequest(proto.LinkedEditingRangeRequest.type, client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asLinkedEditingRanges(result, token2);
            }, (error) => {
              return client2.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document2, position, token, provideLinkedEditing) : provideLinkedEditing(document2, position, token);
        }
      };
      return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
      return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  linkedEditingRange.LinkedEditingFeature = LinkedEditingFeature;
  return linkedEditingRange;
}
var typeHierarchy = {};
var hasRequiredTypeHierarchy;
function requireTypeHierarchy() {
  if (hasRequiredTypeHierarchy)
    return typeHierarchy;
  hasRequiredTypeHierarchy = 1;
  Object.defineProperty(typeHierarchy, "__esModule", { value: true });
  typeHierarchy.TypeHierarchyFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class TypeHierarchyProvider {
    constructor(client2) {
      this.client = client2;
      this.middleware = client2.middleware;
    }
    prepareTypeHierarchy(document2, position, token) {
      const client2 = this.client;
      const middleware = this.middleware;
      const prepareTypeHierarchy = (document3, position2, token2) => {
        const params = client2.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
        return client2.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token2).then((result) => {
          if (token2.isCancellationRequested) {
            return null;
          }
          return client2.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
        }, (error) => {
          return client2.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token2, error, null);
        });
      };
      return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document2, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document2, position, token);
    }
    provideTypeHierarchySupertypes(item, token) {
      const client2 = this.client;
      const middleware = this.middleware;
      const provideTypeHierarchySupertypes = (item2, token2) => {
        const params = {
          item: client2.code2ProtocolConverter.asTypeHierarchyItem(item2)
        };
        return client2.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token2).then((result) => {
          if (token2.isCancellationRequested) {
            return null;
          }
          return client2.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
        }, (error) => {
          return client2.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token2, error, null);
        });
      };
      return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
    }
    provideTypeHierarchySubtypes(item, token) {
      const client2 = this.client;
      const middleware = this.middleware;
      const provideTypeHierarchySubtypes = (item2, token2) => {
        const params = {
          item: client2.code2ProtocolConverter.asTypeHierarchyItem(item2)
        };
        return client2.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token2).then((result) => {
          if (token2.isCancellationRequested) {
            return null;
          }
          return client2.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
        }, (error) => {
          return client2.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token2, error, null);
        });
      };
      return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
    }
  }
  class TypeHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeHierarchy");
      capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
      const [id, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const client2 = this._client;
      const provider = new TypeHierarchyProvider(client2);
      return [vscode_1.languages.registerTypeHierarchyProvider(client2.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
  }
  typeHierarchy.TypeHierarchyFeature = TypeHierarchyFeature;
  return typeHierarchy;
}
var inlineValue = {};
var hasRequiredInlineValue;
function requireInlineValue() {
  if (hasRequiredInlineValue)
    return inlineValue;
  hasRequiredInlineValue = 1;
  Object.defineProperty(inlineValue, "__esModule", { value: true });
  inlineValue.InlineValueFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class InlineValueFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.InlineValueRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlineValue").refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
      this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
        for (const provider of this.getAllProviders()) {
          provider.onDidChangeInlineValues.fire();
        }
      });
      const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const eventEmitter = new vscode_1.EventEmitter();
      const provider = {
        onDidChangeInlineValues: eventEmitter.event,
        provideInlineValues: (document2, viewPort, context, token) => {
          const client2 = this._client;
          const provideInlineValues = (document3, viewPort2, context2, token2) => {
            const requestParams = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              range: client2.code2ProtocolConverter.asRange(viewPort2),
              context: client2.code2ProtocolConverter.asInlineValueContext(context2)
            };
            return client2.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token2).then((values) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asInlineValues(values, token2);
            }, (error) => {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token2, error, null);
            });
          };
          const middleware = client2.middleware;
          return middleware.provideInlineValues ? middleware.provideInlineValues(document2, viewPort, context, token, provideInlineValues) : provideInlineValues(document2, viewPort, context, token);
        }
      };
      return [this.registerProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  inlineValue.InlineValueFeature = InlineValueFeature;
  return inlineValue;
}
var inlayHint = {};
var hasRequiredInlayHint;
function requireInlayHint() {
  if (hasRequiredInlayHint)
    return inlayHint;
  hasRequiredInlayHint = 1;
  Object.defineProperty(inlayHint, "__esModule", { value: true });
  inlayHint.InlayHintsFeature = void 0;
  const vscode_1 = require$$0;
  const vscode_languageserver_protocol_1 = requireMain();
  const features_1 = requireFeatures();
  class InlayHintsFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client2) {
      super(client2, vscode_languageserver_protocol_1.InlayHintRequest.type);
    }
    fillClientCapabilities(capabilities) {
      const inlayHint2 = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlayHint");
      inlayHint2.dynamicRegistration = true;
      inlayHint2.resolveSupport = {
        properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
      };
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlayHint").refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
      this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
        for (const provider of this.getAllProviders()) {
          provider.onDidChangeInlayHints.fire();
        }
      });
      const [id, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
      if (!id || !options) {
        return;
      }
      this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
      const selector = options.documentSelector;
      const eventEmitter = new vscode_1.EventEmitter();
      const provider = {
        onDidChangeInlayHints: eventEmitter.event,
        provideInlayHints: (document2, viewPort, token) => {
          const client2 = this._client;
          const provideInlayHints = async (document3, viewPort2, token2) => {
            const requestParams = {
              textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
              range: client2.code2ProtocolConverter.asRange(viewPort2)
            };
            try {
              const values = await client2.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token2);
              if (token2.isCancellationRequested) {
                return null;
              }
              return client2.protocol2CodeConverter.asInlayHints(values, token2);
            } catch (error) {
              return client2.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token2, error, null);
            }
          };
          const middleware = client2.middleware;
          return middleware.provideInlayHints ? middleware.provideInlayHints(document2, viewPort, token, provideInlayHints) : provideInlayHints(document2, viewPort, token);
        }
      };
      provider.resolveInlayHint = options.resolveProvider === true ? (hint, token) => {
        const client2 = this._client;
        const resolveInlayHint = async (item, token2) => {
          try {
            const value = await client2.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client2.code2ProtocolConverter.asInlayHint(item), token2);
            if (token2.isCancellationRequested) {
              return null;
            }
            const result = client2.protocol2CodeConverter.asInlayHint(value, token2);
            return token2.isCancellationRequested ? null : result;
          } catch (error) {
            return client2.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token2, error, null);
          }
        };
        const middleware = client2.middleware;
        return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
      } : void 0;
      return [this.registerProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
    }
    registerProvider(selector, provider) {
      return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
  }
  inlayHint.InlayHintsFeature = InlayHintsFeature;
  return inlayHint;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient)
    return client;
  hasRequiredClient = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProposedFeatures = exports.BaseLanguageClient = exports.MessageTransports = exports.SuspendMode = exports.State = exports.CloseAction = exports.ErrorAction = exports.RevealOutputChannelOn = void 0;
    const vscode_1 = require$$0;
    const vscode_languageserver_protocol_1 = requireMain();
    const c2p = requireCodeConverter();
    const p2c = requireProtocolConverter();
    const Is2 = requireIs();
    const async_1 = requireAsync();
    const UUID = requireUuid();
    const progressPart_1 = requireProgressPart();
    const features_1 = requireFeatures();
    const diagnostic_1 = requireDiagnostic();
    const notebook_1 = requireNotebook();
    const configuration_1 = requireConfiguration();
    const textSynchronization_1 = requireTextSynchronization();
    const completion_1 = requireCompletion();
    const hover_1 = requireHover();
    const definition_1 = requireDefinition();
    const signatureHelp_1 = requireSignatureHelp();
    const documentHighlight_1 = requireDocumentHighlight();
    const documentSymbol_1 = requireDocumentSymbol();
    const workspaceSymbol_1 = requireWorkspaceSymbol();
    const reference_1 = requireReference();
    const codeAction_1 = requireCodeAction();
    const codeLens_1 = requireCodeLens();
    const formatting_1 = requireFormatting();
    const rename_1 = requireRename();
    const documentLink_1 = requireDocumentLink();
    const executeCommand_1 = requireExecuteCommand();
    const fileSystemWatcher_1 = requireFileSystemWatcher();
    const colorProvider_1 = requireColorProvider();
    const implementation_1 = requireImplementation();
    const typeDefinition_1 = requireTypeDefinition();
    const workspaceFolder_1 = requireWorkspaceFolder();
    const foldingRange_1 = requireFoldingRange();
    const declaration_1 = requireDeclaration();
    const selectionRange_1 = requireSelectionRange();
    const progress_1 = requireProgress();
    const callHierarchy_1 = requireCallHierarchy();
    const semanticTokens_1 = requireSemanticTokens();
    const fileOperations_1 = requireFileOperations();
    const linkedEditingRange_1 = requireLinkedEditingRange();
    const typeHierarchy_1 = requireTypeHierarchy();
    const inlineValue_1 = requireInlineValue();
    const inlayHint_1 = requireInlayHint();
    var RevealOutputChannelOn;
    (function(RevealOutputChannelOn2) {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
    })(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
    var ErrorAction;
    (function(ErrorAction2) {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
    })(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
    var CloseAction;
    (function(CloseAction2) {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
    })(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
    var State;
    (function(State2) {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Starting"] = 3] = "Starting";
      State2[State2["Running"] = 2] = "Running";
    })(State = exports.State || (exports.State = {}));
    (function(SuspendMode) {
      SuspendMode["off"] = "off";
      SuspendMode["on"] = "on";
    })(exports.SuspendMode || (exports.SuspendMode = {}));
    class DefaultErrorHandler {
      constructor(client2, maxRestartCount) {
        this.client = client2;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return { action: ErrorAction.Continue };
        }
        return { action: ErrorAction.Shutdown };
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
          return { action: CloseAction.Restart };
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            return { action: CloseAction.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
          } else {
            this.restarts.shift();
            return { action: CloseAction.Restart };
          }
        }
      }
    }
    var ClientState;
    (function(ClientState2) {
      ClientState2["Initial"] = "initial";
      ClientState2["Starting"] = "starting";
      ClientState2["StartFailed"] = "startFailed";
      ClientState2["Running"] = "running";
      ClientState2["Stopping"] = "stopping";
      ClientState2["Stopped"] = "stopped";
    })(ClientState || (ClientState = {}));
    (function(MessageTransports) {
      function is2(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
      }
      MessageTransports.is = is2;
    })(exports.MessageTransports || (exports.MessageTransports = {}));
    class BaseLanguageClient {
      constructor(id, name, clientOptions) {
        var _a3;
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._diagnosticQueue = /* @__PURE__ */ new Map();
        this._diagnosticQueueState = { state: "idle" };
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this.workspaceEditLock = new async_1.Semaphore(1);
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown !== void 0) {
          markdown.isTrusted = clientOptions.markdown.isTrusted === true;
          markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        this._clientOptions = {
          documentSelector: clientOptions.documentSelector ?? [],
          synchronize: clientOptions.synchronize ?? {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName ?? this._name,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
          stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: !!clientOptions.progressOnInitialization,
          errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler((_a3 = clientOptions.connectionOptions) == null ? void 0 : _a3.maxRestartCount),
          middleware: clientOptions.middleware ?? {},
          uriConverters: clientOptions.uriConverters,
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown,
          // suspend: {
          // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
          // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
          // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
          // },
          diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
          notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._ignoredRegistrations = /* @__PURE__ */ new Set();
        this._listeners = [];
        this._notificationHandlers = /* @__PURE__ */ new Map();
        this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
        this._notificationDisposables = /* @__PURE__ */ new Map();
        this._requestHandlers = /* @__PURE__ */ new Map();
        this._pendingRequestHandlers = /* @__PURE__ */ new Map();
        this._requestDisposables = /* @__PURE__ */ new Map();
        this._progressHandlers = /* @__PURE__ */ new Map();
        this._pendingProgressHandlers = /* @__PURE__ */ new Map();
        this._progressDisposables = /* @__PURE__ */ new Map();
        this._connection = void 0;
        this._initializeResult = void 0;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
          this._disposeOutputChannel = false;
        } else {
          this._outputChannel = void 0;
          this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._diagnostics = void 0;
        this._pendingOpenNotifications = /* @__PURE__ */ new Set();
        this._pendingChangeSemaphore = new async_1.Semaphore(1);
        this._pendingChangeDelayer = new async_1.Delayer(250);
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onStop = void 0;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (Is2.string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
      }
      get name() {
        return this._name;
      }
      get middleware() {
        return this._clientOptions.middleware ?? /* @__PURE__ */ Object.create(null);
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get protocol2CodeConverter() {
        return this._p2c;
      }
      get code2ProtocolConverter() {
        return this._c2p;
      }
      get onTelemetry() {
        return this._telemetryEmitter.event;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get traceOutputChannel() {
        if (this._traceOutputChannel) {
          return this._traceOutputChannel;
        }
        return this.outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      get state() {
        return this.getPublicState();
      }
      get $state() {
        return this._state;
      }
      set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      getPublicState() {
        switch (this.$state) {
          case ClientState.Starting:
            return State.Starting;
          case ClientState.Running:
            return State.Running;
          default:
            return State.Stopped;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      async sendRequest(type, ...params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        const connection2 = await this.$start();
        if (this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
          await this.sendPendingFullTextDocumentChanges(connection2);
        }
        return connection2.sendRequest(type, ...params);
      }
      onRequest(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._requestHandlers.set(method, handler);
        const connection2 = this.activeConnection();
        let disposable2;
        if (connection2 !== void 0) {
          this._requestDisposables.set(method, connection2.onRequest(type, handler));
          disposable2 = {
            dispose: () => {
              const disposable3 = this._requestDisposables.get(method);
              if (disposable3 !== void 0) {
                disposable3.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingRequestHandlers.set(method, handler);
          disposable2 = {
            dispose: () => {
              this._pendingRequestHandlers.delete(method);
              const disposable3 = this._requestDisposables.get(method);
              if (disposable3 !== void 0) {
                disposable3.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._requestHandlers.delete(method);
            disposable2.dispose();
          }
        };
      }
      async sendNotification(type, params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        const needsPendingFullTextDocumentSync = this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        let openNotification;
        if (needsPendingFullTextDocumentSync && typeof type !== "string" && type.method === vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method) {
          openNotification = params == null ? void 0 : params.textDocument.uri;
          this._pendingOpenNotifications.add(openNotification);
        }
        const connection2 = await this.$start();
        if (needsPendingFullTextDocumentSync) {
          await this.sendPendingFullTextDocumentChanges(connection2);
        }
        if (openNotification !== void 0) {
          this._pendingOpenNotifications.delete(openNotification);
        }
        return connection2.sendNotification(type, params);
      }
      onNotification(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._notificationHandlers.set(method, handler);
        const connection2 = this.activeConnection();
        let disposable2;
        if (connection2 !== void 0) {
          this._notificationDisposables.set(method, connection2.onNotification(type, handler));
          disposable2 = {
            dispose: () => {
              const disposable3 = this._notificationDisposables.get(method);
              if (disposable3 !== void 0) {
                disposable3.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingNotificationHandlers.set(method, handler);
          disposable2 = {
            dispose: () => {
              this._pendingNotificationHandlers.delete(method);
              const disposable3 = this._notificationDisposables.get(method);
              if (disposable3 !== void 0) {
                disposable3.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._notificationHandlers.delete(method);
            disposable2.dispose();
          }
        };
      }
      async sendProgress(type, token, value) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
          const connection2 = await this.$start();
          return connection2.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      onProgress(type, token, handler) {
        var _a3;
        this._progressHandlers.set(token, { type, handler });
        const connection2 = this.activeConnection();
        let disposable2;
        const handleWorkDoneProgress = (_a3 = this._clientOptions.middleware) == null ? void 0 : _a3.handleWorkDoneProgress;
        const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
          handleWorkDoneProgress(token, params, () => handler(params));
        } : handler;
        if (connection2 !== void 0) {
          this._progressDisposables.set(token, connection2.onProgress(type, token, realHandler));
          disposable2 = {
            dispose: () => {
              const disposable3 = this._progressDisposables.get(token);
              if (disposable3 !== void 0) {
                disposable3.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        } else {
          this._pendingProgressHandlers.set(token, { type, handler });
          disposable2 = {
            dispose: () => {
              this._pendingProgressHandlers.delete(token);
              const disposable3 = this._progressDisposables.get(token);
              if (disposable3 !== void 0) {
                disposable3.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._progressHandlers.delete(token);
            disposable2.dispose();
          }
        };
      }
      createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== void 0 && maxRestartCount < 0) {
          throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this, maxRestartCount ?? 4);
      }
      async setTrace(value) {
        this._trace = value;
        const connection2 = this.activeConnection();
        if (connection2 !== void 0) {
          await connection2.trace(this._trace, this._tracer, {
            sendNotification: false,
            traceFormat: this._traceFormat
          });
        }
      }
      data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (Is2.string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (Is2.string(data)) {
          return data;
        }
        return data.toString();
      }
      info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
          this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
      }
      warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
          this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
      }
      error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
          this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
      }
      showNotificationMessage(type, message) {
        message = message ?? "A request has failed. See the output for more information.";
        const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error ? vscode_1.window.showErrorMessage : type === vscode_languageserver_protocol_1.MessageType.Warning ? vscode_1.window.showWarningMessage : vscode_1.window.showInformationMessage;
        void messageFunc(message, "Go to output").then((selection) => {
          if (selection !== void 0) {
            this.outputChannel.show(true);
          }
        });
      }
      logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data) {
          this.traceOutputChannel.appendLine(this.data2String(data));
        }
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.traceOutputChannel.append(`[LSP   - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
        } else {
          this.traceOutputChannel.append(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
        }
        if (data) {
          this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      needsStart() {
        return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
      }
      needsStop() {
        return this.$state === ClientState.Starting || this.$state === ClientState.Running;
      }
      activeConnection() {
        return this.$state === ClientState.Running && this._connection !== void 0 ? this._connection : void 0;
      }
      isRunning() {
        return this.$state === ClientState.Running;
      }
      async start() {
        if (this._disposed === "disposing" || this._disposed === "disposed") {
          throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === ClientState.Stopping) {
          throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        if (this._onStart !== void 0) {
          return this._onStart;
        }
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        if (this._diagnostics === void 0) {
          this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection();
        }
        for (const [method, handler] of this._notificationHandlers) {
          if (!this._pendingNotificationHandlers.has(method)) {
            this._pendingNotificationHandlers.set(method, handler);
          }
        }
        for (const [method, handler] of this._requestHandlers) {
          if (!this._pendingRequestHandlers.has(method)) {
            this._pendingRequestHandlers.set(method, handler);
          }
        }
        for (const [token, data] of this._progressHandlers) {
          if (!this._pendingProgressHandlers.has(token)) {
            this._pendingProgressHandlers.set(token, data);
          }
        }
        this.$state = ClientState.Starting;
        try {
          const connection2 = await this.createConnection();
          connection2.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                this.error(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                this.warn(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                this.info(message.message, void 0, false);
                break;
              default:
                this.outputChannel.appendLine(message.message);
            }
          });
          connection2.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                void vscode_1.window.showErrorMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                void vscode_1.window.showWarningMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                void vscode_1.window.showInformationMessage(message.message);
                break;
              default:
                void vscode_1.window.showInformationMessage(message.message);
            }
          });
          connection2.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                messageFunc = vscode_1.window.showErrorMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                messageFunc = vscode_1.window.showWarningMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                messageFunc = vscode_1.window.showInformationMessage;
                break;
              default:
                messageFunc = vscode_1.window.showInformationMessage;
            }
            let actions = params.actions || [];
            return messageFunc(params.message, ...actions);
          });
          connection2.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
            this._telemetryEmitter.fire(data);
          });
          connection2.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
            var _a3;
            const showDocument = async (params2) => {
              const uri = this.protocol2CodeConverter.asUri(params2.uri);
              try {
                if (params2.external === true) {
                  const success = await vscode_1.env.openExternal(uri);
                  return { success };
                } else {
                  const options = {};
                  if (params2.selection !== void 0) {
                    options.selection = this.protocol2CodeConverter.asRange(params2.selection);
                  }
                  if (params2.takeFocus === void 0 || params2.takeFocus === false) {
                    options.preserveFocus = true;
                  } else if (params2.takeFocus === true) {
                    options.preserveFocus = false;
                  }
                  await vscode_1.window.showTextDocument(uri, options);
                  return { success: true };
                }
              } catch (error) {
                return { success: false };
              }
            };
            const middleware = (_a3 = this._clientOptions.middleware.window) == null ? void 0 : _a3.showDocument;
            if (middleware !== void 0) {
              return middleware(params, showDocument);
            } else {
              return showDocument(params);
            }
          });
          connection2.listen();
          await this.initialize(connection2);
          resolve();
        } catch (error) {
          this.$state = ClientState.StartFailed;
          this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
          reject(error);
        }
        return this._onStart;
      }
      createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
          resolve = _resolve;
          reject = _reject;
        });
        return [promise, resolve, reject];
      }
      async initialize(connection2) {
        this.refreshTrace(connection2, false);
        const initOption = this._clientOptions.initializationOptions;
        const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== void 0 ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]] : [this._clientGetRootPath(), null];
        const initParams = {
          processId: null,
          clientInfo: {
            name: vscode_1.env.appName,
            version: vscode_1.version
          },
          locale: this.getLocale(),
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: Is2.func(initOption) ? initOption() : initOption,
          trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
          workspaceFolders
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
          const token = UUID.generateUuid();
          const part = new progressPart_1.ProgressPart(connection2, token);
          initParams.workDoneToken = token;
          try {
            const result = await this.doInitialize(connection2, initParams);
            part.done();
            return result;
          } catch (error) {
            part.cancel();
            throw error;
          }
        } else {
          return this.doInitialize(connection2, initParams);
        }
      }
      async doInitialize(connection2, initParams) {
        try {
          const result = await connection2.initialize(initParams);
          if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
            throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
          }
          this._initializeResult = result;
          this.$state = ClientState.Running;
          let textDocumentSyncOptions = void 0;
          if (Is2.number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection2.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
          connection2.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection2.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection2.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection2.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection2.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          for (const [method, handler] of this._pendingNotificationHandlers) {
            this._notificationDisposables.set(method, connection2.onNotification(method, handler));
          }
          this._pendingNotificationHandlers.clear();
          for (const [method, handler] of this._pendingRequestHandlers) {
            this._requestDisposables.set(method, connection2.onRequest(method, handler));
          }
          this._pendingRequestHandlers.clear();
          for (const [token, data] of this._pendingProgressHandlers) {
            this._progressDisposables.set(token, connection2.onProgress(data.type, token, data.handler));
          }
          this._pendingProgressHandlers.clear();
          await connection2.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
          this.hookFileEvents(connection2);
          this.hookConfigurationChanged(connection2);
          this.initializeFeatures(connection2);
          return result;
        } catch (error) {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              void this.initialize(connection2);
            } else {
              void this.stop();
            }
          } else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
            void vscode_1.window.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              if (item && item.id === "retry") {
                void this.initialize(connection2);
              } else {
                void this.stop();
              }
            });
          } else {
            if (error && error.message) {
              void vscode_1.window.showErrorMessage(error.message);
            }
            this.error("Server initialization failed.", error);
            void this.stop();
          }
          throw error;
        }
      }
      _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      stop(timeout2 = 2e3) {
        return this.shutdown("stop", timeout2);
      }
      dispose(timeout2 = 2e3) {
        try {
          this._disposed = "disposing";
          return this.stop(timeout2);
        } finally {
          this._disposed = "disposed";
        }
      }
      async shutdown(mode, timeout2) {
        if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
          return;
        }
        if (this.$state === ClientState.Stopping) {
          if (this._onStop !== void 0) {
            return this._onStop;
          } else {
            throw new Error(`Client is stopping but no stop promise available.`);
          }
        }
        const connection2 = this.activeConnection();
        if (connection2 === void 0 || this.$state !== ClientState.Running) {
          throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = void 0;
        this.$state = ClientState.Stopping;
        this.cleanUp(mode);
        const tp = new Promise((c) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout2);
        });
        const shutdown = (async (connection3) => {
          await connection3.shutdown();
          await connection3.exit();
          return connection3;
        })(connection2);
        return this._onStop = Promise.race([tp, shutdown]).then((connection3) => {
          if (connection3 !== void 0) {
            connection3.end();
            connection3.dispose();
          } else {
            this.error(`Stopping server timed out`, void 0, false);
            throw new Error(`Stopping the server timed out`);
          }
        }, (error) => {
          this.error(`Stopping server failed`, error, false);
          throw error;
        }).finally(() => {
          this.$state = ClientState.Stopped;
          mode === "stop" && this.cleanUpChannel();
          this._onStart = void 0;
          this._onStop = void 0;
          this._connection = void 0;
          this._ignoredRegistrations.clear();
        });
      }
      cleanUp(mode) {
        this._fileEvents = [];
        this._fileEventDelayer.cancel();
        const disposables = this._listeners.splice(0, this._listeners.length);
        for (const disposable2 of disposables) {
          disposable2.dispose();
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (const feature of Array.from(this._features.entries()).map((entry) => entry[1]).reverse()) {
          feature.dispose();
        }
        if (mode === "stop" && this._diagnostics !== void 0) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
        if (this._idleInterval !== void 0) {
          this._idleInterval.dispose();
          this._idleInterval = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel !== void 0 && this._disposeOutputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      notifyFileEvent(event) {
        var _a3;
        const client2 = this;
        async function didChangeWatchedFile(event2) {
          client2._fileEvents.push(event2);
          return client2._fileEventDelayer.trigger(async () => {
            await client2.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client2._fileEvents });
            client2._fileEvents = [];
          });
        }
        const workSpaceMiddleware = (_a3 = this.clientOptions.middleware) == null ? void 0 : _a3.workspace;
        ((workSpaceMiddleware == null ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
          client2.error(`Notify file events failed.`, error);
        });
      }
      async sendPendingFullTextDocumentChanges(connection2) {
        return this._pendingChangeSemaphore.lock(async () => {
          try {
            const changes = this._didChangeTextDocumentFeature.getPendingDocumentChanges(this._pendingOpenNotifications);
            if (changes.length === 0) {
              return;
            }
            for (const document2 of changes) {
              const params = this.code2ProtocolConverter.asChangeTextDocumentParams(document2);
              await connection2.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              this._didChangeTextDocumentFeature.notificationSent(document2, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
            }
          } catch (error) {
            this.error(`Sending pending changes failed`, error, false);
            throw error;
          }
        });
      }
      triggerPendingChangeDelivery() {
        this._pendingChangeDelayer.trigger(async () => {
          const connection2 = this.activeConnection();
          if (connection2 === void 0) {
            this.triggerPendingChangeDelivery();
            return;
          }
          await this.sendPendingFullTextDocumentChanges(connection2);
        }).catch((error) => this.error(`Delivering pending changes failed`, error, false));
      }
      handleDiagnostics(params) {
        if (!this._diagnostics) {
          return;
        }
        const key = params.uri;
        if (this._diagnosticQueueState.state === "busy" && this._diagnosticQueueState.document === key) {
          this._diagnosticQueueState.tokenSource.cancel();
        }
        this._diagnosticQueue.set(params.uri, params.diagnostics);
        this.triggerDiagnosticQueue();
      }
      triggerDiagnosticQueue() {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
          this.workDiagnosticQueue();
        });
      }
      workDiagnosticQueue() {
        if (this._diagnosticQueueState.state === "busy") {
          return;
        }
        const next = this._diagnosticQueue.entries().next();
        if (next.done === true) {
          return;
        }
        const [document2, diagnostics] = next.value;
        this._diagnosticQueue.delete(document2);
        const tokenSource = new vscode_1.CancellationTokenSource();
        this._diagnosticQueueState = { state: "busy", document: document2, tokenSource };
        this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
          if (!tokenSource.token.isCancellationRequested) {
            const uri = this._p2c.asUri(document2);
            const middleware = this.clientOptions.middleware;
            if (middleware.handleDiagnostics) {
              middleware.handleDiagnostics(uri, converted, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
            } else {
              this.setDiagnostics(uri, converted);
            }
          }
        }).finally(() => {
          this._diagnosticQueueState = { state: "idle" };
          this.triggerDiagnosticQueue();
        });
      }
      setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
          return;
        }
        this._diagnostics.set(uri, diagnostics);
      }
      getLocale() {
        return vscode_1.env.language;
      }
      async $start() {
        if (this.$state === ClientState.StartFailed) {
          throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this.start();
        const connection2 = this.activeConnection();
        if (connection2 === void 0) {
          throw new Error(`Starting server failed`);
        }
        return connection2;
      }
      async createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count).catch((error2) => this.error(`Handling connection error failed`, error2));
        };
        let closeHandler = () => {
          this.handleConnectionClosed().catch((error) => this.error(`Handling connection close failed`, error));
        };
        const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8");
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
      }
      async handleConnectionClosed() {
        if (this.$state === ClientState.Stopped) {
          return;
        }
        try {
          if (this._connection !== void 0) {
            this._connection.dispose();
          }
        } catch (error) {
        }
        let handlerResult = { action: CloseAction.DoNotRestart };
        if (this.$state !== ClientState.Stopping) {
          try {
            handlerResult = await this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connection = void 0;
        if (handlerResult.action === CloseAction.DoNotRestart) {
          this.error(handlerResult.message ?? "Connection to server got closed. Server will not be restarted.", void 0, handlerResult.handled === true ? false : "force");
          this.cleanUp("stop");
          if (this.$state === ClientState.Starting) {
            this.$state = ClientState.StartFailed;
          } else {
            this.$state = ClientState.Stopped;
          }
          this._onStop = Promise.resolve();
          this._onStart = void 0;
        } else if (handlerResult.action === CloseAction.Restart) {
          this.info(handlerResult.message ?? "Connection to server got closed. Server will restart.", !handlerResult.handled);
          this.cleanUp("restart");
          this.$state = ClientState.Initial;
          this._onStop = Promise.resolve();
          this._onStart = void 0;
          this.start().catch((error) => this.error(`Restarting server failed`, error, "force"));
        }
      }
      async handleConnectionError(error, message, count) {
        const handlerResult = await this._clientOptions.errorHandler.error(error, message, count);
        if (handlerResult.action === ErrorAction.Shutdown) {
          this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring. Shutting down server.`, void 0, handlerResult.handled === true ? false : "force");
          this.stop().catch((error2) => {
            this.error(`Stopping server failed`, error2, false);
          });
        }
      }
      hookConfigurationChanged(connection2) {
        this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
          this.refreshTrace(connection2, true);
        }));
      }
      refreshTrace(connection2, sendNotification = false) {
        const config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
          } else {
            trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection2.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        }).catch((error) => {
          this.error(`Updating trace failed with error`, error, false);
        });
      }
      hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
          return;
        }
        let watchers;
        if (Is2.array(fileEvents)) {
          watchers = fileEvents;
        } else {
          watchers = [fileEvents];
        }
        if (!watchers) {
          return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
      }
      registerFeatures(features2) {
        for (let feature of features2) {
          this.registerFeature(feature);
        }
      }
      registerFeature(feature) {
        this._features.push(feature);
        if (features_1.DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getFeature(request) {
        return this._dynamicFeatures.get(request);
      }
      hasDedicatedTextSynchronizationFeature(textDocument) {
        const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
        if (feature === void 0 || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
          return false;
        }
        return feature.handles(textDocument);
      }
      registerBuiltinFeatures() {
        const pendingFullTextDocumentChanges = /* @__PURE__ */ new Map();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this._didChangeTextDocumentFeature = new textSynchronization_1.DidChangeTextDocumentFeature(this, pendingFullTextDocumentChanges);
        this._didChangeTextDocumentFeature.onPendingChangeAdded(() => {
          this.triggerPendingChangeDelivery();
        });
        this.registerFeature(this._didChangeTextDocumentFeature);
        this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
        this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments, pendingFullTextDocumentChanges));
        this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new completion_1.CompletionItemFeature(this));
        this.registerFeature(new hover_1.HoverFeature(this));
        this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
        this.registerFeature(new definition_1.DefinitionFeature(this));
        this.registerFeature(new reference_1.ReferencesFeature(this));
        this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
        this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
        this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
        this.registerFeature(new codeAction_1.CodeActionFeature(this));
        this.registerFeature(new codeLens_1.CodeLensFeature(this));
        this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new rename_1.RenameFeature(this));
        this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
        this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
        this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        if (this.clientOptions.workspaceFolder === void 0) {
          this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
        }
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
        this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
        this.registerFeature(new inlineValue_1.InlineValueFeature(this));
        this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
        this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
        this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (Is2.func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        (0, features_1.ensure)(result, "workspace").applyEdit = true;
        const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: true
        };
        const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = (0, features_1.ensure)(result, "window");
        const showMessage = (0, features_1.ensure)(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = (0, features_1.ensure)(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = (0, features_1.ensure)(result, "general");
        generalCapabilities.staleRequestSupport = {
          cancel: true,
          retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = {
          parser: "marked",
          version: "1.1.0"
        };
        generalCapabilities.positionEncodings = ["utf-16"];
        if (this._clientOptions.markdown.supportHtml) {
          generalCapabilities.markdown.allowedTags = ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"];
        }
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        const documentSelector = this._clientOptions.documentSelector;
        for (const feature of this._features) {
          if (Is2.func(feature.preInitialize)) {
            feature.preInitialize(this._capabilities, documentSelector);
          }
        }
        for (const feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      async handleRegistrationRequest(params) {
        if (!this.isRunning()) {
          for (const registration of params.registrations) {
            this._ignoredRegistrations.add(registration.id);
          }
          return;
        }
        for (const registration of params.registrations) {
          const feature = this._dynamicFeatures.get(registration.method);
          if (feature === void 0) {
            return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
          }
          const options = registration.registerOptions ?? {};
          options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
          const data = {
            id: registration.id,
            registerOptions: options
          };
          try {
            feature.register(data);
          } catch (err) {
            return Promise.reject(err);
          }
        }
      }
      async handleUnregistrationRequest(params) {
        for (let unregistration of params.unregisterations) {
          if (this._ignoredRegistrations.has(unregistration.id)) {
            continue;
          }
          const feature = this._dynamicFeatures.get(unregistration.method);
          if (!feature) {
            return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
          }
          feature.unregister(unregistration.id);
        }
      }
      async handleApplyWorkspaceEdit(params) {
        const workspaceEdit = params.edit;
        const converted = await this.workspaceEditLock.lock(() => {
          return this._p2c.asWorkspaceEdit(workspaceEdit);
        });
        const openTextDocuments = /* @__PURE__ */ new Map();
        vscode_1.workspace.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              const changeUri = this._p2c.asUri(change.textDocument.uri).toString();
              const textDocument = openTextDocuments.get(changeUri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return Is2.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => {
          return { applied: value };
        }));
      }
      handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
          if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
            return defaultValue;
          }
          if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
            if (token !== void 0 && token.isCancellationRequested) {
              return defaultValue;
            } else {
              if (error.data !== void 0) {
                throw new features_1.LSPCancellationError(error.data);
              } else {
                throw new vscode_1.CancellationError();
              }
            }
          } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
            if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method) || BaseLanguageClient.CancellableResolveCalls.has(type.method)) {
              throw new vscode_1.CancellationError();
            } else {
              return defaultValue;
            }
          }
        }
        this.error(`Request ${type.method} failed.`, error, showNotification);
        throw error;
      }
    }
    exports.BaseLanguageClient = BaseLanguageClient;
    BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
      vscode_languageserver_protocol_1.SemanticTokensRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
    ]);
    BaseLanguageClient.CancellableResolveCalls = /* @__PURE__ */ new Set([
      vscode_languageserver_protocol_1.CompletionResolveRequest.method,
      vscode_languageserver_protocol_1.CodeLensResolveRequest.method,
      vscode_languageserver_protocol_1.CodeActionResolveRequest.method,
      vscode_languageserver_protocol_1.InlayHintResolveRequest.method,
      vscode_languageserver_protocol_1.DocumentLinkResolveRequest.method,
      vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.method
    ]);
    class ConsoleLogger {
      error(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
      }
      warn(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
      }
      info(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
      }
      log(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
      }
    }
    function createConnection(input, output, errorHandler, closeHandler, options) {
      const logger = new ConsoleLogger();
      const connection2 = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
      connection2.onError((data) => {
        errorHandler(data[0], data[1], data[2]);
      });
      connection2.onClose(closeHandler);
      const result = {
        listen: () => connection2.listen(),
        sendRequest: connection2.sendRequest,
        onRequest: connection2.onRequest,
        hasPendingResponse: connection2.hasPendingResponse,
        sendNotification: connection2.sendNotification,
        onNotification: connection2.onNotification,
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
          const defaultTraceOptions = {
            sendNotification: false,
            traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
          };
          if (sendNotificationOrTraceOptions === void 0) {
            return connection2.trace(value, tracer, defaultTraceOptions);
          } else if (Is2.boolean(sendNotificationOrTraceOptions)) {
            return connection2.trace(value, tracer, sendNotificationOrTraceOptions);
          } else {
            return connection2.trace(value, tracer, sendNotificationOrTraceOptions);
          }
        },
        initialize: (params) => {
          return connection2.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
        },
        shutdown: () => {
          return connection2.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0);
        },
        exit: () => {
          return connection2.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
        },
        end: () => connection2.end(),
        dispose: () => connection2.dispose()
      };
      return result;
    }
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      function createAll(_client) {
        let result = [];
        return result;
      }
      ProposedFeatures2.createAll = createAll;
    })(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
  })(client);
  return client;
}
var clientExports = requireClient();
class MonacoLanguageClient extends clientExports.BaseLanguageClient {
  constructor({ id, name, clientOptions, connectionProvider }) {
    super(id || name.toLowerCase(), name, clientOptions);
    __publicField(this, "connectionProvider");
    this.connectionProvider = connectionProvider;
  }
  createMessageTransports(encoding) {
    return this.connectionProvider.get(encoding);
  }
  getLocale() {
    return super.getLocale() || "en-US";
  }
}
const wasVscodeApiInitialized = () => {
  var _a3;
  return ((_a3 = window.MonacoEnvironment) == null ? void 0 : _a3.vscodeApiInitialised) === true;
};
const initServices = async (config) => {
  await importAllServices(config);
  if ((config == null ? void 0 : config.debugLogging) === true) {
    console.log("initializeMonacoService completed successfully");
  }
  await initialize();
  if ((config == null ? void 0 : config.debugLogging) === true) {
    console.log("initializeVscodeExtensions completed successfully");
  }
  if (!window.MonacoEnvironment) {
    window.MonacoEnvironment = {
      createTrustedTypesPolicy: (_policyName) => {
        return void 0;
      }
    };
  }
  window.MonacoEnvironment.vscodeApiInitialised = true;
};
const importAllServices = async (config) => {
  var _a3, _b3, _c3, _d3;
  const serviceNames = [];
  const promises = [];
  const lc = config ?? {};
  const userServices = lc.userServices ?? {};
  const addService = (name, promise) => {
    serviceNames.push(name);
    promises.push(promise);
  };
  if (lc.enableModelService === true) {
    addService("model", __vitePreload(() => import("./model-48d4644a.js"), true ? ["assets/model-48d4644a.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.configureEditorOrViewsService !== void 0) {
    if (lc.configureEditorOrViewsService.enableViewsService === true) {
      addService("views", __vitePreload(() => import("./views-b3d6cf4e.js"), true ? ["assets/views-b3d6cf4e.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/viewsService-d4b94cea.js","assets/editor-557b13f4.js","assets/simpleIconLabel-ea6a3011.js","assets/window-67f3d505.js","assets/workbench.contribution-0151a633.js","assets/style-4f366664.js","assets/views-86df89ff.css"] : void 0));
    } else {
      addService("editor", __vitePreload(() => import("./editor-1802042e.js"), true ? ["assets/editor-1802042e.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/editor-557b13f4.js","assets/simpleIconLabel-ea6a3011.js"] : void 0));
    }
  }
  if (lc.configureConfigurationService !== void 0) {
    addService("configuration", __vitePreload(() => Promise.resolve().then(() => configuration$1), true ? void 0 : void 0));
  }
  if (lc.enableDialogService === true) {
    addService("dialogs", __vitePreload(() => import("./dialogs-0d52731e.js"), true ? ["assets/dialogs-0d52731e.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/window-67f3d505.js","assets/dialogs-0d305e50.css"] : void 0));
  }
  if (lc.enableNotificationService === true) {
    addService("notifications", __vitePreload(() => import("./notifications-2389022d.js"), true ? ["assets/notifications-2389022d.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/notificationsCommands-9319aa92.js"] : void 0));
  }
  if (lc.enableThemeService === true) {
    addService("theme", __vitePreload(() => import("./theme-580f3fe7.js"), true ? ["assets/theme-580f3fe7.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.enableTextmateService === true) {
    addService("textmate", __vitePreload(() => import("./textmate-5f13274b.js"), true ? ["assets/textmate-5f13274b.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.enableKeybindingsService === true) {
    addService("keybindings", __vitePreload(() => import("./keybindings-cae95aa4.js"), true ? ["assets/keybindings-cae95aa4.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/unboundCommands-0fd8d661.js","assets/workbench.contribution-0151a633.js","assets/logConstants-8dfc303d.js"] : void 0));
  }
  if (lc.enableLanguagesService === true) {
    addService("languages", __vitePreload(() => import("./languages-8732da29.js"), true ? ["assets/languages-8732da29.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.enableAudioCueService === true) {
    addService("audioCue", __vitePreload(() => import("./audioCue-331f429f.js"), true ? ["assets/audioCue-331f429f.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.enableDebugService === true) {
    addService("debug", __vitePreload(() => import("./debug-5d859e68.js"), true ? ["assets/debug-5d859e68.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/debugCommands-865f55ea.js","assets/markers-818a6784.js","assets/dropdownWithPrimaryActionViewItem-f7a63dfc.js"] : void 0));
  }
  if (lc.enablePreferencesService === true) {
    addService("preferences", __vitePreload(() => import("./preferences-91a52970.js"), true ? ["assets/preferences-91a52970.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/unboundCommands-0fd8d661.js","assets/style-4f366664.js","assets/simpleIconLabel-ea6a3011.js"] : void 0));
  }
  if (lc.enableSnippetsService === true) {
    addService("snippets", __vitePreload(() => import("./snippets-81a8ca92.js"), true ? ["assets/snippets-81a8ca92.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.enableOutputService === true) {
    addService("output", __vitePreload(() => import("./theme-defaults-1df7f429.js").then((n2) => n2.D5), true ? ["assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.configureTerminalService !== void 0) {
    addService("terminal", __vitePreload(() => import("./terminal-9b9f7e56.js"), true ? ["assets/terminal-9b9f7e56.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/quickPickPin-cb6cd653.js","assets/logConstants-8dfc303d.js","assets/viewsService-d4b94cea.js","assets/dropdownWithPrimaryActionViewItem-f7a63dfc.js"] : void 0));
  }
  if (lc.enableSearchService === true) {
    addService("search", __vitePreload(() => import("./search-e77547e8.js"), true ? ["assets/search-e77547e8.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/debugCommands-865f55ea.js","assets/quickPickPin-cb6cd653.js"] : void 0));
  }
  if (lc.enableMarkersService === true) {
    addService("markers", __vitePreload(() => import("./markers-e832c49a.js"), true ? ["assets/markers-e832c49a.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/markers-818a6784.js"] : void 0));
  }
  if (lc.enableAccessibilityService === true) {
    addService("accessibility", __vitePreload(() => import("./accessibility-b4582bd0.js"), true ? ["assets/accessibility-b4582bd0.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css","assets/notificationsCommands-9319aa92.js"] : void 0));
  }
  if (lc.enableLanguageDetectionWorkerService === true) {
    addService("languageDetectionWorker", __vitePreload(() => import("./languageDetectionWorker-19d2d7f5.js"), true ? ["assets/languageDetectionWorker-19d2d7f5.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  if (lc.enableLanguageDetectionWorkerService === true) {
    addService("languageDetectionWorker", __vitePreload(() => import("./languageDetectionWorker-19d2d7f5.js"), true ? ["assets/languageDetectionWorker-19d2d7f5.js","assets/theme-defaults-1df7f429.js","assets/index-3bddf13b.js","assets/index-734057e1.css","assets/theme-defaults-61c0c9ec.css"] : void 0));
  }
  const reportServiceLoading = (services, debugLogging, origin) => {
    for (const serviceName of Object.keys(services)) {
      if (debugLogging) {
        if (origin) {
          console.log(`Loading ${origin} service: ${serviceName}`);
        } else {
          console.log(`Loading service: ${serviceName}`);
        }
      }
    }
  };
  const mergeServices = (services, overrideServices2) => {
    for (const [name, service] of Object.entries(services)) {
      overrideServices2[name] = service;
    }
  };
  let count = 0;
  const loadedImports = await Promise.all(Object.values(promises));
  const overrideServices = {};
  if (userServices) {
    mergeServices(userServices, overrideServices);
    reportServiceLoading(userServices, lc.debugLogging === true, "user");
  }
  const haveThemeService = serviceNames.includes("theme") || Object.keys(overrideServices).includes("themeService");
  const haveTextmateService = serviceNames.includes("textmate") || Object.keys(overrideServices).includes("textMateTokenizationFeature");
  const haveMarkersService = serviceNames.includes("markers");
  const haveViewsService = serviceNames.includes("views") || Object.keys(overrideServices).includes("viewsService");
  if (haveThemeService && !haveTextmateService) {
    throw new Error('"theme" requires "textmate" service. Please add it to the "initServices" config.');
  }
  if (haveMarkersService && !haveViewsService) {
    throw new Error('"markers" requires "views" service. Please add it to the "initServices" config.');
  }
  for (const loadedImport of loadedImports) {
    const serviceName = serviceNames[count];
    if (lc.debugLogging === true) {
      console.log(`Initialising provided service: ${serviceName}`);
    }
    let services = {};
    if (serviceName === "editor" || serviceName === "views") {
      if ((_a3 = lc.configureEditorOrViewsService) == null ? void 0 : _a3.openEditorFunc) {
        services = loadedImport.default(lc.configureEditorOrViewsService.openEditorFunc);
      } else {
        const defaultOpenEditorFunc = async (model, options, sideBySide) => {
          console.log("Trying to open a model", model, options, sideBySide);
          return void 0;
        };
        services = loadedImport.default(defaultOpenEditorFunc);
      }
    } else if (serviceName === "configuration") {
      if ((_b3 = lc.configureConfigurationService) == null ? void 0 : _b3.defaultWorkspaceUri) {
        const uri = Uri.file(lc.configureConfigurationService.defaultWorkspaceUri);
        services = loadedImport.default(uri);
      }
    } else if (serviceName === "terminal") {
      if ((_c3 = lc.configureTerminalService) == null ? void 0 : _c3.backendImpl) {
        services = loadedImport.default(lc.configureTerminalService.backendImpl);
      }
    } else if (serviceName === "storage") {
      services = loadedImport.default((_d3 = lc.configureStorageService) == null ? void 0 : _d3.provider);
    } else {
      services = loadedImport.default();
    }
    mergeServices(services, overrideServices);
    reportServiceLoading(services, lc.debugLogging === true);
    count++;
  }
  await initialize$1(overrideServices);
  if (lc.logLevel) {
    StandaloneServices.get(ILogService).setLevel(lc.logLevel);
  }
};
var messageReaderExports = requireMessageReader();
class WebSocketMessageReader extends messageReaderExports.AbstractMessageReader {
  constructor(socket) {
    super();
    __publicField(this, "socket");
    __publicField(this, "state", "initial");
    __publicField(this, "callback");
    __publicField(this, "events", []);
    this.socket = socket;
    this.socket.onMessage((message) => this.readMessage(message));
    this.socket.onError((error) => this.fireError(error));
    this.socket.onClose((code, reason) => {
      if (code !== 1e3) {
        const error = {
          name: "" + code,
          message: `Error during socket reconnect: code = ${code}, reason = ${reason}`
        };
        this.fireError(error);
      }
      this.fireClose();
    });
  }
  listen(callback) {
    if (this.state === "initial") {
      this.state = "listening";
      this.callback = callback;
      while (this.events.length !== 0) {
        const event = this.events.pop();
        if (event.message) {
          this.readMessage(event.message);
        } else if (event.error) {
          this.fireError(event.error);
        } else {
          this.fireClose();
        }
      }
    }
    return {
      dispose: () => {
        if (this.callback === callback) {
          this.callback = void 0;
        }
      }
    };
  }
  readMessage(message) {
    if (this.state === "initial") {
      this.events.splice(0, 0, { message });
    } else if (this.state === "listening") {
      try {
        const data = JSON.parse(message);
        this.callback(data);
      } catch (err) {
        const error = {
          name: "400",
          message: `Error during message parsing, reason = ${typeof err === "object" ? err.message : "unknown"}`
        };
        this.fireError(error);
      }
    }
  }
  fireError(error) {
    if (this.state === "initial") {
      this.events.splice(0, 0, { error });
    } else if (this.state === "listening") {
      super.fireError(error);
    }
  }
  fireClose() {
    if (this.state === "initial") {
      this.events.splice(0, 0, {});
    } else if (this.state === "listening") {
      super.fireClose();
    }
    this.state = "closed";
  }
}
var messageWriterExports = requireMessageWriter();
class WebSocketMessageWriter extends messageWriterExports.AbstractMessageWriter {
  constructor(socket) {
    super();
    __publicField(this, "socket");
    __publicField(this, "errorCount", 0);
    this.socket = socket;
  }
  end() {
  }
  async write(msg) {
    try {
      const content = JSON.stringify(msg);
      this.socket.send(content);
    } catch (e) {
      this.errorCount++;
      this.fireError(e, msg, this.errorCount);
    }
  }
}
requireMain$1();
function toSocket(webSocket) {
  return {
    send: (content) => webSocket.send(content),
    onMessage: (cb) => {
      webSocket.onmessage = (event) => cb(event.data);
    },
    onError: (cb) => {
      webSocket.onerror = (event) => {
        if ("message" in event) {
          cb(event.message);
        }
      };
    },
    onClose: (cb) => {
      webSocket.onclose = (event) => cb(event.code, event.reason);
    },
    dispose: () => webSocket.close()
  };
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  browser = requireMain();
  return browser;
}
var browserExports = requireBrowser();
class LanguageClientWrapper {
  constructor(languageClientConfig, logger) {
    __publicField(this, "languageClient");
    __publicField(this, "languageClientConfig");
    __publicField(this, "worker");
    __publicField(this, "languageId");
    __publicField(this, "name");
    __publicField(this, "logger");
    if (languageClientConfig) {
      this.languageClientConfig = languageClientConfig;
      this.name = this.languageClientConfig.options.name ?? "unnamed";
    }
    this.logger = logger;
  }
  haveLanguageClient() {
    return this.languageClient !== void 0;
  }
  haveLanguageClientConfig() {
    return this.languageClientConfig !== void 0;
  }
  getLanguageClient() {
    return this.languageClient;
  }
  getWorker() {
    return this.worker;
  }
  isStarted() {
    var _a3;
    return this.languageClient !== void 0 && ((_a3 = this.languageClient) == null ? void 0 : _a3.isRunning());
  }
  init(languageId) {
    this.languageId = languageId;
  }
  async start() {
    if (this.languageClientConfig) {
      return this.startLanguageClientConnection();
    } else {
      const languageClientError = {
        message: `languageClientWrapper (${this.name}): Unable to start monaco-languageclient. No configuration was provided.`,
        error: "No error was provided."
      };
      return Promise.reject(languageClientError);
    }
  }
  /**
   * Restart the languageclient with options to control worker handling
   *
   * @param updatedWorker Set a new worker here that should be used. keepWorker has no effect then, as we want to dispose of the prior workers
   * @param keepWorker Set to true if worker should not be disposed
   */
  async restartLanguageClient(updatedWorker, keepWorker) {
    var _a3;
    if (updatedWorker) {
      await this.disposeLanguageClient(false);
    } else {
      await this.disposeLanguageClient(keepWorker);
    }
    this.worker = updatedWorker;
    if (this.languageClientConfig) {
      (_a3 = this.logger) == null ? void 0 : _a3.info("Re-Starting monaco-languageclient");
      return this.startLanguageClientConnection();
    } else {
      const languageClientError = {
        message: `languageClientWrapper (${this.name}): Unable to restart languageclient. No configuration was provided.`,
        error: "No error was provided."
      };
      return Promise.reject(languageClientError);
    }
  }
  startLanguageClientConnection() {
    var _a3;
    if (this.languageClient && this.languageClient.isRunning()) {
      (_a3 = this.logger) == null ? void 0 : _a3.info("monaco-languageclient already running!");
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      var _a4;
      const lcConfig = (_a4 = this.languageClientConfig) == null ? void 0 : _a4.options;
      if ((lcConfig == null ? void 0 : lcConfig.$type) === "WebSocket" || (lcConfig == null ? void 0 : lcConfig.$type) === "WebSocketUrl") {
        const url = createUrl(lcConfig);
        const webSocket = new WebSocket(url);
        webSocket.onopen = () => {
          const socket = toSocket(webSocket);
          const messageTransports = {
            reader: new WebSocketMessageReader(socket),
            writer: new WebSocketMessageWriter(socket)
          };
          this.handleLanguageClientStart(messageTransports, resolve, reject);
        };
        webSocket.onerror = (ev) => {
          const languageClientError = {
            message: `languageClientWrapper (${this.name}): Websocket connection failed.`,
            error: ev.error ?? "No error was provided."
          };
          reject(languageClientError);
        };
      } else {
        if (!this.worker) {
          if ((lcConfig == null ? void 0 : lcConfig.$type) === "WorkerConfig") {
            const workerConfig = lcConfig;
            this.worker = new Worker(new URL(workerConfig.url, window.location.href).href, {
              type: workerConfig.type,
              name: workerConfig.name
            });
            this.worker.onerror = (ev) => {
              const languageClientError = {
                message: `languageClientWrapper (${this.name}): Illegal worker configuration detected. Potentially the url is wrong.`,
                error: ev.error ?? "No error was provided."
              };
              reject(languageClientError);
            };
          } else {
            const workerDirectConfig = lcConfig;
            this.worker = workerDirectConfig.worker;
          }
        }
        const messageTransports = {
          reader: new browserExports.BrowserMessageReader(this.worker),
          writer: new browserExports.BrowserMessageWriter(this.worker)
        };
        this.handleLanguageClientStart(messageTransports, resolve, reject);
      }
    });
  }
  async handleLanguageClientStart(messageTransports, resolve, reject) {
    var _a3, _b3, _c3;
    this.languageClient = this.createLanguageClient(messageTransports);
    const lcConfig = (_a3 = this.languageClientConfig) == null ? void 0 : _a3.options;
    messageTransports.reader.onClose(async () => {
      var _a4, _b4;
      await ((_a4 = this.languageClient) == null ? void 0 : _a4.stop());
      if (((lcConfig == null ? void 0 : lcConfig.$type) === "WebSocket" || (lcConfig == null ? void 0 : lcConfig.$type) === "WebSocketUrl") && (lcConfig == null ? void 0 : lcConfig.stopOptions)) {
        const stopOptions = lcConfig == null ? void 0 : lcConfig.stopOptions;
        stopOptions.onCall(this.getLanguageClient());
        if (stopOptions.reportStatus) {
          (_b4 = this.logger) == null ? void 0 : _b4.info(this.reportStatus().join("\n"));
        }
      }
    });
    try {
      await this.languageClient.start();
      if (((lcConfig == null ? void 0 : lcConfig.$type) === "WebSocket" || (lcConfig == null ? void 0 : lcConfig.$type) === "WebSocketUrl") && (lcConfig == null ? void 0 : lcConfig.startOptions)) {
        const startOptions = lcConfig == null ? void 0 : lcConfig.startOptions;
        startOptions.onCall(this.getLanguageClient());
        if (startOptions.reportStatus) {
          (_b3 = this.logger) == null ? void 0 : _b3.info(this.reportStatus().join("\n"));
        }
      }
    } catch (e) {
      const languageClientError = {
        message: `languageClientWrapper (${this.name}): Start was unsuccessful.`,
        error: e ?? "No error was provided."
      };
      reject(languageClientError);
    }
    (_c3 = this.logger) == null ? void 0 : _c3.info(`languageClientWrapper (${this.name}): Started successfully.`);
    resolve();
  }
  createLanguageClient(transports) {
    var _a3, _b3, _c3;
    return new MonacoLanguageClient({
      name: ((_a3 = this.languageClientConfig) == null ? void 0 : _a3.options.name) ?? "Monaco Wrapper Language Client",
      clientOptions: {
        // use a language id as a document selector
        documentSelector: [this.languageId],
        // disable the default error handler
        errorHandler: {
          error: () => ({ action: clientExports.ErrorAction.Continue }),
          closed: () => ({ action: clientExports.CloseAction.DoNotRestart })
        },
        // allow to initialize the language client with user specific options
        initializationOptions: (_b3 = this.languageClientConfig) == null ? void 0 : _b3.initializationOptions,
        ...((_c3 = this.languageClientConfig) == null ? void 0 : _c3.configurationOptions) ?? {}
      },
      // create a language client connection from the JSON RPC connection on demand
      connectionProvider: {
        get: () => {
          return Promise.resolve(transports);
        }
      }
    });
  }
  disposeWorker(keepWorker) {
    var _a3;
    if (keepWorker === void 0 || keepWorker === false) {
      (_a3 = this.worker) == null ? void 0 : _a3.terminate();
      this.worker = void 0;
    }
  }
  async disposeLanguageClient(keepWorker) {
    var _a3;
    if (!this.languageClient) {
      this.disposeWorker(keepWorker);
      return Promise.resolve();
    }
    if (this.languageClient && this.languageClient.isRunning()) {
      try {
        await this.languageClient.dispose();
        this.disposeWorker(keepWorker);
        this.languageClient = void 0;
        (_a3 = this.logger) == null ? void 0 : _a3.info("monaco-languageclient and monaco-editor were successfully disposed.");
        return Promise.resolve();
      } catch (e) {
        const languageClientError = {
          message: `languageClientWrapper (${this.name}): Disposing the monaco-languageclient resulted in error.`,
          error: e ?? "No error was provided."
        };
        return Promise.reject(languageClientError);
      }
    } else {
      const languageClientError = {
        message: `languageClientWrapper (${this.name}): Unable to dispose monaco-languageclient: It is not yet started.`,
        error: "No error was provided."
      };
      return Promise.reject(languageClientError);
    }
  }
  reportStatus() {
    const status2 = [];
    const languageClient = this.getLanguageClient();
    status2.push("LanguageClientWrapper status:");
    status2.push(`LanguageClient: ${(languageClient == null ? void 0 : languageClient.name) ?? "Language Client"} is in a '${clientExports.State[(languageClient == null ? void 0 : languageClient.state) ?? 1]}' state`);
    return status2;
  }
}
class Logger {
  constructor(config) {
    __publicField(this, "enabled");
    __publicField(this, "debugEnabled");
    this.enabled = !config ? true : config.enabled === true;
    this.debugEnabled = this.enabled && (config == null ? void 0 : config.debugEnabled) === true;
  }
  isEnabled() {
    return this.enabled;
  }
  isDebugEnabled() {
    return this.debugEnabled;
  }
  info(message) {
    if (this.enabled) {
      console.log(message);
    }
  }
  debug(message, force) {
    if (this.enabled && (this.debugEnabled || force === true)) {
      console.debug(message);
    }
  }
}
class MonacoEditorLanguageClientWrapper {
  constructor() {
    __publicField(this, "id");
    __publicField(this, "htmlElement");
    __publicField(this, "editorApp");
    __publicField(this, "languageClientWrapper");
    __publicField(this, "serviceConfig");
    __publicField(this, "logger");
  }
  async init(userConfig) {
    if (userConfig.wrapperConfig.editorAppConfig.useDiffEditor && !userConfig.wrapperConfig.editorAppConfig.codeOriginal) {
      throw new Error("Use diff editor was used without a valid config.");
    }
    this.id = userConfig.id ?? Math.floor(Math.random() * 101).toString();
    this.htmlElement = userConfig.htmlElement;
    this.logger = new Logger(userConfig.loggerConfig);
    this.serviceConfig = userConfig.wrapperConfig.serviceConfig ?? {};
    this.serviceConfig.enableModelService = this.serviceConfig.enableModelService ?? true;
    this.serviceConfig.configureConfigurationService = this.serviceConfig.configureConfigurationService ?? {
      defaultWorkspaceUri: "/tmp/"
    };
    this.serviceConfig.debugLogging = this.logger.isEnabled() && (this.serviceConfig.debugLogging || this.logger.isDebugEnabled());
    if (wasVscodeApiInitialized()) {
      this.logger.debug("No service init on restart", this.serviceConfig.debugLogging);
    } else {
      this.logger.debug("Init Services", this.serviceConfig.debugLogging);
      await initServices(this.serviceConfig);
    }
    this.languageClientWrapper = new LanguageClientWrapper(userConfig.languageClientConfig, this.logger);
  }
  async start(userConfig) {
    var _a3, _b3;
    await this.init(userConfig);
    (_a3 = this.editorApp) == null ? void 0 : _a3.disposeApp();
    if (isVscodeApiEditorApp(userConfig.wrapperConfig)) {
      this.editorApp = new EditorAppVscodeApi(this.id, userConfig, this.logger);
    } else {
      this.editorApp = new EditorAppClassic(this.id, userConfig, this.logger);
    }
    this.languageClientWrapper.init(this.editorApp.getConfig().languageId);
    this.logger.info(`Starting monaco-editor (${this.id})`);
    await ((_b3 = this.editorApp) == null ? void 0 : _b3.init());
    await this.editorApp.createEditors(this.htmlElement);
    if (this.languageClientWrapper.haveLanguageClientConfig()) {
      await this.languageClientWrapper.start();
    }
  }
  isStarted() {
    var _a3;
    if (!((_a3 = this.editorApp) == null ? void 0 : _a3.haveEditor())) {
      return false;
    }
    if (this.languageClientWrapper.haveLanguageClient()) {
      return this.languageClientWrapper.isStarted();
    }
    return true;
  }
  getMonacoEditorApp() {
    return this.editorApp;
  }
  getEditor() {
    var _a3;
    return (_a3 = this.editorApp) == null ? void 0 : _a3.getEditor();
  }
  getDiffEditor() {
    var _a3;
    return (_a3 = this.editorApp) == null ? void 0 : _a3.getDiffEditor();
  }
  getLanguageClient() {
    return this.languageClientWrapper.getLanguageClient();
  }
  getModel(original) {
    var _a3;
    return (_a3 = this.editorApp) == null ? void 0 : _a3.getModel(original);
  }
  getWorker() {
    return this.languageClientWrapper.getWorker();
  }
  async updateModel(modelUpdate) {
    var _a3;
    await ((_a3 = this.editorApp) == null ? void 0 : _a3.updateModel(modelUpdate));
  }
  async updateDiffModel(modelUpdate) {
    var _a3;
    await ((_a3 = this.editorApp) == null ? void 0 : _a3.updateDiffModel(modelUpdate));
  }
  async updateEditorOptions(options) {
    if (this.editorApp) {
      await this.editorApp.updateEditorOptions(options);
    } else {
      await Promise.reject("Update was called when editor wrapper was not correctly configured.");
    }
  }
  reportStatus() {
    var _a3, _b3;
    const status2 = [];
    status2.push("Wrapper status:");
    status2.push(`Editor: ${(_a3 = this.editorApp) == null ? void 0 : _a3.getEditor()}`);
    status2.push(`DiffEditor: ${(_b3 = this.editorApp) == null ? void 0 : _b3.getDiffEditor()}`);
    return status2;
  }
  async dispose() {
    var _a3;
    (_a3 = this.editorApp) == null ? void 0 : _a3.disposeApp();
    if (this.languageClientWrapper.haveLanguageClient()) {
      await this.languageClientWrapper.disposeLanguageClient(false);
      this.editorApp = void 0;
      await Promise.resolve("Monaco editor and languageclient completed disposed.");
    } else {
      await Promise.resolve("Monaco editor has been disposed.");
    }
  }
  updateLayout() {
    var _a3;
    (_a3 = this.editorApp) == null ? void 0 : _a3.updateLayout();
  }
}
let monacoInitializerQueue = Promise.resolve();
function enqueueMonacoInitializer(makePromise) {
  monacoInitializerQueue = monacoInitializerQueue.then(makePromise).catch((e) => {
    console.error("Error during initialization:", e);
  });
  return monacoInitializerQueue;
}
class MonacoEditorReactComp extends React.Component {
  constructor(props) {
    super(props);
    __publicField(this, "wrapper", new MonacoEditorLanguageClientWrapper());
    __publicField(this, "containerElement");
    __publicField(this, "_subscription", null);
    __publicField(this, "isStarting");
    __publicField(this, "isReiniting");
    __publicField(this, "assignRef", (component) => {
      this.containerElement = component;
    });
    this.containerElement = void 0;
  }
  async componentDidMount() {
    await enqueueMonacoInitializer(() => this.initMonaco());
  }
  componentWillUnmount() {
    this.destroyMonaco();
  }
  async destroyMonaco() {
    if (this.wrapper) {
      await this.isStarting;
      try {
        await this.wrapper.dispose();
      } catch {
      }
    }
    if (this._subscription) {
      this._subscription.dispose();
    }
  }
  async initMonaco() {
    const {
      className,
      userConfig,
      onTextChanged,
      onLoad
    } = this.props;
    if (this.containerElement) {
      this.containerElement.className = className ?? "";
      userConfig.htmlElement = this.containerElement;
      this.isStarting = this.wrapper.start(userConfig);
      await this.isStarting;
      onLoad && onLoad();
      if (onTextChanged) {
        const model = this.wrapper.getModel();
        if (model) {
          const verifyModelContent = () => {
            const modelText = model.getValue();
            onTextChanged(modelText, modelText !== userConfig.wrapperConfig.editorAppConfig.code);
          };
          this._subscription = model.onDidChangeContent(() => {
            verifyModelContent();
          });
          verifyModelContent();
        }
      }
    }
  }
  updateLayout() {
    this.wrapper.updateLayout();
  }
  getEditorWrapper() {
    return this.wrapper;
  }
  /**
   * Executes a custom LSP command by name with args, and returns the result
   * @param cmd Command to execute
   * @param args Arguments to pass along with this command
   * @returns The result of executing this command in the language server
   */
  executeCommand(cmd, ...args) {
    return commands.executeCommand(cmd, ...args);
  }
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: this.assignRef,
        style: this.props.style,
        className: this.props.className
      }
    );
  }
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MonacoEditorReactComp
}, Symbol.toStringTag, { value: "Module" }));
export {
  ReferencesController as $,
  APPLY_ALL_PROFILES_SETTING as A,
  REMOTE_MACHINE_SCOPES as B,
  ChangeTabDisplaySize as C,
  DetectIndentation as D,
  ExtensionData as E,
  FindReplaceState as F,
  GutterActionsRegistry as G,
  HoverWidget as H,
  IWorkbenchThemeService as I,
  getSelectionSearchString as J,
  SeverityIcon as K,
  LOCAL_MACHINE_SCOPES as L,
  ModesHoverController as M,
  NLS_MATCHES_LOCATION as N,
  CONTEXT_FIND_WIDGET_NOT_VISIBLE as O,
  CommonFindController as P,
  MultiCursorSelectionController as Q,
  RangeHighlightDecorations as R,
  SimpleButton as S,
  TrimTrailingWhitespaceAction as T,
  ToggleCaseSensitiveKeybinding as U,
  VS_HC_LIGHT_THEME as V,
  WORKSPACE_SCOPES as W,
  ToggleWholeWordKeybinding as X,
  ToggleRegexKeybinding as Y,
  TogglePreserveCaseKeybinding as Z,
  UnusualLineTerminatorsDetector as _,
  HoverAction as a,
  ToggleTabFocusModeAction as a0,
  index as a1,
  findNextMatchIcon as b,
  NLS_NO_RESULTS as c,
  IndentUsingSpaces as d,
  IndentUsingTabs as e,
  findPreviousMatchIcon as f,
  IndentationToSpacesAction as g,
  IndentationToTabsAction as h,
  FloatingClickMenu as i,
  THEME_SCOPE_OPEN_PAREN as j,
  THEME_SCOPE_CLOSE_PAREN as k,
  THEME_SCOPE_WILDCARD as l,
  themeScopeRegex as m,
  VS_HC_THEME as n,
  VS_LIGHT_THEME as o,
  VS_DARK_THEME as p,
  ThemeSettingDefaults as q,
  ThemeSettings as r,
  COLOR_THEME_LIGHT_INITIAL_COLORS as s,
  toExternalVSDataTransfer as t,
  COLOR_THEME_DARK_INITIAL_COLORS as u,
  FoldingController as v,
  launchSchemaId as w,
  FOLDER_SCOPES as x,
  IWorkbenchConfigurationService as y,
  APPLICATION_SCOPES as z
};
