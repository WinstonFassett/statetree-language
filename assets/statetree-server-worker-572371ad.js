(function() {
  "use strict";
  (() => {
    var f$ = Object.create;
    var bh = Object.defineProperty;
    var p$ = Object.getOwnPropertyDescriptor;
    var h$ = Object.getOwnPropertyNames, dl = Object.getOwnPropertySymbols, m$ = Object.getPrototypeOf, Sh = Object.prototype.hasOwnProperty, IR = Object.prototype.propertyIsEnumerable;
    var DR = (t, e, r) => e in t ? bh(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r, fl = (t, e) => {
      for (var r in e || (e = {}))
        Sh.call(e, r) && DR(t, r, e[r]);
      if (dl)
        for (var r of dl(e))
          IR.call(e, r) && DR(t, r, e[r]);
      return t;
    };
    var pl = ((t) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(t, { get: (e, r) => (typeof require < "u" ? require : e)[r] }) : t)(function(t) {
      if (typeof require < "u")
        return require.apply(this, arguments);
      throw new Error('Dynamic require of "' + t + '" is not supported');
    });
    var xR = (t, e) => {
      var r = {};
      for (var n in t)
        Sh.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
      if (t != null && dl)
        for (var n of dl(t))
          e.indexOf(n) < 0 && IR.call(t, n) && (r[n] = t[n]);
      return r;
    };
    var f = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
    var g$ = (t, e, r, n) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let i of h$(e))
          !Sh.call(t, i) && i !== r && bh(t, i, { get: () => e[i], enumerable: !(n = p$(e, i)) || n.enumerable });
      return t;
    };
    var $r = (t, e, r) => (r = t != null ? f$(m$(t)) : {}, g$(e || !t || !t.__esModule ? bh(r, "default", { value: t, enumerable: true }) : r, t));
    var _i = f((Ch) => {
      Object.defineProperty(Ch, "__esModule", { value: true });
      var Ah;
      function Ph() {
        if (Ah === void 0)
          throw new Error("No runtime abstraction layer installed");
        return Ah;
      }
      (function(t) {
        function e(r) {
          if (r === void 0)
            throw new Error("No runtime abstraction layer provided");
          Ah = r;
        }
        t.install = e;
      })(Ph || (Ph = {}));
      Ch.default = Ph;
    });
    var Nh = f((Pu) => {
      Object.defineProperty(Pu, "__esModule", { value: true });
      Pu.Disposable = void 0;
      (function(t) {
        function e(r) {
          return { dispose: r };
        }
        t.create = e;
      })(Pu.Disposable || (Pu.Disposable = {}));
    });
    var Go = f((Uo) => {
      Object.defineProperty(Uo, "__esModule", { value: true });
      Uo.Emitter = Uo.Event = void 0;
      var v$ = _i();
      (function(t) {
        let e = { dispose() {
        } };
        t.None = function() {
          return e;
        };
      })(Uo.Event || (Uo.Event = {}));
      var Eh = class {
        add(e, r = null, n) {
          this._callbacks || (this._callbacks = [], this._contexts = []), this._callbacks.push(e), this._contexts.push(r), Array.isArray(n) && n.push({ dispose: () => this.remove(e, r) });
        }
        remove(e, r = null) {
          if (!this._callbacks)
            return;
          let n = false;
          for (let i = 0, o = this._callbacks.length; i < o; i++)
            if (this._callbacks[i] === e)
              if (this._contexts[i] === r) {
                this._callbacks.splice(i, 1), this._contexts.splice(i, 1);
                return;
              } else
                n = true;
          if (n)
            throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
        invoke(...e) {
          if (!this._callbacks)
            return [];
          let r = [], n = this._callbacks.slice(0), i = this._contexts.slice(0);
          for (let o = 0, a = n.length; o < a; o++)
            try {
              r.push(n[o].apply(i[o], e));
            } catch (s) {
              (0, v$.default)().console.error(s);
            }
          return r;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0, this._contexts = void 0;
        }
      }, Da = class {
        constructor(e) {
          this._options = e;
        }
        get event() {
          return this._event || (this._event = (e, r, n) => {
            this._callbacks || (this._callbacks = new Eh()), this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty() && this._options.onFirstListenerAdd(this), this._callbacks.add(e, r);
            let i = { dispose: () => {
              this._callbacks && (this._callbacks.remove(e, r), i.dispose = Da._noop, this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty() && this._options.onLastListenerRemove(this));
            } };
            return Array.isArray(n) && n.push(i), i;
          }), this._event;
        }
        fire(e) {
          this._callbacks && this._callbacks.invoke.call(this._callbacks, e);
        }
        dispose() {
          this._callbacks && (this._callbacks.dispose(), this._callbacks = void 0);
        }
      };
      Uo.Emitter = Da;
      Da._noop = function() {
      };
    });
    var qR = f((hl) => {
      Object.defineProperty(hl, "__esModule", { value: true });
      hl.AbstractMessageBuffer = void 0;
      var _$ = 13, R$ = 10, b$ = `\r
`, kh = class {
        constructor(e = "utf-8") {
          this._encoding = e, this._chunks = [], this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(e) {
          let r = typeof e == "string" ? this.fromString(e, this._encoding) : e;
          this._chunks.push(r), this._totalLength += r.byteLength;
        }
        tryReadHeaders() {
          if (this._chunks.length === 0)
            return;
          let e = 0, r = 0, n = 0, i = 0;
          e:
            for (; r < this._chunks.length; ) {
              let u = this._chunks[r];
              n = 0;
              for (; n < u.length; ) {
                switch (u[n]) {
                  case _$:
                    switch (e) {
                      case 0:
                        e = 1;
                        break;
                      case 2:
                        e = 3;
                        break;
                      default:
                        e = 0;
                    }
                    break;
                  case R$:
                    switch (e) {
                      case 1:
                        e = 2;
                        break;
                      case 3:
                        e = 4, n++;
                        break e;
                      default:
                        e = 0;
                    }
                    break;
                  default:
                    e = 0;
                }
                n++;
              }
              i += u.byteLength, r++;
            }
          if (e !== 4)
            return;
          let o = this._read(i + n), a = /* @__PURE__ */ new Map(), s = this.toString(o, "ascii").split(b$);
          if (s.length < 2)
            return a;
          for (let u = 0; u < s.length - 2; u++) {
            let c = s[u], l = c.indexOf(":");
            if (l === -1)
              throw new Error("Message header must separate key and value using :");
            let d = c.substr(0, l), h = c.substr(l + 1).trim();
            a.set(d, h);
          }
          return a;
        }
        tryReadBody(e) {
          if (!(this._totalLength < e))
            return this._read(e);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(e) {
          if (e === 0)
            return this.emptyBuffer();
          if (e > this._totalLength)
            throw new Error("Cannot read so many bytes!");
          if (this._chunks[0].byteLength === e) {
            let o = this._chunks[0];
            return this._chunks.shift(), this._totalLength -= e, this.asNative(o);
          }
          if (this._chunks[0].byteLength > e) {
            let o = this._chunks[0], a = this.asNative(o, e);
            return this._chunks[0] = o.slice(e), this._totalLength -= e, a;
          }
          let r = this.allocNative(e), n = 0, i = 0;
          for (; e > 0; ) {
            let o = this._chunks[i];
            if (o.byteLength > e) {
              let a = o.slice(0, e);
              r.set(a, n), n += e, this._chunks[i] = o.slice(e), this._totalLength -= e, e -= e;
            } else
              r.set(o, n), n += o.byteLength, this._chunks.shift(), this._totalLength -= o.byteLength, e -= o.byteLength;
          }
          return r;
        }
      };
      hl.AbstractMessageBuffer = kh;
    });
    var $R = f((Ih) => {
      Object.defineProperty(Ih, "__esModule", { value: true });
      var LR = _i(), Ia = Nh(), S$ = Go(), A$ = qR(), xa = class extends A$.AbstractMessageBuffer {
        constructor(e = "utf-8") {
          super(e), this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return xa.emptyBuffer;
        }
        fromString(e, r) {
          return new TextEncoder().encode(e);
        }
        toString(e, r) {
          return r === "ascii" ? this.asciiDecoder.decode(e) : new TextDecoder(r).decode(e);
        }
        asNative(e, r) {
          return r === void 0 ? e : e.slice(0, r);
        }
        allocNative(e) {
          return new Uint8Array(e);
        }
      };
      xa.emptyBuffer = new Uint8Array(0);
      var wh = class {
        constructor(e) {
          this.socket = e, this._onData = new S$.Emitter(), this._messageListener = (r) => {
            r.data.arrayBuffer().then((i) => {
              this._onData.fire(new Uint8Array(i));
            }, () => {
              (0, LR.default)().console.error("Converting blob to array buffer failed.");
            });
          }, this.socket.addEventListener("message", this._messageListener);
        }
        onClose(e) {
          return this.socket.addEventListener("close", e), Ia.Disposable.create(() => this.socket.removeEventListener("close", e));
        }
        onError(e) {
          return this.socket.addEventListener("error", e), Ia.Disposable.create(() => this.socket.removeEventListener("error", e));
        }
        onEnd(e) {
          return this.socket.addEventListener("end", e), Ia.Disposable.create(() => this.socket.removeEventListener("end", e));
        }
        onData(e) {
          return this._onData.event(e);
        }
      }, Oh = class {
        constructor(e) {
          this.socket = e;
        }
        onClose(e) {
          return this.socket.addEventListener("close", e), Ia.Disposable.create(() => this.socket.removeEventListener("close", e));
        }
        onError(e) {
          return this.socket.addEventListener("error", e), Ia.Disposable.create(() => this.socket.removeEventListener("error", e));
        }
        onEnd(e) {
          return this.socket.addEventListener("end", e), Ia.Disposable.create(() => this.socket.removeEventListener("end", e));
        }
        write(e, r) {
          if (typeof e == "string") {
            if (r !== void 0 && r !== "utf-8")
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${r}`);
            this.socket.send(e);
          } else
            this.socket.send(e);
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      }, P$ = new TextEncoder(), MR = Object.freeze({ messageBuffer: Object.freeze({ create: (t) => new xa(t) }), applicationJson: Object.freeze({ encoder: Object.freeze({ name: "application/json", encode: (t, e) => {
        if (e.charset !== "utf-8")
          throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${e.charset}`);
        return Promise.resolve(P$.encode(JSON.stringify(t, void 0, 0)));
      } }), decoder: Object.freeze({ name: "application/json", decode: (t, e) => {
        if (!(t instanceof Uint8Array))
          throw new Error("In a Browser environments only Uint8Arrays are supported.");
        return Promise.resolve(JSON.parse(new TextDecoder(e.charset).decode(t)));
      } }) }), stream: Object.freeze({ asReadableStream: (t) => new wh(t), asWritableStream: (t) => new Oh(t) }), console, timer: Object.freeze({ setTimeout(t, e, ...r) {
        let n = setTimeout(t, e, ...r);
        return { dispose: () => clearTimeout(n) };
      }, setImmediate(t, ...e) {
        let r = setTimeout(t, 0, ...e);
        return { dispose: () => clearTimeout(r) };
      }, setInterval(t, e, ...r) {
        let n = setInterval(t, e, ...r);
        return { dispose: () => clearInterval(n) };
      } }) });
      function Dh() {
        return MR;
      }
      (function(t) {
        function e() {
          LR.default.install(MR);
        }
        t.install = e;
      })(Dh || (Dh = {}));
      Ih.default = Dh;
    });
    var qa = f((Jt) => {
      Object.defineProperty(Jt, "__esModule", { value: true });
      Jt.stringArray = Jt.array = Jt.func = Jt.error = Jt.number = Jt.string = Jt.boolean = void 0;
      function C$(t) {
        return t === true || t === false;
      }
      Jt.boolean = C$;
      function FR(t) {
        return typeof t == "string" || t instanceof String;
      }
      Jt.string = FR;
      function N$(t) {
        return typeof t == "number" || t instanceof Number;
      }
      Jt.number = N$;
      function E$(t) {
        return t instanceof Error;
      }
      Jt.error = E$;
      function k$(t) {
        return typeof t == "function";
      }
      Jt.func = k$;
      function jR(t) {
        return Array.isArray(t);
      }
      Jt.array = jR;
      function w$(t) {
        return jR(t) && t.every((e) => FR(e));
      }
      Jt.stringArray = w$;
    });
    var rm = f((Y) => {
      Object.defineProperty(Y, "__esModule", { value: true });
      Y.Message = Y.NotificationType9 = Y.NotificationType8 = Y.NotificationType7 = Y.NotificationType6 = Y.NotificationType5 = Y.NotificationType4 = Y.NotificationType3 = Y.NotificationType2 = Y.NotificationType1 = Y.NotificationType0 = Y.NotificationType = Y.RequestType9 = Y.RequestType8 = Y.RequestType7 = Y.RequestType6 = Y.RequestType5 = Y.RequestType4 = Y.RequestType3 = Y.RequestType2 = Y.RequestType1 = Y.RequestType = Y.RequestType0 = Y.AbstractMessageSignature = Y.ParameterStructures = Y.ResponseError = Y.ErrorCodes = void 0;
      var Ho = qa(), UR;
      (function(t) {
        t.ParseError = -32700, t.InvalidRequest = -32600, t.MethodNotFound = -32601, t.InvalidParams = -32602, t.InternalError = -32603, t.jsonrpcReservedErrorRangeStart = -32099, t.serverErrorStart = -32099, t.MessageWriteError = -32099, t.MessageReadError = -32098, t.PendingResponseRejected = -32097, t.ConnectionInactive = -32096, t.ServerNotInitialized = -32002, t.UnknownErrorCode = -32001, t.jsonrpcReservedErrorRangeEnd = -32e3, t.serverErrorEnd = -32e3;
      })(UR = Y.ErrorCodes || (Y.ErrorCodes = {}));
      var Cu = class extends Error {
        constructor(e, r, n) {
          super(r), this.code = Ho.number(e) ? e : UR.UnknownErrorCode, this.data = n, Object.setPrototypeOf(this, Cu.prototype);
        }
        toJson() {
          let e = { code: this.code, message: this.message };
          return this.data !== void 0 && (e.data = this.data), e;
        }
      };
      Y.ResponseError = Cu;
      var Lt = class {
        constructor(e) {
          this.kind = e;
        }
        static is(e) {
          return e === Lt.auto || e === Lt.byName || e === Lt.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      Y.ParameterStructures = Lt;
      Lt.auto = new Lt("auto");
      Lt.byPosition = new Lt("byPosition");
      Lt.byName = new Lt("byName");
      var Qe = class {
        constructor(e, r) {
          this.method = e, this.numberOfParams = r;
        }
        get parameterStructures() {
          return Lt.auto;
        }
      };
      Y.AbstractMessageSignature = Qe;
      var xh = class extends Qe {
        constructor(e) {
          super(e, 0);
        }
      };
      Y.RequestType0 = xh;
      var qh = class extends Qe {
        constructor(e, r = Lt.auto) {
          super(e, 1), this._parameterStructures = r;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      Y.RequestType = qh;
      var Lh = class extends Qe {
        constructor(e, r = Lt.auto) {
          super(e, 1), this._parameterStructures = r;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      Y.RequestType1 = Lh;
      var Mh = class extends Qe {
        constructor(e) {
          super(e, 2);
        }
      };
      Y.RequestType2 = Mh;
      var $h = class extends Qe {
        constructor(e) {
          super(e, 3);
        }
      };
      Y.RequestType3 = $h;
      var Fh = class extends Qe {
        constructor(e) {
          super(e, 4);
        }
      };
      Y.RequestType4 = Fh;
      var jh = class extends Qe {
        constructor(e) {
          super(e, 5);
        }
      };
      Y.RequestType5 = jh;
      var Uh = class extends Qe {
        constructor(e) {
          super(e, 6);
        }
      };
      Y.RequestType6 = Uh;
      var Gh = class extends Qe {
        constructor(e) {
          super(e, 7);
        }
      };
      Y.RequestType7 = Gh;
      var Hh = class extends Qe {
        constructor(e) {
          super(e, 8);
        }
      };
      Y.RequestType8 = Hh;
      var Wh = class extends Qe {
        constructor(e) {
          super(e, 9);
        }
      };
      Y.RequestType9 = Wh;
      var Bh = class extends Qe {
        constructor(e, r = Lt.auto) {
          super(e, 1), this._parameterStructures = r;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      Y.NotificationType = Bh;
      var Kh = class extends Qe {
        constructor(e) {
          super(e, 0);
        }
      };
      Y.NotificationType0 = Kh;
      var zh = class extends Qe {
        constructor(e, r = Lt.auto) {
          super(e, 1), this._parameterStructures = r;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      Y.NotificationType1 = zh;
      var Vh = class extends Qe {
        constructor(e) {
          super(e, 2);
        }
      };
      Y.NotificationType2 = Vh;
      var Yh = class extends Qe {
        constructor(e) {
          super(e, 3);
        }
      };
      Y.NotificationType3 = Yh;
      var Xh = class extends Qe {
        constructor(e) {
          super(e, 4);
        }
      };
      Y.NotificationType4 = Xh;
      var Jh = class extends Qe {
        constructor(e) {
          super(e, 5);
        }
      };
      Y.NotificationType5 = Jh;
      var Qh = class extends Qe {
        constructor(e) {
          super(e, 6);
        }
      };
      Y.NotificationType6 = Qh;
      var Zh = class extends Qe {
        constructor(e) {
          super(e, 7);
        }
      };
      Y.NotificationType7 = Zh;
      var em = class extends Qe {
        constructor(e) {
          super(e, 8);
        }
      };
      Y.NotificationType8 = em;
      var tm = class extends Qe {
        constructor(e) {
          super(e, 9);
        }
      };
      Y.NotificationType9 = tm;
      (function(t) {
        function e(i) {
          let o = i;
          return o && Ho.string(o.method) && (Ho.string(o.id) || Ho.number(o.id));
        }
        t.isRequest = e;
        function r(i) {
          let o = i;
          return o && Ho.string(o.method) && i.id === void 0;
        }
        t.isNotification = r;
        function n(i) {
          let o = i;
          return o && (o.result !== void 0 || !!o.error) && (Ho.string(o.id) || Ho.number(o.id) || o.id === null);
        }
        t.isResponse = n;
      })(Y.Message || (Y.Message = {}));
    });
    var im = f((Ri) => {
      var GR;
      Object.defineProperty(Ri, "__esModule", { value: true });
      Ri.LRUCache = Ri.LinkedMap = Ri.Touch = void 0;
      var ar;
      (function(t) {
        t.None = 0, t.First = 1, t.AsOld = t.First, t.Last = 2, t.AsNew = t.Last;
      })(ar = Ri.Touch || (Ri.Touch = {}));
      var ml = class {
        constructor() {
          this[GR] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
        }
        clear() {
          this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          var _a;
          return (_a = this._head) == null ? void 0 : _a.value;
        }
        get last() {
          var _a;
          return (_a = this._tail) == null ? void 0 : _a.value;
        }
        has(e) {
          return this._map.has(e);
        }
        get(e, r = ar.None) {
          let n = this._map.get(e);
          if (n)
            return r !== ar.None && this.touch(n, r), n.value;
        }
        set(e, r, n = ar.None) {
          let i = this._map.get(e);
          if (i)
            i.value = r, n !== ar.None && this.touch(i, n);
          else {
            switch (i = { key: e, value: r, next: void 0, previous: void 0 }, n) {
              case ar.None:
                this.addItemLast(i);
                break;
              case ar.First:
                this.addItemFirst(i);
                break;
              case ar.Last:
                this.addItemLast(i);
                break;
              default:
                this.addItemLast(i);
                break;
            }
            this._map.set(e, i), this._size++;
          }
          return this;
        }
        delete(e) {
          return !!this.remove(e);
        }
        remove(e) {
          let r = this._map.get(e);
          if (r)
            return this._map.delete(e), this.removeItem(r), this._size--, r.value;
        }
        shift() {
          if (!this._head && !this._tail)
            return;
          if (!this._head || !this._tail)
            throw new Error("Invalid list");
          let e = this._head;
          return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
        }
        forEach(e, r) {
          let n = this._state, i = this._head;
          for (; i; ) {
            if (r ? e.bind(r)(i.value, i.key, this) : e(i.value, i.key, this), this._state !== n)
              throw new Error("LinkedMap got modified during iteration.");
            i = i.next;
          }
        }
        keys() {
          let e = this._state, r = this._head, n = { [Symbol.iterator]: () => n, next: () => {
            if (this._state !== e)
              throw new Error("LinkedMap got modified during iteration.");
            if (r) {
              let i = { value: r.key, done: false };
              return r = r.next, i;
            } else
              return { value: void 0, done: true };
          } };
          return n;
        }
        values() {
          let e = this._state, r = this._head, n = { [Symbol.iterator]: () => n, next: () => {
            if (this._state !== e)
              throw new Error("LinkedMap got modified during iteration.");
            if (r) {
              let i = { value: r.value, done: false };
              return r = r.next, i;
            } else
              return { value: void 0, done: true };
          } };
          return n;
        }
        entries() {
          let e = this._state, r = this._head, n = { [Symbol.iterator]: () => n, next: () => {
            if (this._state !== e)
              throw new Error("LinkedMap got modified during iteration.");
            if (r) {
              let i = { value: [r.key, r.value], done: false };
              return r = r.next, i;
            } else
              return { value: void 0, done: true };
          } };
          return n;
        }
        [(GR = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(e) {
          if (e >= this.size)
            return;
          if (e === 0) {
            this.clear();
            return;
          }
          let r = this._head, n = this.size;
          for (; r && n > e; )
            this._map.delete(r.key), r = r.next, n--;
          this._head = r, this._size = n, r && (r.previous = void 0), this._state++;
        }
        addItemFirst(e) {
          if (!this._head && !this._tail)
            this._tail = e;
          else if (this._head)
            e.next = this._head, this._head.previous = e;
          else
            throw new Error("Invalid list");
          this._head = e, this._state++;
        }
        addItemLast(e) {
          if (!this._head && !this._tail)
            this._head = e;
          else if (this._tail)
            e.previous = this._tail, this._tail.next = e;
          else
            throw new Error("Invalid list");
          this._tail = e, this._state++;
        }
        removeItem(e) {
          if (e === this._head && e === this._tail)
            this._head = void 0, this._tail = void 0;
          else if (e === this._head) {
            if (!e.next)
              throw new Error("Invalid list");
            e.next.previous = void 0, this._head = e.next;
          } else if (e === this._tail) {
            if (!e.previous)
              throw new Error("Invalid list");
            e.previous.next = void 0, this._tail = e.previous;
          } else {
            let r = e.next, n = e.previous;
            if (!r || !n)
              throw new Error("Invalid list");
            r.previous = n, n.next = r;
          }
          e.next = void 0, e.previous = void 0, this._state++;
        }
        touch(e, r) {
          if (!this._head || !this._tail)
            throw new Error("Invalid list");
          if (!(r !== ar.First && r !== ar.Last)) {
            if (r === ar.First) {
              if (e === this._head)
                return;
              let n = e.next, i = e.previous;
              e === this._tail ? (i.next = void 0, this._tail = i) : (n.previous = i, i.next = n), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
            } else if (r === ar.Last) {
              if (e === this._tail)
                return;
              let n = e.next, i = e.previous;
              e === this._head ? (n.previous = void 0, this._head = n) : (n.previous = i, i.next = n), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
            }
          }
        }
        toJSON() {
          let e = [];
          return this.forEach((r, n) => {
            e.push([n, r]);
          }), e;
        }
        fromJSON(e) {
          this.clear();
          for (let [r, n] of e)
            this.set(r, n);
        }
      };
      Ri.LinkedMap = ml;
      var nm = class extends ml {
        constructor(e, r = 1) {
          super(), this._limit = e, this._ratio = Math.min(Math.max(0, r), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(e) {
          this._limit = e, this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(e) {
          this._ratio = Math.min(Math.max(0, e), 1), this.checkTrim();
        }
        get(e, r = ar.AsNew) {
          return super.get(e, r);
        }
        peek(e) {
          return super.get(e, ar.None);
        }
        set(e, r) {
          return super.set(e, r, ar.Last), this.checkTrim(), this;
        }
        checkTrim() {
          this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio));
        }
      };
      Ri.LRUCache = nm;
    });
    var um = f((Wo) => {
      Object.defineProperty(Wo, "__esModule", { value: true });
      Wo.CancellationTokenSource = Wo.CancellationToken = void 0;
      var D$ = _i(), I$ = qa(), om = Go(), am;
      (function(t) {
        t.None = Object.freeze({ isCancellationRequested: false, onCancellationRequested: om.Event.None }), t.Cancelled = Object.freeze({ isCancellationRequested: true, onCancellationRequested: om.Event.None });
        function e(r) {
          let n = r;
          return n && (n === t.None || n === t.Cancelled || I$.boolean(n.isCancellationRequested) && !!n.onCancellationRequested);
        }
        t.is = e;
      })(am = Wo.CancellationToken || (Wo.CancellationToken = {}));
      var x$ = Object.freeze(function(t, e) {
        let r = (0, D$.default)().timer.setTimeout(t.bind(e), 0);
        return { dispose() {
          r.dispose();
        } };
      }), gl = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          this._isCancelled || (this._isCancelled = true, this._emitter && (this._emitter.fire(void 0), this.dispose()));
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          return this._isCancelled ? x$ : (this._emitter || (this._emitter = new om.Emitter()), this._emitter.event);
        }
        dispose() {
          this._emitter && (this._emitter.dispose(), this._emitter = void 0);
        }
      }, sm = class {
        get token() {
          return this._token || (this._token = new gl()), this._token;
        }
        cancel() {
          this._token ? this._token.cancel() : this._token = am.Cancelled;
        }
        dispose() {
          this._token ? this._token instanceof gl && this._token.dispose() : this._token = am.None;
        }
      };
      Wo.CancellationTokenSource = sm;
    });
    var HR = f((bi) => {
      Object.defineProperty(bi, "__esModule", { value: true });
      bi.ReadableStreamMessageReader = bi.AbstractMessageReader = bi.MessageReader = void 0;
      var lm = _i(), La = qa(), cm = Go();
      (function(t) {
        function e(r) {
          let n = r;
          return n && La.func(n.listen) && La.func(n.dispose) && La.func(n.onError) && La.func(n.onClose) && La.func(n.onPartialMessage);
        }
        t.is = e;
      })(bi.MessageReader || (bi.MessageReader = {}));
      var yl = class {
        constructor() {
          this.errorEmitter = new cm.Emitter(), this.closeEmitter = new cm.Emitter(), this.partialMessageEmitter = new cm.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose(), this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(e) {
          this.errorEmitter.fire(this.asError(e));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(e) {
          this.partialMessageEmitter.fire(e);
        }
        asError(e) {
          return e instanceof Error ? e : new Error(`Reader received error. Reason: ${La.string(e.message) ? e.message : "unknown"}`);
        }
      };
      bi.AbstractMessageReader = yl;
      var dm;
      (function(t) {
        function e(r) {
          let n, o, a = /* @__PURE__ */ new Map(), s, u = /* @__PURE__ */ new Map();
          if (r === void 0 || typeof r == "string")
            n = r ?? "utf-8";
          else {
            if (n = r.charset ?? "utf-8", r.contentDecoder !== void 0 && (o = r.contentDecoder, a.set(o.name, o)), r.contentDecoders !== void 0)
              for (let c of r.contentDecoders)
                a.set(c.name, c);
            if (r.contentTypeDecoder !== void 0 && (s = r.contentTypeDecoder, u.set(s.name, s)), r.contentTypeDecoders !== void 0)
              for (let c of r.contentTypeDecoders)
                u.set(c.name, c);
          }
          return s === void 0 && (s = (0, lm.default)().applicationJson.decoder, u.set(s.name, s)), { charset: n, contentDecoder: o, contentDecoders: a, contentTypeDecoder: s, contentTypeDecoders: u };
        }
        t.fromOptions = e;
      })(dm || (dm = {}));
      var fm = class extends yl {
        constructor(e, r) {
          super(), this.readable = e, this.options = dm.fromOptions(r), this.buffer = (0, lm.default)().messageBuffer.create(this.options.charset), this._partialMessageTimeout = 1e4, this.nextMessageLength = -1, this.messageToken = 0;
        }
        set partialMessageTimeout(e) {
          this._partialMessageTimeout = e;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(e) {
          this.nextMessageLength = -1, this.messageToken = 0, this.partialMessageTimer = void 0, this.callback = e;
          let r = this.readable.onData((n) => {
            this.onData(n);
          });
          return this.readable.onError((n) => this.fireError(n)), this.readable.onClose(() => this.fireClose()), r;
        }
        onData(e) {
          for (this.buffer.append(e); ; ) {
            if (this.nextMessageLength === -1) {
              let i = this.buffer.tryReadHeaders();
              if (!i)
                return;
              let o = i.get("Content-Length");
              if (!o)
                throw new Error("Header must provide a Content-Length property.");
              let a = parseInt(o);
              if (isNaN(a))
                throw new Error("Content-Length value must be a number.");
              this.nextMessageLength = a;
            }
            let r = this.buffer.tryReadBody(this.nextMessageLength);
            if (r === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer(), this.nextMessageLength = -1;
            let n;
            this.options.contentDecoder !== void 0 ? n = this.options.contentDecoder.decode(r) : n = Promise.resolve(r), n.then((i) => {
              this.options.contentTypeDecoder.decode(i, this.options).then((o) => {
                this.callback(o);
              }, (o) => {
                this.fireError(o);
              });
            }, (i) => {
              this.fireError(i);
            });
          }
        }
        clearPartialMessageTimer() {
          this.partialMessageTimer && (this.partialMessageTimer.dispose(), this.partialMessageTimer = void 0);
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer(), !(this._partialMessageTimeout <= 0) && (this.partialMessageTimer = (0, lm.default)().timer.setTimeout((e, r) => {
            this.partialMessageTimer = void 0, e === this.messageToken && (this.firePartialMessage({ messageToken: e, waitingTime: r }), this.setPartialMessageTimer());
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout));
        }
      };
      bi.ReadableStreamMessageReader = fm;
    });
    var WR = f((vl) => {
      Object.defineProperty(vl, "__esModule", { value: true });
      vl.Semaphore = void 0;
      var L$ = _i(), pm = class {
        constructor(e = 1) {
          if (e <= 0)
            throw new Error("Capacity must be greater than 0");
          this._capacity = e, this._active = 0, this._waiting = [];
        }
        lock(e) {
          return new Promise((r, n) => {
            this._waiting.push({ thunk: e, resolve: r, reject: n }), this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          this._waiting.length === 0 || this._active === this._capacity || (0, L$.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity)
            return;
          let e = this._waiting.shift();
          if (this._active++, this._active > this._capacity)
            throw new Error("To many thunks active");
          try {
            let r = e.thunk();
            r instanceof Promise ? r.then((n) => {
              this._active--, e.resolve(n), this.runNext();
            }, (n) => {
              this._active--, e.reject(n), this.runNext();
            }) : (this._active--, e.resolve(r), this.runNext());
          } catch (r) {
            this._active--, e.reject(r), this.runNext();
          }
        }
      };
      vl.Semaphore = pm;
    });
    var VR = f((Si) => {
      Object.defineProperty(Si, "__esModule", { value: true });
      Si.WriteableStreamMessageWriter = Si.AbstractMessageWriter = Si.MessageWriter = void 0;
      var BR = _i(), Nu = qa(), M$ = WR(), KR = Go(), $$ = "Content-Length: ", zR = `\r
`;
      (function(t) {
        function e(r) {
          let n = r;
          return n && Nu.func(n.dispose) && Nu.func(n.onClose) && Nu.func(n.onError) && Nu.func(n.write);
        }
        t.is = e;
      })(Si.MessageWriter || (Si.MessageWriter = {}));
      var Tl = class {
        constructor() {
          this.errorEmitter = new KR.Emitter(), this.closeEmitter = new KR.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose(), this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(e, r, n) {
          this.errorEmitter.fire([this.asError(e), r, n]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(e) {
          return e instanceof Error ? e : new Error(`Writer received error. Reason: ${Nu.string(e.message) ? e.message : "unknown"}`);
        }
      };
      Si.AbstractMessageWriter = Tl;
      var hm;
      (function(t) {
        function e(r) {
          return r === void 0 || typeof r == "string" ? { charset: r ?? "utf-8", contentTypeEncoder: (0, BR.default)().applicationJson.encoder } : { charset: r.charset ?? "utf-8", contentEncoder: r.contentEncoder, contentTypeEncoder: r.contentTypeEncoder ?? (0, BR.default)().applicationJson.encoder };
        }
        t.fromOptions = e;
      })(hm || (hm = {}));
      var mm = class extends Tl {
        constructor(e, r) {
          super(), this.writable = e, this.options = hm.fromOptions(r), this.errorCount = 0, this.writeSemaphore = new M$.Semaphore(1), this.writable.onError((n) => this.fireError(n)), this.writable.onClose(() => this.fireClose());
        }
        async write(e) {
          return this.writeSemaphore.lock(async () => this.options.contentTypeEncoder.encode(e, this.options).then((n) => this.options.contentEncoder !== void 0 ? this.options.contentEncoder.encode(n) : n).then((n) => {
            let i = [];
            return i.push($$, n.byteLength.toString(), zR), i.push(zR), this.doWrite(e, i, n);
          }, (n) => {
            throw this.fireError(n), n;
          }));
        }
        async doWrite(e, r, n) {
          try {
            return await this.writable.write(r.join(""), "ascii"), this.writable.write(n);
          } catch (i) {
            return this.handleError(i, e), Promise.reject(i);
          }
        }
        handleError(e, r) {
          this.errorCount++, this.fireError(e, r, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      Si.WriteableStreamMessageWriter = mm;
    });
    var e0 = f((Q) => {
      Object.defineProperty(Q, "__esModule", { value: true });
      Q.createMessageConnection = Q.ConnectionOptions = Q.CancellationStrategy = Q.CancellationSenderStrategy = Q.CancellationReceiverStrategy = Q.ConnectionStrategy = Q.ConnectionError = Q.ConnectionErrors = Q.LogTraceNotification = Q.SetTraceNotification = Q.TraceFormat = Q.TraceValues = Q.Trace = Q.NullLogger = Q.ProgressType = Q.ProgressToken = void 0;
      var YR = _i(), Dt = qa(), ee = rm(), XR = im(), Eu = Go(), gm = um(), wu;
      (function(t) {
        t.type = new ee.NotificationType("$/cancelRequest");
      })(wu || (wu = {}));
      var JR;
      (function(t) {
        function e(r) {
          return typeof r == "string" || typeof r == "number";
        }
        t.is = e;
      })(JR = Q.ProgressToken || (Q.ProgressToken = {}));
      var ku;
      (function(t) {
        t.type = new ee.NotificationType("$/progress");
      })(ku || (ku = {}));
      var ym = class {
        constructor() {
        }
      };
      Q.ProgressType = ym;
      var vm;
      (function(t) {
        function e(r) {
          return Dt.func(r);
        }
        t.is = e;
      })(vm || (vm = {}));
      Q.NullLogger = Object.freeze({ error: () => {
      }, warn: () => {
      }, info: () => {
      }, log: () => {
      } });
      var Ie;
      (function(t) {
        t[t.Off = 0] = "Off", t[t.Messages = 1] = "Messages", t[t.Compact = 2] = "Compact", t[t.Verbose = 3] = "Verbose";
      })(Ie = Q.Trace || (Q.Trace = {}));
      (function(t) {
        t.Off = "off", t.Messages = "messages", t.Compact = "compact", t.Verbose = "verbose";
      })(Q.TraceValues || (Q.TraceValues = {}));
      (function(t) {
        function e(n) {
          if (!Dt.string(n))
            return t.Off;
          switch (n = n.toLowerCase(), n) {
            case "off":
              return t.Off;
            case "messages":
              return t.Messages;
            case "compact":
              return t.Compact;
            case "verbose":
              return t.Verbose;
            default:
              return t.Off;
          }
        }
        t.fromString = e;
        function r(n) {
          switch (n) {
            case t.Off:
              return "off";
            case t.Messages:
              return "messages";
            case t.Compact:
              return "compact";
            case t.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        t.toString = r;
      })(Ie = Q.Trace || (Q.Trace = {}));
      var ln;
      (function(t) {
        t.Text = "text", t.JSON = "json";
      })(ln = Q.TraceFormat || (Q.TraceFormat = {}));
      (function(t) {
        function e(r) {
          return Dt.string(r) ? (r = r.toLowerCase(), r === "json" ? t.JSON : t.Text) : t.Text;
        }
        t.fromString = e;
      })(ln = Q.TraceFormat || (Q.TraceFormat = {}));
      var QR;
      (function(t) {
        t.type = new ee.NotificationType("$/setTrace");
      })(QR = Q.SetTraceNotification || (Q.SetTraceNotification = {}));
      var Tm;
      (function(t) {
        t.type = new ee.NotificationType("$/logTrace");
      })(Tm = Q.LogTraceNotification || (Q.LogTraceNotification = {}));
      var _l;
      (function(t) {
        t[t.Closed = 1] = "Closed", t[t.Disposed = 2] = "Disposed", t[t.AlreadyListening = 3] = "AlreadyListening";
      })(_l = Q.ConnectionErrors || (Q.ConnectionErrors = {}));
      var Xi = class extends Error {
        constructor(e, r) {
          super(r), this.code = e, Object.setPrototypeOf(this, Xi.prototype);
        }
      };
      Q.ConnectionError = Xi;
      var ZR;
      (function(t) {
        function e(r) {
          let n = r;
          return n && Dt.func(n.cancelUndispatched);
        }
        t.is = e;
      })(ZR = Q.ConnectionStrategy || (Q.ConnectionStrategy = {}));
      var _m;
      (function(t) {
        t.Message = Object.freeze({ createCancellationTokenSource(r) {
          return new gm.CancellationTokenSource();
        } });
        function e(r) {
          let n = r;
          return n && Dt.func(n.createCancellationTokenSource);
        }
        t.is = e;
      })(_m = Q.CancellationReceiverStrategy || (Q.CancellationReceiverStrategy = {}));
      var Rm;
      (function(t) {
        t.Message = Object.freeze({ sendCancellation(r, n) {
          return r.sendNotification(wu.type, { id: n });
        }, cleanup(r) {
        } });
        function e(r) {
          let n = r;
          return n && Dt.func(n.sendCancellation) && Dt.func(n.cleanup);
        }
        t.is = e;
      })(Rm = Q.CancellationSenderStrategy || (Q.CancellationSenderStrategy = {}));
      var bm;
      (function(t) {
        t.Message = Object.freeze({ receiver: _m.Message, sender: Rm.Message });
        function e(r) {
          let n = r;
          return n && _m.is(n.receiver) && Rm.is(n.sender);
        }
        t.is = e;
      })(bm = Q.CancellationStrategy || (Q.CancellationStrategy = {}));
      (function(t) {
        function e(r) {
          let n = r;
          return n && (bm.is(n.cancellationStrategy) || ZR.is(n.connectionStrategy));
        }
        t.is = e;
      })(Q.ConnectionOptions || (Q.ConnectionOptions = {}));
      var dn;
      (function(t) {
        t[t.New = 1] = "New", t[t.Listening = 2] = "Listening", t[t.Closed = 3] = "Closed", t[t.Disposed = 4] = "Disposed";
      })(dn || (dn = {}));
      function G$(t, e, r, n) {
        let i = r !== void 0 ? r : Q.NullLogger, o = 0, a = 0, s = 0, u = "2.0", c, l = /* @__PURE__ */ new Map(), d, h = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), m, R = new XR.LinkedMap(), C = /* @__PURE__ */ new Map(), N = /* @__PURE__ */ new Set(), S = /* @__PURE__ */ new Map(), b = Ie.Off, O = ln.Text, L, W = dn.New, Z = new Eu.Emitter(), Ee = new Eu.Emitter(), ke = new Eu.Emitter(), Je = new Eu.Emitter(), K = new Eu.Emitter(), le = n && n.cancellationStrategy ? n.cancellationStrategy : bm.Message;
        function M(A) {
          if (A === null)
            throw new Error("Can't send requests with id null since the response can't be correlated.");
          return "req-" + A.toString();
        }
        function q(A) {
          return A === null ? "res-unknown-" + (++s).toString() : "res-" + A.toString();
        }
        function F() {
          return "not-" + (++a).toString();
        }
        function B(A, x) {
          ee.Message.isRequest(x) ? A.set(M(x.id), x) : ee.Message.isResponse(x) ? A.set(q(x.id), x) : A.set(F(), x);
        }
        function ie(A) {
        }
        function oe() {
          return W === dn.Listening;
        }
        function J() {
          return W === dn.Closed;
        }
        function lt() {
          return W === dn.Disposed;
        }
        function tt() {
          (W === dn.New || W === dn.Listening) && (W = dn.Closed, Ee.fire(void 0));
        }
        function Ot(A) {
          Z.fire([A, void 0, void 0]);
        }
        function nn(A) {
          Z.fire(A);
        }
        t.onClose(tt), t.onError(Ot), e.onClose(tt), e.onError(nn);
        function Nr() {
          m || R.size === 0 || (m = (0, YR.default)().timer.setImmediate(() => {
            m = void 0, Pa();
          }));
        }
        function Pa() {
          if (R.size === 0)
            return;
          let A = R.shift();
          try {
            ee.Message.isRequest(A) ? Ca(A) : ee.Message.isNotification(A) ? Ea(A) : ee.Message.isResponse(A) ? Na(A) : Su(A);
          } finally {
            Nr();
          }
        }
        let or = (A) => {
          try {
            if (ee.Message.isNotification(A) && A.method === wu.type.method) {
              let x = A.params.id, j = M(x), z = R.get(j);
              if (ee.Message.isRequest(z)) {
                let Ue = n == null ? void 0 : n.connectionStrategy, rt = Ue && Ue.cancelUndispatched ? Ue.cancelUndispatched(z, ie) : void 0;
                if (rt && (rt.error !== void 0 || rt.result !== void 0)) {
                  R.delete(j), S.delete(x), rt.id = z.id, xn(rt, A.method, Date.now()), e.write(rt).catch(() => i.error("Sending response for canceled message failed."));
                  return;
                }
              }
              let je = S.get(x);
              if (je !== void 0) {
                je.cancel(), qn(A);
                return;
              } else
                N.add(x);
            }
            B(R, A);
          } finally {
            Nr();
          }
        };
        function Ca(A) {
          if (lt())
            return;
          function x(ge, Be, Te) {
            let gt = { jsonrpc: u, id: A.id };
            ge instanceof ee.ResponseError ? gt.error = ge.toJson() : gt.result = ge === void 0 ? null : ge, xn(gt, Be, Te), e.write(gt).catch(() => i.error("Sending response failed."));
          }
          function j(ge, Be, Te) {
            let gt = { jsonrpc: u, id: A.id, error: ge.toJson() };
            xn(gt, Be, Te), e.write(gt).catch(() => i.error("Sending response failed."));
          }
          function z(ge, Be, Te) {
            ge === void 0 && (ge = null);
            let gt = { jsonrpc: u, id: A.id, result: ge };
            xn(gt, Be, Te), e.write(gt).catch(() => i.error("Sending response failed."));
          }
          Fo(A);
          let je = l.get(A.method), Ue, rt;
          je && (Ue = je.type, rt = je.handler);
          let Tt = Date.now();
          if (rt || c) {
            let ge = A.id ?? String(Date.now()), Be = le.receiver.createCancellationTokenSource(ge);
            A.id !== null && N.has(A.id) && Be.cancel(), A.id !== null && S.set(ge, Be);
            try {
              let Te;
              if (rt)
                if (A.params === void 0) {
                  if (Ue !== void 0 && Ue.numberOfParams !== 0) {
                    j(new ee.ResponseError(ee.ErrorCodes.InvalidParams, `Request ${A.method} defines ${Ue.numberOfParams} params but received none.`), A.method, Tt);
                    return;
                  }
                  Te = rt(Be.token);
                } else if (Array.isArray(A.params)) {
                  if (Ue !== void 0 && Ue.parameterStructures === ee.ParameterStructures.byName) {
                    j(new ee.ResponseError(ee.ErrorCodes.InvalidParams, `Request ${A.method} defines parameters by name but received parameters by position`), A.method, Tt);
                    return;
                  }
                  Te = rt(...A.params, Be.token);
                } else {
                  if (Ue !== void 0 && Ue.parameterStructures === ee.ParameterStructures.byPosition) {
                    j(new ee.ResponseError(ee.ErrorCodes.InvalidParams, `Request ${A.method} defines parameters by position but received parameters by name`), A.method, Tt);
                    return;
                  }
                  Te = rt(A.params, Be.token);
                }
              else
                c && (Te = c(A.method, A.params, Be.token));
              let gt = Te;
              Te ? gt.then ? gt.then((Xt) => {
                S.delete(ge), x(Xt, A.method, Tt);
              }, (Xt) => {
                S.delete(ge), Xt instanceof ee.ResponseError ? j(Xt, A.method, Tt) : Xt && Dt.string(Xt.message) ? j(new ee.ResponseError(ee.ErrorCodes.InternalError, `Request ${A.method} failed with message: ${Xt.message}`), A.method, Tt) : j(new ee.ResponseError(ee.ErrorCodes.InternalError, `Request ${A.method} failed unexpectedly without providing any details.`), A.method, Tt);
              }) : (S.delete(ge), x(Te, A.method, Tt)) : (S.delete(ge), z(Te, A.method, Tt));
            } catch (Te) {
              S.delete(ge), Te instanceof ee.ResponseError ? x(Te, A.method, Tt) : Te && Dt.string(Te.message) ? j(new ee.ResponseError(ee.ErrorCodes.InternalError, `Request ${A.method} failed with message: ${Te.message}`), A.method, Tt) : j(new ee.ResponseError(ee.ErrorCodes.InternalError, `Request ${A.method} failed unexpectedly without providing any details.`), A.method, Tt);
            }
          } else
            j(new ee.ResponseError(ee.ErrorCodes.MethodNotFound, `Unhandled method ${A.method}`), A.method, Tt);
        }
        function Na(A) {
          if (!lt())
            if (A.id === null)
              A.error ? i.error(`Received response message without id: Error is: 
${JSON.stringify(A.error, void 0, 4)}`) : i.error("Received response message without id. No further error information provided.");
            else {
              let x = A.id, j = C.get(x);
              if (jo(A, j), j !== void 0) {
                C.delete(x);
                try {
                  if (A.error) {
                    let z = A.error;
                    j.reject(new ee.ResponseError(z.code, z.message, z.data));
                  } else if (A.result !== void 0)
                    j.resolve(A.result);
                  else
                    throw new Error("Should never happen.");
                } catch (z) {
                  z.message ? i.error(`Response handler '${j.method}' failed with message: ${z.message}`) : i.error(`Response handler '${j.method}' failed unexpectedly.`);
                }
              }
            }
        }
        function Ea(A) {
          if (lt())
            return;
          let x, j;
          if (A.method === wu.type.method) {
            let z = A.params.id;
            N.delete(z), qn(A);
            return;
          } else {
            let z = h.get(A.method);
            z && (j = z.handler, x = z.type);
          }
          if (j || d)
            try {
              if (qn(A), j)
                if (A.params === void 0)
                  x !== void 0 && x.numberOfParams !== 0 && x.parameterStructures !== ee.ParameterStructures.byName && i.error(`Notification ${A.method} defines ${x.numberOfParams} params but received none.`), j();
                else if (Array.isArray(A.params)) {
                  let z = A.params;
                  A.method === ku.type.method && z.length === 2 && JR.is(z[0]) ? j({ token: z[0], value: z[1] }) : (x !== void 0 && (x.parameterStructures === ee.ParameterStructures.byName && i.error(`Notification ${A.method} defines parameters by name but received parameters by position`), x.numberOfParams !== A.params.length && i.error(`Notification ${A.method} defines ${x.numberOfParams} params but received ${z.length} arguments`)), j(...z));
                } else
                  x !== void 0 && x.parameterStructures === ee.ParameterStructures.byPosition && i.error(`Notification ${A.method} defines parameters by position but received parameters by name`), j(A.params);
              else
                d && d(A.method, A.params);
            } catch (z) {
              z.message ? i.error(`Notification handler '${A.method}' failed with message: ${z.message}`) : i.error(`Notification handler '${A.method}' failed unexpectedly.`);
            }
          else
            ke.fire(A);
        }
        function Su(A) {
          if (!A) {
            i.error("Received empty message.");
            return;
          }
          i.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(A, null, 4)}`);
          let x = A;
          if (Dt.string(x.id) || Dt.number(x.id)) {
            let j = x.id, z = C.get(j);
            z && z.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
        function mt(A) {
          if (A != null)
            switch (b) {
              case Ie.Verbose:
                return JSON.stringify(A, null, 4);
              case Ie.Compact:
                return JSON.stringify(A);
              default:
                return;
            }
        }
        function yi(A) {
          if (!(b === Ie.Off || !L))
            if (O === ln.Text) {
              let x;
              (b === Ie.Verbose || b === Ie.Compact) && A.params && (x = `Params: ${mt(A.params)}

`), L.log(`Sending request '${A.method} - (${A.id})'.`, x);
            } else
              Mr("send-request", A);
        }
        function Au(A) {
          if (!(b === Ie.Off || !L))
            if (O === ln.Text) {
              let x;
              (b === Ie.Verbose || b === Ie.Compact) && (A.params ? x = `Params: ${mt(A.params)}

` : x = `No parameters provided.

`), L.log(`Sending notification '${A.method}'.`, x);
            } else
              Mr("send-notification", A);
        }
        function xn(A, x, j) {
          if (!(b === Ie.Off || !L))
            if (O === ln.Text) {
              let z;
              (b === Ie.Verbose || b === Ie.Compact) && (A.error && A.error.data ? z = `Error data: ${mt(A.error.data)}

` : A.result ? z = `Result: ${mt(A.result)}

` : A.error === void 0 && (z = `No result returned.

`)), L.log(`Sending response '${x} - (${A.id})'. Processing request took ${Date.now() - j}ms`, z);
            } else
              Mr("send-response", A);
        }
        function Fo(A) {
          if (!(b === Ie.Off || !L))
            if (O === ln.Text) {
              let x;
              (b === Ie.Verbose || b === Ie.Compact) && A.params && (x = `Params: ${mt(A.params)}

`), L.log(`Received request '${A.method} - (${A.id})'.`, x);
            } else
              Mr("receive-request", A);
        }
        function qn(A) {
          if (!(b === Ie.Off || !L || A.method === Tm.type.method))
            if (O === ln.Text) {
              let x;
              (b === Ie.Verbose || b === Ie.Compact) && (A.params ? x = `Params: ${mt(A.params)}

` : x = `No parameters provided.

`), L.log(`Received notification '${A.method}'.`, x);
            } else
              Mr("receive-notification", A);
        }
        function jo(A, x) {
          if (!(b === Ie.Off || !L))
            if (O === ln.Text) {
              let j;
              if ((b === Ie.Verbose || b === Ie.Compact) && (A.error && A.error.data ? j = `Error data: ${mt(A.error.data)}

` : A.result ? j = `Result: ${mt(A.result)}

` : A.error === void 0 && (j = `No result returned.

`)), x) {
                let z = A.error ? ` Request failed: ${A.error.message} (${A.error.code}).` : "";
                L.log(`Received response '${x.method} - (${A.id})' in ${Date.now() - x.timerStart}ms.${z}`, j);
              } else
                L.log(`Received response ${A.id} without active response promise.`, j);
            } else
              Mr("receive-response", A);
        }
        function Mr(A, x) {
          if (!L || b === Ie.Off)
            return;
          let j = { isLSPMessage: true, type: A, message: x, timestamp: Date.now() };
          L.log(j);
        }
        function on() {
          if (J())
            throw new Xi(_l.Closed, "Connection is closed.");
          if (lt())
            throw new Xi(_l.Disposed, "Connection is disposed.");
        }
        function ka() {
          if (oe())
            throw new Xi(_l.AlreadyListening, "Connection is already listening");
        }
        function wa() {
          if (!oe())
            throw new Error("Call listen() first.");
        }
        function Er(A) {
          return A === void 0 ? null : A;
        }
        function Ln(A) {
          if (A !== null)
            return A;
        }
        function qt(A) {
          return A != null && !Array.isArray(A) && typeof A == "object";
        }
        function an(A, x) {
          switch (A) {
            case ee.ParameterStructures.auto:
              return qt(x) ? Ln(x) : [Er(x)];
            case ee.ParameterStructures.byName:
              if (!qt(x))
                throw new Error("Received parameters by name but param is not an object literal.");
              return Ln(x);
            case ee.ParameterStructures.byPosition:
              return [Er(x)];
            default:
              throw new Error(`Unknown parameter structure ${A.toString()}`);
          }
        }
        function sn(A, x) {
          let j, z = A.numberOfParams;
          switch (z) {
            case 0:
              j = void 0;
              break;
            case 1:
              j = an(A.parameterStructures, x[0]);
              break;
            default:
              j = [];
              for (let je = 0; je < x.length && je < z; je++)
                j.push(Er(x[je]));
              if (x.length < z)
                for (let je = x.length; je < z; je++)
                  j.push(null);
              break;
          }
          return j;
        }
        let Mn = { sendNotification: (A, ...x) => {
          on();
          let j, z;
          if (Dt.string(A)) {
            j = A;
            let Ue = x[0], rt = 0, Tt = ee.ParameterStructures.auto;
            ee.ParameterStructures.is(Ue) && (rt = 1, Tt = Ue);
            let ge = x.length, Be = ge - rt;
            switch (Be) {
              case 0:
                z = void 0;
                break;
              case 1:
                z = an(Tt, x[rt]);
                break;
              default:
                if (Tt === ee.ParameterStructures.byName)
                  throw new Error(`Received ${Be} parameters for 'by Name' notification parameter structure.`);
                z = x.slice(rt, ge).map((Te) => Er(Te));
                break;
            }
          } else {
            let Ue = x;
            j = A.method, z = sn(A, Ue);
          }
          let je = { jsonrpc: u, method: j, params: z };
          return Au(je), e.write(je).catch(() => i.error("Sending notification failed."));
        }, onNotification: (A, x) => {
          on();
          let j;
          return Dt.func(A) ? d = A : x && (Dt.string(A) ? (j = A, h.set(A, { type: void 0, handler: x })) : (j = A.method, h.set(A.method, { type: A, handler: x }))), { dispose: () => {
            j !== void 0 ? h.delete(j) : d = void 0;
          } };
        }, onProgress: (A, x, j) => {
          if (y.has(x))
            throw new Error(`Progress handler for token ${x} already registered`);
          return y.set(x, j), { dispose: () => {
            y.delete(x);
          } };
        }, sendProgress: (A, x, j) => Mn.sendNotification(ku.type, { token: x, value: j }), onUnhandledProgress: Je.event, sendRequest: (A, ...x) => {
          on(), wa();
          let j, z, je;
          if (Dt.string(A)) {
            j = A;
            let ge = x[0], Be = x[x.length - 1], Te = 0, gt = ee.ParameterStructures.auto;
            ee.ParameterStructures.is(ge) && (Te = 1, gt = ge);
            let Xt = x.length;
            gm.CancellationToken.is(Be) && (Xt = Xt - 1, je = Be);
            let vi = Xt - Te;
            switch (vi) {
              case 0:
                z = void 0;
                break;
              case 1:
                z = an(gt, x[Te]);
                break;
              default:
                if (gt === ee.ParameterStructures.byName)
                  throw new Error(`Received ${vi} parameters for 'by Name' request parameter structure.`);
                z = x.slice(Te, Xt).map(($n) => Er($n));
                break;
            }
          } else {
            let ge = x;
            j = A.method, z = sn(A, ge);
            let Be = A.numberOfParams;
            je = gm.CancellationToken.is(ge[Be]) ? ge[Be] : void 0;
          }
          let Ue = o++, rt;
          return je && (rt = je.onCancellationRequested(() => {
            let ge = le.sender.sendCancellation(Mn, Ue);
            return ge === void 0 ? (i.log(`Received no promise from cancellation strategy when cancelling id ${Ue}`), Promise.resolve()) : ge.catch(() => {
              i.log(`Sending cancellation messages for id ${Ue} failed`);
            });
          })), new Promise((ge, Be) => {
            let Te = { jsonrpc: u, id: Ue, method: j, params: z }, gt = ($n) => {
              ge($n), le.sender.cleanup(Ue), rt == null ? void 0 : rt.dispose();
            }, Xt = ($n) => {
              Be($n), le.sender.cleanup(Ue), rt == null ? void 0 : rt.dispose();
            }, vi = { method: j, timerStart: Date.now(), resolve: gt, reject: Xt };
            yi(Te);
            try {
              e.write(Te).catch(() => i.error("Sending request failed."));
            } catch ($n) {
              vi.reject(new ee.ResponseError(ee.ErrorCodes.MessageWriteError, $n.message ? $n.message : "Unknown reason")), vi = null;
            }
            vi && C.set(Ue, vi);
          });
        }, onRequest: (A, x) => {
          on();
          let j = null;
          return vm.is(A) ? (j = void 0, c = A) : Dt.string(A) ? (j = null, x !== void 0 && (j = A, l.set(A, { handler: x, type: void 0 }))) : x !== void 0 && (j = A.method, l.set(A.method, { type: A, handler: x })), { dispose: () => {
            j !== null && (j !== void 0 ? l.delete(j) : c = void 0);
          } };
        }, hasPendingResponse: () => C.size > 0, trace: async (A, x, j) => {
          let z = false, je = ln.Text;
          j !== void 0 && (Dt.boolean(j) ? z = j : (z = j.sendNotification || false, je = j.traceFormat || ln.Text)), b = A, O = je, b === Ie.Off ? L = void 0 : L = x, z && !J() && !lt() && await Mn.sendNotification(QR.type, { value: Ie.toString(A) });
        }, onError: Z.event, onClose: Ee.event, onUnhandledNotification: ke.event, onDispose: K.event, end: () => {
          e.end();
        }, dispose: () => {
          if (lt())
            return;
          W = dn.Disposed, K.fire(void 0);
          let A = new ee.ResponseError(ee.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (let x of C.values())
            x.reject(A);
          C = /* @__PURE__ */ new Map(), S = /* @__PURE__ */ new Map(), N = /* @__PURE__ */ new Set(), R = new XR.LinkedMap(), Dt.func(e.dispose) && e.dispose(), Dt.func(t.dispose) && t.dispose();
        }, listen: () => {
          on(), ka(), W = dn.Listening, t.listen(or);
        }, inspect: () => {
          (0, YR.default)().console.log("inspect");
        } };
        return Mn.onNotification(Tm.type, (A) => {
          if (b === Ie.Off || !L)
            return;
          let x = b === Ie.Verbose || b === Ie.Compact;
          L.log(A.message, x ? A.verbose : void 0);
        }), Mn.onNotification(ku.type, (A) => {
          let x = y.get(A.token);
          x ? x(A.value) : Je.fire(A);
        }), Mn;
      }
      Q.createMessageConnection = G$;
    });
    var Cm = f((D) => {
      Object.defineProperty(D, "__esModule", { value: true });
      D.TraceFormat = D.TraceValues = D.Trace = D.ProgressType = D.ProgressToken = D.createMessageConnection = D.NullLogger = D.ConnectionOptions = D.ConnectionStrategy = D.WriteableStreamMessageWriter = D.AbstractMessageWriter = D.MessageWriter = D.ReadableStreamMessageReader = D.AbstractMessageReader = D.MessageReader = D.CancellationToken = D.CancellationTokenSource = D.Emitter = D.Event = D.Disposable = D.LRUCache = D.Touch = D.LinkedMap = D.ParameterStructures = D.NotificationType9 = D.NotificationType8 = D.NotificationType7 = D.NotificationType6 = D.NotificationType5 = D.NotificationType4 = D.NotificationType3 = D.NotificationType2 = D.NotificationType1 = D.NotificationType0 = D.NotificationType = D.ErrorCodes = D.ResponseError = D.RequestType9 = D.RequestType8 = D.RequestType7 = D.RequestType6 = D.RequestType5 = D.RequestType4 = D.RequestType3 = D.RequestType2 = D.RequestType1 = D.RequestType0 = D.RequestType = D.Message = D.RAL = void 0;
      D.CancellationStrategy = D.CancellationSenderStrategy = D.CancellationReceiverStrategy = D.ConnectionError = D.ConnectionErrors = D.LogTraceNotification = D.SetTraceNotification = void 0;
      var ze = rm();
      Object.defineProperty(D, "Message", { enumerable: true, get: function() {
        return ze.Message;
      } });
      Object.defineProperty(D, "RequestType", { enumerable: true, get: function() {
        return ze.RequestType;
      } });
      Object.defineProperty(D, "RequestType0", { enumerable: true, get: function() {
        return ze.RequestType0;
      } });
      Object.defineProperty(D, "RequestType1", { enumerable: true, get: function() {
        return ze.RequestType1;
      } });
      Object.defineProperty(D, "RequestType2", { enumerable: true, get: function() {
        return ze.RequestType2;
      } });
      Object.defineProperty(D, "RequestType3", { enumerable: true, get: function() {
        return ze.RequestType3;
      } });
      Object.defineProperty(D, "RequestType4", { enumerable: true, get: function() {
        return ze.RequestType4;
      } });
      Object.defineProperty(D, "RequestType5", { enumerable: true, get: function() {
        return ze.RequestType5;
      } });
      Object.defineProperty(D, "RequestType6", { enumerable: true, get: function() {
        return ze.RequestType6;
      } });
      Object.defineProperty(D, "RequestType7", { enumerable: true, get: function() {
        return ze.RequestType7;
      } });
      Object.defineProperty(D, "RequestType8", { enumerable: true, get: function() {
        return ze.RequestType8;
      } });
      Object.defineProperty(D, "RequestType9", { enumerable: true, get: function() {
        return ze.RequestType9;
      } });
      Object.defineProperty(D, "ResponseError", { enumerable: true, get: function() {
        return ze.ResponseError;
      } });
      Object.defineProperty(D, "ErrorCodes", { enumerable: true, get: function() {
        return ze.ErrorCodes;
      } });
      Object.defineProperty(D, "NotificationType", { enumerable: true, get: function() {
        return ze.NotificationType;
      } });
      Object.defineProperty(D, "NotificationType0", { enumerable: true, get: function() {
        return ze.NotificationType0;
      } });
      Object.defineProperty(D, "NotificationType1", { enumerable: true, get: function() {
        return ze.NotificationType1;
      } });
      Object.defineProperty(D, "NotificationType2", { enumerable: true, get: function() {
        return ze.NotificationType2;
      } });
      Object.defineProperty(D, "NotificationType3", { enumerable: true, get: function() {
        return ze.NotificationType3;
      } });
      Object.defineProperty(D, "NotificationType4", { enumerable: true, get: function() {
        return ze.NotificationType4;
      } });
      Object.defineProperty(D, "NotificationType5", { enumerable: true, get: function() {
        return ze.NotificationType5;
      } });
      Object.defineProperty(D, "NotificationType6", { enumerable: true, get: function() {
        return ze.NotificationType6;
      } });
      Object.defineProperty(D, "NotificationType7", { enumerable: true, get: function() {
        return ze.NotificationType7;
      } });
      Object.defineProperty(D, "NotificationType8", { enumerable: true, get: function() {
        return ze.NotificationType8;
      } });
      Object.defineProperty(D, "NotificationType9", { enumerable: true, get: function() {
        return ze.NotificationType9;
      } });
      Object.defineProperty(D, "ParameterStructures", { enumerable: true, get: function() {
        return ze.ParameterStructures;
      } });
      var Sm = im();
      Object.defineProperty(D, "LinkedMap", { enumerable: true, get: function() {
        return Sm.LinkedMap;
      } });
      Object.defineProperty(D, "LRUCache", { enumerable: true, get: function() {
        return Sm.LRUCache;
      } });
      Object.defineProperty(D, "Touch", { enumerable: true, get: function() {
        return Sm.Touch;
      } });
      var H$ = Nh();
      Object.defineProperty(D, "Disposable", { enumerable: true, get: function() {
        return H$.Disposable;
      } });
      var t0 = Go();
      Object.defineProperty(D, "Event", { enumerable: true, get: function() {
        return t0.Event;
      } });
      Object.defineProperty(D, "Emitter", { enumerable: true, get: function() {
        return t0.Emitter;
      } });
      var r0 = um();
      Object.defineProperty(D, "CancellationTokenSource", { enumerable: true, get: function() {
        return r0.CancellationTokenSource;
      } });
      Object.defineProperty(D, "CancellationToken", { enumerable: true, get: function() {
        return r0.CancellationToken;
      } });
      var Am = HR();
      Object.defineProperty(D, "MessageReader", { enumerable: true, get: function() {
        return Am.MessageReader;
      } });
      Object.defineProperty(D, "AbstractMessageReader", { enumerable: true, get: function() {
        return Am.AbstractMessageReader;
      } });
      Object.defineProperty(D, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return Am.ReadableStreamMessageReader;
      } });
      var Pm = VR();
      Object.defineProperty(D, "MessageWriter", { enumerable: true, get: function() {
        return Pm.MessageWriter;
      } });
      Object.defineProperty(D, "AbstractMessageWriter", { enumerable: true, get: function() {
        return Pm.AbstractMessageWriter;
      } });
      Object.defineProperty(D, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return Pm.WriteableStreamMessageWriter;
      } });
      var Qt = e0();
      Object.defineProperty(D, "ConnectionStrategy", { enumerable: true, get: function() {
        return Qt.ConnectionStrategy;
      } });
      Object.defineProperty(D, "ConnectionOptions", { enumerable: true, get: function() {
        return Qt.ConnectionOptions;
      } });
      Object.defineProperty(D, "NullLogger", { enumerable: true, get: function() {
        return Qt.NullLogger;
      } });
      Object.defineProperty(D, "createMessageConnection", { enumerable: true, get: function() {
        return Qt.createMessageConnection;
      } });
      Object.defineProperty(D, "ProgressToken", { enumerable: true, get: function() {
        return Qt.ProgressToken;
      } });
      Object.defineProperty(D, "ProgressType", { enumerable: true, get: function() {
        return Qt.ProgressType;
      } });
      Object.defineProperty(D, "Trace", { enumerable: true, get: function() {
        return Qt.Trace;
      } });
      Object.defineProperty(D, "TraceValues", { enumerable: true, get: function() {
        return Qt.TraceValues;
      } });
      Object.defineProperty(D, "TraceFormat", { enumerable: true, get: function() {
        return Qt.TraceFormat;
      } });
      Object.defineProperty(D, "SetTraceNotification", { enumerable: true, get: function() {
        return Qt.SetTraceNotification;
      } });
      Object.defineProperty(D, "LogTraceNotification", { enumerable: true, get: function() {
        return Qt.LogTraceNotification;
      } });
      Object.defineProperty(D, "ConnectionErrors", { enumerable: true, get: function() {
        return Qt.ConnectionErrors;
      } });
      Object.defineProperty(D, "ConnectionError", { enumerable: true, get: function() {
        return Qt.ConnectionError;
      } });
      Object.defineProperty(D, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return Qt.CancellationReceiverStrategy;
      } });
      Object.defineProperty(D, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return Qt.CancellationSenderStrategy;
      } });
      Object.defineProperty(D, "CancellationStrategy", { enumerable: true, get: function() {
        return Qt.CancellationStrategy;
      } });
      var W$ = _i();
      D.RAL = W$.default;
    });
    var Fn = f((kr) => {
      var B$ = kr && kr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), K$ = kr && kr.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && B$(e, t, r);
      };
      Object.defineProperty(kr, "__esModule", { value: true });
      kr.createMessageConnection = kr.BrowserMessageWriter = kr.BrowserMessageReader = void 0;
      var z$ = $R();
      z$.default.install();
      var Ma = Cm();
      K$(Cm(), kr);
      var Nm = class extends Ma.AbstractMessageReader {
        constructor(e) {
          super(), this._onData = new Ma.Emitter(), this._messageListener = (r) => {
            this._onData.fire(r.data);
          }, e.addEventListener("error", (r) => this.fireError(r)), e.onmessage = this._messageListener;
        }
        listen(e) {
          return this._onData.event(e);
        }
      };
      kr.BrowserMessageReader = Nm;
      var Em = class extends Ma.AbstractMessageWriter {
        constructor(e) {
          super(), this.context = e, this.errorCount = 0, e.addEventListener("error", (r) => this.fireError(r));
        }
        write(e) {
          try {
            return this.context.postMessage(e), Promise.resolve();
          } catch (r) {
            return this.handleError(r, e), Promise.reject(r);
          }
        }
        handleError(e, r) {
          this.errorCount++, this.fireError(e, r, this.errorCount);
        }
        end() {
        }
      };
      kr.BrowserMessageWriter = Em;
      function V$(t, e, r, n) {
        return r === void 0 && (r = Ma.NullLogger), Ma.ConnectionStrategy.is(n) && (n = { connectionStrategy: n }), (0, Ma.createMessageConnection)(t, e, r, n);
      }
      kr.createMessageConnection = V$;
    });
    var km = f((cde, n0) => {
      n0.exports = Fn();
    });
    var $a = f((i0, Rl) => {
      (function(t) {
        if (typeof Rl == "object" && typeof Rl.exports == "object") {
          var e = t(pl, i0);
          e !== void 0 && (Rl.exports = e);
        } else
          typeof define == "function" && define.amd && define(["require", "exports"], t);
      })(function(t, e) {
        Object.defineProperty(e, "__esModule", { value: true }), e.TextDocument = e.EOL = e.WorkspaceFolder = e.InlayHint = e.InlayHintLabelPart = e.InlayHintKind = e.InlineValueContext = e.InlineValueEvaluatableExpression = e.InlineValueVariableLookup = e.InlineValueText = e.SemanticTokens = e.SemanticTokenModifiers = e.SemanticTokenTypes = e.SelectionRange = e.DocumentLink = e.FormattingOptions = e.CodeLens = e.CodeAction = e.CodeActionContext = e.CodeActionTriggerKind = e.CodeActionKind = e.DocumentSymbol = e.WorkspaceSymbol = e.SymbolInformation = e.SymbolTag = e.SymbolKind = e.DocumentHighlight = e.DocumentHighlightKind = e.SignatureInformation = e.ParameterInformation = e.Hover = e.MarkedString = e.CompletionList = e.CompletionItem = e.CompletionItemLabelDetails = e.InsertTextMode = e.InsertReplaceEdit = e.CompletionItemTag = e.InsertTextFormat = e.CompletionItemKind = e.MarkupContent = e.MarkupKind = e.TextDocumentItem = e.OptionalVersionedTextDocumentIdentifier = e.VersionedTextDocumentIdentifier = e.TextDocumentIdentifier = e.WorkspaceChange = e.WorkspaceEdit = e.DeleteFile = e.RenameFile = e.CreateFile = e.TextDocumentEdit = e.AnnotatedTextEdit = e.ChangeAnnotationIdentifier = e.ChangeAnnotation = e.TextEdit = e.Command = e.Diagnostic = e.CodeDescription = e.DiagnosticTag = e.DiagnosticSeverity = e.DiagnosticRelatedInformation = e.FoldingRange = e.FoldingRangeKind = e.ColorPresentation = e.ColorInformation = e.Color = e.LocationLink = e.Location = e.Range = e.Position = e.uinteger = e.integer = e.URI = e.DocumentUri = void 0;
        (function(g) {
          function P(E) {
            return typeof E == "string";
          }
          g.is = P;
        })(e.DocumentUri || (e.DocumentUri = {}));
        var n;
        (function(g) {
          function P(E) {
            return typeof E == "string";
          }
          g.is = P;
        })(n = e.URI || (e.URI = {}));
        (function(g) {
          g.MIN_VALUE = -2147483648, g.MAX_VALUE = 2147483647;
          function P(E) {
            return typeof E == "number" && g.MIN_VALUE <= E && E <= g.MAX_VALUE;
          }
          g.is = P;
        })(e.integer || (e.integer = {}));
        var o;
        (function(g) {
          g.MIN_VALUE = 0, g.MAX_VALUE = 2147483647;
          function P(E) {
            return typeof E == "number" && g.MIN_VALUE <= E && E <= g.MAX_VALUE;
          }
          g.is = P;
        })(o = e.uinteger || (e.uinteger = {}));
        var a;
        (function(g) {
          function P(_, p) {
            return _ === Number.MAX_VALUE && (_ = o.MAX_VALUE), p === Number.MAX_VALUE && (p = o.MAX_VALUE), { line: _, character: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && k.uinteger(p.line) && k.uinteger(p.character);
          }
          g.is = E;
        })(a = e.Position || (e.Position = {}));
        var s;
        (function(g) {
          function P(_, p, w, I) {
            if (k.uinteger(_) && k.uinteger(p) && k.uinteger(w) && k.uinteger(I))
              return { start: a.create(_, p), end: a.create(w, I) };
            if (a.is(_) && a.is(p))
              return { start: _, end: p };
            throw new Error("Range#create called with invalid arguments[".concat(_, ", ").concat(p, ", ").concat(w, ", ").concat(I, "]"));
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && a.is(p.start) && a.is(p.end);
          }
          g.is = E;
        })(s = e.Range || (e.Range = {}));
        var u;
        (function(g) {
          function P(_, p) {
            return { uri: _, range: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && s.is(p.range) && (k.string(p.uri) || k.undefined(p.uri));
          }
          g.is = E;
        })(u = e.Location || (e.Location = {}));
        (function(g) {
          function P(_, p, w, I) {
            return { targetUri: _, targetRange: p, targetSelectionRange: w, originSelectionRange: I };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && s.is(p.targetRange) && k.string(p.targetUri) && s.is(p.targetSelectionRange) && (s.is(p.originSelectionRange) || k.undefined(p.originSelectionRange));
          }
          g.is = E;
        })(e.LocationLink || (e.LocationLink = {}));
        var l;
        (function(g) {
          function P(_, p, w, I) {
            return { red: _, green: p, blue: w, alpha: I };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && k.numberRange(p.red, 0, 1) && k.numberRange(p.green, 0, 1) && k.numberRange(p.blue, 0, 1) && k.numberRange(p.alpha, 0, 1);
          }
          g.is = E;
        })(l = e.Color || (e.Color = {}));
        (function(g) {
          function P(_, p) {
            return { range: _, color: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && s.is(p.range) && l.is(p.color);
          }
          g.is = E;
        })(e.ColorInformation || (e.ColorInformation = {}));
        (function(g) {
          function P(_, p, w) {
            return { label: _, textEdit: p, additionalTextEdits: w };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && k.string(p.label) && (k.undefined(p.textEdit) || L.is(p)) && (k.undefined(p.additionalTextEdits) || k.typedArray(p.additionalTextEdits, L.is));
          }
          g.is = E;
        })(e.ColorPresentation || (e.ColorPresentation = {}));
        (function(g) {
          g.Comment = "comment", g.Imports = "imports", g.Region = "region";
        })(e.FoldingRangeKind || (e.FoldingRangeKind = {}));
        (function(g) {
          function P(_, p, w, I, ne, dt) {
            var Ke = { startLine: _, endLine: p };
            return k.defined(w) && (Ke.startCharacter = w), k.defined(I) && (Ke.endCharacter = I), k.defined(ne) && (Ke.kind = ne), k.defined(dt) && (Ke.collapsedText = dt), Ke;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && k.uinteger(p.startLine) && k.uinteger(p.startLine) && (k.undefined(p.startCharacter) || k.uinteger(p.startCharacter)) && (k.undefined(p.endCharacter) || k.uinteger(p.endCharacter)) && (k.undefined(p.kind) || k.string(p.kind));
          }
          g.is = E;
        })(e.FoldingRange || (e.FoldingRange = {}));
        var R;
        (function(g) {
          function P(_, p) {
            return { location: _, message: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && u.is(p.location) && k.string(p.message);
          }
          g.is = E;
        })(R = e.DiagnosticRelatedInformation || (e.DiagnosticRelatedInformation = {}));
        (function(g) {
          g.Error = 1, g.Warning = 2, g.Information = 3, g.Hint = 4;
        })(e.DiagnosticSeverity || (e.DiagnosticSeverity = {}));
        (function(g) {
          g.Unnecessary = 1, g.Deprecated = 2;
        })(e.DiagnosticTag || (e.DiagnosticTag = {}));
        (function(g) {
          function P(E) {
            var _ = E;
            return k.objectLiteral(_) && k.string(_.href);
          }
          g.is = P;
        })(e.CodeDescription || (e.CodeDescription = {}));
        var b;
        (function(g) {
          function P(_, p, w, I, ne, dt) {
            var Ke = { range: _, message: p };
            return k.defined(w) && (Ke.severity = w), k.defined(I) && (Ke.code = I), k.defined(ne) && (Ke.source = ne), k.defined(dt) && (Ke.relatedInformation = dt), Ke;
          }
          g.create = P;
          function E(_) {
            var p, w = _;
            return k.defined(w) && s.is(w.range) && k.string(w.message) && (k.number(w.severity) || k.undefined(w.severity)) && (k.integer(w.code) || k.string(w.code) || k.undefined(w.code)) && (k.undefined(w.codeDescription) || k.string((p = w.codeDescription) === null || p === void 0 ? void 0 : p.href)) && (k.string(w.source) || k.undefined(w.source)) && (k.undefined(w.relatedInformation) || k.typedArray(w.relatedInformation, R.is));
          }
          g.is = E;
        })(b = e.Diagnostic || (e.Diagnostic = {}));
        var O;
        (function(g) {
          function P(_, p) {
            for (var w = [], I = 2; I < arguments.length; I++)
              w[I - 2] = arguments[I];
            var ne = { title: _, command: p };
            return k.defined(w) && w.length > 0 && (ne.arguments = w), ne;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && k.string(p.title) && k.string(p.command);
          }
          g.is = E;
        })(O = e.Command || (e.Command = {}));
        var L;
        (function(g) {
          function P(w, I) {
            return { range: w, newText: I };
          }
          g.replace = P;
          function E(w, I) {
            return { range: { start: w, end: w }, newText: I };
          }
          g.insert = E;
          function _(w) {
            return { range: w, newText: "" };
          }
          g.del = _;
          function p(w) {
            var I = w;
            return k.objectLiteral(I) && k.string(I.newText) && s.is(I.range);
          }
          g.is = p;
        })(L = e.TextEdit || (e.TextEdit = {}));
        var W;
        (function(g) {
          function P(_, p, w) {
            var I = { label: _ };
            return p !== void 0 && (I.needsConfirmation = p), w !== void 0 && (I.description = w), I;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && k.string(p.label) && (k.boolean(p.needsConfirmation) || p.needsConfirmation === void 0) && (k.string(p.description) || p.description === void 0);
          }
          g.is = E;
        })(W = e.ChangeAnnotation || (e.ChangeAnnotation = {}));
        var Z;
        (function(g) {
          function P(E) {
            var _ = E;
            return k.string(_);
          }
          g.is = P;
        })(Z = e.ChangeAnnotationIdentifier || (e.ChangeAnnotationIdentifier = {}));
        var Ee;
        (function(g) {
          function P(w, I, ne) {
            return { range: w, newText: I, annotationId: ne };
          }
          g.replace = P;
          function E(w, I, ne) {
            return { range: { start: w, end: w }, newText: I, annotationId: ne };
          }
          g.insert = E;
          function _(w, I) {
            return { range: w, newText: "", annotationId: I };
          }
          g.del = _;
          function p(w) {
            var I = w;
            return L.is(I) && (W.is(I.annotationId) || Z.is(I.annotationId));
          }
          g.is = p;
        })(Ee = e.AnnotatedTextEdit || (e.AnnotatedTextEdit = {}));
        var ke;
        (function(g) {
          function P(_, p) {
            return { textDocument: _, edits: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && J.is(p.textDocument) && Array.isArray(p.edits);
          }
          g.is = E;
        })(ke = e.TextDocumentEdit || (e.TextDocumentEdit = {}));
        var Je;
        (function(g) {
          function P(_, p, w) {
            var I = { kind: "create", uri: _ };
            return p !== void 0 && (p.overwrite !== void 0 || p.ignoreIfExists !== void 0) && (I.options = p), w !== void 0 && (I.annotationId = w), I;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p && p.kind === "create" && k.string(p.uri) && (p.options === void 0 || (p.options.overwrite === void 0 || k.boolean(p.options.overwrite)) && (p.options.ignoreIfExists === void 0 || k.boolean(p.options.ignoreIfExists))) && (p.annotationId === void 0 || Z.is(p.annotationId));
          }
          g.is = E;
        })(Je = e.CreateFile || (e.CreateFile = {}));
        var K;
        (function(g) {
          function P(_, p, w, I) {
            var ne = { kind: "rename", oldUri: _, newUri: p };
            return w !== void 0 && (w.overwrite !== void 0 || w.ignoreIfExists !== void 0) && (ne.options = w), I !== void 0 && (ne.annotationId = I), ne;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p && p.kind === "rename" && k.string(p.oldUri) && k.string(p.newUri) && (p.options === void 0 || (p.options.overwrite === void 0 || k.boolean(p.options.overwrite)) && (p.options.ignoreIfExists === void 0 || k.boolean(p.options.ignoreIfExists))) && (p.annotationId === void 0 || Z.is(p.annotationId));
          }
          g.is = E;
        })(K = e.RenameFile || (e.RenameFile = {}));
        var le;
        (function(g) {
          function P(_, p, w) {
            var I = { kind: "delete", uri: _ };
            return p !== void 0 && (p.recursive !== void 0 || p.ignoreIfNotExists !== void 0) && (I.options = p), w !== void 0 && (I.annotationId = w), I;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p && p.kind === "delete" && k.string(p.uri) && (p.options === void 0 || (p.options.recursive === void 0 || k.boolean(p.options.recursive)) && (p.options.ignoreIfNotExists === void 0 || k.boolean(p.options.ignoreIfNotExists))) && (p.annotationId === void 0 || Z.is(p.annotationId));
          }
          g.is = E;
        })(le = e.DeleteFile || (e.DeleteFile = {}));
        var M;
        (function(g) {
          function P(E) {
            var _ = E;
            return _ && (_.changes !== void 0 || _.documentChanges !== void 0) && (_.documentChanges === void 0 || _.documentChanges.every(function(p) {
              return k.string(p.kind) ? Je.is(p) || K.is(p) || le.is(p) : ke.is(p);
            }));
          }
          g.is = P;
        })(M = e.WorkspaceEdit || (e.WorkspaceEdit = {}));
        var q = function() {
          function g(P, E) {
            this.edits = P, this.changeAnnotations = E;
          }
          return g.prototype.insert = function(P, E, _) {
            var p, w;
            if (_ === void 0 ? p = L.insert(P, E) : Z.is(_) ? (w = _, p = Ee.insert(P, E, _)) : (this.assertChangeAnnotations(this.changeAnnotations), w = this.changeAnnotations.manage(_), p = Ee.insert(P, E, w)), this.edits.push(p), w !== void 0)
              return w;
          }, g.prototype.replace = function(P, E, _) {
            var p, w;
            if (_ === void 0 ? p = L.replace(P, E) : Z.is(_) ? (w = _, p = Ee.replace(P, E, _)) : (this.assertChangeAnnotations(this.changeAnnotations), w = this.changeAnnotations.manage(_), p = Ee.replace(P, E, w)), this.edits.push(p), w !== void 0)
              return w;
          }, g.prototype.delete = function(P, E) {
            var _, p;
            if (E === void 0 ? _ = L.del(P) : Z.is(E) ? (p = E, _ = Ee.del(P, E)) : (this.assertChangeAnnotations(this.changeAnnotations), p = this.changeAnnotations.manage(E), _ = Ee.del(P, p)), this.edits.push(_), p !== void 0)
              return p;
          }, g.prototype.add = function(P) {
            this.edits.push(P);
          }, g.prototype.all = function() {
            return this.edits;
          }, g.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          }, g.prototype.assertChangeAnnotations = function(P) {
            if (P === void 0)
              throw new Error("Text edit change is not configured to manage change annotations.");
          }, g;
        }(), F = function() {
          function g(P) {
            this._annotations = P === void 0 ? /* @__PURE__ */ Object.create(null) : P, this._counter = 0, this._size = 0;
          }
          return g.prototype.all = function() {
            return this._annotations;
          }, Object.defineProperty(g.prototype, "size", { get: function() {
            return this._size;
          }, enumerable: false, configurable: true }), g.prototype.manage = function(P, E) {
            var _;
            if (Z.is(P) ? _ = P : (_ = this.nextId(), E = P), this._annotations[_] !== void 0)
              throw new Error("Id ".concat(_, " is already in use."));
            if (E === void 0)
              throw new Error("No annotation provided for id ".concat(_));
            return this._annotations[_] = E, this._size++, _;
          }, g.prototype.nextId = function() {
            return this._counter++, this._counter.toString();
          }, g;
        }(), B = function() {
          function g(P) {
            var E = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null), P !== void 0 ? (this._workspaceEdit = P, P.documentChanges ? (this._changeAnnotations = new F(P.changeAnnotations), P.changeAnnotations = this._changeAnnotations.all(), P.documentChanges.forEach(function(_) {
              if (ke.is(_)) {
                var p = new q(_.edits, E._changeAnnotations);
                E._textEditChanges[_.textDocument.uri] = p;
              }
            })) : P.changes && Object.keys(P.changes).forEach(function(_) {
              var p = new q(P.changes[_]);
              E._textEditChanges[_] = p;
            })) : this._workspaceEdit = {};
          }
          return Object.defineProperty(g.prototype, "edit", { get: function() {
            return this.initDocumentChanges(), this._changeAnnotations !== void 0 && (this._changeAnnotations.size === 0 ? this._workspaceEdit.changeAnnotations = void 0 : this._workspaceEdit.changeAnnotations = this._changeAnnotations.all()), this._workspaceEdit;
          }, enumerable: false, configurable: true }), g.prototype.getTextEditChange = function(P) {
            if (J.is(P)) {
              if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
                throw new Error("Workspace edit is not configured for document changes.");
              var E = { uri: P.uri, version: P.version }, _ = this._textEditChanges[E.uri];
              if (!_) {
                var p = [], w = { textDocument: E, edits: p };
                this._workspaceEdit.documentChanges.push(w), _ = new q(p, this._changeAnnotations), this._textEditChanges[E.uri] = _;
              }
              return _;
            } else {
              if (this.initChanges(), this._workspaceEdit.changes === void 0)
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              var _ = this._textEditChanges[P];
              if (!_) {
                var p = [];
                this._workspaceEdit.changes[P] = p, _ = new q(p), this._textEditChanges[P] = _;
              }
              return _;
            }
          }, g.prototype.initDocumentChanges = function() {
            this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0 && (this._changeAnnotations = new F(), this._workspaceEdit.documentChanges = [], this._workspaceEdit.changeAnnotations = this._changeAnnotations.all());
          }, g.prototype.initChanges = function() {
            this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0 && (this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null));
          }, g.prototype.createFile = function(P, E, _) {
            if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
              throw new Error("Workspace edit is not configured for document changes.");
            var p;
            W.is(E) || Z.is(E) ? p = E : _ = E;
            var w, I;
            if (p === void 0 ? w = Je.create(P, _) : (I = Z.is(p) ? p : this._changeAnnotations.manage(p), w = Je.create(P, _, I)), this._workspaceEdit.documentChanges.push(w), I !== void 0)
              return I;
          }, g.prototype.renameFile = function(P, E, _, p) {
            if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
              throw new Error("Workspace edit is not configured for document changes.");
            var w;
            W.is(_) || Z.is(_) ? w = _ : p = _;
            var I, ne;
            if (w === void 0 ? I = K.create(P, E, p) : (ne = Z.is(w) ? w : this._changeAnnotations.manage(w), I = K.create(P, E, p, ne)), this._workspaceEdit.documentChanges.push(I), ne !== void 0)
              return ne;
          }, g.prototype.deleteFile = function(P, E, _) {
            if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
              throw new Error("Workspace edit is not configured for document changes.");
            var p;
            W.is(E) || Z.is(E) ? p = E : _ = E;
            var w, I;
            if (p === void 0 ? w = le.create(P, _) : (I = Z.is(p) ? p : this._changeAnnotations.manage(p), w = le.create(P, _, I)), this._workspaceEdit.documentChanges.push(w), I !== void 0)
              return I;
          }, g;
        }();
        e.WorkspaceChange = B;
        (function(g) {
          function P(_) {
            return { uri: _ };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && k.string(p.uri);
          }
          g.is = E;
        })(e.TextDocumentIdentifier || (e.TextDocumentIdentifier = {}));
        (function(g) {
          function P(_, p) {
            return { uri: _, version: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && k.string(p.uri) && k.integer(p.version);
          }
          g.is = E;
        })(e.VersionedTextDocumentIdentifier || (e.VersionedTextDocumentIdentifier = {}));
        var J;
        (function(g) {
          function P(_, p) {
            return { uri: _, version: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && k.string(p.uri) && (p.version === null || k.integer(p.version));
          }
          g.is = E;
        })(J = e.OptionalVersionedTextDocumentIdentifier || (e.OptionalVersionedTextDocumentIdentifier = {}));
        (function(g) {
          function P(_, p, w, I) {
            return { uri: _, languageId: p, version: w, text: I };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && k.string(p.uri) && k.string(p.languageId) && k.integer(p.version) && k.string(p.text);
          }
          g.is = E;
        })(e.TextDocumentItem || (e.TextDocumentItem = {}));
        var tt;
        (function(g) {
          g.PlainText = "plaintext", g.Markdown = "markdown";
          function P(E) {
            var _ = E;
            return _ === g.PlainText || _ === g.Markdown;
          }
          g.is = P;
        })(tt = e.MarkupKind || (e.MarkupKind = {}));
        var Ot;
        (function(g) {
          function P(E) {
            var _ = E;
            return k.objectLiteral(E) && tt.is(_.kind) && k.string(_.value);
          }
          g.is = P;
        })(Ot = e.MarkupContent || (e.MarkupContent = {}));
        (function(g) {
          g.Text = 1, g.Method = 2, g.Function = 3, g.Constructor = 4, g.Field = 5, g.Variable = 6, g.Class = 7, g.Interface = 8, g.Module = 9, g.Property = 10, g.Unit = 11, g.Value = 12, g.Enum = 13, g.Keyword = 14, g.Snippet = 15, g.Color = 16, g.File = 17, g.Reference = 18, g.Folder = 19, g.EnumMember = 20, g.Constant = 21, g.Struct = 22, g.Event = 23, g.Operator = 24, g.TypeParameter = 25;
        })(e.CompletionItemKind || (e.CompletionItemKind = {}));
        (function(g) {
          g.PlainText = 1, g.Snippet = 2;
        })(e.InsertTextFormat || (e.InsertTextFormat = {}));
        (function(g) {
          g.Deprecated = 1;
        })(e.CompletionItemTag || (e.CompletionItemTag = {}));
        (function(g) {
          function P(_, p, w) {
            return { newText: _, insert: p, replace: w };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p && k.string(p.newText) && s.is(p.insert) && s.is(p.replace);
          }
          g.is = E;
        })(e.InsertReplaceEdit || (e.InsertReplaceEdit = {}));
        (function(g) {
          g.asIs = 1, g.adjustIndentation = 2;
        })(e.InsertTextMode || (e.InsertTextMode = {}));
        (function(g) {
          function P(E) {
            var _ = E;
            return _ && (k.string(_.detail) || _.detail === void 0) && (k.string(_.description) || _.description === void 0);
          }
          g.is = P;
        })(e.CompletionItemLabelDetails || (e.CompletionItemLabelDetails = {}));
        (function(g) {
          function P(E) {
            return { label: E };
          }
          g.create = P;
        })(e.CompletionItem || (e.CompletionItem = {}));
        (function(g) {
          function P(E, _) {
            return { items: E || [], isIncomplete: !!_ };
          }
          g.create = P;
        })(e.CompletionList || (e.CompletionList = {}));
        var mt;
        (function(g) {
          function P(_) {
            return _.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
          }
          g.fromPlainText = P;
          function E(_) {
            var p = _;
            return k.string(p) || k.objectLiteral(p) && k.string(p.language) && k.string(p.value);
          }
          g.is = E;
        })(mt = e.MarkedString || (e.MarkedString = {}));
        (function(g) {
          function P(E) {
            var _ = E;
            return !!_ && k.objectLiteral(_) && (Ot.is(_.contents) || mt.is(_.contents) || k.typedArray(_.contents, mt.is)) && (E.range === void 0 || s.is(E.range));
          }
          g.is = P;
        })(e.Hover || (e.Hover = {}));
        (function(g) {
          function P(E, _) {
            return _ ? { label: E, documentation: _ } : { label: E };
          }
          g.create = P;
        })(e.ParameterInformation || (e.ParameterInformation = {}));
        (function(g) {
          function P(E, _) {
            for (var p = [], w = 2; w < arguments.length; w++)
              p[w - 2] = arguments[w];
            var I = { label: E };
            return k.defined(_) && (I.documentation = _), k.defined(p) ? I.parameters = p : I.parameters = [], I;
          }
          g.create = P;
        })(e.SignatureInformation || (e.SignatureInformation = {}));
        (function(g) {
          g.Text = 1, g.Read = 2, g.Write = 3;
        })(e.DocumentHighlightKind || (e.DocumentHighlightKind = {}));
        (function(g) {
          function P(E, _) {
            var p = { range: E };
            return k.number(_) && (p.kind = _), p;
          }
          g.create = P;
        })(e.DocumentHighlight || (e.DocumentHighlight = {}));
        (function(g) {
          g.File = 1, g.Module = 2, g.Namespace = 3, g.Package = 4, g.Class = 5, g.Method = 6, g.Property = 7, g.Field = 8, g.Constructor = 9, g.Enum = 10, g.Interface = 11, g.Function = 12, g.Variable = 13, g.Constant = 14, g.String = 15, g.Number = 16, g.Boolean = 17, g.Array = 18, g.Object = 19, g.Key = 20, g.Null = 21, g.EnumMember = 22, g.Struct = 23, g.Event = 24, g.Operator = 25, g.TypeParameter = 26;
        })(e.SymbolKind || (e.SymbolKind = {}));
        (function(g) {
          g.Deprecated = 1;
        })(e.SymbolTag || (e.SymbolTag = {}));
        (function(g) {
          function P(E, _, p, w, I) {
            var ne = { name: E, kind: _, location: { uri: w, range: p } };
            return I && (ne.containerName = I), ne;
          }
          g.create = P;
        })(e.SymbolInformation || (e.SymbolInformation = {}));
        (function(g) {
          function P(E, _, p, w) {
            return w !== void 0 ? { name: E, kind: _, location: { uri: p, range: w } } : { name: E, kind: _, location: { uri: p } };
          }
          g.create = P;
        })(e.WorkspaceSymbol || (e.WorkspaceSymbol = {}));
        (function(g) {
          function P(_, p, w, I, ne, dt) {
            var Ke = { name: _, detail: p, kind: w, range: I, selectionRange: ne };
            return dt !== void 0 && (Ke.children = dt), Ke;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p && k.string(p.name) && k.number(p.kind) && s.is(p.range) && s.is(p.selectionRange) && (p.detail === void 0 || k.string(p.detail)) && (p.deprecated === void 0 || k.boolean(p.deprecated)) && (p.children === void 0 || Array.isArray(p.children)) && (p.tags === void 0 || Array.isArray(p.tags));
          }
          g.is = E;
        })(e.DocumentSymbol || (e.DocumentSymbol = {}));
        (function(g) {
          g.Empty = "", g.QuickFix = "quickfix", g.Refactor = "refactor", g.RefactorExtract = "refactor.extract", g.RefactorInline = "refactor.inline", g.RefactorRewrite = "refactor.rewrite", g.Source = "source", g.SourceOrganizeImports = "source.organizeImports", g.SourceFixAll = "source.fixAll";
        })(e.CodeActionKind || (e.CodeActionKind = {}));
        var Ln;
        (function(g) {
          g.Invoked = 1, g.Automatic = 2;
        })(Ln = e.CodeActionTriggerKind || (e.CodeActionTriggerKind = {}));
        (function(g) {
          function P(_, p, w) {
            var I = { diagnostics: _ };
            return p != null && (I.only = p), w != null && (I.triggerKind = w), I;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && k.typedArray(p.diagnostics, b.is) && (p.only === void 0 || k.typedArray(p.only, k.string)) && (p.triggerKind === void 0 || p.triggerKind === Ln.Invoked || p.triggerKind === Ln.Automatic);
          }
          g.is = E;
        })(e.CodeActionContext || (e.CodeActionContext = {}));
        (function(g) {
          function P(_, p, w) {
            var I = { title: _ }, ne = true;
            return typeof p == "string" ? (ne = false, I.kind = p) : O.is(p) ? I.command = p : I.edit = p, ne && w !== void 0 && (I.kind = w), I;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p && k.string(p.title) && (p.diagnostics === void 0 || k.typedArray(p.diagnostics, b.is)) && (p.kind === void 0 || k.string(p.kind)) && (p.edit !== void 0 || p.command !== void 0) && (p.command === void 0 || O.is(p.command)) && (p.isPreferred === void 0 || k.boolean(p.isPreferred)) && (p.edit === void 0 || M.is(p.edit));
          }
          g.is = E;
        })(e.CodeAction || (e.CodeAction = {}));
        (function(g) {
          function P(_, p) {
            var w = { range: _ };
            return k.defined(p) && (w.data = p), w;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && s.is(p.range) && (k.undefined(p.command) || O.is(p.command));
          }
          g.is = E;
        })(e.CodeLens || (e.CodeLens = {}));
        (function(g) {
          function P(_, p) {
            return { tabSize: _, insertSpaces: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && k.uinteger(p.tabSize) && k.boolean(p.insertSpaces);
          }
          g.is = E;
        })(e.FormattingOptions || (e.FormattingOptions = {}));
        (function(g) {
          function P(_, p, w) {
            return { range: _, target: p, data: w };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && s.is(p.range) && (k.undefined(p.target) || k.string(p.target));
          }
          g.is = E;
        })(e.DocumentLink || (e.DocumentLink = {}));
        (function(g) {
          function P(_, p) {
            return { range: _, parent: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && s.is(p.range) && (p.parent === void 0 || g.is(p.parent));
          }
          g.is = E;
        })(e.SelectionRange || (e.SelectionRange = {}));
        (function(g) {
          g.namespace = "namespace", g.type = "type", g.class = "class", g.enum = "enum", g.interface = "interface", g.struct = "struct", g.typeParameter = "typeParameter", g.parameter = "parameter", g.variable = "variable", g.property = "property", g.enumMember = "enumMember", g.event = "event", g.function = "function", g.method = "method", g.macro = "macro", g.keyword = "keyword", g.modifier = "modifier", g.comment = "comment", g.string = "string", g.number = "number", g.regexp = "regexp", g.operator = "operator", g.decorator = "decorator";
        })(e.SemanticTokenTypes || (e.SemanticTokenTypes = {}));
        (function(g) {
          g.declaration = "declaration", g.definition = "definition", g.readonly = "readonly", g.static = "static", g.deprecated = "deprecated", g.abstract = "abstract", g.async = "async", g.modification = "modification", g.documentation = "documentation", g.defaultLibrary = "defaultLibrary";
        })(e.SemanticTokenModifiers || (e.SemanticTokenModifiers = {}));
        (function(g) {
          function P(E) {
            var _ = E;
            return k.objectLiteral(_) && (_.resultId === void 0 || typeof _.resultId == "string") && Array.isArray(_.data) && (_.data.length === 0 || typeof _.data[0] == "number");
          }
          g.is = P;
        })(e.SemanticTokens || (e.SemanticTokens = {}));
        (function(g) {
          function P(_, p) {
            return { range: _, text: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p != null && s.is(p.range) && k.string(p.text);
          }
          g.is = E;
        })(e.InlineValueText || (e.InlineValueText = {}));
        (function(g) {
          function P(_, p, w) {
            return { range: _, variableName: p, caseSensitiveLookup: w };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p != null && s.is(p.range) && k.boolean(p.caseSensitiveLookup) && (k.string(p.variableName) || p.variableName === void 0);
          }
          g.is = E;
        })(e.InlineValueVariableLookup || (e.InlineValueVariableLookup = {}));
        (function(g) {
          function P(_, p) {
            return { range: _, expression: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return p != null && s.is(p.range) && (k.string(p.expression) || p.expression === void 0);
          }
          g.is = E;
        })(e.InlineValueEvaluatableExpression || (e.InlineValueEvaluatableExpression = {}));
        (function(g) {
          function P(_, p) {
            return { frameId: _, stoppedLocation: p };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.defined(p) && s.is(_.stoppedLocation);
          }
          g.is = E;
        })(e.InlineValueContext || (e.InlineValueContext = {}));
        var Be;
        (function(g) {
          g.Type = 1, g.Parameter = 2;
          function P(E) {
            return E === 1 || E === 2;
          }
          g.is = P;
        })(Be = e.InlayHintKind || (e.InlayHintKind = {}));
        var Te;
        (function(g) {
          function P(_) {
            return { value: _ };
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && (p.tooltip === void 0 || k.string(p.tooltip) || Ot.is(p.tooltip)) && (p.location === void 0 || u.is(p.location)) && (p.command === void 0 || O.is(p.command));
          }
          g.is = E;
        })(Te = e.InlayHintLabelPart || (e.InlayHintLabelPart = {}));
        (function(g) {
          function P(_, p, w) {
            var I = { position: _, label: p };
            return w !== void 0 && (I.kind = w), I;
          }
          g.create = P;
          function E(_) {
            var p = _;
            return k.objectLiteral(p) && a.is(p.position) && (k.string(p.label) || k.typedArray(p.label, Te.is)) && (p.kind === void 0 || Be.is(p.kind)) && p.textEdits === void 0 || k.typedArray(p.textEdits, L.is) && (p.tooltip === void 0 || k.string(p.tooltip) || Ot.is(p.tooltip)) && (p.paddingLeft === void 0 || k.boolean(p.paddingLeft)) && (p.paddingRight === void 0 || k.boolean(p.paddingRight));
          }
          g.is = E;
        })(e.InlayHint || (e.InlayHint = {}));
        (function(g) {
          function P(E) {
            var _ = E;
            return k.objectLiteral(_) && n.is(_.uri) && k.string(_.name);
          }
          g.is = P;
        })(e.WorkspaceFolder || (e.WorkspaceFolder = {})), e.EOL = [`
`, `\r
`, "\r"];
        (function(g) {
          function P(w, I, ne, dt) {
            return new $n(w, I, ne, dt);
          }
          g.create = P;
          function E(w) {
            var I = w;
            return !!(k.defined(I) && k.string(I.uri) && (k.undefined(I.languageId) || k.string(I.languageId)) && k.uinteger(I.lineCount) && k.func(I.getText) && k.func(I.positionAt) && k.func(I.offsetAt));
          }
          g.is = E;
          function _(w, I) {
            for (var ne = w.getText(), dt = p(I, function(Oa, ll) {
              var OR = Oa.range.start.line - ll.range.start.line;
              return OR === 0 ? Oa.range.start.character - ll.range.start.character : OR;
            }), Ke = ne.length, un = dt.length - 1; un >= 0; un--) {
              var cn = dt[un], Ti = w.offsetAt(cn.range.start), ye = w.offsetAt(cn.range.end);
              if (ye <= Ke)
                ne = ne.substring(0, Ti) + cn.newText + ne.substring(ye, ne.length);
              else
                throw new Error("Overlapping edit");
              Ke = Ti;
            }
            return ne;
          }
          g.applyEdits = _;
          function p(w, I) {
            if (w.length <= 1)
              return w;
            var ne = w.length / 2 | 0, dt = w.slice(0, ne), Ke = w.slice(ne);
            p(dt, I), p(Ke, I);
            for (var un = 0, cn = 0, Ti = 0; un < dt.length && cn < Ke.length; ) {
              var ye = I(dt[un], Ke[cn]);
              ye <= 0 ? w[Ti++] = dt[un++] : w[Ti++] = Ke[cn++];
            }
            for (; un < dt.length; )
              w[Ti++] = dt[un++];
            for (; cn < Ke.length; )
              w[Ti++] = Ke[cn++];
            return w;
          }
        })(e.TextDocument || (e.TextDocument = {}));
        var $n = function() {
          function g(P, E, _, p) {
            this._uri = P, this._languageId = E, this._version = _, this._content = p, this._lineOffsets = void 0;
          }
          return Object.defineProperty(g.prototype, "uri", { get: function() {
            return this._uri;
          }, enumerable: false, configurable: true }), Object.defineProperty(g.prototype, "languageId", { get: function() {
            return this._languageId;
          }, enumerable: false, configurable: true }), Object.defineProperty(g.prototype, "version", { get: function() {
            return this._version;
          }, enumerable: false, configurable: true }), g.prototype.getText = function(P) {
            if (P) {
              var E = this.offsetAt(P.start), _ = this.offsetAt(P.end);
              return this._content.substring(E, _);
            }
            return this._content;
          }, g.prototype.update = function(P, E) {
            this._content = P.text, this._version = E, this._lineOffsets = void 0;
          }, g.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              for (var P = [], E = this._content, _ = true, p = 0; p < E.length; p++) {
                _ && (P.push(p), _ = false);
                var w = E.charAt(p);
                _ = w === "\r" || w === `
`, w === "\r" && p + 1 < E.length && E.charAt(p + 1) === `
` && p++;
              }
              _ && E.length > 0 && P.push(E.length), this._lineOffsets = P;
            }
            return this._lineOffsets;
          }, g.prototype.positionAt = function(P) {
            P = Math.max(Math.min(P, this._content.length), 0);
            var E = this.getLineOffsets(), _ = 0, p = E.length;
            if (p === 0)
              return a.create(0, P);
            for (; _ < p; ) {
              var w = Math.floor((_ + p) / 2);
              E[w] > P ? p = w : _ = w + 1;
            }
            var I = _ - 1;
            return a.create(I, P - E[I]);
          }, g.prototype.offsetAt = function(P) {
            var E = this.getLineOffsets();
            if (P.line >= E.length)
              return this._content.length;
            if (P.line < 0)
              return 0;
            var _ = E[P.line], p = P.line + 1 < E.length ? E[P.line + 1] : this._content.length;
            return Math.max(Math.min(_ + P.character, p), _);
          }, Object.defineProperty(g.prototype, "lineCount", { get: function() {
            return this.getLineOffsets().length;
          }, enumerable: false, configurable: true }), g;
        }(), k;
        (function(g) {
          var P = Object.prototype.toString;
          function E(ye) {
            return typeof ye < "u";
          }
          g.defined = E;
          function _(ye) {
            return typeof ye > "u";
          }
          g.undefined = _;
          function p(ye) {
            return ye === true || ye === false;
          }
          g.boolean = p;
          function w(ye) {
            return P.call(ye) === "[object String]";
          }
          g.string = w;
          function I(ye) {
            return P.call(ye) === "[object Number]";
          }
          g.number = I;
          function ne(ye, Oa, ll) {
            return P.call(ye) === "[object Number]" && Oa <= ye && ye <= ll;
          }
          g.numberRange = ne;
          function dt(ye) {
            return P.call(ye) === "[object Number]" && -2147483648 <= ye && ye <= 2147483647;
          }
          g.integer = dt;
          function Ke(ye) {
            return P.call(ye) === "[object Number]" && 0 <= ye && ye <= 2147483647;
          }
          g.uinteger = Ke;
          function un(ye) {
            return P.call(ye) === "[object Function]";
          }
          g.func = un;
          function cn(ye) {
            return ye !== null && typeof ye == "object";
          }
          g.objectLiteral = cn;
          function Ti(ye, Oa) {
            return Array.isArray(ye) && ye.every(Oa);
          }
          g.typedArray = Ti;
        })(k || (k = {}));
      });
    });
    var ut = f((sr) => {
      Object.defineProperty(sr, "__esModule", { value: true });
      sr.ProtocolNotificationType = sr.ProtocolNotificationType0 = sr.ProtocolRequestType = sr.ProtocolRequestType0 = sr.RegistrationType = sr.MessageDirection = void 0;
      var Fa = Fn();
      (function(t) {
        t.clientToServer = "clientToServer", t.serverToClient = "serverToClient", t.both = "both";
      })(sr.MessageDirection || (sr.MessageDirection = {}));
      var wm = class {
        constructor(e) {
          this.method = e;
        }
      };
      sr.RegistrationType = wm;
      var Om = class extends Fa.RequestType0 {
        constructor(e) {
          super(e);
        }
      };
      sr.ProtocolRequestType0 = Om;
      var Dm = class extends Fa.RequestType {
        constructor(e) {
          super(e, Fa.ParameterStructures.byName);
        }
      };
      sr.ProtocolRequestType = Dm;
      var Im = class extends Fa.NotificationType0 {
        constructor(e) {
          super(e);
        }
      };
      sr.ProtocolNotificationType0 = Im;
      var xm = class extends Fa.NotificationType {
        constructor(e) {
          super(e, Fa.ParameterStructures.byName);
        }
      };
      sr.ProtocolNotificationType = xm;
    });
    var bl = f((_t) => {
      Object.defineProperty(_t, "__esModule", { value: true });
      _t.objectLiteral = _t.typedArray = _t.stringArray = _t.array = _t.func = _t.error = _t.number = _t.string = _t.boolean = void 0;
      function X$(t) {
        return t === true || t === false;
      }
      _t.boolean = X$;
      function o0(t) {
        return typeof t == "string" || t instanceof String;
      }
      _t.string = o0;
      function J$(t) {
        return typeof t == "number" || t instanceof Number;
      }
      _t.number = J$;
      function Q$(t) {
        return t instanceof Error;
      }
      _t.error = Q$;
      function Z$(t) {
        return typeof t == "function";
      }
      _t.func = Z$;
      function a0(t) {
        return Array.isArray(t);
      }
      _t.array = a0;
      function eF(t) {
        return a0(t) && t.every((e) => o0(e));
      }
      _t.stringArray = eF;
      function tF(t, e) {
        return Array.isArray(t) && t.every(e);
      }
      _t.typedArray = tF;
      function rF(t) {
        return t !== null && typeof t == "object";
      }
      _t.objectLiteral = rF;
    });
    var u0 = f((Ou) => {
      Object.defineProperty(Ou, "__esModule", { value: true });
      Ou.ImplementationRequest = void 0;
      var s0 = ut();
      (function(t) {
        t.method = "textDocument/implementation", t.messageDirection = s0.MessageDirection.clientToServer, t.type = new s0.ProtocolRequestType(t.method);
      })(Ou.ImplementationRequest || (Ou.ImplementationRequest = {}));
    });
    var l0 = f((Du) => {
      Object.defineProperty(Du, "__esModule", { value: true });
      Du.TypeDefinitionRequest = void 0;
      var c0 = ut();
      (function(t) {
        t.method = "textDocument/typeDefinition", t.messageDirection = c0.MessageDirection.clientToServer, t.type = new c0.ProtocolRequestType(t.method);
      })(Du.TypeDefinitionRequest || (Du.TypeDefinitionRequest = {}));
    });
    var d0 = f((Ji) => {
      Object.defineProperty(Ji, "__esModule", { value: true });
      Ji.DidChangeWorkspaceFoldersNotification = Ji.WorkspaceFoldersRequest = void 0;
      var Sl = ut();
      (function(t) {
        t.method = "workspace/workspaceFolders", t.messageDirection = Sl.MessageDirection.serverToClient, t.type = new Sl.ProtocolRequestType0(t.method);
      })(Ji.WorkspaceFoldersRequest || (Ji.WorkspaceFoldersRequest = {}));
      (function(t) {
        t.method = "workspace/didChangeWorkspaceFolders", t.messageDirection = Sl.MessageDirection.clientToServer, t.type = new Sl.ProtocolNotificationType(t.method);
      })(Ji.DidChangeWorkspaceFoldersNotification || (Ji.DidChangeWorkspaceFoldersNotification = {}));
    });
    var p0 = f((Iu) => {
      Object.defineProperty(Iu, "__esModule", { value: true });
      Iu.ConfigurationRequest = void 0;
      var f0 = ut();
      (function(t) {
        t.method = "workspace/configuration", t.messageDirection = f0.MessageDirection.serverToClient, t.type = new f0.ProtocolRequestType(t.method);
      })(Iu.ConfigurationRequest || (Iu.ConfigurationRequest = {}));
    });
    var h0 = f((Qi) => {
      Object.defineProperty(Qi, "__esModule", { value: true });
      Qi.ColorPresentationRequest = Qi.DocumentColorRequest = void 0;
      var Al = ut();
      (function(t) {
        t.method = "textDocument/documentColor", t.messageDirection = Al.MessageDirection.clientToServer, t.type = new Al.ProtocolRequestType(t.method);
      })(Qi.DocumentColorRequest || (Qi.DocumentColorRequest = {}));
      (function(t) {
        t.method = "textDocument/colorPresentation", t.messageDirection = Al.MessageDirection.clientToServer, t.type = new Al.ProtocolRequestType(t.method);
      })(Qi.ColorPresentationRequest || (Qi.ColorPresentationRequest = {}));
    });
    var g0 = f((xu) => {
      Object.defineProperty(xu, "__esModule", { value: true });
      xu.FoldingRangeRequest = void 0;
      var m0 = ut();
      (function(t) {
        t.method = "textDocument/foldingRange", t.messageDirection = m0.MessageDirection.clientToServer, t.type = new m0.ProtocolRequestType(t.method);
      })(xu.FoldingRangeRequest || (xu.FoldingRangeRequest = {}));
    });
    var v0 = f((qu) => {
      Object.defineProperty(qu, "__esModule", { value: true });
      qu.DeclarationRequest = void 0;
      var y0 = ut();
      (function(t) {
        t.method = "textDocument/declaration", t.messageDirection = y0.MessageDirection.clientToServer, t.type = new y0.ProtocolRequestType(t.method);
      })(qu.DeclarationRequest || (qu.DeclarationRequest = {}));
    });
    var _0 = f((Lu) => {
      Object.defineProperty(Lu, "__esModule", { value: true });
      Lu.SelectionRangeRequest = void 0;
      var T0 = ut();
      (function(t) {
        t.method = "textDocument/selectionRange", t.messageDirection = T0.MessageDirection.clientToServer, t.type = new T0.ProtocolRequestType(t.method);
      })(Lu.SelectionRangeRequest || (Lu.SelectionRangeRequest = {}));
    });
    var R0 = f((fn) => {
      Object.defineProperty(fn, "__esModule", { value: true });
      fn.WorkDoneProgressCancelNotification = fn.WorkDoneProgressCreateRequest = fn.WorkDoneProgress = void 0;
      var pF = Fn(), Pl = ut();
      (function(t) {
        t.type = new pF.ProgressType();
        function e(r) {
          return r === t.type;
        }
        t.is = e;
      })(fn.WorkDoneProgress || (fn.WorkDoneProgress = {}));
      (function(t) {
        t.method = "window/workDoneProgress/create", t.messageDirection = Pl.MessageDirection.serverToClient, t.type = new Pl.ProtocolRequestType(t.method);
      })(fn.WorkDoneProgressCreateRequest || (fn.WorkDoneProgressCreateRequest = {}));
      (function(t) {
        t.method = "window/workDoneProgress/cancel", t.messageDirection = Pl.MessageDirection.clientToServer, t.type = new Pl.ProtocolNotificationType(t.method);
      })(fn.WorkDoneProgressCancelNotification || (fn.WorkDoneProgressCancelNotification = {}));
    });
    var b0 = f((pn) => {
      Object.defineProperty(pn, "__esModule", { value: true });
      pn.CallHierarchyOutgoingCallsRequest = pn.CallHierarchyIncomingCallsRequest = pn.CallHierarchyPrepareRequest = void 0;
      var ja = ut();
      (function(t) {
        t.method = "textDocument/prepareCallHierarchy", t.messageDirection = ja.MessageDirection.clientToServer, t.type = new ja.ProtocolRequestType(t.method);
      })(pn.CallHierarchyPrepareRequest || (pn.CallHierarchyPrepareRequest = {}));
      (function(t) {
        t.method = "callHierarchy/incomingCalls", t.messageDirection = ja.MessageDirection.clientToServer, t.type = new ja.ProtocolRequestType(t.method);
      })(pn.CallHierarchyIncomingCallsRequest || (pn.CallHierarchyIncomingCallsRequest = {}));
      (function(t) {
        t.method = "callHierarchy/outgoingCalls", t.messageDirection = ja.MessageDirection.clientToServer, t.type = new ja.ProtocolRequestType(t.method);
      })(pn.CallHierarchyOutgoingCallsRequest || (pn.CallHierarchyOutgoingCallsRequest = {}));
    });
    var S0 = f((Rt) => {
      Object.defineProperty(Rt, "__esModule", { value: true });
      Rt.SemanticTokensRefreshRequest = Rt.SemanticTokensRangeRequest = Rt.SemanticTokensDeltaRequest = Rt.SemanticTokensRequest = Rt.SemanticTokensRegistrationType = Rt.TokenFormat = void 0;
      var Ai = ut();
      (function(t) {
        t.Relative = "relative";
      })(Rt.TokenFormat || (Rt.TokenFormat = {}));
      var Cl;
      (function(t) {
        t.method = "textDocument/semanticTokens", t.type = new Ai.RegistrationType(t.method);
      })(Cl = Rt.SemanticTokensRegistrationType || (Rt.SemanticTokensRegistrationType = {}));
      (function(t) {
        t.method = "textDocument/semanticTokens/full", t.messageDirection = Ai.MessageDirection.clientToServer, t.type = new Ai.ProtocolRequestType(t.method), t.registrationMethod = Cl.method;
      })(Rt.SemanticTokensRequest || (Rt.SemanticTokensRequest = {}));
      (function(t) {
        t.method = "textDocument/semanticTokens/full/delta", t.messageDirection = Ai.MessageDirection.clientToServer, t.type = new Ai.ProtocolRequestType(t.method), t.registrationMethod = Cl.method;
      })(Rt.SemanticTokensDeltaRequest || (Rt.SemanticTokensDeltaRequest = {}));
      (function(t) {
        t.method = "textDocument/semanticTokens/range", t.messageDirection = Ai.MessageDirection.clientToServer, t.type = new Ai.ProtocolRequestType(t.method), t.registrationMethod = Cl.method;
      })(Rt.SemanticTokensRangeRequest || (Rt.SemanticTokensRangeRequest = {}));
      (function(t) {
        t.method = "workspace/semanticTokens/refresh", t.messageDirection = Ai.MessageDirection.clientToServer, t.type = new Ai.ProtocolRequestType0(t.method);
      })(Rt.SemanticTokensRefreshRequest || (Rt.SemanticTokensRefreshRequest = {}));
    });
    var P0 = f((Mu) => {
      Object.defineProperty(Mu, "__esModule", { value: true });
      Mu.ShowDocumentRequest = void 0;
      var A0 = ut();
      (function(t) {
        t.method = "window/showDocument", t.messageDirection = A0.MessageDirection.serverToClient, t.type = new A0.ProtocolRequestType(t.method);
      })(Mu.ShowDocumentRequest || (Mu.ShowDocumentRequest = {}));
    });
    var N0 = f(($u) => {
      Object.defineProperty($u, "__esModule", { value: true });
      $u.LinkedEditingRangeRequest = void 0;
      var C0 = ut();
      (function(t) {
        t.method = "textDocument/linkedEditingRange", t.messageDirection = C0.MessageDirection.clientToServer, t.type = new C0.ProtocolRequestType(t.method);
      })($u.LinkedEditingRangeRequest || ($u.LinkedEditingRangeRequest = {}));
    });
    var E0 = f((ct) => {
      Object.defineProperty(ct, "__esModule", { value: true });
      ct.WillDeleteFilesRequest = ct.DidDeleteFilesNotification = ct.DidRenameFilesNotification = ct.WillRenameFilesRequest = ct.DidCreateFilesNotification = ct.WillCreateFilesRequest = ct.FileOperationPatternKind = void 0;
      var Fr = ut();
      (function(t) {
        t.file = "file", t.folder = "folder";
      })(ct.FileOperationPatternKind || (ct.FileOperationPatternKind = {}));
      (function(t) {
        t.method = "workspace/willCreateFiles", t.messageDirection = Fr.MessageDirection.clientToServer, t.type = new Fr.ProtocolRequestType(t.method);
      })(ct.WillCreateFilesRequest || (ct.WillCreateFilesRequest = {}));
      (function(t) {
        t.method = "workspace/didCreateFiles", t.messageDirection = Fr.MessageDirection.clientToServer, t.type = new Fr.ProtocolNotificationType(t.method);
      })(ct.DidCreateFilesNotification || (ct.DidCreateFilesNotification = {}));
      (function(t) {
        t.method = "workspace/willRenameFiles", t.messageDirection = Fr.MessageDirection.clientToServer, t.type = new Fr.ProtocolRequestType(t.method);
      })(ct.WillRenameFilesRequest || (ct.WillRenameFilesRequest = {}));
      (function(t) {
        t.method = "workspace/didRenameFiles", t.messageDirection = Fr.MessageDirection.clientToServer, t.type = new Fr.ProtocolNotificationType(t.method);
      })(ct.DidRenameFilesNotification || (ct.DidRenameFilesNotification = {}));
      (function(t) {
        t.method = "workspace/didDeleteFiles", t.messageDirection = Fr.MessageDirection.clientToServer, t.type = new Fr.ProtocolNotificationType(t.method);
      })(ct.DidDeleteFilesNotification || (ct.DidDeleteFilesNotification = {}));
      (function(t) {
        t.method = "workspace/willDeleteFiles", t.messageDirection = Fr.MessageDirection.clientToServer, t.type = new Fr.ProtocolRequestType(t.method);
      })(ct.WillDeleteFilesRequest || (ct.WillDeleteFilesRequest = {}));
    });
    var w0 = f((hn) => {
      Object.defineProperty(hn, "__esModule", { value: true });
      hn.MonikerRequest = hn.MonikerKind = hn.UniquenessLevel = void 0;
      var k0 = ut();
      (function(t) {
        t.document = "document", t.project = "project", t.group = "group", t.scheme = "scheme", t.global = "global";
      })(hn.UniquenessLevel || (hn.UniquenessLevel = {}));
      (function(t) {
        t.$import = "import", t.$export = "export", t.local = "local";
      })(hn.MonikerKind || (hn.MonikerKind = {}));
      (function(t) {
        t.method = "textDocument/moniker", t.messageDirection = k0.MessageDirection.clientToServer, t.type = new k0.ProtocolRequestType(t.method);
      })(hn.MonikerRequest || (hn.MonikerRequest = {}));
    });
    var O0 = f((mn) => {
      Object.defineProperty(mn, "__esModule", { value: true });
      mn.TypeHierarchySubtypesRequest = mn.TypeHierarchySupertypesRequest = mn.TypeHierarchyPrepareRequest = void 0;
      var Ua = ut();
      (function(t) {
        t.method = "textDocument/prepareTypeHierarchy", t.messageDirection = Ua.MessageDirection.clientToServer, t.type = new Ua.ProtocolRequestType(t.method);
      })(mn.TypeHierarchyPrepareRequest || (mn.TypeHierarchyPrepareRequest = {}));
      (function(t) {
        t.method = "typeHierarchy/supertypes", t.messageDirection = Ua.MessageDirection.clientToServer, t.type = new Ua.ProtocolRequestType(t.method);
      })(mn.TypeHierarchySupertypesRequest || (mn.TypeHierarchySupertypesRequest = {}));
      (function(t) {
        t.method = "typeHierarchy/subtypes", t.messageDirection = Ua.MessageDirection.clientToServer, t.type = new Ua.ProtocolRequestType(t.method);
      })(mn.TypeHierarchySubtypesRequest || (mn.TypeHierarchySubtypesRequest = {}));
    });
    var D0 = f((Zi) => {
      Object.defineProperty(Zi, "__esModule", { value: true });
      Zi.InlineValueRefreshRequest = Zi.InlineValueRequest = void 0;
      var Nl = ut();
      (function(t) {
        t.method = "textDocument/inlineValue", t.messageDirection = Nl.MessageDirection.clientToServer, t.type = new Nl.ProtocolRequestType(t.method);
      })(Zi.InlineValueRequest || (Zi.InlineValueRequest = {}));
      (function(t) {
        t.method = "workspace/inlineValue/refresh", t.messageDirection = Nl.MessageDirection.clientToServer, t.type = new Nl.ProtocolRequestType0(t.method);
      })(Zi.InlineValueRefreshRequest || (Zi.InlineValueRefreshRequest = {}));
    });
    var I0 = f((gn) => {
      Object.defineProperty(gn, "__esModule", { value: true });
      gn.InlayHintRefreshRequest = gn.InlayHintResolveRequest = gn.InlayHintRequest = void 0;
      var Ga = ut();
      (function(t) {
        t.method = "textDocument/inlayHint", t.messageDirection = Ga.MessageDirection.clientToServer, t.type = new Ga.ProtocolRequestType(t.method);
      })(gn.InlayHintRequest || (gn.InlayHintRequest = {}));
      (function(t) {
        t.method = "inlayHint/resolve", t.messageDirection = Ga.MessageDirection.clientToServer, t.type = new Ga.ProtocolRequestType(t.method);
      })(gn.InlayHintResolveRequest || (gn.InlayHintResolveRequest = {}));
      (function(t) {
        t.method = "workspace/inlayHint/refresh", t.messageDirection = Ga.MessageDirection.clientToServer, t.type = new Ga.ProtocolRequestType0(t.method);
      })(gn.InlayHintRefreshRequest || (gn.InlayHintRefreshRequest = {}));
    });
    var q0 = f((Wt) => {
      Object.defineProperty(Wt, "__esModule", { value: true });
      Wt.DiagnosticRefreshRequest = Wt.WorkspaceDiagnosticRequest = Wt.DocumentDiagnosticRequest = Wt.DocumentDiagnosticReportKind = Wt.DiagnosticServerCancellationData = void 0;
      var x0 = Fn(), BF = bl(), Ha = ut();
      (function(t) {
        function e(r) {
          let n = r;
          return n && BF.boolean(n.retriggerRequest);
        }
        t.is = e;
      })(Wt.DiagnosticServerCancellationData || (Wt.DiagnosticServerCancellationData = {}));
      (function(t) {
        t.Full = "full", t.Unchanged = "unchanged";
      })(Wt.DocumentDiagnosticReportKind || (Wt.DocumentDiagnosticReportKind = {}));
      (function(t) {
        t.method = "textDocument/diagnostic", t.messageDirection = Ha.MessageDirection.clientToServer, t.type = new Ha.ProtocolRequestType(t.method), t.partialResult = new x0.ProgressType();
      })(Wt.DocumentDiagnosticRequest || (Wt.DocumentDiagnosticRequest = {}));
      (function(t) {
        t.method = "workspace/diagnostic", t.messageDirection = Ha.MessageDirection.clientToServer, t.type = new Ha.ProtocolRequestType(t.method), t.partialResult = new x0.ProgressType();
      })(Wt.WorkspaceDiagnosticRequest || (Wt.WorkspaceDiagnosticRequest = {}));
      (function(t) {
        t.method = "workspace/diagnostic/refresh", t.messageDirection = Ha.MessageDirection.clientToServer, t.type = new Ha.ProtocolRequestType0(t.method);
      })(Wt.DiagnosticRefreshRequest || (Wt.DiagnosticRefreshRequest = {}));
    });
    var $0 = f((Re) => {
      Object.defineProperty(Re, "__esModule", { value: true });
      Re.DidCloseNotebookDocumentNotification = Re.DidSaveNotebookDocumentNotification = Re.DidChangeNotebookDocumentNotification = Re.NotebookCellArrayChange = Re.DidOpenNotebookDocumentNotification = Re.NotebookDocumentSyncRegistrationType = Re.NotebookDocument = Re.NotebookCell = Re.ExecutionSummary = Re.NotebookCellKind = void 0;
      var Fu = $a(), yn = bl(), jn = ut(), L0;
      (function(t) {
        t.Markup = 1, t.Code = 2;
        function e(r) {
          return r === 1 || r === 2;
        }
        t.is = e;
      })(L0 = Re.NotebookCellKind || (Re.NotebookCellKind = {}));
      var M0;
      (function(t) {
        function e(i, o) {
          let a = { executionOrder: i };
          return (o === true || o === false) && (a.success = o), a;
        }
        t.create = e;
        function r(i) {
          let o = i;
          return yn.objectLiteral(o) && Fu.uinteger.is(o.executionOrder) && (o.success === void 0 || yn.boolean(o.success));
        }
        t.is = r;
        function n(i, o) {
          return i === o ? true : i == null || o === null || o === void 0 ? false : i.executionOrder === o.executionOrder && i.success === o.success;
        }
        t.equals = n;
      })(M0 = Re.ExecutionSummary || (Re.ExecutionSummary = {}));
      var qm;
      (function(t) {
        function e(o, a) {
          return { kind: o, document: a };
        }
        t.create = e;
        function r(o) {
          let a = o;
          return yn.objectLiteral(a) && L0.is(a.kind) && Fu.DocumentUri.is(a.document) && (a.metadata === void 0 || yn.objectLiteral(a.metadata));
        }
        t.is = r;
        function n(o, a) {
          let s = /* @__PURE__ */ new Set();
          return o.document !== a.document && s.add("document"), o.kind !== a.kind && s.add("kind"), o.executionSummary !== a.executionSummary && s.add("executionSummary"), (o.metadata !== void 0 || a.metadata !== void 0) && !i(o.metadata, a.metadata) && s.add("metadata"), (o.executionSummary !== void 0 || a.executionSummary !== void 0) && !M0.equals(o.executionSummary, a.executionSummary) && s.add("executionSummary"), s;
        }
        t.diff = n;
        function i(o, a) {
          if (o === a)
            return true;
          if (o == null || a === null || a === void 0 || typeof o != typeof a || typeof o != "object")
            return false;
          let s = Array.isArray(o), u = Array.isArray(a);
          if (s !== u)
            return false;
          if (s && u) {
            if (o.length !== a.length)
              return false;
            for (let c = 0; c < o.length; c++)
              if (!i(o[c], a[c]))
                return false;
          }
          if (yn.objectLiteral(o) && yn.objectLiteral(a)) {
            let c = Object.keys(o), l = Object.keys(a);
            if (c.length !== l.length || (c.sort(), l.sort(), !i(c, l)))
              return false;
            for (let d = 0; d < c.length; d++) {
              let h = c[d];
              if (!i(o[h], a[h]))
                return false;
            }
          }
          return true;
        }
      })(qm = Re.NotebookCell || (Re.NotebookCell = {}));
      (function(t) {
        function e(n, i, o, a) {
          return { uri: n, notebookType: i, version: o, cells: a };
        }
        t.create = e;
        function r(n) {
          let i = n;
          return yn.objectLiteral(i) && yn.string(i.uri) && Fu.integer.is(i.version) && yn.typedArray(i.cells, qm.is);
        }
        t.is = r;
      })(Re.NotebookDocument || (Re.NotebookDocument = {}));
      var ju;
      (function(t) {
        t.method = "notebookDocument/sync", t.messageDirection = jn.MessageDirection.clientToServer, t.type = new jn.RegistrationType(t.method);
      })(ju = Re.NotebookDocumentSyncRegistrationType || (Re.NotebookDocumentSyncRegistrationType = {}));
      (function(t) {
        t.method = "notebookDocument/didOpen", t.messageDirection = jn.MessageDirection.clientToServer, t.type = new jn.ProtocolNotificationType(t.method), t.registrationMethod = ju.method;
      })(Re.DidOpenNotebookDocumentNotification || (Re.DidOpenNotebookDocumentNotification = {}));
      (function(t) {
        function e(n) {
          let i = n;
          return yn.objectLiteral(i) && Fu.uinteger.is(i.start) && Fu.uinteger.is(i.deleteCount) && (i.cells === void 0 || yn.typedArray(i.cells, qm.is));
        }
        t.is = e;
        function r(n, i, o) {
          let a = { start: n, deleteCount: i };
          return o !== void 0 && (a.cells = o), a;
        }
        t.create = r;
      })(Re.NotebookCellArrayChange || (Re.NotebookCellArrayChange = {}));
      (function(t) {
        t.method = "notebookDocument/didChange", t.messageDirection = jn.MessageDirection.clientToServer, t.type = new jn.ProtocolNotificationType(t.method), t.registrationMethod = ju.method;
      })(Re.DidChangeNotebookDocumentNotification || (Re.DidChangeNotebookDocumentNotification = {}));
      (function(t) {
        t.method = "notebookDocument/didSave", t.messageDirection = jn.MessageDirection.clientToServer, t.type = new jn.ProtocolNotificationType(t.method), t.registrationMethod = ju.method;
      })(Re.DidSaveNotebookDocumentNotification || (Re.DidSaveNotebookDocumentNotification = {}));
      (function(t) {
        t.method = "notebookDocument/didClose", t.messageDirection = jn.MessageDirection.clientToServer, t.type = new jn.ProtocolNotificationType(t.method), t.registrationMethod = ju.method;
      })(Re.DidCloseNotebookDocumentNotification || (Re.DidCloseNotebookDocumentNotification = {}));
    });
    var z0 = f((v) => {
      Object.defineProperty(v, "__esModule", { value: true });
      v.WorkspaceSymbolRequest = v.CodeActionResolveRequest = v.CodeActionRequest = v.DocumentSymbolRequest = v.DocumentHighlightRequest = v.ReferencesRequest = v.DefinitionRequest = v.SignatureHelpRequest = v.SignatureHelpTriggerKind = v.HoverRequest = v.CompletionResolveRequest = v.CompletionRequest = v.CompletionTriggerKind = v.PublishDiagnosticsNotification = v.WatchKind = v.RelativePattern = v.FileChangeType = v.DidChangeWatchedFilesNotification = v.WillSaveTextDocumentWaitUntilRequest = v.WillSaveTextDocumentNotification = v.TextDocumentSaveReason = v.DidSaveTextDocumentNotification = v.DidCloseTextDocumentNotification = v.DidChangeTextDocumentNotification = v.TextDocumentContentChangeEvent = v.DidOpenTextDocumentNotification = v.TextDocumentSyncKind = v.TelemetryEventNotification = v.LogMessageNotification = v.ShowMessageRequest = v.ShowMessageNotification = v.MessageType = v.DidChangeConfigurationNotification = v.ExitNotification = v.ShutdownRequest = v.InitializedNotification = v.InitializeErrorCodes = v.InitializeRequest = v.WorkDoneProgressOptions = v.TextDocumentRegistrationOptions = v.StaticRegistrationOptions = v.PositionEncodingKind = v.FailureHandlingKind = v.ResourceOperationKind = v.UnregistrationRequest = v.RegistrationRequest = v.DocumentSelector = v.NotebookCellTextDocumentFilter = v.NotebookDocumentFilter = v.TextDocumentFilter = void 0;
      v.TypeHierarchySubtypesRequest = v.TypeHierarchyPrepareRequest = v.MonikerRequest = v.MonikerKind = v.UniquenessLevel = v.WillDeleteFilesRequest = v.DidDeleteFilesNotification = v.WillRenameFilesRequest = v.DidRenameFilesNotification = v.WillCreateFilesRequest = v.DidCreateFilesNotification = v.FileOperationPatternKind = v.LinkedEditingRangeRequest = v.ShowDocumentRequest = v.SemanticTokensRegistrationType = v.SemanticTokensRefreshRequest = v.SemanticTokensRangeRequest = v.SemanticTokensDeltaRequest = v.SemanticTokensRequest = v.TokenFormat = v.CallHierarchyPrepareRequest = v.CallHierarchyOutgoingCallsRequest = v.CallHierarchyIncomingCallsRequest = v.WorkDoneProgressCancelNotification = v.WorkDoneProgressCreateRequest = v.WorkDoneProgress = v.SelectionRangeRequest = v.DeclarationRequest = v.FoldingRangeRequest = v.ColorPresentationRequest = v.DocumentColorRequest = v.ConfigurationRequest = v.DidChangeWorkspaceFoldersNotification = v.WorkspaceFoldersRequest = v.TypeDefinitionRequest = v.ImplementationRequest = v.ApplyWorkspaceEditRequest = v.ExecuteCommandRequest = v.PrepareRenameRequest = v.RenameRequest = v.PrepareSupportDefaultBehavior = v.DocumentOnTypeFormattingRequest = v.DocumentRangeFormattingRequest = v.DocumentFormattingRequest = v.DocumentLinkResolveRequest = v.DocumentLinkRequest = v.CodeLensRefreshRequest = v.CodeLensResolveRequest = v.CodeLensRequest = v.WorkspaceSymbolResolveRequest = void 0;
      v.DidCloseNotebookDocumentNotification = v.DidSaveNotebookDocumentNotification = v.DidChangeNotebookDocumentNotification = v.NotebookCellArrayChange = v.DidOpenNotebookDocumentNotification = v.NotebookDocumentSyncRegistrationType = v.NotebookDocument = v.NotebookCell = v.ExecutionSummary = v.NotebookCellKind = v.DiagnosticRefreshRequest = v.WorkspaceDiagnosticRequest = v.DocumentDiagnosticRequest = v.DocumentDiagnosticReportKind = v.DiagnosticServerCancellationData = v.InlayHintRefreshRequest = v.InlayHintResolveRequest = v.InlayHintRequest = v.InlineValueRefreshRequest = v.InlineValueRequest = v.TypeHierarchySupertypesRequest = void 0;
      var $ = ut(), F0 = $a(), Bt = bl(), nj = u0();
      Object.defineProperty(v, "ImplementationRequest", { enumerable: true, get: function() {
        return nj.ImplementationRequest;
      } });
      var ij = l0();
      Object.defineProperty(v, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return ij.TypeDefinitionRequest;
      } });
      var j0 = d0();
      Object.defineProperty(v, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return j0.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(v, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return j0.DidChangeWorkspaceFoldersNotification;
      } });
      var oj = p0();
      Object.defineProperty(v, "ConfigurationRequest", { enumerable: true, get: function() {
        return oj.ConfigurationRequest;
      } });
      var U0 = h0();
      Object.defineProperty(v, "DocumentColorRequest", { enumerable: true, get: function() {
        return U0.DocumentColorRequest;
      } });
      Object.defineProperty(v, "ColorPresentationRequest", { enumerable: true, get: function() {
        return U0.ColorPresentationRequest;
      } });
      var aj = g0();
      Object.defineProperty(v, "FoldingRangeRequest", { enumerable: true, get: function() {
        return aj.FoldingRangeRequest;
      } });
      var sj = v0();
      Object.defineProperty(v, "DeclarationRequest", { enumerable: true, get: function() {
        return sj.DeclarationRequest;
      } });
      var uj = _0();
      Object.defineProperty(v, "SelectionRangeRequest", { enumerable: true, get: function() {
        return uj.SelectionRangeRequest;
      } });
      var Lm = R0();
      Object.defineProperty(v, "WorkDoneProgress", { enumerable: true, get: function() {
        return Lm.WorkDoneProgress;
      } });
      Object.defineProperty(v, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return Lm.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(v, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return Lm.WorkDoneProgressCancelNotification;
      } });
      var Mm = b0();
      Object.defineProperty(v, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return Mm.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(v, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return Mm.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(v, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return Mm.CallHierarchyPrepareRequest;
      } });
      var Wa = S0();
      Object.defineProperty(v, "TokenFormat", { enumerable: true, get: function() {
        return Wa.TokenFormat;
      } });
      Object.defineProperty(v, "SemanticTokensRequest", { enumerable: true, get: function() {
        return Wa.SemanticTokensRequest;
      } });
      Object.defineProperty(v, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return Wa.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(v, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return Wa.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(v, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return Wa.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(v, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return Wa.SemanticTokensRegistrationType;
      } });
      var cj = P0();
      Object.defineProperty(v, "ShowDocumentRequest", { enumerable: true, get: function() {
        return cj.ShowDocumentRequest;
      } });
      var lj = N0();
      Object.defineProperty(v, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return lj.LinkedEditingRangeRequest;
      } });
      var Bo = E0();
      Object.defineProperty(v, "FileOperationPatternKind", { enumerable: true, get: function() {
        return Bo.FileOperationPatternKind;
      } });
      Object.defineProperty(v, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return Bo.DidCreateFilesNotification;
      } });
      Object.defineProperty(v, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return Bo.WillCreateFilesRequest;
      } });
      Object.defineProperty(v, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return Bo.DidRenameFilesNotification;
      } });
      Object.defineProperty(v, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return Bo.WillRenameFilesRequest;
      } });
      Object.defineProperty(v, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return Bo.DidDeleteFilesNotification;
      } });
      Object.defineProperty(v, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return Bo.WillDeleteFilesRequest;
      } });
      var $m = w0();
      Object.defineProperty(v, "UniquenessLevel", { enumerable: true, get: function() {
        return $m.UniquenessLevel;
      } });
      Object.defineProperty(v, "MonikerKind", { enumerable: true, get: function() {
        return $m.MonikerKind;
      } });
      Object.defineProperty(v, "MonikerRequest", { enumerable: true, get: function() {
        return $m.MonikerRequest;
      } });
      var Fm = O0();
      Object.defineProperty(v, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return Fm.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(v, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return Fm.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(v, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return Fm.TypeHierarchySupertypesRequest;
      } });
      var G0 = D0();
      Object.defineProperty(v, "InlineValueRequest", { enumerable: true, get: function() {
        return G0.InlineValueRequest;
      } });
      Object.defineProperty(v, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return G0.InlineValueRefreshRequest;
      } });
      var jm = I0();
      Object.defineProperty(v, "InlayHintRequest", { enumerable: true, get: function() {
        return jm.InlayHintRequest;
      } });
      Object.defineProperty(v, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return jm.InlayHintResolveRequest;
      } });
      Object.defineProperty(v, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return jm.InlayHintRefreshRequest;
      } });
      var Uu = q0();
      Object.defineProperty(v, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return Uu.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(v, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return Uu.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(v, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return Uu.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(v, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return Uu.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(v, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return Uu.DiagnosticRefreshRequest;
      } });
      var Un = $0();
      Object.defineProperty(v, "NotebookCellKind", { enumerable: true, get: function() {
        return Un.NotebookCellKind;
      } });
      Object.defineProperty(v, "ExecutionSummary", { enumerable: true, get: function() {
        return Un.ExecutionSummary;
      } });
      Object.defineProperty(v, "NotebookCell", { enumerable: true, get: function() {
        return Un.NotebookCell;
      } });
      Object.defineProperty(v, "NotebookDocument", { enumerable: true, get: function() {
        return Un.NotebookDocument;
      } });
      Object.defineProperty(v, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return Un.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(v, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return Un.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(v, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return Un.NotebookCellArrayChange;
      } });
      Object.defineProperty(v, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return Un.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(v, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return Un.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(v, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return Un.DidCloseNotebookDocumentNotification;
      } });
      var H0;
      (function(t) {
        function e(r) {
          let n = r;
          return Bt.string(n.language) || Bt.string(n.scheme) || Bt.string(n.pattern);
        }
        t.is = e;
      })(H0 = v.TextDocumentFilter || (v.TextDocumentFilter = {}));
      var W0;
      (function(t) {
        function e(r) {
          let n = r;
          return Bt.objectLiteral(n) && (Bt.string(n.notebookType) || Bt.string(n.scheme) || Bt.string(n.pattern));
        }
        t.is = e;
      })(W0 = v.NotebookDocumentFilter || (v.NotebookDocumentFilter = {}));
      var B0;
      (function(t) {
        function e(r) {
          let n = r;
          return Bt.objectLiteral(n) && (Bt.string(n.notebook) || W0.is(n.notebook)) && (n.language === void 0 || Bt.string(n.language));
        }
        t.is = e;
      })(B0 = v.NotebookCellTextDocumentFilter || (v.NotebookCellTextDocumentFilter = {}));
      var K0;
      (function(t) {
        function e(r) {
          if (!Array.isArray(r))
            return false;
          for (let n of r)
            if (!Bt.string(n) && !H0.is(n) && !B0.is(n))
              return false;
          return true;
        }
        t.is = e;
      })(K0 = v.DocumentSelector || (v.DocumentSelector = {}));
      (function(t) {
        t.method = "client/registerCapability", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolRequestType(t.method);
      })(v.RegistrationRequest || (v.RegistrationRequest = {}));
      (function(t) {
        t.method = "client/unregisterCapability", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolRequestType(t.method);
      })(v.UnregistrationRequest || (v.UnregistrationRequest = {}));
      (function(t) {
        t.Create = "create", t.Rename = "rename", t.Delete = "delete";
      })(v.ResourceOperationKind || (v.ResourceOperationKind = {}));
      (function(t) {
        t.Abort = "abort", t.Transactional = "transactional", t.TextOnlyTransactional = "textOnlyTransactional", t.Undo = "undo";
      })(v.FailureHandlingKind || (v.FailureHandlingKind = {}));
      (function(t) {
        t.UTF8 = "utf-8", t.UTF16 = "utf-16", t.UTF32 = "utf-32";
      })(v.PositionEncodingKind || (v.PositionEncodingKind = {}));
      (function(t) {
        function e(r) {
          let n = r;
          return n && Bt.string(n.id) && n.id.length > 0;
        }
        t.hasId = e;
      })(v.StaticRegistrationOptions || (v.StaticRegistrationOptions = {}));
      (function(t) {
        function e(r) {
          let n = r;
          return n && (n.documentSelector === null || K0.is(n.documentSelector));
        }
        t.is = e;
      })(v.TextDocumentRegistrationOptions || (v.TextDocumentRegistrationOptions = {}));
      (function(t) {
        function e(n) {
          let i = n;
          return Bt.objectLiteral(i) && (i.workDoneProgress === void 0 || Bt.boolean(i.workDoneProgress));
        }
        t.is = e;
        function r(n) {
          let i = n;
          return i && Bt.boolean(i.workDoneProgress);
        }
        t.hasWorkDoneProgress = r;
      })(v.WorkDoneProgressOptions || (v.WorkDoneProgressOptions = {}));
      (function(t) {
        t.method = "initialize", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.InitializeRequest || (v.InitializeRequest = {}));
      (function(t) {
        t.unknownProtocolVersion = 1;
      })(v.InitializeErrorCodes || (v.InitializeErrorCodes = {}));
      (function(t) {
        t.method = "initialized", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.InitializedNotification || (v.InitializedNotification = {}));
      (function(t) {
        t.method = "shutdown", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType0(t.method);
      })(v.ShutdownRequest || (v.ShutdownRequest = {}));
      (function(t) {
        t.method = "exit", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType0(t.method);
      })(v.ExitNotification || (v.ExitNotification = {}));
      (function(t) {
        t.method = "workspace/didChangeConfiguration", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.DidChangeConfigurationNotification || (v.DidChangeConfigurationNotification = {}));
      (function(t) {
        t.Error = 1, t.Warning = 2, t.Info = 3, t.Log = 4;
      })(v.MessageType || (v.MessageType = {}));
      (function(t) {
        t.method = "window/showMessage", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolNotificationType(t.method);
      })(v.ShowMessageNotification || (v.ShowMessageNotification = {}));
      (function(t) {
        t.method = "window/showMessageRequest", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolRequestType(t.method);
      })(v.ShowMessageRequest || (v.ShowMessageRequest = {}));
      (function(t) {
        t.method = "window/logMessage", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolNotificationType(t.method);
      })(v.LogMessageNotification || (v.LogMessageNotification = {}));
      (function(t) {
        t.method = "telemetry/event", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolNotificationType(t.method);
      })(v.TelemetryEventNotification || (v.TelemetryEventNotification = {}));
      (function(t) {
        t.None = 0, t.Full = 1, t.Incremental = 2;
      })(v.TextDocumentSyncKind || (v.TextDocumentSyncKind = {}));
      (function(t) {
        t.method = "textDocument/didOpen", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.DidOpenTextDocumentNotification || (v.DidOpenTextDocumentNotification = {}));
      (function(t) {
        function e(n) {
          let i = n;
          return i != null && typeof i.text == "string" && i.range !== void 0 && (i.rangeLength === void 0 || typeof i.rangeLength == "number");
        }
        t.isIncremental = e;
        function r(n) {
          let i = n;
          return i != null && typeof i.text == "string" && i.range === void 0 && i.rangeLength === void 0;
        }
        t.isFull = r;
      })(v.TextDocumentContentChangeEvent || (v.TextDocumentContentChangeEvent = {}));
      (function(t) {
        t.method = "textDocument/didChange", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.DidChangeTextDocumentNotification || (v.DidChangeTextDocumentNotification = {}));
      (function(t) {
        t.method = "textDocument/didClose", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.DidCloseTextDocumentNotification || (v.DidCloseTextDocumentNotification = {}));
      (function(t) {
        t.method = "textDocument/didSave", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.DidSaveTextDocumentNotification || (v.DidSaveTextDocumentNotification = {}));
      (function(t) {
        t.Manual = 1, t.AfterDelay = 2, t.FocusOut = 3;
      })(v.TextDocumentSaveReason || (v.TextDocumentSaveReason = {}));
      (function(t) {
        t.method = "textDocument/willSave", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.WillSaveTextDocumentNotification || (v.WillSaveTextDocumentNotification = {}));
      (function(t) {
        t.method = "textDocument/willSaveWaitUntil", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.WillSaveTextDocumentWaitUntilRequest || (v.WillSaveTextDocumentWaitUntilRequest = {}));
      (function(t) {
        t.method = "workspace/didChangeWatchedFiles", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolNotificationType(t.method);
      })(v.DidChangeWatchedFilesNotification || (v.DidChangeWatchedFilesNotification = {}));
      (function(t) {
        t.Created = 1, t.Changed = 2, t.Deleted = 3;
      })(v.FileChangeType || (v.FileChangeType = {}));
      (function(t) {
        function e(r) {
          let n = r;
          return Bt.objectLiteral(n) && (F0.URI.is(n.baseUri) || F0.WorkspaceFolder.is(n.baseUri)) && Bt.string(n.pattern);
        }
        t.is = e;
      })(v.RelativePattern || (v.RelativePattern = {}));
      (function(t) {
        t.Create = 1, t.Change = 2, t.Delete = 4;
      })(v.WatchKind || (v.WatchKind = {}));
      (function(t) {
        t.method = "textDocument/publishDiagnostics", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolNotificationType(t.method);
      })(v.PublishDiagnosticsNotification || (v.PublishDiagnosticsNotification = {}));
      (function(t) {
        t.Invoked = 1, t.TriggerCharacter = 2, t.TriggerForIncompleteCompletions = 3;
      })(v.CompletionTriggerKind || (v.CompletionTriggerKind = {}));
      (function(t) {
        t.method = "textDocument/completion", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.CompletionRequest || (v.CompletionRequest = {}));
      (function(t) {
        t.method = "completionItem/resolve", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.CompletionResolveRequest || (v.CompletionResolveRequest = {}));
      (function(t) {
        t.method = "textDocument/hover", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.HoverRequest || (v.HoverRequest = {}));
      (function(t) {
        t.Invoked = 1, t.TriggerCharacter = 2, t.ContentChange = 3;
      })(v.SignatureHelpTriggerKind || (v.SignatureHelpTriggerKind = {}));
      (function(t) {
        t.method = "textDocument/signatureHelp", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.SignatureHelpRequest || (v.SignatureHelpRequest = {}));
      (function(t) {
        t.method = "textDocument/definition", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DefinitionRequest || (v.DefinitionRequest = {}));
      (function(t) {
        t.method = "textDocument/references", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.ReferencesRequest || (v.ReferencesRequest = {}));
      (function(t) {
        t.method = "textDocument/documentHighlight", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DocumentHighlightRequest || (v.DocumentHighlightRequest = {}));
      (function(t) {
        t.method = "textDocument/documentSymbol", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DocumentSymbolRequest || (v.DocumentSymbolRequest = {}));
      (function(t) {
        t.method = "textDocument/codeAction", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.CodeActionRequest || (v.CodeActionRequest = {}));
      (function(t) {
        t.method = "codeAction/resolve", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.CodeActionResolveRequest || (v.CodeActionResolveRequest = {}));
      (function(t) {
        t.method = "workspace/symbol", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.WorkspaceSymbolRequest || (v.WorkspaceSymbolRequest = {}));
      (function(t) {
        t.method = "workspaceSymbol/resolve", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.WorkspaceSymbolResolveRequest || (v.WorkspaceSymbolResolveRequest = {}));
      (function(t) {
        t.method = "textDocument/codeLens", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.CodeLensRequest || (v.CodeLensRequest = {}));
      (function(t) {
        t.method = "codeLens/resolve", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.CodeLensResolveRequest || (v.CodeLensResolveRequest = {}));
      (function(t) {
        t.method = "workspace/codeLens/refresh", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolRequestType0(t.method);
      })(v.CodeLensRefreshRequest || (v.CodeLensRefreshRequest = {}));
      (function(t) {
        t.method = "textDocument/documentLink", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DocumentLinkRequest || (v.DocumentLinkRequest = {}));
      (function(t) {
        t.method = "documentLink/resolve", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DocumentLinkResolveRequest || (v.DocumentLinkResolveRequest = {}));
      (function(t) {
        t.method = "textDocument/formatting", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DocumentFormattingRequest || (v.DocumentFormattingRequest = {}));
      (function(t) {
        t.method = "textDocument/rangeFormatting", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DocumentRangeFormattingRequest || (v.DocumentRangeFormattingRequest = {}));
      (function(t) {
        t.method = "textDocument/onTypeFormatting", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.DocumentOnTypeFormattingRequest || (v.DocumentOnTypeFormattingRequest = {}));
      (function(t) {
        t.Identifier = 1;
      })(v.PrepareSupportDefaultBehavior || (v.PrepareSupportDefaultBehavior = {}));
      (function(t) {
        t.method = "textDocument/rename", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.RenameRequest || (v.RenameRequest = {}));
      (function(t) {
        t.method = "textDocument/prepareRename", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.PrepareRenameRequest || (v.PrepareRenameRequest = {}));
      (function(t) {
        t.method = "workspace/executeCommand", t.messageDirection = $.MessageDirection.clientToServer, t.type = new $.ProtocolRequestType(t.method);
      })(v.ExecuteCommandRequest || (v.ExecuteCommandRequest = {}));
      (function(t) {
        t.method = "workspace/applyEdit", t.messageDirection = $.MessageDirection.serverToClient, t.type = new $.ProtocolRequestType("workspace/applyEdit");
      })(v.ApplyWorkspaceEditRequest || (v.ApplyWorkspaceEditRequest = {}));
    });
    var Y0 = f((El) => {
      Object.defineProperty(El, "__esModule", { value: true });
      El.createProtocolConnection = void 0;
      var V0 = Fn();
      function yU(t, e, r, n) {
        return V0.ConnectionStrategy.is(n) && (n = { connectionStrategy: n }), (0, V0.createMessageConnection)(t, e, r, n);
      }
      El.createProtocolConnection = yU;
    });
    var X0 = f((ur) => {
      var vU = ur && ur.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), kl = ur && ur.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && vU(e, t, r);
      };
      Object.defineProperty(ur, "__esModule", { value: true });
      ur.LSPErrorCodes = ur.createProtocolConnection = void 0;
      kl(Fn(), ur);
      kl($a(), ur);
      kl(ut(), ur);
      kl(z0(), ur);
      var TU = Y0();
      Object.defineProperty(ur, "createProtocolConnection", { enumerable: true, get: function() {
        return TU.createProtocolConnection;
      } });
      (function(t) {
        t.lspReservedErrorRangeStart = -32899, t.RequestFailed = -32803, t.ServerCancelled = -32802, t.ContentModified = -32801, t.RequestCancelled = -32800, t.lspReservedErrorRangeEnd = -32800;
      })(ur.LSPErrorCodes || (ur.LSPErrorCodes = {}));
    });
    var bt = f((Gn) => {
      var RU = Gn && Gn.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), J0 = Gn && Gn.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && RU(e, t, r);
      };
      Object.defineProperty(Gn, "__esModule", { value: true });
      Gn.createProtocolConnection = void 0;
      var bU = km();
      J0(km(), Gn);
      J0(X0(), Gn);
      function SU(t, e, r, n) {
        return (0, bU.createMessageConnection)(t, e, r, n);
      }
      Gn.createProtocolConnection = SU;
    });
    var Gm = f((eo) => {
      Object.defineProperty(eo, "__esModule", { value: true });
      eo.SemanticTokensBuilder = eo.SemanticTokensDiff = eo.SemanticTokensFeature = void 0;
      var wl = bt(), AU = (t) => class extends t {
        get semanticTokens() {
          return { refresh: () => this.connection.sendRequest(wl.SemanticTokensRefreshRequest.type), on: (e) => {
            let r = wl.SemanticTokensRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          }, onDelta: (e) => {
            let r = wl.SemanticTokensDeltaRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          }, onRange: (e) => {
            let r = wl.SemanticTokensRangeRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          } };
        }
      };
      eo.SemanticTokensFeature = AU;
      var Ol = class {
        constructor(e, r) {
          this.originalSequence = e, this.modifiedSequence = r;
        }
        computeDiff() {
          let e = this.originalSequence.length, r = this.modifiedSequence.length, n = 0;
          for (; n < r && n < e && this.originalSequence[n] === this.modifiedSequence[n]; )
            n++;
          if (n < r && n < e) {
            let i = e - 1, o = r - 1;
            for (; i >= n && o >= n && this.originalSequence[i] === this.modifiedSequence[o]; )
              i--, o--;
            (i < n || o < n) && (i++, o++);
            let a = i - n + 1, s = this.modifiedSequence.slice(n, o + 1);
            return s.length === 1 && s[0] === this.originalSequence[i] ? [{ start: n, deleteCount: a - 1 }] : [{ start: n, deleteCount: a, data: s }];
          } else
            return n < r ? [{ start: n, deleteCount: 0, data: this.modifiedSequence.slice(n) }] : n < e ? [{ start: n, deleteCount: e - n }] : [];
        }
      };
      eo.SemanticTokensDiff = Ol;
      var Um = class {
        constructor() {
          this._prevData = void 0, this.initialize();
        }
        initialize() {
          this._id = Date.now(), this._prevLine = 0, this._prevChar = 0, this._data = [], this._dataLen = 0;
        }
        push(e, r, n, i, o) {
          let a = e, s = r;
          this._dataLen > 0 && (a -= this._prevLine, a === 0 && (s -= this._prevChar)), this._data[this._dataLen++] = a, this._data[this._dataLen++] = s, this._data[this._dataLen++] = n, this._data[this._dataLen++] = i, this._data[this._dataLen++] = o, this._prevLine = e, this._prevChar = r;
        }
        get id() {
          return this._id.toString();
        }
        previousResult(e) {
          this.id === e && (this._prevData = this._data), this.initialize();
        }
        build() {
          return this._prevData = void 0, { resultId: this.id, data: this._data };
        }
        canBuildEdits() {
          return this._prevData !== void 0;
        }
        buildEdits() {
          return this._prevData !== void 0 ? { resultId: this.id, edits: new Ol(this._prevData, this._data).computeDiff() } : this.build();
        }
      };
      eo.SemanticTokensBuilder = Um;
    });
    var Wm = f((Dl) => {
      Object.defineProperty(Dl, "__esModule", { value: true });
      Dl.TextDocuments = void 0;
      var Ko = bt(), Hm = class {
        constructor(e) {
          this._configuration = e, this._syncedDocuments = /* @__PURE__ */ new Map(), this._onDidChangeContent = new Ko.Emitter(), this._onDidOpen = new Ko.Emitter(), this._onDidClose = new Ko.Emitter(), this._onDidSave = new Ko.Emitter(), this._onWillSave = new Ko.Emitter();
        }
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        get onDidChangeContent() {
          return this._onDidChangeContent.event;
        }
        get onWillSave() {
          return this._onWillSave.event;
        }
        onWillSaveWaitUntil(e) {
          this._willSaveWaitUntil = e;
        }
        get onDidSave() {
          return this._onDidSave.event;
        }
        get onDidClose() {
          return this._onDidClose.event;
        }
        get(e) {
          return this._syncedDocuments.get(e);
        }
        all() {
          return Array.from(this._syncedDocuments.values());
        }
        keys() {
          return Array.from(this._syncedDocuments.keys());
        }
        listen(e) {
          e.__textDocumentSync = Ko.TextDocumentSyncKind.Incremental;
          let r = [];
          return r.push(e.onDidOpenTextDocument((n) => {
            let i = n.textDocument, o = this._configuration.create(i.uri, i.languageId, i.version, i.text);
            this._syncedDocuments.set(i.uri, o);
            let a = Object.freeze({ document: o });
            this._onDidOpen.fire(a), this._onDidChangeContent.fire(a);
          })), r.push(e.onDidChangeTextDocument((n) => {
            let i = n.textDocument, o = n.contentChanges;
            if (o.length === 0)
              return;
            let { version: a } = i;
            if (a == null)
              throw new Error(`Received document change event for ${i.uri} without valid version identifier`);
            let s = this._syncedDocuments.get(i.uri);
            s !== void 0 && (s = this._configuration.update(s, o, a), this._syncedDocuments.set(i.uri, s), this._onDidChangeContent.fire(Object.freeze({ document: s })));
          })), r.push(e.onDidCloseTextDocument((n) => {
            let i = this._syncedDocuments.get(n.textDocument.uri);
            i !== void 0 && (this._syncedDocuments.delete(n.textDocument.uri), this._onDidClose.fire(Object.freeze({ document: i })));
          })), r.push(e.onWillSaveTextDocument((n) => {
            let i = this._syncedDocuments.get(n.textDocument.uri);
            i !== void 0 && this._onWillSave.fire(Object.freeze({ document: i, reason: n.reason }));
          })), r.push(e.onWillSaveTextDocumentWaitUntil((n, i) => {
            let o = this._syncedDocuments.get(n.textDocument.uri);
            return o !== void 0 && this._willSaveWaitUntil ? this._willSaveWaitUntil(Object.freeze({ document: o, reason: n.reason }), i) : [];
          })), r.push(e.onDidSaveTextDocument((n) => {
            let i = this._syncedDocuments.get(n.textDocument.uri);
            i !== void 0 && this._onDidSave.fire(Object.freeze({ document: i }));
          })), Ko.Disposable.create(() => {
            r.forEach((n) => n.dispose());
          });
        }
      };
      Dl.TextDocuments = Hm;
    });
    var Km = f((Ba) => {
      Object.defineProperty(Ba, "__esModule", { value: true });
      Ba.NotebookDocuments = Ba.NotebookSyncFeature = void 0;
      var jr = bt(), Q0 = Wm(), PU = (t) => class extends t {
        get synchronization() {
          return { onDidOpenNotebookDocument: (e) => this.connection.onNotification(jr.DidOpenNotebookDocumentNotification.type, (r) => {
            e(r);
          }), onDidChangeNotebookDocument: (e) => this.connection.onNotification(jr.DidChangeNotebookDocumentNotification.type, (r) => {
            e(r);
          }), onDidSaveNotebookDocument: (e) => this.connection.onNotification(jr.DidSaveNotebookDocumentNotification.type, (r) => {
            e(r);
          }), onDidCloseNotebookDocument: (e) => this.connection.onNotification(jr.DidCloseNotebookDocumentNotification.type, (r) => {
            e(r);
          }) };
        }
      };
      Ba.NotebookSyncFeature = PU;
      var to = class {
        onDidOpenTextDocument(e) {
          return this.openHandler = e, jr.Disposable.create(() => {
            this.openHandler = void 0;
          });
        }
        openTextDocument(e) {
          this.openHandler && this.openHandler(e);
        }
        onDidChangeTextDocument(e) {
          return this.changeHandler = e, jr.Disposable.create(() => {
            this.changeHandler = e;
          });
        }
        changeTextDocument(e) {
          this.changeHandler && this.changeHandler(e);
        }
        onDidCloseTextDocument(e) {
          return this.closeHandler = e, jr.Disposable.create(() => {
            this.closeHandler = void 0;
          });
        }
        closeTextDocument(e) {
          this.closeHandler && this.closeHandler(e);
        }
        onWillSaveTextDocument() {
          return to.NULL_DISPOSE;
        }
        onWillSaveTextDocumentWaitUntil() {
          return to.NULL_DISPOSE;
        }
        onDidSaveTextDocument() {
          return to.NULL_DISPOSE;
        }
      };
      to.NULL_DISPOSE = Object.freeze({ dispose: () => {
      } });
      var Bm = class {
        constructor(e) {
          e instanceof Q0.TextDocuments ? this._cellTextDocuments = e : this._cellTextDocuments = new Q0.TextDocuments(e), this.notebookDocuments = /* @__PURE__ */ new Map(), this.notebookCellMap = /* @__PURE__ */ new Map(), this._onDidOpen = new jr.Emitter(), this._onDidChange = new jr.Emitter(), this._onDidSave = new jr.Emitter(), this._onDidClose = new jr.Emitter();
        }
        get cellTextDocuments() {
          return this._cellTextDocuments;
        }
        getCellTextDocument(e) {
          return this._cellTextDocuments.get(e.document);
        }
        getNotebookDocument(e) {
          return this.notebookDocuments.get(e);
        }
        getNotebookCell(e) {
          let r = this.notebookCellMap.get(e);
          return r && r[0];
        }
        findNotebookDocumentForCell(e) {
          let r = typeof e == "string" ? e : e.document, n = this.notebookCellMap.get(r);
          return n && n[1];
        }
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        get onDidSave() {
          return this._onDidSave.event;
        }
        get onDidChange() {
          return this._onDidChange.event;
        }
        get onDidClose() {
          return this._onDidClose.event;
        }
        listen(e) {
          let r = new to(), n = [];
          return n.push(this.cellTextDocuments.listen(r)), n.push(e.notebooks.synchronization.onDidOpenNotebookDocument((i) => {
            this.notebookDocuments.set(i.notebookDocument.uri, i.notebookDocument);
            for (let o of i.cellTextDocuments)
              r.openTextDocument({ textDocument: o });
            this.updateCellMap(i.notebookDocument), this._onDidOpen.fire(i.notebookDocument);
          })), n.push(e.notebooks.synchronization.onDidChangeNotebookDocument((i) => {
            let o = this.notebookDocuments.get(i.notebookDocument.uri);
            if (o === void 0)
              return;
            o.version = i.notebookDocument.version;
            let a = o.metadata, s = false, u = i.change;
            u.metadata !== void 0 && (s = true, o.metadata = u.metadata);
            let c = [], l = [], d = [], h = [];
            if (u.cells !== void 0) {
              let N = u.cells;
              if (N.structure !== void 0) {
                let S = N.structure.array;
                if (o.cells.splice(S.start, S.deleteCount, ...S.cells !== void 0 ? S.cells : []), N.structure.didOpen !== void 0)
                  for (let b of N.structure.didOpen)
                    r.openTextDocument({ textDocument: b }), c.push(b.uri);
                if (N.structure.didClose)
                  for (let b of N.structure.didClose)
                    r.closeTextDocument({ textDocument: b }), l.push(b.uri);
              }
              if (N.data !== void 0) {
                let S = new Map(N.data.map((b) => [b.document, b]));
                for (let b = 0; b <= o.cells.length; b++) {
                  let O = S.get(o.cells[b].document);
                  if (O !== void 0) {
                    let L = o.cells.splice(b, 1, O);
                    if (d.push({ old: L[0], new: O }), S.delete(O.document), S.size === 0)
                      break;
                  }
                }
              }
              if (N.textContent !== void 0)
                for (let S of N.textContent)
                  r.changeTextDocument({ textDocument: S.document, contentChanges: S.changes }), h.push(S.document.uri);
            }
            this.updateCellMap(o);
            let y = { notebookDocument: o };
            s && (y.metadata = { old: a, new: o.metadata });
            let m = [];
            for (let N of c)
              m.push(this.getNotebookCell(N));
            let R = [];
            for (let N of l)
              R.push(this.getNotebookCell(N));
            let C = [];
            for (let N of h)
              C.push(this.getNotebookCell(N));
            (m.length > 0 || R.length > 0 || d.length > 0 || C.length > 0) && (y.cells = { added: m, removed: R, changed: { data: d, textContent: C } }), (y.metadata !== void 0 || y.cells !== void 0) && this._onDidChange.fire(y);
          })), n.push(e.notebooks.synchronization.onDidSaveNotebookDocument((i) => {
            let o = this.notebookDocuments.get(i.notebookDocument.uri);
            o !== void 0 && this._onDidSave.fire(o);
          })), n.push(e.notebooks.synchronization.onDidCloseNotebookDocument((i) => {
            let o = this.notebookDocuments.get(i.notebookDocument.uri);
            if (o !== void 0) {
              this._onDidClose.fire(o);
              for (let a of i.cellTextDocuments)
                r.closeTextDocument({ textDocument: a });
              this.notebookDocuments.delete(i.notebookDocument.uri);
              for (let a of o.cells)
                this.notebookCellMap.delete(a.document);
            }
          })), jr.Disposable.create(() => {
            n.forEach((i) => i.dispose());
          });
        }
        updateCellMap(e) {
          for (let r of e.cells)
            this.notebookCellMap.set(r.document, [r, e]);
        }
      };
      Ba.NotebookDocuments = Bm;
    });
    var zm = f((St) => {
      Object.defineProperty(St, "__esModule", { value: true });
      St.thenable = St.typedArray = St.stringArray = St.array = St.func = St.error = St.number = St.string = St.boolean = void 0;
      function CU(t) {
        return t === true || t === false;
      }
      St.boolean = CU;
      function Z0(t) {
        return typeof t == "string" || t instanceof String;
      }
      St.string = Z0;
      function NU(t) {
        return typeof t == "number" || t instanceof Number;
      }
      St.number = NU;
      function EU(t) {
        return t instanceof Error;
      }
      St.error = EU;
      function eb(t) {
        return typeof t == "function";
      }
      St.func = eb;
      function tb(t) {
        return Array.isArray(t);
      }
      St.array = tb;
      function kU(t) {
        return tb(t) && t.every((e) => Z0(e));
      }
      St.stringArray = kU;
      function wU(t, e) {
        return Array.isArray(t) && t.every(e);
      }
      St.typedArray = wU;
      function OU(t) {
        return t && eb(t.then);
      }
      St.thenable = OU;
    });
    var Vm = f((Ur) => {
      Object.defineProperty(Ur, "__esModule", { value: true });
      Ur.generateUuid = Ur.parse = Ur.isUUID = Ur.v4 = Ur.empty = void 0;
      var Gu = class {
        constructor(e) {
          this._value = e;
        }
        asHex() {
          return this._value;
        }
        equals(e) {
          return this.asHex() === e.asHex();
        }
      }, ae = class extends Gu {
        constructor() {
          super([ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), "-", ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), "-", "4", ae._randomHex(), ae._randomHex(), ae._randomHex(), "-", ae._oneOf(ae._timeHighBits), ae._randomHex(), ae._randomHex(), ae._randomHex(), "-", ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex(), ae._randomHex()].join(""));
        }
        static _oneOf(e) {
          return e[Math.floor(e.length * Math.random())];
        }
        static _randomHex() {
          return ae._oneOf(ae._chars);
        }
      };
      ae._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      ae._timeHighBits = ["8", "9", "a", "b"];
      Ur.empty = new Gu("00000000-0000-0000-0000-000000000000");
      function rb() {
        return new ae();
      }
      Ur.v4 = rb;
      var DU = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      function nb(t) {
        return DU.test(t);
      }
      Ur.isUUID = nb;
      function IU(t) {
        if (!nb(t))
          throw new Error("invalid uuid");
        return new Gu(t);
      }
      Ur.parse = IU;
      function xU() {
        return rb().asHex();
      }
      Ur.generateUuid = xU;
    });
    var ib = f((no) => {
      Object.defineProperty(no, "__esModule", { value: true });
      no.attachPartialResult = no.ProgressFeature = no.attachWorkDone = void 0;
      var ro = bt(), qU = Vm(), Hn = class {
        constructor(e, r) {
          this._connection = e, this._token = r, Hn.Instances.set(this._token, this);
        }
        begin(e, r, n, i) {
          let o = { kind: "begin", title: e, percentage: r, message: n, cancellable: i };
          this._connection.sendProgress(ro.WorkDoneProgress.type, this._token, o);
        }
        report(e, r) {
          let n = { kind: "report" };
          typeof e == "number" ? (n.percentage = e, r !== void 0 && (n.message = r)) : n.message = e, this._connection.sendProgress(ro.WorkDoneProgress.type, this._token, n);
        }
        done() {
          Hn.Instances.delete(this._token), this._connection.sendProgress(ro.WorkDoneProgress.type, this._token, { kind: "end" });
        }
      };
      Hn.Instances = /* @__PURE__ */ new Map();
      var Il = class extends Hn {
        constructor(e, r) {
          super(e, r), this._source = new ro.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose(), super.done();
        }
        cancel() {
          this._source.cancel();
        }
      }, Hu = class {
        constructor() {
        }
        begin() {
        }
        report() {
        }
        done() {
        }
      }, xl = class extends Hu {
        constructor() {
          super(), this._source = new ro.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
        }
        cancel() {
          this._source.cancel();
        }
      };
      function LU(t, e) {
        if (e === void 0 || e.workDoneToken === void 0)
          return new Hu();
        let r = e.workDoneToken;
        return delete e.workDoneToken, new Hn(t, r);
      }
      no.attachWorkDone = LU;
      var MU = (t) => class extends t {
        constructor() {
          super(), this._progressSupported = false;
        }
        initialize(e) {
          var _a;
          super.initialize(e), ((_a = e == null ? void 0 : e.window) == null ? void 0 : _a.workDoneProgress) === true && (this._progressSupported = true, this.connection.onNotification(ro.WorkDoneProgressCancelNotification.type, (r) => {
            let n = Hn.Instances.get(r.token);
            (n instanceof Il || n instanceof xl) && n.cancel();
          }));
        }
        attachWorkDoneProgress(e) {
          return e === void 0 ? new Hu() : new Hn(this.connection, e);
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            let e = (0, qU.generateUuid)();
            return this.connection.sendRequest(ro.WorkDoneProgressCreateRequest.type, { token: e }).then(() => new Il(this.connection, e));
          } else
            return Promise.resolve(new xl());
        }
      };
      no.ProgressFeature = MU;
      var Ym;
      (function(t) {
        t.type = new ro.ProgressType();
      })(Ym || (Ym = {}));
      var Xm = class {
        constructor(e, r) {
          this._connection = e, this._token = r;
        }
        report(e) {
          this._connection.sendProgress(Ym.type, this._token, e);
        }
      };
      function $U(t, e) {
        if (e === void 0 || e.partialResultToken === void 0)
          return;
        let r = e.partialResultToken;
        return delete e.partialResultToken, new Xm(t, r);
      }
      no.attachPartialResult = $U;
    });
    var ob = f((ql) => {
      Object.defineProperty(ql, "__esModule", { value: true });
      ql.ConfigurationFeature = void 0;
      var FU = bt(), jU = zm(), UU = (t) => class extends t {
        getConfiguration(e) {
          return e ? jU.string(e) ? this._getConfiguration({ section: e }) : this._getConfiguration(e) : this._getConfiguration({});
        }
        _getConfiguration(e) {
          let r = { items: Array.isArray(e) ? e : [e] };
          return this.connection.sendRequest(FU.ConfigurationRequest.type, r).then((n) => Array.isArray(n) ? Array.isArray(e) ? n : n[0] : Array.isArray(e) ? [] : null);
        }
      };
      ql.ConfigurationFeature = UU;
    });
    var ab = f((Ml) => {
      Object.defineProperty(Ml, "__esModule", { value: true });
      Ml.WorkspaceFoldersFeature = void 0;
      var Ll = bt(), GU = (t) => class extends t {
        constructor() {
          super(), this._notificationIsAutoRegistered = false;
        }
        initialize(e) {
          super.initialize(e);
          let r = e.workspace;
          r && r.workspaceFolders && (this._onDidChangeWorkspaceFolders = new Ll.Emitter(), this.connection.onNotification(Ll.DidChangeWorkspaceFoldersNotification.type, (n) => {
            this._onDidChangeWorkspaceFolders.fire(n.event);
          }));
        }
        fillServerCapabilities(e) {
          var _a, _b;
          super.fillServerCapabilities(e);
          let r = (_b = (_a = e.workspace) == null ? void 0 : _a.workspaceFolders) == null ? void 0 : _b.changeNotifications;
          this._notificationIsAutoRegistered = r === true || typeof r == "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(Ll.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders)
            throw new Error("Client doesn't support sending workspace folder change events.");
          return !this._notificationIsAutoRegistered && !this._unregistration && (this._unregistration = this.connection.client.register(Ll.DidChangeWorkspaceFoldersNotification.type)), this._onDidChangeWorkspaceFolders.event;
        }
      };
      Ml.WorkspaceFoldersFeature = GU;
    });
    var sb = f(($l) => {
      Object.defineProperty($l, "__esModule", { value: true });
      $l.CallHierarchyFeature = void 0;
      var Jm = bt(), HU = (t) => class extends t {
        get callHierarchy() {
          return { onPrepare: (e) => this.connection.onRequest(Jm.CallHierarchyPrepareRequest.type, (r, n) => e(r, n, this.attachWorkDoneProgress(r), void 0)), onIncomingCalls: (e) => {
            let r = Jm.CallHierarchyIncomingCallsRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          }, onOutgoingCalls: (e) => {
            let r = Jm.CallHierarchyOutgoingCallsRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          } };
        }
      };
      $l.CallHierarchyFeature = HU;
    });
    var ub = f((Fl) => {
      Object.defineProperty(Fl, "__esModule", { value: true });
      Fl.ShowDocumentFeature = void 0;
      var WU = bt(), BU = (t) => class extends t {
        showDocument(e) {
          return this.connection.sendRequest(WU.ShowDocumentRequest.type, e);
        }
      };
      Fl.ShowDocumentFeature = BU;
    });
    var cb = f((jl) => {
      Object.defineProperty(jl, "__esModule", { value: true });
      jl.FileOperationsFeature = void 0;
      var Ka = bt(), KU = (t) => class extends t {
        onDidCreateFiles(e) {
          return this.connection.onNotification(Ka.DidCreateFilesNotification.type, (r) => {
            e(r);
          });
        }
        onDidRenameFiles(e) {
          return this.connection.onNotification(Ka.DidRenameFilesNotification.type, (r) => {
            e(r);
          });
        }
        onDidDeleteFiles(e) {
          return this.connection.onNotification(Ka.DidDeleteFilesNotification.type, (r) => {
            e(r);
          });
        }
        onWillCreateFiles(e) {
          return this.connection.onRequest(Ka.WillCreateFilesRequest.type, (r, n) => e(r, n));
        }
        onWillRenameFiles(e) {
          return this.connection.onRequest(Ka.WillRenameFilesRequest.type, (r, n) => e(r, n));
        }
        onWillDeleteFiles(e) {
          return this.connection.onRequest(Ka.WillDeleteFilesRequest.type, (r, n) => e(r, n));
        }
      };
      jl.FileOperationsFeature = KU;
    });
    var lb = f((Ul) => {
      Object.defineProperty(Ul, "__esModule", { value: true });
      Ul.LinkedEditingRangeFeature = void 0;
      var zU = bt(), VU = (t) => class extends t {
        onLinkedEditingRange(e) {
          return this.connection.onRequest(zU.LinkedEditingRangeRequest.type, (r, n) => e(r, n, this.attachWorkDoneProgress(r), void 0));
        }
      };
      Ul.LinkedEditingRangeFeature = VU;
    });
    var db = f((Gl) => {
      Object.defineProperty(Gl, "__esModule", { value: true });
      Gl.TypeHierarchyFeature = void 0;
      var Qm = bt(), YU = (t) => class extends t {
        get typeHierarchy() {
          return { onPrepare: (e) => this.connection.onRequest(Qm.TypeHierarchyPrepareRequest.type, (r, n) => e(r, n, this.attachWorkDoneProgress(r), void 0)), onSupertypes: (e) => {
            let r = Qm.TypeHierarchySupertypesRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          }, onSubtypes: (e) => {
            let r = Qm.TypeHierarchySubtypesRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          } };
        }
      };
      Gl.TypeHierarchyFeature = YU;
    });
    var pb = f((Hl) => {
      Object.defineProperty(Hl, "__esModule", { value: true });
      Hl.InlineValueFeature = void 0;
      var fb = bt(), XU = (t) => class extends t {
        get inlineValue() {
          return { refresh: () => this.connection.sendRequest(fb.InlineValueRefreshRequest.type), on: (e) => this.connection.onRequest(fb.InlineValueRequest.type, (r, n) => e(r, n, this.attachWorkDoneProgress(r))) };
        }
      };
      Hl.InlineValueFeature = XU;
    });
    var hb = f((Wl) => {
      Object.defineProperty(Wl, "__esModule", { value: true });
      Wl.InlayHintFeature = void 0;
      var Zm = bt(), JU = (t) => class extends t {
        get inlayHint() {
          return { refresh: () => this.connection.sendRequest(Zm.InlayHintRefreshRequest.type), on: (e) => this.connection.onRequest(Zm.InlayHintRequest.type, (r, n) => e(r, n, this.attachWorkDoneProgress(r))), resolve: (e) => this.connection.onRequest(Zm.InlayHintResolveRequest.type, (r, n) => e(r, n)) };
        }
      };
      Wl.InlayHintFeature = JU;
    });
    var mb = f((Bl) => {
      Object.defineProperty(Bl, "__esModule", { value: true });
      Bl.DiagnosticFeature = void 0;
      var Wu = bt(), QU = (t) => class extends t {
        get diagnostics() {
          return { refresh: () => this.connection.sendRequest(Wu.DiagnosticRefreshRequest.type), on: (e) => this.connection.onRequest(Wu.DocumentDiagnosticRequest.type, (r, n) => e(r, n, this.attachWorkDoneProgress(r), this.attachPartialResultProgress(Wu.DocumentDiagnosticRequest.partialResult, r))), onWorkspace: (e) => this.connection.onRequest(Wu.WorkspaceDiagnosticRequest.type, (r, n) => e(r, n, this.attachWorkDoneProgress(r), this.attachPartialResultProgress(Wu.WorkspaceDiagnosticRequest.partialResult, r))) };
        }
      };
      Bl.DiagnosticFeature = QU;
    });
    var gb = f((Kl) => {
      Object.defineProperty(Kl, "__esModule", { value: true });
      Kl.MonikerFeature = void 0;
      var ZU = bt(), eG = (t) => class extends t {
        get moniker() {
          return { on: (e) => {
            let r = ZU.MonikerRequest.type;
            return this.connection.onRequest(r, (n, i) => e(n, i, this.attachWorkDoneProgress(n), this.attachPartialResultProgress(r, n)));
          } };
        }
      };
      Kl.MonikerFeature = eG;
    });
    var kb = f((ve) => {
      Object.defineProperty(ve, "__esModule", { value: true });
      ve.createConnection = ve.combineFeatures = ve.combineNotebooksFeatures = ve.combineLanguagesFeatures = ve.combineWorkspaceFeatures = ve.combineWindowFeatures = ve.combineClientFeatures = ve.combineTracerFeatures = ve.combineTelemetryFeatures = ve.combineConsoleFeatures = ve._NotebooksImpl = ve._LanguagesImpl = ve.BulkUnregistration = ve.BulkRegistration = ve.ErrorMessageTracker = void 0;
      var G = bt(), Gr = zm(), tg = Vm(), te = ib(), tG = ob(), rG = ab(), nG = sb(), iG = Gm(), oG = ub(), aG = cb(), sG = lb(), uG = db(), cG = pb(), lG = hb(), dG = mb(), fG = Km(), pG = gb();
      function eg(t) {
        if (t !== null)
          return t;
      }
      var rg = class {
        constructor() {
          this._messages = /* @__PURE__ */ Object.create(null);
        }
        add(e) {
          let r = this._messages[e];
          r || (r = 0), r++, this._messages[e] = r;
        }
        sendErrors(e) {
          Object.keys(this._messages).forEach((r) => {
            e.window.showErrorMessage(r);
          });
        }
      };
      ve.ErrorMessageTracker = rg;
      var zl = class {
        constructor() {
        }
        rawAttach(e) {
          this._rawConnection = e;
        }
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        fillServerCapabilities(e) {
        }
        initialize(e) {
        }
        error(e) {
          this.send(G.MessageType.Error, e);
        }
        warn(e) {
          this.send(G.MessageType.Warning, e);
        }
        info(e) {
          this.send(G.MessageType.Info, e);
        }
        log(e) {
          this.send(G.MessageType.Log, e);
        }
        send(e, r) {
          this._rawConnection && this._rawConnection.sendNotification(G.LogMessageNotification.type, { type: e, message: r }).catch(() => {
            (0, G.RAL)().console.error("Sending log message failed");
          });
        }
      }, ng = class {
        constructor() {
        }
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        initialize(e) {
        }
        fillServerCapabilities(e) {
        }
        showErrorMessage(e, ...r) {
          let n = { type: G.MessageType.Error, message: e, actions: r };
          return this.connection.sendRequest(G.ShowMessageRequest.type, n).then(eg);
        }
        showWarningMessage(e, ...r) {
          let n = { type: G.MessageType.Warning, message: e, actions: r };
          return this.connection.sendRequest(G.ShowMessageRequest.type, n).then(eg);
        }
        showInformationMessage(e, ...r) {
          let n = { type: G.MessageType.Info, message: e, actions: r };
          return this.connection.sendRequest(G.ShowMessageRequest.type, n).then(eg);
        }
      }, yb = (0, oG.ShowDocumentFeature)((0, te.ProgressFeature)(ng));
      (function(t) {
        function e() {
          return new Vl();
        }
        t.create = e;
      })(ve.BulkRegistration || (ve.BulkRegistration = {}));
      var Vl = class {
        constructor() {
          this._registrations = [], this._registered = /* @__PURE__ */ new Set();
        }
        add(e, r) {
          let n = Gr.string(e) ? e : e.method;
          if (this._registered.has(n))
            throw new Error(`${n} is already added to this registration`);
          let i = tg.generateUuid();
          this._registrations.push({ id: i, method: n, registerOptions: r || {} }), this._registered.add(n);
        }
        asRegistrationParams() {
          return { registrations: this._registrations };
        }
      };
      (function(t) {
        function e() {
          return new Bu(void 0, []);
        }
        t.create = e;
      })(ve.BulkUnregistration || (ve.BulkUnregistration = {}));
      var Bu = class {
        constructor(e, r) {
          this._connection = e, this._unregistrations = /* @__PURE__ */ new Map(), r.forEach((n) => {
            this._unregistrations.set(n.method, n);
          });
        }
        get isAttached() {
          return !!this._connection;
        }
        attach(e) {
          this._connection = e;
        }
        add(e) {
          this._unregistrations.set(e.method, e);
        }
        dispose() {
          let e = [];
          for (let n of this._unregistrations.values())
            e.push(n);
          let r = { unregisterations: e };
          this._connection.sendRequest(G.UnregistrationRequest.type, r).catch(() => {
            this._connection.console.info("Bulk unregistration failed.");
          });
        }
        disposeSingle(e) {
          let r = Gr.string(e) ? e : e.method, n = this._unregistrations.get(r);
          if (!n)
            return false;
          let i = { unregisterations: [n] };
          return this._connection.sendRequest(G.UnregistrationRequest.type, i).then(() => {
            this._unregistrations.delete(r);
          }, (o) => {
            this._connection.console.info(`Un-registering request handler for ${n.id} failed.`);
          }), true;
        }
      }, Yl = class {
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        initialize(e) {
        }
        fillServerCapabilities(e) {
        }
        register(e, r, n) {
          return e instanceof Vl ? this.registerMany(e) : e instanceof Bu ? this.registerSingle1(e, r, n) : this.registerSingle2(e, r);
        }
        registerSingle1(e, r, n) {
          let i = Gr.string(r) ? r : r.method, o = tg.generateUuid(), a = { registrations: [{ id: o, method: i, registerOptions: n || {} }] };
          return e.isAttached || e.attach(this.connection), this.connection.sendRequest(G.RegistrationRequest.type, a).then((s) => (e.add({ id: o, method: i }), e), (s) => (this.connection.console.info(`Registering request handler for ${i} failed.`), Promise.reject(s)));
        }
        registerSingle2(e, r) {
          let n = Gr.string(e) ? e : e.method, i = tg.generateUuid(), o = { registrations: [{ id: i, method: n, registerOptions: r || {} }] };
          return this.connection.sendRequest(G.RegistrationRequest.type, o).then((a) => G.Disposable.create(() => {
            this.unregisterSingle(i, n).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${i} failed.`);
            });
          }), (a) => (this.connection.console.info(`Registering request handler for ${n} failed.`), Promise.reject(a)));
        }
        unregisterSingle(e, r) {
          let n = { unregisterations: [{ id: e, method: r }] };
          return this.connection.sendRequest(G.UnregistrationRequest.type, n).catch(() => {
            this.connection.console.info(`Un-registering request handler for ${e} failed.`);
          });
        }
        registerMany(e) {
          let r = e.asRegistrationParams();
          return this.connection.sendRequest(G.RegistrationRequest.type, r).then(() => new Bu(this._connection, r.registrations.map((n) => ({ id: n.id, method: n.method }))), (n) => (this.connection.console.info("Bulk registration failed."), Promise.reject(n)));
        }
      }, ig = class {
        constructor() {
        }
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        initialize(e) {
        }
        fillServerCapabilities(e) {
        }
        applyEdit(e) {
          function r(i) {
            return i && !!i.edit;
          }
          let n = r(e) ? e : { edit: e };
          return this.connection.sendRequest(G.ApplyWorkspaceEditRequest.type, n);
        }
      }, vb = (0, aG.FileOperationsFeature)((0, rG.WorkspaceFoldersFeature)((0, tG.ConfigurationFeature)(ig))), Xl = class {
        constructor() {
          this._trace = G.Trace.Off;
        }
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        initialize(e) {
        }
        fillServerCapabilities(e) {
        }
        set trace(e) {
          this._trace = e;
        }
        log(e, r) {
          this._trace !== G.Trace.Off && this.connection.sendNotification(G.LogTraceNotification.type, { message: e, verbose: this._trace === G.Trace.Verbose ? r : void 0 }).catch(() => {
          });
        }
      }, Jl = class {
        constructor() {
        }
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        initialize(e) {
        }
        fillServerCapabilities(e) {
        }
        logEvent(e) {
          this.connection.sendNotification(G.TelemetryEventNotification.type, e).catch(() => {
            this.connection.console.log("Sending TelemetryEventNotification failed");
          });
        }
      }, Ql = class {
        constructor() {
        }
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        initialize(e) {
        }
        fillServerCapabilities(e) {
        }
        attachWorkDoneProgress(e) {
          return (0, te.attachWorkDone)(this.connection, e);
        }
        attachPartialResultProgress(e, r) {
          return (0, te.attachPartialResult)(this.connection, r);
        }
      };
      ve._LanguagesImpl = Ql;
      var Tb = (0, pG.MonikerFeature)((0, dG.DiagnosticFeature)((0, lG.InlayHintFeature)((0, cG.InlineValueFeature)((0, uG.TypeHierarchyFeature)((0, sG.LinkedEditingRangeFeature)((0, iG.SemanticTokensFeature)((0, nG.CallHierarchyFeature)(Ql)))))))), Zl = class {
        constructor() {
        }
        attach(e) {
          this._connection = e;
        }
        get connection() {
          if (!this._connection)
            throw new Error("Remote is not attached to a connection yet.");
          return this._connection;
        }
        initialize(e) {
        }
        fillServerCapabilities(e) {
        }
        attachWorkDoneProgress(e) {
          return (0, te.attachWorkDone)(this.connection, e);
        }
        attachPartialResultProgress(e, r) {
          return (0, te.attachPartialResult)(this.connection, r);
        }
      };
      ve._NotebooksImpl = Zl;
      var _b = (0, fG.NotebookSyncFeature)(Zl);
      function Rb(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineConsoleFeatures = Rb;
      function bb(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineTelemetryFeatures = bb;
      function Sb(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineTracerFeatures = Sb;
      function Ab(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineClientFeatures = Ab;
      function Pb(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineWindowFeatures = Pb;
      function Cb(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineWorkspaceFeatures = Cb;
      function Nb(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineLanguagesFeatures = Nb;
      function Eb(t, e) {
        return function(r) {
          return e(t(r));
        };
      }
      ve.combineNotebooksFeatures = Eb;
      function gG(t, e) {
        function r(i, o, a) {
          return i && o ? a(i, o) : i || o;
        }
        return { __brand: "features", console: r(t.console, e.console, Rb), tracer: r(t.tracer, e.tracer, Sb), telemetry: r(t.telemetry, e.telemetry, bb), client: r(t.client, e.client, Ab), window: r(t.window, e.window, Pb), workspace: r(t.workspace, e.workspace, Cb), languages: r(t.languages, e.languages, Nb), notebooks: r(t.notebooks, e.notebooks, Eb) };
      }
      ve.combineFeatures = gG;
      function yG(t, e, r) {
        let n = r && r.console ? new (r.console(zl))() : new zl(), i = t(n);
        n.rawAttach(i);
        let o = r && r.tracer ? new (r.tracer(Xl))() : new Xl(), a = r && r.telemetry ? new (r.telemetry(Jl))() : new Jl(), s = r && r.client ? new (r.client(Yl))() : new Yl(), u = r && r.window ? new (r.window(yb))() : new yb(), c = r && r.workspace ? new (r.workspace(vb))() : new vb(), l = r && r.languages ? new (r.languages(Tb))() : new Tb(), d = r && r.notebooks ? new (r.notebooks(_b))() : new _b(), h = [n, o, a, s, u, c, l, d];
        function y(S) {
          return S instanceof Promise ? S : Gr.thenable(S) ? new Promise((b, O) => {
            S.then((L) => b(L), (L) => O(L));
          }) : Promise.resolve(S);
        }
        let m, R, C, N = { listen: () => i.listen(), sendRequest: (S, ...b) => i.sendRequest(Gr.string(S) ? S : S.method, ...b), onRequest: (S, b) => i.onRequest(S, b), sendNotification: (S, b) => {
          let O = Gr.string(S) ? S : S.method;
          return arguments.length === 1 ? i.sendNotification(O) : i.sendNotification(O, b);
        }, onNotification: (S, b) => i.onNotification(S, b), onProgress: i.onProgress, sendProgress: i.sendProgress, onInitialize: (S) => (R = S, { dispose: () => {
          R = void 0;
        } }), onInitialized: (S) => i.onNotification(G.InitializedNotification.type, S), onShutdown: (S) => (m = S, { dispose: () => {
          m = void 0;
        } }), onExit: (S) => (C = S, { dispose: () => {
          C = void 0;
        } }), get console() {
          return n;
        }, get telemetry() {
          return a;
        }, get tracer() {
          return o;
        }, get client() {
          return s;
        }, get window() {
          return u;
        }, get workspace() {
          return c;
        }, get languages() {
          return l;
        }, get notebooks() {
          return d;
        }, onDidChangeConfiguration: (S) => i.onNotification(G.DidChangeConfigurationNotification.type, S), onDidChangeWatchedFiles: (S) => i.onNotification(G.DidChangeWatchedFilesNotification.type, S), __textDocumentSync: void 0, onDidOpenTextDocument: (S) => i.onNotification(G.DidOpenTextDocumentNotification.type, S), onDidChangeTextDocument: (S) => i.onNotification(G.DidChangeTextDocumentNotification.type, S), onDidCloseTextDocument: (S) => i.onNotification(G.DidCloseTextDocumentNotification.type, S), onWillSaveTextDocument: (S) => i.onNotification(G.WillSaveTextDocumentNotification.type, S), onWillSaveTextDocumentWaitUntil: (S) => i.onRequest(G.WillSaveTextDocumentWaitUntilRequest.type, S), onDidSaveTextDocument: (S) => i.onNotification(G.DidSaveTextDocumentNotification.type, S), sendDiagnostics: (S) => i.sendNotification(G.PublishDiagnosticsNotification.type, S), onHover: (S) => i.onRequest(G.HoverRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), void 0)), onCompletion: (S) => i.onRequest(G.CompletionRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onCompletionResolve: (S) => i.onRequest(G.CompletionResolveRequest.type, S), onSignatureHelp: (S) => i.onRequest(G.SignatureHelpRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), void 0)), onDeclaration: (S) => i.onRequest(G.DeclarationRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onDefinition: (S) => i.onRequest(G.DefinitionRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onTypeDefinition: (S) => i.onRequest(G.TypeDefinitionRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onImplementation: (S) => i.onRequest(G.ImplementationRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onReferences: (S) => i.onRequest(G.ReferencesRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onDocumentHighlight: (S) => i.onRequest(G.DocumentHighlightRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onDocumentSymbol: (S) => i.onRequest(G.DocumentSymbolRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onWorkspaceSymbol: (S) => i.onRequest(G.WorkspaceSymbolRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onWorkspaceSymbolResolve: (S) => i.onRequest(G.WorkspaceSymbolResolveRequest.type, S), onCodeAction: (S) => i.onRequest(G.CodeActionRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onCodeActionResolve: (S) => i.onRequest(G.CodeActionResolveRequest.type, (b, O) => S(b, O)), onCodeLens: (S) => i.onRequest(G.CodeLensRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onCodeLensResolve: (S) => i.onRequest(G.CodeLensResolveRequest.type, (b, O) => S(b, O)), onDocumentFormatting: (S) => i.onRequest(G.DocumentFormattingRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), void 0)), onDocumentRangeFormatting: (S) => i.onRequest(G.DocumentRangeFormattingRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), void 0)), onDocumentOnTypeFormatting: (S) => i.onRequest(G.DocumentOnTypeFormattingRequest.type, (b, O) => S(b, O)), onRenameRequest: (S) => i.onRequest(G.RenameRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), void 0)), onPrepareRename: (S) => i.onRequest(G.PrepareRenameRequest.type, (b, O) => S(b, O)), onDocumentLinks: (S) => i.onRequest(G.DocumentLinkRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onDocumentLinkResolve: (S) => i.onRequest(G.DocumentLinkResolveRequest.type, (b, O) => S(b, O)), onDocumentColor: (S) => i.onRequest(G.DocumentColorRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onColorPresentation: (S) => i.onRequest(G.ColorPresentationRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onFoldingRanges: (S) => i.onRequest(G.FoldingRangeRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onSelectionRanges: (S) => i.onRequest(G.SelectionRangeRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), (0, te.attachPartialResult)(i, b))), onExecuteCommand: (S) => i.onRequest(G.ExecuteCommandRequest.type, (b, O) => S(b, O, (0, te.attachWorkDone)(i, b), void 0)), dispose: () => i.dispose() };
        for (let S of h)
          S.attach(N);
        return i.onRequest(G.InitializeRequest.type, (S) => {
          e.initialize(S), Gr.string(S.trace) && (o.trace = G.Trace.fromString(S.trace));
          for (let b of h)
            b.initialize(S.capabilities);
          if (R) {
            let b = R(S, new G.CancellationTokenSource().token, (0, te.attachWorkDone)(i, S), void 0);
            return y(b).then((O) => {
              if (O instanceof G.ResponseError)
                return O;
              let L = O;
              L || (L = { capabilities: {} });
              let W = L.capabilities;
              W || (W = {}, L.capabilities = W), W.textDocumentSync === void 0 || W.textDocumentSync === null ? W.textDocumentSync = Gr.number(N.__textDocumentSync) ? N.__textDocumentSync : G.TextDocumentSyncKind.None : !Gr.number(W.textDocumentSync) && !Gr.number(W.textDocumentSync.change) && (W.textDocumentSync.change = Gr.number(N.__textDocumentSync) ? N.__textDocumentSync : G.TextDocumentSyncKind.None);
              for (let Z of h)
                Z.fillServerCapabilities(W);
              return L;
            });
          } else {
            let b = { capabilities: { textDocumentSync: G.TextDocumentSyncKind.None } };
            for (let O of h)
              O.fillServerCapabilities(b.capabilities);
            return b;
          }
        }), i.onRequest(G.ShutdownRequest.type, () => {
          if (e.shutdownReceived = true, m)
            return m(new G.CancellationTokenSource().token);
        }), i.onNotification(G.ExitNotification.type, () => {
          try {
            C && C();
          } finally {
            e.shutdownReceived ? e.exit(0) : e.exit(1);
          }
        }), i.onNotification(G.SetTraceNotification.type, (S) => {
          o.trace = G.Trace.fromString(S.value);
        }), N;
      }
      ve.createConnection = yG;
    });
    var og = f((Kt) => {
      var vG = Kt && Kt.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), wb = Kt && Kt.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && vG(e, t, r);
      };
      Object.defineProperty(Kt, "__esModule", { value: true });
      Kt.ProposedFeatures = Kt.NotebookDocuments = Kt.TextDocuments = Kt.SemanticTokensBuilder = void 0;
      var TG = Gm();
      Object.defineProperty(Kt, "SemanticTokensBuilder", { enumerable: true, get: function() {
        return TG.SemanticTokensBuilder;
      } });
      wb(bt(), Kt);
      var _G = Wm();
      Object.defineProperty(Kt, "TextDocuments", { enumerable: true, get: function() {
        return _G.TextDocuments;
      } });
      var RG = Km();
      Object.defineProperty(Kt, "NotebookDocuments", { enumerable: true, get: function() {
        return RG.NotebookDocuments;
      } });
      wb(kb(), Kt);
      (function(t) {
        t.all = { __brand: "features" };
      })(Kt.ProposedFeatures || (Kt.ProposedFeatures = {}));
    });
    var Db = f((gfe, Ob) => {
      Ob.exports = bt();
    });
    var xe = f((Wn) => {
      var SG = Wn && Wn.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), xb = Wn && Wn.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && SG(e, t, r);
      };
      Object.defineProperty(Wn, "__esModule", { value: true });
      Wn.createConnection = void 0;
      var ed = og();
      xb(Db(), Wn);
      xb(og(), Wn);
      var Ib = false, AG = { initialize: (t) => {
      }, get shutdownReceived() {
        return Ib;
      }, set shutdownReceived(t) {
        Ib = t;
      }, exit: (t) => {
      } };
      function PG(t, e, r, n) {
        let i, o, a, s;
        t !== void 0 && t.__brand === "features" && (i = t, t = e, e = r, r = n), ed.ConnectionStrategy.is(t) || ed.ConnectionOptions.is(t) ? s = t : (o = t, a = e, s = r);
        let u = (c) => (0, ed.createProtocolConnection)(o, a, c, s);
        return (0, ed.createConnection)(u, AG, i);
      }
      Wn.createConnection = PG;
    });
    var ag = f((rd, td) => {
      var CG = rd && rd.__spreadArray || function(t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), o[n] = e[n]);
        return t.concat(o || Array.prototype.slice.call(e));
      };
      (function(t) {
        if (typeof td == "object" && typeof td.exports == "object") {
          var e = t(pl, rd);
          e !== void 0 && (td.exports = e);
        } else
          typeof define == "function" && define.amd && define(["require", "exports"], t);
      })(function(t, e) {
        Object.defineProperty(e, "__esModule", { value: true }), e.TextDocument = void 0;
        var r = function() {
          function u(c, l, d, h) {
            this._uri = c, this._languageId = l, this._version = d, this._content = h, this._lineOffsets = void 0;
          }
          return Object.defineProperty(u.prototype, "uri", { get: function() {
            return this._uri;
          }, enumerable: false, configurable: true }), Object.defineProperty(u.prototype, "languageId", { get: function() {
            return this._languageId;
          }, enumerable: false, configurable: true }), Object.defineProperty(u.prototype, "version", { get: function() {
            return this._version;
          }, enumerable: false, configurable: true }), u.prototype.getText = function(c) {
            if (c) {
              var l = this.offsetAt(c.start), d = this.offsetAt(c.end);
              return this._content.substring(l, d);
            }
            return this._content;
          }, u.prototype.update = function(c, l) {
            for (var d = 0, h = c; d < h.length; d++) {
              var y = h[d];
              if (u.isIncremental(y)) {
                var m = a(y.range), R = this.offsetAt(m.start), C = this.offsetAt(m.end);
                this._content = this._content.substring(0, R) + y.text + this._content.substring(C, this._content.length);
                var N = Math.max(m.start.line, 0), S = Math.max(m.end.line, 0), b = this._lineOffsets, O = o(y.text, false, R);
                if (S - N === O.length)
                  for (var L = 0, W = O.length; L < W; L++)
                    b[L + N + 1] = O[L];
                else
                  O.length < 1e4 ? b.splice.apply(b, CG([N + 1, S - N], O, false)) : this._lineOffsets = b = b.slice(0, N + 1).concat(O, b.slice(S + 1));
                var Z = y.text.length - (C - R);
                if (Z !== 0)
                  for (var L = N + 1 + O.length, W = b.length; L < W; L++)
                    b[L] = b[L] + Z;
              } else if (u.isFull(y))
                this._content = y.text, this._lineOffsets = void 0;
              else
                throw new Error("Unknown change event received");
            }
            this._version = l;
          }, u.prototype.getLineOffsets = function() {
            return this._lineOffsets === void 0 && (this._lineOffsets = o(this._content, true)), this._lineOffsets;
          }, u.prototype.positionAt = function(c) {
            c = Math.max(Math.min(c, this._content.length), 0);
            var l = this.getLineOffsets(), d = 0, h = l.length;
            if (h === 0)
              return { line: 0, character: c };
            for (; d < h; ) {
              var y = Math.floor((d + h) / 2);
              l[y] > c ? h = y : d = y + 1;
            }
            var m = d - 1;
            return { line: m, character: c - l[m] };
          }, u.prototype.offsetAt = function(c) {
            var l = this.getLineOffsets();
            if (c.line >= l.length)
              return this._content.length;
            if (c.line < 0)
              return 0;
            var d = l[c.line], h = c.line + 1 < l.length ? l[c.line + 1] : this._content.length;
            return Math.max(Math.min(d + c.character, h), d);
          }, Object.defineProperty(u.prototype, "lineCount", { get: function() {
            return this.getLineOffsets().length;
          }, enumerable: false, configurable: true }), u.isIncremental = function(c) {
            var l = c;
            return l != null && typeof l.text == "string" && l.range !== void 0 && (l.rangeLength === void 0 || typeof l.rangeLength == "number");
          }, u.isFull = function(c) {
            var l = c;
            return l != null && typeof l.text == "string" && l.range === void 0 && l.rangeLength === void 0;
          }, u;
        }();
        (function(u) {
          function c(h, y, m, R) {
            return new r(h, y, m, R);
          }
          u.create = c;
          function l(h, y, m) {
            if (h instanceof r)
              return h.update(y, m), h;
            throw new Error("TextDocument.update: document must be created by TextDocument.create");
          }
          u.update = l;
          function d(h, y) {
            for (var m = h.getText(), R = i(y.map(s), function(W, Z) {
              var Ee = W.range.start.line - Z.range.start.line;
              return Ee === 0 ? W.range.start.character - Z.range.start.character : Ee;
            }), C = 0, N = [], S = 0, b = R; S < b.length; S++) {
              var O = b[S], L = h.offsetAt(O.range.start);
              if (L < C)
                throw new Error("Overlapping edit");
              L > C && N.push(m.substring(C, L)), O.newText.length && N.push(O.newText), C = h.offsetAt(O.range.end);
            }
            return N.push(m.substr(C)), N.join("");
          }
          u.applyEdits = d;
        })(e.TextDocument || (e.TextDocument = {}));
        function i(u, c) {
          if (u.length <= 1)
            return u;
          var l = u.length / 2 | 0, d = u.slice(0, l), h = u.slice(l);
          i(d, c), i(h, c);
          for (var y = 0, m = 0, R = 0; y < d.length && m < h.length; ) {
            var C = c(d[y], h[m]);
            C <= 0 ? u[R++] = d[y++] : u[R++] = h[m++];
          }
          for (; y < d.length; )
            u[R++] = d[y++];
          for (; m < h.length; )
            u[R++] = h[m++];
          return u;
        }
        function o(u, c, l) {
          l === void 0 && (l = 0);
          for (var d = c ? [l] : [], h = 0; h < u.length; h++) {
            var y = u.charCodeAt(h);
            (y === 13 || y === 10) && (y === 13 && h + 1 < u.length && u.charCodeAt(h + 1) === 10 && h++, d.push(l + h + 1));
          }
          return d;
        }
        function a(u) {
          var c = u.start, l = u.end;
          return c.line > l.line || c.line === l.line && c.character > l.character ? { start: l, end: c } : u;
        }
        function s(u) {
          var c = a(u.range);
          return c !== u.range ? { newText: u.newText, range: c } : u;
        }
      });
    });
    var Zt = f((Mt) => {
      Object.defineProperty(Mt, "__esModule", { value: true });
      Mt.isRootCstNode = Mt.isLeafCstNode = Mt.isCompositeCstNode = Mt.AbstractAstReflection = Mt.isLinkingError = Mt.isAstNodeDescription = Mt.isReference = Mt.isAstNode = void 0;
      function ug(t) {
        return typeof t == "object" && t !== null && typeof t.$type == "string";
      }
      Mt.isAstNode = ug;
      function qb(t) {
        return typeof t == "object" && t !== null && typeof t.$refText == "string";
      }
      Mt.isReference = qb;
      function NG(t) {
        return typeof t == "object" && t !== null && typeof t.name == "string" && typeof t.type == "string" && typeof t.path == "string";
      }
      Mt.isAstNodeDescription = NG;
      function EG(t) {
        return typeof t == "object" && t !== null && ug(t.container) && qb(t.reference) && typeof t.message == "string";
      }
      Mt.isLinkingError = EG;
      var sg = class {
        constructor() {
          this.subtypes = {}, this.allSubtypes = {};
        }
        isInstance(e, r) {
          return ug(e) && this.isSubtype(e.$type, r);
        }
        isSubtype(e, r) {
          if (e === r)
            return true;
          let n = this.subtypes[e];
          n || (n = this.subtypes[e] = {});
          let i = n[r];
          if (i !== void 0)
            return i;
          {
            let o = this.computeIsSubtype(e, r);
            return n[r] = o, o;
          }
        }
        getAllSubTypes(e) {
          let r = this.allSubtypes[e];
          if (r)
            return r;
          {
            let n = this.getAllTypes(), i = [];
            for (let o of n)
              this.isSubtype(o, e) && i.push(o);
            return this.allSubtypes[e] = i, i;
          }
        }
      };
      Mt.AbstractAstReflection = sg;
      function Lb(t) {
        return typeof t == "object" && t !== null && "children" in t;
      }
      Mt.isCompositeCstNode = Lb;
      function kG(t) {
        return typeof t == "object" && t !== null && "tokenType" in t;
      }
      Mt.isLeafCstNode = kG;
      function wG(t) {
        return Lb(t) && "fullText" in t;
      }
      Mt.isRootCstNode = wG;
    });
    var $t = f((Ve) => {
      Object.defineProperty(Ve, "__esModule", { value: true });
      Ve.Reduction = Ve.TreeStreamImpl = Ve.stream = Ve.DONE_RESULT = Ve.EMPTY_STREAM = Ve.StreamImpl = void 0;
      var zt = class {
        constructor(e, r) {
          this.startFn = e, this.nextFn = r;
        }
        iterator() {
          let e = { state: this.startFn(), next: () => this.nextFn(e.state), [Symbol.iterator]: () => e };
          return e;
        }
        [Symbol.iterator]() {
          return this.iterator();
        }
        isEmpty() {
          let e = this.iterator();
          return Boolean(e.next().done);
        }
        count() {
          let e = this.iterator(), r = 0, n = e.next();
          for (; !n.done; )
            r++, n = e.next();
          return r;
        }
        toArray() {
          let e = [], r = this.iterator(), n;
          do
            n = r.next(), n.value !== void 0 && e.push(n.value);
          while (!n.done);
          return e;
        }
        toSet() {
          return new Set(this);
        }
        toMap(e, r) {
          let n = this.map((i) => [e ? e(i) : i, r ? r(i) : i]);
          return new Map(n);
        }
        toString() {
          return this.join();
        }
        concat(e) {
          let r = e[Symbol.iterator]();
          return new zt(() => ({ first: this.startFn(), firstDone: false }), (n) => {
            let i;
            if (!n.firstDone) {
              do
                if (i = this.nextFn(n.first), !i.done)
                  return i;
              while (!i.done);
              n.firstDone = true;
            }
            do
              if (i = r.next(), !i.done)
                return i;
            while (!i.done);
            return Ve.DONE_RESULT;
          });
        }
        join(e = ",") {
          let r = this.iterator(), n = "", i, o = false;
          do
            i = r.next(), i.done || (o && (n += e), n += OG(i.value)), o = true;
          while (!i.done);
          return n;
        }
        indexOf(e, r = 0) {
          let n = this.iterator(), i = 0, o = n.next();
          for (; !o.done; ) {
            if (i >= r && o.value === e)
              return i;
            o = n.next(), i++;
          }
          return -1;
        }
        every(e) {
          let r = this.iterator(), n = r.next();
          for (; !n.done; ) {
            if (!e(n.value))
              return false;
            n = r.next();
          }
          return true;
        }
        some(e) {
          let r = this.iterator(), n = r.next();
          for (; !n.done; ) {
            if (e(n.value))
              return true;
            n = r.next();
          }
          return false;
        }
        forEach(e) {
          let r = this.iterator(), n = 0, i = r.next();
          for (; !i.done; )
            e(i.value, n), i = r.next(), n++;
        }
        map(e) {
          return new zt(this.startFn, (r) => {
            let { done: n, value: i } = this.nextFn(r);
            return n ? Ve.DONE_RESULT : { done: false, value: e(i) };
          });
        }
        filter(e) {
          return new zt(this.startFn, (r) => {
            let n;
            do
              if (n = this.nextFn(r), !n.done && e(n.value))
                return n;
            while (!n.done);
            return Ve.DONE_RESULT;
          });
        }
        nonNullable() {
          return this.filter((e) => e != null);
        }
        reduce(e, r) {
          let n = this.iterator(), i = r, o = n.next();
          for (; !o.done; )
            i === void 0 ? i = o.value : i = e(i, o.value), o = n.next();
          return i;
        }
        reduceRight(e, r) {
          return this.recursiveReduce(this.iterator(), e, r);
        }
        recursiveReduce(e, r, n) {
          let i = e.next();
          if (i.done)
            return n;
          let o = this.recursiveReduce(e, r, n);
          return o === void 0 ? i.value : r(o, i.value);
        }
        find(e) {
          let r = this.iterator(), n = r.next();
          for (; !n.done; ) {
            if (e(n.value))
              return n.value;
            n = r.next();
          }
        }
        findIndex(e) {
          let r = this.iterator(), n = 0, i = r.next();
          for (; !i.done; ) {
            if (e(i.value))
              return n;
            i = r.next(), n++;
          }
          return -1;
        }
        includes(e) {
          let r = this.iterator(), n = r.next();
          for (; !n.done; ) {
            if (n.value === e)
              return true;
            n = r.next();
          }
          return false;
        }
        flatMap(e) {
          return new zt(() => ({ this: this.startFn() }), (r) => {
            do {
              if (r.iterator) {
                let o = r.iterator.next();
                if (o.done)
                  r.iterator = void 0;
                else
                  return o;
              }
              let { done: n, value: i } = this.nextFn(r.this);
              if (!n) {
                let o = e(i);
                if (nd(o))
                  r.iterator = o[Symbol.iterator]();
                else
                  return { done: false, value: o };
              }
            } while (r.iterator);
            return Ve.DONE_RESULT;
          });
        }
        flat(e) {
          if (e === void 0 && (e = 1), e <= 0)
            return this;
          let r = e > 1 ? this.flat(e - 1) : this;
          return new zt(() => ({ this: r.startFn() }), (n) => {
            do {
              if (n.iterator) {
                let a = n.iterator.next();
                if (a.done)
                  n.iterator = void 0;
                else
                  return a;
              }
              let { done: i, value: o } = r.nextFn(n.this);
              if (!i)
                if (nd(o))
                  n.iterator = o[Symbol.iterator]();
                else
                  return { done: false, value: o };
            } while (n.iterator);
            return Ve.DONE_RESULT;
          });
        }
        head() {
          let r = this.iterator().next();
          if (!r.done)
            return r.value;
        }
        tail(e = 1) {
          return new zt(() => {
            let r = this.startFn();
            for (let n = 0; n < e; n++)
              if (this.nextFn(r).done)
                return r;
            return r;
          }, this.nextFn);
        }
        limit(e) {
          return new zt(() => ({ size: 0, state: this.startFn() }), (r) => (r.size++, r.size > e ? Ve.DONE_RESULT : this.nextFn(r.state)));
        }
        distinct(e) {
          let r = /* @__PURE__ */ new Set();
          return this.filter((n) => {
            let i = e ? e(n) : n;
            return r.has(i) ? false : (r.add(i), true);
          });
        }
        exclude(e, r) {
          let n = /* @__PURE__ */ new Set();
          for (let i of e) {
            let o = r ? r(i) : i;
            n.add(o);
          }
          return this.filter((i) => {
            let o = r ? r(i) : i;
            return !n.has(o);
          });
        }
      };
      Ve.StreamImpl = zt;
      function OG(t) {
        return typeof t == "string" ? t : typeof t > "u" ? "undefined" : typeof t.toString == "function" ? t.toString() : Object.prototype.toString.call(t);
      }
      function nd(t) {
        return !!t && typeof t[Symbol.iterator] == "function";
      }
      Ve.EMPTY_STREAM = new zt(() => {
      }, () => Ve.DONE_RESULT);
      Ve.DONE_RESULT = Object.freeze({ done: true, value: void 0 });
      function DG(...t) {
        if (t.length === 1) {
          let e = t[0];
          if (e instanceof zt)
            return e;
          if (nd(e))
            return new zt(() => e[Symbol.iterator](), (r) => r.next());
          if (typeof e.length == "number")
            return new zt(() => ({ index: 0 }), (r) => r.index < e.length ? { done: false, value: e[r.index++] } : Ve.DONE_RESULT);
        }
        return t.length > 1 ? new zt(() => ({ collIndex: 0, arrIndex: 0 }), (e) => {
          do {
            if (e.iterator) {
              let r = e.iterator.next();
              if (!r.done)
                return r;
              e.iterator = void 0;
            }
            if (e.array) {
              if (e.arrIndex < e.array.length)
                return { done: false, value: e.array[e.arrIndex++] };
              e.array = void 0, e.arrIndex = 0;
            }
            if (e.collIndex < t.length) {
              let r = t[e.collIndex++];
              nd(r) ? e.iterator = r[Symbol.iterator]() : r && typeof r.length == "number" && (e.array = r);
            }
          } while (e.iterator || e.array || e.collIndex < t.length);
          return Ve.DONE_RESULT;
        }) : Ve.EMPTY_STREAM;
      }
      Ve.stream = DG;
      var cg = class extends zt {
        constructor(e, r, n) {
          super(() => ({ iterators: (n == null ? void 0 : n.includeRoot) ? [[e][Symbol.iterator]()] : [r(e)[Symbol.iterator]()], pruned: false }), (i) => {
            for (i.pruned && (i.iterators.pop(), i.pruned = false); i.iterators.length > 0; ) {
              let a = i.iterators[i.iterators.length - 1].next();
              if (a.done)
                i.iterators.pop();
              else
                return i.iterators.push(r(a.value)[Symbol.iterator]()), a;
            }
            return Ve.DONE_RESULT;
          });
        }
        iterator() {
          let e = { state: this.startFn(), next: () => this.nextFn(e.state), prune: () => {
            e.state.pruned = true;
          }, [Symbol.iterator]: () => e };
          return e;
        }
      };
      Ve.TreeStreamImpl = cg;
      (function(t) {
        function e(o) {
          return o.reduce((a, s) => a + s, 0);
        }
        t.sum = e;
        function r(o) {
          return o.reduce((a, s) => a * s, 0);
        }
        t.product = r;
        function n(o) {
          return o.reduce((a, s) => Math.min(a, s));
        }
        t.min = n;
        function i(o) {
          return o.reduce((a, s) => Math.max(a, s));
        }
        t.max = i;
      })(Ve.Reduction || (Ve.Reduction = {}));
    });
    var Le = f((ue) => {
      Object.defineProperty(ue, "__esModule", { value: true });
      ue.getInteriorNodes = ue.getStartlineNode = ue.getNextNode = ue.getPreviousNode = ue.findLeafNodeAtOffset = ue.isCommentNode = ue.findCommentNode = ue.findDeclarationNodeAtOffset = ue.DefaultNameRegexp = ue.inRange = ue.compareRange = ue.RangeComparison = ue.toDocumentSegment = ue.tokenToRange = ue.isCstChildNode = ue.flattenCst = ue.streamCst = void 0;
      var za = Zt(), xG = $t();
      function $b(t) {
        return new xG.TreeStreamImpl(t, (e) => (0, za.isCompositeCstNode)(e) ? e.children : [], { includeRoot: true });
      }
      ue.streamCst = $b;
      function qG(t) {
        return $b(t).filter(za.isLeafCstNode);
      }
      ue.flattenCst = qG;
      function LG(t, e) {
        for (; t.parent; )
          if (t = t.parent, t === e)
            return true;
        return false;
      }
      ue.isCstChildNode = LG;
      function MG(t) {
        return { start: { character: t.startColumn - 1, line: t.startLine - 1 }, end: { character: t.endColumn, line: t.endLine - 1 } };
      }
      ue.tokenToRange = MG;
      function $G(t) {
        if (!t)
          return;
        let { offset: e, end: r, range: n } = t;
        return { range: n, offset: e, end: r, length: r - e };
      }
      ue.toDocumentSegment = $G;
      var zo;
      (function(t) {
        t[t.Before = 0] = "Before", t[t.After = 1] = "After", t[t.OverlapFront = 2] = "OverlapFront", t[t.OverlapBack = 3] = "OverlapBack", t[t.Inside = 4] = "Inside";
      })(zo = ue.RangeComparison || (ue.RangeComparison = {}));
      function Fb(t, e) {
        if (t.end.line < e.start.line || t.end.line === e.start.line && t.end.character < t.start.character)
          return zo.Before;
        if (t.start.line > e.end.line || t.start.line === e.end.line && t.start.character > e.end.character)
          return zo.After;
        let r = t.start.line > e.start.line || t.start.line === e.start.line && t.start.character >= e.start.character, n = t.end.line < e.end.line || t.end.line === e.end.line && t.end.character <= e.end.character;
        return r && n ? zo.Inside : r ? zo.OverlapBack : zo.OverlapFront;
      }
      ue.compareRange = Fb;
      function FG(t, e) {
        return Fb(t, e) > zo.After;
      }
      ue.inRange = FG;
      ue.DefaultNameRegexp = /^[\w\p{L}]$/u;
      function jG(t, e, r = ue.DefaultNameRegexp) {
        if (t) {
          if (e > 0) {
            let n = e - t.offset, i = t.text.charAt(n);
            r.test(i) || e--;
          }
          return id(t, e);
        }
      }
      ue.findDeclarationNodeAtOffset = jG;
      function UG(t, e) {
        if (t) {
          let r = jb(t, true);
          if (r && lg(r, e))
            return r;
          if ((0, za.isRootCstNode)(t)) {
            let n = t.children.findIndex((i) => !i.hidden);
            for (let i = n - 1; i >= 0; i--) {
              let o = t.children[i];
              if (lg(o, e))
                return o;
            }
          }
        }
      }
      ue.findCommentNode = UG;
      function lg(t, e) {
        return (0, za.isLeafCstNode)(t) && e.includes(t.tokenType.name);
      }
      ue.isCommentNode = lg;
      function id(t, e) {
        if ((0, za.isLeafCstNode)(t))
          return t;
        if ((0, za.isCompositeCstNode)(t)) {
          let r = 0, n = t.children.length - 1;
          for (; r < n; ) {
            let i = Math.floor((r + n) / 2), o = t.children[i];
            if (o.offset > e)
              n = i - 1;
            else if (o.end <= e)
              r = i + 1;
            else
              return id(o, e);
          }
          if (r === n)
            return id(t.children[r], e);
        }
      }
      ue.findLeafNodeAtOffset = id;
      function jb(t, e = true) {
        for (; t.parent; ) {
          let r = t.parent, n = r.children.indexOf(t);
          for (; n > 0; ) {
            n--;
            let i = r.children[n];
            if (e || !i.hidden)
              return i;
          }
          t = r;
        }
      }
      ue.getPreviousNode = jb;
      function GG(t, e = true) {
        for (; t.parent; ) {
          let r = t.parent, n = r.children.indexOf(t), i = r.children.length - 1;
          for (; n < i; ) {
            n++;
            let o = r.children[n];
            if (e || !o.hidden)
              return o;
          }
          t = r;
        }
      }
      ue.getNextNode = GG;
      function HG(t) {
        if (t.range.start.character === 0)
          return t;
        let e = t.range.start.line, r = t, n;
        for (; t.parent; ) {
          let i = t.parent, o = n ?? i.children.indexOf(t);
          if (o === 0 ? (t = i, n = void 0) : (n = o - 1, t = i.children[n]), t.range.start.line !== e)
            break;
          r = t;
        }
        return r;
      }
      ue.getStartlineNode = HG;
      function WG(t, e) {
        let r = BG(t, e);
        return r ? r.parent.children.slice(r.a + 1, r.b) : [];
      }
      ue.getInteriorNodes = WG;
      function BG(t, e) {
        let r = Mb(t), n = Mb(e), i;
        for (let o = 0; o < r.length && o < n.length; o++) {
          let a = r[o], s = n[o];
          if (a.parent === s.parent)
            i = { parent: a.parent, a: a.index, b: s.index };
          else
            break;
        }
        return i;
      }
      function Mb(t) {
        let e = [];
        for (; t.parent; ) {
          let r = t.parent, n = r.children.indexOf(t);
          e.push({ parent: r, index: n }), t = r;
        }
        return e.reverse();
      }
    });
    var vn = f((Ku, dg) => {
      (function(t, e) {
        if (typeof Ku == "object" && typeof dg == "object")
          dg.exports = e();
        else if (typeof define == "function" && define.amd)
          define([], e);
        else {
          var r = e();
          for (var n in r)
            (typeof Ku == "object" ? Ku : t)[n] = r[n];
        }
      })(Ku, () => (() => {
        var t = { 470: (i) => {
          function o(u) {
            if (typeof u != "string")
              throw new TypeError("Path must be a string. Received " + JSON.stringify(u));
          }
          function a(u, c) {
            for (var l, d = "", h = 0, y = -1, m = 0, R = 0; R <= u.length; ++R) {
              if (R < u.length)
                l = u.charCodeAt(R);
              else {
                if (l === 47)
                  break;
                l = 47;
              }
              if (l === 47) {
                if (!(y === R - 1 || m === 1))
                  if (y !== R - 1 && m === 2) {
                    if (d.length < 2 || h !== 2 || d.charCodeAt(d.length - 1) !== 46 || d.charCodeAt(d.length - 2) !== 46) {
                      if (d.length > 2) {
                        var C = d.lastIndexOf("/");
                        if (C !== d.length - 1) {
                          C === -1 ? (d = "", h = 0) : h = (d = d.slice(0, C)).length - 1 - d.lastIndexOf("/"), y = R, m = 0;
                          continue;
                        }
                      } else if (d.length === 2 || d.length === 1) {
                        d = "", h = 0, y = R, m = 0;
                        continue;
                      }
                    }
                    c && (d.length > 0 ? d += "/.." : d = "..", h = 2);
                  } else
                    d.length > 0 ? d += "/" + u.slice(y + 1, R) : d = u.slice(y + 1, R), h = R - y - 1;
                y = R, m = 0;
              } else
                l === 46 && m !== -1 ? ++m : m = -1;
            }
            return d;
          }
          var s = { resolve: function() {
            for (var u, c = "", l = false, d = arguments.length - 1; d >= -1 && !l; d--) {
              var h;
              d >= 0 ? h = arguments[d] : (u === void 0 && (u = process.cwd()), h = u), o(h), h.length !== 0 && (c = h + "/" + c, l = h.charCodeAt(0) === 47);
            }
            return c = a(c, !l), l ? c.length > 0 ? "/" + c : "/" : c.length > 0 ? c : ".";
          }, normalize: function(u) {
            if (o(u), u.length === 0)
              return ".";
            var c = u.charCodeAt(0) === 47, l = u.charCodeAt(u.length - 1) === 47;
            return (u = a(u, !c)).length !== 0 || c || (u = "."), u.length > 0 && l && (u += "/"), c ? "/" + u : u;
          }, isAbsolute: function(u) {
            return o(u), u.length > 0 && u.charCodeAt(0) === 47;
          }, join: function() {
            if (arguments.length === 0)
              return ".";
            for (var u, c = 0; c < arguments.length; ++c) {
              var l = arguments[c];
              o(l), l.length > 0 && (u === void 0 ? u = l : u += "/" + l);
            }
            return u === void 0 ? "." : s.normalize(u);
          }, relative: function(u, c) {
            if (o(u), o(c), u === c || (u = s.resolve(u)) === (c = s.resolve(c)))
              return "";
            for (var l = 1; l < u.length && u.charCodeAt(l) === 47; ++l)
              ;
            for (var d = u.length, h = d - l, y = 1; y < c.length && c.charCodeAt(y) === 47; ++y)
              ;
            for (var m = c.length - y, R = h < m ? h : m, C = -1, N = 0; N <= R; ++N) {
              if (N === R) {
                if (m > R) {
                  if (c.charCodeAt(y + N) === 47)
                    return c.slice(y + N + 1);
                  if (N === 0)
                    return c.slice(y + N);
                } else
                  h > R && (u.charCodeAt(l + N) === 47 ? C = N : N === 0 && (C = 0));
                break;
              }
              var S = u.charCodeAt(l + N);
              if (S !== c.charCodeAt(y + N))
                break;
              S === 47 && (C = N);
            }
            var b = "";
            for (N = l + C + 1; N <= d; ++N)
              N !== d && u.charCodeAt(N) !== 47 || (b.length === 0 ? b += ".." : b += "/..");
            return b.length > 0 ? b + c.slice(y + C) : (y += C, c.charCodeAt(y) === 47 && ++y, c.slice(y));
          }, _makeLong: function(u) {
            return u;
          }, dirname: function(u) {
            if (o(u), u.length === 0)
              return ".";
            for (var c = u.charCodeAt(0), l = c === 47, d = -1, h = true, y = u.length - 1; y >= 1; --y)
              if ((c = u.charCodeAt(y)) === 47) {
                if (!h) {
                  d = y;
                  break;
                }
              } else
                h = false;
            return d === -1 ? l ? "/" : "." : l && d === 1 ? "//" : u.slice(0, d);
          }, basename: function(u, c) {
            if (c !== void 0 && typeof c != "string")
              throw new TypeError('"ext" argument must be a string');
            o(u);
            var l, d = 0, h = -1, y = true;
            if (c !== void 0 && c.length > 0 && c.length <= u.length) {
              if (c.length === u.length && c === u)
                return "";
              var m = c.length - 1, R = -1;
              for (l = u.length - 1; l >= 0; --l) {
                var C = u.charCodeAt(l);
                if (C === 47) {
                  if (!y) {
                    d = l + 1;
                    break;
                  }
                } else
                  R === -1 && (y = false, R = l + 1), m >= 0 && (C === c.charCodeAt(m) ? --m == -1 && (h = l) : (m = -1, h = R));
              }
              return d === h ? h = R : h === -1 && (h = u.length), u.slice(d, h);
            }
            for (l = u.length - 1; l >= 0; --l)
              if (u.charCodeAt(l) === 47) {
                if (!y) {
                  d = l + 1;
                  break;
                }
              } else
                h === -1 && (y = false, h = l + 1);
            return h === -1 ? "" : u.slice(d, h);
          }, extname: function(u) {
            o(u);
            for (var c = -1, l = 0, d = -1, h = true, y = 0, m = u.length - 1; m >= 0; --m) {
              var R = u.charCodeAt(m);
              if (R !== 47)
                d === -1 && (h = false, d = m + 1), R === 46 ? c === -1 ? c = m : y !== 1 && (y = 1) : c !== -1 && (y = -1);
              else if (!h) {
                l = m + 1;
                break;
              }
            }
            return c === -1 || d === -1 || y === 0 || y === 1 && c === d - 1 && c === l + 1 ? "" : u.slice(c, d);
          }, format: function(u) {
            if (u === null || typeof u != "object")
              throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof u);
            return function(c, l) {
              var d = l.dir || l.root, h = l.base || (l.name || "") + (l.ext || "");
              return d ? d === l.root ? d + h : d + "/" + h : h;
            }(0, u);
          }, parse: function(u) {
            o(u);
            var c = { root: "", dir: "", base: "", ext: "", name: "" };
            if (u.length === 0)
              return c;
            var l, d = u.charCodeAt(0), h = d === 47;
            h ? (c.root = "/", l = 1) : l = 0;
            for (var y = -1, m = 0, R = -1, C = true, N = u.length - 1, S = 0; N >= l; --N)
              if ((d = u.charCodeAt(N)) !== 47)
                R === -1 && (C = false, R = N + 1), d === 46 ? y === -1 ? y = N : S !== 1 && (S = 1) : y !== -1 && (S = -1);
              else if (!C) {
                m = N + 1;
                break;
              }
            return y === -1 || R === -1 || S === 0 || S === 1 && y === R - 1 && y === m + 1 ? R !== -1 && (c.base = c.name = m === 0 && h ? u.slice(1, R) : u.slice(m, R)) : (m === 0 && h ? (c.name = u.slice(1, y), c.base = u.slice(1, R)) : (c.name = u.slice(m, y), c.base = u.slice(m, R)), c.ext = u.slice(y, R)), m > 0 ? c.dir = u.slice(0, m - 1) : h && (c.dir = "/"), c;
          }, sep: "/", delimiter: ":", win32: null, posix: null };
          s.posix = s, i.exports = s;
        }, 674: (i, o) => {
          if (Object.defineProperty(o, "__esModule", { value: true }), o.isWindows = void 0, typeof process == "object")
            o.isWindows = process.platform === "win32";
          else if (typeof navigator == "object") {
            var a = navigator.userAgent;
            o.isWindows = a.indexOf("Windows") >= 0;
          }
        }, 796: function(i, o, a) {
          var s, u, c = this && this.__extends || (s = function(M, q) {
            return s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(F, B) {
              F.__proto__ = B;
            } || function(F, B) {
              for (var ie in B)
                Object.prototype.hasOwnProperty.call(B, ie) && (F[ie] = B[ie]);
            }, s(M, q);
          }, function(M, q) {
            if (typeof q != "function" && q !== null)
              throw new TypeError("Class extends value " + String(q) + " is not a constructor or null");
            function F() {
              this.constructor = M;
            }
            s(M, q), M.prototype = q === null ? Object.create(q) : (F.prototype = q.prototype, new F());
          });
          Object.defineProperty(o, "__esModule", { value: true }), o.uriToFsPath = o.URI = void 0;
          var l = a(674), d = /^\w[\w\d+.-]*$/, h = /^\//, y = /^\/\//;
          function m(M, q) {
            if (!M.scheme && q)
              throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(M.authority, '", path: "').concat(M.path, '", query: "').concat(M.query, '", fragment: "').concat(M.fragment, '"}'));
            if (M.scheme && !d.test(M.scheme))
              throw new Error("[UriError]: Scheme contains illegal characters.");
            if (M.path) {
              if (M.authority) {
                if (!h.test(M.path))
                  throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
              } else if (y.test(M.path))
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
          }
          var R = "", C = "/", N = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, S = function() {
            function M(q, F, B, ie, oe, J) {
              J === void 0 && (J = false), typeof q == "object" ? (this.scheme = q.scheme || R, this.authority = q.authority || R, this.path = q.path || R, this.query = q.query || R, this.fragment = q.fragment || R) : (this.scheme = function(lt, tt) {
                return lt || tt ? lt : "file";
              }(q, J), this.authority = F || R, this.path = function(lt, tt) {
                switch (lt) {
                  case "https":
                  case "http":
                  case "file":
                    tt ? tt[0] !== C && (tt = C + tt) : tt = C;
                }
                return tt;
              }(this.scheme, B || R), this.query = ie || R, this.fragment = oe || R, m(this, J));
            }
            return M.isUri = function(q) {
              return q instanceof M || !!q && typeof q.authority == "string" && typeof q.fragment == "string" && typeof q.path == "string" && typeof q.query == "string" && typeof q.scheme == "string" && typeof q.fsPath == "string" && typeof q.with == "function" && typeof q.toString == "function";
            }, Object.defineProperty(M.prototype, "fsPath", { get: function() {
              return Ee(this, false);
            }, enumerable: false, configurable: true }), M.prototype.with = function(q) {
              if (!q)
                return this;
              var F = q.scheme, B = q.authority, ie = q.path, oe = q.query, J = q.fragment;
              return F === void 0 ? F = this.scheme : F === null && (F = R), B === void 0 ? B = this.authority : B === null && (B = R), ie === void 0 ? ie = this.path : ie === null && (ie = R), oe === void 0 ? oe = this.query : oe === null && (oe = R), J === void 0 ? J = this.fragment : J === null && (J = R), F === this.scheme && B === this.authority && ie === this.path && oe === this.query && J === this.fragment ? this : new O(F, B, ie, oe, J);
            }, M.parse = function(q, F) {
              F === void 0 && (F = false);
              var B = N.exec(q);
              return B ? new O(B[2] || R, le(B[4] || R), le(B[5] || R), le(B[7] || R), le(B[9] || R), F) : new O(R, R, R, R, R);
            }, M.file = function(q) {
              var F = R;
              if (l.isWindows && (q = q.replace(/\\/g, C)), q[0] === C && q[1] === C) {
                var B = q.indexOf(C, 2);
                B === -1 ? (F = q.substring(2), q = C) : (F = q.substring(2, B), q = q.substring(B) || C);
              }
              return new O("file", F, q, R, R);
            }, M.from = function(q) {
              var F = new O(q.scheme, q.authority, q.path, q.query, q.fragment);
              return m(F, true), F;
            }, M.prototype.toString = function(q) {
              return q === void 0 && (q = false), ke(this, q);
            }, M.prototype.toJSON = function() {
              return this;
            }, M.revive = function(q) {
              if (q) {
                if (q instanceof M)
                  return q;
                var F = new O(q);
                return F._formatted = q.external, F._fsPath = q._sep === b ? q.fsPath : null, F;
              }
              return q;
            }, M;
          }();
          o.URI = S;
          var b = l.isWindows ? 1 : void 0, O = function(M) {
            function q() {
              var F = M !== null && M.apply(this, arguments) || this;
              return F._formatted = null, F._fsPath = null, F;
            }
            return c(q, M), Object.defineProperty(q.prototype, "fsPath", { get: function() {
              return this._fsPath || (this._fsPath = Ee(this, false)), this._fsPath;
            }, enumerable: false, configurable: true }), q.prototype.toString = function(F) {
              return F === void 0 && (F = false), F ? ke(this, true) : (this._formatted || (this._formatted = ke(this, false)), this._formatted);
            }, q.prototype.toJSON = function() {
              var F = { $mid: 1 };
              return this._fsPath && (F.fsPath = this._fsPath, F._sep = b), this._formatted && (F.external = this._formatted), this.path && (F.path = this.path), this.scheme && (F.scheme = this.scheme), this.authority && (F.authority = this.authority), this.query && (F.query = this.query), this.fragment && (F.fragment = this.fragment), F;
            }, q;
          }(S), L = ((u = {})[58] = "%3A", u[47] = "%2F", u[63] = "%3F", u[35] = "%23", u[91] = "%5B", u[93] = "%5D", u[64] = "%40", u[33] = "%21", u[36] = "%24", u[38] = "%26", u[39] = "%27", u[40] = "%28", u[41] = "%29", u[42] = "%2A", u[43] = "%2B", u[44] = "%2C", u[59] = "%3B", u[61] = "%3D", u[32] = "%20", u);
          function W(M, q, F) {
            for (var B = void 0, ie = -1, oe = 0; oe < M.length; oe++) {
              var J = M.charCodeAt(oe);
              if (J >= 97 && J <= 122 || J >= 65 && J <= 90 || J >= 48 && J <= 57 || J === 45 || J === 46 || J === 95 || J === 126 || q && J === 47 || F && J === 91 || F && J === 93 || F && J === 58)
                ie !== -1 && (B += encodeURIComponent(M.substring(ie, oe)), ie = -1), B !== void 0 && (B += M.charAt(oe));
              else {
                B === void 0 && (B = M.substr(0, oe));
                var lt = L[J];
                lt !== void 0 ? (ie !== -1 && (B += encodeURIComponent(M.substring(ie, oe)), ie = -1), B += lt) : ie === -1 && (ie = oe);
              }
            }
            return ie !== -1 && (B += encodeURIComponent(M.substring(ie))), B !== void 0 ? B : M;
          }
          function Z(M) {
            for (var q = void 0, F = 0; F < M.length; F++) {
              var B = M.charCodeAt(F);
              B === 35 || B === 63 ? (q === void 0 && (q = M.substr(0, F)), q += L[B]) : q !== void 0 && (q += M[F]);
            }
            return q !== void 0 ? q : M;
          }
          function Ee(M, q) {
            var F;
            return F = M.authority && M.path.length > 1 && M.scheme === "file" ? "//".concat(M.authority).concat(M.path) : M.path.charCodeAt(0) === 47 && (M.path.charCodeAt(1) >= 65 && M.path.charCodeAt(1) <= 90 || M.path.charCodeAt(1) >= 97 && M.path.charCodeAt(1) <= 122) && M.path.charCodeAt(2) === 58 ? q ? M.path.substr(1) : M.path[1].toLowerCase() + M.path.substr(2) : M.path, l.isWindows && (F = F.replace(/\//g, "\\")), F;
          }
          function ke(M, q) {
            var F = q ? Z : W, B = "", ie = M.scheme, oe = M.authority, J = M.path, lt = M.query, tt = M.fragment;
            if (ie && (B += ie, B += ":"), (oe || ie === "file") && (B += C, B += C), oe) {
              var Ot = oe.indexOf("@");
              if (Ot !== -1) {
                var nn = oe.substr(0, Ot);
                oe = oe.substr(Ot + 1), (Ot = nn.lastIndexOf(":")) === -1 ? B += F(nn, false, false) : (B += F(nn.substr(0, Ot), false, false), B += ":", B += F(nn.substr(Ot + 1), false, true)), B += "@";
              }
              (Ot = (oe = oe.toLowerCase()).lastIndexOf(":")) === -1 ? B += F(oe, false, true) : (B += F(oe.substr(0, Ot), false, true), B += oe.substr(Ot));
            }
            if (J) {
              if (J.length >= 3 && J.charCodeAt(0) === 47 && J.charCodeAt(2) === 58)
                (Nr = J.charCodeAt(1)) >= 65 && Nr <= 90 && (J = "/".concat(String.fromCharCode(Nr + 32), ":").concat(J.substr(3)));
              else if (J.length >= 2 && J.charCodeAt(1) === 58) {
                var Nr;
                (Nr = J.charCodeAt(0)) >= 65 && Nr <= 90 && (J = "".concat(String.fromCharCode(Nr + 32), ":").concat(J.substr(2)));
              }
              B += F(J, true, false);
            }
            return lt && (B += "?", B += F(lt, false, false)), tt && (B += "#", B += q ? tt : W(tt, false, false)), B;
          }
          function Je(M) {
            try {
              return decodeURIComponent(M);
            } catch {
              return M.length > 3 ? M.substr(0, 3) + Je(M.substr(3)) : M;
            }
          }
          o.uriToFsPath = Ee;
          var K = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
          function le(M) {
            return M.match(K) ? M.replace(K, function(q) {
              return Je(q);
            }) : M;
          }
        }, 679: function(i, o, a) {
          var s = this && this.__spreadArray || function(h, y, m) {
            if (m || arguments.length === 2)
              for (var R, C = 0, N = y.length; C < N; C++)
                !R && C in y || (R || (R = Array.prototype.slice.call(y, 0, C)), R[C] = y[C]);
            return h.concat(R || Array.prototype.slice.call(y));
          };
          Object.defineProperty(o, "__esModule", { value: true }), o.Utils = void 0;
          var u, c = a(470), l = c.posix || c, d = "/";
          (u = o.Utils || (o.Utils = {})).joinPath = function(h) {
            for (var y = [], m = 1; m < arguments.length; m++)
              y[m - 1] = arguments[m];
            return h.with({ path: l.join.apply(l, s([h.path], y, false)) });
          }, u.resolvePath = function(h) {
            for (var y = [], m = 1; m < arguments.length; m++)
              y[m - 1] = arguments[m];
            var R = h.path, C = false;
            R[0] !== d && (R = d + R, C = true);
            var N = l.resolve.apply(l, s([R], y, false));
            return C && N[0] === d && !h.authority && (N = N.substring(1)), h.with({ path: N });
          }, u.dirname = function(h) {
            if (h.path.length === 0 || h.path === d)
              return h;
            var y = l.dirname(h.path);
            return y.length === 1 && y.charCodeAt(0) === 46 && (y = ""), h.with({ path: y });
          }, u.basename = function(h) {
            return l.basename(h.path);
          }, u.extname = function(h) {
            return l.extname(h.path);
          };
        } }, e = {};
        function r(i) {
          var o = e[i];
          if (o !== void 0)
            return o.exports;
          var a = e[i] = { exports: {} };
          return t[i].call(a.exports, a, a.exports, r), a.exports;
        }
        var n = {};
        return (() => {
          var i = n;
          Object.defineProperty(i, "__esModule", { value: true }), i.Utils = i.URI = void 0;
          var o = r(796);
          Object.defineProperty(i, "URI", { enumerable: true, get: function() {
            return o.URI;
          } });
          var a = r(679);
          Object.defineProperty(i, "Utils", { enumerable: true, get: function() {
            return a.Utils;
          } });
        })(), n;
      })());
    });
    var zu = f((Va) => {
      Object.defineProperty(Va, "__esModule", { value: true });
      Va.eagerLoad = Va.inject = void 0;
      function KG(t, e, r, n) {
        let i = [t, e, r, n].reduce(Bb, {});
        return Wb(i);
      }
      Va.inject = KG;
      var fg = Symbol("isProxy");
      function Hb(t) {
        if (t && t[fg])
          for (let e of Object.values(t))
            Hb(e);
        return t;
      }
      Va.eagerLoad = Hb;
      function Wb(t, e) {
        let r = new Proxy({}, { deleteProperty: () => false, get: (n, i) => Gb(n, i, t, e || r), getOwnPropertyDescriptor: (n, i) => (Gb(n, i, t, e || r), Object.getOwnPropertyDescriptor(n, i)), has: (n, i) => i in t, ownKeys: () => [...Reflect.ownKeys(t), fg] });
        return r[fg] = true, r;
      }
      var Ub = Symbol();
      function Gb(t, e, r, n) {
        if (e in t) {
          if (t[e] instanceof Error)
            throw new Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: t[e] });
          if (t[e] === Ub)
            throw new Error('Cycle detected. Please make "' + String(e) + '" lazy. See https://langium.org/docs/di/cyclic-dependencies');
          return t[e];
        } else if (e in r) {
          let i = r[e];
          t[e] = Ub;
          try {
            t[e] = typeof i == "function" ? i(n) : Wb(i, n);
          } catch (o) {
            throw t[e] = o instanceof Error ? o : void 0, o;
          }
          return t[e];
        } else
          return;
      }
      function Bb(t, e) {
        if (e) {
          for (let [r, n] of Object.entries(e))
            if (n !== void 0) {
              let i = t[r];
              i !== null && n !== null && typeof i == "object" && typeof n == "object" ? t[r] = Bb(i, n) : t[r] = n;
            }
        }
        return t;
      }
    });
    var Tn = f((od) => {
      Object.defineProperty(od, "__esModule", { value: true });
      od.MultiMap = void 0;
      var Ya = $t(), pg = class {
        constructor(e) {
          if (this.map = /* @__PURE__ */ new Map(), e)
            for (let [r, n] of e)
              this.add(r, n);
        }
        get size() {
          return Ya.Reduction.sum((0, Ya.stream)(this.map.values()).map((e) => e.length));
        }
        clear() {
          this.map.clear();
        }
        delete(e, r) {
          if (r === void 0)
            return this.map.delete(e);
          {
            let n = this.map.get(e);
            if (n) {
              let i = n.indexOf(r);
              if (i >= 0)
                return n.length === 1 ? this.map.delete(e) : n.splice(i, 1), true;
            }
            return false;
          }
        }
        get(e) {
          var r;
          return (r = this.map.get(e)) !== null && r !== void 0 ? r : [];
        }
        has(e, r) {
          if (r === void 0)
            return this.map.has(e);
          {
            let n = this.map.get(e);
            return n ? n.indexOf(r) >= 0 : false;
          }
        }
        add(e, r) {
          return this.map.has(e) ? this.map.get(e).push(r) : this.map.set(e, [r]), this;
        }
        addAll(e, r) {
          return this.map.has(e) ? this.map.get(e).push(...r) : this.map.set(e, Array.from(r)), this;
        }
        forEach(e) {
          this.map.forEach((r, n) => r.forEach((i) => e(i, n, this)));
        }
        [Symbol.iterator]() {
          return this.entries().iterator();
        }
        entries() {
          return (0, Ya.stream)(this.map.entries()).flatMap(([e, r]) => r.map((n) => [e, n]));
        }
        keys() {
          return (0, Ya.stream)(this.map.keys());
        }
        values() {
          return (0, Ya.stream)(this.map.values()).flat();
        }
        entriesGroupedByKey() {
          return (0, Ya.stream)(this.map.entries());
        }
      };
      od.MultiMap = pg;
    });
    var we = f((T) => {
      Object.defineProperty(T, "__esModule", { value: true });
      T.isTypeAttribute = T.TypeAttribute = T.isType = T.Type = T.isTerminalRule = T.TerminalRule = T.isSimpleType = T.SimpleType = T.isReturnType = T.ReturnType = T.isReferenceType = T.ReferenceType = T.isParserRule = T.ParserRule = T.isParameterReference = T.ParameterReference = T.isParameter = T.Parameter = T.isNegation = T.Negation = T.isNamedArgument = T.NamedArgument = T.isLiteralCondition = T.LiteralCondition = T.isInterface = T.Interface = T.isInferredType = T.InferredType = T.isGrammarImport = T.GrammarImport = T.isGrammar = T.Grammar = T.isDisjunction = T.Disjunction = T.isConjunction = T.Conjunction = T.isArrayType = T.ArrayType = T.isAbstractElement = T.AbstractElement = T.isTypeDefinition = T.TypeDefinition = T.isPrimitiveType = T.isFeatureName = T.isCondition = T.Condition = T.isAbstractType = T.AbstractType = T.isAbstractRule = T.AbstractRule = void 0;
      T.reflection = T.LangiumGrammarAstReflection = T.isWildcard = T.Wildcard = T.isUntilToken = T.UntilToken = T.isUnorderedGroup = T.UnorderedGroup = T.isTerminalRuleCall = T.TerminalRuleCall = T.isTerminalGroup = T.TerminalGroup = T.isTerminalAlternatives = T.TerminalAlternatives = T.isRuleCall = T.RuleCall = T.isRegexToken = T.RegexToken = T.isNegatedToken = T.NegatedToken = T.isKeyword = T.Keyword = T.isGroup = T.Group = T.isCrossReference = T.CrossReference = T.isCharacterRange = T.CharacterRange = T.isAssignment = T.Assignment = T.isAlternatives = T.Alternatives = T.isAction = T.Action = T.isUnionType = T.UnionType = void 0;
      var zG = Zt();
      T.AbstractRule = "AbstractRule";
      function VG(t) {
        return T.reflection.isInstance(t, T.AbstractRule);
      }
      T.isAbstractRule = VG;
      T.AbstractType = "AbstractType";
      function YG(t) {
        return T.reflection.isInstance(t, T.AbstractType);
      }
      T.isAbstractType = YG;
      T.Condition = "Condition";
      function XG(t) {
        return T.reflection.isInstance(t, T.Condition);
      }
      T.isCondition = XG;
      function JG(t) {
        return Kb(t) || t === "current" || t === "entry" || t === "extends" || t === "false" || t === "fragment" || t === "grammar" || t === "hidden" || t === "import" || t === "interface" || t === "returns" || t === "terminal" || t === "true" || t === "type" || t === "infer" || t === "infers" || t === "with" || typeof t == "string" && /\^?[_a-zA-Z][\w_]*/.test(t);
      }
      T.isFeatureName = JG;
      function Kb(t) {
        return t === "string" || t === "number" || t === "boolean" || t === "Date" || t === "bigint";
      }
      T.isPrimitiveType = Kb;
      T.TypeDefinition = "TypeDefinition";
      function QG(t) {
        return T.reflection.isInstance(t, T.TypeDefinition);
      }
      T.isTypeDefinition = QG;
      T.AbstractElement = "AbstractElement";
      function ZG(t) {
        return T.reflection.isInstance(t, T.AbstractElement);
      }
      T.isAbstractElement = ZG;
      T.ArrayType = "ArrayType";
      function eH(t) {
        return T.reflection.isInstance(t, T.ArrayType);
      }
      T.isArrayType = eH;
      T.Conjunction = "Conjunction";
      function tH(t) {
        return T.reflection.isInstance(t, T.Conjunction);
      }
      T.isConjunction = tH;
      T.Disjunction = "Disjunction";
      function rH(t) {
        return T.reflection.isInstance(t, T.Disjunction);
      }
      T.isDisjunction = rH;
      T.Grammar = "Grammar";
      function nH(t) {
        return T.reflection.isInstance(t, T.Grammar);
      }
      T.isGrammar = nH;
      T.GrammarImport = "GrammarImport";
      function iH(t) {
        return T.reflection.isInstance(t, T.GrammarImport);
      }
      T.isGrammarImport = iH;
      T.InferredType = "InferredType";
      function oH(t) {
        return T.reflection.isInstance(t, T.InferredType);
      }
      T.isInferredType = oH;
      T.Interface = "Interface";
      function aH(t) {
        return T.reflection.isInstance(t, T.Interface);
      }
      T.isInterface = aH;
      T.LiteralCondition = "LiteralCondition";
      function sH(t) {
        return T.reflection.isInstance(t, T.LiteralCondition);
      }
      T.isLiteralCondition = sH;
      T.NamedArgument = "NamedArgument";
      function uH(t) {
        return T.reflection.isInstance(t, T.NamedArgument);
      }
      T.isNamedArgument = uH;
      T.Negation = "Negation";
      function cH(t) {
        return T.reflection.isInstance(t, T.Negation);
      }
      T.isNegation = cH;
      T.Parameter = "Parameter";
      function lH(t) {
        return T.reflection.isInstance(t, T.Parameter);
      }
      T.isParameter = lH;
      T.ParameterReference = "ParameterReference";
      function dH(t) {
        return T.reflection.isInstance(t, T.ParameterReference);
      }
      T.isParameterReference = dH;
      T.ParserRule = "ParserRule";
      function fH(t) {
        return T.reflection.isInstance(t, T.ParserRule);
      }
      T.isParserRule = fH;
      T.ReferenceType = "ReferenceType";
      function pH(t) {
        return T.reflection.isInstance(t, T.ReferenceType);
      }
      T.isReferenceType = pH;
      T.ReturnType = "ReturnType";
      function hH(t) {
        return T.reflection.isInstance(t, T.ReturnType);
      }
      T.isReturnType = hH;
      T.SimpleType = "SimpleType";
      function mH(t) {
        return T.reflection.isInstance(t, T.SimpleType);
      }
      T.isSimpleType = mH;
      T.TerminalRule = "TerminalRule";
      function gH(t) {
        return T.reflection.isInstance(t, T.TerminalRule);
      }
      T.isTerminalRule = gH;
      T.Type = "Type";
      function yH(t) {
        return T.reflection.isInstance(t, T.Type);
      }
      T.isType = yH;
      T.TypeAttribute = "TypeAttribute";
      function vH(t) {
        return T.reflection.isInstance(t, T.TypeAttribute);
      }
      T.isTypeAttribute = vH;
      T.UnionType = "UnionType";
      function TH(t) {
        return T.reflection.isInstance(t, T.UnionType);
      }
      T.isUnionType = TH;
      T.Action = "Action";
      function _H(t) {
        return T.reflection.isInstance(t, T.Action);
      }
      T.isAction = _H;
      T.Alternatives = "Alternatives";
      function RH(t) {
        return T.reflection.isInstance(t, T.Alternatives);
      }
      T.isAlternatives = RH;
      T.Assignment = "Assignment";
      function bH(t) {
        return T.reflection.isInstance(t, T.Assignment);
      }
      T.isAssignment = bH;
      T.CharacterRange = "CharacterRange";
      function SH(t) {
        return T.reflection.isInstance(t, T.CharacterRange);
      }
      T.isCharacterRange = SH;
      T.CrossReference = "CrossReference";
      function AH(t) {
        return T.reflection.isInstance(t, T.CrossReference);
      }
      T.isCrossReference = AH;
      T.Group = "Group";
      function PH(t) {
        return T.reflection.isInstance(t, T.Group);
      }
      T.isGroup = PH;
      T.Keyword = "Keyword";
      function CH(t) {
        return T.reflection.isInstance(t, T.Keyword);
      }
      T.isKeyword = CH;
      T.NegatedToken = "NegatedToken";
      function NH(t) {
        return T.reflection.isInstance(t, T.NegatedToken);
      }
      T.isNegatedToken = NH;
      T.RegexToken = "RegexToken";
      function EH(t) {
        return T.reflection.isInstance(t, T.RegexToken);
      }
      T.isRegexToken = EH;
      T.RuleCall = "RuleCall";
      function kH(t) {
        return T.reflection.isInstance(t, T.RuleCall);
      }
      T.isRuleCall = kH;
      T.TerminalAlternatives = "TerminalAlternatives";
      function wH(t) {
        return T.reflection.isInstance(t, T.TerminalAlternatives);
      }
      T.isTerminalAlternatives = wH;
      T.TerminalGroup = "TerminalGroup";
      function OH(t) {
        return T.reflection.isInstance(t, T.TerminalGroup);
      }
      T.isTerminalGroup = OH;
      T.TerminalRuleCall = "TerminalRuleCall";
      function DH(t) {
        return T.reflection.isInstance(t, T.TerminalRuleCall);
      }
      T.isTerminalRuleCall = DH;
      T.UnorderedGroup = "UnorderedGroup";
      function IH(t) {
        return T.reflection.isInstance(t, T.UnorderedGroup);
      }
      T.isUnorderedGroup = IH;
      T.UntilToken = "UntilToken";
      function xH(t) {
        return T.reflection.isInstance(t, T.UntilToken);
      }
      T.isUntilToken = xH;
      T.Wildcard = "Wildcard";
      function qH(t) {
        return T.reflection.isInstance(t, T.Wildcard);
      }
      T.isWildcard = qH;
      var ad = class extends zG.AbstractAstReflection {
        getAllTypes() {
          return ["AbstractElement", "AbstractRule", "AbstractType", "Action", "Alternatives", "ArrayType", "Assignment", "CharacterRange", "Condition", "Conjunction", "CrossReference", "Disjunction", "Grammar", "GrammarImport", "Group", "InferredType", "Interface", "Keyword", "LiteralCondition", "NamedArgument", "NegatedToken", "Negation", "Parameter", "ParameterReference", "ParserRule", "ReferenceType", "RegexToken", "ReturnType", "RuleCall", "SimpleType", "TerminalAlternatives", "TerminalGroup", "TerminalRule", "TerminalRuleCall", "Type", "TypeAttribute", "TypeDefinition", "UnionType", "UnorderedGroup", "UntilToken", "Wildcard"];
        }
        computeIsSubtype(e, r) {
          switch (e) {
            case T.Action:
              return this.isSubtype(T.AbstractElement, r) || this.isSubtype(T.AbstractType, r);
            case T.Alternatives:
            case T.Assignment:
            case T.CharacterRange:
            case T.CrossReference:
            case T.Group:
            case T.Keyword:
            case T.NegatedToken:
            case T.RegexToken:
            case T.RuleCall:
            case T.TerminalAlternatives:
            case T.TerminalGroup:
            case T.TerminalRuleCall:
            case T.UnorderedGroup:
            case T.UntilToken:
            case T.Wildcard:
              return this.isSubtype(T.AbstractElement, r);
            case T.ArrayType:
            case T.ReferenceType:
            case T.SimpleType:
            case T.UnionType:
              return this.isSubtype(T.TypeDefinition, r);
            case T.Conjunction:
            case T.Disjunction:
            case T.LiteralCondition:
            case T.Negation:
            case T.ParameterReference:
              return this.isSubtype(T.Condition, r);
            case T.Interface:
            case T.Type:
              return this.isSubtype(T.AbstractType, r);
            case T.ParserRule:
              return this.isSubtype(T.AbstractRule, r) || this.isSubtype(T.AbstractType, r);
            case T.TerminalRule:
              return this.isSubtype(T.AbstractRule, r);
            default:
              return false;
          }
        }
        getReferenceType(e) {
          let r = `${e.container.$type}:${e.property}`;
          switch (r) {
            case "Action:type":
            case "CrossReference:type":
            case "Interface:superTypes":
            case "ParserRule:returnType":
            case "SimpleType:typeRef":
              return T.AbstractType;
            case "Grammar:hiddenTokens":
            case "ParserRule:hiddenTokens":
            case "RuleCall:rule":
              return T.AbstractRule;
            case "Grammar:usedGrammars":
              return T.Grammar;
            case "NamedArgument:parameter":
            case "ParameterReference:parameter":
              return T.Parameter;
            case "TerminalRuleCall:rule":
              return T.TerminalRule;
            default:
              throw new Error(`${r} is not a valid reference id.`);
          }
        }
        getTypeMetaData(e) {
          switch (e) {
            case "Grammar":
              return { name: "Grammar", mandatory: [{ name: "definesHiddenTokens", type: "boolean" }, { name: "hiddenTokens", type: "array" }, { name: "imports", type: "array" }, { name: "interfaces", type: "array" }, { name: "isDeclared", type: "boolean" }, { name: "rules", type: "array" }, { name: "types", type: "array" }, { name: "usedGrammars", type: "array" }] };
            case "Interface":
              return { name: "Interface", mandatory: [{ name: "attributes", type: "array" }, { name: "superTypes", type: "array" }] };
            case "LiteralCondition":
              return { name: "LiteralCondition", mandatory: [{ name: "true", type: "boolean" }] };
            case "NamedArgument":
              return { name: "NamedArgument", mandatory: [{ name: "calledByName", type: "boolean" }] };
            case "ParserRule":
              return { name: "ParserRule", mandatory: [{ name: "definesHiddenTokens", type: "boolean" }, { name: "entry", type: "boolean" }, { name: "fragment", type: "boolean" }, { name: "hiddenTokens", type: "array" }, { name: "parameters", type: "array" }, { name: "wildcard", type: "boolean" }] };
            case "TerminalRule":
              return { name: "TerminalRule", mandatory: [{ name: "fragment", type: "boolean" }, { name: "hidden", type: "boolean" }] };
            case "TypeAttribute":
              return { name: "TypeAttribute", mandatory: [{ name: "isOptional", type: "boolean" }] };
            case "UnionType":
              return { name: "UnionType", mandatory: [{ name: "types", type: "array" }] };
            case "Alternatives":
              return { name: "Alternatives", mandatory: [{ name: "elements", type: "array" }] };
            case "CrossReference":
              return { name: "CrossReference", mandatory: [{ name: "deprecatedSyntax", type: "boolean" }] };
            case "Group":
              return { name: "Group", mandatory: [{ name: "elements", type: "array" }] };
            case "RuleCall":
              return { name: "RuleCall", mandatory: [{ name: "arguments", type: "array" }] };
            case "TerminalAlternatives":
              return { name: "TerminalAlternatives", mandatory: [{ name: "elements", type: "array" }] };
            case "TerminalGroup":
              return { name: "TerminalGroup", mandatory: [{ name: "elements", type: "array" }] };
            case "UnorderedGroup":
              return { name: "UnorderedGroup", mandatory: [{ name: "elements", type: "array" }] };
            default:
              return { name: e, mandatory: [] };
          }
        }
      };
      T.LangiumGrammarAstReflection = ad;
      T.reflection = new ad();
    });
    var be = f((nt) => {
      Object.defineProperty(nt, "__esModule", { value: true });
      nt.copyAstNode = nt.findLocalReferences = nt.streamReferences = nt.streamAst = nt.streamAllContents = nt.streamContents = nt.findRootNode = nt.getDocument = nt.hasContainerOfType = nt.getContainerOfType = nt.linkContentToContainer = void 0;
      var Bn = Zt(), io = $t(), LH = Le();
      function zb(t) {
        for (let [e, r] of Object.entries(t))
          e.startsWith("$") || (Array.isArray(r) ? r.forEach((n, i) => {
            (0, Bn.isAstNode)(n) && (n.$container = t, n.$containerProperty = e, n.$containerIndex = i);
          }) : (0, Bn.isAstNode)(r) && (r.$container = t, r.$containerProperty = e));
      }
      nt.linkContentToContainer = zb;
      function MH(t, e) {
        let r = t;
        for (; r; ) {
          if (e(r))
            return r;
          r = r.$container;
        }
      }
      nt.getContainerOfType = MH;
      function $H(t, e) {
        let r = t;
        for (; r; ) {
          if (e(r))
            return true;
          r = r.$container;
        }
        return false;
      }
      nt.hasContainerOfType = $H;
      function Vb(t) {
        let r = Yb(t).$document;
        if (!r)
          throw new Error("AST node has no document.");
        return r;
      }
      nt.getDocument = Vb;
      function Yb(t) {
        for (; t.$container; )
          t = t.$container;
        return t;
      }
      nt.findRootNode = Yb;
      function gg(t, e) {
        if (!t)
          throw new Error("Node must be an AstNode.");
        let r = e == null ? void 0 : e.range;
        return new io.StreamImpl(() => ({ keys: Object.keys(t), keyIndex: 0, arrayIndex: 0 }), (n) => {
          for (; n.keyIndex < n.keys.length; ) {
            let i = n.keys[n.keyIndex];
            if (!i.startsWith("$")) {
              let o = t[i];
              if ((0, Bn.isAstNode)(o)) {
                if (n.keyIndex++, hg(o, r))
                  return { done: false, value: o };
              } else if (Array.isArray(o)) {
                for (; n.arrayIndex < o.length; ) {
                  let a = n.arrayIndex++, s = o[a];
                  if ((0, Bn.isAstNode)(s) && hg(s, r))
                    return { done: false, value: s };
                }
                n.arrayIndex = 0;
              }
            }
            n.keyIndex++;
          }
          return io.DONE_RESULT;
        });
      }
      nt.streamContents = gg;
      function FH(t, e) {
        if (!t)
          throw new Error("Root node must be an AstNode.");
        return new io.TreeStreamImpl(t, (r) => gg(r, e));
      }
      nt.streamAllContents = FH;
      function Xb(t, e) {
        if (t) {
          if ((e == null ? void 0 : e.range) && !hg(t, e.range))
            return new io.TreeStreamImpl(t, () => []);
        } else
          throw new Error("Root node must be an AstNode.");
        return new io.TreeStreamImpl(t, (r) => gg(r, e), { includeRoot: true });
      }
      nt.streamAst = Xb;
      function hg(t, e) {
        var r;
        if (!e)
          return true;
        let n = (r = t.$cstNode) === null || r === void 0 ? void 0 : r.range;
        return n ? (0, LH.inRange)(n, e) : false;
      }
      function Jb(t) {
        return new io.StreamImpl(() => ({ keys: Object.keys(t), keyIndex: 0, arrayIndex: 0 }), (e) => {
          for (; e.keyIndex < e.keys.length; ) {
            let r = e.keys[e.keyIndex];
            if (!r.startsWith("$")) {
              let n = t[r];
              if ((0, Bn.isReference)(n))
                return e.keyIndex++, { done: false, value: { reference: n, container: t, property: r } };
              if (Array.isArray(n)) {
                for (; e.arrayIndex < n.length; ) {
                  let i = e.arrayIndex++, o = n[i];
                  if ((0, Bn.isReference)(o))
                    return { done: false, value: { reference: o, container: t, property: r, index: i } };
                }
                e.arrayIndex = 0;
              }
            }
            e.keyIndex++;
          }
          return io.DONE_RESULT;
        });
      }
      nt.streamReferences = Jb;
      function jH(t, e = Vb(t).parseResult.value) {
        let r = [];
        return Xb(e).forEach((n) => {
          Jb(n).forEach((i) => {
            i.reference.ref === t && r.push(i.reference);
          });
        }), (0, io.stream)(r);
      }
      nt.findLocalReferences = jH;
      function mg(t, e) {
        let r = { $type: t.$type };
        for (let [n, i] of Object.entries(t))
          if (!n.startsWith("$"))
            if ((0, Bn.isAstNode)(i))
              r[n] = mg(i, e);
            else if ((0, Bn.isReference)(i))
              r[n] = e(r, n, i.$refNode, i.$refText);
            else if (Array.isArray(i)) {
              let o = [];
              for (let a of i)
                (0, Bn.isAstNode)(a) ? o.push(mg(a, e)) : (0, Bn.isReference)(a) ? o.push(e(r, n, a.$refNode, a.$refText)) : o.push(a);
              r[n] = o;
            } else
              r[n] = i;
        return zb(r), r;
      }
      nt.copyAstNode = mg;
    });
    var eS = f((sd) => {
      Object.defineProperty(sd, "__esModule", { value: true });
      sd.getSourceRegion = void 0;
      var Qb = be(), UH = yt(), GH = $t();
      function HH(t) {
        var e, r;
        if (t) {
          if ("astNode" in t)
            return KH(t);
          if (Array.isArray(t))
            return t.reduce(Zb, void 0);
          {
            let n = t, i = WH(n) ? BH((r = (e = n == null ? void 0 : n.root) === null || e === void 0 ? void 0 : e.element) !== null && r !== void 0 ? r : n == null ? void 0 : n.element) : void 0;
            return Xa(n, i);
          }
        } else
          return;
      }
      sd.getSourceRegion = HH;
      function WH(t) {
        return typeof t < "u" && "element" in t && "text" in t;
      }
      function BH(t) {
        try {
          return (0, Qb.getDocument)(t).uri.toString();
        } catch {
          return;
        }
      }
      function KH(t) {
        var e, r;
        let { astNode: n, property: i, index: o } = t ?? {}, a = (e = n == null ? void 0 : n.$cstNode) !== null && e !== void 0 ? e : n == null ? void 0 : n.$textRegion;
        if (!(n === void 0 || a === void 0)) {
          if (i === void 0)
            return Xa(a, yg(n));
          {
            let s = (u) => o !== void 0 && o > -1 && Array.isArray(n[i]) ? o < u.length ? u[o] : void 0 : u.reduce(Zb, void 0);
            if (!((r = a.assignments) === null || r === void 0) && r[i]) {
              let u = s(a.assignments[i]);
              return u && Xa(u, yg(n));
            } else if (n.$cstNode) {
              let u = s((0, UH.findNodesForProperty)(n.$cstNode, i));
              return u && Xa(u, yg(n));
            } else
              return;
          }
        }
      }
      function yg(t) {
        var e, r, n, i;
        return t.$cstNode ? (r = (e = (0, Qb.getDocument)(t)) === null || e === void 0 ? void 0 : e.uri) === null || r === void 0 ? void 0 : r.toString() : t.$textRegion ? t.$textRegion.documentURI || ((i = (n = new GH.TreeStreamImpl(t, (o) => o.$container ? [o.$container] : []).find((o) => {
          var a;
          return (a = o.$textRegion) === null || a === void 0 ? void 0 : a.documentURI;
        })) === null || n === void 0 ? void 0 : n.$textRegion) === null || i === void 0 ? void 0 : i.documentURI) : void 0;
      }
      function Xa(t, e) {
        var r, n;
        let i = { offset: t.offset, end: (r = t.end) !== null && r !== void 0 ? r : t.offset + t.length, length: (n = t.length) !== null && n !== void 0 ? n : t.end - t.offset };
        return t.range && (i.range = t.range), e ?? (e = t.fileURI), e && (i.fileURI = e), i;
      }
      function Zb(t, e) {
        var r, n;
        if (t) {
          if (!e)
            return t && Xa(t);
        } else
          return e && Xa(e);
        let i = (r = t.end) !== null && r !== void 0 ? r : t.offset + t.length, o = (n = e.end) !== null && n !== void 0 ? n : e.offset + e.length, a = Math.min(t.offset, e.offset), s = Math.max(i, o), u = s - a, c = { offset: a, end: s, length: u };
        if (t.range && e.range && (c.range = { start: e.range.start.line < t.range.start.line || e.range.start.line === t.range.start.line && e.range.start.character < t.range.start.character ? e.range.start : t.range.start, end: e.range.end.line > t.range.end.line || e.range.end.line === t.range.end.line && e.range.end.character > t.range.end.character ? e.range.end : t.range.end }), t.fileURI || e.fileURI) {
          let l = t.fileURI, d = e.fileURI, h = l && d && l !== d ? `<unmergable text regions of ${l}, ${d}>` : l ?? d;
          c.fileURI = h;
        }
        return c;
      }
    });
    var oS = f((ud) => {
      Object.defineProperty(ud, "__esModule", { value: true });
      ud.processGeneratorNode = void 0;
      var Vu = Vo(), zH = eS(), vg = class {
        constructor(e) {
          this.defaultIndentation = "    ", this.pendingIndent = true, this.currentIndents = [], this.recentNonImmediateIndents = [], this.traceData = [], this.lines = [[]], typeof e == "string" ? this.defaultIndentation = e : typeof e == "number" && (this.defaultIndentation = "".padStart(e));
        }
        get content() {
          return this.lines.map((e) => e.join("")).join("");
        }
        get currentLineNumber() {
          return this.lines.length - 1;
        }
        get currentLineContent() {
          return this.lines[this.currentLineNumber].join("");
        }
        get currentPosition() {
          return { offset: this.content.length, line: this.currentLineNumber, character: this.currentLineContent.length };
        }
        append(e, r) {
          if (e.length > 0) {
            let n = r && this.currentPosition;
            this.lines[this.currentLineNumber].push(e), n && this.indentPendingTraceRegions(n);
          }
        }
        indentPendingTraceRegions(e) {
          for (let r = this.traceData.length - 1; r >= 0; r--) {
            let n = this.traceData[r];
            n.targetStart && n.targetStart.offset === e.offset && (n.targetStart = this.currentPosition);
          }
        }
        increaseIndent(e) {
          this.currentIndents.push(e), e.indentImmediately || this.recentNonImmediateIndents.push(e);
        }
        decreaseIndent() {
          this.currentIndents.pop();
        }
        get relevantIndents() {
          return this.currentIndents.filter((e) => !this.recentNonImmediateIndents.includes(e));
        }
        resetCurrentLine() {
          this.lines[this.currentLineNumber] = [];
        }
        addNewLine() {
          this.pendingIndent = true, this.lines.push([]), this.recentNonImmediateIndents.length = 0;
        }
        pushTraceRegion(e) {
          let r = VH(e, this.currentPosition, (n) => {
            var i, o;
            return (o = (i = this.traceData[this.traceData.length - 1]) === null || i === void 0 ? void 0 : i.children) === null || o === void 0 ? void 0 : o.push(n);
          });
          return this.traceData.push(r), r;
        }
        popTraceRegion(e) {
          let r = this.traceData.pop();
          return this.assertTrue(r === e, "Trace region mismatch!"), r;
        }
        getParentTraceSourceFileURI() {
          var e;
          for (let r = this.traceData.length - 1; r > -1; r--) {
            let n = (e = this.traceData[r].sourceRegion) === null || e === void 0 ? void 0 : e.fileURI;
            if (n)
              return n;
          }
        }
        assertTrue(e, r) {
          if (!e)
            throw new Error(r);
        }
      };
      function VH(t, e, r) {
        let n = { sourceRegion: t, targetRegion: void 0, children: [], targetStart: e, complete: (i) => {
          var o, a;
          return n.targetRegion = { offset: n.targetStart.offset, end: i.offset, length: i.offset - n.targetStart.offset, range: { start: { line: n.targetStart.line, character: n.targetStart.character }, end: { line: i.line, character: i.character } } }, delete n.targetStart, ((o = n.children) === null || o === void 0 ? void 0 : o.length) === 0 && delete n.children, !((a = n.targetRegion) === null || a === void 0) && a.length && r(n), delete n.complete, n;
        } };
        return n;
      }
      function YH(t, e) {
        let r = new vg(e), n = r.pushTraceRegion(void 0);
        tS(t, r), r.popTraceRegion(n), n.complete && n.complete(r.currentPosition);
        let i = n.children && n.children.length === 1 ? n.children[0] : void 0, o = i == null ? void 0 : i.targetRegion, a = n.targetRegion;
        return o && i.sourceRegion && o.offset === a.offset && o.length === a.length ? { text: r.content, trace: i } : { text: r.content, trace: n };
      }
      ud.processGeneratorNode = YH;
      function tS(t, e) {
        typeof t == "string" ? XH(t, e) : t instanceof Vu.IndentNode ? JH(t, e) : t instanceof Vu.CompositeGeneratorNode ? iS(t, e) : t instanceof Vu.NewLineNode && QH(t, e);
      }
      function rS(t, e) {
        return typeof t == "string" ? t.length !== 0 : t instanceof Vu.CompositeGeneratorNode ? t.contents.some((r) => rS(r, e)) : t instanceof Vu.NewLineNode ? !(t.ifNotEmpty && e.currentLineContent.length === 0) : false;
      }
      function XH(t, e) {
        t && (e.pendingIndent && nS(e, false), e.append(t));
      }
      function nS(t, e) {
        var r;
        let n = "";
        for (let i of t.relevantIndents.filter((o) => o.indentEmptyLines || !e))
          n += (r = i.indentation) !== null && r !== void 0 ? r : t.defaultIndentation;
        t.append(n, true), t.pendingIndent = false;
      }
      function iS(t, e) {
        let r, n = (0, zH.getSourceRegion)(t.tracedSource);
        n && (r = e.pushTraceRegion(n));
        for (let i of t.contents)
          tS(i, e);
        if (r) {
          e.popTraceRegion(r);
          let i = e.getParentTraceSourceFileURI();
          i && (n == null ? void 0 : n.fileURI) === i && delete n.fileURI, r.complete && r.complete(e.currentPosition);
        }
      }
      function JH(t, e) {
        var r;
        if (rS(t, e)) {
          t.indentImmediately && !e.pendingIndent && e.append((r = t.indentation) !== null && r !== void 0 ? r : e.defaultIndentation, true);
          try {
            e.increaseIndent(t), iS(t, e);
          } finally {
            e.decreaseIndent();
          }
        }
      }
      function QH(t, e) {
        t.ifNotEmpty && !ZH(e.currentLineContent) ? e.resetCurrentLine() : (e.pendingIndent && nS(e, true), e.append(t.lineDelimiter), e.addNewLine());
      }
      function ZH(t) {
        return t.trimStart() !== "";
      }
    });
    var cd = f((At) => {
      Object.defineProperty(At, "__esModule", { value: true });
      At.normalizeEOL = At.findIndentation = At.NEWLINE_REGEXP = At.SNLE = At.expandToString = At.expandToStringWithNL = void 0;
      var Yu = Vo();
      function eW(t, ...e) {
        return aS(t, ...e) + Yu.EOL;
      }
      At.expandToStringWithNL = eW;
      function aS(t, ...e) {
        let r = e.reduce((a, s, u) => {
          var c;
          return a + (s === void 0 ? At.SNLE : rW((0, Yu.toString)(s), a)) + ((c = t[u + 1]) !== null && c !== void 0 ? c : "");
        }, t[0]).split(At.NEWLINE_REGEXP).filter((a) => a.trim() !== At.SNLE).map((a) => a.replace(At.SNLE, "").trimRight());
        r = r.length > 1 && r[0].trim().length === 0 ? r.slice(1) : r, r = r.length !== 0 && r[r.length - 1].trimRight().length === 0 ? r.slice(0, r.length - 1) : r;
        let o = sS(r);
        return r.map((a) => a.slice(o).trimRight()).join(Yu.EOL);
      }
      At.expandToString = aS;
      At.SNLE = Object.freeze("__SKIP^NEW^LINE^IF^EMPTY__");
      At.NEWLINE_REGEXP = /\r?\n/g;
      var tW = /\S|$/;
      function rW(t, e) {
        let r = Math.max(0, e.length - e.lastIndexOf(`
`) - 1), n = " ".repeat(r);
        return t.replace(At.NEWLINE_REGEXP, Yu.EOL + n);
      }
      function sS(t) {
        let e = t.filter((n) => n.length > 0).map((n) => n.search(tW)), r = e.length === 0 ? 0 : Math.min(...e);
        return Math.max(0, r);
      }
      At.findIndentation = sS;
      function nW(t) {
        return t.replace(At.NEWLINE_REGEXP, Yu.EOL);
      }
      At.normalizeEOL = nW;
    });
    var Rg = f((oo) => {
      Object.defineProperty(oo, "__esModule", { value: true });
      oo.expandTracedToNodeIf = oo.expandTracedToNode = oo.expandToNode = void 0;
      var dd = Vo(), _g = cd();
      function uS(t, ...e) {
        let r = oW(t), n = aW(t, e, r);
        return uW(n);
      }
      oo.expandToNode = uS;
      function cS(t, e, r) {
        return (n, ...i) => (0, dd.traceToNode)(t, e, r)(uS(n, ...i));
      }
      oo.expandTracedToNode = cS;
      function iW(t, e, r, n) {
        return t ? cS(typeof e == "function" ? e() : e, r, n) : () => {
        };
      }
      oo.expandTracedToNodeIf = iW;
      function oW(t) {
        let e = t.join("_").split(_g.NEWLINE_REGEXP), r = e.length > 1 && e[0].trim().length === 0, n = r && e.length > 1 && e[e.length - 1].trim().length === 0;
        if (e.length === 1 || e.length !== 0 && e[0].trim().length !== 0 || e.length === 2 && e[1].trim().length === 0)
          return { indentation: 0, omitFirstLine: r, omitLastLine: n, trimLastLine: e.length !== 1 && e[e.length - 1].trim().length === 0 };
        {
          let i = r ? e.slice(1) : e;
          i = n ? i.slice(0, i.length - 1) : i, i = i.filter((a) => a.length !== 0);
          let o = (0, _g.findIndentation)(i);
          return { indentation: o, omitFirstLine: r, omitLastLine: n && (e[e.length - 1].length < o || !e[e.length - 1].startsWith(i[0].substring(0, o))) };
        }
      }
      function aW(t, e, { indentation: r, omitFirstLine: n, omitLastLine: i, trimLastLine: o }) {
        let a = [];
        t.forEach((c, l) => {
          a.push(...c.split(_g.NEWLINE_REGEXP).map((d, h) => h === 0 || d.length < r ? d : d.substring(r)).reduce(l === 0 ? (d, h, y) => y === 0 ? n ? [] : [h] : y === 1 && d.length === 0 ? [h] : d.concat(ld, h) : (d, h, y) => y === 0 ? [h] : d.concat(ld, h), []).filter((d) => !(typeof d == "string" && d.length === 0)).concat((0, dd.isGeneratorNode)(e[l]) ? e[l] : e[l] !== void 0 ? new dd.CompositeGeneratorNode(String(e[l])) : l < e.length ? lS : []));
        });
        let s = a.length, u = s !== 0 ? a[s - 1] : void 0;
        return (i || o) && typeof u == "string" && u.trim().length === 0 ? n && s !== 1 && a[s - 2] === ld ? a.slice(0, s - 2) : a.slice(0, s - 1) : a;
      }
      var ld = { isNewLine: true }, lS = { isUndefinedSegment: true }, Tg = (t) => t === ld, sW = (t) => t === lS;
      function uW(t) {
        return t.reduce((r, n, i) => sW(n) ? r : Tg(n) ? { node: i === 0 || Tg(t[i - 1]) || typeof t[i - 1] == "string" ? r.node.appendNewLine() : r.node.appendNewLineIfNotEmpty() } : (() => {
          var o;
          let a = (i === 0 || Tg(t[i - 1])) && typeof n == "string" && n.length !== 0 ? "".padStart(n.length - n.trimLeft().length) : "", s;
          return { node: r.indented ? r.node : a.length !== 0 ? r.node.indent({ indentation: a, indentImmediately: false, indentedChildren: (u) => s = u.append(n) }) : r.node.append(n), indented: s ?? ((o = r.indented) === null || o === void 0 ? void 0 : o.append(n)) };
        })(), { node: new dd.CompositeGeneratorNode() }).node;
      }
    });
    var Vo = f((Oe) => {
      Object.defineProperty(Oe, "__esModule", { value: true });
      Oe.NLEmpty = Oe.NL = Oe.NewLineNode = Oe.IndentNode = Oe.traceToNodeIf = Oe.traceToNode = Oe.CompositeGeneratorNode = Oe.toStringAndTrace = Oe.toString = Oe.isNewLineNode = Oe.isGeneratorNode = Oe.EOL = void 0;
      var cW = Zt(), fS = oS(), dS = Rg();
      Oe.EOL = typeof process > "u" ? `
` : process.platform === "win32" ? `\r
` : `
`;
      function pS(t) {
        return t instanceof Pi || t instanceof Xu || t instanceof Yo;
      }
      Oe.isGeneratorNode = pS;
      function lW(t) {
        return t instanceof Yo;
      }
      Oe.isNewLineNode = lW;
      function dW(t, e) {
        return pS(t) ? (0, fS.processGeneratorNode)(t, e).text : String(t);
      }
      Oe.toString = dW;
      function fW(t, e) {
        return (0, fS.processGeneratorNode)(t, e);
      }
      Oe.toStringAndTrace = fW;
      var Pi = class {
        constructor(...e) {
          this.contents = [], this.append(...e);
        }
        isEmpty() {
          return this.contents.length === 0;
        }
        trace(e, r, n) {
          if ((0, cW.isAstNode)(e)) {
            if (this.tracedSource = { astNode: e, property: r, index: n }, this.tracedSource.property === void 0 && this.tracedSource.index !== void 0 && this.tracedSource.index > -1)
              throw new Error("Generation support: 'property' argument must not be 'undefined' if a non-negative value is assigned to 'index' in 'CompositeGeneratorNode.trace(...)'.");
          } else
            this.tracedSource = e;
          return this;
        }
        append(...e) {
          for (let r of e)
            typeof r == "function" ? r(this) : r && this.contents.push(r);
          return this;
        }
        appendIf(e, ...r) {
          return e ? this.append(...r) : this;
        }
        appendNewLine() {
          return this.append(Oe.NL);
        }
        appendNewLineIf(e) {
          return e ? this.append(Oe.NL) : this;
        }
        appendNewLineIfNotEmpty() {
          return this.append(Oe.NLEmpty);
        }
        appendNewLineIfNotEmptyIf(e) {
          return e ? this.appendNewLineIfNotEmpty() : this;
        }
        appendTemplate(e, ...r) {
          return this.append((0, dS.expandToNode)(e, ...r));
        }
        appendTemplateIf(e) {
          return e ? (r, ...n) => this.appendTemplate(r, ...n) : () => this;
        }
        indent(e) {
          let { indentedChildren: r, indentation: n, indentEmptyLines: i, indentImmediately: o } = Array.isArray(e) || typeof e == "function" ? { indentedChildren: e } : typeof e == "object" ? e : {}, a = new Xu(n, o, i);
          return this.contents.push(a), Array.isArray(r) ? a.append(...r) : r && a.append(r), this;
        }
        appendTraced(e, r, n) {
          return (i) => this.append(new Pi().trace(e, r, n).append(i));
        }
        appendTracedIf(e, r, n, i) {
          return e ? this.appendTraced(typeof r == "function" ? r() : r, n, i) : () => this;
        }
        appendTracedTemplate(e, r, n) {
          return (i, ...o) => this.append((0, dS.expandTracedToNode)(e, r, n)(i, ...o));
        }
        appendTracedTemplateIf(e, r, n, i) {
          return e ? this.appendTracedTemplate(typeof r == "function" ? r() : r, n, i) : () => this;
        }
      };
      Oe.CompositeGeneratorNode = Pi;
      function hS(t, e, r) {
        return (n) => n instanceof Pi && n.tracedSource === void 0 ? n.trace(t, e, r) : new Pi().trace(t, e, r).append(n);
      }
      Oe.traceToNode = hS;
      function pW(t, e, r, n) {
        return t ? hS(typeof e == "function" ? e() : e, r, n) : () => {
        };
      }
      Oe.traceToNodeIf = pW;
      var Xu = class extends Pi {
        constructor(e, r = true, n = false) {
          super(), this.indentImmediately = true, this.indentEmptyLines = false, typeof e == "string" ? this.indentation = e : typeof e == "number" && (this.indentation = "".padStart(e)), this.indentImmediately = r, this.indentEmptyLines = n;
        }
      };
      Oe.IndentNode = Xu;
      var Yo = class {
        constructor(e, r = false) {
          this.ifNotEmpty = false, this.lineDelimiter = e ?? Oe.EOL, this.ifNotEmpty = r;
        }
      };
      Oe.NewLineNode = Yo;
      Oe.NL = new Yo();
      Oe.NLEmpty = new Yo(void 0, true);
    });
    var Za = f((Se) => {
      Object.defineProperty(Se, "__esModule", { value: true });
      Se.isMandatoryPropertyType = Se.propertyTypeToString = Se.isTypeAssignable = Se.TypeResolutionError = Se.InterfaceType = Se.UnionType = Se.isInterfaceType = Se.isUnionType = Se.isStringType = Se.isPrimitiveType = Se.isValueType = Se.flattenPropertyUnion = Se.isPropertyUnion = Se.isArrayType = Se.isReferenceType = void 0;
      var Me = Vo(), Ja = es();
      function Ju(t) {
        return "referenceType" in t;
      }
      Se.isReferenceType = Ju;
      function Qu(t) {
        return "elementType" in t;
      }
      Se.isArrayType = Qu;
      function wr(t) {
        return "types" in t;
      }
      Se.isPropertyUnion = wr;
      function gS(t) {
        if (wr(t)) {
          let e = [];
          for (let r of t.types)
            e.push(...gS(r));
          return e;
        } else
          return [t];
      }
      Se.flattenPropertyUnion = gS;
      function Xo(t) {
        return "value" in t;
      }
      Se.isValueType = Xo;
      function Kn(t) {
        return "primitive" in t;
      }
      Se.isPrimitiveType = Kn;
      function so(t) {
        return "string" in t;
      }
      Se.isStringType = so;
      function Qa(t) {
        return t && "type" in t;
      }
      Se.isUnionType = Qa;
      function Cg(t) {
        return t && "properties" in t;
      }
      Se.isInterfaceType = Cg;
      var Sg = class {
        constructor(e, r) {
          var n;
          this.superTypes = /* @__PURE__ */ new Set(), this.subTypes = /* @__PURE__ */ new Set(), this.containerTypes = /* @__PURE__ */ new Set(), this.typeNames = /* @__PURE__ */ new Set(), this.name = e, this.declared = (n = r == null ? void 0 : r.declared) !== null && n !== void 0 ? n : false, this.dataType = r == null ? void 0 : r.dataType;
        }
        toAstTypesString(e) {
          let r = new Me.CompositeGeneratorNode();
          return r.append(`export type ${this.name} = ${Jo(this.type, "AstType")};`, Me.NL), e && (r.append(Me.NL), vS(r, this.name)), this.dataType && hW(r, this), (0, Me.toString)(r);
        }
        toDeclaredTypesString(e) {
          let r = new Me.CompositeGeneratorNode();
          return r.append(`type ${Eg(this.name, e)} = ${Jo(this.type, "DeclaredType")};`, Me.NL), (0, Me.toString)(r);
        }
      };
      Se.UnionType = Sg;
      var Zu = class {
        get superProperties() {
          return this.getSuperProperties(/* @__PURE__ */ new Set());
        }
        getSuperProperties(e) {
          if (e.has(this.name))
            return [];
          e.add(this.name);
          let r = /* @__PURE__ */ new Map();
          for (let n of this.properties)
            r.set(n.name, n);
          for (let n of this.interfaceSuperTypes) {
            let i = n.getSuperProperties(e);
            for (let o of i)
              r.has(o.name) || r.set(o.name, o);
          }
          return Array.from(r.values());
        }
        get allProperties() {
          let e = new Map(this.superProperties.map((n) => [n.name, n]));
          for (let n of this.subTypes)
            this.getSubTypeProperties(n, e, /* @__PURE__ */ new Set());
          return Array.from(e.values());
        }
        getSubTypeProperties(e, r, n) {
          if (n.has(this.name))
            return;
          n.add(this.name);
          let i = Cg(e) ? e.properties : [];
          for (let o of i)
            r.has(o.name) || r.set(o.name, o);
          for (let o of e.subTypes)
            this.getSubTypeProperties(o, r, n);
        }
        get interfaceSuperTypes() {
          return Array.from(this.superTypes).filter((e) => e instanceof Zu);
        }
        constructor(e, r, n) {
          this.superTypes = /* @__PURE__ */ new Set(), this.subTypes = /* @__PURE__ */ new Set(), this.containerTypes = /* @__PURE__ */ new Set(), this.typeNames = /* @__PURE__ */ new Set(), this.declared = false, this.abstract = false, this.properties = [], this.name = e, this.declared = r, this.abstract = n;
        }
        toAstTypesString(e) {
          let r = new Me.CompositeGeneratorNode(), n = this.interfaceSuperTypes.map((o) => o.name), i = n.length > 0 ? (0, Ja.distinctAndSorted)([...n]) : ["AstNode"];
          return r.append(`export interface ${this.name} extends ${i.join(", ")} {`, Me.NL), r.indent((o) => {
            this.containerTypes.size > 0 && o.append(`readonly $container: ${(0, Ja.distinctAndSorted)([...this.containerTypes].map((a) => a.name)).join(" | ")};`, Me.NL), this.typeNames.size > 0 && o.append(`readonly $type: ${(0, Ja.distinctAndSorted)([...this.typeNames]).map((a) => `'${a}'`).join(" | ")};`, Me.NL), mS(o, this.properties, "AstType");
          }), r.append("}", Me.NL), e && (r.append(Me.NL), vS(r, this.name)), (0, Me.toString)(r);
        }
        toDeclaredTypesString(e) {
          let r = new Me.CompositeGeneratorNode(), n = Eg(this.name, e), i = (0, Ja.distinctAndSorted)(this.interfaceSuperTypes.map((o) => o.name)).join(", ");
          return r.append(`interface ${n}${i.length > 0 ? ` extends ${i}` : ""} {`, Me.NL), r.indent((o) => mS(o, this.properties, "DeclaredType", e)), r.append("}", Me.NL), (0, Me.toString)(r);
        }
      };
      Se.InterfaceType = Zu;
      var Ag = class extends Error {
        constructor(e, r) {
          super(e), this.name = "TypeResolutionError", this.target = r;
        }
      };
      Se.TypeResolutionError = Ag;
      function ao(t, e) {
        return wr(t) ? t.types.every((r) => ao(r, e)) : wr(e) ? e.types.some((r) => ao(t, r)) : Xo(e) && Qa(e.value) ? Xo(t) && Qa(t.value) && e.value.name === t.value.name ? true : ao(t, e.value.type) : Ju(t) ? Ju(e) && ao(t.referenceType, e.referenceType) : Qu(t) ? Qu(e) && ao(t.elementType, e.elementType) : Xo(t) ? Qa(t.value) ? ao(t.value.type, e) : Xo(e) ? Qa(e.value) ? ao(t, e.value.type) : yS(t.value, e.value, /* @__PURE__ */ new Set()) : false : Kn(t) ? Kn(e) && t.primitive === e.primitive : so(t) ? Kn(e) && e.primitive === "string" || so(e) && e.string === t.string : false;
      }
      Se.isTypeAssignable = ao;
      function yS(t, e, r) {
        if (r.has(t.name) || (r.add(t.name), t.name === e.name))
          return true;
        for (let n of t.superTypes)
          if (Cg(n) && yS(n, e, r))
            return true;
        return false;
      }
      function Jo(t, e = "AstType") {
        if (Ju(t)) {
          let r = Jo(t.referenceType, e);
          return e === "AstType" ? `Reference<${r}>` : `@${bg(t.referenceType, r)}`;
        } else if (Qu(t)) {
          let r = Jo(t.elementType, e);
          return e === "AstType" ? `Array<${r}>` : `${bg(t.elementType, r)}[]`;
        } else if (wr(t)) {
          let r = t.types.map((n) => bg(n, Jo(n, e)));
          return (0, Ja.distinctAndSorted)(r).join(" | ");
        } else {
          if (Xo(t))
            return t.value.name;
          if (Kn(t))
            return t.primitive;
          if (so(t)) {
            let r = e === "AstType" ? "'" : '"';
            return `${r}${t.string}${r}`;
          }
        }
        throw new Error("Invalid type");
      }
      Se.propertyTypeToString = Jo;
      function bg(t, e) {
        return wr(t) && (e = `(${e})`), e;
      }
      function mS(t, e, r, n = /* @__PURE__ */ new Set()) {
        function i(o) {
          let a = r === "AstType" ? o.name : Eg(o.name, n), s = o.optional && !Ng(o.type), u = Jo(o.type, r);
          return `${a}${s ? "?" : ""}: ${u}`;
        }
        (0, Ja.distinctAndSorted)(e, (o, a) => o.name.localeCompare(a.name)).forEach((o) => t.append(i(o), Me.NL));
      }
      function Ng(t) {
        return Qu(t) ? true : Ju(t) ? false : wr(t) ? t.types.every((e) => Ng(e)) : Kn(t) ? t.primitive === "boolean" : false;
      }
      Se.isMandatoryPropertyType = Ng;
      function vS(t, e) {
        t.append(`export const ${e} = '${e}';`, Me.NL), t.append(Me.NL), t.append(`export function is${e}(item: unknown): item is ${e} {`, Me.NL), t.indent((r) => r.append(`return reflection.isInstance(item, ${e});`, Me.NL)), t.append("}", Me.NL);
      }
      function hW(t, e) {
        switch (e.dataType) {
          case "string":
            if (Pg(e.type)) {
              let r = Array.from(e.subTypes).map((o) => o.name), n = TS(e.type), i = _S(e.type);
              if (r.length === 0 && n.length === 0 && i.length === 0)
                fd(t, e.name, `typeof item === '${e.dataType}'`);
              else {
                let o = mW(r, n, i);
                fd(t, e.name, o);
              }
            }
            break;
          case "number":
          case "boolean":
          case "bigint":
            fd(t, e.name, `typeof item === '${e.dataType}'`);
            break;
          case "Date":
            fd(t, e.name, "item instanceof Date");
            break;
          default:
            return;
        }
      }
      function Pg(t) {
        let e = true;
        if (Kn(t))
          return t.primitive === "string";
        if (so(t))
          return true;
        if (wr(t)) {
          for (let r of t.types)
            if (Xo(r))
              if (Qa(r.value)) {
                if (!Pg(r.value.type))
                  return false;
              } else
                return false;
            else if (Kn(r)) {
              if (r.primitive !== "string" || !r.regex)
                return false;
            } else if (wr(r))
              e = Pg(r);
            else if (!so(r))
              return false;
        } else
          return false;
        return e;
      }
      function mW(t, e, r) {
        let n = [...t.map((i) => `is${i}(item)`), ...e.map((i) => `item === '${i}'`)];
        if (r.length > 0) {
          let i = r.map((o) => `/${o}/.test(item)`).join(" || ");
          n.push(`(typeof item === 'string' && (${i}))`);
        }
        return n.join(" || ");
      }
      function Eg(t, e) {
        return e.has(t) ? `^${t}` : t;
      }
      function TS(t) {
        let e = [];
        if (so(t))
          return [t.string];
        if (wr(t))
          for (let r of t.types)
            so(r) ? e.push(r.string) : wr(r) && e.push(...TS(r));
        return e;
      }
      function _S(t) {
        let e = [];
        if (Kn(t) && t.primitive === "string" && t.regex && e.push(t.regex), wr(t))
          for (let r of t.types)
            Kn(r) && r.primitive === "string" && r.regex ? e.push(r.regex) : wr(r) && e.push(..._S(r));
        return e;
      }
      function fd(t, e, r) {
        t.append(Me.NL, `export function is${e}(item: unknown): item is ${e} {`, Me.NL), t.indent((n) => n.append(`return ${r};`, Me.NL)), t.append("}", Me.NL);
      }
    });
    var es = f((Ye) => {
      Object.defineProperty(Ye, "__esModule", { value: true });
      Ye.isAstType = Ye.findReferenceTypes = Ye.hasBooleanType = Ye.hasArrayType = Ye.sortInterfacesTopologically = Ye.mergeTypesAndInterfaces = Ye.mergeInterfaces = Ye.collectSuperTypes = Ye.collectTypeHierarchy = Ye.collectChildrenTypes = Ye.distinctAndSorted = Ye.collectAllPlainProperties = void 0;
      var ec = Tn(), Ci = we(), zn = Za();
      function gW(t) {
        let e = new ec.MultiMap();
        for (let r of t)
          e.addAll(r.name, r.properties);
        for (let r of t)
          for (let n of r.superTypes) {
            let i = e.get(n);
            i && e.addAll(r.name, i);
          }
        return e;
      }
      Ye.collectAllPlainProperties = gW;
      function yW(t, e) {
        return Array.from(new Set(t)).sort(e);
      }
      Ye.distinctAndSorted = yW;
      function RS(t, e, r, n) {
        let i = /* @__PURE__ */ new Set();
        return i.add(t), e.findReferences(t, {}).forEach((a) => {
          let s = r.getOrCreateDocument(a.sourceUri), u = n.getAstNode(s.parseResult.value, a.sourcePath);
          (0, Ci.isInterface)(u) ? (i.add(u), RS(u, e, r, n).forEach((l) => i.add(l))) : u && (0, Ci.isType)(u.$container) && i.add(u.$container);
        }), i;
      }
      Ye.collectChildrenTypes = RS;
      function vW(t) {
        let e = new Set(t), r = new ec.MultiMap(), n = new ec.MultiMap();
        for (let a of e) {
          for (let s of a.superTypes)
            e.has(s) && (r.add(a.name, s.name), n.add(s.name, a.name));
          for (let s of a.subTypes)
            e.has(s) && (r.add(s.name, a.name), n.add(a.name, s.name));
        }
        let i = new ec.MultiMap(), o = new ec.MultiMap();
        for (let [a, s] of Array.from(r.entriesGroupedByKey()).sort(([u], [c]) => u.localeCompare(c)))
          i.addAll(a, Array.from(new Set(s)));
        for (let [a, s] of Array.from(n.entriesGroupedByKey()).sort(([u], [c]) => u.localeCompare(c)))
          o.addAll(a, Array.from(new Set(s)));
        return { superTypes: i, subTypes: o };
      }
      Ye.collectTypeHierarchy = vW;
      function kg(t) {
        let e = /* @__PURE__ */ new Set();
        if ((0, Ci.isInterface)(t))
          e.add(t), t.superTypes.forEach((r) => {
            if ((0, Ci.isInterface)(r.ref)) {
              e.add(r.ref);
              let n = kg(r.ref);
              for (let i of n)
                e.add(i);
            }
          });
        else if ((0, Ci.isType)(t)) {
          let r = bS(t.type);
          for (let n of r) {
            let i = kg(n);
            for (let o of i)
              e.add(o);
          }
        }
        return e;
      }
      Ye.collectSuperTypes = kg;
      function bS(t) {
        var e;
        if ((0, Ci.isUnionType)(t))
          return t.types.flatMap((r) => bS(r));
        if ((0, Ci.isSimpleType)(t)) {
          let r = (e = t.typeRef) === null || e === void 0 ? void 0 : e.ref;
          if ((0, Ci.isType)(r) || (0, Ci.isInterface)(r))
            return [r];
        }
        return [];
      }
      function TW(t, e) {
        return t.interfaces.concat(e.interfaces);
      }
      Ye.mergeInterfaces = TW;
      function _W(t) {
        return t.interfaces.concat(t.unions);
      }
      Ye.mergeTypesAndInterfaces = _W;
      function RW(t) {
        let e = t.sort((i, o) => i.name.localeCompare(o.name)).map((i) => ({ value: i, nodes: [] }));
        for (let i of e)
          i.nodes = e.filter((o) => i.value.superTypes.has(o.value.name));
        let r = [], n = e.filter((i) => i.nodes.length === 0);
        for (; n.length > 0; ) {
          let i = n.shift();
          r.includes(i) || (r.push(i), e.filter((o) => o.nodes.includes(i)).forEach((o) => n.push(o)));
        }
        return r.map((i) => i.value);
      }
      Ye.sortInterfacesTopologically = RW;
      function SS(t) {
        return (0, zn.isPropertyUnion)(t) ? t.types.some((e) => SS(e)) : !!(0, zn.isArrayType)(t);
      }
      Ye.hasArrayType = SS;
      function AS(t) {
        return (0, zn.isPropertyUnion)(t) ? t.types.some((e) => AS(e)) : (0, zn.isPrimitiveType)(t) ? t.primitive === "boolean" : false;
      }
      Ye.hasBooleanType = AS;
      function wg(t) {
        if ((0, zn.isPropertyUnion)(t))
          return t.types.flatMap((e) => wg(e));
        if ((0, zn.isReferenceType)(t)) {
          let e = t.referenceType;
          if ((0, zn.isValueType)(e))
            return [e.value.name];
        } else if ((0, zn.isArrayType)(t))
          return wg(t.elementType);
        return [];
      }
      Ye.findReferenceTypes = wg;
      function Og(t) {
        if ((0, zn.isPropertyUnion)(t))
          return t.types.every(Og);
        if ((0, zn.isValueType)(t)) {
          let e = t.value;
          return "type" in e ? Og(e.type) : true;
        }
        return false;
      }
      Ye.isAstType = Og;
    });
    var rs = f((ts) => {
      Object.defineProperty(ts, "__esModule", { value: true });
      ts.DefaultNameProvider = ts.isNamed = void 0;
      var bW = yt();
      function PS(t) {
        return typeof t.name == "string";
      }
      ts.isNamed = PS;
      var Dg = class {
        getName(e) {
          if (PS(e))
            return e.name;
        }
        getNameNode(e) {
          return (0, bW.findNodeForProperty)(e.$cstNode, "name");
        }
      };
      ts.DefaultNameProvider = Dg;
    });
    var tc = f((CS, pd) => {
      (function(t, e) {
        typeof define == "function" && define.amd ? define([], e) : typeof pd == "object" && pd.exports ? pd.exports = e() : t.regexpToAst = e();
      })(typeof self < "u" ? self : CS, function() {
        function t() {
        }
        t.prototype.saveState = function() {
          return { idx: this.idx, input: this.input, groupIdx: this.groupIdx };
        }, t.prototype.restoreState = function(m) {
          this.idx = m.idx, this.input = m.input, this.groupIdx = m.groupIdx;
        }, t.prototype.pattern = function(m) {
          this.idx = 0, this.input = m, this.groupIdx = 0, this.consumeChar("/");
          var R = this.disjunction();
          this.consumeChar("/");
          for (var C = { type: "Flags", loc: { begin: this.idx, end: m.length }, global: false, ignoreCase: false, multiLine: false, unicode: false, sticky: false }; this.isRegExpFlag(); )
            switch (this.popChar()) {
              case "g":
                a(C, "global");
                break;
              case "i":
                a(C, "ignoreCase");
                break;
              case "m":
                a(C, "multiLine");
                break;
              case "u":
                a(C, "unicode");
                break;
              case "y":
                a(C, "sticky");
                break;
            }
          if (this.idx !== this.input.length)
            throw Error("Redundant input: " + this.input.substring(this.idx));
          return { type: "Pattern", flags: C, value: R, loc: this.loc(0) };
        }, t.prototype.disjunction = function() {
          var m = [], R = this.idx;
          for (m.push(this.alternative()); this.peekChar() === "|"; )
            this.consumeChar("|"), m.push(this.alternative());
          return { type: "Disjunction", value: m, loc: this.loc(R) };
        }, t.prototype.alternative = function() {
          for (var m = [], R = this.idx; this.isTerm(); )
            m.push(this.term());
          return { type: "Alternative", value: m, loc: this.loc(R) };
        }, t.prototype.term = function() {
          return this.isAssertion() ? this.assertion() : this.atom();
        }, t.prototype.assertion = function() {
          var m = this.idx;
          switch (this.popChar()) {
            case "^":
              return { type: "StartAnchor", loc: this.loc(m) };
            case "$":
              return { type: "EndAnchor", loc: this.loc(m) };
            case "\\":
              switch (this.popChar()) {
                case "b":
                  return { type: "WordBoundary", loc: this.loc(m) };
                case "B":
                  return { type: "NonWordBoundary", loc: this.loc(m) };
              }
              throw Error("Invalid Assertion Escape");
            case "(":
              this.consumeChar("?");
              var R;
              switch (this.popChar()) {
                case "=":
                  R = "Lookahead";
                  break;
                case "!":
                  R = "NegativeLookahead";
                  break;
              }
              s(R);
              var C = this.disjunction();
              return this.consumeChar(")"), { type: R, value: C, loc: this.loc(m) };
          }
          u();
        }, t.prototype.quantifier = function(m) {
          var R, C = this.idx;
          switch (this.popChar()) {
            case "*":
              R = { atLeast: 0, atMost: 1 / 0 };
              break;
            case "+":
              R = { atLeast: 1, atMost: 1 / 0 };
              break;
            case "?":
              R = { atLeast: 0, atMost: 1 };
              break;
            case "{":
              var N = this.integerIncludingZero();
              switch (this.popChar()) {
                case "}":
                  R = { atLeast: N, atMost: N };
                  break;
                case ",":
                  var S;
                  this.isDigit() ? (S = this.integerIncludingZero(), R = { atLeast: N, atMost: S }) : R = { atLeast: N, atMost: 1 / 0 }, this.consumeChar("}");
                  break;
              }
              if (m === true && R === void 0)
                return;
              s(R);
              break;
          }
          if (!(m === true && R === void 0))
            return s(R), this.peekChar(0) === "?" ? (this.consumeChar("?"), R.greedy = false) : R.greedy = true, R.type = "Quantifier", R.loc = this.loc(C), R;
        }, t.prototype.atom = function() {
          var m, R = this.idx;
          switch (this.peekChar()) {
            case ".":
              m = this.dotAll();
              break;
            case "\\":
              m = this.atomEscape();
              break;
            case "[":
              m = this.characterClass();
              break;
            case "(":
              m = this.group();
              break;
          }
          return m === void 0 && this.isPatternCharacter() && (m = this.patternCharacter()), s(m), m.loc = this.loc(R), this.isQuantifier() && (m.quantifier = this.quantifier()), m;
        }, t.prototype.dotAll = function() {
          return this.consumeChar("."), { type: "Set", complement: true, value: [i(`
`), i("\r"), i("\u2028"), i("\u2029")] };
        }, t.prototype.atomEscape = function() {
          switch (this.consumeChar("\\"), this.peekChar()) {
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        }, t.prototype.decimalEscapeAtom = function() {
          var m = this.positiveInteger();
          return { type: "GroupBackReference", value: m };
        }, t.prototype.characterClassEscape = function() {
          var m, R = false;
          switch (this.popChar()) {
            case "d":
              m = l;
              break;
            case "D":
              m = l, R = true;
              break;
            case "s":
              m = h;
              break;
            case "S":
              m = h, R = true;
              break;
            case "w":
              m = d;
              break;
            case "W":
              m = d, R = true;
              break;
          }
          return s(m), { type: "Set", value: m, complement: R };
        }, t.prototype.controlEscapeAtom = function() {
          var m;
          switch (this.popChar()) {
            case "f":
              m = i("\f");
              break;
            case "n":
              m = i(`
`);
              break;
            case "r":
              m = i("\r");
              break;
            case "t":
              m = i("	");
              break;
            case "v":
              m = i("\v");
              break;
          }
          return s(m), { type: "Character", value: m };
        }, t.prototype.controlLetterEscapeAtom = function() {
          this.consumeChar("c");
          var m = this.popChar();
          if (/[a-zA-Z]/.test(m) === false)
            throw Error("Invalid ");
          var R = m.toUpperCase().charCodeAt(0) - 64;
          return { type: "Character", value: R };
        }, t.prototype.nulCharacterAtom = function() {
          return this.consumeChar("0"), { type: "Character", value: i("\0") };
        }, t.prototype.hexEscapeSequenceAtom = function() {
          return this.consumeChar("x"), this.parseHexDigits(2);
        }, t.prototype.regExpUnicodeEscapeSequenceAtom = function() {
          return this.consumeChar("u"), this.parseHexDigits(4);
        }, t.prototype.identityEscapeAtom = function() {
          var m = this.popChar();
          return { type: "Character", value: i(m) };
        }, t.prototype.classPatternCharacterAtom = function() {
          switch (this.peekChar()) {
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
            case "\\":
            case "]":
              throw Error("TBD");
            default:
              var m = this.popChar();
              return { type: "Character", value: i(m) };
          }
        }, t.prototype.characterClass = function() {
          var m = [], R = false;
          for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), R = true); this.isClassAtom(); ) {
            var C = this.classAtom(), N = C.type === "Character";
            if (N && this.isRangeDash()) {
              this.consumeChar("-");
              var S = this.classAtom(), b = S.type === "Character";
              if (b) {
                if (S.value < C.value)
                  throw Error("Range out of order in character class");
                m.push({ from: C.value, to: S.value });
              } else
                o(C.value, m), m.push(i("-")), o(S.value, m);
            } else
              o(C.value, m);
          }
          return this.consumeChar("]"), { type: "Set", complement: R, value: m };
        }, t.prototype.classAtom = function() {
          switch (this.peekChar()) {
            case "]":
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              throw Error("TBD");
            case "\\":
              return this.classEscape();
            default:
              return this.classPatternCharacterAtom();
          }
        }, t.prototype.classEscape = function() {
          switch (this.consumeChar("\\"), this.peekChar()) {
            case "b":
              return this.consumeChar("b"), { type: "Character", value: i("\b") };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        }, t.prototype.group = function() {
          var m = true;
          switch (this.consumeChar("("), this.peekChar(0)) {
            case "?":
              this.consumeChar("?"), this.consumeChar(":"), m = false;
              break;
            default:
              this.groupIdx++;
              break;
          }
          var R = this.disjunction();
          this.consumeChar(")");
          var C = { type: "Group", capturing: m, value: R };
          return m && (C.idx = this.groupIdx), C;
        }, t.prototype.positiveInteger = function() {
          var m = this.popChar();
          if (n.test(m) === false)
            throw Error("Expecting a positive integer");
          for (; r.test(this.peekChar(0)); )
            m += this.popChar();
          return parseInt(m, 10);
        }, t.prototype.integerIncludingZero = function() {
          var m = this.popChar();
          if (r.test(m) === false)
            throw Error("Expecting an integer");
          for (; r.test(this.peekChar(0)); )
            m += this.popChar();
          return parseInt(m, 10);
        }, t.prototype.patternCharacter = function() {
          var m = this.popChar();
          switch (m) {
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
              throw Error("TBD");
            default:
              return { type: "Character", value: i(m) };
          }
        }, t.prototype.isRegExpFlag = function() {
          switch (this.peekChar(0)) {
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
              return true;
            default:
              return false;
          }
        }, t.prototype.isRangeDash = function() {
          return this.peekChar() === "-" && this.isClassAtom(1);
        }, t.prototype.isDigit = function() {
          return r.test(this.peekChar(0));
        }, t.prototype.isClassAtom = function(m) {
          switch (m === void 0 && (m = 0), this.peekChar(m)) {
            case "]":
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        }, t.prototype.isTerm = function() {
          return this.isAtom() || this.isAssertion();
        }, t.prototype.isAtom = function() {
          if (this.isPatternCharacter())
            return true;
          switch (this.peekChar(0)) {
            case ".":
            case "\\":
            case "[":
            case "(":
              return true;
            default:
              return false;
          }
        }, t.prototype.isAssertion = function() {
          switch (this.peekChar(0)) {
            case "^":
            case "$":
              return true;
            case "\\":
              switch (this.peekChar(1)) {
                case "b":
                case "B":
                  return true;
                default:
                  return false;
              }
            case "(":
              return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
              return false;
          }
        }, t.prototype.isQuantifier = function() {
          var m = this.saveState();
          try {
            return this.quantifier(true) !== void 0;
          } catch {
            return false;
          } finally {
            this.restoreState(m);
          }
        }, t.prototype.isPatternCharacter = function() {
          switch (this.peekChar()) {
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        }, t.prototype.parseHexDigits = function(m) {
          for (var R = "", C = 0; C < m; C++) {
            var N = this.popChar();
            if (e.test(N) === false)
              throw Error("Expecting a HexDecimal digits");
            R += N;
          }
          var S = parseInt(R, 16);
          return { type: "Character", value: S };
        }, t.prototype.peekChar = function(m) {
          return m === void 0 && (m = 0), this.input[this.idx + m];
        }, t.prototype.popChar = function() {
          var m = this.peekChar(0);
          return this.consumeChar(), m;
        }, t.prototype.consumeChar = function(m) {
          if (m !== void 0 && this.input[this.idx] !== m)
            throw Error("Expected: '" + m + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
          if (this.idx >= this.input.length)
            throw Error("Unexpected end of input");
          this.idx++;
        }, t.prototype.loc = function(m) {
          return { begin: m, end: this.idx };
        };
        var e = /[0-9a-fA-F]/, r = /[0-9]/, n = /[1-9]/;
        function i(m) {
          return m.charCodeAt(0);
        }
        function o(m, R) {
          m.length !== void 0 ? m.forEach(function(C) {
            R.push(C);
          }) : R.push(m);
        }
        function a(m, R) {
          if (m[R] === true)
            throw "duplicate flag " + R;
          m[R] = true;
        }
        function s(m) {
          if (m === void 0)
            throw Error("Internal Error - Should never get here!");
        }
        function u() {
          throw Error("Internal Error - Should never get here!");
        }
        var c, l = [];
        for (c = i("0"); c <= i("9"); c++)
          l.push(c);
        var d = [i("_")].concat(l);
        for (c = i("a"); c <= i("z"); c++)
          d.push(c);
        for (c = i("A"); c <= i("Z"); c++)
          d.push(c);
        var h = [i(" "), i("\f"), i(`
`), i("\r"), i("	"), i("\v"), i("	"), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i("\u2028"), i("\u2029"), i(""), i(""), i(""), i("\uFEFF")];
        function y() {
        }
        return y.prototype.visitChildren = function(m) {
          for (var R in m) {
            var C = m[R];
            m.hasOwnProperty(R) && (C.type !== void 0 ? this.visit(C) : Array.isArray(C) && C.forEach(function(N) {
              this.visit(N);
            }, this));
          }
        }, y.prototype.visit = function(m) {
          switch (m.type) {
            case "Pattern":
              this.visitPattern(m);
              break;
            case "Flags":
              this.visitFlags(m);
              break;
            case "Disjunction":
              this.visitDisjunction(m);
              break;
            case "Alternative":
              this.visitAlternative(m);
              break;
            case "StartAnchor":
              this.visitStartAnchor(m);
              break;
            case "EndAnchor":
              this.visitEndAnchor(m);
              break;
            case "WordBoundary":
              this.visitWordBoundary(m);
              break;
            case "NonWordBoundary":
              this.visitNonWordBoundary(m);
              break;
            case "Lookahead":
              this.visitLookahead(m);
              break;
            case "NegativeLookahead":
              this.visitNegativeLookahead(m);
              break;
            case "Character":
              this.visitCharacter(m);
              break;
            case "Set":
              this.visitSet(m);
              break;
            case "Group":
              this.visitGroup(m);
              break;
            case "GroupBackReference":
              this.visitGroupBackReference(m);
              break;
            case "Quantifier":
              this.visitQuantifier(m);
              break;
          }
          this.visitChildren(m);
        }, y.prototype.visitPattern = function(m) {
        }, y.prototype.visitFlags = function(m) {
        }, y.prototype.visitDisjunction = function(m) {
        }, y.prototype.visitAlternative = function(m) {
        }, y.prototype.visitStartAnchor = function(m) {
        }, y.prototype.visitEndAnchor = function(m) {
        }, y.prototype.visitWordBoundary = function(m) {
        }, y.prototype.visitNonWordBoundary = function(m) {
        }, y.prototype.visitLookahead = function(m) {
        }, y.prototype.visitNegativeLookahead = function(m) {
        }, y.prototype.visitCharacter = function(m) {
        }, y.prototype.visitSet = function(m) {
        }, y.prototype.visitGroup = function(m) {
        }, y.prototype.visitGroupBackReference = function(m) {
        }, y.prototype.visitQuantifier = function(m) {
        }, { RegExpParser: t, BaseRegExpVisitor: y, VERSION: "0.5.0" };
      });
    });
    var Zo = f((er) => {
      Object.defineProperty(er, "__esModule", { value: true });
      er.partialRegex = er.partialMatches = er.getCaseInsensitivePattern = er.escapeRegExp = er.isWhitespaceRegExp = er.isMultilineComment = er.getTerminalParts = void 0;
      var NS = tc(), ES = new NS.RegExpParser(), Ig = class extends NS.BaseRegExpVisitor {
        constructor() {
          super(...arguments), this.isStarting = true, this.endRegexStack = [], this.multiline = false;
        }
        get endRegex() {
          return this.endRegexStack.join("");
        }
        reset(e) {
          this.multiline = false, this.regex = e, this.startRegex = "", this.isStarting = true, this.endRegexStack = [];
        }
        visitGroup(e) {
          e.quantifier && (this.isStarting = false, this.endRegexStack = []);
        }
        visitCharacter(e) {
          let r = String.fromCharCode(e.value);
          if (!this.multiline && r === `
` && (this.multiline = true), e.quantifier)
            this.isStarting = false, this.endRegexStack = [];
          else {
            let n = xg(r);
            this.endRegexStack.push(n), this.isStarting && (this.startRegex += n);
          }
        }
        visitSet(e) {
          if (!this.multiline) {
            let r = this.regex.substring(e.loc.begin, e.loc.end), n = new RegExp(r);
            this.multiline = Boolean(`
`.match(n));
          }
          if (e.quantifier)
            this.isStarting = false, this.endRegexStack = [];
          else {
            let r = this.regex.substring(e.loc.begin, e.loc.end);
            this.endRegexStack.push(r), this.isStarting && (this.startRegex += r);
          }
        }
        visitChildren(e) {
          e.type === "Group" && e.quantifier || super.visitChildren(e);
        }
      }, Qo = new Ig();
      function SW(t) {
        try {
          typeof t != "string" && (t = t.source), t = `/${t}/`;
          let e = ES.pattern(t), r = [];
          for (let n of e.value.value)
            Qo.reset(t), Qo.visit(n), r.push({ start: Qo.startRegex, end: Qo.endRegex });
          return r;
        } catch {
          return [];
        }
      }
      er.getTerminalParts = SW;
      function AW(t) {
        try {
          return typeof t != "string" && (t = t.source), t = `/${t}/`, Qo.reset(t), Qo.visit(ES.pattern(t)), Qo.multiline;
        } catch {
          return false;
        }
      }
      er.isMultilineComment = AW;
      function PW(t) {
        return (typeof t == "string" ? new RegExp(t) : t).test(" ");
      }
      er.isWhitespaceRegExp = PW;
      function xg(t) {
        return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      er.escapeRegExp = xg;
      function CW(t) {
        return Array.prototype.map.call(t, (e) => /\w/.test(e) ? `[${e.toLowerCase()}${e.toUpperCase()}]` : xg(e)).join("");
      }
      er.getCaseInsensitivePattern = CW;
      function NW(t, e) {
        let r = kS(t), n = e.match(r);
        return !!n && n[0].length > 0;
      }
      er.partialMatches = NW;
      function kS(t) {
        typeof t == "string" && (t = new RegExp(t));
        let e = t, r = t.source, n = 0;
        function i() {
          let o = "", a;
          function s(c) {
            o += r.substr(n, c), n += c;
          }
          function u(c) {
            o += "(?:" + r.substr(n, c) + "|$)", n += c;
          }
          for (; n < r.length; )
            switch (r[n]) {
              case "\\":
                switch (r[n + 1]) {
                  case "c":
                    u(3);
                    break;
                  case "x":
                    u(4);
                    break;
                  case "u":
                    e.unicode ? r[n + 2] === "{" ? u(r.indexOf("}", n) - n + 1) : u(6) : u(2);
                    break;
                  case "p":
                  case "P":
                    e.unicode ? u(r.indexOf("}", n) - n + 1) : u(2);
                    break;
                  case "k":
                    u(r.indexOf(">", n) - n + 1);
                    break;
                  default:
                    u(2);
                    break;
                }
                break;
              case "[":
                a = /\[(?:\\.|.)*?\]/g, a.lastIndex = n, a = a.exec(r) || [], u(a[0].length);
                break;
              case "|":
              case "^":
              case "$":
              case "*":
              case "+":
              case "?":
                s(1);
                break;
              case "{":
                a = /\{\d+,?\d*\}/g, a.lastIndex = n, a = a.exec(r), a ? s(a[0].length) : u(1);
                break;
              case "(":
                if (r[n + 1] === "?")
                  switch (r[n + 2]) {
                    case ":":
                      o += "(?:", n += 3, o += i() + "|$)";
                      break;
                    case "=":
                      o += "(?=", n += 3, o += i() + ")";
                      break;
                    case "!":
                      a = n, n += 3, i(), o += r.substr(a, n - a);
                      break;
                    case "<":
                      switch (r[n + 3]) {
                        case "=":
                        case "!":
                          a = n, n += 4, i(), o += r.substr(a, n - a);
                          break;
                        default:
                          s(r.indexOf(">", n) - n + 1), o += i() + "|$)";
                          break;
                      }
                      break;
                  }
                else
                  s(1), o += i() + "|$)";
                break;
              case ")":
                return ++n, o;
              default:
                u(1);
                break;
            }
          return o;
        }
        return new RegExp(i(), t.flags);
      }
      er.partialRegex = kS;
    });
    var Ft = f((re) => {
      var EW = re && re.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), kW = re && re.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), wW = re && re.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && EW(e, t, r);
        return kW(e, t), e;
      };
      Object.defineProperty(re, "__esModule", { value: true });
      re.isPrimitiveType = re.extractAssignments = re.resolveTransitiveImports = re.resolveImport = re.resolveImportUri = re.terminalRegex = re.getRuleType = re.getActionType = re.getExplicitRuleType = re.getTypeNameWithoutError = re.getTypeName = re.getActionAtElement = re.isDataType = re.hasDataTypeReturn = re.isDataTypeRule = re.isArrayOperator = re.isArrayCardinality = re.isOptionalCardinality = void 0;
      var se = wW(we()), wS = vn(), hd = be(), OW = Za(), DW = Zo();
      function IW(t) {
        return t === "?" || t === "*";
      }
      re.isOptionalCardinality = IW;
      function xW(t) {
        return t === "*" || t === "+";
      }
      re.isArrayCardinality = xW;
      function qW(t) {
        return t === "+=";
      }
      re.isArrayOperator = qW;
      function Fg(t) {
        return OS(t, /* @__PURE__ */ new Set());
      }
      re.isDataTypeRule = Fg;
      function OS(t, e) {
        if (e.has(t))
          return true;
        e.add(t);
        for (let r of (0, hd.streamAllContents)(t))
          if (se.isRuleCall(r)) {
            if (!r.rule.ref || se.isParserRule(r.rule.ref) && !OS(r.rule.ref, e))
              return false;
          } else {
            if (se.isAssignment(r))
              return false;
            if (se.isAction(r))
              return false;
          }
        return Boolean(t.definition);
      }
      function LW(t) {
        var e;
        let r = (e = t.returnType) === null || e === void 0 ? void 0 : e.ref;
        return t.dataType !== void 0 || se.isType(r) && DS(r);
      }
      re.hasDataTypeReturn = LW;
      function DS(t) {
        return Lg(t.type, /* @__PURE__ */ new Set());
      }
      re.isDataType = DS;
      function Lg(t, e) {
        if (e.has(t))
          return true;
        if (e.add(t), se.isArrayType(t))
          return false;
        if (se.isReferenceType(t))
          return false;
        if (se.isUnionType(t))
          return t.types.every((r) => Lg(r, e));
        if (se.isSimpleType(t)) {
          if (t.primitiveType !== void 0)
            return true;
          if (t.stringType !== void 0)
            return true;
          if (t.typeRef !== void 0) {
            let r = t.typeRef.ref;
            return se.isType(r) ? Lg(r.type, e) : false;
          } else
            return false;
        } else
          return false;
      }
      function IS(t) {
        let e = t.$container;
        if (se.isGroup(e)) {
          let r = e.elements, n = r.indexOf(t);
          for (let i = n - 1; i >= 0; i--) {
            let o = r[i];
            if (se.isAction(o))
              return o;
            {
              let a = (0, hd.streamAllContents)(r[i]).find(se.isAction);
              if (a)
                return a;
            }
          }
        }
        if (se.isAbstractElement(e))
          return IS(e);
      }
      re.getActionAtElement = IS;
      function jg(t) {
        var e;
        if (se.isParserRule(t))
          return Fg(t) ? t.name : (e = Ug(t)) !== null && e !== void 0 ? e : t.name;
        if (se.isInterface(t) || se.isType(t) || se.isReturnType(t))
          return t.name;
        if (se.isAction(t)) {
          let r = xS(t);
          if (r)
            return r;
        } else if (se.isInferredType(t))
          return t.name;
        throw new OW.TypeResolutionError("Cannot get name of Unknown Type", t.$cstNode);
      }
      re.getTypeName = jg;
      function MW(t) {
        if (t)
          try {
            return jg(t);
          } catch {
            return;
          }
      }
      re.getTypeNameWithoutError = MW;
      function Ug(t) {
        if (t.inferredType)
          return t.inferredType.name;
        if (t.dataType)
          return t.dataType;
        if (t.returnType) {
          let e = t.returnType.ref;
          if (e) {
            if (se.isParserRule(e))
              return e.name;
            if (se.isInterface(e) || se.isType(e))
              return e.name;
          }
        }
      }
      re.getExplicitRuleType = Ug;
      function xS(t) {
        var e;
        if (t.inferredType)
          return t.inferredType.name;
        if (!((e = t.type) === null || e === void 0) && e.ref)
          return jg(t.type.ref);
      }
      re.getActionType = xS;
      function $W(t) {
        var e, r, n;
        return se.isTerminalRule(t) ? (r = (e = t.type) === null || e === void 0 ? void 0 : e.name) !== null && r !== void 0 ? r : "string" : Fg(t) ? t.name : (n = Ug(t)) !== null && n !== void 0 ? n : t.name;
      }
      re.getRuleType = $W;
      function qS(t) {
        return rc(t.definition);
      }
      re.terminalRegex = qS;
      var Gg = /[\s\S]/.source;
      function rc(t) {
        if (se.isTerminalAlternatives(t))
          return FW(t);
        if (se.isTerminalGroup(t))
          return jW(t);
        if (se.isCharacterRange(t))
          return HW(t);
        if (se.isTerminalRuleCall(t)) {
          let e = t.rule.ref;
          if (!e)
            throw new Error("Missing rule reference.");
          return Ni(qS(e), { cardinality: t.cardinality, lookahead: t.lookahead });
        } else {
          if (se.isNegatedToken(t))
            return GW(t);
          if (se.isUntilToken(t))
            return UW(t);
          if (se.isRegexToken(t))
            return Ni(t.regex, { cardinality: t.cardinality, lookahead: t.lookahead, wrap: false });
          if (se.isWildcard(t))
            return Ni(Gg, { cardinality: t.cardinality, lookahead: t.lookahead });
          throw new Error(`Invalid terminal element: ${t == null ? void 0 : t.$type}`);
        }
      }
      function FW(t) {
        return Ni(t.elements.map(rc).join("|"), { cardinality: t.cardinality, lookahead: t.lookahead });
      }
      function jW(t) {
        return Ni(t.elements.map(rc).join(""), { cardinality: t.cardinality, lookahead: t.lookahead });
      }
      function UW(t) {
        return Ni(`${Gg}*?${rc(t.terminal)}`, { cardinality: t.cardinality, lookahead: t.lookahead });
      }
      function GW(t) {
        return Ni(`(?!${rc(t.terminal)})${Gg}*?`, { cardinality: t.cardinality, lookahead: t.lookahead });
      }
      function HW(t) {
        return t.right ? Ni(`[${qg(t.left)}-${qg(t.right)}]`, { cardinality: t.cardinality, lookahead: t.lookahead, wrap: false }) : Ni(qg(t.left), { cardinality: t.cardinality, lookahead: t.lookahead, wrap: false });
      }
      function qg(t) {
        return (0, DW.escapeRegExp)(t.value);
      }
      function Ni(t, e) {
        var r;
        return (e.wrap !== false || e.lookahead) && (t = `(${(r = e.lookahead) !== null && r !== void 0 ? r : ""}${t})`), e.cardinality ? `${t}${e.cardinality}` : t;
      }
      function LS(t) {
        if (t.path === void 0 || t.path.length === 0)
          return;
        let e = wS.Utils.dirname((0, hd.getDocument)(t).uri), r = t.path;
        return r.endsWith(".langium") || (r += ".langium"), wS.Utils.resolvePath(e, r);
      }
      re.resolveImportUri = LS;
      function Hg(t, e) {
        let r = LS(e);
        try {
          if (r) {
            let i = t.getOrCreateDocument(r).parseResult.value;
            if (se.isGrammar(i))
              return i;
          }
        } catch {
        }
      }
      re.resolveImport = Hg;
      function WW(t, e) {
        if (se.isGrammarImport(e)) {
          let r = Hg(t, e);
          if (r) {
            let n = Mg(t, r);
            return n.push(r), n;
          }
          return [];
        } else
          return Mg(t, e);
      }
      re.resolveTransitiveImports = WW;
      function Mg(t, e, r = e, n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set()) {
        let o = (0, hd.getDocument)(e);
        if (r !== e && i.add(e), !n.has(o.uri)) {
          n.add(o.uri);
          for (let a of e.imports) {
            let s = Hg(t, a);
            s && Mg(t, s, r, n, i);
          }
        }
        return Array.from(i);
      }
      function $g(t) {
        return se.isAssignment(t) ? [t] : se.isAlternatives(t) || se.isGroup(t) || se.isUnorderedGroup(t) ? t.elements.flatMap((e) => $g(e)) : se.isRuleCall(t) && t.rule.ref ? $g(t.rule.ref.definition) : [];
      }
      re.extractAssignments = $g;
      var BW = ["string", "number", "boolean", "Date", "bigint"];
      function KW(t) {
        return BW.includes(t);
      }
      re.isPrimitiveType = KW;
    });
    var Td = f((it) => {
      Object.defineProperty(it, "__esModule", { value: true });
      it.flattenPlainType = it.mergePropertyTypes = it.plainToTypes = it.isPlainStringType = it.isPlainPrimitiveType = it.isPlainValueType = it.isPlainPropertyUnion = it.isPlainArrayType = it.isPlainReferenceType = it.isPlainUnion = it.isPlainInterface = void 0;
      var MS = Za();
      function zW(t) {
        return !$S(t);
      }
      it.isPlainInterface = zW;
      function $S(t) {
        return "type" in t;
      }
      it.isPlainUnion = $S;
      function md(t) {
        return "referenceType" in t;
      }
      it.isPlainReferenceType = md;
      function gd(t) {
        return "elementType" in t;
      }
      it.isPlainArrayType = gd;
      function Bg(t) {
        return "types" in t;
      }
      it.isPlainPropertyUnion = Bg;
      function yd(t) {
        return "value" in t;
      }
      it.isPlainValueType = yd;
      function FS(t) {
        return "primitive" in t;
      }
      it.isPlainPrimitiveType = FS;
      function jS(t) {
        return "string" in t;
      }
      it.isPlainStringType = jS;
      function VW(t) {
        let e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
        for (let n of t.interfaces) {
          let i = new MS.InterfaceType(n.name, n.declared, n.abstract);
          e.set(n.name, i);
        }
        for (let n of t.unions) {
          let i = new MS.UnionType(n.name, { declared: n.declared, dataType: n.dataType });
          r.set(n.name, i);
        }
        for (let n of t.interfaces) {
          let i = e.get(n.name);
          for (let o of n.superTypes) {
            let a = e.get(o) || r.get(o);
            a && i.superTypes.add(a);
          }
          for (let o of n.subTypes) {
            let a = e.get(o) || r.get(o);
            a && i.subTypes.add(a);
          }
          for (let o of n.properties) {
            let a = YW(o, e, r);
            i.properties.push(a);
          }
        }
        for (let n of t.unions) {
          let i = r.get(n.name);
          i.type = nc(n.type, i, e, r);
        }
        return { interfaces: Array.from(e.values()), unions: Array.from(r.values()) };
      }
      it.plainToTypes = VW;
      function YW(t, e, r) {
        return { name: t.name, optional: t.optional, astNodes: t.astNodes, type: nc(t.type, void 0, e, r) };
      }
      function nc(t, e, r, n) {
        if (gd(t))
          return { elementType: nc(t.elementType, e, r, n) };
        if (md(t))
          return { referenceType: nc(t.referenceType, void 0, r, n) };
        if (Bg(t))
          return { types: t.types.map((i) => nc(i, e, r, n)) };
        if (jS(t))
          return { string: t.string };
        if (FS(t))
          return { primitive: t.primitive, regex: t.regex };
        if (yd(t)) {
          let i = r.get(t.value) || n.get(t.value);
          return i ? (e && e.subTypes.add(i), { value: i }) : { primitive: "unknown" };
        } else
          throw new Error("Invalid property type");
      }
      function XW(t, e) {
        let r = vd(t), n = vd(e);
        for (let i of n)
          JW(r, i) || r.push(i);
        return r.length === 1 ? r[0] : { types: r };
      }
      it.mergePropertyTypes = XW;
      function JW(t, e) {
        return t.some((r) => Wg(r, e));
      }
      function Wg(t, e) {
        return gd(t) && gd(e) ? Wg(t.elementType, e.elementType) : md(t) && md(e) ? Wg(t.referenceType, e.referenceType) : yd(t) && yd(e) ? t.value === e.value : false;
      }
      function vd(t) {
        return Bg(t) ? t.types.flatMap((e) => vd(e)) : [t];
      }
      it.flattenPlainType = vd;
    });
    var zS = f((_d) => {
      Object.defineProperty(_d, "__esModule", { value: true });
      _d.collectInferredTypes = void 0;
      var QW = rs(), Yg = Tn(), ft = we(), Vn = Ft(), GS = Td(), Kg = class {
        constructor(e, r) {
          this.context = e, this.root = r;
        }
        getTypes() {
          let e = { name: this.root.name, properties: this.root.properties, ruleCalls: this.root.ruleCalls, super: [] };
          return this.root.children.length === 0 ? [{ alt: e, next: [] }] : this.applyNext(this.root, { alt: e, next: this.root.children });
        }
        applyNext(e, r) {
          let n = this.splitType(r.alt, r.next.length), i = [];
          for (let o = 0; o < r.next.length; o++) {
            let a = n[o], s = r.next[o];
            s.actionWithAssignment && i.push({ alt: US(a), next: [] }), s.name !== void 0 && s.name !== a.name && (s.actionWithAssignment ? (a.properties = [], a.ruleCalls = [], a.super = [e.name], a.name = s.name) : (a.super = [a.name, ...a.ruleCalls], a.properties = [], a.ruleCalls = [], a.name = s.name)), a.properties.push(...s.properties), a.ruleCalls.push(...s.ruleCalls);
            let u = { alt: a, next: s.children };
            u.next.length === 0 ? (u.alt.super = u.alt.super.filter((c) => c !== u.alt.name), i.push(u)) : i.push(...this.applyNext(e, u));
          }
          return KS(i);
        }
        splitType(e, r) {
          let n = [];
          for (let i = 0; i < r; i++)
            n.push(US(e));
          return n;
        }
        getSuperTypes(e) {
          let r = /* @__PURE__ */ new Set();
          return this.collectSuperTypes(e, e, r), Array.from(r);
        }
        collectSuperTypes(e, r, n) {
          if (r.ruleCalls.length > 0) {
            for (let i of r.ruleCalls)
              n.add(i);
            return;
          }
          for (let i of r.parents)
            e.name === void 0 ? this.collectSuperTypes(i, i, n) : i.name !== void 0 && i.name !== e.name ? n.add(i.name) : this.collectSuperTypes(e, i, n);
          r.parents.length === 0 && r.name && n.add(r.name);
        }
        connect(e, r) {
          return r.parents.push(e), e.children.push(r), r;
        }
        merge(...e) {
          if (e.length === 1)
            return e[0];
          if (e.length === 0)
            throw new Error("No parts to merge");
          let r = ea();
          r.parents = e;
          for (let n of e)
            n.children.push(r);
          return r;
        }
        hasLeafNode(e) {
          return this.partHasLeafNode(e);
        }
        partHasLeafNode(e, r) {
          return e.children.some((n) => n !== r) ? true : e.name ? false : e.parents.some((n) => this.partHasLeafNode(n, e));
        }
      };
      function ZW(t) {
        return { name: t.name, children: [], parents: [], actionWithAssignment: t.actionWithAssignment, ruleCalls: [...t.ruleCalls], properties: t.properties.map(HS) };
      }
      function US(t) {
        return { name: t.name, super: t.super, ruleCalls: t.ruleCalls, properties: t.properties.map((e) => HS(e)) };
      }
      function HS(t) {
        return { name: t.name, optional: t.optional, type: t.type, astNodes: t.astNodes };
      }
      function eB(t, e, r) {
        let n = [], i = { fragments: /* @__PURE__ */ new Map() };
        for (let u of t)
          n.push(...WS(i, u));
        let o = aB(n), a = sB(o), s = uB(o, a, r);
        for (let u of e) {
          let c = tB(u);
          s.unions.push({ name: u.name, declared: false, type: c, subTypes: /* @__PURE__ */ new Set(), superTypes: /* @__PURE__ */ new Set(), dataType: u.dataType });
        }
        return s;
      }
      _d.collectInferredTypes = eB;
      function tB(t) {
        if (t.dataType && t.dataType !== "string")
          return { primitive: t.dataType };
        let e = false, r = () => (e = true, { primitive: "unknown" }), n = zg(t.definition, r);
        return e ? { primitive: "string" } : n;
      }
      function zg(t, e) {
        var r, n, i;
        if (t.cardinality)
          return e();
        if ((0, ft.isAlternatives)(t))
          return { types: t.elements.map((o) => zg(o, e)) };
        if ((0, ft.isGroup)(t) || (0, ft.isUnorderedGroup)(t))
          return t.elements.length !== 1 ? e() : zg(t.elements[0], e);
        if ((0, ft.isRuleCall)(t)) {
          let o = (r = t.rule) === null || r === void 0 ? void 0 : r.ref;
          return o ? (0, ft.isTerminalRule)(o) ? { primitive: (i = (n = o.type) === null || n === void 0 ? void 0 : n.name) !== null && i !== void 0 ? i : "string", regex: (0, Vn.terminalRegex)(o) } : { value: o.name } : e();
        } else if ((0, ft.isKeyword)(t))
          return { string: t.value };
        return e();
      }
      function WS(t, e) {
        let r = ea(e), n = new Kg(t, r);
        return e.definition && Vg(n, n.root, e.definition), n.getTypes();
      }
      function ea(t) {
        return { name: (0, ft.isParserRule)(t) || (0, ft.isAction)(t) ? (0, Vn.getTypeNameWithoutError)(t) : t, properties: [], ruleCalls: [], children: [], parents: [], actionWithAssignment: false };
      }
      function Vg(t, e, r) {
        let n = (0, Vn.isOptionalCardinality)(r.cardinality);
        if ((0, ft.isAlternatives)(r)) {
          let i = [];
          n && i.push(t.connect(e, ea()));
          for (let o of r.elements) {
            let a = t.connect(e, ea());
            i.push(Vg(t, a, o));
          }
          return t.merge(...i);
        } else if ((0, ft.isGroup)(r) || (0, ft.isUnorderedGroup)(r)) {
          let i = t.connect(e, ea()), o;
          n && (o = t.connect(e, ea()));
          for (let a of r.elements)
            i = Vg(t, i, a);
          return o ? t.merge(o, i) : i;
        } else {
          if ((0, ft.isAction)(r))
            return rB(t, e, r);
          (0, ft.isAssignment)(r) ? nB(e, r) : (0, ft.isRuleCall)(r) && iB(t, e, r);
        }
        return e;
      }
      function rB(t, e, r) {
        var n;
        if (!t.hasLeafNode(e)) {
          let o = ZW(e);
          t.connect(e, o);
        }
        let i = t.connect(e, ea(r));
        if (r.type) {
          let o = (n = r.type) === null || n === void 0 ? void 0 : n.ref;
          o && (0, QW.isNamed)(o) && (i.name = o.name);
        }
        return r.feature && r.operator && (i.actionWithAssignment = true, i.properties.push({ name: r.feature, optional: false, type: ta(r.operator === "+=", false, t.root.ruleCalls.length !== 0 ? t.root.ruleCalls : t.getSuperTypes(i)), astNodes: /* @__PURE__ */ new Set([r]) })), i;
      }
      function nB(t, e) {
        let r = { types: /* @__PURE__ */ new Set(), reference: false };
        BS(e.terminal, r);
        let n = ta(e.operator === "+=", r.reference, e.operator === "?=" ? ["boolean"] : Array.from(r.types));
        t.properties.push({ name: e.feature, optional: (0, Vn.isOptionalCardinality)(e.cardinality), type: n, astNodes: /* @__PURE__ */ new Set([e]) });
      }
      function BS(t, e) {
        if ((0, ft.isAlternatives)(t) || (0, ft.isUnorderedGroup)(t) || (0, ft.isGroup)(t))
          for (let r of t.elements)
            BS(r, e);
        else if ((0, ft.isKeyword)(t))
          e.types.add(`'${t.value}'`);
        else if ((0, ft.isRuleCall)(t) && t.rule.ref)
          e.types.add((0, Vn.getRuleType)(t.rule.ref));
        else if ((0, ft.isCrossReference)(t) && t.type.ref) {
          let r = (0, Vn.getTypeNameWithoutError)(t.type.ref);
          r && e.types.add(r), e.reference = true;
        }
      }
      function iB(t, e, r) {
        let n = r.rule.ref;
        if ((0, ft.isParserRule)(n) && n.fragment) {
          let i = oB(n, t.context);
          (0, Vn.isOptionalCardinality)(r.cardinality) ? e.properties.push(...i.map((o) => Object.assign(Object.assign({}, o), { optional: true }))) : e.properties.push(...i);
        } else
          (0, ft.isParserRule)(n) && e.ruleCalls.push((0, Vn.getRuleType)(n));
      }
      function oB(t, e) {
        let r = e.fragments.get(t);
        if (r)
          return r;
        let n = [];
        e.fragments.set(t, n);
        let i = (0, Vn.getTypeNameWithoutError)(t), o = WS(e, t).filter((a) => a.alt.name === i);
        return n.push(...o.flatMap((a) => a.alt.properties)), n;
      }
      function aB(t) {
        let e = /* @__PURE__ */ new Map(), r = [], n = KS(t).map((i) => i.alt);
        for (let i of n) {
          let o = { name: i.name, properties: i.properties, superTypes: new Set(i.super), subTypes: /* @__PURE__ */ new Set(), declared: false, abstract: false };
          e.set(o.name, o), i.ruleCalls.length > 0 && (r.push(i), i.ruleCalls.forEach((a) => {
            a !== o.name && o.subTypes.add(a);
          }));
        }
        for (let i of r)
          for (let o of i.ruleCalls) {
            let a = e.get(o);
            a && a.name !== i.name && a.superTypes.add(i.name);
          }
        return Array.from(e.values());
      }
      function KS(t) {
        let e = t.reduce((n, i) => n.add(i.alt.name, i), new Yg.MultiMap()), r = [];
        for (let [n, i] of e.entriesGroupedByKey()) {
          let o = [], a = /* @__PURE__ */ new Set(), s = { alt: { name: n, properties: o, ruleCalls: [], super: [] }, next: [] };
          for (let u of i) {
            let c = u.alt;
            s.alt.super.push(...c.super), s.next.push(...u.next);
            let l = c.properties;
            for (let d of l) {
              let h = o.find((y) => y.name === d.name);
              h ? (h.type = (0, GS.mergePropertyTypes)(h.type, d.type), d.astNodes.forEach((y) => h.astNodes.add(y))) : o.push(Object.assign({}, d));
            }
            c.ruleCalls.forEach((d) => a.add(d));
          }
          for (let u of i) {
            let c = u.alt;
            if (c.ruleCalls.length === 0)
              for (let l of o)
                c.properties.find((d) => d.name === l.name) || (l.optional = true);
          }
          s.alt.ruleCalls = Array.from(a), r.push(s);
        }
        return r;
      }
      function sB(t) {
        let e = new Map(t.map((i) => [i.name, i])), r = [], n = new Yg.MultiMap();
        for (let i of t)
          for (let o of i.superTypes)
            n.add(o, i.name);
        for (let [i, o] of n.entriesGroupedByKey())
          if (!e.has(i)) {
            let a = { declared: false, name: i, subTypes: /* @__PURE__ */ new Set(), superTypes: /* @__PURE__ */ new Set(), type: ta(false, false, o) };
            r.push(a);
          }
        return r;
      }
      function uB(t, e, r) {
        let n = new Yg.MultiMap();
        for (let s of t)
          for (let u of s.superTypes)
            n.add(u, s.name);
        let i = new Set(r.interfaces.map((s) => s.name)), o = { interfaces: [], unions: e }, a = new Map(e.map((s) => [s.name, s]));
        for (let s of t) {
          let u = new Set(n.get(s.name));
          if (s.properties.length === 0 && u.size > 0)
            if (i.has(s.name))
              s.abstract = true, o.interfaces.push(s);
            else {
              let c = ta(false, false, Array.from(u)), l = a.get(s.name);
              if (l)
                l.type = (0, GS.mergePropertyTypes)(l.type, c);
              else {
                let d = { name: s.name, declared: false, subTypes: u, superTypes: s.superTypes, type: c };
                o.unions.push(d), a.set(s.name, d);
              }
            }
          else
            o.interfaces.push(s);
        }
        for (let s of o.interfaces)
          s.superTypes = new Set([...s.superTypes].filter((u) => !a.has(u)));
        return o;
      }
      function ta(t, e, r) {
        if (t)
          return { elementType: ta(false, e, r) };
        if (e)
          return { referenceType: ta(false, false, r) };
        if (r.length === 1) {
          let n = r[0];
          return n.startsWith("'") ? { string: n.substring(1, n.length - 1) } : (0, Vn.isPrimitiveType)(n) ? { primitive: n } : { value: n };
        } else
          return { types: r.map((n) => ta(false, false, [n])) };
      }
    });
    var Jg = f((is) => {
      Object.defineProperty(is, "__esModule", { value: true });
      is.typeDefinitionToPropertyType = is.collectDeclaredTypes = void 0;
      var Rd = we(), Xg = Ft();
      function cB(t, e) {
        let r = { unions: [], interfaces: [] };
        for (let n of t) {
          let i = [];
          for (let s of n.attributes)
            i.push({ name: s.name, optional: s.isOptional, astNodes: /* @__PURE__ */ new Set([s]), type: ns(s.type) });
          let o = /* @__PURE__ */ new Set();
          for (let s of n.superTypes)
            s.ref && o.add((0, Xg.getTypeName)(s.ref));
          let a = { name: n.name, declared: true, abstract: false, properties: i, superTypes: o, subTypes: /* @__PURE__ */ new Set() };
          r.interfaces.push(a);
        }
        for (let n of e) {
          let i = { name: n.name, declared: true, type: ns(n.type), superTypes: /* @__PURE__ */ new Set(), subTypes: /* @__PURE__ */ new Set() };
          r.unions.push(i);
        }
        return r;
      }
      is.collectDeclaredTypes = cB;
      function ns(t) {
        if ((0, Rd.isArrayType)(t))
          return { elementType: ns(t.elementType) };
        if ((0, Rd.isReferenceType)(t))
          return { referenceType: ns(t.referenceType) };
        if ((0, Rd.isUnionType)(t))
          return { types: t.types.map(ns) };
        if ((0, Rd.isSimpleType)(t)) {
          let e;
          if (t.primitiveType)
            return e = t.primitiveType, { primitive: e };
          if (t.stringType)
            return e = t.stringType, { string: e };
          if (t.typeRef) {
            let r = t.typeRef.ref, n = (0, Xg.getTypeNameWithoutError)(r);
            if (n)
              return (0, Xg.isPrimitiveType)(n) ? { primitive: n } : { value: n };
          }
        }
        return { primitive: "unknown" };
      }
      is.typeDefinitionToPropertyType = ns;
    });
    var YS = f((os) => {
      Object.defineProperty(os, "__esModule", { value: true });
      os.collectAllAstResources = os.collectTypeResources = void 0;
      var lB = zS(), dB = Jg(), fB = be(), pB = we(), VS = Ft();
      function hB(t, e) {
        let r = Qg(t, e), n = (0, dB.collectDeclaredTypes)(r.interfaces, r.types), i = (0, lB.collectInferredTypes)(r.parserRules, r.datatypeRules, n);
        return { astResources: r, inferred: i, declared: n };
      }
      os.collectTypeResources = hB;
      function Qg(t, e, r = /* @__PURE__ */ new Set(), n = { parserRules: [], datatypeRules: [], interfaces: [], types: [] }) {
        Array.isArray(t) || (t = [t]);
        for (let i of t) {
          let o = (0, fB.getDocument)(i);
          if (!r.has(o.uri)) {
            r.add(o.uri);
            for (let a of i.rules)
              (0, pB.isParserRule)(a) && !a.fragment && ((0, VS.isDataTypeRule)(a) ? n.datatypeRules.push(a) : n.parserRules.push(a));
            if (i.interfaces.forEach((a) => n.interfaces.push(a)), i.types.forEach((a) => n.types.push(a)), e) {
              let a = i.imports.map((s) => (0, VS.resolveImport)(e, s)).filter((s) => s !== void 0);
              Qg(a, e, r, n);
            }
          }
        }
        return n;
      }
      os.collectAllAstResources = Qg;
    });
    var ty = f((Yn) => {
      Object.defineProperty(Yn, "__esModule", { value: true });
      Yn.specifyAstNodeProperties = Yn.createAstTypes = Yn.collectValidationAst = Yn.collectAst = void 0;
      var JS = es(), Ei = Za(), QS = YS(), mB = Td();
      function gB(t, e) {
        let { inferred: r, declared: n } = (0, QS.collectTypeResources)(t, e);
        return bd(r, n);
      }
      Yn.collectAst = gB;
      function yB(t, e) {
        let { inferred: r, declared: n, astResources: i } = (0, QS.collectTypeResources)(t, e);
        return { astResources: i, inferred: bd(n, r), declared: bd(r, n) };
      }
      Yn.collectValidationAst = yB;
      function bd(t, e) {
        var r, n;
        let i = { interfaces: (0, JS.sortInterfacesTopologically)(XS(...t.interfaces, ...(r = e == null ? void 0 : e.interfaces) !== null && r !== void 0 ? r : [])), unions: XS(...t.unions, ...(n = e == null ? void 0 : e.unions) !== null && n !== void 0 ? n : []) }, o = (0, mB.plainToTypes)(i);
        return ZS(o), o;
      }
      Yn.createAstTypes = bd;
      function XS(...t) {
        return Array.from(t.reduce((e, r) => (e.set(r.name, r), e), /* @__PURE__ */ new Map()).values()).sort((e, r) => e.name.localeCompare(r.name));
      }
      function ZS(t) {
        let e = TB(t), r = Array.from(e.values());
        _B(r), RB(r), vB(r);
      }
      Yn.specifyAstNodeProperties = ZS;
      function vB(t) {
        let e = /* @__PURE__ */ new Set(), r = (n) => {
          if (!e.has(n)) {
            e.add(n), n.typeNames.add(n.name);
            for (let i of n.subTypes)
              r(i), i.typeNames.forEach((o) => n.typeNames.add(o));
          }
        };
        t.forEach(r);
      }
      function TB({ interfaces: t, unions: e }) {
        let r = t.concat(e).reduce((i, o) => (i.set(o.name, o), i), /* @__PURE__ */ new Map()), n = /* @__PURE__ */ new Map();
        for (let i of e)
          n.set(i, Zg(i.type, /* @__PURE__ */ new Set()));
        for (let [i, o] of n)
          o && r.delete(i.name);
        return r;
      }
      function Zg(t, e) {
        if (e.has(t))
          return true;
        if (e.add(t), (0, Ei.isPropertyUnion)(t))
          return t.types.every((r) => Zg(r, e));
        if ((0, Ei.isValueType)(t)) {
          let r = t.value;
          return (0, Ei.isUnionType)(r) ? Zg(r.type, e) : false;
        } else
          return (0, Ei.isPrimitiveType)(t) || (0, Ei.isStringType)(t);
      }
      function _B(t) {
        for (let e of t)
          for (let r of e.superTypes)
            r.subTypes.add(e);
      }
      function RB(t) {
        let e = t.filter(Ei.isInterfaceType);
        for (let n of e) {
          let i = n.properties.flatMap((o) => ey(o.type, /* @__PURE__ */ new Set()));
          for (let o of i)
            o.containerTypes.add(n);
        }
        let r = bB(t);
        SB(r);
      }
      function ey(t, e) {
        return (0, Ei.isPropertyUnion)(t) ? t.types.flatMap((r) => ey(r, e)) : (0, Ei.isValueType)(t) ? e.has(t.value) ? [] : (e.add(t.value), [t.value]) : (0, Ei.isArrayType)(t) ? ey(t.elementType, e) : [];
      }
      function bB(t) {
        function e(a) {
          let s = [a];
          o.add(a);
          let u = [...i.subTypes.get(a.name), ...i.superTypes.get(a.name)];
          for (let c of u) {
            let l = r.get(c);
            l && !o.has(l) && s.push(...e(l));
          }
          return s;
        }
        let r = new Map(t.map((a) => [a.name, a])), n = [], i = (0, JS.collectTypeHierarchy)(t), o = /* @__PURE__ */ new Set();
        for (let a of t)
          o.has(a) || n.push(e(a));
        return n;
      }
      function SB(t) {
        for (let e of t) {
          let r = /* @__PURE__ */ new Set();
          e.forEach((n) => n.containerTypes.forEach((i) => r.add(i))), e.forEach((n) => n.containerTypes = r);
        }
      }
    });
    var ny = f((Sd) => {
      Object.defineProperty(Sd, "__esModule", { value: true });
      Sd.interpretAstReflection = void 0;
      var AB = Zt(), PB = Tn(), CB = we(), NB = ty(), ra = es();
      function EB(t, e) {
        let r;
        (0, CB.isGrammar)(t) ? r = (0, NB.collectAst)(t, e) : r = t;
        let n = r.interfaces.map((s) => s.name).concat(r.unions.filter((s) => (0, ra.isAstType)(s.type)).map((s) => s.name)), i = kB(r), o = wB(r), a = (0, ra.collectTypeHierarchy)((0, ra.mergeTypesAndInterfaces)(r)).superTypes;
        return new ry({ allTypes: n, references: i, metaData: o, superTypes: a });
      }
      Sd.interpretAstReflection = EB;
      var ry = class extends AB.AbstractAstReflection {
        constructor(e) {
          super(), this.allTypes = e.allTypes, this.references = e.references, this.metaData = e.metaData, this.superTypes = e.superTypes;
        }
        getAllTypes() {
          return this.allTypes;
        }
        getReferenceType(e) {
          let r = `${e.container.$type}:${e.property}`, n = this.references.get(r);
          if (n)
            return n;
          throw new Error("Could not find reference type for " + r);
        }
        getTypeMetaData(e) {
          var r;
          return (r = this.metaData.get(e)) !== null && r !== void 0 ? r : { name: e, mandatory: [] };
        }
        computeIsSubtype(e, r) {
          let n = this.superTypes.get(e);
          for (let i of n)
            if (this.isSubtype(i, r))
              return true;
          return false;
        }
      };
      function kB(t) {
        let e = new PB.MultiMap();
        for (let n of t.interfaces) {
          for (let i of n.properties)
            for (let o of (0, ra.findReferenceTypes)(i.type))
              e.add(n.name, [i.name, o]);
          for (let i of n.interfaceSuperTypes) {
            let o = e.get(i.name);
            e.addAll(n.name, o);
          }
        }
        let r = /* @__PURE__ */ new Map();
        for (let [n, [i, o]] of e)
          r.set(`${n}:${i}`, o);
        return r;
      }
      function wB(t) {
        let e = /* @__PURE__ */ new Map();
        for (let r of t.interfaces) {
          let n = r.superProperties, i = n.filter((a) => (0, ra.hasArrayType)(a.type)), o = n.filter((a) => !(0, ra.hasArrayType)(a.type) && (0, ra.hasBooleanType)(a.type));
          (i.length > 0 || o.length > 0) && e.set(r.name, { name: r.name, mandatory: OB(i, o) });
        }
        return e;
      }
      function OB(t, e) {
        let r = [], n = t.concat(e).sort((i, o) => i.name.localeCompare(o.name));
        for (let i of n) {
          let o = t.includes(i) ? "array" : "boolean";
          r.push({ name: i.name, type: o });
        }
        return r;
      }
    });
    var eA = f((Pd) => {
      Object.defineProperty(Pd, "__esModule", { value: true });
      Pd.LangiumGrammarGrammar = void 0;
      var DB = yt(), Ad, IB = () => Ad ?? (Ad = (0, DB.loadGrammarFromJson)(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "LangiumGrammar",
  "rules": [
    {
      "$type": "ParserRule",
      "name": "Grammar",
      "entry": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isDeclared",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "grammar"
                }
              },
              {
                "$type": "Assignment",
                "feature": "name",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@59"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "with"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "usedGrammars",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/rules@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "usedGrammars",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@0"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "definesHiddenTokens",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "hidden"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "hiddenTokens",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@11"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": ","
                          },
                          {
                            "$type": "Assignment",
                            "feature": "hiddenTokens",
                            "operator": "+=",
                            "terminal": {
                              "$type": "CrossReference",
                              "type": {
                                "$ref": "#/rules@11"
                              },
                              "terminal": {
                                "$type": "RuleCall",
                                "rule": {
                                  "$ref": "#/rules@59"
                                },
                                "arguments": []
                              },
                              "deprecatedSyntax": false
                            }
                          }
                        ],
                        "cardinality": "*"
                      }
                    ],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "imports",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@12"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "rules",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@11"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "interfaces",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@1"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "types",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@10"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          }
        ]
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Interface",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "extends"
              },
              {
                "$type": "Assignment",
                "feature": "superTypes",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@0"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "superTypes",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SchemaType",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@3"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "}"
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "isOptional",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "?"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeDefinition",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@5"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnionType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@6"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "UnionType"
                },
                "feature": "types",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "types",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@6"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArrayType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@7"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ArrayType"
                },
                "feature": "elementType",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "["
              },
              {
                "$type": "Keyword",
                "value": "]"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@8"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ReferenceType"
                }
              },
              {
                "$type": "Keyword",
                "value": "@"
              },
              {
                "$type": "Assignment",
                "feature": "referenceType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@8"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SimpleType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@4"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "SimpleType"
                }
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "typeRef",
                    "operator": "=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "primitiveType",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@9"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "stringType",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@60"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimitiveType",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "string"
          },
          {
            "$type": "Keyword",
            "value": "number"
          },
          {
            "$type": "Keyword",
            "value": "boolean"
          },
          {
            "$type": "Keyword",
            "value": "Date"
          },
          {
            "$type": "Keyword",
            "value": "bigint"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Type",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "type"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractRule",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@13"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GrammarImport",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "Assignment",
            "feature": "path",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@60"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParserRule",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "entry",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "entry"
                }
              },
              {
                "$type": "Assignment",
                "feature": "fragment",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "fragment"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@15"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "wildcard",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "returns"
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "returnType",
                        "operator": "=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/types@0"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "dataType",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@9"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "inferredType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@14"
                  },
                  "arguments": [
                    {
                      "$type": "NamedArgument",
                      "value": {
                        "$type": "LiteralCondition",
                        "true": false
                      },
                      "calledByName": false
                    }
                  ]
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "definesHiddenTokens",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "hidden"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "hiddenTokens",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/rules@11"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "hiddenTokens",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@11"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "definition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InferredType",
      "parameters": [
        {
          "$type": "Parameter",
          "name": "imperative"
        }
      ],
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "guardCondition": {
                  "$type": "ParameterReference",
                  "parameter": {
                    "$ref": "#/rules@14/parameters@0"
                  }
                },
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "infer"
                  }
                ]
              },
              {
                "$type": "Group",
                "guardCondition": {
                  "$type": "Negation",
                  "value": {
                    "$type": "ParameterReference",
                    "parameter": {
                      "$ref": "#/rules@14/parameters@0"
                    }
                  }
                },
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "infers"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RuleNameAndParams",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "parameters",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@16"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "parameters",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@16"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Parameter",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@59"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Alternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@18"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Alternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@18"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConditionalBranch",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@19"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Group"
                }
              },
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "guardCondition",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@29"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ">"
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@21"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnorderedGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@20"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "UnorderedGroup"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "&"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@20"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Group",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@21"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Group"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@21"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@22"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@23"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractTokenWithCardinality",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@37"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@24"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "cardinality",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?"
                },
                {
                  "$type": "Keyword",
                  "value": "*"
                },
                {
                  "$type": "Keyword",
                  "value": "+"
                }
              ]
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Action",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Action"
            }
          },
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@0"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Assignment",
                "feature": "inferredType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@14"
                  },
                  "arguments": [
                    {
                      "$type": "NamedArgument",
                      "value": {
                        "$type": "LiteralCondition",
                        "true": true
                      },
                      "calledByName": false
                    }
                  ]
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "feature",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@58"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "="
                    },
                    {
                      "$type": "Keyword",
                      "value": "+="
                    }
                  ]
                }
              },
              {
                "$type": "Keyword",
                "value": "current"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "}"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@43"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@35"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@36"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@44"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Keyword",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@60"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RuleCall",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@11"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "arguments",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@27"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "arguments",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@27"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgument",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "parameter",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@16"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Assignment",
                "feature": "calledByName",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "="
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@29"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralCondition",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "true",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "true"
            }
          },
          {
            "$type": "Keyword",
            "value": "false"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Disjunction",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@30"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Disjunction"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "|"
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@30"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Conjunction",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@31"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Conjunction"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "&"
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@31"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Negation",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Negation"
                }
              },
              {
                "$type": "Keyword",
                "value": "!"
              },
              {
                "$type": "Assignment",
                "feature": "value",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@31"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Atom",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@34"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@33"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@28"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedCondition",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@29"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParameterReference",
      "definition": {
        "$type": "Assignment",
        "feature": "parameter",
        "operator": "=",
        "terminal": {
          "$type": "CrossReference",
          "type": {
            "$ref": "#/rules@16"
          },
          "terminal": {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          },
          "deprecatedSyntax": false
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedKeyword",
      "inferredType": {
        "$type": "InferredType",
        "name": "Keyword"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@60"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedRuleCall",
      "inferredType": {
        "$type": "InferredType",
        "name": "RuleCall"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@11"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "arguments",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@27"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "arguments",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@27"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Assignment",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Assignment"
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "feature",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "+="
                },
                {
                  "$type": "Keyword",
                  "value": "="
                },
                {
                  "$type": "Keyword",
                  "value": "?="
                }
              ]
            }
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@38"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignableTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@39"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@41"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedAssignableElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@40"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignableAlternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@38"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Alternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@38"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossReference",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "CrossReference"
            }
          },
          {
            "$type": "Keyword",
            "value": "["
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/types@0"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "deprecatedSyntax",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "|"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ":"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "terminal",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "]"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossReferenceableTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@17"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "Group"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnType",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "Alternatives",
          "elements": [
            {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@9"
              },
              "arguments": []
            },
            {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          ]
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalRule",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "hidden",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "hidden"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "terminal"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "fragment",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "fragment"
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@59"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@59"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "returns"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "type",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@45"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "definition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@47"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalAlternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@48"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TerminalAlternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Keyword",
                "value": "|"
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@48"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@49"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TerminalGroup"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@49"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "cardinality",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?"
                },
                {
                  "$type": "Keyword",
                  "value": "*"
                },
                {
                  "$type": "Keyword",
                  "value": "+"
                }
              ]
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalTokenElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@57"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@52"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@51"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@53"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@54"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@55"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@56"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedTerminalElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "lookahead",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?="
                },
                {
                  "$type": "Keyword",
                  "value": "?!"
                }
              ]
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalRuleCall",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "TerminalRuleCall"
            }
          },
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@46"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NegatedToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "NegatedToken"
            }
          },
          {
            "$type": "Keyword",
            "value": "!"
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@50"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UntilToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "UntilToken"
            }
          },
          {
            "$type": "Keyword",
            "value": "->"
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@50"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RegexToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "RegexToken"
            }
          },
          {
            "$type": "Assignment",
            "feature": "regex",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@61"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Wildcard",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Wildcard"
            }
          },
          {
            "$type": "Keyword",
            "value": "."
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CharacterRange",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "CharacterRange"
            }
          },
          {
            "$type": "Assignment",
            "feature": "left",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ".."
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@25"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureName",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "current"
          },
          {
            "$type": "Keyword",
            "value": "entry"
          },
          {
            "$type": "Keyword",
            "value": "extends"
          },
          {
            "$type": "Keyword",
            "value": "false"
          },
          {
            "$type": "Keyword",
            "value": "fragment"
          },
          {
            "$type": "Keyword",
            "value": "grammar"
          },
          {
            "$type": "Keyword",
            "value": "hidden"
          },
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "Keyword",
            "value": "returns"
          },
          {
            "$type": "Keyword",
            "value": "terminal"
          },
          {
            "$type": "Keyword",
            "value": "true"
          },
          {
            "$type": "Keyword",
            "value": "type"
          },
          {
            "$type": "Keyword",
            "value": "infer"
          },
          {
            "$type": "Keyword",
            "value": "infers"
          },
          {
            "$type": "Keyword",
            "value": "with"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@9"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\^?[_a-zA-Z][\\\\w_]*"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\"(\\\\\\\\.|[^\\"\\\\\\\\])*\\"|'(\\\\\\\\.|[^'\\\\\\\\])*'"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "RegexLiteral",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/(?![*+?])(?:[^\\\\r\\\\n\\\\[/\\\\\\\\]|\\\\\\\\.|\\\\[(?:[^\\\\r\\\\n\\\\]\\\\\\\\]|\\\\\\\\.)*\\\\])+\\\\/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\s+"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/[^\\\\n\\\\r]*"
      },
      "fragment": false
    }
  ],
  "types": [
    {
      "$type": "Type",
      "name": "AbstractType",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@1"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@10"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@23/definition/elements@0"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@13"
            }
          }
        ]
      }
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "imports": [],
  "interfaces": [],
  "usedGrammars": []
}`));
      Pd.LangiumGrammarGrammar = IB;
    });
    var tA = f((Hr) => {
      Object.defineProperty(Hr, "__esModule", { value: true });
      Hr.LangiumGrammarGeneratedModule = Hr.LangiumGrammarGeneratedSharedModule = Hr.LangiumGrammarParserConfig = Hr.LangiumGrammarLanguageMetaData = void 0;
      var xB = we(), qB = eA();
      Hr.LangiumGrammarLanguageMetaData = { languageId: "langium", fileExtensions: [".langium"], caseInsensitive: false };
      Hr.LangiumGrammarParserConfig = { maxLookahead: 3 };
      Hr.LangiumGrammarGeneratedSharedModule = { AstReflection: () => new xB.LangiumGrammarAstReflection() };
      Hr.LangiumGrammarGeneratedModule = { Grammar: () => (0, qB.LangiumGrammarGrammar)(), LanguageMetaData: () => Hr.LangiumGrammarLanguageMetaData, parser: { ParserConfig: () => Hr.LangiumGrammarParserConfig } };
    });
    var vr = f((Pt) => {
      Object.defineProperty(Pt, "__esModule", { value: true });
      Pt.Deferred = Pt.MutexLock = Pt.interruptAndCheck = Pt.isOperationCancelled = Pt.OperationCancelled = Pt.setInterruptionPeriod = Pt.startCancelableOperation = Pt.delayNextTick = void 0;
      var Cd = Fn();
      function rA() {
        return new Promise((t) => {
          typeof setImmediate > "u" ? setTimeout(t, 0) : setImmediate(t);
        });
      }
      Pt.delayNextTick = rA;
      var iy = 0, nA = 10;
      function LB() {
        return iy = Date.now(), new Cd.CancellationTokenSource();
      }
      Pt.startCancelableOperation = LB;
      function MB(t) {
        nA = t;
      }
      Pt.setInterruptionPeriod = MB;
      Pt.OperationCancelled = Symbol("OperationCancelled");
      function iA(t) {
        return t === Pt.OperationCancelled;
      }
      Pt.isOperationCancelled = iA;
      async function $B(t) {
        if (t === Cd.CancellationToken.None)
          return;
        let e = Date.now();
        if (e - iy >= nA && (iy = e, await rA()), t.isCancellationRequested)
          throw Pt.OperationCancelled;
      }
      Pt.interruptAndCheck = $B;
      var oy = class {
        constructor() {
          this.previousAction = Promise.resolve(), this.previousTokenSource = new Cd.CancellationTokenSource();
        }
        lock(e) {
          this.cancel();
          let r = new Cd.CancellationTokenSource();
          return this.previousTokenSource = r, this.previousAction = this.previousAction.then(() => e(r.token).catch((n) => {
            iA(n) || console.error("Error: ", n);
          }));
        }
        cancel() {
          this.previousTokenSource.cancel();
        }
      };
      Pt.MutexLock = oy;
      var ay = class {
        constructor() {
          this.promise = new Promise((e, r) => {
            this.resolve = (n) => (e(n), this), this.reject = (n) => (r(n), this);
          });
        }
      };
      Pt.Deferred = ay;
    });
    var Ed = f((Nd) => {
      Object.defineProperty(Nd, "__esModule", { value: true });
      Nd.DefaultScopeComputation = void 0;
      var sy = Fn(), oA = be(), FB = Tn(), aA = vr(), uy = class {
        constructor(e) {
          this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider;
        }
        async computeExports(e, r = sy.CancellationToken.None) {
          return this.computeExportsForNode(e.parseResult.value, e, void 0, r);
        }
        async computeExportsForNode(e, r, n = oA.streamContents, i = sy.CancellationToken.None) {
          let o = [];
          this.exportNode(e, o, r);
          for (let a of n(e))
            await (0, aA.interruptAndCheck)(i), this.exportNode(a, o, r);
          return o;
        }
        exportNode(e, r, n) {
          let i = this.nameProvider.getName(e);
          i && r.push(this.descriptions.createDescription(e, i, n));
        }
        async computeLocalScopes(e, r = sy.CancellationToken.None) {
          let n = e.parseResult.value, i = new FB.MultiMap();
          for (let o of (0, oA.streamAllContents)(n))
            await (0, aA.interruptAndCheck)(r), this.processNode(o, e, i);
          return i;
        }
        processNode(e, r, n) {
          let i = e.$container;
          if (i) {
            let o = this.nameProvider.getName(e);
            o && n.add(i, this.descriptions.createDescription(e, o, r));
          }
        }
      };
      Nd.DefaultScopeComputation = uy;
    });
    var wd = f((uo) => {
      Object.defineProperty(uo, "__esModule", { value: true });
      uo.DefaultScopeProvider = uo.EMPTY_SCOPE = uo.StreamScope = void 0;
      var jB = be(), kd = $t(), as = class {
        constructor(e, r, n) {
          this.elements = e, this.outerScope = r, this.caseInsensitive = n == null ? void 0 : n.caseInsensitive;
        }
        getAllElements() {
          return this.outerScope ? this.elements.concat(this.outerScope.getAllElements()) : this.elements;
        }
        getElement(e) {
          let r = this.caseInsensitive ? this.elements.find((n) => n.name.toLowerCase() === e.toLowerCase()) : this.elements.find((n) => n.name === e);
          if (r)
            return r;
          if (this.outerScope)
            return this.outerScope.getElement(e);
        }
      };
      uo.StreamScope = as;
      uo.EMPTY_SCOPE = { getElement() {
      }, getAllElements() {
        return kd.EMPTY_STREAM;
      } };
      var cy = class {
        constructor(e) {
          this.reflection = e.shared.AstReflection, this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider, this.indexManager = e.shared.workspace.IndexManager;
        }
        getScope(e) {
          let r = [], n = this.reflection.getReferenceType(e), i = (0, jB.getDocument)(e.container).precomputedScopes;
          if (i) {
            let a = e.container;
            do {
              let s = i.get(a);
              s.length > 0 && r.push((0, kd.stream)(s).filter((u) => this.reflection.isSubtype(u.type, n))), a = a.$container;
            } while (a);
          }
          let o = this.getGlobalScope(n, e);
          for (let a = r.length - 1; a >= 0; a--)
            o = this.createScope(r[a], o);
          return o;
        }
        createScope(e, r, n) {
          return new as((0, kd.stream)(e), r, n);
        }
        createScopeForNodes(e, r, n) {
          let i = (0, kd.stream)(e).map((o) => {
            let a = this.nameProvider.getName(o);
            if (a)
              return this.descriptions.createDescription(o, a);
          }).nonNullable();
          return new as(i, r, n);
        }
        getGlobalScope(e, r) {
          return new as(this.indexManager.allElements(e));
        }
      };
      uo.DefaultScopeProvider = cy;
    });
    var ki = f((ss) => {
      Object.defineProperty(ss, "__esModule", { value: true });
      ss.relativeURI = ss.equalURI = void 0;
      function UB(t, e) {
        return (t == null ? void 0 : t.toString()) === (e == null ? void 0 : e.toString());
      }
      ss.equalURI = UB;
      function GB(t, e) {
        let r = t.path, n = e.path, i = r.split("/").filter((c) => c.length > 0), o = n.split("/").filter((c) => c.length > 0), a = 0;
        for (; a < i.length && i[a] === o[a]; a++)
          ;
        let s = "../".repeat(i.length - a), u = o.slice(a).join("/");
        return s + u;
      }
      ss.relativeURI = GB;
    });
    var cA = f((cs) => {
      Object.defineProperty(cs, "__esModule", { value: true });
      cs.LangiumGrammarScopeComputation = cs.LangiumGrammarScopeProvider = void 0;
      var HB = Ed(), ly = wd(), us = be(), sA = Le(), uA = $t(), WB = ki(), Wr = we(), dy = Ft(), fy = class extends ly.DefaultScopeProvider {
        constructor(e) {
          super(e);
        }
        getScope(e) {
          let r = this.reflection.getReferenceType(e);
          return r === Wr.AbstractType ? this.getTypeScope(r, e) : super.getScope(e);
        }
        getTypeScope(e, r) {
          let n, i = (0, us.getDocument)(r.container).precomputedScopes, o = (0, us.findRootNode)(r.container);
          if (i && o) {
            let s = i.get(o);
            s.length > 0 && (n = (0, uA.stream)(s).filter((u) => u.type === Wr.Interface || u.type === Wr.Type));
          }
          let a = this.getGlobalScope(e, r);
          return n ? this.createScope(n, a) : a;
        }
        getGlobalScope(e, r) {
          let n = (0, us.getContainerOfType)(r.container, Wr.isGrammar);
          if (!n)
            return ly.EMPTY_SCOPE;
          let i = (0, uA.stream)(n.imports).map(dy.resolveImportUri).nonNullable(), o = this.indexManager.allElements(e).filter((a) => i.some((s) => (0, WB.equalURI)(a.documentUri, s)));
          return e === Wr.AbstractType && (o = o.filter((a) => a.type === Wr.Interface || a.type === Wr.Type)), new ly.StreamScope(o);
        }
      };
      cs.LangiumGrammarScopeProvider = fy;
      var py = class extends HB.DefaultScopeComputation {
        constructor(e) {
          super(e), this.astNodeLocator = e.workspace.AstNodeLocator;
        }
        exportNode(e, r, n) {
          var i;
          if (super.exportNode(e, r, n), (0, Wr.isParserRule)(e)) {
            if (!e.returnType && !e.dataType) {
              let o = (i = e.inferredType) !== null && i !== void 0 ? i : e;
              r.push(this.createInterfaceDescription(o, o.name, n));
            }
            (0, us.streamAllContents)(e).forEach((o) => {
              if ((0, Wr.isAction)(o) && o.inferredType) {
                let a = (0, dy.getActionType)(o);
                a && r.push(this.createInterfaceDescription(o, a, n));
              }
            });
          }
        }
        processNode(e, r, n) {
          (0, Wr.isReturnType)(e) || (this.processTypeNode(e, r, n), this.processActionNode(e, r, n), super.processNode(e, r, n));
        }
        processTypeNode(e, r, n) {
          var i;
          let o = e.$container;
          if (o && (0, Wr.isParserRule)(e) && !e.returnType && !e.dataType) {
            let a = (i = e.inferredType) !== null && i !== void 0 ? i : e;
            n.add(o, this.createInterfaceDescription(a, a.name, r));
          }
        }
        processActionNode(e, r, n) {
          let i = (0, us.findRootNode)(e);
          if (i && (0, Wr.isAction)(e) && e.inferredType) {
            let o = (0, dy.getActionType)(e);
            o && n.add(i, this.createInterfaceDescription(e, o, r));
          }
        }
        createInterfaceDescription(e, r, n = (0, us.getDocument)(e)) {
          var i;
          let o = (i = this.nameProvider.getNameNode(e)) !== null && i !== void 0 ? i : e.$cstNode;
          return { node: e, name: r, nameSegment: (0, sA.toDocumentSegment)(o), selectionSegment: (0, sA.toDocumentSegment)(e.$cstNode), type: "Interface", documentUri: n.uri, path: this.astNodeLocator.getAstNodePath(e) };
        }
      };
      cs.LangiumGrammarScopeComputation = py;
    });
    var _y = f((lr) => {
      var BB = lr && lr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), KB = lr && lr.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), zB = lr && lr.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && BB(e, t, r);
        return KB(e, t), e;
      };
      Object.defineProperty(lr, "__esModule", { value: true });
      lr.LangiumGrammarValidator = lr.IssueCodes = lr.registerValidationChecks = void 0;
      var hy = $a(), co = be(), lo = Tn(), my = Le(), fo = yt(), gy = $t(), Pe = zB(we()), yy = we(), It = Ft(), VB = Jg(), vy = Td();
      function YB(t) {
        let e = t.validation.ValidationRegistry, r = t.validation.LangiumGrammarValidator, n = { Action: [r.checkAssignmentReservedName], AbstractRule: r.checkRuleName, Assignment: [r.checkAssignmentWithFeatureName, r.checkAssignmentToFragmentRule, r.checkAssignmentTypes, r.checkAssignmentReservedName], ParserRule: [r.checkParserRuleDataType, r.checkRuleParametersUsed, r.checkParserRuleReservedName], TerminalRule: [r.checkTerminalRuleReturnType, r.checkHiddenTerminalRule, r.checkEmptyTerminalRule], InferredType: r.checkTypeReservedName, Keyword: r.checkKeyword, UnorderedGroup: r.checkUnorderedGroup, Grammar: [r.checkGrammarName, r.checkEntryGrammarRule, r.checkUniqueRuleName, r.checkUniqueTypeName, r.checkUniqueImportedRules, r.checkDuplicateImportedGrammar, r.checkGrammarHiddenTokens, r.checkGrammarForUnusedRules, r.checkGrammarTypeInfer, r.checkClashingTerminalNames], GrammarImport: r.checkPackageImport, CharacterRange: r.checkInvalidCharacterRange, Interface: [r.checkTypeReservedName, r.checkInterfacePropertyTypes], Type: [r.checkTypeReservedName], TypeAttribute: r.checkTypeReservedName, RuleCall: [r.checkUsedHiddenTerminalRule, r.checkUsedFragmentTerminalRule, r.checkRuleCallParameters], TerminalRuleCall: r.checkUsedHiddenTerminalRule, CrossReference: [r.checkCrossReferenceSyntax, r.checkCrossRefNameAssignment, r.checkCrossRefTerminalType, r.checkCrossRefType, r.checkCrossReferenceToTypeUnion], SimpleType: r.checkFragmentsInTypes, ReferenceType: r.checkReferenceTypeUnion };
        e.register(n, r);
      }
      lr.registerValidationChecks = YB;
      var cr;
      (function(t) {
        t.GrammarNameUppercase = "grammar-name-uppercase", t.RuleNameUppercase = "rule-name-uppercase", t.HiddenGrammarTokens = "hidden-grammar-tokens", t.UseRegexTokens = "use-regex-tokens", t.EntryRuleTokenSyntax = "entry-rule-token-syntax", t.CrossRefTokenSyntax = "cross-ref-token-syntax", t.UnnecessaryFileExtension = "unnecessary-file-extension", t.InvalidReturns = "invalid-returns", t.InvalidInfers = "invalid-infers", t.MissingInfer = "missing-infer", t.MissingReturns = "missing-returns", t.SuperfluousInfer = "superfluous-infer", t.OptionalUnorderedGroup = "optional-unordered-group";
      })(cr = lr.IssueCodes || (lr.IssueCodes = {}));
      var Ty = class {
        constructor(e) {
          this.references = e.references.References, this.documents = e.shared.workspace.LangiumDocuments;
        }
        checkGrammarName(e, r) {
          if (e.name) {
            let n = e.name.substring(0, 1);
            n.toUpperCase() !== n && r("warning", "Grammar name should start with an upper case letter.", { node: e, property: "name", code: cr.GrammarNameUppercase });
          }
        }
        checkEntryGrammarRule(e, r) {
          if (e.isDeclared && !e.name)
            return;
          let n = e.rules.filter((i) => Pe.isParserRule(i) && i.entry);
          if (e.isDeclared && n.length === 0) {
            let i = e.rules.find((o) => Pe.isParserRule(o) && !(0, It.isDataTypeRule)(o));
            i ? r("error", "The grammar is missing an entry parser rule. This rule can be an entry one.", { node: i, property: "name", code: cr.EntryRuleTokenSyntax }) : r("error", "This grammar is missing an entry parser rule.", { node: e, property: "name" });
          } else
            !e.isDeclared && n.length >= 1 ? n.forEach((i) => r("error", "Cannot declare entry rules for unnamed grammars.", { node: i, property: "name" })) : n.length > 1 ? n.forEach((i) => r("error", "The entry rule has to be unique.", { node: i, property: "name" })) : n.length === 1 && (0, It.isDataTypeRule)(n[0]) && r("error", "The entry rule cannot be a data type rule.", { node: n[0], property: "name" });
        }
        checkUniqueRuleName(e, r) {
          let n = (i) => (0, gy.stream)(i.rules).filter((o) => !ic(o));
          this.checkUniqueName(e, r, n, "rule");
        }
        checkUniqueTypeName(e, r) {
          let n = (i) => (0, gy.stream)(i.types).concat(i.interfaces);
          this.checkUniqueName(e, r, n, "type");
        }
        checkUniqueName(e, r, n, i) {
          let o = new lo.MultiMap();
          n(e).forEach((u) => o.add(u.name, u));
          for (let [, u] of o.entriesGroupedByKey())
            u.length > 1 && u.forEach((c) => {
              r("error", `A ${i}'s name has to be unique.`, { node: c, property: "name" });
            });
          let a = /* @__PURE__ */ new Set(), s = (0, It.resolveTransitiveImports)(this.documents, e);
          for (let u of s)
            n(u).forEach((c) => a.add(c.name));
          for (let u of o.keys())
            a.has(u) && o.get(u).forEach((l) => {
              r("error", `A ${i} with the name '${l.name}' already exists in an imported grammar.`, { node: l, property: "name" });
            });
        }
        checkDuplicateImportedGrammar(e, r) {
          let n = new lo.MultiMap();
          for (let i of e.imports) {
            let o = (0, It.resolveImport)(this.documents, i);
            o && n.add(o, i);
          }
          for (let [, i] of n.entriesGroupedByKey())
            i.length > 1 && i.forEach((o, a) => {
              a > 0 && r("warning", "The grammar is already being directly imported.", { node: o, tags: [hy.DiagnosticTag.Unnecessary] });
            });
        }
        checkUniqueImportedRules(e, r) {
          let n = /* @__PURE__ */ new Map();
          for (let o of e.imports) {
            let a = (0, It.resolveTransitiveImports)(this.documents, o);
            n.set(o, a);
          }
          let i = new lo.MultiMap();
          for (let o of e.imports) {
            let a = n.get(o);
            for (let s of e.imports) {
              if (o === s)
                continue;
              let u = n.get(s), c = this.getDuplicateExportedRules(a, u);
              for (let l of c)
                i.add(o, l);
            }
          }
          for (let o of e.imports) {
            let a = i.get(o);
            a.length > 0 && r("error", "Some rules exported by this grammar are also included in other imports: " + (0, gy.stream)(a).distinct().join(", "), { node: o, property: "path" });
          }
        }
        getDuplicateExportedRules(e, r) {
          let i = e.filter((s) => !r.includes(s)).flatMap((s) => s.rules), o = r.flatMap((s) => s.rules), a = /* @__PURE__ */ new Set();
          for (let s of i) {
            let u = s.name;
            for (let c of o) {
              let l = c.name;
              u === l && a.add(c.name);
            }
          }
          return a;
        }
        checkGrammarTypeInfer(e, r) {
          var n, i, o;
          let a = /* @__PURE__ */ new Set();
          for (let u of e.types)
            a.add(u.name);
          for (let u of e.interfaces)
            a.add(u.name);
          (0, It.resolveTransitiveImports)(this.documents, e).forEach((u) => {
            u.types.forEach((c) => a.add(c.name)), u.interfaces.forEach((c) => a.add(c.name));
          });
          for (let u of e.rules.filter(Pe.isParserRule)) {
            if (ic(u))
              continue;
            let c = (0, It.isDataTypeRule)(u), l = !u.returnType && !u.dataType, d = (0, It.getTypeNameWithoutError)(u);
            if (!c && d && a.has(d) === l) {
              if ((l || ((n = u.returnType) === null || n === void 0 ? void 0 : n.ref) !== void 0) && u.inferredType === void 0)
                r("error", s(d, l), { node: u, property: "name", code: cr.MissingReturns });
              else if (l || ((i = u.returnType) === null || i === void 0 ? void 0 : i.ref) !== void 0) {
                let h = (0, fo.findNodeForKeyword)(u.inferredType.$cstNode, "infers");
                r("error", s(d, l), { node: u.inferredType, property: "name", code: cr.InvalidInfers, data: (0, my.toDocumentSegment)(h) });
              }
            } else if (c && l) {
              let h = (0, fo.findNodeForKeyword)(u.$cstNode, "infer");
              r("error", "Data type rules cannot infer a type.", { node: u, property: "inferredType", code: cr.InvalidInfers, data: (0, my.toDocumentSegment)(h) });
            }
          }
          for (let u of (0, co.streamAllContents)(e).filter(Pe.isAction)) {
            let c = this.getActionType(u);
            if (c) {
              let l = Boolean(u.inferredType), d = (0, It.getTypeNameWithoutError)(u);
              if (u.type && d && a.has(d) === l) {
                let h = l ? (0, fo.findNodeForKeyword)(u.$cstNode, "infer") : (0, fo.findNodeForKeyword)(u.$cstNode, "{");
                r("error", s(d, l), { node: u, property: "type", code: l ? cr.SuperfluousInfer : cr.MissingInfer, data: (0, my.toDocumentSegment)(h) });
              } else if (c && d && a.has(d) && l && u.$cstNode) {
                let h = (0, fo.findNodeForProperty)((o = u.inferredType) === null || o === void 0 ? void 0 : o.$cstNode, "name"), y = (0, fo.findNodeForKeyword)(u.$cstNode, "{");
                h && y && r("error", `${d} is a declared type and cannot be redefined.`, { node: u, property: "type", code: cr.SuperfluousInfer, data: { start: y.range.end, end: h.range.start } });
              }
            }
          }
          function s(u, c) {
            return c ? `The type '${u}' is already explicitly declared and cannot be inferred.` : `The type '${u}' is not explicitly declared and must be inferred.`;
          }
        }
        getActionType(e) {
          var r;
          if (e.type)
            return (r = e.type) === null || r === void 0 ? void 0 : r.ref;
          if (e.inferredType)
            return e.inferredType;
        }
        checkGrammarHiddenTokens(e, r) {
          e.definesHiddenTokens && r("error", "Hidden terminals are declared at the terminal definition.", { node: e, property: "definesHiddenTokens", code: cr.HiddenGrammarTokens });
        }
        checkHiddenTerminalRule(e, r) {
          e.hidden && e.fragment && r("error", "Cannot use terminal fragments as hidden tokens.", { node: e, property: "hidden" });
        }
        checkEmptyTerminalRule(e, r) {
          try {
            let n = (0, It.terminalRegex)(e);
            new RegExp(n).test("") && r("error", "This terminal could match an empty string.", { node: e, property: "name" });
          } catch {
          }
        }
        checkUsedHiddenTerminalRule(e, r) {
          let n = (0, co.getContainerOfType)(e, (i) => Pe.isTerminalRule(i) || Pe.isParserRule(i));
          if (n) {
            if ("hidden" in n && n.hidden)
              return;
            let i = e.rule.ref;
            Pe.isTerminalRule(i) && i.hidden && r("error", "Cannot use hidden terminal in non-hidden rule", { node: e, property: "rule" });
          }
        }
        checkUsedFragmentTerminalRule(e, r) {
          let n = e.rule.ref;
          Pe.isTerminalRule(n) && n.fragment && (0, co.getContainerOfType)(e, Pe.isParserRule) && r("error", "Cannot use terminal fragments as part of parser rules.", { node: e, property: "rule" });
        }
        checkCrossReferenceSyntax(e, r) {
          e.deprecatedSyntax && r("error", "'|' is deprecated. Please, use ':' instead.", { node: e, property: "deprecatedSyntax", code: cr.CrossRefTokenSyntax });
        }
        checkPackageImport(e, r) {
          (0, It.resolveImport)(this.documents, e) === void 0 ? r("error", "Import cannot be resolved.", { node: e, property: "path" }) : e.path.endsWith(".langium") && r("warning", "Imports do not need file extensions.", { node: e, property: "path", code: cr.UnnecessaryFileExtension });
        }
        checkInvalidCharacterRange(e, r) {
          if (e.right) {
            let n = "Character ranges cannot use more than one character", i = false;
            e.left.value.length > 1 && (i = true, r("error", n, { node: e.left, property: "value" })), e.right.value.length > 1 && (i = true, r("error", n, { node: e.right, property: "value" })), i || r("hint", "Consider using regex instead of character ranges", { node: e, code: cr.UseRegexTokens });
          }
        }
        checkGrammarForUnusedRules(e, r) {
          let n = (0, fo.getAllReachableRules)(e, true);
          for (let i of e.rules)
            Pe.isTerminalRule(i) && i.hidden || ic(i) || n.has(i) || r("hint", "This rule is declared but never referenced.", { node: i, property: "name", tags: [hy.DiagnosticTag.Unnecessary] });
        }
        checkClashingTerminalNames(e, r) {
          let n = new lo.MultiMap(), i = /* @__PURE__ */ new Set();
          for (let c of e.rules)
            Pe.isTerminalRule(c) && c.name && n.add(c.name, c), Pe.isParserRule(c) && (0, co.streamAllContents)(c).filter(Pe.isKeyword).forEach((d) => i.add(d.value));
          let o = new lo.MultiMap(), a = new lo.MultiMap();
          for (let c of e.imports) {
            let l = (0, It.resolveTransitiveImports)(this.documents, c);
            for (let d of l)
              for (let h of d.rules)
                Pe.isTerminalRule(h) && h.name ? o.add(h.name, c) : Pe.isParserRule(h) && h.name && (0, co.streamAllContents)(h).filter(Pe.isKeyword).forEach((m) => a.add(m.value, c));
          }
          for (let c of n.values())
            if (i.has(c.name))
              r("error", "Terminal name clashes with existing keyword.", { node: c, property: "name" });
            else if (a.has(c.name)) {
              let l = a.get(c.name);
              r("error", `Terminal name clashes with imported keyword from "${l[0].path}".`, { node: c, property: "name" });
            }
          let s = new lo.MultiMap();
          for (let c of i)
            for (let l of o.get(c))
              s.add(l, c);
          for (let [c, l] of s.entriesGroupedByKey())
            l.length > 0 && r("error", `Imported terminals (${l.join(", ")}) clash with locally defined keywords.`, { node: c, property: "path" });
          let u = new lo.MultiMap();
          for (let [c, l] of o.entriesGroupedByKey()) {
            let d = a.get(c);
            d.length > 0 && l.filter((h) => !d.includes(h)).forEach((h) => u.add(h, c));
          }
          for (let [c, l] of u.entriesGroupedByKey())
            l.length > 0 && r("error", `Imported terminals (${l.join(", ")}) clash with imported keywords.`, { node: c, property: "path" });
        }
        checkRuleName(e, r) {
          if (e.name && !ic(e)) {
            let n = e.name.substring(0, 1);
            n.toUpperCase() !== n && r("warning", "Rule name should start with an upper case letter.", { node: e, property: "name", code: cr.RuleNameUppercase });
          }
        }
        checkTypeReservedName(e, r) {
          this.checkReservedName(e, "name", r);
        }
        checkAssignmentReservedName(e, r) {
          this.checkReservedName(e, "feature", r);
        }
        checkParserRuleReservedName(e, r) {
          e.inferredType || this.checkReservedName(e, "name", r);
        }
        checkReservedName(e, r, n) {
          let i = e[r];
          typeof i == "string" && XB.has(i) && n("error", `'${i}' is a reserved name of the JavaScript runtime.`, { node: e, property: r });
        }
        checkKeyword(e, r) {
          (0, co.getContainerOfType)(e, yy.isParserRule) && (e.value.length === 0 ? r("error", "Keywords cannot be empty.", { node: e }) : e.value.trim().length === 0 ? r("error", "Keywords cannot only consist of whitespace characters.", { node: e }) : /\s/g.test(e.value) && r("warning", "Keywords should not contain whitespace characters.", { node: e }));
        }
        checkUnorderedGroup(e, r) {
          e.elements.forEach((n) => {
            (0, It.isOptionalCardinality)(n.cardinality) && r("error", "Optional elements in Unordered groups are currently not supported", { node: n, code: cr.OptionalUnorderedGroup });
          });
        }
        checkRuleParametersUsed(e, r) {
          let n = e.parameters;
          if (n.length > 0) {
            let i = (0, co.streamAllContents)(e).filter(Pe.isParameterReference);
            for (let o of n)
              i.some((a) => a.parameter.ref === o) || r("hint", `Parameter '${o.name}' is unused.`, { node: o, tags: [hy.DiagnosticTag.Unnecessary] });
          }
        }
        checkParserRuleDataType(e, r) {
          if (ic(e))
            return;
          let n = (0, It.hasDataTypeReturn)(e), i = (0, It.isDataTypeRule)(e);
          !n && i ? r("error", "This parser rule does not create an object. Add a primitive return type or an action to the start of the rule to force object instantiation.", { node: e, property: "name" }) : n && !i && r("error", "Normal parser rules are not allowed to return a primitive value. Use a datatype rule for that.", { node: e, property: e.dataType ? "dataType" : "returnType" });
        }
        checkAssignmentToFragmentRule(e, r) {
          e.terminal && (0, yy.isRuleCall)(e.terminal) && (0, yy.isParserRule)(e.terminal.rule.ref) && e.terminal.rule.ref.fragment && r("error", `Cannot use fragment rule '${e.terminal.rule.ref.name}' for assignment of property '${e.feature}'.`, { node: e, property: "terminal" });
        }
        checkAssignmentTypes(e, r) {
          if (!e.terminal)
            return;
          let n;
          (0, co.streamAllContents)(e.terminal).map((o) => Pe.isCrossReference(o) ? "ref" : "other").find((o) => n ? o !== n : (n = o, false)) && r("error", this.createMixedTypeError(e.feature), { node: e, property: "terminal" });
        }
        checkInterfacePropertyTypes(e, r) {
          for (let n of e.attributes)
            if (n.type) {
              let i = (0, VB.typeDefinitionToPropertyType)(n.type), o = (0, vy.flattenPlainType)(i), a = false, s = false;
              for (let u of o)
                (0, vy.isPlainReferenceType)(u) ? a = true : (0, vy.isPlainReferenceType)(u) || (s = true);
              a && s && r("error", this.createMixedTypeError(n.name), { node: n, property: "type" });
            }
        }
        createMixedTypeError(e) {
          return `Mixing a cross-reference with other types is not supported. Consider splitting property "${e}" into two or more different properties.`;
        }
        checkTerminalRuleReturnType(e, r) {
          var n;
          !((n = e.type) === null || n === void 0) && n.name && !(0, It.isPrimitiveType)(e.type.name) && r("error", "Terminal rules can only return primitive types like 'string', 'boolean', 'number', 'Date' or 'bigint'.", { node: e.type, property: "name" });
        }
        checkRuleCallParameters(e, r) {
          let n = e.rule.ref;
          if (Pe.isParserRule(n)) {
            let i = n.parameters.length, o = e.arguments.length;
            i !== o && r("error", `Rule '${n.name}' expects ${i} arguments, but got ${o}.`, { node: e });
          } else
            Pe.isTerminalRule(n) && e.arguments.length > 0 && r("error", "Terminal rules do not accept any arguments", { node: e });
        }
        checkCrossRefNameAssignment(e, r) {
          !e.terminal && e.type.ref && !(0, fo.findNameAssignment)(e.type.ref) && r("error", "Cannot infer terminal or data type rule for cross reference.", { node: e, property: "type" });
        }
        checkCrossRefTerminalType(e, r) {
          Pe.isRuleCall(e.terminal) && Pe.isParserRule(e.terminal.rule.ref) && !(0, It.isDataTypeRule)(e.terminal.rule.ref) && r("error", "Parser rules cannot be used for cross references.", { node: e.terminal, property: "rule" });
        }
        checkCrossRefType(e, r) {
          let n = this.checkReferenceToRuleButNotType(e == null ? void 0 : e.type);
          n && r("error", n, { node: e, property: "type" });
        }
        checkCrossReferenceToTypeUnion(e, r) {
          if (Pe.isType(e.type.ref) && Pe.isUnionType(e.type.ref.type)) {
            let n = lA(e.type.ref.type);
            n.length > 0 && r("error", `Cross-reference on type union is only valid if all alternatives are AST nodes. ${n.join(", ")} ${n.length > 1 ? "are" : "is"} not ${n.length > 1 ? "" : "an "}AST node${n.length > 1 ? "s" : ""}.`, { node: e, property: "type" });
          }
        }
        checkFragmentsInTypes(e, r) {
          var n, i;
          Pe.isParserRule((n = e.typeRef) === null || n === void 0 ? void 0 : n.ref) && (!((i = e.typeRef) === null || i === void 0) && i.ref.fragment) && r("error", "Cannot use rule fragments in types.", { node: e, property: "typeRef" });
        }
        checkReferenceTypeUnion(e, r) {
          Pe.isSimpleType(e.referenceType) || r("error", "Only direct rule references are allowed in reference types.", { node: e, property: "referenceType" });
        }
        checkReferenceToRuleButNotType(e) {
          if (e && Pe.isParserRule(e.ref) && !(0, It.isDataTypeRule)(e.ref) && (e.ref.returnType || e.ref.inferredType)) {
            let r = (0, It.getTypeNameWithoutError)(e.ref);
            if (r)
              return `Use the rule type '${r}' instead of the typed rule name '${e.ref.name}' for cross references.`;
          }
        }
        checkAssignmentWithFeatureName(e, r) {
          e.feature === "name" && Pe.isCrossReference(e.terminal) && r("warning", 'The "name" property is not recommended for cross-references.', { node: e, property: "feature" });
        }
      };
      lr.LangiumGrammarValidator = Ty;
      function ic(t) {
        return !t.definition || !t.definition.$cstNode || t.definition.$cstNode.length === 0;
      }
      var XB = /* @__PURE__ */ new Set(["Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array", "Map", "Set", "WeakMap", "WeakSet", "Error", "AggregateError", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "BigInt", "RegExp", "Number", "Object", "Function", "Symbol", "String", "Math", "NaN", "Infinity", "isFinite", "isNaN", "Buffer", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "globalThis", "decodeURIComponent", "decodeURI", "encodeURIComponent", "encodeURI", "parseInt", "parseFloat", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "AsyncGenerator", "AsyncGeneratorFunction", "Reflect", "Proxy", "Date", "Intl", "eval", "undefined"]);
      function lA(t) {
        let e = [];
        return t.types.forEach((r) => {
          var n;
          Pe.isSimpleType(r) && (!((n = r.typeRef) === null || n === void 0) && n.ref ? Pe.isType(r.typeRef.ref) && (Pe.isUnionType(r.typeRef.ref.type) ? e.push(...lA(r.typeRef.ref.type)) : e.push(r.typeRef.ref.name)) : r.stringType ? e.push(`"${r.stringType}"`) : r.primitiveType && e.push(r.primitiveType));
        }), Array.from(new Set(e));
      }
    });
    var Id = f((_n) => {
      Object.defineProperty(_n, "__esModule", { value: true });
      _n.DocumentValidator = _n.toDiagnosticSeverity = _n.getDiagnosticRange = _n.DefaultDocumentValidator = void 0;
      var Br = xe(), dA = yt(), JB = be(), QB = Le(), Od = vr(), Ry = class {
        constructor(e) {
          this.validationRegistry = e.validation.ValidationRegistry, this.metadata = e.LanguageMetaData;
        }
        async validateDocument(e, r = Br.CancellationToken.None) {
          let n = e.parseResult, i = [];
          await (0, Od.interruptAndCheck)(r);
          for (let o of n.lexerErrors) {
            let a = { severity: Br.DiagnosticSeverity.Error, range: { start: { line: o.line - 1, character: o.column - 1 }, end: { line: o.line - 1, character: o.column + o.length - 1 } }, message: o.message, code: Dd.LexingError, source: this.getSource() };
            i.push(a);
          }
          for (let o of n.parserErrors) {
            let a;
            if (isNaN(o.token.startOffset)) {
              if ("previousToken" in o) {
                let s = o.previousToken;
                if (isNaN(s.startOffset))
                  a = Br.Range.create(0, 0, 0, 0);
                else {
                  let u = Br.Position.create(s.endLine - 1, s.endColumn);
                  a = Br.Range.create(u, u);
                }
              }
            } else
              a = (0, QB.tokenToRange)(o.token);
            if (a) {
              let s = { severity: Br.DiagnosticSeverity.Error, range: a, message: o.message, code: Dd.ParsingError, source: this.getSource() };
              i.push(s);
            }
          }
          for (let o of e.references) {
            let a = o.error;
            if (a) {
              let s = { containerType: a.container.$type, property: a.property, refText: a.reference.$refText }, u = { node: a.container, property: a.property, index: a.index, code: Dd.LinkingError, data: s };
              i.push(this.toDiagnostic("error", a.message, u));
            }
          }
          try {
            i.push(...await this.validateAst(n.value, e, r));
          } catch (o) {
            if ((0, Od.isOperationCancelled)(o))
              throw o;
            console.error("An error occurred during validation:", o);
          }
          return await (0, Od.interruptAndCheck)(r), i;
        }
        async validateAst(e, r, n = Br.CancellationToken.None) {
          let i = [], o = (a, s, u) => {
            i.push(this.toDiagnostic(a, s, u));
          };
          return await Promise.all((0, JB.streamAst)(e).map(async (a) => {
            await (0, Od.interruptAndCheck)(n);
            let s = this.validationRegistry.getChecks(a.$type);
            for (let u of s)
              await u(a, o, n);
          })), i;
        }
        toDiagnostic(e, r, n) {
          return { message: r, range: fA(n), severity: pA(e), code: n.code, codeDescription: n.codeDescription, tags: n.tags, relatedInformation: n.relatedInformation, data: n.data, source: this.getSource() };
        }
        getSource() {
          return this.metadata.languageId;
        }
      };
      _n.DefaultDocumentValidator = Ry;
      function fA(t) {
        if (Br.Range.is(t.range))
          return t.range;
        let e;
        return typeof t.property == "string" ? e = (0, dA.findNodeForProperty)(t.node.$cstNode, t.property, t.index) : typeof t.keyword == "string" && (e = (0, dA.findNodeForKeyword)(t.node.$cstNode, t.keyword, t.index)), e ?? (e = t.node.$cstNode), e ? e.range : { start: { line: 0, character: 0 }, end: { line: 0, character: 0 } };
      }
      _n.getDiagnosticRange = fA;
      function pA(t) {
        switch (t) {
          case "error":
            return Br.DiagnosticSeverity.Error;
          case "warning":
            return Br.DiagnosticSeverity.Warning;
          case "info":
            return Br.DiagnosticSeverity.Information;
          case "hint":
            return Br.DiagnosticSeverity.Hint;
          default:
            throw new Error("Invalid diagnostic severity: " + t);
        }
      }
      _n.toDiagnosticSeverity = pA;
      var Dd;
      (function(t) {
        t.LexingError = "lexing-error", t.ParsingError = "parsing-error", t.LinkingError = "linking-error";
      })(Dd = _n.DocumentValidator || (_n.DocumentValidator = {}));
    });
    var vA = f((Xn) => {
      var ZB = Xn && Xn.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), eK = Xn && Xn.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), tK = Xn && Xn.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && ZB(e, t, r);
        return eK(e, t), e;
      };
      Object.defineProperty(Xn, "__esModule", { value: true });
      Xn.LangiumGrammarCodeActionProvider = void 0;
      var Kr = xe(), rK = vn(), hA = be(), mA = Le(), nK = yt(), gA = Zo(), yA = ki(), iK = Id(), by = tK(we()), zr = _y(), Sy = class {
        constructor(e) {
          this.reflection = e.shared.AstReflection, this.indexManager = e.shared.workspace.IndexManager;
        }
        getCodeActions(e, r) {
          let n = [], i = (o) => o && n.push(o);
          for (let o of r.context.diagnostics)
            this.createCodeActions(o, e, i);
          return n;
        }
        createCodeActions(e, r, n) {
          switch (e.code) {
            case zr.IssueCodes.GrammarNameUppercase:
            case zr.IssueCodes.RuleNameUppercase:
              n(this.makeUpperCase(e, r));
              break;
            case zr.IssueCodes.HiddenGrammarTokens:
              n(this.fixHiddenTerminals(e, r));
              break;
            case zr.IssueCodes.UseRegexTokens:
              n(this.fixRegexTokens(e, r));
              break;
            case zr.IssueCodes.EntryRuleTokenSyntax:
              n(this.addEntryKeyword(e, r));
              break;
            case zr.IssueCodes.CrossRefTokenSyntax:
              n(this.fixCrossRefSyntax(e, r));
              break;
            case zr.IssueCodes.UnnecessaryFileExtension:
              n(this.fixUnnecessaryFileExtension(e, r));
              break;
            case zr.IssueCodes.MissingReturns:
              n(this.fixMissingReturns(e, r));
              break;
            case zr.IssueCodes.InvalidInfers:
            case zr.IssueCodes.InvalidReturns:
              n(this.fixInvalidReturnsInfers(e, r));
              break;
            case zr.IssueCodes.MissingInfer:
              n(this.fixMissingInfer(e, r));
              break;
            case zr.IssueCodes.SuperfluousInfer:
              n(this.fixSuperfluousInfer(e, r));
              break;
            case iK.DocumentValidator.LinkingError: {
              let i = e.data;
              i && i.containerType === "RuleCall" && i.property === "rule" && n(this.addNewRule(e, i, r)), i && this.lookInGlobalScope(e, i, r).forEach(n);
              break;
            }
          }
        }
        fixMissingReturns(e, r) {
          let n = r.textDocument.getText(e.range);
          if (n)
            return { title: `Add explicit return type for parser rule ${n}`, kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], edit: { changes: { [r.textDocument.uri]: [{ range: e.range, newText: `${n} returns ${n}` }] } } };
        }
        fixInvalidReturnsInfers(e, r) {
          let n = e.data;
          if (n) {
            let i = r.textDocument.getText(n.range);
            return { title: `Correct ${i} usage`, kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], edit: { changes: { [r.textDocument.uri]: [{ range: n.range, newText: i === "infers" ? "returns" : "infers" }] } } };
          }
        }
        fixMissingInfer(e, r) {
          let n = e.data;
          if (n)
            return { title: "Correct 'infer' usage", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], edit: { changes: { [r.textDocument.uri]: [{ range: { start: n.range.end, end: n.range.end }, newText: "infer " }] } } };
        }
        fixSuperfluousInfer(e, r) {
          if (e.data)
            return { title: "Remove the 'infer' keyword", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], edit: { changes: { [r.textDocument.uri]: [{ range: e.data, newText: "" }] } } };
        }
        fixUnnecessaryFileExtension(e, r) {
          let n = Object.assign({}, e.range.end);
          n.character -= 1;
          let i = Object.assign({}, n);
          return i.character -= 8, { title: "Remove file extension", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: true, edit: { changes: { [r.textDocument.uri]: [{ range: { start: i, end: n }, newText: "" }] } } };
        }
        makeUpperCase(e, r) {
          let n = { start: e.range.start, end: { line: e.range.start.line, character: e.range.start.character + 1 } };
          return { title: "First letter to upper case", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: true, edit: { changes: { [r.textDocument.uri]: [{ range: n, newText: r.textDocument.getText(n).toUpperCase() }] } } };
        }
        addEntryKeyword(e, r) {
          return { title: "Add entry keyword", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: true, edit: { changes: { [r.textDocument.uri]: [{ range: { start: e.range.start, end: e.range.start }, newText: "entry " }] } } };
        }
        fixRegexTokens(e, r) {
          let n = r.textDocument.offsetAt(e.range.start), i = r.parseResult.value.$cstNode;
          if (i) {
            let o = (0, mA.findLeafNodeAtOffset)(i, n), a = (0, hA.getContainerOfType)(o == null ? void 0 : o.element, by.isCharacterRange);
            if (a && a.right && a.$cstNode) {
              let s = a.left.value, u = a.right.value;
              return { title: "Refactor into regular expression", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: true, edit: { changes: { [r.textDocument.uri]: [{ range: a.$cstNode.range, newText: `/[${(0, gA.escapeRegExp)(s)}-${(0, gA.escapeRegExp)(u)}]/` }] } } };
            }
          }
        }
        fixCrossRefSyntax(e, r) {
          return { title: "Replace '|' with ':'", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: true, edit: { changes: { [r.textDocument.uri]: [{ range: e.range, newText: ":" }] } } };
        }
        fixHiddenTerminals(e, r) {
          let n = r.parseResult.value, i = n.hiddenTokens, o = [], a = (0, nK.findNodeForProperty)(n.$cstNode, "definesHiddenTokens");
          if (a) {
            let s = a.range.start, u = a.offset, c = n.$cstNode.text.indexOf(")", u) + 1;
            o.push({ newText: "", range: { start: s, end: r.textDocument.positionAt(c) } });
          }
          for (let s of i) {
            let u = s.ref;
            if (u && by.isTerminalRule(u) && !u.hidden && u.$cstNode) {
              let c = u.$cstNode.range.start;
              o.push({ newText: "hidden ", range: { start: c, end: c } });
            }
          }
          return { title: "Fix hidden terminals", kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: true, edit: { changes: { [r.textDocument.uri]: o } } };
        }
        addNewRule(e, r, n) {
          let i = n.textDocument.offsetAt(e.range.start), o = n.parseResult.value.$cstNode;
          if (o) {
            let a = (0, mA.findLeafNodeAtOffset)(o, i), s = (0, hA.getContainerOfType)(a == null ? void 0 : a.element, by.isParserRule);
            if (s && s.$cstNode)
              return { title: `Add new rule '${r.refText}'`, kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: false, edit: { changes: { [n.textDocument.uri]: [{ range: { start: s.$cstNode.range.end, end: s.$cstNode.range.end }, newText: `

` + r.refText + `:
    /* TODO implement rule */ {infer ` + r.refText + "};" }] } } };
          }
        }
        lookInGlobalScope(e, r, n) {
          var i, o;
          let a = { container: { $type: r.containerType }, property: r.property, reference: { $refText: r.refText } }, s = this.reflection.getReferenceType(a), u = this.indexManager.allElements(s).filter((h) => h.name === r.refText), c = [], l = -1, d = -1;
          for (let h of u) {
            if ((0, yA.equalURI)(h.documentUri, n.uri))
              continue;
            let y = oK(n.uri, h.documentUri), m, R = "", C = n.parseResult.value, N = C.imports.find((S) => S.path && y < S.path);
            if (N)
              m = (i = N.$cstNode) === null || i === void 0 ? void 0 : i.range.start;
            else if (C.imports.length > 0) {
              let S = C.imports[C.imports.length - 1].$cstNode.range.end;
              S && (m = { line: S.line + 1, character: 0 });
            } else
              C.rules.length > 0 && (m = (o = C.rules[0].$cstNode) === null || o === void 0 ? void 0 : o.range.start, R = `
`);
            m && ((l < 0 || y.length < d) && (l = c.length, d = y.length), c.push({ title: `Add import to '${y}'`, kind: Kr.CodeActionKind.QuickFix, diagnostics: [e], isPreferred: false, edit: { changes: { [n.textDocument.uri]: [{ range: { start: m, end: m }, newText: `import '${y}'
${R}` }] } } }));
          }
          return l >= 0 && (c[l].isPreferred = true), c;
        }
      };
      Xn.LangiumGrammarCodeActionProvider = Sy;
      function oK(t, e) {
        let r = rK.Utils.dirname(t), n = (0, yA.relativeURI)(r, e);
        return !n.startsWith("./") && !n.startsWith("../") && (n = "./" + n), n.endsWith(".langium") && (n = n.substring(0, n.length - 8)), n;
      }
    });
    var qd = f((xd) => {
      Object.defineProperty(xd, "__esModule", { value: true });
      xd.DefaultFoldingRangeProvider = void 0;
      var Ay = xe(), aK = be(), sK = Le(), Py = class {
        constructor(e) {
          this.commentNames = e.parser.GrammarConfig.multilineCommentRules;
        }
        getFoldingRanges(e) {
          let r = [], n = (i) => r.push(i);
          return this.collectFolding(e, n), r;
        }
        collectFolding(e, r) {
          var n;
          let i = (n = e.parseResult) === null || n === void 0 ? void 0 : n.value;
          if (i) {
            if (this.shouldProcessContent(i)) {
              let o = (0, aK.streamAllContents)(i).iterator(), a;
              do
                if (a = o.next(), !a.done) {
                  let s = a.value;
                  this.shouldProcess(s) && this.collectObjectFolding(e, s, r), this.shouldProcessContent(s) || o.prune();
                }
              while (!a.done);
            }
            this.collectCommentFolding(e, i, r);
          }
        }
        shouldProcess(e) {
          return true;
        }
        shouldProcessContent(e) {
          return true;
        }
        collectObjectFolding(e, r, n) {
          let i = r.$cstNode;
          if (i) {
            let o = this.toFoldingRange(e, i);
            o && n(o);
          }
        }
        collectCommentFolding(e, r, n) {
          let i = r.$cstNode;
          if (i) {
            for (let o of (0, sK.flattenCst)(i))
              if (this.commentNames.includes(o.tokenType.name)) {
                let a = this.toFoldingRange(e, o, Ay.FoldingRangeKind.Comment);
                a && n(a);
              }
          }
        }
        toFoldingRange(e, r, n) {
          let i = r.range, o = i.start, a = i.end;
          if (!(a.line - o.line < 2))
            return this.includeLastFoldingLine(r, n) || (a = e.textDocument.positionAt(e.textDocument.offsetAt({ line: a.line, character: 0 }) - 1)), Ay.FoldingRange.create(o.line, a.line, o.character, a.character, n);
        }
        includeLastFoldingLine(e, r) {
          if (r === Ay.FoldingRangeKind.Comment)
            return false;
          let n = e.text, i = n.charAt(n.length - 1);
          return !(i === "}" || i === ")" || i === "]");
        }
      };
      xd.DefaultFoldingRangeProvider = Py;
    });
    var TA = f((Ld) => {
      Object.defineProperty(Ld, "__esModule", { value: true });
      Ld.LangiumGrammarFoldingRangeProvider = void 0;
      var uK = qd(), cK = we(), Cy = class extends uK.DefaultFoldingRangeProvider {
        shouldProcessContent(e) {
          return !(0, cK.isParserRule)(e);
        }
      };
      Ld.LangiumGrammarFoldingRangeProvider = Cy;
    });
    var ky = f((Rn) => {
      Object.defineProperty(Rn, "__esModule", { value: true });
      Rn.Formatting = Rn.FormattingRegion = Rn.DefaultNodeFormatter = Rn.AbstractFormatter = void 0;
      var Md = yt(), Ny = Zt(), lK = be(), _A = Le(), oc = $t(), Ey = class {
        constructor() {
          this.collector = () => {
          };
        }
        getNodeFormatter(e) {
          return new $d(e, this.collector);
        }
        formatDocument(e, r) {
          let n = e.parseResult;
          return n.lexerErrors.length === 0 && n.parserErrors.length === 0 ? this.doDocumentFormat(e, r.options) : [];
        }
        isFormatRangeErrorFree(e, r) {
          let n = e.parseResult;
          return n.lexerErrors.length || n.parserErrors.length ? Math.min(...n.lexerErrors.map((o) => {
            var a;
            return (a = o.line) !== null && a !== void 0 ? a : Number.MAX_VALUE;
          }), ...n.parserErrors.map((o) => {
            var a;
            return (a = o.token.startLine) !== null && a !== void 0 ? a : Number.MAX_VALUE;
          })) > r.end.line : true;
        }
        formatDocumentRange(e, r) {
          return this.isFormatRangeErrorFree(e, r.range) ? this.doDocumentFormat(e, r.options, r.range) : [];
        }
        formatDocumentOnType(e, r) {
          let n = { start: { character: 0, line: r.position.line }, end: r.position };
          return this.isFormatRangeErrorFree(e, n) ? this.doDocumentFormat(e, r.options, n) : [];
        }
        get formatOnTypeOptions() {
        }
        doDocumentFormat(e, r, n) {
          let i = /* @__PURE__ */ new Map(), o = (s, u, c) => {
            var l, d;
            let h = this.nodeModeToKey(s, u), y = i.get(h), m = (l = c.options.priority) !== null && l !== void 0 ? l : 0, R = (d = y == null ? void 0 : y.options.priority) !== null && d !== void 0 ? d : 0;
            (!y || R <= m) && i.set(h, c);
          };
          this.collector = o, this.iterateAstFormatting(e, n);
          let a = this.iterateCstFormatting(e, i, r, n);
          return this.avoidOverlappingEdits(e.textDocument, a);
        }
        avoidOverlappingEdits(e, r) {
          let n = [];
          for (let i of r) {
            let o = n[n.length - 1];
            if (o) {
              let a = e.offsetAt(i.range.start), s = e.offsetAt(o.range.end);
              a < s && n.pop();
            }
            n.push(i);
          }
          return n;
        }
        iterateAstFormatting(e, r) {
          let n = e.parseResult.value;
          this.format(n);
          let i = (0, lK.streamAllContents)(n).iterator(), o;
          do
            if (o = i.next(), !o.done) {
              let a = o.value;
              this.insideRange(a.$cstNode.range, r) ? this.format(a) : i.prune();
            }
          while (!o.done);
        }
        nodeModeToKey(e, r) {
          return `${e.offset}:${e.end}:${r}`;
        }
        insideRange(e, r) {
          return !r || e.start.line <= r.start.line && e.end.line >= r.end.line || e.start.line >= r.start.line && e.end.line <= r.end.line || e.start.line <= r.end.line && e.end.line >= r.end.line;
        }
        isNecessary(e, r) {
          return r.getText(e.range) !== e.newText;
        }
        iterateCstFormatting(e, r, n, i) {
          let o = { indentation: 0, options: n, document: e.textDocument }, a = [], u = this.iterateCstTree(e, o).iterator(), c, l;
          do
            if (l = u.next(), !l.done) {
              let d = l.value, h = (0, Ny.isLeafCstNode)(d), y = this.nodeModeToKey(d, "prepend"), m = r.get(y);
              if (r.delete(y), m) {
                let N = this.createTextEdit(c, d, m, o);
                for (let S of N)
                  S && this.insideRange(S.range, i) && this.isNecessary(S, e.textDocument) && a.push(S);
              }
              let R = this.nodeModeToKey(d, "append"), C = r.get(R);
              if (r.delete(R), C) {
                let N = (0, _A.getNextNode)(d);
                if (N) {
                  let S = this.createTextEdit(d, N, C, o);
                  for (let b of S)
                    b && this.insideRange(b.range, i) && this.isNecessary(b, e.textDocument) && a.push(b);
                }
              }
              if (!m && d.hidden) {
                let N = this.createHiddenTextEdits(c, d, void 0, o);
                for (let S of N)
                  S && this.insideRange(S.range, i) && this.isNecessary(S, e.textDocument) && a.push(S);
              }
              h && (c = d);
            }
          while (!l.done);
          return a;
        }
        createHiddenTextEdits(e, r, n, i) {
          var o;
          let a = r.range.start.line;
          if (e && e.range.end.line === a)
            return [];
          let s = [], u = { start: { character: 0, line: a }, end: r.range.start }, c = i.document.getText(u), l = this.findFittingMove(u, (o = n == null ? void 0 : n.moves) !== null && o !== void 0 ? o : [], i), d = this.getExistingIndentationCharacterCount(c, i), y = this.getIndentationCharacterCount(i, l) - d;
          if (y === 0)
            return [];
          let m = "";
          y > 0 && (m = (i.options.insertSpaces ? " " : "	").repeat(y));
          let R = r.text.split(`
`);
          R[0] = c + R[0];
          for (let C = 0; C < R.length; C++) {
            let N = a + C, S = { character: 0, line: N };
            if (y > 0)
              s.push({ newText: m, range: { start: S, end: S } });
            else {
              let b = R[C], O = 0;
              for (; O < b.length; O++) {
                let L = b.charAt(O);
                if (L !== " " && L !== "	")
                  break;
              }
              s.push({ newText: "", range: { start: S, end: { line: N, character: Math.min(O, Math.abs(y)) } } });
            }
          }
          return s;
        }
        getExistingIndentationCharacterCount(e, r) {
          let n = " ".repeat(r.options.tabSize);
          return (r.options.insertSpaces ? e.replaceAll("	", n) : e.replaceAll(n, "	")).length;
        }
        getIndentationCharacterCount(e, r) {
          let n = e.indentation;
          return r && r.tabs && (n += r.tabs), (e.options.insertSpaces ? e.options.tabSize : 1) * n;
        }
        createTextEdit(e, r, n, i) {
          var o;
          if (r.hidden)
            return this.createHiddenTextEdits(e, r, n, i);
          let a = { start: (o = e == null ? void 0 : e.range.end) !== null && o !== void 0 ? o : { character: 0, line: 0 }, end: r.range.start }, s = this.findFittingMove(a, n.moves, i);
          if (!s)
            return [];
          let u = s.characters, c = s.lines, l = s.tabs, d = i.indentation;
          i.indentation += l ?? 0;
          let h = [];
          return u !== void 0 ? h.push(this.createSpaceTextEdit(a, u, n.options)) : c !== void 0 ? h.push(this.createLineTextEdit(a, c, i, n.options)) : l !== void 0 && h.push(this.createTabTextEdit(a, Boolean(e), i)), (0, Ny.isLeafCstNode)(r) && (i.indentation = d), h;
        }
        createSpaceTextEdit(e, r, n) {
          if (e.start.line === e.end.line) {
            let o = e.end.character - e.start.character;
            r = this.fitIntoOptions(r, o, n);
          }
          return { newText: " ".repeat(r), range: e };
        }
        createLineTextEdit(e, r, n, i) {
          let o = e.end.line - e.start.line;
          r = this.fitIntoOptions(r, o, i);
          let s = (n.options.insertSpaces ? " ".repeat(n.options.tabSize) : "	").repeat(n.indentation);
          return { newText: `${`
`.repeat(r)}${s}`, range: e };
        }
        createTabTextEdit(e, r, n) {
          let o = (n.options.insertSpaces ? " ".repeat(n.options.tabSize) : "	").repeat(n.indentation), a = r ? 1 : 0, s = Math.max(e.end.line - e.start.line, a);
          return { newText: `${`
`.repeat(s)}${o}`, range: e };
        }
        fitIntoOptions(e, r, n) {
          return n.allowMore ? e = Math.max(r, e) : n.allowLess && (e = Math.min(r, e)), e;
        }
        findFittingMove(e, r, n) {
          if (r.length === 0)
            return;
          if (r.length === 1)
            return r[0];
          let i = e.end.line - e.start.line;
          for (let o of r) {
            if (o.lines !== void 0 && i <= o.lines)
              return o;
            if (o.lines === void 0 && i === 0)
              return o;
          }
          return r[r.length - 1];
        }
        iterateCstTree(e, r) {
          let i = e.parseResult.value.$cstNode;
          return i ? new oc.TreeStreamImpl(i, (o) => this.iterateCst(o, r)) : oc.EMPTY_STREAM;
        }
        iterateCst(e, r) {
          if (!(0, Ny.isCompositeCstNode)(e))
            return oc.EMPTY_STREAM;
          let n = r.indentation;
          return new oc.StreamImpl(() => ({ index: 0 }), (i) => i.index < e.children.length ? { done: false, value: e.children[i.index++] } : (r.indentation = n, oc.DONE_RESULT));
        }
      };
      Rn.AbstractFormatter = Ey;
      var $d = class {
        constructor(e, r) {
          this.astNode = e, this.collector = r;
        }
        node(e) {
          return new Tr(e.$cstNode ? [e.$cstNode] : [], this.collector);
        }
        nodes(...e) {
          let r = [];
          for (let n of e)
            n.$cstNode && r.push(n.$cstNode);
          return new Tr(r, this.collector);
        }
        property(e, r) {
          let n = (0, Md.findNodeForProperty)(this.astNode.$cstNode, e, r);
          return new Tr(n ? [n] : [], this.collector);
        }
        properties(...e) {
          let r = [];
          for (let n of e) {
            let i = (0, Md.findNodesForProperty)(this.astNode.$cstNode, n);
            r.push(...i);
          }
          return new Tr(r, this.collector);
        }
        keyword(e, r) {
          let n = (0, Md.findNodeForKeyword)(this.astNode.$cstNode, e, r);
          return new Tr(n ? [n] : [], this.collector);
        }
        keywords(...e) {
          let r = [];
          for (let n of e) {
            let i = (0, Md.findNodesForKeyword)(this.astNode.$cstNode, n);
            r.push(...i);
          }
          return new Tr(r, this.collector);
        }
        cst(e) {
          return new Tr([...e], this.collector);
        }
        interior(e, r) {
          let n = e.nodes, i = r.nodes;
          if (n.length !== 1 || i.length !== 1)
            return new Tr([], this.collector);
          let o = n[0], a = i[0];
          if (o.offset > a.offset) {
            let s = o;
            o = a, a = s;
          }
          return new Tr((0, _A.getInteriorNodes)(o, a), this.collector);
        }
      };
      Rn.DefaultNodeFormatter = $d;
      var Tr = class {
        constructor(e, r) {
          this.nodes = e, this.collector = r;
        }
        prepend(e) {
          for (let r of this.nodes)
            this.collector(r, "prepend", e);
          return this;
        }
        append(e) {
          for (let r of this.nodes)
            this.collector(r, "append", e);
          return this;
        }
        surround(e) {
          for (let r of this.nodes)
            this.collector(r, "prepend", e), this.collector(r, "append", e);
          return this;
        }
        slice(e, r) {
          return new Tr(this.nodes.slice(e, r), this.collector);
        }
      };
      Rn.FormattingRegion = Tr;
      (function(t) {
        function e(...l) {
          return { options: {}, moves: l.flatMap((d) => d.moves).sort(c) };
        }
        t.fit = e;
        function r(l) {
          return i(0, l);
        }
        t.noSpace = r;
        function n(l) {
          return i(1, l);
        }
        t.oneSpace = n;
        function i(l, d) {
          return { options: d ?? {}, moves: [{ characters: l }] };
        }
        t.spaces = i;
        function o(l) {
          return a(1, l);
        }
        t.newLine = o;
        function a(l, d) {
          return { options: d ?? {}, moves: [{ lines: l }] };
        }
        t.newLines = a;
        function s(l) {
          return { options: l ?? {}, moves: [{ tabs: 1, lines: 1 }] };
        }
        t.indent = s;
        function u(l) {
          return { options: l ?? {}, moves: [{ tabs: 0 }] };
        }
        t.noIndent = u;
        function c(l, d) {
          var h, y, m, R, C, N;
          let S = (h = l.lines) !== null && h !== void 0 ? h : 0, b = (y = d.lines) !== null && y !== void 0 ? y : 0, O = (m = l.tabs) !== null && m !== void 0 ? m : 0, L = (R = d.tabs) !== null && R !== void 0 ? R : 0, W = (C = l.characters) !== null && C !== void 0 ? C : 0, Z = (N = d.characters) !== null && N !== void 0 ? N : 0;
          return S < b ? -1 : S > b ? 1 : O < L ? -1 : O > L ? 1 : W < Z ? -1 : W > Z ? 1 : 0;
        }
      })(Rn.Formatting || (Rn.Formatting = {}));
    });
    var RA = f((Jn) => {
      var fK = Jn && Jn.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), pK = Jn && Jn.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), hK = Jn && Jn.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && fK(e, t, r);
        return pK(e, t), e;
      };
      Object.defineProperty(Jn, "__esModule", { value: true });
      Jn.LangiumGrammarFormatter = void 0;
      var Ce = ky(), po = hK(we()), wy = class extends Ce.AbstractFormatter {
        format(e) {
          if (po.isCrossReference(e))
            this.getNodeFormatter(e).properties("type", "terminal").surround(Ce.Formatting.noSpace());
          else if (po.isParserRule(e)) {
            let r = this.getNodeFormatter(e);
            r.keywords("entry", "fragment", "returns").append(Ce.Formatting.oneSpace()), (e.inferredType || e.returnType || e.dataType) && e.parameters.length === 0 ? r.property("name").append(Ce.Formatting.oneSpace()) : r.property("name").append(Ce.Formatting.noSpace()), r.properties("parameters").append(Ce.Formatting.noSpace()), r.keywords(",").append(Ce.Formatting.oneSpace()), r.keywords("<").append(Ce.Formatting.noSpace());
            let n = r.keyword(";"), i = r.keyword(":");
            i.prepend(Ce.Formatting.noSpace()), r.interior(i, n).prepend(Ce.Formatting.indent()), n.prepend(Ce.Formatting.fit(Ce.Formatting.noSpace(), Ce.Formatting.newLine())), r.node(e).prepend(Ce.Formatting.noIndent());
          } else if (po.isTerminalRule(e)) {
            let r = this.getNodeFormatter(e);
            e.type && (r.property("name").append(Ce.Formatting.oneSpace()), r.keyword("returns").append(Ce.Formatting.oneSpace())), r.keywords("hidden", "terminal", "fragment").append(Ce.Formatting.oneSpace()), r.keyword(":").prepend(Ce.Formatting.noSpace()), r.keyword(";").prepend(Ce.Formatting.fit(Ce.Formatting.noSpace(), Ce.Formatting.newLine())), r.node(e).prepend(Ce.Formatting.noIndent());
          } else if (po.isAction(e)) {
            let r = this.getNodeFormatter(e);
            r.keyword("{").append(Ce.Formatting.noSpace()), r.keywords(".", "+=", "=").surround(Ce.Formatting.noSpace()), r.keyword("}").prepend(Ce.Formatting.noSpace());
          } else if (po.isInferredType(e))
            this.getNodeFormatter(e).keywords("infer", "infers").append(Ce.Formatting.oneSpace());
          else if (po.isAssignment(e))
            this.getNodeFormatter(e).keywords("=", "+=", "?=").surround(Ce.Formatting.noSpace());
          else if (po.isRuleCall(e)) {
            let r = this.getNodeFormatter(e);
            r.keyword("<").surround(Ce.Formatting.noSpace()), r.keyword(",").append(Ce.Formatting.oneSpace()), r.properties("arguments").append(Ce.Formatting.noSpace());
          }
          po.isAbstractElement(e) && this.getNodeFormatter(e).property("cardinality").prepend(Ce.Formatting.noSpace());
        }
      };
      Jn.LangiumGrammarFormatter = wy;
    });
    var Ud = f((Ct) => {
      Object.defineProperty(Ct, "__esModule", { value: true });
      Ct.SemanticTokensDecoder = Ct.AbstractSemanticTokenProvider = Ct.SemanticTokensBuilder = Ct.DefaultSemanticTokenOptions = Ct.AllSemanticTokenModifiers = Ct.AllSemanticTokenTypes = void 0;
      var fe = xe(), Fd = yt(), mK = be(), gK = vr(), yK = Le();
      Ct.AllSemanticTokenTypes = { [fe.SemanticTokenTypes.class]: 0, [fe.SemanticTokenTypes.comment]: 1, [fe.SemanticTokenTypes.enum]: 2, [fe.SemanticTokenTypes.enumMember]: 3, [fe.SemanticTokenTypes.event]: 4, [fe.SemanticTokenTypes.function]: 5, [fe.SemanticTokenTypes.interface]: 6, [fe.SemanticTokenTypes.keyword]: 7, [fe.SemanticTokenTypes.macro]: 8, [fe.SemanticTokenTypes.method]: 9, [fe.SemanticTokenTypes.modifier]: 10, [fe.SemanticTokenTypes.namespace]: 11, [fe.SemanticTokenTypes.number]: 12, [fe.SemanticTokenTypes.operator]: 13, [fe.SemanticTokenTypes.parameter]: 14, [fe.SemanticTokenTypes.property]: 15, [fe.SemanticTokenTypes.regexp]: 16, [fe.SemanticTokenTypes.string]: 17, [fe.SemanticTokenTypes.struct]: 18, [fe.SemanticTokenTypes.type]: 19, [fe.SemanticTokenTypes.typeParameter]: 20, [fe.SemanticTokenTypes.variable]: 21 };
      Ct.AllSemanticTokenModifiers = { [fe.SemanticTokenModifiers.abstract]: 1 << 0, [fe.SemanticTokenModifiers.async]: 1 << 1, [fe.SemanticTokenModifiers.declaration]: 1 << 2, [fe.SemanticTokenModifiers.defaultLibrary]: 1 << 3, [fe.SemanticTokenModifiers.definition]: 1 << 4, [fe.SemanticTokenModifiers.deprecated]: 1 << 5, [fe.SemanticTokenModifiers.documentation]: 1 << 6, [fe.SemanticTokenModifiers.modification]: 1 << 7, [fe.SemanticTokenModifiers.readonly]: 1 << 8, [fe.SemanticTokenModifiers.static]: 1 << 9 };
      Ct.DefaultSemanticTokenOptions = { legend: { tokenTypes: Object.keys(Ct.AllSemanticTokenTypes), tokenModifiers: Object.keys(Ct.AllSemanticTokenModifiers) }, full: { delta: true }, range: true };
      var jd = class extends fe.SemanticTokensBuilder {
        constructor() {
          super(...arguments), this._tokens = [];
        }
        push(e, r, n, i, o) {
          this._tokens.push({ line: e, char: r, length: n, tokenType: i, tokenModifiers: o });
        }
        build() {
          return this.applyTokens(), super.build();
        }
        buildEdits() {
          return this.applyTokens(), super.buildEdits();
        }
        applyTokens() {
          for (let e of this._tokens.sort(this.compareTokens))
            super.push(e.line, e.char, e.length, e.tokenType, e.tokenModifiers);
          this._tokens = [];
        }
        compareTokens(e, r) {
          return e.line === r.line ? e.char - r.char : e.line - r.line;
        }
      };
      Ct.SemanticTokensBuilder = jd;
      var Oy = class {
        constructor(e) {
          this.tokensBuilders = /* @__PURE__ */ new Map(), e.shared.workspace.TextDocuments.onDidClose((r) => {
            this.tokensBuilders.delete(r.document.uri);
          }), e.shared.lsp.LanguageServer.onInitialize((r) => {
            var n;
            this.initialize((n = r.capabilities.textDocument) === null || n === void 0 ? void 0 : n.semanticTokens);
          });
        }
        initialize(e) {
          this.clientCapabilities = e;
        }
        async semanticHighlight(e, r, n = fe.CancellationToken.None) {
          return this.currentRange = void 0, this.currentDocument = e, this.currentTokensBuilder = this.getDocumentTokensBuilder(e), await this.computeHighlighting(e, this.createAcceptor(), n), this.currentTokensBuilder.build();
        }
        async semanticHighlightRange(e, r, n = fe.CancellationToken.None) {
          return this.currentRange = r.range, this.currentDocument = e, this.currentTokensBuilder = this.getDocumentTokensBuilder(e), await this.computeHighlighting(e, this.createAcceptor(), n), this.currentTokensBuilder.build();
        }
        async semanticHighlightDelta(e, r, n = fe.CancellationToken.None) {
          return this.currentRange = void 0, this.currentDocument = e, this.currentTokensBuilder = this.getDocumentTokensBuilder(e), this.currentTokensBuilder.previousResult(r.previousResultId), await this.computeHighlighting(e, this.createAcceptor(), n), this.currentTokensBuilder.buildEdits();
        }
        createAcceptor() {
          return (r) => {
            "line" in r ? this.highlightToken({ range: { start: { line: r.line, character: r.char }, end: { line: r.line, character: r.char + r.length } }, type: r.type, modifier: r.modifier }) : "range" in r ? this.highlightToken(r) : "keyword" in r ? this.highlightKeyword(r) : "property" in r ? this.highlightProperty(r) : this.highlightNode({ node: r.cst, type: r.type, modifier: r.modifier });
          };
        }
        getDocumentTokensBuilder(e) {
          let r = this.tokensBuilders.get(e.uri.toString());
          if (r)
            return r;
          let n = new jd();
          return this.tokensBuilders.set(e.uri.toString(), n), n;
        }
        async computeHighlighting(e, r, n) {
          let i = e.parseResult.value, o = (0, mK.streamAst)(i, { range: this.currentRange }).iterator(), a;
          do
            if (a = o.next(), !a.done) {
              await (0, gK.interruptAndCheck)(n);
              let s = a.value;
              this.highlightElement(s, r) === "prune" && o.prune();
            }
          while (!a.done);
        }
        highlightToken(e) {
          var r;
          let { range: n, type: i } = e, o = e.modifier;
          if (this.currentRange && !(0, yK.inRange)(n, this.currentRange) || !this.currentDocument || !this.currentTokensBuilder)
            return;
          let a = Ct.AllSemanticTokenTypes[i], s = 0;
          if (o !== void 0) {
            typeof o == "string" && (o = [o]);
            for (let l of o) {
              let d = Ct.AllSemanticTokenModifiers[l];
              s |= d;
            }
          }
          let u = n.start.line, c = n.end.line;
          if (u === c) {
            let l = n.start.character, d = n.end.character - l;
            this.currentTokensBuilder.push(u, l, d, a, s);
          } else if (!((r = this.clientCapabilities) === null || r === void 0) && r.multilineTokenSupport) {
            let l = n.start.character, d = this.currentDocument.textDocument.offsetAt(n.start), h = this.currentDocument.textDocument.offsetAt(n.end);
            this.currentTokensBuilder.push(u, l, h - d, a, s);
          } else {
            let l = n.start, d = this.currentDocument.textDocument.offsetAt({ line: u + 1, character: 0 });
            this.currentTokensBuilder.push(l.line, l.character, d - l.character - 1, a, s);
            for (let h = u + 1; h < c; h++) {
              let y = d;
              d = this.currentDocument.textDocument.offsetAt({ line: h + 1, character: 0 }), this.currentTokensBuilder.push(h, 0, d - y - 1, a, s);
            }
            this.currentTokensBuilder.push(c, 0, n.end.character, a, s);
          }
        }
        highlightProperty(e) {
          let r = [];
          if (typeof e.index == "number") {
            let o = (0, Fd.findNodeForProperty)(e.node.$cstNode, e.property, e.index);
            o && r.push(o);
          } else
            r.push(...(0, Fd.findNodesForProperty)(e.node.$cstNode, e.property));
          let { type: n, modifier: i } = e;
          for (let o of r)
            this.highlightNode({ node: o, type: n, modifier: i });
        }
        highlightKeyword(e) {
          let { node: r, keyword: n, type: i, index: o, modifier: a } = e, s = [];
          if (typeof o == "number") {
            let u = (0, Fd.findNodeForKeyword)(r.$cstNode, n, o);
            u && s.push(u);
          } else
            s.push(...(0, Fd.findNodesForKeyword)(r.$cstNode, n));
          for (let u of s)
            this.highlightNode({ node: u, type: i, modifier: a });
        }
        highlightNode(e) {
          let { node: r, type: n, modifier: i } = e, o = r.range;
          this.highlightToken({ range: o, type: n, modifier: i });
        }
      };
      Ct.AbstractSemanticTokenProvider = Oy;
      (function(t) {
        function e(n, i) {
          let o = /* @__PURE__ */ new Map();
          Object.entries(Ct.AllSemanticTokenTypes).forEach(([u, c]) => o.set(c, u));
          let a = 0, s = 0;
          return r(n.data, 5).map((u) => {
            a += u[0], u[0] !== 0 && (s = 0), s += u[1];
            let c = u[2];
            return { offset: i.textDocument.offsetAt({ line: a, character: s }), tokenType: o.get(u[3]), tokenModifiers: u[4], text: i.textDocument.getText({ start: { line: a, character: s }, end: { line: a, character: s + c } }) };
          });
        }
        t.decode = e;
        function r(n, i) {
          let o = [];
          for (let a = 0; a < n.length; a += i) {
            let s = n.slice(a, a + i);
            o.push(s);
          }
          return o;
        }
      })(Ct.SemanticTokensDecoder || (Ct.SemanticTokensDecoder = {}));
    });
    var bA = f((Gd) => {
      Object.defineProperty(Gd, "__esModule", { value: true });
      Gd.LangiumGrammarSemanticTokenProvider = void 0;
      var ho = xe(), TK = Ud(), mo = we(), Dy = class extends TK.AbstractSemanticTokenProvider {
        highlightElement(e, r) {
          var n;
          (0, mo.isAssignment)(e) ? r({ node: e, property: "feature", type: ho.SemanticTokenTypes.property }) : (0, mo.isAction)(e) ? e.feature && r({ node: e, property: "feature", type: ho.SemanticTokenTypes.property }) : (0, mo.isReturnType)(e) ? r({ node: e, property: "name", type: ho.SemanticTokenTypes.type }) : (0, mo.isSimpleType)(e) ? (e.primitiveType || e.typeRef) && r({ node: e, property: e.primitiveType ? "primitiveType" : "typeRef", type: ho.SemanticTokenTypes.type }) : (0, mo.isParameter)(e) ? r({ node: e, property: "name", type: ho.SemanticTokenTypes.parameter }) : (0, mo.isParameterReference)(e) ? r({ node: e, property: "parameter", type: ho.SemanticTokenTypes.parameter }) : (0, mo.isRuleCall)(e) ? !((n = e.rule.ref) === null || n === void 0) && n.fragment && r({ node: e, property: "rule", type: ho.SemanticTokenTypes.type }) : (0, mo.isTypeAttribute)(e) && r({ node: e, property: "name", type: ho.SemanticTokenTypes.property });
        }
      };
      Gd.LangiumGrammarSemanticTokenProvider = Dy;
    });
    var AA = f((Hd) => {
      Object.defineProperty(Hd, "__esModule", { value: true });
      Hd.LangiumGrammarNameProvider = void 0;
      var _K = rs(), RK = yt(), SA = we(), Iy = class extends _K.DefaultNameProvider {
        getName(e) {
          return (0, SA.isAssignment)(e) ? e.feature : super.getName(e);
        }
        getNameNode(e) {
          return (0, SA.isAssignment)(e) ? (0, RK.findNodeForProperty)(e.$cstNode, "feature") : super.getNameNode(e);
        }
      };
      Hd.LangiumGrammarNameProvider = Iy;
    });
    var Bd = f((Wd) => {
      Object.defineProperty(Wd, "__esModule", { value: true });
      Wd.DefaultReferences = void 0;
      var bK = yt(), PA = Zt(), SK = be(), CA = Le(), AK = $t(), PK = ki(), xy = class {
        constructor(e) {
          this.nameProvider = e.references.NameProvider, this.index = e.shared.workspace.IndexManager, this.nodeLocator = e.workspace.AstNodeLocator;
        }
        findDeclaration(e) {
          if (e) {
            let r = (0, bK.findAssignment)(e), n = e.element;
            if (r && n) {
              let i = n[r.feature];
              if ((0, PA.isReference)(i))
                return i.ref;
              if (Array.isArray(i)) {
                for (let o of i)
                  if ((0, PA.isReference)(o) && o.$refNode && o.$refNode.offset <= e.offset && o.$refNode.end >= e.end)
                    return o.ref;
              }
            }
            if (n) {
              let i = this.nameProvider.getNameNode(n);
              if (i && (i === e || (0, CA.isCstChildNode)(e, i)))
                return n;
            }
          }
        }
        findDeclarationNode(e) {
          let r = this.findDeclaration(e);
          if (r == null ? void 0 : r.$cstNode) {
            let n = this.nameProvider.getNameNode(r);
            return n ?? r.$cstNode;
          }
        }
        findReferences(e, r) {
          let n = [];
          if (r.includeDeclaration) {
            let o = this.getReferenceToSelf(e);
            o && n.push(o);
          }
          let i = this.index.findAllReferences(e, this.nodeLocator.getAstNodePath(e));
          return r.documentUri && (i = i.filter((o) => (0, PK.equalURI)(o.sourceUri, r.documentUri))), n.push(...i), (0, AK.stream)(n);
        }
        getReferenceToSelf(e) {
          let r = this.nameProvider.getNameNode(e);
          if (r) {
            let n = (0, SK.getDocument)(e), i = this.nodeLocator.getAstNodePath(e);
            return { sourceUri: n.uri, sourcePath: i, targetUri: n.uri, targetPath: i, segment: (0, CA.toDocumentSegment)(r), local: true };
          }
        }
      };
      Wd.DefaultReferences = xy;
    });
    var OA = f((Kd) => {
      Object.defineProperty(Kd, "__esModule", { value: true });
      Kd.LangiumGrammarReferences = void 0;
      var CK = Bd(), bn = be(), NA = Le(), EA = yt(), NK = $t(), kA = ki(), Sn = we(), wA = Ft(), qy = es(), Ly = class extends CK.DefaultReferences {
        constructor(e) {
          super(e), this.documents = e.shared.workspace.LangiumDocuments;
        }
        findDeclaration(e) {
          let r = e.element, n = (0, EA.findAssignment)(e);
          if (n && n.feature === "feature") {
            if ((0, Sn.isAssignment)(r))
              return this.findAssignmentDeclaration(r);
            if ((0, Sn.isAction)(r))
              return this.findActionDeclaration(r);
          }
          return super.findDeclaration(e);
        }
        findReferences(e, r) {
          var n;
          return (0, Sn.isTypeAttribute)(e) ? this.findReferencesToTypeAttribute(e, (n = r.includeDeclaration) !== null && n !== void 0 ? n : false) : super.findReferences(e, r);
        }
        findReferencesToTypeAttribute(e, r) {
          let n = [], i = (0, bn.getContainerOfType)(e, Sn.isInterface);
          if (i) {
            if (r) {
              let s = this.getReferenceToSelf(e);
              s && n.push(s);
            }
            let o = (0, qy.collectChildrenTypes)(i, this, this.documents, this.nodeLocator), a = [];
            o.forEach((s) => {
              let u = this.findRulesWithReturnType(s);
              a.push(...u);
            }), a.forEach((s) => {
              let u = this.createReferencesToAttribute(s, e);
              n.push(...u);
            });
          }
          return (0, NK.stream)(n);
        }
        createReferencesToAttribute(e, r) {
          let n = [];
          if ((0, Sn.isParserRule)(e)) {
            let i = (0, wA.extractAssignments)(e.definition).find((o) => o.feature === r.name);
            if (i == null ? void 0 : i.$cstNode) {
              let o = this.nameProvider.getNameNode(i);
              o && n.push({ sourceUri: (0, bn.getDocument)(i).uri, sourcePath: this.nodeLocator.getAstNodePath(i), targetUri: (0, bn.getDocument)(r).uri, targetPath: this.nodeLocator.getAstNodePath(r), segment: (0, NA.toDocumentSegment)(o), local: (0, kA.equalURI)((0, bn.getDocument)(i).uri, (0, bn.getDocument)(r).uri) });
            }
          } else {
            if (e.feature === r.name) {
              let o = (0, EA.findNodeForProperty)(e.$cstNode, "feature");
              o && n.push({ sourceUri: (0, bn.getDocument)(e).uri, sourcePath: this.nodeLocator.getAstNodePath(e), targetUri: (0, bn.getDocument)(r).uri, targetPath: this.nodeLocator.getAstNodePath(r), segment: (0, NA.toDocumentSegment)(o), local: (0, kA.equalURI)((0, bn.getDocument)(e).uri, (0, bn.getDocument)(r).uri) });
            }
            let i = (0, bn.getContainerOfType)(e, Sn.isParserRule);
            n.push(...this.createReferencesToAttribute(i, r));
          }
          return n;
        }
        findAssignmentDeclaration(e) {
          var r;
          let n = (0, bn.getContainerOfType)(e, Sn.isParserRule), i = (0, wA.getActionAtElement)(e);
          if (i) {
            let o = this.findActionDeclaration(i, e.feature);
            if (o)
              return o;
          }
          if (!((r = n == null ? void 0 : n.returnType) === null || r === void 0) && r.ref && ((0, Sn.isInterface)(n.returnType.ref) || (0, Sn.isType)(n.returnType.ref))) {
            let o = (0, qy.collectSuperTypes)(n.returnType.ref);
            for (let a of o) {
              let s = a.attributes.find((u) => u.name === e.feature);
              if (s)
                return s;
            }
          }
          return e;
        }
        findActionDeclaration(e, r) {
          var n;
          if (!((n = e.type) === null || n === void 0) && n.ref) {
            let i = r ?? e.feature, o = (0, qy.collectSuperTypes)(e.type.ref);
            for (let a of o) {
              let s = a.attributes.find((u) => u.name === i);
              if (s)
                return s;
            }
          }
        }
        findRulesWithReturnType(e) {
          let r = [];
          return this.index.findAllReferences(e, this.nodeLocator.getAstNodePath(e)).forEach((i) => {
            let o = this.documents.getOrCreateDocument(i.sourceUri), a = this.nodeLocator.getAstNode(o.parseResult.value, i.sourcePath);
            ((0, Sn.isParserRule)(a) || (0, Sn.isAction)(a)) && r.push(a);
          }), r;
        }
      };
      Kd.LangiumGrammarReferences = Ly;
    });
    var Fy = f((Vr) => {
      var EK = Vr && Vr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), kK = Vr && Vr.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), wK = Vr && Vr.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && EK(e, t, r);
        return kK(e, t), e;
      };
      Object.defineProperty(Vr, "__esModule", { value: true });
      Vr.findFirstFeatures = Vr.findNextFeatures = void 0;
      var tr = wK(we()), wi = Ft(), OK = Zt(), DK = be(), IK = yt();
      function xK(t, e) {
        let r = { stacks: t, tokens: e };
        return qK(r), r.stacks.flat().forEach((i) => {
          i.property = void 0;
        }), xA(r.stacks).map((i) => i[i.length - 1]);
      }
      Vr.findNextFeatures = xK;
      function My(t) {
        let { next: e, cardinalities: r, visited: n, plus: i } = t, o = [], a = e.feature;
        if (n.has(a))
          return [];
        n.add(a);
        let s, u = a;
        for (; u.$container; )
          if (tr.isGroup(u.$container)) {
            s = u.$container;
            break;
          } else if (tr.isAbstractElement(u.$container))
            u = u.$container;
          else
            break;
        if ((0, wi.isArrayCardinality)(u.cardinality)) {
          let c = ls({ next: { feature: u, type: e.type, new: false }, cardinalities: r, visited: n, plus: i });
          for (let l of c)
            i.add(l.feature);
          o.push(...c);
        }
        if (s) {
          let c = s.elements.indexOf(u);
          c !== void 0 && c < s.elements.length - 1 && o.push(...IA({ feature: s, type: e.type, new: false }, c + 1, r, n, i)), o.every((l) => (0, wi.isOptionalCardinality)(l.feature.cardinality) || (0, wi.isOptionalCardinality)(r.get(l.feature)) || i.has(l.feature)) && o.push(...My({ next: { feature: s, type: e.type, new: false }, cardinalities: r, visited: n, plus: i }));
        }
        return o;
      }
      function DA(t) {
        return (0, OK.isAstNode)(t) && (t = { feature: t }), ls({ next: t, cardinalities: /* @__PURE__ */ new Map(), visited: /* @__PURE__ */ new Set(), plus: /* @__PURE__ */ new Set() });
      }
      Vr.findFirstFeatures = DA;
      function ls(t) {
        var e, r, n;
        let { next: i, cardinalities: o, visited: a, plus: s } = t;
        if (i === void 0)
          return [];
        let { feature: u, type: c } = i;
        if (tr.isGroup(u)) {
          if (a.has(u))
            return [];
          a.add(u);
        }
        if (tr.isGroup(u))
          return IA(i, 0, o, a, s).map((l) => zd(l, u.cardinality, o));
        if (tr.isAlternatives(u) || tr.isUnorderedGroup(u))
          return u.elements.flatMap((l) => ls({ next: { feature: l, new: false, type: c }, cardinalities: o, visited: a, plus: s })).map((l) => zd(l, u.cardinality, o));
        if (tr.isAssignment(u)) {
          let l = { feature: u.terminal, new: false, type: c, property: (e = i.property) !== null && e !== void 0 ? e : u.feature };
          return ls({ next: l, cardinalities: o, visited: a, plus: s }).map((d) => zd(d, u.cardinality, o));
        } else {
          if (tr.isAction(u))
            return My({ next: { feature: u, new: true, type: (0, wi.getTypeName)(u), property: (r = i.property) !== null && r !== void 0 ? r : u.feature }, cardinalities: o, visited: a, plus: s });
          if (tr.isRuleCall(u) && tr.isParserRule(u.rule.ref)) {
            let l = u.rule.ref, d = { feature: l.definition, new: true, type: l.fragment ? void 0 : (n = (0, wi.getExplicitRuleType)(l)) !== null && n !== void 0 ? n : l.name, property: i.property };
            return ls({ next: d, cardinalities: o, visited: a, plus: s }).map((h) => zd(h, u.cardinality, o));
          } else
            return [i];
        }
      }
      function zd(t, e, r) {
        return r.set(t.feature, e), t;
      }
      function IA(t, e, r, n, i) {
        var o;
        let a = [], s;
        for (; e < t.feature.elements.length && (s = { feature: t.feature.elements[e++], new: false, type: t.type }, a.push(...ls({ next: s, cardinalities: r, visited: n, plus: i })), !!(0, wi.isOptionalCardinality)((o = s.feature.cardinality) !== null && o !== void 0 ? o : r.get(s.feature))); )
          ;
        return a;
      }
      function qK(t) {
        for (let e of t.tokens) {
          let r = xA(t.stacks, e);
          t.stacks = r;
        }
      }
      function xA(t, e) {
        let r = [];
        for (let n of t)
          r.push(...LK(n, e));
        return r;
      }
      function LK(t, e) {
        let r = /* @__PURE__ */ new Map(), n = new Set(t.map((o) => o.feature).filter(MK)), i = [];
        for (; t.length > 0; ) {
          let o = t.pop(), a = My({ next: o, cardinalities: r, plus: n, visited: /* @__PURE__ */ new Set() }).filter((s) => e ? $y(s.feature, e) : true);
          for (let s of a)
            i.push([...t, s]);
          if (!a.every((s) => (0, wi.isOptionalCardinality)(s.feature.cardinality) || (0, wi.isOptionalCardinality)(r.get(s.feature))))
            break;
        }
        return i;
      }
      function MK(t) {
        if (t.cardinality === "+")
          return true;
        let e = (0, DK.getContainerOfType)(t, tr.isAssignment);
        return !!(e && e.cardinality === "+");
      }
      function $y(t, e) {
        if (tr.isKeyword(t))
          return t.value === e.image;
        if (tr.isRuleCall(t))
          return $K(t.rule.ref, e);
        if (tr.isCrossReference(t)) {
          let r = (0, IK.getCrossReferenceTerminal)(t);
          if (r)
            return $y(r, e);
        }
        return false;
      }
      function $K(t, e) {
        return tr.isParserRule(t) ? DA(t.definition).some((n) => $y(n.feature, e)) : tr.isTerminalRule(t) ? new RegExp((0, wi.terminalRegex)(t)).test(e.image) : false;
      }
    });
    var Yd = f((Yr) => {
      var FK = Yr && Yr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), jK = Yr && Yr.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), UK = Yr && Yr.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && FK(e, t, r);
        return jK(e, t), e;
      };
      Object.defineProperty(Yr, "__esModule", { value: true });
      Yr.DefaultCompletionProvider = Yr.mergeCompletionProviderOptions = void 0;
      var ac = xe(), sc = UK(we()), GK = Ft(), HK = be(), qA = Le(), LA = yt(), jy = $t(), Vd = Fy();
      function WK(t) {
        let e = Array.from(new Set(t.flatMap((n) => {
          var i;
          return (i = n == null ? void 0 : n.triggerCharacters) !== null && i !== void 0 ? i : [];
        }))), r = Array.from(new Set(t.flatMap((n) => {
          var i;
          return (i = n == null ? void 0 : n.allCommitCharacters) !== null && i !== void 0 ? i : [];
        })));
        return { triggerCharacters: e.length > 0 ? e : void 0, allCommitCharacters: r.length > 0 ? r : void 0 };
      }
      Yr.mergeCompletionProviderOptions = WK;
      var Uy = class {
        constructor(e) {
          this.scopeProvider = e.references.ScopeProvider, this.grammar = e.Grammar, this.completionParser = e.parser.CompletionParser, this.nameProvider = e.references.NameProvider, this.grammarConfig = e.parser.GrammarConfig;
        }
        async getCompletion(e, r) {
          var n, i;
          let a = e.parseResult.value.$cstNode;
          if (!a)
            return;
          let s = [], u = e.textDocument, c = u.getText(), l = u.offsetAt(r.position), d = (L) => {
            let W = this.fillCompletionItem(u, l, L);
            W && s.push(W);
          }, h = this.backtrackToAnyToken(c, l), y = (n = (0, qA.findLeafNodeAtOffset)(a, h)) === null || n === void 0 ? void 0 : n.element, m = { document: e, textDocument: u, node: y, offset: l, position: r.position };
          if (!y) {
            let L = (0, LA.getEntryRule)(this.grammar);
            return await this.completionForRule(m, L, d), ac.CompletionList.create(this.deduplicateItems(s), true);
          }
          let R = [m];
          if (h === l && h > 0) {
            let L = (i = (0, qA.findLeafNodeAtOffset)(a, h - 1)) === null || i === void 0 ? void 0 : i.element;
            L !== y && R.push({ document: e, textDocument: u, node: L, offset: l, position: r.position });
          }
          let C = this.backtrackToTokenStart(c, l), N = this.findFeaturesAt(u, C), S = [], b = this.canReparse() && l !== C;
          b && (S = this.findFeaturesAt(u, l));
          let O = (L) => sc.isKeyword(L.feature) ? L.feature.value : L.feature;
          return await Promise.all((0, jy.stream)(N).distinct(O).map((L) => this.completionForContexts(R, L, d))), b && await Promise.all((0, jy.stream)(S).exclude(N, O).distinct(O).map((L) => this.completionForContexts(R, L, d))), ac.CompletionList.create(this.deduplicateItems(s), true);
        }
        deduplicateItems(e) {
          return (0, jy.stream)(e).distinct((r) => `${r.kind}_${r.label}_${r.detail}`).toArray();
        }
        canReparse() {
          return false;
        }
        findFeaturesAt(e, r) {
          let n = e.getText({ start: ac.Position.create(0, 0), end: e.positionAt(r) }), i = this.completionParser.parse(n), o = i.tokens;
          if (i.tokenIndex === 0) {
            let u = (0, LA.getEntryRule)(this.grammar), c = (0, Vd.findFirstFeatures)({ feature: u.definition, new: true, type: (0, GK.getExplicitRuleType)(u) });
            return o.length > 0 ? (o.shift(), (0, Vd.findNextFeatures)(c.map((l) => [l]), o)) : c;
          }
          let a = [...o].splice(i.tokenIndex);
          return (0, Vd.findNextFeatures)([i.elementStack.map((u) => ({ feature: u }))], a);
        }
        backtrackToAnyToken(e, r) {
          for (r >= e.length && (r = e.length - 1); r > 0 && /\s/.test(e.charAt(r)); )
            r--;
          return r;
        }
        backtrackToTokenStart(e, r) {
          if (r < 1)
            return r;
          let n = this.grammarConfig.nameRegexp, i = e.charAt(r - 1);
          for (; r > 0 && n.test(i); )
            r--, i = e.charAt(r - 1);
          return r;
        }
        async completionForRule(e, r, n) {
          if (sc.isParserRule(r)) {
            let i = (0, Vd.findFirstFeatures)(r.definition);
            await Promise.all(i.map((o) => this.completionFor(e, o, n)));
          }
        }
        async completionForContexts(e, r, n) {
          for (let i of e)
            await this.completionFor(i, r, n);
        }
        completionFor(e, r, n) {
          if (sc.isKeyword(r.feature))
            return this.completionForKeyword(e, r.feature, n);
          if (sc.isCrossReference(r.feature) && e.node)
            return this.completionForCrossReference(e, r, n);
        }
        completionForCrossReference(e, r, n) {
          let i = (0, HK.getContainerOfType)(r.feature, sc.isAssignment), o = e.node;
          if (i && o) {
            if (r.type && (r.new || o.$type !== r.type) && (o = { $type: r.type, $container: o, $containerProperty: r.property }), !e)
              return;
            let a = { reference: {}, container: o, property: i.feature };
            try {
              let s = this.scopeProvider.getScope(a), u = /* @__PURE__ */ new Set();
              s.getAllElements().forEach((c) => {
                !u.has(c.name) && this.filterCrossReference(c) && (n(this.createReferenceCompletionItem(c)), u.add(c.name));
              });
            } catch (s) {
              console.error(s);
            }
          }
        }
        createReferenceCompletionItem(e) {
          return { nodeDescription: e, kind: ac.CompletionItemKind.Reference, detail: e.type, sortText: "0" };
        }
        filterCrossReference(e) {
          return true;
        }
        completionForKeyword(e, r, n) {
          r.value.match(/[\w]/) && n({ label: r.value, kind: ac.CompletionItemKind.Keyword, detail: "Keyword", sortText: "1" });
        }
        fillCompletionItem(e, r, n) {
          var i, o;
          let a;
          if (typeof n.label == "string")
            a = n.label;
          else if ("node" in n) {
            let l = this.nameProvider.getName(n.node);
            if (!l)
              return;
            a = l;
          } else if ("nodeDescription" in n)
            a = n.nodeDescription.name;
          else
            return;
          let s;
          typeof ((i = n.textEdit) === null || i === void 0 ? void 0 : i.newText) == "string" ? s = n.textEdit.newText : typeof n.insertText == "string" ? s = n.insertText : s = a;
          let u = (o = n.textEdit) !== null && o !== void 0 ? o : this.buildCompletionTextEdit(e, r, a, s);
          return u ? { additionalTextEdits: n.additionalTextEdits, command: n.command, commitCharacters: n.commitCharacters, data: n.data, detail: n.detail, documentation: n.documentation, filterText: n.filterText, insertText: n.insertText, insertTextFormat: n.insertTextFormat, insertTextMode: n.insertTextMode, kind: n.kind, labelDetails: n.labelDetails, preselect: n.preselect, sortText: n.sortText, tags: n.tags, textEditText: n.textEditText, textEdit: u, label: a } : void 0;
        }
        buildCompletionTextEdit(e, r, n, i) {
          let o = e.getText(), a = this.backtrackToTokenStart(o, r), s = o.substring(a, r);
          if (this.charactersFuzzyMatch(s, n)) {
            let u = e.positionAt(a), c = e.positionAt(r);
            return { newText: i, range: { start: u, end: c } };
          } else
            return;
        }
        isWordCharacterAt(e, r) {
          return this.grammarConfig.nameRegexp.test(e.charAt(r));
        }
        charactersFuzzyMatch(e, r) {
          if (e.length === 0)
            return true;
          r = r.toLowerCase();
          let n = false, i, o = 0, a = r.length;
          for (let s = 0; s < a; s++) {
            let u = r.charCodeAt(s), c = e.charCodeAt(o);
            if ((u === c || this.toUpperCharCode(u) === this.toUpperCharCode(c)) && (n || (n = i === void 0 || this.isWordTransition(i, u)), n && o++, o === e.length))
              return true;
            i = u;
          }
          return false;
        }
        isWordTransition(e, r) {
          return MA <= e && e <= $A && BK <= r && r <= KK || e === FA && r !== FA;
        }
        toUpperCharCode(e) {
          return MA <= e && e <= $A ? e - 32 : e;
        }
      };
      Yr.DefaultCompletionProvider = Uy;
      var MA = "a".charCodeAt(0), $A = "z".charCodeAt(0), BK = "A".charCodeAt(0), KK = "Z".charCodeAt(0), FA = "_".charCodeAt(0);
    });
    var Wy = f((Xd) => {
      Object.defineProperty(Xd, "__esModule", { value: true });
      Xd.AbstractCallHierarchyProvider = void 0;
      var zK = xe(), jA = vn(), Gy = Le(), Hy = class {
        constructor(e) {
          this.grammarConfig = e.parser.GrammarConfig, this.nameProvider = e.references.NameProvider, this.documents = e.shared.workspace.LangiumDocuments, this.references = e.references.References;
        }
        prepareCallHierarchy(e, r) {
          let n = e.parseResult.value, i = (0, Gy.findDeclarationNodeAtOffset)(n.$cstNode, e.textDocument.offsetAt(r.position), this.grammarConfig.nameRegexp);
          if (!i)
            return;
          let o = this.references.findDeclarationNode(i);
          if (o)
            return this.getCallHierarchyItems(o.element, e);
        }
        getCallHierarchyItems(e, r) {
          let n = this.nameProvider.getNameNode(e), i = this.nameProvider.getName(e);
          if (!(!n || !e.$cstNode || i === void 0))
            return [Object.assign({ kind: zK.SymbolKind.Method, name: i, range: e.$cstNode.range, selectionRange: n.range, uri: r.uri.toString() }, this.getCallHierarchyItem(e))];
        }
        getCallHierarchyItem(e) {
        }
        incomingCalls(e) {
          let r = this.documents.getOrCreateDocument(jA.URI.parse(e.item.uri)), n = r.parseResult.value, i = (0, Gy.findDeclarationNodeAtOffset)(n.$cstNode, r.textDocument.offsetAt(e.item.range.start), this.grammarConfig.nameRegexp);
          if (!i)
            return;
          let o = this.references.findReferences(i.element, { includeDeclaration: false });
          return this.getIncomingCalls(i.element, o);
        }
        outgoingCalls(e) {
          let r = this.documents.getOrCreateDocument(jA.URI.parse(e.item.uri)), n = r.parseResult.value, i = (0, Gy.findDeclarationNodeAtOffset)(n.$cstNode, r.textDocument.offsetAt(e.item.range.start), this.grammarConfig.nameRegexp);
          if (i)
            return this.getOutgoingCalls(i.element);
        }
      };
      Xd.AbstractCallHierarchyProvider = Hy;
    });
    var GA = f((UA) => {
      Object.defineProperty(UA, "__esModule", { value: true });
    });
    var WA = f((HA) => {
      Object.defineProperty(HA, "__esModule", { value: true });
    });
    var KA = f((BA) => {
      Object.defineProperty(BA, "__esModule", { value: true });
    });
    var Ky = f((Jd) => {
      Object.defineProperty(Jd, "__esModule", { value: true });
      Jd.DefaultDefinitionProvider = void 0;
      var VK = xe(), YK = be(), XK = Le(), By = class {
        constructor(e) {
          this.nameProvider = e.references.NameProvider, this.references = e.references.References, this.grammarConfig = e.parser.GrammarConfig;
        }
        getDefinition(e, r) {
          let n = e.parseResult.value;
          if (n.$cstNode) {
            let i = n.$cstNode, o = (0, XK.findDeclarationNodeAtOffset)(i, e.textDocument.offsetAt(r.position), this.grammarConfig.nameRegexp);
            if (o)
              return this.collectLocationLinks(o, r);
          }
        }
        collectLocationLinks(e, r) {
          var n;
          let i = this.findLink(e);
          if (i)
            return [VK.LocationLink.create(i.targetDocument.textDocument.uri, ((n = i.target.element.$cstNode) !== null && n !== void 0 ? n : i.target).range, i.target.range, i.source.range)];
        }
        findLink(e) {
          let r = this.references.findDeclarationNode(e);
          if (r == null ? void 0 : r.element) {
            let n = (0, YK.getDocument)(r.element);
            if (r && n)
              return { source: e, target: r, targetDocument: n };
          }
        }
      };
      Jd.DefaultDefinitionProvider = By;
    });
    var Vy = f((Qd) => {
      Object.defineProperty(Qd, "__esModule", { value: true });
      Qd.DefaultDocumentHighlightProvider = void 0;
      var JK = xe(), QK = be(), ZK = Le(), ez = ki(), zy = class {
        constructor(e) {
          this.references = e.references.References, this.nameProvider = e.references.NameProvider, this.grammarConfig = e.parser.GrammarConfig;
        }
        getDocumentHighlight(e, r) {
          let n = e.parseResult.value.$cstNode;
          if (!n)
            return;
          let i = (0, ZK.findDeclarationNodeAtOffset)(n, e.textDocument.offsetAt(r.position), this.grammarConfig.nameRegexp);
          if (!i)
            return;
          let o = this.references.findDeclaration(i);
          if (o) {
            let a = (0, ez.equalURI)((0, QK.getDocument)(o).uri, e.uri), s = { documentUri: e.uri, includeDeclaration: a };
            return this.references.findReferences(o, s).map((c) => this.createDocumentHighlight(c)).toArray();
          }
        }
        createDocumentHighlight(e) {
          return JK.DocumentHighlight.create(e.segment.range);
        }
      };
      Qd.DefaultDocumentHighlightProvider = zy;
    });
    var VA = f((zA) => {
      Object.defineProperty(zA, "__esModule", { value: true });
    });
    var Xy = f((Zd) => {
      Object.defineProperty(Zd, "__esModule", { value: true });
      Zd.DefaultDocumentSymbolProvider = void 0;
      var tz = xe(), rz = be(), Yy = class {
        constructor(e) {
          this.nameProvider = e.references.NameProvider;
        }
        getSymbols(e) {
          return this.getSymbol(e, e.parseResult.value);
        }
        getSymbol(e, r) {
          let n = r.$cstNode, i = this.nameProvider.getNameNode(r);
          if (i && n) {
            let o = this.nameProvider.getName(r);
            return [{ kind: this.getSymbolKind(r.$type), name: o ?? i.text, range: n.range, selectionRange: i.range, children: this.getChildSymbols(e, r) }];
          } else
            return this.getChildSymbols(e, r) || [];
        }
        getChildSymbols(e, r) {
          let n = [];
          for (let i of (0, rz.streamContents)(r)) {
            let o = this.getSymbol(e, i);
            n.push(...o);
          }
          if (n.length > 0)
            return n;
        }
        getSymbolKind(e) {
          return tz.SymbolKind.Field;
        }
      };
      Zd.DefaultDocumentSymbolProvider = Yy;
    });
    var YA = f((ef) => {
      Object.defineProperty(ef, "__esModule", { value: true });
      ef.AbstractExecuteCommandHandler = void 0;
      var nz = xe(), Jy = class {
        get commands() {
          return Array.from(this.registeredCommands.keys());
        }
        constructor() {
          this.registeredCommands = /* @__PURE__ */ new Map(), this.registerCommands(this.createCommandAcceptor());
        }
        async executeCommand(e, r, n = nz.CancellationToken.None) {
          let i = this.registeredCommands.get(e);
          if (i)
            return i(r, n);
        }
        createCommandAcceptor() {
          return (e, r) => this.registeredCommands.set(e, r);
        }
      };
      ef.AbstractExecuteCommandHandler = Jy;
    });
    var Zy = f((ds) => {
      Object.defineProperty(ds, "__esModule", { value: true });
      ds.MultilineCommentHoverProvider = ds.AstNodeHoverProvider = void 0;
      var iz = Le(), tf = class {
        constructor(e) {
          this.references = e.references.References, this.grammarConfig = e.parser.GrammarConfig;
        }
        getHoverContent(e, r) {
          var n, i;
          let o = (i = (n = e.parseResult) === null || n === void 0 ? void 0 : n.value) === null || i === void 0 ? void 0 : i.$cstNode;
          if (o) {
            let a = e.textDocument.offsetAt(r.position), s = (0, iz.findDeclarationNodeAtOffset)(o, a, this.grammarConfig.nameRegexp);
            if (s && s.offset + s.length > a) {
              let u = this.references.findDeclaration(s);
              if (u)
                return this.getAstNodeHoverContent(u);
            }
          }
        }
      };
      ds.AstNodeHoverProvider = tf;
      var Qy = class extends tf {
        constructor(e) {
          super(e), this.documentationProvider = e.documentation.DocumentationProvider;
        }
        getAstNodeHoverContent(e) {
          let r = this.documentationProvider.getDocumentation(e);
          if (r)
            return { contents: { kind: "markdown", value: r } };
        }
      };
      ds.MultilineCommentHoverProvider = Qy;
    });
    var XA = f((rf) => {
      Object.defineProperty(rf, "__esModule", { value: true });
      rf.AbstractGoToImplementationProvider = void 0;
      var oz = xe(), az = Le(), ev = class {
        constructor(e) {
          this.references = e.references.References, this.grammarConfig = e.parser.GrammarConfig;
        }
        getImplementation(e, r, n = oz.CancellationToken.None) {
          let i = e.parseResult.value;
          if (i.$cstNode) {
            let o = (0, az.findDeclarationNodeAtOffset)(i.$cstNode, e.textDocument.offsetAt(r.position), this.grammarConfig.nameRegexp);
            if (o) {
              let a = this.references.findDeclaration(o);
              if (a)
                return this.collectGoToImplementationLocationLinks(a, n);
            }
          }
        }
      };
      rf.AbstractGoToImplementationProvider = ev;
    });
    var JA = f((nf) => {
      Object.defineProperty(nf, "__esModule", { value: true });
      nf.AbstractInlayHintProvider = void 0;
      var sz = xe(), uz = be(), cz = vr(), tv = class {
        async getInlayHints(e, r, n = sz.CancellationToken.None) {
          let i = e.parseResult.value, o = [], a = (s) => o.push(s);
          for (let s of (0, uz.streamAst)(i, { range: r.range }))
            await (0, cz.interruptAndCheck)(n), this.computeInlayHint(s, a);
          return o;
        }
      };
      nf.AbstractInlayHintProvider = tv;
    });
    var go = f((Oi) => {
      Object.defineProperty(Oi, "__esModule", { value: true });
      Oi.DefaultLangiumDocuments = Oi.DefaultLangiumDocumentFactory = Oi.DocumentState = void 0;
      var lz = ag(), dz = vn(), fz = $t(), fs;
      (function(t) {
        t[t.Changed = 0] = "Changed", t[t.Parsed = 1] = "Parsed", t[t.IndexedContent = 2] = "IndexedContent", t[t.ComputedScopes = 3] = "ComputedScopes", t[t.Linked = 4] = "Linked", t[t.IndexedReferences = 5] = "IndexedReferences", t[t.Validated = 6] = "Validated";
      })(fs = Oi.DocumentState || (Oi.DocumentState = {}));
      var rv = class {
        constructor(e) {
          this.serviceRegistry = e.ServiceRegistry, this.textDocuments = e.workspace.TextDocuments, this.fileSystemProvider = e.workspace.FileSystemProvider;
        }
        fromTextDocument(e, r) {
          return this.create(r ?? dz.URI.parse(e.uri), e);
        }
        fromString(e, r) {
          return this.create(r, e);
        }
        fromModel(e, r) {
          return this.create(r, { $model: e });
        }
        create(e, r) {
          if (r ?? (r = this.textDocuments.get(e.toString())), r ?? (r = this.getContentFromFileSystem(e)), typeof r == "string") {
            let n = this.parse(e, r);
            return this.createLangiumDocument(n, e, void 0, r);
          } else if ("$model" in r) {
            let n = { value: r.$model, parserErrors: [], lexerErrors: [] };
            return this.createLangiumDocument(n, e);
          } else {
            let n = this.parse(e, r.getText());
            return this.createLangiumDocument(n, e, r);
          }
        }
        createLangiumDocument(e, r, n, i) {
          let o;
          if (n)
            o = { parseResult: e, uri: r, state: fs.Parsed, references: [], textDocument: n };
          else {
            let a = this.createTextDocumentGetter(r, i);
            o = { parseResult: e, uri: r, state: fs.Parsed, references: [], get textDocument() {
              return a();
            } };
          }
          return e.value.$document = o, o;
        }
        update(e) {
          let r = this.textDocuments.get(e.uri.toString()), n = r ? r.getText() : this.getContentFromFileSystem(e.uri);
          if (r)
            Object.defineProperty(e, "textDocument", { value: r });
          else {
            let i = this.createTextDocumentGetter(e.uri, n);
            Object.defineProperty(e, "textDocument", { get: i });
          }
          return e.parseResult = this.parse(e.uri, n), e.parseResult.value.$document = e, e.state = fs.Parsed, e;
        }
        getContentFromFileSystem(e) {
          return this.fileSystemProvider.readFileSync(e);
        }
        parse(e, r) {
          return this.serviceRegistry.getServices(e).parser.LangiumParser.parse(r);
        }
        createTextDocumentGetter(e, r) {
          let n = this.serviceRegistry, i;
          return () => i ?? (i = lz.TextDocument.create(e.toString(), n.getServices(e).LanguageMetaData.languageId, 0, r ?? ""));
        }
      };
      Oi.DefaultLangiumDocumentFactory = rv;
      var nv = class {
        constructor(e) {
          this.documentMap = /* @__PURE__ */ new Map(), this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory;
        }
        get all() {
          return (0, fz.stream)(this.documentMap.values());
        }
        addDocument(e) {
          let r = e.uri.toString();
          if (this.documentMap.has(r))
            throw new Error(`A document with the URI '${r}' is already present.`);
          this.documentMap.set(r, e);
        }
        getOrCreateDocument(e) {
          let r = e.toString(), n = this.documentMap.get(r);
          return n || (n = this.langiumDocumentFactory.create(e), this.documentMap.set(r, n), n);
        }
        hasDocument(e) {
          return this.documentMap.has(e.toString());
        }
        invalidateDocument(e) {
          let r = e.toString(), n = this.documentMap.get(r);
          return n && (n.state = fs.Changed, n.references = [], n.precomputedScopes = void 0, n.diagnostics = []), n;
        }
        deleteDocument(e) {
          let r = e.toString(), n = this.documentMap.get(r);
          return n && (n.state = fs.Changed, this.documentMap.delete(r)), n;
        }
      };
      Oi.DefaultLangiumDocuments = nv;
    });
    var ov = f((ps) => {
      Object.defineProperty(ps, "__esModule", { value: true });
      ps.mergeSignatureHelpOptions = ps.AbstractSignatureHelpProvider = void 0;
      var pz = xe(), hz = Le(), iv = class {
        provideSignatureHelp(e, r, n = pz.CancellationToken.None) {
          let o = e.parseResult.value.$cstNode;
          if (o) {
            let a = (0, hz.findLeafNodeAtOffset)(o, e.textDocument.offsetAt(r.position));
            if (a)
              return this.getSignatureFromElement(a.element, n);
          }
        }
        get signatureHelpOptions() {
          return { triggerCharacters: ["("], retriggerCharacters: [","] };
        }
      };
      ps.AbstractSignatureHelpProvider = iv;
      function mz(t) {
        let e = [], r = [];
        t.forEach((i) => {
          (i == null ? void 0 : i.triggerCharacters) && e.push(...i.triggerCharacters), (i == null ? void 0 : i.retriggerCharacters) && r.push(...i.retriggerCharacters);
        });
        let n = { triggerCharacters: e.length > 0 ? Array.from(new Set(e)).sort() : void 0, retriggerCharacters: r.length > 0 ? Array.from(new Set(r)).sort() : void 0 };
        return n.triggerCharacters ? n : void 0;
      }
      ps.mergeSignatureHelpOptions = mz;
    });
    var uv = f((X) => {
      Object.defineProperty(X, "__esModule", { value: true });
      X.createRequestHandler = X.createServerRequestHandler = X.createCallHierarchyRequestHandler = X.addCallHierarchyHandler = X.addCodeLensHandler = X.addSignatureHelpHandler = X.addDocumentLinkHandler = X.addExecuteCommandHandler = X.addConfigurationChangeHandler = X.addSemanticTokenHandler = X.addInlayHintHandler = X.addRenameHandler = X.addFormattingHandler = X.addFoldingRangeHandler = X.addHoverHandler = X.addDocumentHighlightsHandler = X.addGoToDeclarationHandler = X.addGoToImplementationHandler = X.addGoToTypeDefinitionHandler = X.addGotoDefinitionHandler = X.addDocumentSymbolHandler = X.addCodeActionHandler = X.addFindReferencesHandler = X.addCompletionHandler = X.addDiagnosticsHandler = X.addDocumentsHandler = X.startLanguageServer = X.DefaultLanguageServer = void 0;
      var na = xe(), uc = vn(), QA = zu(), gz = vr(), yz = go(), vz = Yd(), Tz = Ud(), _z = ov(), av = class {
        constructor(e) {
          this.onInitializeEmitter = new na.Emitter(), this.onInitializedEmitter = new na.Emitter(), this.services = e;
        }
        get onInitialize() {
          return this.onInitializeEmitter.event;
        }
        get onInitialized() {
          return this.onInitializedEmitter.event;
        }
        async initialize(e) {
          return this.eagerLoadServices(), this.onInitializeEmitter.fire(e), this.onInitializeEmitter.dispose(), this.buildInitializeResult(e);
        }
        eagerLoadServices() {
          (0, QA.eagerLoad)(this.services), this.services.ServiceRegistry.all.forEach((e) => (0, QA.eagerLoad)(e));
        }
        hasService(e) {
          return this.services.ServiceRegistry.all.some((r) => e(r) !== void 0);
        }
        buildInitializeResult(e) {
          var r;
          let n = this.services.ServiceRegistry.all, i = this.hasService((K) => K.lsp.Formatter), o = n.map((K) => {
            var le;
            return (le = K.lsp.Formatter) === null || le === void 0 ? void 0 : le.formatOnTypeOptions;
          }).find((K) => Boolean(K)), a = this.hasService((K) => K.lsp.CodeActionProvider), s = this.hasService((K) => K.lsp.SemanticTokenProvider), u = (r = this.services.lsp.ExecuteCommandHandler) === null || r === void 0 ? void 0 : r.commands, c = this.services.lsp.DocumentLinkProvider, l = (0, _z.mergeSignatureHelpOptions)(n.map((K) => {
            var le;
            return (le = K.lsp.SignatureHelp) === null || le === void 0 ? void 0 : le.signatureHelpOptions;
          })), d = this.hasService((K) => K.lsp.TypeProvider), h = this.hasService((K) => K.lsp.ImplementationProvider), y = this.hasService((K) => K.lsp.CompletionProvider), m = (0, vz.mergeCompletionProviderOptions)(n.map((K) => {
            var le;
            return (le = K.lsp.CompletionProvider) === null || le === void 0 ? void 0 : le.completionOptions;
          })), R = this.hasService((K) => K.lsp.ReferencesProvider), C = this.hasService((K) => K.lsp.DocumentSymbolProvider), N = this.hasService((K) => K.lsp.DefinitionProvider), S = this.hasService((K) => K.lsp.DocumentHighlightProvider), b = this.hasService((K) => K.lsp.FoldingRangeProvider), O = this.hasService((K) => K.lsp.HoverProvider), L = this.hasService((K) => K.lsp.RenameProvider), W = this.hasService((K) => K.lsp.CallHierarchyProvider), Z = this.services.lsp.CodeLensProvider, Ee = this.hasService((K) => K.lsp.DeclarationProvider), ke = this.services.lsp.InlayHintProvider;
          return { capabilities: { workspace: { workspaceFolders: { supported: true } }, executeCommandProvider: u && { commands: u }, textDocumentSync: na.TextDocumentSyncKind.Incremental, completionProvider: y ? m : void 0, referencesProvider: R, documentSymbolProvider: C, definitionProvider: N, typeDefinitionProvider: d, documentHighlightProvider: S, codeActionProvider: a, documentFormattingProvider: i, documentRangeFormattingProvider: i, documentOnTypeFormattingProvider: o, foldingRangeProvider: b, hoverProvider: O, renameProvider: L ? { prepareProvider: true } : void 0, semanticTokensProvider: s ? Tz.DefaultSemanticTokenOptions : void 0, signatureHelpProvider: l, implementationProvider: h, callHierarchyProvider: W ? {} : void 0, documentLinkProvider: c ? { resolveProvider: Boolean(c.resolveDocumentLink) } : void 0, codeLensProvider: Z ? { resolveProvider: Boolean(Z.resolveCodeLens) } : void 0, declarationProvider: Ee, inlayHintProvider: ke ? { resolveProvider: Boolean(ke.resolveInlayHint) } : void 0 } };
        }
        async initialized(e) {
          this.onInitializedEmitter.fire(e), this.onInitializedEmitter.dispose();
        }
      };
      X.DefaultLanguageServer = av;
      function Rz(t) {
        let e = t.lsp.Connection;
        if (!e)
          throw new Error("Starting a language server requires the languageServer.Connection service to be set.");
        ZA(e, t), eP(e, t), tP(e, t), rP(e, t), iP(e, t), oP(e, t), aP(e, t), sP(e, t), cP(e, t), dP(e, t), fP(e, t), nP(e, t), pP(e, t), lP(e, t), hP(e, t), mP(e, t), yP(e, t), TP(e, t), RP(e, t), _P(e, t), vP(e, t), gP(e, t), uP(e, t), e.onInitialize((n) => t.lsp.LanguageServer.initialize(n)), e.onInitialized((n) => t.lsp.LanguageServer.initialized(n)), t.workspace.TextDocuments.listen(e), e.listen();
      }
      X.startLanguageServer = Rz;
      function ZA(t, e) {
        let r = e.workspace.DocumentBuilder, n = e.workspace.MutexLock;
        function i(a, s) {
          n.lock((u) => r.update(a, s, u));
        }
        e.workspace.TextDocuments.onDidChangeContent((a) => {
          i([uc.URI.parse(a.document.uri)], []);
        }), t.onDidChangeWatchedFiles((a) => {
          let s = [], u = [];
          for (let c of a.changes) {
            let l = uc.URI.parse(c.uri);
            c.type === na.FileChangeType.Deleted ? u.push(l) : s.push(l);
          }
          i(s, u);
        });
      }
      X.addDocumentsHandler = ZA;
      function eP(t, e) {
        e.workspace.DocumentBuilder.onBuildPhase(yz.DocumentState.Validated, async (n, i) => {
          for (let o of n)
            if (o.diagnostics && t.sendDiagnostics({ uri: o.uri.toString(), diagnostics: o.diagnostics }), i.isCancellationRequested)
              return;
        });
      }
      X.addDiagnosticsHandler = eP;
      function tP(t, e) {
        t.onCompletion(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.CompletionProvider) === null || a === void 0 ? void 0 : a.getCompletion(n, i, o);
        }, e));
      }
      X.addCompletionHandler = tP;
      function rP(t, e) {
        t.onReferences(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.ReferencesProvider) === null || a === void 0 ? void 0 : a.findReferences(n, i, o);
        }, e));
      }
      X.addFindReferencesHandler = rP;
      function nP(t, e) {
        t.onCodeAction(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.CodeActionProvider) === null || a === void 0 ? void 0 : a.getCodeActions(n, i, o);
        }, e));
      }
      X.addCodeActionHandler = nP;
      function iP(t, e) {
        t.onDocumentSymbol(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.DocumentSymbolProvider) === null || a === void 0 ? void 0 : a.getSymbols(n, i, o);
        }, e));
      }
      X.addDocumentSymbolHandler = iP;
      function oP(t, e) {
        t.onDefinition(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.DefinitionProvider) === null || a === void 0 ? void 0 : a.getDefinition(n, i, o);
        }, e));
      }
      X.addGotoDefinitionHandler = oP;
      function aP(t, e) {
        t.onTypeDefinition(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.TypeProvider) === null || a === void 0 ? void 0 : a.getTypeDefinition(n, i, o);
        }, e));
      }
      X.addGoToTypeDefinitionHandler = aP;
      function sP(t, e) {
        t.onImplementation(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.ImplementationProvider) === null || a === void 0 ? void 0 : a.getImplementation(n, i, o);
        }, e));
      }
      X.addGoToImplementationHandler = sP;
      function uP(t, e) {
        t.onDeclaration(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.DeclarationProvider) === null || a === void 0 ? void 0 : a.getDeclaration(n, i, o);
        }, e));
      }
      X.addGoToDeclarationHandler = uP;
      function cP(t, e) {
        t.onDocumentHighlight(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.DocumentHighlightProvider) === null || a === void 0 ? void 0 : a.getDocumentHighlight(n, i, o);
        }, e));
      }
      X.addDocumentHighlightsHandler = cP;
      function lP(t, e) {
        t.onHover(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.HoverProvider) === null || a === void 0 ? void 0 : a.getHoverContent(n, i, o);
        }, e));
      }
      X.addHoverHandler = lP;
      function dP(t, e) {
        t.onFoldingRanges(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.FoldingRangeProvider) === null || a === void 0 ? void 0 : a.getFoldingRanges(n, i, o);
        }, e));
      }
      X.addFoldingRangeHandler = dP;
      function fP(t, e) {
        t.onDocumentFormatting(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.Formatter) === null || a === void 0 ? void 0 : a.formatDocument(n, i, o);
        }, e)), t.onDocumentRangeFormatting(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.Formatter) === null || a === void 0 ? void 0 : a.formatDocumentRange(n, i, o);
        }, e)), t.onDocumentOnTypeFormatting(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.Formatter) === null || a === void 0 ? void 0 : a.formatDocumentOnType(n, i, o);
        }, e));
      }
      X.addFormattingHandler = fP;
      function pP(t, e) {
        t.onRenameRequest(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.RenameProvider) === null || a === void 0 ? void 0 : a.rename(n, i, o);
        }, e)), t.onPrepareRename(Vt((r, n, i, o) => {
          var a;
          return (a = r.lsp.RenameProvider) === null || a === void 0 ? void 0 : a.prepareRename(n, i, o);
        }, e));
      }
      X.addRenameHandler = pP;
      function hP(t, e) {
        var r;
        let n = e.lsp.InlayHintProvider;
        if (n) {
          t.languages.inlayHint.on(Di((o, a, s, u) => n.getInlayHints(a, s, u), e));
          let i = (r = n.resolveInlayHint) === null || r === void 0 ? void 0 : r.bind(n);
          i && t.languages.inlayHint.resolve(async (o, a) => {
            try {
              return await i(o, a);
            } catch (s) {
              return ia(s);
            }
          });
        }
      }
      X.addInlayHintHandler = hP;
      function mP(t, e) {
        let r = { data: [] };
        t.languages.semanticTokens.on(Di((n, i, o, a) => n.lsp.SemanticTokenProvider ? n.lsp.SemanticTokenProvider.semanticHighlight(i, o, a) : r, e)), t.languages.semanticTokens.onDelta(Di((n, i, o, a) => n.lsp.SemanticTokenProvider ? n.lsp.SemanticTokenProvider.semanticHighlightDelta(i, o, a) : r, e)), t.languages.semanticTokens.onRange(Di((n, i, o, a) => n.lsp.SemanticTokenProvider ? n.lsp.SemanticTokenProvider.semanticHighlightRange(i, o, a) : r, e));
      }
      X.addSemanticTokenHandler = mP;
      function gP(t, e) {
        t.onDidChangeConfiguration((r) => {
          r.settings && e.workspace.ConfigurationProvider.updateConfiguration(r);
        });
      }
      X.addConfigurationChangeHandler = gP;
      function yP(t, e) {
        let r = e.lsp.ExecuteCommandHandler;
        r && t.onExecuteCommand(async (n, i) => {
          var o;
          try {
            return await r.executeCommand(n.command, (o = n.arguments) !== null && o !== void 0 ? o : [], i);
          } catch (a) {
            return ia(a);
          }
        });
      }
      X.addExecuteCommandHandler = yP;
      function vP(t, e) {
        var r;
        let n = e.lsp.DocumentLinkProvider;
        if (n) {
          t.onDocumentLinks(Di((o, a, s, u) => n.getDocumentLinks(a, s, u), e));
          let i = (r = n.resolveDocumentLink) === null || r === void 0 ? void 0 : r.bind(n);
          i && t.onDocumentLinkResolve(async (o, a) => {
            try {
              return await i(o, a);
            } catch (s) {
              return ia(s);
            }
          });
        }
      }
      X.addDocumentLinkHandler = vP;
      function TP(t, e) {
        t.onSignatureHelp(Di((r, n, i, o) => {
          var a;
          return (a = r.lsp.SignatureHelp) === null || a === void 0 ? void 0 : a.provideSignatureHelp(n, i, o);
        }, e));
      }
      X.addSignatureHelpHandler = TP;
      function _P(t, e) {
        var r;
        let n = e.lsp.CodeLensProvider;
        if (n) {
          t.onCodeLens(Di((o, a, s, u) => n.provideCodeLens(a, s, u), e));
          let i = (r = n.resolveCodeLens) === null || r === void 0 ? void 0 : r.bind(n);
          i && t.onCodeLensResolve(async (o, a) => {
            try {
              return await i(o, a);
            } catch (s) {
              return ia(s);
            }
          });
        }
      }
      X.addCodeLensHandler = _P;
      function RP(t, e) {
        t.languages.callHierarchy.onPrepare(Di((r, n, i, o) => {
          var a;
          return r.lsp.CallHierarchyProvider && (a = r.lsp.CallHierarchyProvider.prepareCallHierarchy(n, i, o)) !== null && a !== void 0 ? a : null;
        }, e)), t.languages.callHierarchy.onIncomingCalls(sv((r, n, i) => {
          var o;
          return r.lsp.CallHierarchyProvider && (o = r.lsp.CallHierarchyProvider.incomingCalls(n, i)) !== null && o !== void 0 ? o : null;
        }, e)), t.languages.callHierarchy.onOutgoingCalls(sv((r, n, i) => {
          var o;
          return r.lsp.CallHierarchyProvider && (o = r.lsp.CallHierarchyProvider.outgoingCalls(n, i)) !== null && o !== void 0 ? o : null;
        }, e));
      }
      X.addCallHierarchyHandler = RP;
      function sv(t, e) {
        let r = e.ServiceRegistry;
        return async (n, i) => {
          let o = uc.URI.parse(n.item.uri), a = r.getServices(o);
          if (!a) {
            let s = `Could not find service instance for uri: '${o.toString()}'`;
            throw console.error(s), new Error(s);
          }
          try {
            return await t(a, n, i);
          } catch (s) {
            return ia(s);
          }
        };
      }
      X.createCallHierarchyRequestHandler = sv;
      function Di(t, e) {
        let r = e.workspace.LangiumDocuments, n = e.ServiceRegistry;
        return async (i, o) => {
          let a = uc.URI.parse(i.textDocument.uri), s = n.getServices(a);
          if (!s)
            throw console.error(`Could not find service instance for uri: '${a.toString()}'`), new Error();
          let u = r.getOrCreateDocument(a);
          if (!u)
            throw new Error();
          try {
            return await t(s, u, i, o);
          } catch (c) {
            return ia(c);
          }
        };
      }
      X.createServerRequestHandler = Di;
      function Vt(t, e) {
        let r = e.workspace.LangiumDocuments, n = e.ServiceRegistry;
        return async (i, o) => {
          let a = uc.URI.parse(i.textDocument.uri), s = n.getServices(a);
          if (!s)
            return console.error(`Could not find service instance for uri: '${a.toString()}'`), null;
          let u = r.getOrCreateDocument(a);
          if (!u)
            return null;
          try {
            return await t(s, u, i, o);
          } catch (c) {
            return ia(c);
          }
        };
      }
      X.createRequestHandler = Vt;
      function ia(t) {
        if ((0, gz.isOperationCancelled)(t))
          return new na.ResponseError(na.LSPErrorCodes.RequestCancelled, "The request has been cancelled.");
        if (t instanceof na.ResponseError)
          return t;
        throw t;
      }
    });
    var lv = f((of) => {
      Object.defineProperty(of, "__esModule", { value: true });
      of.DefaultReferencesProvider = void 0;
      var bz = xe(), Sz = Le(), cv = class {
        constructor(e) {
          this.nameProvider = e.references.NameProvider, this.references = e.references.References, this.grammarConfig = e.parser.GrammarConfig;
        }
        findReferences(e, r) {
          let n = e.parseResult.value.$cstNode;
          if (!n)
            return [];
          let i = (0, Sz.findDeclarationNodeAtOffset)(n, e.textDocument.offsetAt(r.position), this.grammarConfig.nameRegexp);
          return i ? this.getReferences(i, r, e) : [];
        }
        getReferences(e, r, n) {
          let i = [], o = this.references.findDeclaration(e);
          if (o) {
            let a = { includeDeclaration: r.context.includeDeclaration };
            this.references.findReferences(o, a).forEach((s) => {
              i.push(bz.Location.create(s.sourceUri.toString(), s.segment.range));
            });
          }
          return i;
        }
      };
      of.DefaultReferencesProvider = cv;
    });
    var fv = f((af) => {
      Object.defineProperty(af, "__esModule", { value: true });
      af.DefaultRenameProvider = void 0;
      var Az = xe(), Pz = rs(), bP = Le(), dv = class {
        constructor(e) {
          this.references = e.references.References, this.nameProvider = e.references.NameProvider, this.grammarConfig = e.parser.GrammarConfig;
        }
        async rename(e, r) {
          let n = {}, i = e.parseResult.value.$cstNode;
          if (!i)
            return;
          let o = e.textDocument.offsetAt(r.position), a = (0, bP.findDeclarationNodeAtOffset)(i, o, this.grammarConfig.nameRegexp);
          if (!a)
            return;
          let s = this.references.findDeclaration(a);
          if (!s)
            return;
          let u = { onlyLocal: false, includeDeclaration: true };
          return this.references.findReferences(s, u).forEach((l) => {
            let d = Az.TextEdit.replace(l.segment.range, r.newName), h = l.sourceUri.toString();
            n[h] ? n[h].push(d) : n[h] = [d];
          }), { changes: n };
        }
        prepareRename(e, r) {
          return this.renameNodeRange(e, r.position);
        }
        renameNodeRange(e, r) {
          let n = e.parseResult.value.$cstNode, i = e.textDocument.offsetAt(r);
          if (n && i) {
            let o = (0, bP.findDeclarationNodeAtOffset)(n, i, this.grammarConfig.nameRegexp);
            if (!o)
              return;
            if (this.references.findDeclaration(o) || this.isNameNode(o))
              return o.range;
          }
        }
        isNameNode(e) {
          return (e == null ? void 0 : e.element) && (0, Pz.isNamed)(e.element) && e === this.nameProvider.getNameNode(e.element);
        }
      };
      af.DefaultRenameProvider = dv;
    });
    var SP = f((sf) => {
      Object.defineProperty(sf, "__esModule", { value: true });
      sf.AbstractTypeDefinitionProvider = void 0;
      var Cz = xe(), Nz = Le(), pv = class {
        constructor(e) {
          this.references = e.references.References;
        }
        getTypeDefinition(e, r, n = Cz.CancellationToken.None) {
          let i = e.parseResult.value;
          if (i.$cstNode) {
            let o = (0, Nz.findDeclarationNodeAtOffset)(i.$cstNode, e.textDocument.offsetAt(r.position));
            if (o) {
              let a = this.references.findDeclaration(o);
              if (a)
                return this.collectGoToTypeLocationLinks(a, n);
            }
          }
        }
      };
      sf.AbstractTypeDefinitionProvider = pv;
    });
    var hv = f(($e) => {
      var Ez = $e && $e.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), pt = $e && $e.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Ez(e, t, r);
      };
      Object.defineProperty($e, "__esModule", { value: true });
      pt(Yd(), $e);
      pt(Fy(), $e);
      pt(Wy(), $e);
      pt(GA(), $e);
      pt(WA(), $e);
      pt(KA(), $e);
      pt(Ky(), $e);
      pt(Vy(), $e);
      pt(VA(), $e);
      pt(Xy(), $e);
      pt(YA(), $e);
      pt(qd(), $e);
      pt(ky(), $e);
      pt(Zy(), $e);
      pt(XA(), $e);
      pt(JA(), $e);
      pt(uv(), $e);
      pt(lv(), $e);
      pt(fv(), $e);
      pt(Ud(), $e);
      pt(ov(), $e);
      pt(SP(), $e);
    });
    var AP = f((uf) => {
      Object.defineProperty(uf, "__esModule", { value: true });
      uf.LangiumGrammarDefinitionProvider = void 0;
      var mv = xe(), kz = hv(), wz = be(), Oz = yt(), Dz = we(), Iz = Ft(), gv = class extends kz.DefaultDefinitionProvider {
        constructor(e) {
          super(e), this.documents = e.shared.workspace.LangiumDocuments;
        }
        collectLocationLinks(e, r) {
          var n, i, o, a, s, u;
          let c = "path";
          if ((0, Dz.isGrammarImport)(e.element) && ((n = (0, Oz.findAssignment)(e)) === null || n === void 0 ? void 0 : n.feature) === c) {
            let l = (0, Iz.resolveImport)(this.documents, e.element);
            if (l == null ? void 0 : l.$document) {
              let d = (i = this.findTargetObject(l)) !== null && i !== void 0 ? i : l, h = (a = (o = this.nameProvider.getNameNode(d)) === null || o === void 0 ? void 0 : o.range) !== null && a !== void 0 ? a : mv.Range.create(0, 0, 0, 0), y = (u = (s = d.$cstNode) === null || s === void 0 ? void 0 : s.range) !== null && u !== void 0 ? u : mv.Range.create(0, 0, 0, 0);
              return [mv.LocationLink.create(l.$document.uri.toString(), y, h, e.range)];
            }
            return;
          }
          return super.collectLocationLinks(e, r);
        }
        findTargetObject(e) {
          return e.isDeclared ? e : (0, wz.streamContents)(e).head();
        }
      };
      uf.LangiumGrammarDefinitionProvider = gv;
    });
    var CP = f((lf) => {
      Object.defineProperty(lf, "__esModule", { value: true });
      lf.LangiumGrammarCallHierarchyProvider = void 0;
      var PP = xe(), xz = Wy(), yv = be(), qz = Le(), cf = we(), vv = class extends xz.AbstractCallHierarchyProvider {
        getIncomingCalls(e, r) {
          if (!(0, cf.isParserRule)(e))
            return;
          let n = /* @__PURE__ */ new Map();
          if (r.forEach((i) => {
            let a = this.documents.getOrCreateDocument(i.sourceUri).parseResult.value;
            if (!a.$cstNode)
              return;
            let s = (0, qz.findLeafNodeAtOffset)(a.$cstNode, i.segment.offset);
            if (!s)
              return;
            let u = (0, yv.getContainerOfType)(s.element, cf.isParserRule);
            if (!u || !u.$cstNode)
              return;
            let c = this.nameProvider.getNameNode(u);
            if (!c)
              return;
            let l = i.sourceUri.toString(), d = l + "@" + c.text;
            n.has(d) ? n.set(d, { parserRule: u.$cstNode, nameNode: c, targetNodes: [...n.get(d).targetNodes, s], docUri: l }) : n.set(d, { parserRule: u.$cstNode, nameNode: c, targetNodes: [s], docUri: l });
          }), n.size !== 0)
            return Array.from(n.values()).map((i) => ({ from: { kind: PP.SymbolKind.Method, name: i.nameNode.text, range: i.parserRule.range, selectionRange: i.nameNode.range, uri: i.docUri }, fromRanges: i.targetNodes.map((o) => o.range) }));
        }
        getOutgoingCalls(e) {
          if (!(0, cf.isParserRule)(e))
            return;
          let r = (0, yv.streamAllContents)(e).filter(cf.isRuleCall).toArray(), n = /* @__PURE__ */ new Map();
          if (r.forEach((i) => {
            var o;
            let a = i.$cstNode;
            if (!a)
              return;
            let s = (o = i.rule.ref) === null || o === void 0 ? void 0 : o.$cstNode;
            if (!s)
              return;
            let u = this.nameProvider.getNameNode(s.element);
            if (!u)
              return;
            let c = (0, yv.getDocument)(s.element).uri.toString(), l = c + "@" + u.text;
            n.has(l) ? n.set(l, { refCstNode: s, to: u, from: [...n.get(l).from, a.range], docUri: c }) : n.set(l, { refCstNode: s, to: u, from: [a.range], docUri: c });
          }), n.size !== 0)
            return Array.from(n.values()).map((i) => ({ to: { kind: PP.SymbolKind.Method, name: i.to.text, range: i.refCstNode.range, selectionRange: i.to.range, uri: i.docUri }, fromRanges: i.from }));
        }
      };
      lf.LangiumGrammarCallHierarchyProvider = vv;
    });
    var kP = f((pf) => {
      Object.defineProperty(pf, "__esModule", { value: true });
      pf.LangiumGrammarValidationResourcesCollector = void 0;
      var Lz = Tn(), EP = $t(), df = we(), NP = Ft(), ff = es(), Mz = ty(), Tv = class {
        constructor(e) {
          this.documents = e.shared.workspace.LangiumDocuments;
        }
        collectValidationResources(e) {
          let r = (0, Mz.collectValidationAst)(e, this.documents);
          return { typeToValidationInfo: this.collectValidationInfo(r), typeToSuperProperties: this.collectSuperProperties(r) };
        }
        collectValidationInfo({ astResources: e, inferred: r, declared: n }) {
          let i = /* @__PURE__ */ new Map(), o = $z(e);
          for (let s of (0, ff.mergeTypesAndInterfaces)(r))
            i.set(s.name, { inferred: s, inferredNodes: o.get(s.name) });
          let a = (0, EP.stream)(e.interfaces).concat(e.types).reduce((s, u) => s.set(u.name, u), /* @__PURE__ */ new Map());
          for (let s of (0, ff.mergeTypesAndInterfaces)(n)) {
            let u = a.get(s.name);
            if (u) {
              let c = i.get(s.name);
              i.set(s.name, Object.assign(Object.assign({}, c ?? {}), { declared: s, declaredNode: u }));
            }
          }
          return i;
        }
        collectSuperProperties({ inferred: e, declared: r }) {
          let n = /* @__PURE__ */ new Map(), i = (0, ff.mergeInterfaces)(e, r), o = new Map(i.map((a) => [a.name, a]));
          for (let a of (0, ff.mergeInterfaces)(e, r))
            n.set(a.name, this.addSuperProperties(a, o, /* @__PURE__ */ new Set()));
          return n;
        }
        addSuperProperties(e, r, n) {
          if (n.has(e.name))
            return [];
          n.add(e.name);
          let i = [...e.properties];
          for (let o of e.superTypes) {
            let a = r.get(o.name);
            a && i.push(...this.addSuperProperties(a, r, n));
          }
          return i;
        }
      };
      pf.LangiumGrammarValidationResourcesCollector = Tv;
      function $z({ parserRules: t, datatypeRules: e }) {
        let r = new Lz.MultiMap();
        (0, EP.stream)(t).concat(e).forEach((i) => r.add((0, NP.getRuleType)(i), i));
        function n(i) {
          if ((0, df.isAction)(i)) {
            let o = (0, NP.getActionType)(i);
            o && r.add(o, i);
          }
          ((0, df.isAlternatives)(i) || (0, df.isGroup)(i) || (0, df.isUnorderedGroup)(i)) && i.elements.forEach((o) => n(o));
        }
        return t.forEach((i) => n(i.definition)), r;
      }
    });
    var wP = f((yo) => {
      Object.defineProperty(yo, "__esModule", { value: true });
      yo.isInferredAndDeclared = yo.isInferred = yo.isDeclared = void 0;
      function Fz(t) {
        return t && "declared" in t;
      }
      yo.isDeclared = Fz;
      function jz(t) {
        return t && "inferred" in t;
      }
      yo.isInferred = jz;
      function Uz(t) {
        return t && "inferred" in t && "declared" in t;
      }
      yo.isInferredAndDeclared = Uz;
    });
    var DP = f((Xr) => {
      var Gz = Xr && Xr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), Hz = Xr && Xr.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), Wz = Xr && Xr.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Gz(e, t, r);
        return Hz(e, t), e;
      };
      Object.defineProperty(Xr, "__esModule", { value: true });
      Xr.LangiumGrammarTypesValidator = Xr.registerTypeValidationChecks = void 0;
      var hs = Wz(we()), Bz = Tn(), Kz = Ft(), Ze = Za(), _v = wP();
      function zz(t) {
        let e = t.validation.ValidationRegistry, r = t.validation.LangiumGrammarTypesValidator, n = { Action: [r.checkActionIsNotUnionType], Grammar: [r.checkDeclaredTypesConsistency, r.checkDeclaredAndInferredTypesConsistency] };
        e.register(n, r);
      }
      Xr.registerTypeValidationChecks = zz;
      var Rv = class {
        checkDeclaredTypesConsistency(e, r) {
          var n;
          let i = (n = e.$document) === null || n === void 0 ? void 0 : n.validationResources;
          if (i) {
            for (let o of i.typeToValidationInfo.values())
              if ((0, _v.isDeclared)(o) && (0, Ze.isInterfaceType)(o.declared) && hs.isInterface(o.declaredNode)) {
                let a = o;
                Yz(a, r), Xz(a, r);
              }
          }
        }
        checkDeclaredAndInferredTypesConsistency(e, r) {
          var n;
          let i = (n = e.$document) === null || n === void 0 ? void 0 : n.validationResources;
          if (i)
            for (let o of i.typeToValidationInfo.values())
              (0, _v.isInferred)(o) && o.inferred instanceof Ze.InterfaceType && Vz(o.inferred, r), (0, _v.isInferredAndDeclared)(o) && Zz(o, i, r);
        }
        checkActionIsNotUnionType(e, r) {
          hs.isType(e.type) && r("error", "Actions cannot create union types.", { node: e, property: "type" });
        }
      };
      Xr.LangiumGrammarTypesValidator = Rv;
      function Vz(t, e) {
        t.properties.forEach((r) => {
          var n;
          let i = (0, Ze.flattenPropertyUnion)(r.type);
          if (i.length > 1) {
            let o = (s) => (0, Ze.isReferenceType)(s) ? "ref" : "other", a = o(i[0]);
            if (i.slice(1).some((s) => o(s) !== a)) {
              let s = (n = r.astNodes.values().next()) === null || n === void 0 ? void 0 : n.value;
              s && e("error", `Mixing a cross-reference with other types is not supported. Consider splitting property "${r.name}" into two or more different properties.`, { node: s });
            }
          }
        });
      }
      function Yz({ declared: t, declaredNode: e }, r) {
        Array.from(t.superTypes).forEach((n, i) => {
          n && ((0, Ze.isUnionType)(n) && r("error", "Interfaces cannot extend union types.", { node: e, property: "superTypes", index: i }), n.declared || r("error", "Extending an inferred type is discouraged.", { node: e, property: "superTypes", index: i }));
        });
      }
      function Xz({ declared: t, declaredNode: e }, r) {
        let n = t.properties.reduce((a, s) => a.add(s.name, s), new Bz.MultiMap());
        for (let [a, s] of n.entriesGroupedByKey())
          if (s.length > 1)
            for (let u of s)
              r("error", `Cannot have two properties with the same name '${a}'.`, { node: Array.from(u.astNodes)[0], property: "name" });
        let i = Array.from(t.superTypes);
        for (let a = 0; a < i.length; a++)
          for (let s = a + 1; s < i.length; s++) {
            let u = i[a], c = i[s], l = (0, Ze.isInterfaceType)(u) ? u.superProperties : [], d = (0, Ze.isInterfaceType)(c) ? c.superProperties : [], h = Jz(l, d);
            h.length > 0 && r("error", `Cannot simultaneously inherit from '${u}' and '${c}'. Their ${h.map((y) => "'" + y + "'").join(", ")} properties are not identical.`, { node: e, property: "name" });
          }
        let o = /* @__PURE__ */ new Set();
        for (let a of i) {
          let s = (0, Ze.isInterfaceType)(a) ? a.superProperties : [];
          for (let u of s)
            o.add(u.name);
        }
        for (let a of t.properties)
          if (o.has(a.name)) {
            let s = e.attributes.find((u) => u.name === a.name);
            s && r("error", `Cannot redeclare property '${a.name}'. It is already inherited from another interface.`, { node: s, property: "name" });
          }
      }
      function Jz(t, e) {
        let r = [];
        for (let n of t) {
          let i = e.find((o) => o.name === n.name);
          i && !Qz(n, i) && r.push(n.name);
        }
        return r;
      }
      function Qz(t, e) {
        return (0, Ze.isTypeAssignable)(t.type, e.type) && (0, Ze.isTypeAssignable)(e.type, t.type);
      }
      function Zz(t, e, r) {
        let { inferred: n, declared: i, declaredNode: o, inferredNodes: a } = t, s = i.name, u = (d) => (h) => a.forEach((y) => r("error", `${h}${d ? ` ${d}` : ""}.`, (y == null ? void 0 : y.inferredType) ? { node: y == null ? void 0 : y.inferredType, property: "name" } : { node: y, property: hs.isAction(y) ? "type" : "name" })), c = (d, h) => d.forEach((y) => r("error", h, { node: y, property: hs.isAssignment(y) || hs.isAction(y) ? "feature" : "name" })), l = (d) => {
          a.forEach((h) => {
            hs.isParserRule(h) && (0, Kz.extractAssignments)(h.definition).find((m) => m.feature === d) === void 0 && r("error", `Property '${d}' is missing in a rule '${h.name}', but is required in type '${s}'.`, { node: h, property: "parameters" });
          });
        };
        if ((0, Ze.isUnionType)(n) && (0, Ze.isUnionType)(i))
          eV(n.type, i.type, u(`in a rule that returns type '${s}'`));
        else if ((0, Ze.isInterfaceType)(n) && (0, Ze.isInterfaceType)(i))
          tV(n, i, e, u(`in a rule that returns type '${s}'`), c, l);
        else {
          let d = `Inferred and declared versions of type '${s}' both have to be interfaces or unions.`;
          u()(d), r("error", d, { node: o, property: "name" });
        }
      }
      function eV(t, e, r) {
        (0, Ze.isTypeAssignable)(t, e) || r(`Cannot assign type '${(0, Ze.propertyTypeToString)(t, "DeclaredType")}' to '${(0, Ze.propertyTypeToString)(e, "DeclaredType")}'`);
      }
      function OP(t) {
        return t.optional || (0, Ze.isMandatoryPropertyType)(t.type);
      }
      function tV(t, e, r, n, i, o) {
        let a = new Set(t.properties.map((d) => d.name)), s = new Map(t.allProperties.map((d) => [d.name, d])), u = new Map(e.superProperties.map((d) => [d.name, d])), c = (d) => {
          if ((0, Ze.isPropertyUnion)(d))
            return { types: d.types.map((h) => c(h)) };
          if ((0, Ze.isReferenceType)(d))
            return { referenceType: c(d.referenceType) };
          if ((0, Ze.isArrayType)(d))
            return { elementType: c(d.elementType) };
          if ((0, Ze.isValueType)(d)) {
            let h = r.typeToValidationInfo.get(d.value.name);
            return h ? { value: "declared" in h ? h.declared : h.inferred } : d;
          }
          return d;
        };
        for (let [d, h] of s.entries()) {
          let y = u.get(d);
          if (y) {
            let m = (0, Ze.propertyTypeToString)(h.type, "DeclaredType"), R = (0, Ze.propertyTypeToString)(y.type, "DeclaredType");
            if (!(0, Ze.isTypeAssignable)(c(h.type), y.type)) {
              let N = `The assigned type '${m}' is not compatible with the declared property '${d}' of type '${R}'.`;
              i(h.astNodes, N);
            }
            h.optional && !OP(y) && o(d);
          } else
            a.has(d) && i(h.astNodes, `A property '${d}' is not expected.`);
        }
        let l = /* @__PURE__ */ new Set();
        for (let [d, h] of u.entries())
          !s.get(d) && !OP(h) && l.add(d);
        if (l.size > 0) {
          let d = l.size > 1 ? "Properties" : "A property", h = l.size > 1 ? "are expected" : "is expected", y = Array.from(l).map((m) => `'${m}'`).sort().join(", ");
          n(`${d} ${y} ${h}.`);
        }
      }
    });
    var bv = f((oa) => {
      Object.defineProperty(oa, "__esModule", { value: true });
      oa.createLangiumGrammarServices = oa.LangiumGrammarModule = void 0;
      var IP = hf(), xP = zu(), qP = tA(), LP = cA(), MP = _y(), rV = vA(), nV = TA(), iV = RA(), oV = bA(), aV = AA(), sV = OA(), uV = AP(), cV = CP(), lV = kP(), $P = DP(), dV = vr(), fV = go();
      oa.LangiumGrammarModule = { validation: { LangiumGrammarValidator: (t) => new MP.LangiumGrammarValidator(t), ValidationResourcesCollector: (t) => new lV.LangiumGrammarValidationResourcesCollector(t), LangiumGrammarTypesValidator: () => new $P.LangiumGrammarTypesValidator() }, lsp: { FoldingRangeProvider: (t) => new nV.LangiumGrammarFoldingRangeProvider(t), CodeActionProvider: (t) => new rV.LangiumGrammarCodeActionProvider(t), SemanticTokenProvider: (t) => new oV.LangiumGrammarSemanticTokenProvider(t), Formatter: () => new iV.LangiumGrammarFormatter(), DefinitionProvider: (t) => new uV.LangiumGrammarDefinitionProvider(t), CallHierarchyProvider: (t) => new cV.LangiumGrammarCallHierarchyProvider(t) }, references: { ScopeComputation: (t) => new LP.LangiumGrammarScopeComputation(t), ScopeProvider: (t) => new LP.LangiumGrammarScopeProvider(t), References: (t) => new sV.LangiumGrammarReferences(t), NameProvider: () => new aV.LangiumGrammarNameProvider() } };
      function pV(t, e) {
        let r = (0, xP.inject)((0, IP.createDefaultSharedModule)(t), qP.LangiumGrammarGeneratedSharedModule, e), n = (0, xP.inject)((0, IP.createDefaultModule)({ shared: r }), qP.LangiumGrammarGeneratedModule, oa.LangiumGrammarModule);
        return hV(r, n), r.ServiceRegistry.register(n), (0, MP.registerValidationChecks)(n), (0, $P.registerTypeValidationChecks)(n), { shared: r, grammar: n };
      }
      oa.createLangiumGrammarServices = pV;
      function hV(t, e) {
        t.workspace.DocumentBuilder.onBuildPhase(fV.DocumentState.IndexedReferences, async (n, i) => {
          for (let o of n) {
            await (0, dV.interruptAndCheck)(i);
            let a = e.validation.ValidationResourcesCollector, s = o.parseResult.value;
            o.validationResources = a.collectValidationResources(s);
          }
        });
      }
    });
    var Sv = f((ms) => {
      Object.defineProperty(ms, "__esModule", { value: true });
      ms.EmptyFileSystem = ms.EmptyFileSystemProvider = void 0;
      var mf = class {
        readFile() {
          throw new Error("Method not implemented.");
        }
        readFileSync() {
          throw new Error("Method not implemented.");
        }
        async readDirectory() {
          return [];
        }
      };
      ms.EmptyFileSystemProvider = mf;
      ms.EmptyFileSystem = { fileSystemProvider: () => new mf() };
    });
    var yt = f((pe) => {
      var mV = pe && pe.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), gV = pe && pe.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), yV = pe && pe.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && mV(e, t, r);
        return gV(e, t), e;
      };
      Object.defineProperty(pe, "__esModule", { value: true });
      pe.createServicesForGrammar = pe.loadGrammarFromJson = pe.findNameAssignment = pe.findAssignment = pe.findNodesForKeywordInternal = pe.findNodeForKeyword = pe.findNodesForKeyword = pe.findNodeForProperty = pe.findNodesForProperty = pe.isCommentTerminal = pe.getCrossReferenceTerminal = pe.getAllReachableRules = pe.getHiddenRules = pe.getEntryRule = void 0;
      var UP = vn(), FP = hf(), jP = zu(), vV = ny(), dr = yV(we()), TV = Ft(), GP = bv(), _V = Zt(), gs = be(), RV = Le(), Av = Sv();
      function HP(t) {
        return t.rules.find((e) => dr.isParserRule(e) && e.entry);
      }
      pe.getEntryRule = HP;
      function WP(t) {
        return t.rules.filter((e) => dr.isTerminalRule(e) && e.hidden);
      }
      pe.getHiddenRules = WP;
      function bV(t, e) {
        let r = /* @__PURE__ */ new Set(), n = HP(t);
        if (!n)
          return new Set(t.rules);
        let i = [n].concat(WP(t));
        for (let a of i)
          BP(a, r, e);
        let o = /* @__PURE__ */ new Set();
        for (let a of t.rules)
          (r.has(a.name) || dr.isTerminalRule(a) && a.hidden) && o.add(a);
        return o;
      }
      pe.getAllReachableRules = bV;
      function BP(t, e, r) {
        e.add(t.name), (0, gs.streamAllContents)(t).forEach((n) => {
          if (dr.isRuleCall(n) || r && dr.isTerminalRuleCall(n)) {
            let i = n.rule.ref;
            i && !e.has(i.name) && BP(i, e, r);
          }
        });
      }
      function SV(t) {
        if (t.terminal)
          return t.terminal;
        if (t.type.ref) {
          let e = KP(t.type.ref);
          return e == null ? void 0 : e.terminal;
        }
      }
      pe.getCrossReferenceTerminal = SV;
      function AV(t) {
        return t.hidden && !" ".match((0, TV.terminalRegex)(t));
      }
      pe.isCommentTerminal = AV;
      function PV(t, e) {
        return !t || !e ? [] : Pv(t, e, t.element, true);
      }
      pe.findNodesForProperty = PV;
      function CV(t, e, r) {
        if (!t || !e)
          return;
        let n = Pv(t, e, t.element, true);
        if (n.length !== 0)
          return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
      }
      pe.findNodeForProperty = CV;
      function Pv(t, e, r, n) {
        if (!n) {
          let i = (0, gs.getContainerOfType)(t.feature, dr.isAssignment);
          if (i && i.feature === e)
            return [t];
        }
        return (0, _V.isCompositeCstNode)(t) && t.element === r ? t.children.flatMap((i) => Pv(i, e, r, false)) : [];
      }
      function NV(t, e) {
        return t ? Cv(t, e, t == null ? void 0 : t.element) : [];
      }
      pe.findNodesForKeyword = NV;
      function EV(t, e, r) {
        if (!t)
          return;
        let n = Cv(t, e, t == null ? void 0 : t.element);
        if (n.length !== 0)
          return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
      }
      pe.findNodeForKeyword = EV;
      function Cv(t, e, r) {
        if (t.element !== r)
          return [];
        if (dr.isKeyword(t.feature) && t.feature.value === e)
          return [t];
        let n = (0, RV.streamCst)(t).iterator(), i, o = [];
        do
          if (i = n.next(), !i.done) {
            let a = i.value;
            a.element === r ? dr.isKeyword(a.feature) && a.feature.value === e && o.push(a) : n.prune();
          }
        while (!i.done);
        return o;
      }
      pe.findNodesForKeywordInternal = Cv;
      function kV(t) {
        var e;
        let r = t.element;
        for (; r === ((e = t.parent) === null || e === void 0 ? void 0 : e.element); ) {
          let n = (0, gs.getContainerOfType)(t.feature, dr.isAssignment);
          if (n)
            return n;
          t = t.parent;
        }
      }
      pe.findAssignment = kV;
      function KP(t) {
        return dr.isInferredType(t) && (t = t.$container), zP(t, /* @__PURE__ */ new Map());
      }
      pe.findNameAssignment = KP;
      function zP(t, e) {
        var r;
        function n(i, o) {
          let a;
          return (0, gs.getContainerOfType)(i, dr.isAssignment) || (a = zP(o, e)), e.set(t, a), a;
        }
        if (e.has(t))
          return e.get(t);
        e.set(t, void 0);
        for (let i of (0, gs.streamAllContents)(t)) {
          if (dr.isAssignment(i) && i.feature.toLowerCase() === "name")
            return e.set(t, i), i;
          if (dr.isRuleCall(i) && dr.isParserRule(i.rule.ref))
            return n(i, i.rule.ref);
          if (dr.isSimpleType(i) && (!((r = i.typeRef) === null || r === void 0) && r.ref))
            return n(i, i.typeRef.ref);
        }
      }
      function wV(t) {
        var e;
        let r = (0, GP.createLangiumGrammarServices)(Av.EmptyFileSystem).grammar, n = r.serializer.JsonSerializer.deserialize(t);
        return r.shared.workspace.LangiumDocumentFactory.fromModel(n, UP.URI.parse(`memory://${(e = n.name) !== null && e !== void 0 ? e : "grammar"}.langium`)), n;
      }
      pe.loadGrammarFromJson = wV;
      async function OV(t) {
        var e, r, n, i, o, a;
        let s = (e = t.grammarServices) !== null && e !== void 0 ? e : (0, GP.createLangiumGrammarServices)(Av.EmptyFileSystem).grammar, u = UP.URI.parse("memory:///grammar.langium"), c = s.shared.workspace.LangiumDocumentFactory, l = typeof t.grammar == "string" ? c.fromString(t.grammar, u) : (0, gs.getDocument)(t.grammar), d = l.parseResult.value;
        await s.shared.workspace.DocumentBuilder.build([l], { validationChecks: "none" });
        let y = (r = t.parserConfig) !== null && r !== void 0 ? r : { skipValidations: false }, m = (n = t.languageMetaData) !== null && n !== void 0 ? n : { caseInsensitive: false, fileExtensions: [`.${(o = (i = d.name) === null || i === void 0 ? void 0 : i.toLowerCase()) !== null && o !== void 0 ? o : "unknown"}`], languageId: (a = d.name) !== null && a !== void 0 ? a : "UNKNOWN" }, R = { AstReflection: () => (0, vV.interpretAstReflection)(d) }, C = { Grammar: () => d, LanguageMetaData: () => m, parser: { ParserConfig: () => y } }, N = (0, jP.inject)((0, FP.createDefaultSharedModule)(Av.EmptyFileSystem), R, t.sharedModule), S = (0, jP.inject)((0, FP.createDefaultModule)({ shared: N }), C, t.module);
        return N.ServiceRegistry.register(S), S;
      }
      pe.createServicesForGrammar = OV;
    });
    var Nv = f((gf) => {
      Object.defineProperty(gf, "__esModule", { value: true });
      gf.createGrammarConfig = void 0;
      var DV = Le(), IV = yt(), xV = Zo(), qV = we(), LV = Ft();
      function MV(t) {
        let e = [], r = t.Grammar;
        for (let n of r.rules)
          (0, qV.isTerminalRule)(n) && (0, IV.isCommentTerminal)(n) && (0, xV.isMultilineComment)((0, LV.terminalRegex)(n)) && e.push(n.name);
        return { multilineCommentRules: e, nameRegexp: DV.DefaultNameRegexp };
      }
      gf.createGrammarConfig = MV;
    });
    var Ev = f((yf) => {
      Object.defineProperty(yf, "__esModule", { value: true });
      yf.VERSION = void 0;
      yf.VERSION = "10.4.2";
    });
    var ys = f(($pe, VP) => {
      var $V = Object.prototype;
      function FV(t) {
        var e = t && t.constructor, r = typeof e == "function" && e.prototype || $V;
        return t === r;
      }
      VP.exports = FV;
    });
    var kv = f((Fpe, YP) => {
      function jV(t, e) {
        return function(r) {
          return t(e(r));
        };
      }
      YP.exports = jV;
    });
    var JP = f((jpe, XP) => {
      var UV = kv(), GV = UV(Object.keys, Object);
      XP.exports = GV;
    });
    var wv = f((Upe, QP) => {
      var HV = ys(), WV = JP(), BV = Object.prototype, KV = BV.hasOwnProperty;
      function zV(t) {
        if (!HV(t))
          return WV(t);
        var e = [];
        for (var r in Object(t))
          KV.call(t, r) && r != "constructor" && e.push(r);
        return e;
      }
      QP.exports = zV;
    });
    var Ov = f((Gpe, ZP) => {
      var VV = typeof global == "object" && global && global.Object === Object && global;
      ZP.exports = VV;
    });
    var An = f((Hpe, eC) => {
      var YV = Ov(), XV = typeof self == "object" && self && self.Object === Object && self, JV = YV || XV || Function("return this")();
      eC.exports = JV;
    });
    var aa = f((Wpe, tC) => {
      var QV = An(), ZV = QV.Symbol;
      tC.exports = ZV;
    });
    var oC = f((Bpe, iC) => {
      var rC = aa(), nC = Object.prototype, e2 = nC.hasOwnProperty, t2 = nC.toString, cc = rC ? rC.toStringTag : void 0;
      function r2(t) {
        var e = e2.call(t, cc), r = t[cc];
        try {
          t[cc] = void 0;
          var n = true;
        } catch {
        }
        var i = t2.call(t);
        return n && (e ? t[cc] = r : delete t[cc]), i;
      }
      iC.exports = r2;
    });
    var sC = f((Kpe, aC) => {
      var n2 = Object.prototype, i2 = n2.toString;
      function o2(t) {
        return i2.call(t);
      }
      aC.exports = o2;
    });
    var vo = f((zpe, lC) => {
      var uC = aa(), a2 = oC(), s2 = sC(), u2 = "[object Null]", c2 = "[object Undefined]", cC = uC ? uC.toStringTag : void 0;
      function l2(t) {
        return t == null ? t === void 0 ? c2 : u2 : cC && cC in Object(t) ? a2(t) : s2(t);
      }
      lC.exports = l2;
    });
    var Pn = f((Vpe, dC) => {
      function d2(t) {
        var e = typeof t;
        return t != null && (e == "object" || e == "function");
      }
      dC.exports = d2;
    });
    var vs = f((Ype, fC) => {
      var f2 = vo(), p2 = Pn(), h2 = "[object AsyncFunction]", m2 = "[object Function]", g2 = "[object GeneratorFunction]", y2 = "[object Proxy]";
      function v2(t) {
        if (!p2(t))
          return false;
        var e = f2(t);
        return e == m2 || e == g2 || e == h2 || e == y2;
      }
      fC.exports = v2;
    });
    var hC = f((Xpe, pC) => {
      var T2 = An(), _2 = T2["__core-js_shared__"];
      pC.exports = _2;
    });
    var yC = f((Jpe, gC) => {
      var Dv = hC(), mC = function() {
        var t = /[^.]+$/.exec(Dv && Dv.keys && Dv.keys.IE_PROTO || "");
        return t ? "Symbol(src)_1." + t : "";
      }();
      function R2(t) {
        return !!mC && mC in t;
      }
      gC.exports = R2;
    });
    var Iv = f((Qpe, vC) => {
      var b2 = Function.prototype, S2 = b2.toString;
      function A2(t) {
        if (t != null) {
          try {
            return S2.call(t);
          } catch {
          }
          try {
            return t + "";
          } catch {
          }
        }
        return "";
      }
      vC.exports = A2;
    });
    var _C = f((Zpe, TC) => {
      var P2 = vs(), C2 = yC(), N2 = Pn(), E2 = Iv(), k2 = /[\\^$.*+?()[\]{}|]/g, w2 = /^\[object .+?Constructor\]$/, O2 = Function.prototype, D2 = Object.prototype, I2 = O2.toString, x2 = D2.hasOwnProperty, q2 = RegExp("^" + I2.call(x2).replace(k2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function L2(t) {
        if (!N2(t) || C2(t))
          return false;
        var e = P2(t) ? q2 : w2;
        return e.test(E2(t));
      }
      TC.exports = L2;
    });
    var bC = f((ehe, RC) => {
      function M2(t, e) {
        return t == null ? void 0 : t[e];
      }
      RC.exports = M2;
    });
    var To = f((the, SC) => {
      var $2 = _C(), F2 = bC();
      function j2(t, e) {
        var r = F2(t, e);
        return $2(r) ? r : void 0;
      }
      SC.exports = j2;
    });
    var PC = f((rhe, AC) => {
      var U2 = To(), G2 = An(), H2 = U2(G2, "DataView");
      AC.exports = H2;
    });
    var vf = f((nhe, CC) => {
      var W2 = To(), B2 = An(), K2 = W2(B2, "Map");
      CC.exports = K2;
    });
    var EC = f((ihe, NC) => {
      var z2 = To(), V2 = An(), Y2 = z2(V2, "Promise");
      NC.exports = Y2;
    });
    var xv = f((ohe, kC) => {
      var X2 = To(), J2 = An(), Q2 = X2(J2, "Set");
      kC.exports = Q2;
    });
    var OC = f((ahe, wC) => {
      var Z2 = To(), e3 = An(), t3 = Z2(e3, "WeakMap");
      wC.exports = t3;
    });
    var _s = f((she, $C) => {
      var qv = PC(), Lv = vf(), Mv = EC(), $v = xv(), Fv = OC(), MC = vo(), Ts = Iv(), DC = "[object Map]", r3 = "[object Object]", IC = "[object Promise]", xC = "[object Set]", qC = "[object WeakMap]", LC = "[object DataView]", n3 = Ts(qv), i3 = Ts(Lv), o3 = Ts(Mv), a3 = Ts($v), s3 = Ts(Fv), sa = MC;
      (qv && sa(new qv(new ArrayBuffer(1))) != LC || Lv && sa(new Lv()) != DC || Mv && sa(Mv.resolve()) != IC || $v && sa(new $v()) != xC || Fv && sa(new Fv()) != qC) && (sa = function(t) {
        var e = MC(t), r = e == r3 ? t.constructor : void 0, n = r ? Ts(r) : "";
        if (n)
          switch (n) {
            case n3:
              return LC;
            case i3:
              return DC;
            case o3:
              return IC;
            case a3:
              return xC;
            case s3:
              return qC;
          }
        return e;
      });
      $C.exports = sa;
    });
    var Cn = f((uhe, FC) => {
      function u3(t) {
        return t != null && typeof t == "object";
      }
      FC.exports = u3;
    });
    var UC = f((che, jC) => {
      var c3 = vo(), l3 = Cn(), d3 = "[object Arguments]";
      function f3(t) {
        return l3(t) && c3(t) == d3;
      }
      jC.exports = f3;
    });
    var lc = f((lhe, WC) => {
      var GC = UC(), p3 = Cn(), HC = Object.prototype, h3 = HC.hasOwnProperty, m3 = HC.propertyIsEnumerable, g3 = GC(function() {
        return arguments;
      }()) ? GC : function(t) {
        return p3(t) && h3.call(t, "callee") && !m3.call(t, "callee");
      };
      WC.exports = g3;
    });
    var qe = f((dhe, BC) => {
      var y3 = Array.isArray;
      BC.exports = y3;
    });
    var Tf = f((fhe, KC) => {
      var v3 = 9007199254740991;
      function T3(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= v3;
      }
      KC.exports = T3;
    });
    var Nn = f((phe, zC) => {
      var _3 = vs(), R3 = Tf();
      function b3(t) {
        return t != null && R3(t.length) && !_3(t);
      }
      zC.exports = b3;
    });
    var YC = f((hhe, VC) => {
      function S3() {
        return false;
      }
      VC.exports = S3;
    });
    var fc = f((dc, Rs) => {
      var A3 = An(), P3 = YC(), QC = typeof dc == "object" && dc && !dc.nodeType && dc, XC = QC && typeof Rs == "object" && Rs && !Rs.nodeType && Rs, C3 = XC && XC.exports === QC, JC = C3 ? A3.Buffer : void 0, N3 = JC ? JC.isBuffer : void 0, E3 = N3 || P3;
      Rs.exports = E3;
    });
    var eN = f((mhe, ZC) => {
      var k3 = vo(), w3 = Tf(), O3 = Cn(), D3 = "[object Arguments]", I3 = "[object Array]", x3 = "[object Boolean]", q3 = "[object Date]", L3 = "[object Error]", M3 = "[object Function]", $3 = "[object Map]", F3 = "[object Number]", j3 = "[object Object]", U3 = "[object RegExp]", G3 = "[object Set]", H3 = "[object String]", W3 = "[object WeakMap]", B3 = "[object ArrayBuffer]", K3 = "[object DataView]", z3 = "[object Float32Array]", V3 = "[object Float64Array]", Y3 = "[object Int8Array]", X3 = "[object Int16Array]", J3 = "[object Int32Array]", Q3 = "[object Uint8Array]", Z3 = "[object Uint8ClampedArray]", e4 = "[object Uint16Array]", t4 = "[object Uint32Array]", et = {};
      et[z3] = et[V3] = et[Y3] = et[X3] = et[J3] = et[Q3] = et[Z3] = et[e4] = et[t4] = true;
      et[D3] = et[I3] = et[B3] = et[x3] = et[K3] = et[q3] = et[L3] = et[M3] = et[$3] = et[F3] = et[j3] = et[U3] = et[G3] = et[H3] = et[W3] = false;
      function r4(t) {
        return O3(t) && w3(t.length) && !!et[k3(t)];
      }
      ZC.exports = r4;
    });
    var bs = f((ghe, tN) => {
      function n4(t) {
        return function(e) {
          return t(e);
        };
      }
      tN.exports = n4;
    });
    var mc = f((pc, Ss) => {
      var i4 = Ov(), rN = typeof pc == "object" && pc && !pc.nodeType && pc, hc = rN && typeof Ss == "object" && Ss && !Ss.nodeType && Ss, o4 = hc && hc.exports === rN, jv = o4 && i4.process, a4 = function() {
        try {
          var t = hc && hc.require && hc.require("util").types;
          return t || jv && jv.binding && jv.binding("util");
        } catch {
        }
      }();
      Ss.exports = a4;
    });
    var _f = f((yhe, oN) => {
      var s4 = eN(), u4 = bs(), nN = mc(), iN = nN && nN.isTypedArray, c4 = iN ? u4(iN) : s4;
      oN.exports = c4;
    });
    var Or = f((vhe, aN) => {
      var l4 = wv(), d4 = _s(), f4 = lc(), p4 = qe(), h4 = Nn(), m4 = fc(), g4 = ys(), y4 = _f(), v4 = "[object Map]", T4 = "[object Set]", _4 = Object.prototype, R4 = _4.hasOwnProperty;
      function b4(t) {
        if (t == null)
          return true;
        if (h4(t) && (p4(t) || typeof t == "string" || typeof t.splice == "function" || m4(t) || y4(t) || f4(t)))
          return !t.length;
        var e = d4(t);
        if (e == v4 || e == T4)
          return !t.size;
        if (g4(t))
          return !l4(t).length;
        for (var r in t)
          if (R4.call(t, r))
            return false;
        return true;
      }
      aN.exports = b4;
    });
    var As = f((The, sN) => {
      function S4(t, e) {
        for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
          i[r] = e(t[r], r, t);
        return i;
      }
      sN.exports = S4;
    });
    var cN = f((_he, uN) => {
      function A4() {
        this.__data__ = [], this.size = 0;
      }
      uN.exports = A4;
    });
    var Ps = f((Rhe, lN) => {
      function P4(t, e) {
        return t === e || t !== t && e !== e;
      }
      lN.exports = P4;
    });
    var gc = f((bhe, dN) => {
      var C4 = Ps();
      function N4(t, e) {
        for (var r = t.length; r--; )
          if (C4(t[r][0], e))
            return r;
        return -1;
      }
      dN.exports = N4;
    });
    var pN = f((She, fN) => {
      var E4 = gc(), k4 = Array.prototype, w4 = k4.splice;
      function O4(t) {
        var e = this.__data__, r = E4(e, t);
        if (r < 0)
          return false;
        var n = e.length - 1;
        return r == n ? e.pop() : w4.call(e, r, 1), --this.size, true;
      }
      fN.exports = O4;
    });
    var mN = f((Ahe, hN) => {
      var D4 = gc();
      function I4(t) {
        var e = this.__data__, r = D4(e, t);
        return r < 0 ? void 0 : e[r][1];
      }
      hN.exports = I4;
    });
    var yN = f((Phe, gN) => {
      var x4 = gc();
      function q4(t) {
        return x4(this.__data__, t) > -1;
      }
      gN.exports = q4;
    });
    var TN = f((Che, vN) => {
      var L4 = gc();
      function M4(t, e) {
        var r = this.__data__, n = L4(r, t);
        return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
      }
      vN.exports = M4;
    });
    var yc = f((Nhe, _N) => {
      var $4 = cN(), F4 = pN(), j4 = mN(), U4 = yN(), G4 = TN();
      function Cs(t) {
        var e = -1, r = t == null ? 0 : t.length;
        for (this.clear(); ++e < r; ) {
          var n = t[e];
          this.set(n[0], n[1]);
        }
      }
      Cs.prototype.clear = $4;
      Cs.prototype.delete = F4;
      Cs.prototype.get = j4;
      Cs.prototype.has = U4;
      Cs.prototype.set = G4;
      _N.exports = Cs;
    });
    var bN = f((Ehe, RN) => {
      var H4 = yc();
      function W4() {
        this.__data__ = new H4(), this.size = 0;
      }
      RN.exports = W4;
    });
    var AN = f((khe, SN) => {
      function B4(t) {
        var e = this.__data__, r = e.delete(t);
        return this.size = e.size, r;
      }
      SN.exports = B4;
    });
    var CN = f((whe, PN) => {
      function K4(t) {
        return this.__data__.get(t);
      }
      PN.exports = K4;
    });
    var EN = f((Ohe, NN) => {
      function z4(t) {
        return this.__data__.has(t);
      }
      NN.exports = z4;
    });
    var vc = f((Dhe, kN) => {
      var V4 = To(), Y4 = V4(Object, "create");
      kN.exports = Y4;
    });
    var DN = f((Ihe, ON) => {
      var wN = vc();
      function X4() {
        this.__data__ = wN ? wN(null) : {}, this.size = 0;
      }
      ON.exports = X4;
    });
    var xN = f((xhe, IN) => {
      function J4(t) {
        var e = this.has(t) && delete this.__data__[t];
        return this.size -= e ? 1 : 0, e;
      }
      IN.exports = J4;
    });
    var LN = f((qhe, qN) => {
      var Q4 = vc(), Z4 = "__lodash_hash_undefined__", e6 = Object.prototype, t6 = e6.hasOwnProperty;
      function r6(t) {
        var e = this.__data__;
        if (Q4) {
          var r = e[t];
          return r === Z4 ? void 0 : r;
        }
        return t6.call(e, t) ? e[t] : void 0;
      }
      qN.exports = r6;
    });
    var $N = f((Lhe, MN) => {
      var n6 = vc(), i6 = Object.prototype, o6 = i6.hasOwnProperty;
      function a6(t) {
        var e = this.__data__;
        return n6 ? e[t] !== void 0 : o6.call(e, t);
      }
      MN.exports = a6;
    });
    var jN = f((Mhe, FN) => {
      var s6 = vc(), u6 = "__lodash_hash_undefined__";
      function c6(t, e) {
        var r = this.__data__;
        return this.size += this.has(t) ? 0 : 1, r[t] = s6 && e === void 0 ? u6 : e, this;
      }
      FN.exports = c6;
    });
    var GN = f(($he, UN) => {
      var l6 = DN(), d6 = xN(), f6 = LN(), p6 = $N(), h6 = jN();
      function Ns(t) {
        var e = -1, r = t == null ? 0 : t.length;
        for (this.clear(); ++e < r; ) {
          var n = t[e];
          this.set(n[0], n[1]);
        }
      }
      Ns.prototype.clear = l6;
      Ns.prototype.delete = d6;
      Ns.prototype.get = f6;
      Ns.prototype.has = p6;
      Ns.prototype.set = h6;
      UN.exports = Ns;
    });
    var BN = f((Fhe, WN) => {
      var HN = GN(), m6 = yc(), g6 = vf();
      function y6() {
        this.size = 0, this.__data__ = { hash: new HN(), map: new (g6 || m6)(), string: new HN() };
      }
      WN.exports = y6;
    });
    var zN = f((jhe, KN) => {
      function v6(t) {
        var e = typeof t;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
      }
      KN.exports = v6;
    });
    var Tc = f((Uhe, VN) => {
      var T6 = zN();
      function _6(t, e) {
        var r = t.__data__;
        return T6(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
      }
      VN.exports = _6;
    });
    var XN = f((Ghe, YN) => {
      var R6 = Tc();
      function b6(t) {
        var e = R6(this, t).delete(t);
        return this.size -= e ? 1 : 0, e;
      }
      YN.exports = b6;
    });
    var QN = f((Hhe, JN) => {
      var S6 = Tc();
      function A6(t) {
        return S6(this, t).get(t);
      }
      JN.exports = A6;
    });
    var eE = f((Whe, ZN) => {
      var P6 = Tc();
      function C6(t) {
        return P6(this, t).has(t);
      }
      ZN.exports = C6;
    });
    var rE = f((Bhe, tE) => {
      var N6 = Tc();
      function E6(t, e) {
        var r = N6(this, t), n = r.size;
        return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
      }
      tE.exports = E6;
    });
    var Rf = f((Khe, nE) => {
      var k6 = BN(), w6 = XN(), O6 = QN(), D6 = eE(), I6 = rE();
      function Es(t) {
        var e = -1, r = t == null ? 0 : t.length;
        for (this.clear(); ++e < r; ) {
          var n = t[e];
          this.set(n[0], n[1]);
        }
      }
      Es.prototype.clear = k6;
      Es.prototype.delete = w6;
      Es.prototype.get = O6;
      Es.prototype.has = D6;
      Es.prototype.set = I6;
      nE.exports = Es;
    });
    var oE = f((zhe, iE) => {
      var x6 = yc(), q6 = vf(), L6 = Rf(), M6 = 200;
      function $6(t, e) {
        var r = this.__data__;
        if (r instanceof x6) {
          var n = r.__data__;
          if (!q6 || n.length < M6 - 1)
            return n.push([t, e]), this.size = ++r.size, this;
          r = this.__data__ = new L6(n);
        }
        return r.set(t, e), this.size = r.size, this;
      }
      iE.exports = $6;
    });
    var bf = f((Vhe, aE) => {
      var F6 = yc(), j6 = bN(), U6 = AN(), G6 = CN(), H6 = EN(), W6 = oE();
      function ks(t) {
        var e = this.__data__ = new F6(t);
        this.size = e.size;
      }
      ks.prototype.clear = j6;
      ks.prototype.delete = U6;
      ks.prototype.get = G6;
      ks.prototype.has = H6;
      ks.prototype.set = W6;
      aE.exports = ks;
    });
    var uE = f((Yhe, sE) => {
      var B6 = "__lodash_hash_undefined__";
      function K6(t) {
        return this.__data__.set(t, B6), this;
      }
      sE.exports = K6;
    });
    var lE = f((Xhe, cE) => {
      function z6(t) {
        return this.__data__.has(t);
      }
      cE.exports = z6;
    });
    var Af = f((Jhe, dE) => {
      var V6 = Rf(), Y6 = uE(), X6 = lE();
      function Sf(t) {
        var e = -1, r = t == null ? 0 : t.length;
        for (this.__data__ = new V6(); ++e < r; )
          this.add(t[e]);
      }
      Sf.prototype.add = Sf.prototype.push = Y6;
      Sf.prototype.has = X6;
      dE.exports = Sf;
    });
    var Uv = f((Qhe, fE) => {
      function J6(t, e) {
        for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
          if (e(t[r], r, t))
            return true;
        return false;
      }
      fE.exports = J6;
    });
    var Pf = f((Zhe, pE) => {
      function Q6(t, e) {
        return t.has(e);
      }
      pE.exports = Q6;
    });
    var Gv = f((eme, hE) => {
      var Z6 = Af(), e8 = Uv(), t8 = Pf(), r8 = 1, n8 = 2;
      function i8(t, e, r, n, i, o) {
        var a = r & r8, s = t.length, u = e.length;
        if (s != u && !(a && u > s))
          return false;
        var c = o.get(t), l = o.get(e);
        if (c && l)
          return c == e && l == t;
        var d = -1, h = true, y = r & n8 ? new Z6() : void 0;
        for (o.set(t, e), o.set(e, t); ++d < s; ) {
          var m = t[d], R = e[d];
          if (n)
            var C = a ? n(R, m, d, e, t, o) : n(m, R, d, t, e, o);
          if (C !== void 0) {
            if (C)
              continue;
            h = false;
            break;
          }
          if (y) {
            if (!e8(e, function(N, S) {
              if (!t8(y, S) && (m === N || i(m, N, r, n, o)))
                return y.push(S);
            })) {
              h = false;
              break;
            }
          } else if (!(m === R || i(m, R, r, n, o))) {
            h = false;
            break;
          }
        }
        return o.delete(t), o.delete(e), h;
      }
      hE.exports = i8;
    });
    var Hv = f((tme, mE) => {
      var o8 = An(), a8 = o8.Uint8Array;
      mE.exports = a8;
    });
    var yE = f((rme, gE) => {
      function s8(t) {
        var e = -1, r = Array(t.size);
        return t.forEach(function(n, i) {
          r[++e] = [i, n];
        }), r;
      }
      gE.exports = s8;
    });
    var Cf = f((nme, vE) => {
      function u8(t) {
        var e = -1, r = Array(t.size);
        return t.forEach(function(n) {
          r[++e] = n;
        }), r;
      }
      vE.exports = u8;
    });
    var SE = f((ime, bE) => {
      var TE = aa(), _E = Hv(), c8 = Ps(), l8 = Gv(), d8 = yE(), f8 = Cf(), p8 = 1, h8 = 2, m8 = "[object Boolean]", g8 = "[object Date]", y8 = "[object Error]", v8 = "[object Map]", T8 = "[object Number]", _8 = "[object RegExp]", R8 = "[object Set]", b8 = "[object String]", S8 = "[object Symbol]", A8 = "[object ArrayBuffer]", P8 = "[object DataView]", RE = TE ? TE.prototype : void 0, Wv = RE ? RE.valueOf : void 0;
      function C8(t, e, r, n, i, o, a) {
        switch (r) {
          case P8:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
              return false;
            t = t.buffer, e = e.buffer;
          case A8:
            return !(t.byteLength != e.byteLength || !o(new _E(t), new _E(e)));
          case m8:
          case g8:
          case T8:
            return c8(+t, +e);
          case y8:
            return t.name == e.name && t.message == e.message;
          case _8:
          case b8:
            return t == e + "";
          case v8:
            var s = d8;
          case R8:
            var u = n & p8;
            if (s || (s = f8), t.size != e.size && !u)
              return false;
            var c = a.get(t);
            if (c)
              return c == e;
            n |= h8, a.set(t, e);
            var l = l8(s(t), s(e), n, i, o, a);
            return a.delete(t), l;
          case S8:
            if (Wv)
              return Wv.call(t) == Wv.call(e);
        }
        return false;
      }
      bE.exports = C8;
    });
    var Nf = f((ome, AE) => {
      function N8(t, e) {
        for (var r = -1, n = e.length, i = t.length; ++r < n; )
          t[i + r] = e[r];
        return t;
      }
      AE.exports = N8;
    });
    var Bv = f((ame, PE) => {
      var E8 = Nf(), k8 = qe();
      function w8(t, e, r) {
        var n = e(t);
        return k8(t) ? n : E8(n, r(t));
      }
      PE.exports = w8;
    });
    var Ef = f((sme, CE) => {
      function O8(t, e) {
        for (var r = -1, n = t == null ? 0 : t.length, i = 0, o = []; ++r < n; ) {
          var a = t[r];
          e(a, r, t) && (o[i++] = a);
        }
        return o;
      }
      CE.exports = O8;
    });
    var Kv = f((ume, NE) => {
      function D8() {
        return [];
      }
      NE.exports = D8;
    });
    var kf = f((cme, kE) => {
      var I8 = Ef(), x8 = Kv(), q8 = Object.prototype, L8 = q8.propertyIsEnumerable, EE = Object.getOwnPropertySymbols, M8 = EE ? function(t) {
        return t == null ? [] : (t = Object(t), I8(EE(t), function(e) {
          return L8.call(t, e);
        }));
      } : x8;
      kE.exports = M8;
    });
    var OE = f((lme, wE) => {
      function $8(t, e) {
        for (var r = -1, n = Array(t); ++r < t; )
          n[r] = e(r);
        return n;
      }
      wE.exports = $8;
    });
    var _c = f((dme, DE) => {
      var F8 = 9007199254740991, j8 = /^(?:0|[1-9]\d*)$/;
      function U8(t, e) {
        var r = typeof t;
        return e = e ?? F8, !!e && (r == "number" || r != "symbol" && j8.test(t)) && t > -1 && t % 1 == 0 && t < e;
      }
      DE.exports = U8;
    });
    var zv = f((fme, IE) => {
      var G8 = OE(), H8 = lc(), W8 = qe(), B8 = fc(), K8 = _c(), z8 = _f(), V8 = Object.prototype, Y8 = V8.hasOwnProperty;
      function X8(t, e) {
        var r = W8(t), n = !r && H8(t), i = !r && !n && B8(t), o = !r && !n && !i && z8(t), a = r || n || i || o, s = a ? G8(t.length, String) : [], u = s.length;
        for (var c in t)
          (e || Y8.call(t, c)) && !(a && (c == "length" || i && (c == "offset" || c == "parent") || o && (c == "buffer" || c == "byteLength" || c == "byteOffset") || K8(c, u))) && s.push(c);
        return s;
      }
      IE.exports = X8;
    });
    var Dr = f((pme, xE) => {
      var J8 = zv(), Q8 = wv(), Z8 = Nn();
      function e9(t) {
        return Z8(t) ? J8(t) : Q8(t);
      }
      xE.exports = e9;
    });
    var Vv = f((hme, qE) => {
      var t9 = Bv(), r9 = kf(), n9 = Dr();
      function i9(t) {
        return t9(t, n9, r9);
      }
      qE.exports = i9;
    });
    var $E = f((mme, ME) => {
      var LE = Vv(), o9 = 1, a9 = Object.prototype, s9 = a9.hasOwnProperty;
      function u9(t, e, r, n, i, o) {
        var a = r & o9, s = LE(t), u = s.length, c = LE(e), l = c.length;
        if (u != l && !a)
          return false;
        for (var d = u; d--; ) {
          var h = s[d];
          if (!(a ? h in e : s9.call(e, h)))
            return false;
        }
        var y = o.get(t), m = o.get(e);
        if (y && m)
          return y == e && m == t;
        var R = true;
        o.set(t, e), o.set(e, t);
        for (var C = a; ++d < u; ) {
          h = s[d];
          var N = t[h], S = e[h];
          if (n)
            var b = a ? n(S, N, h, e, t, o) : n(N, S, h, t, e, o);
          if (!(b === void 0 ? N === S || i(N, S, r, n, o) : b)) {
            R = false;
            break;
          }
          C || (C = h == "constructor");
        }
        if (R && !C) {
          var O = t.constructor, L = e.constructor;
          O != L && "constructor" in t && "constructor" in e && !(typeof O == "function" && O instanceof O && typeof L == "function" && L instanceof L) && (R = false);
        }
        return o.delete(t), o.delete(e), R;
      }
      ME.exports = u9;
    });
    var KE = f((gme, BE) => {
      var Yv = bf(), c9 = Gv(), l9 = SE(), d9 = $E(), FE = _s(), jE = qe(), UE = fc(), f9 = _f(), p9 = 1, GE = "[object Arguments]", HE = "[object Array]", wf = "[object Object]", h9 = Object.prototype, WE = h9.hasOwnProperty;
      function m9(t, e, r, n, i, o) {
        var a = jE(t), s = jE(e), u = a ? HE : FE(t), c = s ? HE : FE(e);
        u = u == GE ? wf : u, c = c == GE ? wf : c;
        var l = u == wf, d = c == wf, h = u == c;
        if (h && UE(t)) {
          if (!UE(e))
            return false;
          a = true, l = false;
        }
        if (h && !l)
          return o || (o = new Yv()), a || f9(t) ? c9(t, e, r, n, i, o) : l9(t, e, u, r, n, i, o);
        if (!(r & p9)) {
          var y = l && WE.call(t, "__wrapped__"), m = d && WE.call(e, "__wrapped__");
          if (y || m) {
            var R = y ? t.value() : t, C = m ? e.value() : e;
            return o || (o = new Yv()), i(R, C, r, n, o);
          }
        }
        return h ? (o || (o = new Yv()), d9(t, e, r, n, i, o)) : false;
      }
      BE.exports = m9;
    });
    var Xv = f((yme, YE) => {
      var g9 = KE(), zE = Cn();
      function VE(t, e, r, n, i) {
        return t === e ? true : t == null || e == null || !zE(t) && !zE(e) ? t !== t && e !== e : g9(t, e, r, n, VE, i);
      }
      YE.exports = VE;
    });
    var JE = f((vme, XE) => {
      var y9 = bf(), v9 = Xv(), T9 = 1, _9 = 2;
      function R9(t, e, r, n) {
        var i = r.length, o = i, a = !n;
        if (t == null)
          return !o;
        for (t = Object(t); i--; ) {
          var s = r[i];
          if (a && s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
            return false;
        }
        for (; ++i < o; ) {
          s = r[i];
          var u = s[0], c = t[u], l = s[1];
          if (a && s[2]) {
            if (c === void 0 && !(u in t))
              return false;
          } else {
            var d = new y9();
            if (n)
              var h = n(c, l, u, t, e, d);
            if (!(h === void 0 ? v9(l, c, T9 | _9, n, d) : h))
              return false;
          }
        }
        return true;
      }
      XE.exports = R9;
    });
    var Jv = f((Tme, QE) => {
      var b9 = Pn();
      function S9(t) {
        return t === t && !b9(t);
      }
      QE.exports = S9;
    });
    var ek = f((_me, ZE) => {
      var A9 = Jv(), P9 = Dr();
      function C9(t) {
        for (var e = P9(t), r = e.length; r--; ) {
          var n = e[r], i = t[n];
          e[r] = [n, i, A9(i)];
        }
        return e;
      }
      ZE.exports = C9;
    });
    var Qv = f((Rme, tk) => {
      function N9(t, e) {
        return function(r) {
          return r == null ? false : r[t] === e && (e !== void 0 || t in Object(r));
        };
      }
      tk.exports = N9;
    });
    var nk = f((bme, rk) => {
      var E9 = JE(), k9 = ek(), w9 = Qv();
      function O9(t) {
        var e = k9(t);
        return e.length == 1 && e[0][2] ? w9(e[0][0], e[0][1]) : function(r) {
          return r === t || E9(r, t, e);
        };
      }
      rk.exports = O9;
    });
    var ws = f((Sme, ik) => {
      var D9 = vo(), I9 = Cn(), x9 = "[object Symbol]";
      function q9(t) {
        return typeof t == "symbol" || I9(t) && D9(t) == x9;
      }
      ik.exports = q9;
    });
    var Of = f((Ame, ok) => {
      var L9 = qe(), M9 = ws(), $9 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, F9 = /^\w*$/;
      function j9(t, e) {
        if (L9(t))
          return false;
        var r = typeof t;
        return r == "number" || r == "symbol" || r == "boolean" || t == null || M9(t) ? true : F9.test(t) || !$9.test(t) || e != null && t in Object(e);
      }
      ok.exports = j9;
    });
    var uk = f((Pme, sk) => {
      var ak = Rf(), U9 = "Expected a function";
      function Zv(t, e) {
        if (typeof t != "function" || e != null && typeof e != "function")
          throw new TypeError(U9);
        var r = function() {
          var n = arguments, i = e ? e.apply(this, n) : n[0], o = r.cache;
          if (o.has(i))
            return o.get(i);
          var a = t.apply(this, n);
          return r.cache = o.set(i, a) || o, a;
        };
        return r.cache = new (Zv.Cache || ak)(), r;
      }
      Zv.Cache = ak;
      sk.exports = Zv;
    });
    var lk = f((Cme, ck) => {
      var G9 = uk(), H9 = 500;
      function W9(t) {
        var e = G9(t, function(n) {
          return r.size === H9 && r.clear(), n;
        }), r = e.cache;
        return e;
      }
      ck.exports = W9;
    });
    var fk = f((Nme, dk) => {
      var B9 = lk(), K9 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, z9 = /\\(\\)?/g, V9 = B9(function(t) {
        var e = [];
        return t.charCodeAt(0) === 46 && e.push(""), t.replace(K9, function(r, n, i, o) {
          e.push(i ? o.replace(z9, "$1") : n || r);
        }), e;
      });
      dk.exports = V9;
    });
    var vk = f((Eme, yk) => {
      var pk = aa(), Y9 = As(), X9 = qe(), J9 = ws(), Q9 = 1 / 0, hk = pk ? pk.prototype : void 0, mk = hk ? hk.toString : void 0;
      function gk(t) {
        if (typeof t == "string")
          return t;
        if (X9(t))
          return Y9(t, gk) + "";
        if (J9(t))
          return mk ? mk.call(t) : "";
        var e = t + "";
        return e == "0" && 1 / t == -Q9 ? "-0" : e;
      }
      yk.exports = gk;
    });
    var eT = f((kme, Tk) => {
      var Z9 = vk();
      function e5(t) {
        return t == null ? "" : Z9(t);
      }
      Tk.exports = e5;
    });
    var Rc = f((wme, _k) => {
      var t5 = qe(), r5 = Of(), n5 = fk(), i5 = eT();
      function o5(t, e) {
        return t5(t) ? t : r5(t, e) ? [t] : n5(i5(t));
      }
      _k.exports = o5;
    });
    var Os = f((Ome, Rk) => {
      var a5 = ws(), s5 = 1 / 0;
      function u5(t) {
        if (typeof t == "string" || a5(t))
          return t;
        var e = t + "";
        return e == "0" && 1 / t == -s5 ? "-0" : e;
      }
      Rk.exports = u5;
    });
    var Df = f((Dme, bk) => {
      var c5 = Rc(), l5 = Os();
      function d5(t, e) {
        e = c5(e, t);
        for (var r = 0, n = e.length; t != null && r < n; )
          t = t[l5(e[r++])];
        return r && r == n ? t : void 0;
      }
      bk.exports = d5;
    });
    var Ak = f((Ime, Sk) => {
      var f5 = Df();
      function p5(t, e, r) {
        var n = t == null ? void 0 : f5(t, e);
        return n === void 0 ? r : n;
      }
      Sk.exports = p5;
    });
    var Ck = f((xme, Pk) => {
      function h5(t, e) {
        return t != null && e in Object(t);
      }
      Pk.exports = h5;
    });
    var tT = f((qme, Nk) => {
      var m5 = Rc(), g5 = lc(), y5 = qe(), v5 = _c(), T5 = Tf(), _5 = Os();
      function R5(t, e, r) {
        e = m5(e, t);
        for (var n = -1, i = e.length, o = false; ++n < i; ) {
          var a = _5(e[n]);
          if (!(o = t != null && r(t, a)))
            break;
          t = t[a];
        }
        return o || ++n != i ? o : (i = t == null ? 0 : t.length, !!i && T5(i) && v5(a, i) && (y5(t) || g5(t)));
      }
      Nk.exports = R5;
    });
    var kk = f((Lme, Ek) => {
      var b5 = Ck(), S5 = tT();
      function A5(t, e) {
        return t != null && S5(t, e, b5);
      }
      Ek.exports = A5;
    });
    var Ok = f((Mme, wk) => {
      var P5 = Xv(), C5 = Ak(), N5 = kk(), E5 = Of(), k5 = Jv(), w5 = Qv(), O5 = Os(), D5 = 1, I5 = 2;
      function x5(t, e) {
        return E5(t) && k5(e) ? w5(O5(t), e) : function(r) {
          var n = C5(r, t);
          return n === void 0 && n === e ? N5(r, t) : P5(e, n, D5 | I5);
        };
      }
      wk.exports = x5;
    });
    var ua = f(($me, Dk) => {
      function q5(t) {
        return t;
      }
      Dk.exports = q5;
    });
    var xk = f((Fme, Ik) => {
      function L5(t) {
        return function(e) {
          return e == null ? void 0 : e[t];
        };
      }
      Ik.exports = L5;
    });
    var Lk = f((jme, qk) => {
      var M5 = Df();
      function $5(t) {
        return function(e) {
          return M5(e, t);
        };
      }
      qk.exports = $5;
    });
    var $k = f((Ume, Mk) => {
      var F5 = xk(), j5 = Lk(), U5 = Of(), G5 = Os();
      function H5(t) {
        return U5(t) ? F5(G5(t)) : j5(t);
      }
      Mk.exports = H5;
    });
    var Jr = f((Gme, Fk) => {
      var W5 = nk(), B5 = Ok(), K5 = ua(), z5 = qe(), V5 = $k();
      function Y5(t) {
        return typeof t == "function" ? t : t == null ? K5 : typeof t == "object" ? z5(t) ? B5(t[0], t[1]) : W5(t) : V5(t);
      }
      Fk.exports = Y5;
    });
    var Uk = f((Hme, jk) => {
      function X5(t) {
        return function(e, r, n) {
          for (var i = -1, o = Object(e), a = n(e), s = a.length; s--; ) {
            var u = a[t ? s : ++i];
            if (r(o[u], u, o) === false)
              break;
          }
          return e;
        };
      }
      jk.exports = X5;
    });
    var Hk = f((Wme, Gk) => {
      var J5 = Uk(), Q5 = J5();
      Gk.exports = Q5;
    });
    var Bk = f((Bme, Wk) => {
      var Z5 = Hk(), eY = Dr();
      function tY(t, e) {
        return t && Z5(t, e, eY);
      }
      Wk.exports = tY;
    });
    var zk = f((Kme, Kk) => {
      var rY = Nn();
      function nY(t, e) {
        return function(r, n) {
          if (r == null)
            return r;
          if (!rY(r))
            return t(r, n);
          for (var i = r.length, o = e ? i : -1, a = Object(r); (e ? o-- : ++o < i) && n(a[o], o, a) !== false; )
            ;
          return r;
        };
      }
      Kk.exports = nY;
    });
    var _o = f((zme, Vk) => {
      var iY = Bk(), oY = zk(), aY = oY(iY);
      Vk.exports = aY;
    });
    var Xk = f((Vme, Yk) => {
      var sY = _o(), uY = Nn();
      function cY(t, e) {
        var r = -1, n = uY(t) ? Array(t.length) : [];
        return sY(t, function(i, o, a) {
          n[++r] = e(i, o, a);
        }), n;
      }
      Yk.exports = cY;
    });
    var jt = f((Yme, Jk) => {
      var lY = As(), dY = Jr(), fY = Xk(), pY = qe();
      function hY(t, e) {
        var r = pY(t) ? lY : fY;
        return r(t, dY(e, 3));
      }
      Jk.exports = hY;
    });
    var rT = f((Xme, Qk) => {
      function mY(t, e) {
        for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== false; )
          ;
        return t;
      }
      Qk.exports = mY;
    });
    var ew = f((Jme, Zk) => {
      var gY = ua();
      function yY(t) {
        return typeof t == "function" ? t : gY;
      }
      Zk.exports = yY;
    });
    var Ut = f((Qme, tw) => {
      var vY = rT(), TY = _o(), _Y = ew(), RY = qe();
      function bY(t, e) {
        var r = RY(t) ? vY : TY;
        return r(t, _Y(e));
      }
      tw.exports = bY;
    });
    var nw = f((Zme, rw) => {
      var SY = As();
      function AY(t, e) {
        return SY(e, function(r) {
          return t[r];
        });
      }
      rw.exports = AY;
    });
    var Qn = f((ege, iw) => {
      var PY = nw(), CY = Dr();
      function NY(t) {
        return t == null ? [] : PY(t, CY(t));
      }
      iw.exports = NY;
    });
    var aw = f((tge, ow) => {
      var EY = Object.prototype, kY = EY.hasOwnProperty;
      function wY(t, e) {
        return t != null && kY.call(t, e);
      }
      ow.exports = wY;
    });
    var Ir = f((rge, sw) => {
      var OY = aw(), DY = tT();
      function IY(t, e) {
        return t != null && DY(t, e, OY);
      }
      sw.exports = IY;
    });
    var nT = f((nge, uw) => {
      var xY = To(), qY = function() {
        try {
          var t = xY(Object, "defineProperty");
          return t({}, "", {}), t;
        } catch {
        }
      }();
      uw.exports = qY;
    });
    var If = f((ige, lw) => {
      var cw = nT();
      function LY(t, e, r) {
        e == "__proto__" && cw ? cw(t, e, { configurable: true, enumerable: true, value: r, writable: true }) : t[e] = r;
      }
      lw.exports = LY;
    });
    var bc = f((oge, dw) => {
      var MY = If(), $Y = Ps(), FY = Object.prototype, jY = FY.hasOwnProperty;
      function UY(t, e, r) {
        var n = t[e];
        (!(jY.call(t, e) && $Y(n, r)) || r === void 0 && !(e in t)) && MY(t, e, r);
      }
      dw.exports = UY;
    });
    var Ds = f((age, fw) => {
      var GY = bc(), HY = If();
      function WY(t, e, r, n) {
        var i = !r;
        r || (r = {});
        for (var o = -1, a = e.length; ++o < a; ) {
          var s = e[o], u = n ? n(r[s], t[s], s, r, t) : void 0;
          u === void 0 && (u = t[s]), i ? HY(r, s, u) : GY(r, s, u);
        }
        return r;
      }
      fw.exports = WY;
    });
    var hw = f((sge, pw) => {
      var BY = Ds(), KY = Dr();
      function zY(t, e) {
        return t && BY(e, KY(e), t);
      }
      pw.exports = zY;
    });
    var gw = f((uge, mw) => {
      function VY(t) {
        var e = [];
        if (t != null)
          for (var r in Object(t))
            e.push(r);
        return e;
      }
      mw.exports = VY;
    });
    var vw = f((cge, yw) => {
      var YY = Pn(), XY = ys(), JY = gw(), QY = Object.prototype, ZY = QY.hasOwnProperty;
      function eX(t) {
        if (!YY(t))
          return JY(t);
        var e = XY(t), r = [];
        for (var n in t)
          n == "constructor" && (e || !ZY.call(t, n)) || r.push(n);
        return r;
      }
      yw.exports = eX;
    });
    var Sc = f((lge, Tw) => {
      var tX = zv(), rX = vw(), nX = Nn();
      function iX(t) {
        return nX(t) ? tX(t, true) : rX(t);
      }
      Tw.exports = iX;
    });
    var Rw = f((dge, _w) => {
      var oX = Ds(), aX = Sc();
      function sX(t, e) {
        return t && oX(e, aX(e), t);
      }
      _w.exports = sX;
    });
    var Cw = f((Ac, Is) => {
      var uX = An(), Pw = typeof Ac == "object" && Ac && !Ac.nodeType && Ac, bw = Pw && typeof Is == "object" && Is && !Is.nodeType && Is, cX = bw && bw.exports === Pw, Sw = cX ? uX.Buffer : void 0, Aw = Sw ? Sw.allocUnsafe : void 0;
      function lX(t, e) {
        if (e)
          return t.slice();
        var r = t.length, n = Aw ? Aw(r) : new t.constructor(r);
        return t.copy(n), n;
      }
      Is.exports = lX;
    });
    var Ew = f((fge, Nw) => {
      function dX(t, e) {
        var r = -1, n = t.length;
        for (e || (e = Array(n)); ++r < n; )
          e[r] = t[r];
        return e;
      }
      Nw.exports = dX;
    });
    var ww = f((pge, kw) => {
      var fX = Ds(), pX = kf();
      function hX(t, e) {
        return fX(t, pX(t), e);
      }
      kw.exports = hX;
    });
    var iT = f((hge, Ow) => {
      var mX = kv(), gX = mX(Object.getPrototypeOf, Object);
      Ow.exports = gX;
    });
    var oT = f((mge, Dw) => {
      var yX = Nf(), vX = iT(), TX = kf(), _X = Kv(), RX = Object.getOwnPropertySymbols, bX = RX ? function(t) {
        for (var e = []; t; )
          yX(e, TX(t)), t = vX(t);
        return e;
      } : _X;
      Dw.exports = bX;
    });
    var xw = f((gge, Iw) => {
      var SX = Ds(), AX = oT();
      function PX(t, e) {
        return SX(t, AX(t), e);
      }
      Iw.exports = PX;
    });
    var aT = f((yge, qw) => {
      var CX = Bv(), NX = oT(), EX = Sc();
      function kX(t) {
        return CX(t, EX, NX);
      }
      qw.exports = kX;
    });
    var Mw = f((vge, Lw) => {
      var wX = Object.prototype, OX = wX.hasOwnProperty;
      function DX(t) {
        var e = t.length, r = new t.constructor(e);
        return e && typeof t[0] == "string" && OX.call(t, "index") && (r.index = t.index, r.input = t.input), r;
      }
      Lw.exports = DX;
    });
    var xf = f((Tge, Fw) => {
      var $w = Hv();
      function IX(t) {
        var e = new t.constructor(t.byteLength);
        return new $w(e).set(new $w(t)), e;
      }
      Fw.exports = IX;
    });
    var Uw = f((_ge, jw) => {
      var xX = xf();
      function qX(t, e) {
        var r = e ? xX(t.buffer) : t.buffer;
        return new t.constructor(r, t.byteOffset, t.byteLength);
      }
      jw.exports = qX;
    });
    var Hw = f((Rge, Gw) => {
      var LX = /\w*$/;
      function MX(t) {
        var e = new t.constructor(t.source, LX.exec(t));
        return e.lastIndex = t.lastIndex, e;
      }
      Gw.exports = MX;
    });
    var Vw = f((bge, zw) => {
      var Ww = aa(), Bw = Ww ? Ww.prototype : void 0, Kw = Bw ? Bw.valueOf : void 0;
      function $X(t) {
        return Kw ? Object(Kw.call(t)) : {};
      }
      zw.exports = $X;
    });
    var Xw = f((Sge, Yw) => {
      var FX = xf();
      function jX(t, e) {
        var r = e ? FX(t.buffer) : t.buffer;
        return new t.constructor(r, t.byteOffset, t.length);
      }
      Yw.exports = jX;
    });
    var Qw = f((Age, Jw) => {
      var UX = xf(), GX = Uw(), HX = Hw(), WX = Vw(), BX = Xw(), KX = "[object Boolean]", zX = "[object Date]", VX = "[object Map]", YX = "[object Number]", XX = "[object RegExp]", JX = "[object Set]", QX = "[object String]", ZX = "[object Symbol]", e7 = "[object ArrayBuffer]", t7 = "[object DataView]", r7 = "[object Float32Array]", n7 = "[object Float64Array]", i7 = "[object Int8Array]", o7 = "[object Int16Array]", a7 = "[object Int32Array]", s7 = "[object Uint8Array]", u7 = "[object Uint8ClampedArray]", c7 = "[object Uint16Array]", l7 = "[object Uint32Array]";
      function d7(t, e, r) {
        var n = t.constructor;
        switch (e) {
          case e7:
            return UX(t);
          case KX:
          case zX:
            return new n(+t);
          case t7:
            return GX(t, r);
          case r7:
          case n7:
          case i7:
          case o7:
          case a7:
          case s7:
          case u7:
          case c7:
          case l7:
            return BX(t, r);
          case VX:
            return new n();
          case YX:
          case QX:
            return new n(t);
          case XX:
            return HX(t);
          case JX:
            return new n();
          case ZX:
            return WX(t);
        }
      }
      Jw.exports = d7;
    });
    var tO = f((Pge, eO) => {
      var f7 = Pn(), Zw = Object.create, p7 = function() {
        function t() {
        }
        return function(e) {
          if (!f7(e))
            return {};
          if (Zw)
            return Zw(e);
          t.prototype = e;
          var r = new t();
          return t.prototype = void 0, r;
        };
      }();
      eO.exports = p7;
    });
    var nO = f((Cge, rO) => {
      var h7 = tO(), m7 = iT(), g7 = ys();
      function y7(t) {
        return typeof t.constructor == "function" && !g7(t) ? h7(m7(t)) : {};
      }
      rO.exports = y7;
    });
    var oO = f((Nge, iO) => {
      var v7 = _s(), T7 = Cn(), _7 = "[object Map]";
      function R7(t) {
        return T7(t) && v7(t) == _7;
      }
      iO.exports = R7;
    });
    var cO = f((Ege, uO) => {
      var b7 = oO(), S7 = bs(), aO = mc(), sO = aO && aO.isMap, A7 = sO ? S7(sO) : b7;
      uO.exports = A7;
    });
    var dO = f((kge, lO) => {
      var P7 = _s(), C7 = Cn(), N7 = "[object Set]";
      function E7(t) {
        return C7(t) && P7(t) == N7;
      }
      lO.exports = E7;
    });
    var mO = f((wge, hO) => {
      var k7 = dO(), w7 = bs(), fO = mc(), pO = fO && fO.isSet, O7 = pO ? w7(pO) : k7;
      hO.exports = O7;
    });
    var _O = f((Oge, TO) => {
      var D7 = bf(), I7 = rT(), x7 = bc(), q7 = hw(), L7 = Rw(), M7 = Cw(), $7 = Ew(), F7 = ww(), j7 = xw(), U7 = Vv(), G7 = aT(), H7 = _s(), W7 = Mw(), B7 = Qw(), K7 = nO(), z7 = qe(), V7 = fc(), Y7 = cO(), X7 = Pn(), J7 = mO(), Q7 = Dr(), Z7 = Sc(), eJ = 1, tJ = 2, rJ = 4, gO = "[object Arguments]", nJ = "[object Array]", iJ = "[object Boolean]", oJ = "[object Date]", aJ = "[object Error]", yO = "[object Function]", sJ = "[object GeneratorFunction]", uJ = "[object Map]", cJ = "[object Number]", vO = "[object Object]", lJ = "[object RegExp]", dJ = "[object Set]", fJ = "[object String]", pJ = "[object Symbol]", hJ = "[object WeakMap]", mJ = "[object ArrayBuffer]", gJ = "[object DataView]", yJ = "[object Float32Array]", vJ = "[object Float64Array]", TJ = "[object Int8Array]", _J = "[object Int16Array]", RJ = "[object Int32Array]", bJ = "[object Uint8Array]", SJ = "[object Uint8ClampedArray]", AJ = "[object Uint16Array]", PJ = "[object Uint32Array]", Xe = {};
      Xe[gO] = Xe[nJ] = Xe[mJ] = Xe[gJ] = Xe[iJ] = Xe[oJ] = Xe[yJ] = Xe[vJ] = Xe[TJ] = Xe[_J] = Xe[RJ] = Xe[uJ] = Xe[cJ] = Xe[vO] = Xe[lJ] = Xe[dJ] = Xe[fJ] = Xe[pJ] = Xe[bJ] = Xe[SJ] = Xe[AJ] = Xe[PJ] = true;
      Xe[aJ] = Xe[yO] = Xe[hJ] = false;
      function qf(t, e, r, n, i, o) {
        var a, s = e & eJ, u = e & tJ, c = e & rJ;
        if (r && (a = i ? r(t, n, i, o) : r(t)), a !== void 0)
          return a;
        if (!X7(t))
          return t;
        var l = z7(t);
        if (l) {
          if (a = W7(t), !s)
            return $7(t, a);
        } else {
          var d = H7(t), h = d == yO || d == sJ;
          if (V7(t))
            return M7(t, s);
          if (d == vO || d == gO || h && !i) {
            if (a = u || h ? {} : K7(t), !s)
              return u ? j7(t, L7(a, t)) : F7(t, q7(a, t));
          } else {
            if (!Xe[d])
              return i ? t : {};
            a = B7(t, d, s);
          }
        }
        o || (o = new D7());
        var y = o.get(t);
        if (y)
          return y;
        o.set(t, a), J7(t) ? t.forEach(function(C) {
          a.add(qf(C, e, r, C, t, o));
        }) : Y7(t) && t.forEach(function(C, N) {
          a.set(N, qf(C, e, r, N, t, o));
        });
        var m = c ? u ? G7 : U7 : u ? Z7 : Q7, R = l ? void 0 : m(t);
        return I7(R || t, function(C, N) {
          R && (N = C, C = t[N]), x7(a, N, qf(C, e, r, N, t, o));
        }), a;
      }
      TO.exports = qf;
    });
    var Ii = f((Dge, RO) => {
      var CJ = _O(), NJ = 4;
      function EJ(t) {
        return CJ(t, NJ);
      }
      RO.exports = EJ;
    });
    var bO = f((xs) => {
      Object.defineProperty(xs, "__esModule", { value: true });
      xs.PRINT_WARNING = xs.PRINT_ERROR = void 0;
      function kJ(t) {
        console && console.error && console.error("Error: ".concat(t));
      }
      xs.PRINT_ERROR = kJ;
      function wJ(t) {
        console && console.warn && console.warn("Warning: ".concat(t));
      }
      xs.PRINT_WARNING = wJ;
    });
    var SO = f((Lf) => {
      Object.defineProperty(Lf, "__esModule", { value: true });
      Lf.timer = void 0;
      function OJ(t) {
        var e = (/* @__PURE__ */ new Date()).getTime(), r = t(), n = (/* @__PURE__ */ new Date()).getTime(), i = n - e;
        return { time: i, value: r };
      }
      Lf.timer = OJ;
    });
    var AO = f((exports, module) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toFastProperties = void 0;
      function toFastProperties(toBecomeFast) {
        function FakeConstructor() {
        }
        FakeConstructor.prototype = toBecomeFast;
        var fakeInstance = new FakeConstructor();
        function fakeAccess() {
          return typeof fakeInstance.bar;
        }
        return fakeAccess(), fakeAccess(), toBecomeFast;
      }
      exports.toFastProperties = toFastProperties;
    });
    var qs = f((Zn) => {
      Object.defineProperty(Zn, "__esModule", { value: true });
      Zn.toFastProperties = Zn.timer = Zn.PRINT_ERROR = Zn.PRINT_WARNING = void 0;
      var PO = bO();
      Object.defineProperty(Zn, "PRINT_WARNING", { enumerable: true, get: function() {
        return PO.PRINT_WARNING;
      } });
      Object.defineProperty(Zn, "PRINT_ERROR", { enumerable: true, get: function() {
        return PO.PRINT_ERROR;
      } });
      var DJ = SO();
      Object.defineProperty(Zn, "timer", { enumerable: true, get: function() {
        return DJ.timer;
      } });
      var IJ = AO();
      Object.defineProperty(Zn, "toFastProperties", { enumerable: true, get: function() {
        return IJ.toFastProperties;
      } });
    });
    var Mf = f((Lge, CO) => {
      function xJ(t, e, r) {
        var n = -1, i = t.length;
        e < 0 && (e = -e > i ? 0 : i + e), r = r > i ? i : r, r < 0 && (r += i), i = e > r ? 0 : r - e >>> 0, e >>>= 0;
        for (var o = Array(i); ++n < i; )
          o[n] = t[n + e];
        return o;
      }
      CO.exports = xJ;
    });
    var EO = f((Mge, NO) => {
      var qJ = /\s/;
      function LJ(t) {
        for (var e = t.length; e-- && qJ.test(t.charAt(e)); )
          ;
        return e;
      }
      NO.exports = LJ;
    });
    var wO = f(($ge, kO) => {
      var MJ = EO(), $J = /^\s+/;
      function FJ(t) {
        return t && t.slice(0, MJ(t) + 1).replace($J, "");
      }
      kO.exports = FJ;
    });
    var xO = f((Fge, IO) => {
      var jJ = wO(), OO = Pn(), UJ = ws(), DO = 0 / 0, GJ = /^[-+]0x[0-9a-f]+$/i, HJ = /^0b[01]+$/i, WJ = /^0o[0-7]+$/i, BJ = parseInt;
      function KJ(t) {
        if (typeof t == "number")
          return t;
        if (UJ(t))
          return DO;
        if (OO(t)) {
          var e = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = OO(e) ? e + "" : e;
        }
        if (typeof t != "string")
          return t === 0 ? t : +t;
        t = jJ(t);
        var r = HJ.test(t);
        return r || WJ.test(t) ? BJ(t.slice(2), r ? 2 : 8) : GJ.test(t) ? DO : +t;
      }
      IO.exports = KJ;
    });
    var MO = f((jge, LO) => {
      var zJ = xO(), qO = 1 / 0, VJ = 17976931348623157e292;
      function YJ(t) {
        if (!t)
          return t === 0 ? t : 0;
        if (t = zJ(t), t === qO || t === -qO) {
          var e = t < 0 ? -1 : 1;
          return e * VJ;
        }
        return t === t ? t : 0;
      }
      LO.exports = YJ;
    });
    var Ls = f((Uge, $O) => {
      var XJ = MO();
      function JJ(t) {
        var e = XJ(t), r = e % 1;
        return e === e ? r ? e - r : e : 0;
      }
      $O.exports = JJ;
    });
    var $f = f((Gge, FO) => {
      var QJ = Mf(), ZJ = Ls();
      function eQ(t, e, r) {
        var n = t == null ? 0 : t.length;
        return n ? (e = r || e === void 0 ? 1 : ZJ(e), QJ(t, e < 0 ? 0 : e, n)) : [];
      }
      FO.exports = eQ;
    });
    var Pc = f((Hge, jO) => {
      var tQ = vo(), rQ = qe(), nQ = Cn(), iQ = "[object String]";
      function oQ(t) {
        return typeof t == "string" || !rQ(t) && nQ(t) && tQ(t) == iQ;
      }
      jO.exports = oQ;
    });
    var GO = f((Wge, UO) => {
      var aQ = vo(), sQ = Cn(), uQ = "[object RegExp]";
      function cQ(t) {
        return sQ(t) && aQ(t) == uQ;
      }
      UO.exports = cQ;
    });
    var sT = f((Bge, BO) => {
      var lQ = GO(), dQ = bs(), HO = mc(), WO = HO && HO.isRegExp, fQ = WO ? dQ(WO) : lQ;
      BO.exports = fQ;
    });
    var VO = f((Kge, zO) => {
      var pQ = bc(), hQ = Rc(), mQ = _c(), KO = Pn(), gQ = Os();
      function yQ(t, e, r, n) {
        if (!KO(t))
          return t;
        e = hQ(e, t);
        for (var i = -1, o = e.length, a = o - 1, s = t; s != null && ++i < o; ) {
          var u = gQ(e[i]), c = r;
          if (u === "__proto__" || u === "constructor" || u === "prototype")
            return t;
          if (i != a) {
            var l = s[u];
            c = n ? n(l, u, s) : void 0, c === void 0 && (c = KO(l) ? l : mQ(e[i + 1]) ? [] : {});
          }
          pQ(s, u, c), s = s[u];
        }
        return t;
      }
      zO.exports = yQ;
    });
    var XO = f((zge, YO) => {
      var vQ = Df(), TQ = VO(), _Q = Rc();
      function RQ(t, e, r) {
        for (var n = -1, i = e.length, o = {}; ++n < i; ) {
          var a = e[n], s = vQ(t, a);
          r(s, a) && TQ(o, _Q(a, t), s);
        }
        return o;
      }
      YO.exports = RQ;
    });
    var uT = f((Vge, JO) => {
      var bQ = As(), SQ = Jr(), AQ = XO(), PQ = aT();
      function CQ(t, e) {
        if (t == null)
          return {};
        var r = bQ(PQ(t), function(n) {
          return [n];
        });
        return e = SQ(e), AQ(t, r, function(n, i) {
          return e(n, i[0]);
        });
      }
      JO.exports = CQ;
    });
    var ZO = f((Yge, QO) => {
      function NQ(t, e, r) {
        switch (r.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, r[0]);
          case 2:
            return t.call(e, r[0], r[1]);
          case 3:
            return t.call(e, r[0], r[1], r[2]);
        }
        return t.apply(e, r);
      }
      QO.exports = NQ;
    });
    var rD = f((Xge, tD) => {
      var EQ = ZO(), eD = Math.max;
      function kQ(t, e, r) {
        return e = eD(e === void 0 ? t.length - 1 : e, 0), function() {
          for (var n = arguments, i = -1, o = eD(n.length - e, 0), a = Array(o); ++i < o; )
            a[i] = n[e + i];
          i = -1;
          for (var s = Array(e + 1); ++i < e; )
            s[i] = n[i];
          return s[e] = r(a), EQ(t, this, s);
        };
      }
      tD.exports = kQ;
    });
    var iD = f((Jge, nD) => {
      function wQ(t) {
        return function() {
          return t;
        };
      }
      nD.exports = wQ;
    });
    var sD = f((Qge, aD) => {
      var OQ = iD(), oD = nT(), DQ = ua(), IQ = oD ? function(t, e) {
        return oD(t, "toString", { configurable: true, enumerable: false, value: OQ(e), writable: true });
      } : DQ;
      aD.exports = IQ;
    });
    var cD = f((Zge, uD) => {
      var xQ = 800, qQ = 16, LQ = Date.now;
      function MQ(t) {
        var e = 0, r = 0;
        return function() {
          var n = LQ(), i = qQ - (n - r);
          if (r = n, i > 0) {
            if (++e >= xQ)
              return arguments[0];
          } else
            e = 0;
          return t.apply(void 0, arguments);
        };
      }
      uD.exports = MQ;
    });
    var dD = f((eye, lD) => {
      var $Q = sD(), FQ = cD(), jQ = FQ($Q);
      lD.exports = jQ;
    });
    var Ff = f((tye, fD) => {
      var UQ = ua(), GQ = rD(), HQ = dD();
      function WQ(t, e) {
        return HQ(GQ(t, e, UQ), t + "");
      }
      fD.exports = WQ;
    });
    var Cc = f((rye, pD) => {
      var BQ = Ps(), KQ = Nn(), zQ = _c(), VQ = Pn();
      function YQ(t, e, r) {
        if (!VQ(r))
          return false;
        var n = typeof e;
        return (n == "number" ? KQ(r) && zQ(e, r.length) : n == "string" && e in r) ? BQ(r[e], t) : false;
      }
      pD.exports = YQ;
    });
    var mD = f((nye, hD) => {
      var XQ = Ff(), JQ = Cc();
      function QQ(t) {
        return XQ(function(e, r) {
          var n = -1, i = r.length, o = i > 1 ? r[i - 1] : void 0, a = i > 2 ? r[2] : void 0;
          for (o = t.length > 3 && typeof o == "function" ? (i--, o) : void 0, a && JQ(r[0], r[1], a) && (o = i < 3 ? void 0 : o, i = 1), e = Object(e); ++n < i; ) {
            var s = r[n];
            s && t(e, s, n, o);
          }
          return e;
        });
      }
      hD.exports = QQ;
    });
    var Nc = f((iye, gD) => {
      var ZQ = bc(), eZ = Ds(), tZ = mD(), rZ = Nn(), nZ = ys(), iZ = Dr(), oZ = Object.prototype, aZ = oZ.hasOwnProperty, sZ = tZ(function(t, e) {
        if (nZ(e) || rZ(e)) {
          eZ(e, iZ(e), t);
          return;
        }
        for (var r in e)
          aZ.call(e, r) && ZQ(t, r, e[r]);
      });
      gD.exports = sZ;
    });
    var Uf = f((Ae) => {
      var xi = Ae && Ae.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), Ms = Ae && Ae.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Ae, "__esModule", { value: true });
      Ae.serializeProduction = Ae.serializeGrammar = Ae.Terminal = Ae.Alternation = Ae.RepetitionWithSeparator = Ae.Repetition = Ae.RepetitionMandatoryWithSeparator = Ae.RepetitionMandatory = Ae.Option = Ae.Alternative = Ae.Rule = Ae.NonTerminal = Ae.AbstractProduction = void 0;
      var yD = Ms(jt()), uZ = Ms(Ut()), cT = Ms(Pc()), cZ = Ms(sT()), ei = Ms(uT()), ti = Ms(Nc());
      function lZ(t) {
        return dZ(t) ? t.LABEL : t.name;
      }
      function dZ(t) {
        return (0, cT.default)(t.LABEL) && t.LABEL !== "";
      }
      var ri = function() {
        function t(e) {
          this._definition = e;
        }
        return Object.defineProperty(t.prototype, "definition", { get: function() {
          return this._definition;
        }, set: function(e) {
          this._definition = e;
        }, enumerable: false, configurable: true }), t.prototype.accept = function(e) {
          e.visit(this), (0, uZ.default)(this.definition, function(r) {
            r.accept(e);
          });
        }, t;
      }();
      Ae.AbstractProduction = ri;
      var vD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, []) || this;
          return n.idx = 1, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return Object.defineProperty(e.prototype, "definition", { get: function() {
          return this.referencedRule !== void 0 ? this.referencedRule.definition : [];
        }, set: function(r) {
        }, enumerable: false, configurable: true }), e.prototype.accept = function(r) {
          r.visit(this);
        }, e;
      }(ri);
      Ae.NonTerminal = vD;
      var TD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.orgText = "", (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return e;
      }(ri);
      Ae.Rule = TD;
      var _D = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.ignoreAmbiguities = false, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return e;
      }(ri);
      Ae.Alternative = _D;
      var RD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.idx = 1, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return e;
      }(ri);
      Ae.Option = RD;
      var bD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.idx = 1, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return e;
      }(ri);
      Ae.RepetitionMandatory = bD;
      var SD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.idx = 1, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return e;
      }(ri);
      Ae.RepetitionMandatoryWithSeparator = SD;
      var AD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.idx = 1, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return e;
      }(ri);
      Ae.Repetition = AD;
      var PD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.idx = 1, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return e;
      }(ri);
      Ae.RepetitionWithSeparator = PD;
      var CD = function(t) {
        xi(e, t);
        function e(r) {
          var n = t.call(this, r.definition) || this;
          return n.idx = 1, n.ignoreAmbiguities = false, n.hasPredicates = false, (0, ti.default)(n, (0, ei.default)(r, function(i) {
            return i !== void 0;
          })), n;
        }
        return Object.defineProperty(e.prototype, "definition", { get: function() {
          return this._definition;
        }, set: function(r) {
          this._definition = r;
        }, enumerable: false, configurable: true }), e;
      }(ri);
      Ae.Alternation = CD;
      var jf = function() {
        function t(e) {
          this.idx = 1, (0, ti.default)(this, (0, ei.default)(e, function(r) {
            return r !== void 0;
          }));
        }
        return t.prototype.accept = function(e) {
          e.visit(this);
        }, t;
      }();
      Ae.Terminal = jf;
      function fZ(t) {
        return (0, yD.default)(t, Ec);
      }
      Ae.serializeGrammar = fZ;
      function Ec(t) {
        function e(o) {
          return (0, yD.default)(o, Ec);
        }
        if (t instanceof vD) {
          var r = { type: "NonTerminal", name: t.nonTerminalName, idx: t.idx };
          return (0, cT.default)(t.label) && (r.label = t.label), r;
        } else {
          if (t instanceof _D)
            return { type: "Alternative", definition: e(t.definition) };
          if (t instanceof RD)
            return { type: "Option", idx: t.idx, definition: e(t.definition) };
          if (t instanceof bD)
            return { type: "RepetitionMandatory", idx: t.idx, definition: e(t.definition) };
          if (t instanceof SD)
            return { type: "RepetitionMandatoryWithSeparator", idx: t.idx, separator: Ec(new jf({ terminalType: t.separator })), definition: e(t.definition) };
          if (t instanceof PD)
            return { type: "RepetitionWithSeparator", idx: t.idx, separator: Ec(new jf({ terminalType: t.separator })), definition: e(t.definition) };
          if (t instanceof AD)
            return { type: "Repetition", idx: t.idx, definition: e(t.definition) };
          if (t instanceof CD)
            return { type: "Alternation", idx: t.idx, definition: e(t.definition) };
          if (t instanceof jf) {
            var n = { type: "Terminal", name: t.terminalType.name, label: lZ(t.terminalType), idx: t.idx };
            (0, cT.default)(t.label) && (n.terminalLabel = t.label);
            var i = t.terminalType.PATTERN;
            return t.terminalType.PATTERN && (n.pattern = (0, cZ.default)(i) ? i.source : i), n;
          } else {
            if (t instanceof TD)
              return { type: "Rule", name: t.name, orgText: t.orgText, definition: e(t.definition) };
            throw Error("non exhaustive match");
          }
        }
      }
      Ae.serializeProduction = Ec;
    });
    var ND = f((Gf) => {
      Object.defineProperty(Gf, "__esModule", { value: true });
      Gf.GAstVisitor = void 0;
      var ni = Uf(), pZ = function() {
        function t() {
        }
        return t.prototype.visit = function(e) {
          var r = e;
          switch (r.constructor) {
            case ni.NonTerminal:
              return this.visitNonTerminal(r);
            case ni.Alternative:
              return this.visitAlternative(r);
            case ni.Option:
              return this.visitOption(r);
            case ni.RepetitionMandatory:
              return this.visitRepetitionMandatory(r);
            case ni.RepetitionMandatoryWithSeparator:
              return this.visitRepetitionMandatoryWithSeparator(r);
            case ni.RepetitionWithSeparator:
              return this.visitRepetitionWithSeparator(r);
            case ni.Repetition:
              return this.visitRepetition(r);
            case ni.Alternation:
              return this.visitAlternation(r);
            case ni.Terminal:
              return this.visitTerminal(r);
            case ni.Rule:
              return this.visitRule(r);
            default:
              throw Error("non exhaustive match");
          }
        }, t.prototype.visitNonTerminal = function(e) {
        }, t.prototype.visitAlternative = function(e) {
        }, t.prototype.visitOption = function(e) {
        }, t.prototype.visitRepetition = function(e) {
        }, t.prototype.visitRepetitionMandatory = function(e) {
        }, t.prototype.visitRepetitionMandatoryWithSeparator = function(e) {
        }, t.prototype.visitRepetitionWithSeparator = function(e) {
        }, t.prototype.visitAlternation = function(e) {
        }, t.prototype.visitTerminal = function(e) {
        }, t.prototype.visitRule = function(e) {
        }, t;
      }();
      Gf.GAstVisitor = pZ;
    });
    var kD = f((sye, ED) => {
      var hZ = _o();
      function mZ(t, e) {
        var r;
        return hZ(t, function(n, i, o) {
          return r = e(n, i, o), !r;
        }), !!r;
      }
      ED.exports = mZ;
    });
    var Hf = f((uye, wD) => {
      var gZ = Uv(), yZ = Jr(), vZ = kD(), TZ = qe(), _Z = Cc();
      function RZ(t, e, r) {
        var n = TZ(t) ? gZ : vZ;
        return r && _Z(t, e, r) && (e = void 0), n(t, yZ(e, 3));
      }
      wD.exports = RZ;
    });
    var DD = f((cye, OD) => {
      function bZ(t, e) {
        for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
          if (!e(t[r], r, t))
            return false;
        return true;
      }
      OD.exports = bZ;
    });
    var xD = f((lye, ID) => {
      var SZ = _o();
      function AZ(t, e) {
        var r = true;
        return SZ(t, function(n, i, o) {
          return r = !!e(n, i, o), r;
        }), r;
      }
      ID.exports = AZ;
    });
    var kc = f((dye, qD) => {
      var PZ = DD(), CZ = xD(), NZ = Jr(), EZ = qe(), kZ = Cc();
      function wZ(t, e, r) {
        var n = EZ(t) ? PZ : CZ;
        return r && kZ(t, e, r) && (e = void 0), n(t, NZ(e, 3));
      }
      qD.exports = wZ;
    });
    var lT = f((fye, LD) => {
      function OZ(t, e, r, n) {
        for (var i = t.length, o = r + (n ? 1 : -1); n ? o-- : ++o < i; )
          if (e(t[o], o, t))
            return o;
        return -1;
      }
      LD.exports = OZ;
    });
    var $D = f((pye, MD) => {
      function DZ(t) {
        return t !== t;
      }
      MD.exports = DZ;
    });
    var jD = f((hye, FD) => {
      function IZ(t, e, r) {
        for (var n = r - 1, i = t.length; ++n < i; )
          if (t[n] === e)
            return n;
        return -1;
      }
      FD.exports = IZ;
    });
    var Wf = f((mye, UD) => {
      var xZ = lT(), qZ = $D(), LZ = jD();
      function MZ(t, e, r) {
        return e === e ? LZ(t, e, r) : xZ(t, qZ, r);
      }
      UD.exports = MZ;
    });
    var qi = f((gye, GD) => {
      var $Z = Wf(), FZ = Nn(), jZ = Pc(), UZ = Ls(), GZ = Qn(), HZ = Math.max;
      function WZ(t, e, r, n) {
        t = FZ(t) ? t : GZ(t), r = r && !n ? UZ(r) : 0;
        var i = t.length;
        return r < 0 && (r = HZ(i + r, 0)), jZ(t) ? r <= i && t.indexOf(e, r) > -1 : !!i && $Z(t, e, r) > -1;
      }
      GD.exports = WZ;
    });
    var HD = f((Qr) => {
      var fT = Qr && Qr.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Qr, "__esModule", { value: true });
      Qr.getProductionDslName = Qr.isBranchingProd = Qr.isOptionalProd = Qr.isSequenceProd = void 0;
      var BZ = fT(Hf()), KZ = fT(kc()), zZ = fT(qi()), ot = Uf();
      function VZ(t) {
        return t instanceof ot.Alternative || t instanceof ot.Option || t instanceof ot.Repetition || t instanceof ot.RepetitionMandatory || t instanceof ot.RepetitionMandatoryWithSeparator || t instanceof ot.RepetitionWithSeparator || t instanceof ot.Terminal || t instanceof ot.Rule;
      }
      Qr.isSequenceProd = VZ;
      function dT(t, e) {
        e === void 0 && (e = []);
        var r = t instanceof ot.Option || t instanceof ot.Repetition || t instanceof ot.RepetitionWithSeparator;
        return r ? true : t instanceof ot.Alternation ? (0, BZ.default)(t.definition, function(n) {
          return dT(n, e);
        }) : t instanceof ot.NonTerminal && (0, zZ.default)(e, t) ? false : t instanceof ot.AbstractProduction ? (t instanceof ot.NonTerminal && e.push(t), (0, KZ.default)(t.definition, function(n) {
          return dT(n, e);
        })) : false;
      }
      Qr.isOptionalProd = dT;
      function YZ(t) {
        return t instanceof ot.Alternation;
      }
      Qr.isBranchingProd = YZ;
      function XZ(t) {
        if (t instanceof ot.NonTerminal)
          return "SUBRULE";
        if (t instanceof ot.Option)
          return "OPTION";
        if (t instanceof ot.Alternation)
          return "OR";
        if (t instanceof ot.RepetitionMandatory)
          return "AT_LEAST_ONE";
        if (t instanceof ot.RepetitionMandatoryWithSeparator)
          return "AT_LEAST_ONE_SEP";
        if (t instanceof ot.RepetitionWithSeparator)
          return "MANY_SEP";
        if (t instanceof ot.Repetition)
          return "MANY";
        if (t instanceof ot.Terminal)
          return "CONSUME";
        throw Error("non exhaustive match");
      }
      Qr.getProductionDslName = XZ;
    });
    var vt = f((he) => {
      Object.defineProperty(he, "__esModule", { value: true });
      he.isSequenceProd = he.isBranchingProd = he.isOptionalProd = he.getProductionDslName = he.GAstVisitor = he.serializeProduction = he.serializeGrammar = he.Alternative = he.Alternation = he.RepetitionWithSeparator = he.RepetitionMandatoryWithSeparator = he.RepetitionMandatory = he.Repetition = he.Option = he.NonTerminal = he.Terminal = he.Rule = void 0;
      var Zr = Uf();
      Object.defineProperty(he, "Rule", { enumerable: true, get: function() {
        return Zr.Rule;
      } });
      Object.defineProperty(he, "Terminal", { enumerable: true, get: function() {
        return Zr.Terminal;
      } });
      Object.defineProperty(he, "NonTerminal", { enumerable: true, get: function() {
        return Zr.NonTerminal;
      } });
      Object.defineProperty(he, "Option", { enumerable: true, get: function() {
        return Zr.Option;
      } });
      Object.defineProperty(he, "Repetition", { enumerable: true, get: function() {
        return Zr.Repetition;
      } });
      Object.defineProperty(he, "RepetitionMandatory", { enumerable: true, get: function() {
        return Zr.RepetitionMandatory;
      } });
      Object.defineProperty(he, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
        return Zr.RepetitionMandatoryWithSeparator;
      } });
      Object.defineProperty(he, "RepetitionWithSeparator", { enumerable: true, get: function() {
        return Zr.RepetitionWithSeparator;
      } });
      Object.defineProperty(he, "Alternation", { enumerable: true, get: function() {
        return Zr.Alternation;
      } });
      Object.defineProperty(he, "Alternative", { enumerable: true, get: function() {
        return Zr.Alternative;
      } });
      Object.defineProperty(he, "serializeGrammar", { enumerable: true, get: function() {
        return Zr.serializeGrammar;
      } });
      Object.defineProperty(he, "serializeProduction", { enumerable: true, get: function() {
        return Zr.serializeProduction;
      } });
      var JZ = ND();
      Object.defineProperty(he, "GAstVisitor", { enumerable: true, get: function() {
        return JZ.GAstVisitor;
      } });
      var Bf = HD();
      Object.defineProperty(he, "getProductionDslName", { enumerable: true, get: function() {
        return Bf.getProductionDslName;
      } });
      Object.defineProperty(he, "isOptionalProd", { enumerable: true, get: function() {
        return Bf.isOptionalProd;
      } });
      Object.defineProperty(he, "isBranchingProd", { enumerable: true, get: function() {
        return Bf.isBranchingProd;
      } });
      Object.defineProperty(he, "isSequenceProd", { enumerable: true, get: function() {
        return Bf.isSequenceProd;
      } });
    });
    var Kf = f(($s) => {
      var KD = $s && $s.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty($s, "__esModule", { value: true });
      $s.RestWalker = void 0;
      var QZ = KD($f()), WD = KD(Ut()), _r = vt(), ZZ = function() {
        function t() {
        }
        return t.prototype.walk = function(e, r) {
          var n = this;
          r === void 0 && (r = []), (0, WD.default)(e.definition, function(i, o) {
            var a = (0, QZ.default)(e.definition, o + 1);
            if (i instanceof _r.NonTerminal)
              n.walkProdRef(i, a, r);
            else if (i instanceof _r.Terminal)
              n.walkTerminal(i, a, r);
            else if (i instanceof _r.Alternative)
              n.walkFlat(i, a, r);
            else if (i instanceof _r.Option)
              n.walkOption(i, a, r);
            else if (i instanceof _r.RepetitionMandatory)
              n.walkAtLeastOne(i, a, r);
            else if (i instanceof _r.RepetitionMandatoryWithSeparator)
              n.walkAtLeastOneSep(i, a, r);
            else if (i instanceof _r.RepetitionWithSeparator)
              n.walkManySep(i, a, r);
            else if (i instanceof _r.Repetition)
              n.walkMany(i, a, r);
            else if (i instanceof _r.Alternation)
              n.walkOr(i, a, r);
            else
              throw Error("non exhaustive match");
          });
        }, t.prototype.walkTerminal = function(e, r, n) {
        }, t.prototype.walkProdRef = function(e, r, n) {
        }, t.prototype.walkFlat = function(e, r, n) {
          var i = r.concat(n);
          this.walk(e, i);
        }, t.prototype.walkOption = function(e, r, n) {
          var i = r.concat(n);
          this.walk(e, i);
        }, t.prototype.walkAtLeastOne = function(e, r, n) {
          var i = [new _r.Option({ definition: e.definition })].concat(r, n);
          this.walk(e, i);
        }, t.prototype.walkAtLeastOneSep = function(e, r, n) {
          var i = BD(e, r, n);
          this.walk(e, i);
        }, t.prototype.walkMany = function(e, r, n) {
          var i = [new _r.Option({ definition: e.definition })].concat(r, n);
          this.walk(e, i);
        }, t.prototype.walkManySep = function(e, r, n) {
          var i = BD(e, r, n);
          this.walk(e, i);
        }, t.prototype.walkOr = function(e, r, n) {
          var i = this, o = r.concat(n);
          (0, WD.default)(e.definition, function(a) {
            var s = new _r.Alternative({ definition: [a] });
            i.walk(s, o);
          });
        }, t;
      }();
      $s.RestWalker = ZZ;
      function BD(t, e, r) {
        var n = [new _r.Option({ definition: [new _r.Terminal({ terminalType: t.separator })].concat(t.definition) })], i = n.concat(e, r);
        return i;
      }
    });
    var XD = f((_ye, YD) => {
      var zD = aa(), eee = lc(), tee = qe(), VD = zD ? zD.isConcatSpreadable : void 0;
      function ree(t) {
        return tee(t) || eee(t) || !!(VD && t && t[VD]);
      }
      YD.exports = ree;
    });
    var zf = f((Rye, QD) => {
      var nee = Nf(), iee = XD();
      function JD(t, e, r, n, i) {
        var o = -1, a = t.length;
        for (r || (r = iee), i || (i = []); ++o < a; ) {
          var s = t[o];
          e > 0 && r(s) ? e > 1 ? JD(s, e - 1, r, n, i) : nee(i, s) : n || (i[i.length] = s);
        }
        return i;
      }
      QD.exports = JD;
    });
    var En = f((bye, ZD) => {
      var oee = zf();
      function aee(t) {
        var e = t == null ? 0 : t.length;
        return e ? oee(t, 1) : [];
      }
      ZD.exports = aee;
    });
    var pT = f((Sye, eI) => {
      var see = Wf();
      function uee(t, e) {
        var r = t == null ? 0 : t.length;
        return !!r && see(t, e, 0) > -1;
      }
      eI.exports = uee;
    });
    var hT = f((Aye, tI) => {
      function cee(t, e, r) {
        for (var n = -1, i = t == null ? 0 : t.length; ++n < i; )
          if (r(e, t[n]))
            return true;
        return false;
      }
      tI.exports = cee;
    });
    var Vf = f((Pye, rI) => {
      function lee() {
      }
      rI.exports = lee;
    });
    var iI = f((Cye, nI) => {
      var mT = xv(), dee = Vf(), fee = Cf(), pee = 1 / 0, hee = mT && 1 / fee(new mT([, -0]))[1] == pee ? function(t) {
        return new mT(t);
      } : dee;
      nI.exports = hee;
    });
    var gT = f((Nye, oI) => {
      var mee = Af(), gee = pT(), yee = hT(), vee = Pf(), Tee = iI(), _ee = Cf(), Ree = 200;
      function bee(t, e, r) {
        var n = -1, i = gee, o = t.length, a = true, s = [], u = s;
        if (r)
          a = false, i = yee;
        else if (o >= Ree) {
          var c = e ? null : Tee(t);
          if (c)
            return _ee(c);
          a = false, i = vee, u = new mee();
        } else
          u = e ? [] : s;
        e:
          for (; ++n < o; ) {
            var l = t[n], d = e ? e(l) : l;
            if (l = r || l !== 0 ? l : 0, a && d === d) {
              for (var h = u.length; h--; )
                if (u[h] === d)
                  continue e;
              e && u.push(d), s.push(l);
            } else
              i(u, d, r) || (u !== s && u.push(d), s.push(l));
          }
        return s;
      }
      oI.exports = bee;
    });
    var Yf = f((Eye, aI) => {
      var See = gT();
      function Aee(t) {
        return t && t.length ? See(t) : [];
      }
      aI.exports = Aee;
    });
    var TT = f((en) => {
      var vT = en && en.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(en, "__esModule", { value: true });
      en.firstForTerminal = en.firstForBranching = en.firstForSequence = en.first = void 0;
      var Pee = vT(En()), uI = vT(Yf()), Cee = vT(jt()), sI = vt(), yT = vt();
      function Xf(t) {
        if (t instanceof sI.NonTerminal)
          return Xf(t.referencedRule);
        if (t instanceof sI.Terminal)
          return dI(t);
        if ((0, yT.isSequenceProd)(t))
          return cI(t);
        if ((0, yT.isBranchingProd)(t))
          return lI(t);
        throw Error("non exhaustive match");
      }
      en.first = Xf;
      function cI(t) {
        for (var e = [], r = t.definition, n = 0, i = r.length > n, o, a = true; i && a; )
          o = r[n], a = (0, yT.isOptionalProd)(o), e = e.concat(Xf(o)), n = n + 1, i = r.length > n;
        return (0, uI.default)(e);
      }
      en.firstForSequence = cI;
      function lI(t) {
        var e = (0, Cee.default)(t.definition, function(r) {
          return Xf(r);
        });
        return (0, uI.default)((0, Pee.default)(e));
      }
      en.firstForBranching = lI;
      function dI(t) {
        return [t.terminalType];
      }
      en.firstForTerminal = dI;
    });
    var _T = f((Jf) => {
      Object.defineProperty(Jf, "__esModule", { value: true });
      Jf.IN = void 0;
      Jf.IN = "_~IN~_";
    });
    var gI = f((Rr) => {
      var Nee = Rr && Rr.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), fI = Rr && Rr.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Rr, "__esModule", { value: true });
      Rr.buildInProdFollowPrefix = Rr.buildBetweenProdsFollowPrefix = Rr.computeAllProdsFollows = Rr.ResyncFollowsWalker = void 0;
      var Eee = Kf(), kee = TT(), wee = fI(Ut()), Oee = fI(Nc()), pI = _T(), Dee = vt(), hI = function(t) {
        Nee(e, t);
        function e(r) {
          var n = t.call(this) || this;
          return n.topProd = r, n.follows = {}, n;
        }
        return e.prototype.startWalking = function() {
          return this.walk(this.topProd), this.follows;
        }, e.prototype.walkTerminal = function(r, n, i) {
        }, e.prototype.walkProdRef = function(r, n, i) {
          var o = mI(r.referencedRule, r.idx) + this.topProd.name, a = n.concat(i), s = new Dee.Alternative({ definition: a }), u = (0, kee.first)(s);
          this.follows[o] = u;
        }, e;
      }(Eee.RestWalker);
      Rr.ResyncFollowsWalker = hI;
      function Iee(t) {
        var e = {};
        return (0, wee.default)(t, function(r) {
          var n = new hI(r).startWalking();
          (0, Oee.default)(e, n);
        }), e;
      }
      Rr.computeAllProdsFollows = Iee;
      function mI(t, e) {
        return t.name + e + pI.IN;
      }
      Rr.buildBetweenProdsFollowPrefix = mI;
      function xee(t) {
        var e = t.terminalType.name;
        return e + t.idx + pI.IN;
      }
      Rr.buildInProdFollowPrefix = xee;
    });
    var ca = f((Dye, yI) => {
      function qee(t) {
        return t === void 0;
      }
      yI.exports = qee;
    });
    var TI = f((Iye, vI) => {
      function Lee(t) {
        return t && t.length ? t[0] : void 0;
      }
      vI.exports = Lee;
    });
    var Fs = f((xye, _I) => {
      _I.exports = TI();
    });
    var wc = f((qye, RI) => {
      function Mee(t) {
        for (var e = -1, r = t == null ? 0 : t.length, n = 0, i = []; ++e < r; ) {
          var o = t[e];
          o && (i[n++] = o);
        }
        return i;
      }
      RI.exports = Mee;
    });
    var RT = f((Lye, bI) => {
      var $ee = _o();
      function Fee(t, e) {
        var r = [];
        return $ee(t, function(n, i, o) {
          e(n, i, o) && r.push(n);
        }), r;
      }
      bI.exports = Fee;
    });
    var AI = f((Mye, SI) => {
      var jee = "Expected a function";
      function Uee(t) {
        if (typeof t != "function")
          throw new TypeError(jee);
        return function() {
          var e = arguments;
          switch (e.length) {
            case 0:
              return !t.call(this);
            case 1:
              return !t.call(this, e[0]);
            case 2:
              return !t.call(this, e[0], e[1]);
            case 3:
              return !t.call(this, e[0], e[1], e[2]);
          }
          return !t.apply(this, e);
        };
      }
      SI.exports = Uee;
    });
    var Qf = f(($ye, PI) => {
      var Gee = Ef(), Hee = RT(), Wee = Jr(), Bee = qe(), Kee = AI();
      function zee(t, e) {
        var r = Bee(t) ? Gee : Hee;
        return r(t, Kee(Wee(e, 3)));
      }
      PI.exports = zee;
    });
    var NI = f((Fye, CI) => {
      var Vee = Af(), Yee = pT(), Xee = hT(), Jee = As(), Qee = bs(), Zee = Pf(), ete = 200;
      function tte(t, e, r, n) {
        var i = -1, o = Yee, a = true, s = t.length, u = [], c = e.length;
        if (!s)
          return u;
        r && (e = Jee(e, Qee(r))), n ? (o = Xee, a = false) : e.length >= ete && (o = Zee, a = false, e = new Vee(e));
        e:
          for (; ++i < s; ) {
            var l = t[i], d = r == null ? l : r(l);
            if (l = n || l !== 0 ? l : 0, a && d === d) {
              for (var h = c; h--; )
                if (e[h] === d)
                  continue e;
              u.push(l);
            } else
              o(e, d, n) || u.push(l);
          }
        return u;
      }
      CI.exports = tte;
    });
    var kI = f((jye, EI) => {
      var rte = Nn(), nte = Cn();
      function ite(t) {
        return nte(t) && rte(t);
      }
      EI.exports = ite;
    });
    var Zf = f((Uye, OI) => {
      var ote = NI(), ate = zf(), ste = Ff(), wI = kI(), ute = ste(function(t, e) {
        return wI(t) ? ote(t, ate(e, 1, wI, true)) : [];
      });
      OI.exports = ute;
    });
    var II = f((Gye, DI) => {
      var cte = Wf(), lte = Ls(), dte = Math.max;
      function fte(t, e, r) {
        var n = t == null ? 0 : t.length;
        if (!n)
          return -1;
        var i = r == null ? 0 : lte(r);
        return i < 0 && (i = dte(n + i, 0)), cte(t, e, i);
      }
      DI.exports = fte;
    });
    var qI = f((Hye, xI) => {
      var pte = Jr(), hte = Nn(), mte = Dr();
      function gte(t) {
        return function(e, r, n) {
          var i = Object(e);
          if (!hte(e)) {
            var o = pte(r, 3);
            e = mte(e), r = function(s) {
              return o(i[s], s, i);
            };
          }
          var a = t(e, r, n);
          return a > -1 ? i[o ? e[a] : a] : void 0;
        };
      }
      xI.exports = gte;
    });
    var MI = f((Wye, LI) => {
      var yte = lT(), vte = Jr(), Tte = Ls(), _te = Math.max;
      function Rte(t, e, r) {
        var n = t == null ? 0 : t.length;
        if (!n)
          return -1;
        var i = r == null ? 0 : Tte(r);
        return i < 0 && (i = _te(n + i, 0)), yte(t, vte(e, 3), i);
      }
      LI.exports = Rte;
    });
    var ep = f((Bye, $I) => {
      var bte = qI(), Ste = MI(), Ate = bte(Ste);
      $I.exports = Ate;
    });
    var Oc = f((Kye, FI) => {
      var Pte = Ef(), Cte = RT(), Nte = Jr(), Ete = qe();
      function kte(t, e) {
        var r = Ete(t) ? Pte : Cte;
        return r(t, Nte(e, 3));
      }
      FI.exports = kte;
    });
    var bT = f((zye, UI) => {
      var wte = Ff(), Ote = Ps(), Dte = Cc(), Ite = Sc(), jI = Object.prototype, xte = jI.hasOwnProperty, qte = wte(function(t, e) {
        t = Object(t);
        var r = -1, n = e.length, i = n > 2 ? e[2] : void 0;
        for (i && Dte(e[0], e[1], i) && (n = 1); ++r < n; )
          for (var o = e[r], a = Ite(o), s = -1, u = a.length; ++s < u; ) {
            var c = a[s], l = t[c];
            (l === void 0 || Ote(l, jI[c]) && !xte.call(t, c)) && (t[c] = o[c]);
          }
        return t;
      });
      UI.exports = qte;
    });
    var HI = f((Vye, GI) => {
      function Lte(t, e, r, n) {
        var i = -1, o = t == null ? 0 : t.length;
        for (n && o && (r = t[++i]); ++i < o; )
          r = e(r, t[i], i, t);
        return r;
      }
      GI.exports = Lte;
    });
    var BI = f((Yye, WI) => {
      function Mte(t, e, r, n, i) {
        return i(t, function(o, a, s) {
          r = n ? (n = false, o) : e(r, o, a, s);
        }), r;
      }
      WI.exports = Mte;
    });
    var Li = f((Xye, KI) => {
      var $te = HI(), Fte = _o(), jte = Jr(), Ute = BI(), Gte = qe();
      function Hte(t, e, r) {
        var n = Gte(t) ? $te : Ute, i = arguments.length < 3;
        return n(t, jte(e, 4), r, i, Fte);
      }
      KI.exports = Hte;
    });
    var rp = f((js) => {
      Object.defineProperty(js, "__esModule", { value: true });
      js.clearRegExpParserCache = js.getRegExpAst = void 0;
      var Wte = tc(), tp = {}, Bte = new Wte.RegExpParser();
      function Kte(t) {
        var e = t.toString();
        if (tp.hasOwnProperty(e))
          return tp[e];
        var r = Bte.pattern(e);
        return tp[e] = r, r;
      }
      js.getRegExpAst = Kte;
      function zte() {
        tp = {};
      }
      js.clearRegExpParserCache = zte;
    });
    var QI = f((rr) => {
      var Vte = rr && rr.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), Us = rr && rr.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(rr, "__esModule", { value: true });
      rr.canMatchCharCode = rr.firstCharOptimizedIndices = rr.getOptimizedStartCodesIndices = rr.failedOptimizationPrefixMsg = void 0;
      var YI = tc(), Yte = Us(qe()), Xte = Us(kc()), Jte = Us(Ut()), ST = Us(ep()), Qte = Us(Qn()), PT = Us(qi()), zI = qs(), XI = rp(), Mi = CT(), JI = "Complement Sets are not supported for first char optimization";
      rr.failedOptimizationPrefixMsg = `Unable to use "first char" lexer optimizations:
`;
      function Zte(t, e) {
        e === void 0 && (e = false);
        try {
          var r = (0, XI.getRegExpAst)(t), n = ip(r.value, {}, r.flags.ignoreCase);
          return n;
        } catch (o) {
          if (o.message === JI)
            e && (0, zI.PRINT_WARNING)("".concat(rr.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(t.toString(), ` >
`) + `	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
          else {
            var i = "";
            e && (i = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), (0, zI.PRINT_ERROR)("".concat(rr.failedOptimizationPrefixMsg, `
`) + "	Failed parsing: < ".concat(t.toString(), ` >
`) + "	Using the regexp-to-ast library version: ".concat(YI.VERSION, `
`) + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + i);
          }
        }
        return [];
      }
      rr.getOptimizedStartCodesIndices = Zte;
      function ip(t, e, r) {
        switch (t.type) {
          case "Disjunction":
            for (var n = 0; n < t.value.length; n++)
              ip(t.value[n], e, r);
            break;
          case "Alternative":
            for (var i = t.value, n = 0; n < i.length; n++) {
              var o = i[n];
              switch (o.type) {
                case "EndAnchor":
                case "GroupBackReference":
                case "Lookahead":
                case "NegativeLookahead":
                case "StartAnchor":
                case "WordBoundary":
                case "NonWordBoundary":
                  continue;
              }
              var a = o;
              switch (a.type) {
                case "Character":
                  np(a.value, e, r);
                  break;
                case "Set":
                  if (a.complement === true)
                    throw Error(JI);
                  (0, Jte.default)(a.value, function(c) {
                    if (typeof c == "number")
                      np(c, e, r);
                    else {
                      var l = c;
                      if (r === true)
                        for (var d = l.from; d <= l.to; d++)
                          np(d, e, r);
                      else {
                        for (var d = l.from; d <= l.to && d < Mi.minOptimizationVal; d++)
                          np(d, e, r);
                        if (l.to >= Mi.minOptimizationVal)
                          for (var h = l.from >= Mi.minOptimizationVal ? l.from : Mi.minOptimizationVal, y = l.to, m = (0, Mi.charCodeToOptimizedIndex)(h), R = (0, Mi.charCodeToOptimizedIndex)(y), C = m; C <= R; C++)
                            e[C] = C;
                      }
                    }
                  });
                  break;
                case "Group":
                  ip(a.value, e, r);
                  break;
                default:
                  throw Error("Non Exhaustive Match");
              }
              var s = a.quantifier !== void 0 && a.quantifier.atLeast === 0;
              if (a.type === "Group" && AT(a) === false || a.type !== "Group" && s === false)
                break;
            }
            break;
          default:
            throw Error("non exhaustive match!");
        }
        return (0, Qte.default)(e);
      }
      rr.firstCharOptimizedIndices = ip;
      function np(t, e, r) {
        var n = (0, Mi.charCodeToOptimizedIndex)(t);
        e[n] = n, r === true && ere(t, e);
      }
      function ere(t, e) {
        var r = String.fromCharCode(t), n = r.toUpperCase();
        if (n !== r) {
          var i = (0, Mi.charCodeToOptimizedIndex)(n.charCodeAt(0));
          e[i] = i;
        } else {
          var o = r.toLowerCase();
          if (o !== r) {
            var i = (0, Mi.charCodeToOptimizedIndex)(o.charCodeAt(0));
            e[i] = i;
          }
        }
      }
      function VI(t, e) {
        return (0, ST.default)(t.value, function(r) {
          if (typeof r == "number")
            return (0, PT.default)(e, r);
          var n = r;
          return (0, ST.default)(e, function(i) {
            return n.from <= i && i <= n.to;
          }) !== void 0;
        });
      }
      function AT(t) {
        var e = t.quantifier;
        return e && e.atLeast === 0 ? true : t.value ? (0, Yte.default)(t.value) ? (0, Xte.default)(t.value, AT) : AT(t.value) : false;
      }
      var tre = function(t) {
        Vte(e, t);
        function e(r) {
          var n = t.call(this) || this;
          return n.targetCharCodes = r, n.found = false, n;
        }
        return e.prototype.visitChildren = function(r) {
          if (this.found !== true) {
            switch (r.type) {
              case "Lookahead":
                this.visitLookahead(r);
                return;
              case "NegativeLookahead":
                this.visitNegativeLookahead(r);
                return;
            }
            t.prototype.visitChildren.call(this, r);
          }
        }, e.prototype.visitCharacter = function(r) {
          (0, PT.default)(this.targetCharCodes, r.value) && (this.found = true);
        }, e.prototype.visitSet = function(r) {
          r.complement ? VI(r, this.targetCharCodes) === void 0 && (this.found = true) : VI(r, this.targetCharCodes) !== void 0 && (this.found = true);
        }, e;
      }(YI.BaseRegExpVisitor);
      function rre(t, e) {
        if (e instanceof RegExp) {
          var r = (0, XI.getRegExpAst)(e), n = new tre(t);
          return n.visit(r), n.found;
        } else
          return (0, ST.default)(e, function(i) {
            return (0, PT.default)(t, i.charCodeAt(0));
          }) !== void 0;
      }
      rr.canMatchCharCode = rre;
    });
    var CT = f((H) => {
      var tx = H && H.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), ht = H && H.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(H, "__esModule", { value: true });
      H.charCodeToOptimizedIndex = H.minOptimizationVal = H.buildLineBreakIssueMessage = H.LineTerminatorOptimizedTester = H.isShortPattern = H.isCustomPattern = H.cloneEmptyGroups = H.performWarningRuntimeChecks = H.performRuntimeChecks = H.addStickyFlag = H.addStartOfInput = H.findUnreachablePatterns = H.findModesThatDoNotExist = H.findInvalidGroupType = H.findDuplicatePatterns = H.findUnsupportedFlags = H.findStartOfInputAnchor = H.findEmptyMatchRegExps = H.findEndOfInputAnchor = H.findInvalidPatterns = H.findMissingPatterns = H.validatePatterns = H.analyzeTokenTypes = H.enableSticky = H.disableSticky = H.SUPPORT_STICKY = H.MODES = H.DEFAULT_MODE = void 0;
      var rx = tc(), Fe = Dc(), nre = ht(Fs()), nx = ht(Or()), ix = ht(wc()), ap = ht(qe()), ire = ht(Qn()), ore = ht(En()), ox = ht(Qf()), ax = ht(Zf()), ZI = ht(II()), at = ht(jt()), $i = ht(Ut()), Fi = ht(Pc()), up = ht(vs()), ET = ht(ca()), are = ht(ep()), nr = ht(Ir()), sre = ht(Dr()), Ro = ht(sT()), ii = ht(Oc()), ure = ht(bT()), sp = ht(Li()), cp = ht(qi()), ex = qs(), Gs = QI(), sx = rp(), la = "PATTERN";
      H.DEFAULT_MODE = "defaultMode";
      H.MODES = "modes";
      H.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky == "boolean";
      function cre() {
        H.SUPPORT_STICKY = false;
      }
      H.disableSticky = cre;
      function lre() {
        H.SUPPORT_STICKY = true;
      }
      H.enableSticky = lre;
      function dre(t, e) {
        e = (0, ure.default)(e, { useSticky: H.SUPPORT_STICKY, debug: false, safeMode: false, positionTracking: "full", lineTerminatorCharacters: ["\r", `
`], tracer: function(S, b) {
          return b();
        } });
        var r = e.tracer;
        r("initCharCodeToOptimizedIndexMap", function() {
          Rre();
        });
        var n;
        r("Reject Lexer.NA", function() {
          n = (0, ox.default)(t, function(S) {
            return S[la] === Fe.Lexer.NA;
          });
        });
        var i = false, o;
        r("Transform Patterns", function() {
          i = false, o = (0, at.default)(n, function(S) {
            var b = S[la];
            if ((0, Ro.default)(b)) {
              var O = b.source;
              return O.length === 1 && O !== "^" && O !== "$" && O !== "." && !b.ignoreCase ? O : O.length === 2 && O[0] === "\\" && !(0, cp.default)(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], O[1]) ? O[1] : e.useSticky ? wT(b) : kT(b);
            } else {
              if ((0, up.default)(b))
                return i = true, { exec: b };
              if (typeof b == "object")
                return i = true, b;
              if (typeof b == "string") {
                if (b.length === 1)
                  return b;
                var L = b.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), W = new RegExp(L);
                return e.useSticky ? wT(W) : kT(W);
              } else
                throw Error("non exhaustive match");
            }
          });
        });
        var a, s, u, c, l;
        r("misc mapping", function() {
          a = (0, at.default)(n, function(S) {
            return S.tokenTypeIdx;
          }), s = (0, at.default)(n, function(S) {
            var b = S.GROUP;
            if (b !== Fe.Lexer.SKIPPED) {
              if ((0, Fi.default)(b))
                return b;
              if ((0, ET.default)(b))
                return false;
              throw Error("non exhaustive match");
            }
          }), u = (0, at.default)(n, function(S) {
            var b = S.LONGER_ALT;
            if (b) {
              var O = (0, ap.default)(b) ? (0, at.default)(b, function(L) {
                return (0, ZI.default)(n, L);
              }) : [(0, ZI.default)(n, b)];
              return O;
            }
          }), c = (0, at.default)(n, function(S) {
            return S.PUSH_MODE;
          }), l = (0, at.default)(n, function(S) {
            return (0, nr.default)(S, "POP_MODE");
          });
        });
        var d;
        r("Line Terminator Handling", function() {
          var S = Rx(e.lineTerminatorCharacters);
          d = (0, at.default)(n, function(b) {
            return false;
          }), e.positionTracking !== "onlyOffset" && (d = (0, at.default)(n, function(b) {
            return (0, nr.default)(b, "LINE_BREAKS") ? !!b.LINE_BREAKS : Tx(b, S) === false && (0, Gs.canMatchCharCode)(S, b.PATTERN);
          }));
        });
        var h, y, m, R;
        r("Misc Mapping #2", function() {
          h = (0, at.default)(n, DT), y = (0, at.default)(o, vx), m = (0, sp.default)(n, function(S, b) {
            var O = b.GROUP;
            return (0, Fi.default)(O) && O !== Fe.Lexer.SKIPPED && (S[O] = []), S;
          }, {}), R = (0, at.default)(o, function(S, b) {
            return { pattern: o[b], longerAlt: u[b], canLineTerminator: d[b], isCustom: h[b], short: y[b], group: s[b], push: c[b], pop: l[b], tokenTypeIdx: a[b], tokenType: n[b] };
          });
        });
        var C = true, N = [];
        return e.safeMode || r("First Char Optimization", function() {
          N = (0, sp.default)(n, function(S, b, O) {
            if (typeof b.PATTERN == "string") {
              var L = b.PATTERN.charCodeAt(0), W = OT(L);
              NT(S, W, R[O]);
            } else if ((0, ap.default)(b.START_CHARS_HINT)) {
              var Z;
              (0, $i.default)(b.START_CHARS_HINT, function(ke) {
                var Je = typeof ke == "string" ? ke.charCodeAt(0) : ke, K = OT(Je);
                Z !== K && (Z = K, NT(S, K, R[O]));
              });
            } else if ((0, Ro.default)(b.PATTERN))
              if (b.PATTERN.unicode)
                C = false, e.ensureOptimizations && (0, ex.PRINT_ERROR)("".concat(Gs.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(b.PATTERN.toString(), ` > pattern.
`) + `	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
              else {
                var Ee = (0, Gs.getOptimizedStartCodesIndices)(b.PATTERN, e.ensureOptimizations);
                (0, nx.default)(Ee) && (C = false), (0, $i.default)(Ee, function(ke) {
                  NT(S, ke, R[O]);
                });
              }
            else
              e.ensureOptimizations && (0, ex.PRINT_ERROR)("".concat(Gs.failedOptimizationPrefixMsg) + "	TokenType: <".concat(b.name, `> is using a custom token pattern without providing <start_chars_hint> parameter.
`) + `	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), C = false;
            return S;
          }, []);
        }), { emptyGroups: m, patternIdxToConfig: R, charCodeToPatternIdxToConfig: N, hasCustom: i, canBeOptimized: C };
      }
      H.analyzeTokenTypes = dre;
      function fre(t, e) {
        var r = [], n = ux(t);
        r = r.concat(n.errors);
        var i = cx(n.valid), o = i.valid;
        return r = r.concat(i.errors), r = r.concat(pre(o)), r = r.concat(mx(o)), r = r.concat(gx(o, e)), r = r.concat(yx(o)), r;
      }
      H.validatePatterns = fre;
      function pre(t) {
        var e = [], r = (0, ii.default)(t, function(n) {
          return (0, Ro.default)(n[la]);
        });
        return e = e.concat(lx(r)), e = e.concat(fx(r)), e = e.concat(px(r)), e = e.concat(hx(r)), e = e.concat(dx(r)), e;
      }
      function ux(t) {
        var e = (0, ii.default)(t, function(i) {
          return !(0, nr.default)(i, la);
        }), r = (0, at.default)(e, function(i) {
          return { message: "Token Type: ->" + i.name + "<- missing static 'PATTERN' property", type: Fe.LexerDefinitionErrorType.MISSING_PATTERN, tokenTypes: [i] };
        }), n = (0, ax.default)(t, e);
        return { errors: r, valid: n };
      }
      H.findMissingPatterns = ux;
      function cx(t) {
        var e = (0, ii.default)(t, function(i) {
          var o = i[la];
          return !(0, Ro.default)(o) && !(0, up.default)(o) && !(0, nr.default)(o, "exec") && !(0, Fi.default)(o);
        }), r = (0, at.default)(e, function(i) {
          return { message: "Token Type: ->" + i.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.", type: Fe.LexerDefinitionErrorType.INVALID_PATTERN, tokenTypes: [i] };
        }), n = (0, ax.default)(t, e);
        return { errors: r, valid: n };
      }
      H.findInvalidPatterns = cx;
      var hre = /[^\\][$]/;
      function lx(t) {
        var e = function(i) {
          tx(o, i);
          function o() {
            var a = i !== null && i.apply(this, arguments) || this;
            return a.found = false, a;
          }
          return o.prototype.visitEndAnchor = function(a) {
            this.found = true;
          }, o;
        }(rx.BaseRegExpVisitor), r = (0, ii.default)(t, function(i) {
          var o = i.PATTERN;
          try {
            var a = (0, sx.getRegExpAst)(o), s = new e();
            return s.visit(a), s.found;
          } catch {
            return hre.test(o.source);
          }
        }), n = (0, at.default)(r, function(i) {
          return { message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + i.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`, type: Fe.LexerDefinitionErrorType.EOI_ANCHOR_FOUND, tokenTypes: [i] };
        });
        return n;
      }
      H.findEndOfInputAnchor = lx;
      function dx(t) {
        var e = (0, ii.default)(t, function(n) {
          var i = n.PATTERN;
          return i.test("");
        }), r = (0, at.default)(e, function(n) {
          return { message: "Token Type: ->" + n.name + "<- static 'PATTERN' must not match an empty string", type: Fe.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN, tokenTypes: [n] };
        });
        return r;
      }
      H.findEmptyMatchRegExps = dx;
      var mre = /[^\\[][\^]|^\^/;
      function fx(t) {
        var e = function(i) {
          tx(o, i);
          function o() {
            var a = i !== null && i.apply(this, arguments) || this;
            return a.found = false, a;
          }
          return o.prototype.visitStartAnchor = function(a) {
            this.found = true;
          }, o;
        }(rx.BaseRegExpVisitor), r = (0, ii.default)(t, function(i) {
          var o = i.PATTERN;
          try {
            var a = (0, sx.getRegExpAst)(o), s = new e();
            return s.visit(a), s.found;
          } catch {
            return mre.test(o.source);
          }
        }), n = (0, at.default)(r, function(i) {
          return { message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + i.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`, type: Fe.LexerDefinitionErrorType.SOI_ANCHOR_FOUND, tokenTypes: [i] };
        });
        return n;
      }
      H.findStartOfInputAnchor = fx;
      function px(t) {
        var e = (0, ii.default)(t, function(n) {
          var i = n[la];
          return i instanceof RegExp && (i.multiline || i.global);
        }), r = (0, at.default)(e, function(n) {
          return { message: "Token Type: ->" + n.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')", type: Fe.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND, tokenTypes: [n] };
        });
        return r;
      }
      H.findUnsupportedFlags = px;
      function hx(t) {
        var e = [], r = (0, at.default)(t, function(o) {
          return (0, sp.default)(t, function(a, s) {
            return o.PATTERN.source === s.PATTERN.source && !(0, cp.default)(e, s) && s.PATTERN !== Fe.Lexer.NA && (e.push(s), a.push(s)), a;
          }, []);
        });
        r = (0, ix.default)(r);
        var n = (0, ii.default)(r, function(o) {
          return o.length > 1;
        }), i = (0, at.default)(n, function(o) {
          var a = (0, at.default)(o, function(u) {
            return u.name;
          }), s = (0, nre.default)(o).PATTERN;
          return { message: "The same RegExp pattern ->".concat(s, "<-") + "has been used in all of the following Token Types: ".concat(a.join(", "), " <-"), type: Fe.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND, tokenTypes: o };
        });
        return i;
      }
      H.findDuplicatePatterns = hx;
      function mx(t) {
        var e = (0, ii.default)(t, function(n) {
          if (!(0, nr.default)(n, "GROUP"))
            return false;
          var i = n.GROUP;
          return i !== Fe.Lexer.SKIPPED && i !== Fe.Lexer.NA && !(0, Fi.default)(i);
        }), r = (0, at.default)(e, function(n) {
          return { message: "Token Type: ->" + n.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String", type: Fe.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND, tokenTypes: [n] };
        });
        return r;
      }
      H.findInvalidGroupType = mx;
      function gx(t, e) {
        var r = (0, ii.default)(t, function(i) {
          return i.PUSH_MODE !== void 0 && !(0, cp.default)(e, i.PUSH_MODE);
        }), n = (0, at.default)(r, function(i) {
          var o = "Token Type: ->".concat(i.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(i.PUSH_MODE, "<-") + "which does not exist";
          return { message: o, type: Fe.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST, tokenTypes: [i] };
        });
        return n;
      }
      H.findModesThatDoNotExist = gx;
      function yx(t) {
        var e = [], r = (0, sp.default)(t, function(n, i, o) {
          var a = i.PATTERN;
          return a === Fe.Lexer.NA || ((0, Fi.default)(a) ? n.push({ str: a, idx: o, tokenType: i }) : (0, Ro.default)(a) && yre(a) && n.push({ str: a.source, idx: o, tokenType: i })), n;
        }, []);
        return (0, $i.default)(t, function(n, i) {
          (0, $i.default)(r, function(o) {
            var a = o.str, s = o.idx, u = o.tokenType;
            if (i < s && gre(a, n.PATTERN)) {
              var c = "Token: ->".concat(u.name, `<- can never be matched.
`) + "Because it appears AFTER the Token Type ->".concat(n.name, "<-") + `in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
              e.push({ message: c, type: Fe.LexerDefinitionErrorType.UNREACHABLE_PATTERN, tokenTypes: [n, u] });
            }
          });
        }), e;
      }
      H.findUnreachablePatterns = yx;
      function gre(t, e) {
        if ((0, Ro.default)(e)) {
          var r = e.exec(t);
          return r !== null && r.index === 0;
        } else {
          if ((0, up.default)(e))
            return e(t, 0, [], {});
          if ((0, nr.default)(e, "exec"))
            return e.exec(t, 0, [], {});
          if (typeof e == "string")
            return e === t;
          throw Error("non exhaustive match");
        }
      }
      function yre(t) {
        var e = [".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"];
        return (0, are.default)(e, function(r) {
          return t.source.indexOf(r) !== -1;
        }) === void 0;
      }
      function kT(t) {
        var e = t.ignoreCase ? "i" : "";
        return new RegExp("^(?:".concat(t.source, ")"), e);
      }
      H.addStartOfInput = kT;
      function wT(t) {
        var e = t.ignoreCase ? "iy" : "y";
        return new RegExp("".concat(t.source), e);
      }
      H.addStickyFlag = wT;
      function vre(t, e, r) {
        var n = [];
        return (0, nr.default)(t, H.DEFAULT_MODE) || n.push({ message: "A MultiMode Lexer cannot be initialized without a <" + H.DEFAULT_MODE + `> property in its definition
`, type: Fe.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE }), (0, nr.default)(t, H.MODES) || n.push({ message: "A MultiMode Lexer cannot be initialized without a <" + H.MODES + `> property in its definition
`, type: Fe.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY }), (0, nr.default)(t, H.MODES) && (0, nr.default)(t, H.DEFAULT_MODE) && !(0, nr.default)(t.modes, t.defaultMode) && n.push({ message: "A MultiMode Lexer cannot be initialized with a ".concat(H.DEFAULT_MODE, ": <").concat(t.defaultMode, ">") + `which does not exist
`, type: Fe.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST }), (0, nr.default)(t, H.MODES) && (0, $i.default)(t.modes, function(i, o) {
          (0, $i.default)(i, function(a, s) {
            if ((0, ET.default)(a))
              n.push({ message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(o, "> at index: <").concat(s, `>
`), type: Fe.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED });
            else if ((0, nr.default)(a, "LONGER_ALT")) {
              var u = (0, ap.default)(a.LONGER_ALT) ? a.LONGER_ALT : [a.LONGER_ALT];
              (0, $i.default)(u, function(c) {
                !(0, ET.default)(c) && !(0, cp.default)(i, c) && n.push({ message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(c.name, "> on token <").concat(a.name, "> outside of mode <").concat(o, `>
`), type: Fe.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE });
              });
            }
          });
        }), n;
      }
      H.performRuntimeChecks = vre;
      function Tre(t, e, r) {
        var n = [], i = false, o = (0, ix.default)((0, ore.default)((0, ire.default)(t.modes))), a = (0, ox.default)(o, function(u) {
          return u[la] === Fe.Lexer.NA;
        }), s = Rx(r);
        return e && (0, $i.default)(a, function(u) {
          var c = Tx(u, s);
          if (c !== false) {
            var l = _x(u, c), d = { message: l, type: c.issue, tokenType: u };
            n.push(d);
          } else
            (0, nr.default)(u, "LINE_BREAKS") ? u.LINE_BREAKS === true && (i = true) : (0, Gs.canMatchCharCode)(s, u.PATTERN) && (i = true);
        }), e && !i && n.push({ message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`, type: Fe.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS }), n;
      }
      H.performWarningRuntimeChecks = Tre;
      function _re(t) {
        var e = {}, r = (0, sre.default)(t);
        return (0, $i.default)(r, function(n) {
          var i = t[n];
          if ((0, ap.default)(i))
            e[n] = [];
          else
            throw Error("non exhaustive match");
        }), e;
      }
      H.cloneEmptyGroups = _re;
      function DT(t) {
        var e = t.PATTERN;
        if ((0, Ro.default)(e))
          return false;
        if ((0, up.default)(e))
          return true;
        if ((0, nr.default)(e, "exec"))
          return true;
        if ((0, Fi.default)(e))
          return false;
        throw Error("non exhaustive match");
      }
      H.isCustomPattern = DT;
      function vx(t) {
        return (0, Fi.default)(t) && t.length === 1 ? t.charCodeAt(0) : false;
      }
      H.isShortPattern = vx;
      H.LineTerminatorOptimizedTester = { test: function(t) {
        for (var e = t.length, r = this.lastIndex; r < e; r++) {
          var n = t.charCodeAt(r);
          if (n === 10)
            return this.lastIndex = r + 1, true;
          if (n === 13)
            return t.charCodeAt(r + 1) === 10 ? this.lastIndex = r + 2 : this.lastIndex = r + 1, true;
        }
        return false;
      }, lastIndex: 0 };
      function Tx(t, e) {
        if ((0, nr.default)(t, "LINE_BREAKS"))
          return false;
        if ((0, Ro.default)(t.PATTERN)) {
          try {
            (0, Gs.canMatchCharCode)(e, t.PATTERN);
          } catch (r) {
            return { issue: Fe.LexerDefinitionErrorType.IDENTIFY_TERMINATOR, errMsg: r.message };
          }
          return false;
        } else {
          if ((0, Fi.default)(t.PATTERN))
            return false;
          if (DT(t))
            return { issue: Fe.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
          throw Error("non exhaustive match");
        }
      }
      function _x(t, e) {
        if (e.issue === Fe.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)
          return `Warning: unable to identify line terminator usage in pattern.
` + "	The problem is in the <".concat(t.name, `> Token Type
`) + "	 Root cause: ".concat(e.errMsg, `.
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
        if (e.issue === Fe.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)
          return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
` + "	The problem is in the <".concat(t.name, `> Token Type
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
        throw Error("non exhaustive match");
      }
      H.buildLineBreakIssueMessage = _x;
      function Rx(t) {
        var e = (0, at.default)(t, function(r) {
          return (0, Fi.default)(r) ? r.charCodeAt(0) : r;
        });
        return e;
      }
      function NT(t, e, r) {
        t[e] === void 0 ? t[e] = [r] : t[e].push(r);
      }
      H.minOptimizationVal = 256;
      var op = [];
      function OT(t) {
        return t < H.minOptimizationVal ? t : op[t];
      }
      H.charCodeToOptimizedIndex = OT;
      function Rre() {
        if ((0, nx.default)(op)) {
          op = new Array(65536);
          for (var t = 0; t < 65536; t++)
            op[t] = t > 255 ? 255 + ~~(t / 255) : t;
        }
      }
    });
    var lp = f((eve, bx) => {
      function bre(t) {
        var e = t == null ? 0 : t.length;
        return e ? t[e - 1] : void 0;
      }
      bx.exports = bre;
    });
    var fa = f((ce) => {
      var oi = ce && ce.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(ce, "__esModule", { value: true });
      ce.isTokenType = ce.hasExtendingTokensTypesMapProperty = ce.hasExtendingTokensTypesProperty = ce.hasCategoriesProperty = ce.hasShortKeyProperty = ce.singleAssignCategoriesToksMap = ce.assignCategoriesMapProp = ce.assignCategoriesTokensProp = ce.assignTokenDefaultProps = ce.expandCategories = ce.augmentTokenTypes = ce.tokenIdxToClass = ce.tokenShortNameIdx = ce.tokenStructuredMatcherNoCategories = ce.tokenStructuredMatcher = void 0;
      var Sre = oi(Or()), Are = oi(wc()), Pre = oi(qe()), Cre = oi(En()), Nre = oi(Zf()), Ere = oi(jt()), da = oi(Ut()), Ic = oi(Ir()), kre = oi(qi()), wre = oi(Ii());
      function Ore(t, e) {
        var r = t.tokenTypeIdx;
        return r === e.tokenTypeIdx ? true : e.isParent === true && e.categoryMatchesMap[r] === true;
      }
      ce.tokenStructuredMatcher = Ore;
      function Dre(t, e) {
        return t.tokenTypeIdx === e.tokenTypeIdx;
      }
      ce.tokenStructuredMatcherNoCategories = Dre;
      ce.tokenShortNameIdx = 1;
      ce.tokenIdxToClass = {};
      function Ire(t) {
        var e = Sx(t);
        Ax(e), Cx(e), Px(e), (0, da.default)(e, function(r) {
          r.isParent = r.categoryMatches.length > 0;
        });
      }
      ce.augmentTokenTypes = Ire;
      function Sx(t) {
        for (var e = (0, wre.default)(t), r = t, n = true; n; ) {
          r = (0, Are.default)((0, Cre.default)((0, Ere.default)(r, function(o) {
            return o.CATEGORIES;
          })));
          var i = (0, Nre.default)(r, e);
          e = e.concat(i), (0, Sre.default)(i) ? n = false : r = i;
        }
        return e;
      }
      ce.expandCategories = Sx;
      function Ax(t) {
        (0, da.default)(t, function(e) {
          Nx(e) || (ce.tokenIdxToClass[ce.tokenShortNameIdx] = e, e.tokenTypeIdx = ce.tokenShortNameIdx++), IT(e) && !(0, Pre.default)(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), IT(e) || (e.CATEGORIES = []), Ex(e) || (e.categoryMatches = []), kx(e) || (e.categoryMatchesMap = {});
        });
      }
      ce.assignTokenDefaultProps = Ax;
      function Px(t) {
        (0, da.default)(t, function(e) {
          e.categoryMatches = [], (0, da.default)(e.categoryMatchesMap, function(r, n) {
            e.categoryMatches.push(ce.tokenIdxToClass[n].tokenTypeIdx);
          });
        });
      }
      ce.assignCategoriesTokensProp = Px;
      function Cx(t) {
        (0, da.default)(t, function(e) {
          xT([], e);
        });
      }
      ce.assignCategoriesMapProp = Cx;
      function xT(t, e) {
        (0, da.default)(t, function(r) {
          e.categoryMatchesMap[r.tokenTypeIdx] = true;
        }), (0, da.default)(e.CATEGORIES, function(r) {
          var n = t.concat(e);
          (0, kre.default)(n, r) || xT(n, r);
        });
      }
      ce.singleAssignCategoriesToksMap = xT;
      function Nx(t) {
        return (0, Ic.default)(t, "tokenTypeIdx");
      }
      ce.hasShortKeyProperty = Nx;
      function IT(t) {
        return (0, Ic.default)(t, "CATEGORIES");
      }
      ce.hasCategoriesProperty = IT;
      function Ex(t) {
        return (0, Ic.default)(t, "categoryMatches");
      }
      ce.hasExtendingTokensTypesProperty = Ex;
      function kx(t) {
        return (0, Ic.default)(t, "categoryMatchesMap");
      }
      ce.hasExtendingTokensTypesMapProperty = kx;
      function xre(t) {
        return (0, Ic.default)(t, "tokenTypeIdx");
      }
      ce.isTokenType = xre;
    });
    var qT = f((dp) => {
      Object.defineProperty(dp, "__esModule", { value: true });
      dp.defaultLexerErrorProvider = void 0;
      dp.defaultLexerErrorProvider = { buildUnableToPopLexerModeMessage: function(t) {
        return "Unable to pop Lexer Mode after encountering Token ->".concat(t.image, "<- The Mode Stack is empty");
      }, buildUnexpectedCharactersMessage: function(t, e, r, n, i) {
        return "unexpected character: ->".concat(t.charAt(e), "<- at offset: ").concat(e, ",") + " skipped ".concat(r, " characters.");
      } };
    });
    var Dc = f((Ui) => {
      var xr = Ui && Ui.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Ui, "__esModule", { value: true });
      Ui.Lexer = Ui.LexerDefinitionErrorType = void 0;
      var ji = CT(), LT = xr(Vf()), fp = xr(Or()), qre = xr(qe()), Lre = xr(lp()), Mre = xr(Qf()), wx = xr(jt()), MT = xr(Ut()), $re = xr(Dr()), Fre = xr(ca()), Ox = xr(ua()), Dx = xr(Nc()), jre = xr(Li()), Ix = xr(Ii()), $T = qs(), Ure = fa(), Gre = qT(), Hre = rp();
      (function(t) {
        t[t.MISSING_PATTERN = 0] = "MISSING_PATTERN", t[t.INVALID_PATTERN = 1] = "INVALID_PATTERN", t[t.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", t[t.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", t[t.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", t[t.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", t[t.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", t[t.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", t[t.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", t[t.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", t[t.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", t[t.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", t[t.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK", t[t.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
      })(Ui.LexerDefinitionErrorType || (Ui.LexerDefinitionErrorType = {}));
      var xc = { deferDefinitionErrorsHandling: false, positionTracking: "full", lineTerminatorsPattern: /\n|\r\n?/g, lineTerminatorCharacters: [`
`, "\r"], ensureOptimizations: false, safeMode: false, errorMessageProvider: Gre.defaultLexerErrorProvider, traceInitPerf: false, skipValidations: false, recoveryEnabled: true };
      Object.freeze(xc);
      var Bre = function() {
        function t(e, r) {
          r === void 0 && (r = xc);
          var n = this;
          if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.trackStartLines = true, this.trackEndLines = true, this.hasCustom = false, this.canModeBeOptimized = {}, this.TRACE_INIT = function(o, a) {
            if (n.traceInitPerf === true) {
              n.traceInitIndent++;
              var s = new Array(n.traceInitIndent + 1).join("	");
              n.traceInitIndent < n.traceInitMaxIdent && console.log("".concat(s, "--> <").concat(o, ">"));
              var u = (0, $T.timer)(a), c = u.time, l = u.value, d = c > 10 ? console.warn : console.log;
              return n.traceInitIndent < n.traceInitMaxIdent && d("".concat(s, "<-- <").concat(o, "> time: ").concat(c, "ms")), n.traceInitIndent--, l;
            } else
              return a();
          }, typeof r == "boolean")
            throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
          this.config = (0, Dx.default)({}, xc, r);
          var i = this.config.traceInitPerf;
          i === true ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = true) : typeof i == "number" && (this.traceInitMaxIdent = i, this.traceInitPerf = true), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", function() {
            var o, a = true;
            n.TRACE_INIT("Lexer Config handling", function() {
              if (n.config.lineTerminatorsPattern === xc.lineTerminatorsPattern)
                n.config.lineTerminatorsPattern = ji.LineTerminatorOptimizedTester;
              else if (n.config.lineTerminatorCharacters === xc.lineTerminatorCharacters)
                throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
              if (r.safeMode && r.ensureOptimizations)
                throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
              n.trackStartLines = /full|onlyStart/i.test(n.config.positionTracking), n.trackEndLines = /full/i.test(n.config.positionTracking), (0, qre.default)(e) ? o = { modes: { defaultMode: (0, Ix.default)(e) }, defaultMode: ji.DEFAULT_MODE } : (a = false, o = (0, Ix.default)(e));
            }), n.config.skipValidations === false && (n.TRACE_INIT("performRuntimeChecks", function() {
              n.lexerDefinitionErrors = n.lexerDefinitionErrors.concat((0, ji.performRuntimeChecks)(o, n.trackStartLines, n.config.lineTerminatorCharacters));
            }), n.TRACE_INIT("performWarningRuntimeChecks", function() {
              n.lexerDefinitionWarning = n.lexerDefinitionWarning.concat((0, ji.performWarningRuntimeChecks)(o, n.trackStartLines, n.config.lineTerminatorCharacters));
            })), o.modes = o.modes ? o.modes : {}, (0, MT.default)(o.modes, function(l, d) {
              o.modes[d] = (0, Mre.default)(l, function(h) {
                return (0, Fre.default)(h);
              });
            });
            var s = (0, $re.default)(o.modes);
            if ((0, MT.default)(o.modes, function(l, d) {
              n.TRACE_INIT("Mode: <".concat(d, "> processing"), function() {
                if (n.modes.push(d), n.config.skipValidations === false && n.TRACE_INIT("validatePatterns", function() {
                  n.lexerDefinitionErrors = n.lexerDefinitionErrors.concat((0, ji.validatePatterns)(l, s));
                }), (0, fp.default)(n.lexerDefinitionErrors)) {
                  (0, Ure.augmentTokenTypes)(l);
                  var h;
                  n.TRACE_INIT("analyzeTokenTypes", function() {
                    h = (0, ji.analyzeTokenTypes)(l, { lineTerminatorCharacters: n.config.lineTerminatorCharacters, positionTracking: r.positionTracking, ensureOptimizations: r.ensureOptimizations, safeMode: r.safeMode, tracer: n.TRACE_INIT });
                  }), n.patternIdxToConfig[d] = h.patternIdxToConfig, n.charCodeToPatternIdxToConfig[d] = h.charCodeToPatternIdxToConfig, n.emptyGroups = (0, Dx.default)({}, n.emptyGroups, h.emptyGroups), n.hasCustom = h.hasCustom || n.hasCustom, n.canModeBeOptimized[d] = h.canBeOptimized;
                }
              });
            }), n.defaultMode = o.defaultMode, !(0, fp.default)(n.lexerDefinitionErrors) && !n.config.deferDefinitionErrorsHandling) {
              var u = (0, wx.default)(n.lexerDefinitionErrors, function(l) {
                return l.message;
              }), c = u.join(`-----------------------
`);
              throw new Error(`Errors detected in definition of Lexer:
` + c);
            }
            (0, MT.default)(n.lexerDefinitionWarning, function(l) {
              (0, $T.PRINT_WARNING)(l.message);
            }), n.TRACE_INIT("Choosing sub-methods implementations", function() {
              if (ji.SUPPORT_STICKY ? (n.chopInput = Ox.default, n.match = n.matchWithTest) : (n.updateLastIndex = LT.default, n.match = n.matchWithExec), a && (n.handleModes = LT.default), n.trackStartLines === false && (n.computeNewColumn = Ox.default), n.trackEndLines === false && (n.updateTokenEndLineColumnLocation = LT.default), /full/i.test(n.config.positionTracking))
                n.createTokenInstance = n.createFullToken;
              else if (/onlyStart/i.test(n.config.positionTracking))
                n.createTokenInstance = n.createStartOnlyToken;
              else if (/onlyOffset/i.test(n.config.positionTracking))
                n.createTokenInstance = n.createOffsetOnlyToken;
              else
                throw Error('Invalid <positionTracking> config option: "'.concat(n.config.positionTracking, '"'));
              n.hasCustom ? (n.addToken = n.addTokenUsingPush, n.handlePayload = n.handlePayloadWithCustom) : (n.addToken = n.addTokenUsingMemberAccess, n.handlePayload = n.handlePayloadNoCustom);
            }), n.TRACE_INIT("Failed Optimization Warnings", function() {
              var l = (0, jre.default)(n.canModeBeOptimized, function(d, h, y) {
                return h === false && d.push(y), d;
              }, []);
              if (r.ensureOptimizations && !(0, fp.default)(l))
                throw Error("Lexer Modes: < ".concat(l.join(", "), ` > cannot be optimized.
`) + `	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
            }), n.TRACE_INIT("clearRegExpParserCache", function() {
              (0, Hre.clearRegExpParserCache)();
            }), n.TRACE_INIT("toFastProperties", function() {
              (0, $T.toFastProperties)(n);
            });
          });
        }
        return t.prototype.tokenize = function(e, r) {
          if (r === void 0 && (r = this.defaultMode), !(0, fp.default)(this.lexerDefinitionErrors)) {
            var n = (0, wx.default)(this.lexerDefinitionErrors, function(o) {
              return o.message;
            }), i = n.join(`-----------------------
`);
            throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + i);
          }
          return this.tokenizeInternal(e, r);
        }, t.prototype.tokenizeInternal = function(e, r) {
          var n = this, i, o, a, s, u, c, l, d, h, y, m, R, C, S, b, O = e, L = O.length, W = 0, Z = 0, Ee = this.hasCustom ? 0 : Math.floor(e.length / 10), ke = new Array(Ee), Je = [], K = this.trackStartLines ? 1 : void 0, le = this.trackStartLines ? 1 : void 0, M = (0, ji.cloneEmptyGroups)(this.emptyGroups), q = this.trackStartLines, F = this.config.lineTerminatorsPattern, B = 0, ie = [], oe = [], J = [], lt = [];
          Object.freeze(lt);
          var tt;
          function Ot() {
            return ie;
          }
          function nn(qt) {
            var an = (0, ji.charCodeToOptimizedIndex)(qt), sn = oe[an];
            return sn === void 0 ? lt : sn;
          }
          var Nr = function(qt) {
            if (J.length === 1 && qt.tokenType.PUSH_MODE === void 0) {
              var an = n.config.errorMessageProvider.buildUnableToPopLexerModeMessage(qt);
              Je.push({ offset: qt.startOffset, line: qt.startLine, column: qt.startColumn, length: qt.image.length, message: an });
            } else {
              J.pop();
              var sn = (0, Lre.default)(J);
              ie = n.patternIdxToConfig[sn], oe = n.charCodeToPatternIdxToConfig[sn], B = ie.length;
              var Mn = n.canModeBeOptimized[sn] && n.config.safeMode === false;
              oe && Mn ? tt = nn : tt = Ot;
            }
          };
          function Pa(qt) {
            J.push(qt), oe = this.charCodeToPatternIdxToConfig[qt], ie = this.patternIdxToConfig[qt], B = ie.length, B = ie.length;
            var an = this.canModeBeOptimized[qt] && this.config.safeMode === false;
            oe && an ? tt = nn : tt = Ot;
          }
          Pa.call(this, r);
          for (var or, Ca = this.config.recoveryEnabled; W < L; ) {
            c = null;
            var Na = O.charCodeAt(W), Ea = tt(Na), Su = Ea.length;
            for (i = 0; i < Su; i++) {
              or = Ea[i];
              var mt = or.pattern;
              l = null;
              var yi = or.short;
              if (yi !== false ? Na === yi && (c = mt) : or.isCustom === true ? (b = mt.exec(O, W, ke, M), b !== null ? (c = b[0], b.payload !== void 0 && (l = b.payload)) : c = null) : (this.updateLastIndex(mt, W), c = this.match(mt, e, W)), c !== null) {
                if (u = or.longerAlt, u !== void 0) {
                  var Au = u.length;
                  for (a = 0; a < Au; a++) {
                    var xn = ie[u[a]], Fo = xn.pattern;
                    if (d = null, xn.isCustom === true ? (b = Fo.exec(O, W, ke, M), b !== null ? (s = b[0], b.payload !== void 0 && (d = b.payload)) : s = null) : (this.updateLastIndex(Fo, W), s = this.match(Fo, e, W)), s && s.length > c.length) {
                      c = s, l = d, or = xn;
                      break;
                    }
                  }
                }
                break;
              }
            }
            if (c !== null) {
              if (h = c.length, y = or.group, y !== void 0 && (m = or.tokenTypeIdx, R = this.createTokenInstance(c, W, m, or.tokenType, K, le, h), this.handlePayload(R, l), y === false ? Z = this.addToken(ke, Z, R) : M[y].push(R)), e = this.chopInput(e, h), W = W + h, le = this.computeNewColumn(le, h), q === true && or.canLineTerminator === true) {
                var qn = 0, jo = void 0, Mr = void 0;
                F.lastIndex = 0;
                do
                  jo = F.test(c), jo === true && (Mr = F.lastIndex - 1, qn++);
                while (jo === true);
                qn !== 0 && (K = K + qn, le = h - Mr, this.updateTokenEndLineColumnLocation(R, y, Mr, qn, K, le, h));
              }
              this.handleModes(or, Nr, Pa, R);
            } else {
              for (var on = W, ka = K, wa = le, Er = Ca === false; Er === false && W < L; )
                for (e = this.chopInput(e, 1), W++, o = 0; o < B; o++) {
                  var Ln = ie[o], mt = Ln.pattern, yi = Ln.short;
                  if (yi !== false ? O.charCodeAt(W) === yi && (Er = true) : Ln.isCustom === true ? Er = mt.exec(O, W, ke, M) !== null : (this.updateLastIndex(mt, W), Er = mt.exec(e) !== null), Er === true)
                    break;
                }
              if (C = W - on, S = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(O, on, C, ka, wa), Je.push({ offset: on, line: ka, column: wa, length: C, message: S }), Ca === false)
                break;
            }
          }
          return this.hasCustom || (ke.length = Z), { tokens: ke, groups: M, errors: Je };
        }, t.prototype.handleModes = function(e, r, n, i) {
          if (e.pop === true) {
            var o = e.push;
            r(i), o !== void 0 && n.call(this, o);
          } else
            e.push !== void 0 && n.call(this, e.push);
        }, t.prototype.chopInput = function(e, r) {
          return e.substring(r);
        }, t.prototype.updateLastIndex = function(e, r) {
          e.lastIndex = r;
        }, t.prototype.updateTokenEndLineColumnLocation = function(e, r, n, i, o, a, s) {
          var u, c;
          r !== void 0 && (u = n === s - 1, c = u ? -1 : 0, i === 1 && u === true || (e.endLine = o + c, e.endColumn = a - 1 + -c));
        }, t.prototype.computeNewColumn = function(e, r) {
          return e + r;
        }, t.prototype.createOffsetOnlyToken = function(e, r, n, i) {
          return { image: e, startOffset: r, tokenTypeIdx: n, tokenType: i };
        }, t.prototype.createStartOnlyToken = function(e, r, n, i, o, a) {
          return { image: e, startOffset: r, startLine: o, startColumn: a, tokenTypeIdx: n, tokenType: i };
        }, t.prototype.createFullToken = function(e, r, n, i, o, a, s) {
          return { image: e, startOffset: r, endOffset: r + s - 1, startLine: o, endLine: o, startColumn: a, endColumn: a + s - 1, tokenTypeIdx: n, tokenType: i };
        }, t.prototype.addTokenUsingPush = function(e, r, n) {
          return e.push(n), r;
        }, t.prototype.addTokenUsingMemberAccess = function(e, r, n) {
          return e[r] = n, r++, r;
        }, t.prototype.handlePayloadNoCustom = function(e, r) {
        }, t.prototype.handlePayloadWithCustom = function(e, r) {
          r !== null && (e.payload = r);
        }, t.prototype.matchWithTest = function(e, r, n) {
          var i = e.test(r);
          return i === true ? r.substring(n, e.lastIndex) : null;
        }, t.prototype.matchWithExec = function(e, r) {
          var n = e.exec(r);
          return n !== null ? n[0] : null;
        }, t.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.", t.NA = /NOT_APPLICABLE/, t;
      }();
      Ui.Lexer = Bre;
    });
    var pa = f((xt) => {
      var FT = xt && xt.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(xt, "__esModule", { value: true });
      xt.tokenMatcher = xt.createTokenInstance = xt.EOF = xt.createToken = xt.hasTokenLabel = xt.tokenName = xt.tokenLabel = void 0;
      var Kre = FT(Pc()), Gi = FT(Ir()), zre = FT(ca()), Vre = Dc(), jT = fa();
      function Yre(t) {
        return Gx(t) ? t.LABEL : t.name;
      }
      xt.tokenLabel = Yre;
      function Xre(t) {
        return t.name;
      }
      xt.tokenName = Xre;
      function Gx(t) {
        return (0, Kre.default)(t.LABEL) && t.LABEL !== "";
      }
      xt.hasTokenLabel = Gx;
      var Jre = "parent", xx = "categories", qx = "label", Lx = "group", Mx = "push_mode", $x = "pop_mode", Fx = "longer_alt", jx = "line_breaks", Ux = "start_chars_hint";
      function Hx(t) {
        return Qre(t);
      }
      xt.createToken = Hx;
      function Qre(t) {
        var e = t.pattern, r = {};
        if (r.name = t.name, (0, zre.default)(e) || (r.PATTERN = e), (0, Gi.default)(t, Jre))
          throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
        return (0, Gi.default)(t, xx) && (r.CATEGORIES = t[xx]), (0, jT.augmentTokenTypes)([r]), (0, Gi.default)(t, qx) && (r.LABEL = t[qx]), (0, Gi.default)(t, Lx) && (r.GROUP = t[Lx]), (0, Gi.default)(t, $x) && (r.POP_MODE = t[$x]), (0, Gi.default)(t, Mx) && (r.PUSH_MODE = t[Mx]), (0, Gi.default)(t, Fx) && (r.LONGER_ALT = t[Fx]), (0, Gi.default)(t, jx) && (r.LINE_BREAKS = t[jx]), (0, Gi.default)(t, Ux) && (r.START_CHARS_HINT = t[Ux]), r;
      }
      xt.EOF = Hx({ name: "EOF", pattern: Vre.Lexer.NA });
      (0, jT.augmentTokenTypes)([xt.EOF]);
      function Zre(t, e, r, n, i, o, a, s) {
        return { image: e, startOffset: r, endOffset: n, startLine: i, endLine: o, startColumn: a, endColumn: s, tokenTypeIdx: t.tokenTypeIdx, tokenType: t };
      }
      xt.createTokenInstance = Zre;
      function ene(t, e) {
        return (0, jT.tokenStructuredMatcher)(t, e);
      }
      xt.tokenMatcher = ene;
    });
    var Ws = f((kn) => {
      var HT = kn && kn.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(kn, "__esModule", { value: true });
      kn.defaultGrammarValidatorErrorProvider = kn.defaultGrammarResolverErrorProvider = kn.defaultParserErrorProvider = void 0;
      var Hs = pa(), GT = HT(Fs()), bo = HT(jt()), tne = HT(Li()), UT = vt(), Wx = vt();
      kn.defaultParserErrorProvider = { buildMismatchTokenMessage: function(t) {
        var e = t.expected, r = t.actual;
        t.previous;
        t.ruleName;
        var o = (0, Hs.hasTokenLabel)(e), a = o ? "--> ".concat((0, Hs.tokenLabel)(e), " <--") : "token of type --> ".concat(e.name, " <--"), s = "Expecting ".concat(a, " but found --> '").concat(r.image, "' <--");
        return s;
      }, buildNotAllInputParsedMessage: function(t) {
        var e = t.firstRedundant;
        t.ruleName;
        return "Redundant input, expecting EOF but found: " + e.image;
      }, buildNoViableAltMessage: function(t) {
        var e = t.expectedPathsPerAlt, r = t.actual;
        t.previous;
        var i = t.customUserDescription;
        t.ruleName;
        var a = "Expecting: ", s = (0, GT.default)(r).image, u = `
but found: '` + s + "'";
        if (i)
          return a + i + u;
        var c = (0, tne.default)(e, function(y, m) {
          return y.concat(m);
        }, []), l = (0, bo.default)(c, function(y) {
          return "[".concat((0, bo.default)(y, function(m) {
            return (0, Hs.tokenLabel)(m);
          }).join(", "), "]");
        }), d = (0, bo.default)(l, function(y, m) {
          return "  ".concat(m + 1, ". ").concat(y);
        }), h = `one of these possible Token sequences:
`.concat(d.join(`
`));
        return a + h + u;
      }, buildEarlyExitMessage: function(t) {
        var e = t.expectedIterationPaths, r = t.actual, n = t.customUserDescription;
        t.ruleName;
        var o = "Expecting: ", a = (0, GT.default)(r).image, s = `
but found: '` + a + "'";
        if (n)
          return o + n + s;
        var u = (0, bo.default)(e, function(l) {
          return "[".concat((0, bo.default)(l, function(d) {
            return (0, Hs.tokenLabel)(d);
          }).join(","), "]");
        }), c = `expecting at least one iteration which starts with one of these possible Token sequences::
  ` + "<".concat(u.join(" ,"), ">");
        return o + c + s;
      } };
      Object.freeze(kn.defaultParserErrorProvider);
      kn.defaultGrammarResolverErrorProvider = { buildRuleNotFoundError: function(t, e) {
        var r = "Invalid grammar, reference to a rule which is not defined: ->" + e.nonTerminalName + `<-
inside top level rule: ->` + t.name + "<-";
        return r;
      } };
      kn.defaultGrammarValidatorErrorProvider = { buildDuplicateFoundError: function(t, e) {
        function r(l) {
          return l instanceof UT.Terminal ? l.terminalType.name : l instanceof UT.NonTerminal ? l.nonTerminalName : "";
        }
        var n = t.name, i = (0, GT.default)(e), o = i.idx, a = (0, Wx.getProductionDslName)(i), s = r(i), u = o > 0, c = "->".concat(a).concat(u ? o : "", "<- ").concat(s ? "with argument: ->".concat(s, "<-") : "", `
                  appears more than once (`).concat(e.length, " times) in the top level rule: ->").concat(n, `<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `);
        return c = c.replace(/[ \t]+/g, " "), c = c.replace(/\s\s+/g, `
`), c;
      }, buildNamespaceConflictError: function(t) {
        var e = `Namespace conflict found in grammar.
` + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(t.name, `>.
`) + `To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
        return e;
      }, buildAlternationPrefixAmbiguityError: function(t) {
        var e = (0, bo.default)(t.prefixPath, function(i) {
          return (0, Hs.tokenLabel)(i);
        }).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx, n = "Ambiguous alternatives: <".concat(t.ambiguityIndices.join(" ,"), `> due to common lookahead prefix
`) + "in <OR".concat(r, "> inside <").concat(t.topLevelRule.name, `> Rule,
`) + "<".concat(e, `> may appears as a prefix path in all these alternatives.
`) + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
        return n;
      }, buildAlternationAmbiguityError: function(t) {
        var e = (0, bo.default)(t.prefixPath, function(i) {
          return (0, Hs.tokenLabel)(i);
        }).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx, n = "Ambiguous Alternatives Detected: <".concat(t.ambiguityIndices.join(" ,"), "> in <OR").concat(r, ">") + " inside <".concat(t.topLevelRule.name, `> Rule,
`) + "<".concat(e, `> may appears as a prefix path in all these alternatives.
`);
        return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
      }, buildEmptyRepetitionError: function(t) {
        var e = (0, Wx.getProductionDslName)(t.repetition);
        t.repetition.idx !== 0 && (e += t.repetition.idx);
        var r = "The repetition <".concat(e, "> within Rule <").concat(t.topLevelRule.name, `> can never consume any tokens.
`) + "This could lead to an infinite loop.";
        return r;
      }, buildTokenNameError: function(t) {
        return "deprecated";
      }, buildEmptyAlternationError: function(t) {
        var e = "Ambiguous empty alternative: <".concat(t.emptyChoiceIdx + 1, ">") + " in <OR".concat(t.alternation.idx, "> inside <").concat(t.topLevelRule.name, `> Rule.
`) + "Only the last alternative may be an empty alternative.";
        return e;
      }, buildTooManyAlternativesError: function(t) {
        var e = `An Alternation cannot have more than 256 alternatives:
` + "<OR".concat(t.alternation.idx, "> inside <").concat(t.topLevelRule.name, `> Rule.
 has `).concat(t.alternation.definition.length + 1, " alternatives.");
        return e;
      }, buildLeftRecursionError: function(t) {
        var e = t.topLevelRule.name, r = (0, bo.default)(t.leftRecursionPath, function(o) {
          return o.name;
        }), n = "".concat(e, " --> ").concat(r.concat([e]).join(" --> ")), i = `Left Recursion found in grammar.
` + "rule: <".concat(e, `> can be invoked from itself (directly or indirectly)
`) + `without consuming any Tokens. The grammar path that causes this is: 
 `.concat(n, `
`) + ` To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
        return i;
      }, buildInvalidRuleNameError: function(t) {
        return "deprecated";
      }, buildDuplicateRuleNameError: function(t) {
        var e;
        t.topLevelRule instanceof UT.Rule ? e = t.topLevelRule.name : e = t.topLevelRule;
        var r = "Duplicate definition, rule: ->".concat(e, "<- is already defined in the grammar: ->").concat(t.grammarName, "<-");
        return r;
      } };
    });
    var zx = f((ai) => {
      var rne = ai && ai.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), Bx = ai && ai.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(ai, "__esModule", { value: true });
      ai.GastRefResolverVisitor = ai.resolveGrammar = void 0;
      var nne = br(), ine = Bx(Ut()), one = Bx(Qn()), ane = vt();
      function sne(t, e) {
        var r = new Kx(t, e);
        return r.resolveRefs(), r.errors;
      }
      ai.resolveGrammar = sne;
      var Kx = function(t) {
        rne(e, t);
        function e(r, n) {
          var i = t.call(this) || this;
          return i.nameToTopRule = r, i.errMsgProvider = n, i.errors = [], i;
        }
        return e.prototype.resolveRefs = function() {
          var r = this;
          (0, ine.default)((0, one.default)(this.nameToTopRule), function(n) {
            r.currTopLevel = n, n.accept(r);
          });
        }, e.prototype.visitNonTerminal = function(r) {
          var n = this.nameToTopRule[r.nonTerminalName];
          if (n)
            r.referencedRule = n;
          else {
            var i = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, r);
            this.errors.push({ message: i, type: nne.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF, ruleName: this.currTopLevel.name, unresolvedRefName: r.nonTerminalName });
          }
        }, e;
      }(ane.GAstVisitor);
      ai.GastRefResolverVisitor = Kx;
    });
    var Yx = f((sve, Vx) => {
      function une(t, e, r, n) {
        for (var i = -1, o = t == null ? 0 : t.length; ++i < o; ) {
          var a = t[i];
          e(n, a, r(a), t);
        }
        return n;
      }
      Vx.exports = une;
    });
    var Jx = f((uve, Xx) => {
      var cne = _o();
      function lne(t, e, r, n) {
        return cne(t, function(i, o, a) {
          e(n, i, r(i), a);
        }), n;
      }
      Xx.exports = lne;
    });
    var Zx = f((cve, Qx) => {
      var dne = Yx(), fne = Jx(), pne = Jr(), hne = qe();
      function mne(t, e) {
        return function(r, n) {
          var i = hne(r) ? dne : fne, o = e ? e() : {};
          return i(r, t, pne(n, 2), o);
        };
      }
      Qx.exports = mne;
    });
    var WT = f((lve, eq) => {
      var gne = If(), yne = Zx(), vne = Object.prototype, Tne = vne.hasOwnProperty, _ne = yne(function(t, e, r) {
        Tne.call(t, r) ? t[r].push(e) : gne(t, r, [e]);
      });
      eq.exports = _ne;
    });
    var pp = f((dve, tq) => {
      var Rne = zf(), bne = jt();
      function Sne(t, e) {
        return Rne(bne(t, e), 1);
      }
      tq.exports = Sne;
    });
    var hp = f((fve, rq) => {
      var Ane = Mf(), Pne = Ls();
      function Cne(t, e, r) {
        var n = t == null ? 0 : t.length;
        return n ? (e = r || e === void 0 ? 1 : Pne(e), e = n - e, Ane(t, 0, e < 0 ? 0 : e)) : [];
      }
      rq.exports = Cne;
    });
    var Lc = f((st) => {
      var ma = st && st.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), ga = st && st.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(st, "__esModule", { value: true });
      st.nextPossibleTokensAfter = st.possiblePathsFrom = st.NextTerminalAfterAtLeastOneSepWalker = st.NextTerminalAfterAtLeastOneWalker = st.NextTerminalAfterManySepWalker = st.NextTerminalAfterManyWalker = st.AbstractNextTerminalAfterProductionWalker = st.NextAfterTokenWalker = st.AbstractNextPossibleTokensWalker = void 0;
      var iq = Kf(), gp = ga(Fs()), mp = ga(Or()), nq = ga(hp()), fr = ga($f()), Nne = ga(lp()), Ene = ga(Ut()), ha = ga(Ii()), kne = TT(), de = vt(), oq = function(t) {
        ma(e, t);
        function e(r, n) {
          var i = t.call(this) || this;
          return i.topProd = r, i.path = n, i.possibleTokTypes = [], i.nextProductionName = "", i.nextProductionOccurrence = 0, i.found = false, i.isAtEndOfPath = false, i;
        }
        return e.prototype.startWalking = function() {
          if (this.found = false, this.path.ruleStack[0] !== this.topProd.name)
            throw Error("The path does not start with the walker's top Rule!");
          return this.ruleStack = (0, ha.default)(this.path.ruleStack).reverse(), this.occurrenceStack = (0, ha.default)(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
        }, e.prototype.walk = function(r, n) {
          n === void 0 && (n = []), this.found || t.prototype.walk.call(this, r, n);
        }, e.prototype.walkProdRef = function(r, n, i) {
          if (r.referencedRule.name === this.nextProductionName && r.idx === this.nextProductionOccurrence) {
            var o = n.concat(i);
            this.updateExpectedNext(), this.walk(r.referencedRule, o);
          }
        }, e.prototype.updateExpectedNext = function() {
          (0, mp.default)(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = true) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
        }, e;
      }(iq.RestWalker);
      st.AbstractNextPossibleTokensWalker = oq;
      var wne = function(t) {
        ma(e, t);
        function e(r, n) {
          var i = t.call(this, r, n) || this;
          return i.path = n, i.nextTerminalName = "", i.nextTerminalOccurrence = 0, i.nextTerminalName = i.path.lastTok.name, i.nextTerminalOccurrence = i.path.lastTokOccurrence, i;
        }
        return e.prototype.walkTerminal = function(r, n, i) {
          if (this.isAtEndOfPath && r.terminalType.name === this.nextTerminalName && r.idx === this.nextTerminalOccurrence && !this.found) {
            var o = n.concat(i), a = new de.Alternative({ definition: o });
            this.possibleTokTypes = (0, kne.first)(a), this.found = true;
          }
        }, e;
      }(oq);
      st.NextAfterTokenWalker = wne;
      var qc = function(t) {
        ma(e, t);
        function e(r, n) {
          var i = t.call(this) || this;
          return i.topRule = r, i.occurrence = n, i.result = { token: void 0, occurrence: void 0, isEndOfRule: void 0 }, i;
        }
        return e.prototype.startWalking = function() {
          return this.walk(this.topRule), this.result;
        }, e;
      }(iq.RestWalker);
      st.AbstractNextTerminalAfterProductionWalker = qc;
      var One = function(t) {
        ma(e, t);
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        return e.prototype.walkMany = function(r, n, i) {
          if (r.idx === this.occurrence) {
            var o = (0, gp.default)(n.concat(i));
            this.result.isEndOfRule = o === void 0, o instanceof de.Terminal && (this.result.token = o.terminalType, this.result.occurrence = o.idx);
          } else
            t.prototype.walkMany.call(this, r, n, i);
        }, e;
      }(qc);
      st.NextTerminalAfterManyWalker = One;
      var Dne = function(t) {
        ma(e, t);
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        return e.prototype.walkManySep = function(r, n, i) {
          if (r.idx === this.occurrence) {
            var o = (0, gp.default)(n.concat(i));
            this.result.isEndOfRule = o === void 0, o instanceof de.Terminal && (this.result.token = o.terminalType, this.result.occurrence = o.idx);
          } else
            t.prototype.walkManySep.call(this, r, n, i);
        }, e;
      }(qc);
      st.NextTerminalAfterManySepWalker = Dne;
      var Ine = function(t) {
        ma(e, t);
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        return e.prototype.walkAtLeastOne = function(r, n, i) {
          if (r.idx === this.occurrence) {
            var o = (0, gp.default)(n.concat(i));
            this.result.isEndOfRule = o === void 0, o instanceof de.Terminal && (this.result.token = o.terminalType, this.result.occurrence = o.idx);
          } else
            t.prototype.walkAtLeastOne.call(this, r, n, i);
        }, e;
      }(qc);
      st.NextTerminalAfterAtLeastOneWalker = Ine;
      var xne = function(t) {
        ma(e, t);
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        return e.prototype.walkAtLeastOneSep = function(r, n, i) {
          if (r.idx === this.occurrence) {
            var o = (0, gp.default)(n.concat(i));
            this.result.isEndOfRule = o === void 0, o instanceof de.Terminal && (this.result.token = o.terminalType, this.result.occurrence = o.idx);
          } else
            t.prototype.walkAtLeastOneSep.call(this, r, n, i);
        }, e;
      }(qc);
      st.NextTerminalAfterAtLeastOneSepWalker = xne;
      function aq(t, e, r) {
        r === void 0 && (r = []), r = (0, ha.default)(r);
        var n = [], i = 0;
        function o(c) {
          return c.concat((0, fr.default)(t, i + 1));
        }
        function a(c) {
          var l = aq(o(c), e, r);
          return n.concat(l);
        }
        for (; r.length < e && i < t.length; ) {
          var s = t[i];
          if (s instanceof de.Alternative)
            return a(s.definition);
          if (s instanceof de.NonTerminal)
            return a(s.definition);
          if (s instanceof de.Option)
            n = a(s.definition);
          else if (s instanceof de.RepetitionMandatory) {
            var u = s.definition.concat([new de.Repetition({ definition: s.definition })]);
            return a(u);
          } else if (s instanceof de.RepetitionMandatoryWithSeparator) {
            var u = [new de.Alternative({ definition: s.definition }), new de.Repetition({ definition: [new de.Terminal({ terminalType: s.separator })].concat(s.definition) })];
            return a(u);
          } else if (s instanceof de.RepetitionWithSeparator) {
            var u = s.definition.concat([new de.Repetition({ definition: [new de.Terminal({ terminalType: s.separator })].concat(s.definition) })]);
            n = a(u);
          } else if (s instanceof de.Repetition) {
            var u = s.definition.concat([new de.Repetition({ definition: s.definition })]);
            n = a(u);
          } else {
            if (s instanceof de.Alternation)
              return (0, Ene.default)(s.definition, function(c) {
                (0, mp.default)(c.definition) === false && (n = a(c.definition));
              }), n;
            if (s instanceof de.Terminal)
              r.push(s.terminalType);
            else
              throw Error("non exhaustive match");
          }
          i++;
        }
        return n.push({ partialPath: r, suffixDef: (0, fr.default)(t, i) }), n;
      }
      st.possiblePathsFrom = aq;
      function qne(t, e, r, n) {
        var i = "EXIT_NONE_TERMINAL", o = [i], a = "EXIT_ALTERNATIVE", s = false, u = e.length, c = u - n - 1, l = [], d = [];
        for (d.push({ idx: -1, def: t, ruleStack: [], occurrenceStack: [] }); !(0, mp.default)(d); ) {
          var h = d.pop();
          if (h === a) {
            s && (0, Nne.default)(d).idx <= c && d.pop();
            continue;
          }
          var y = h.def, m = h.idx, R = h.ruleStack, C = h.occurrenceStack;
          if (!(0, mp.default)(y)) {
            var N = y[0];
            if (N === i) {
              var S = { idx: m, def: (0, fr.default)(y), ruleStack: (0, nq.default)(R), occurrenceStack: (0, nq.default)(C) };
              d.push(S);
            } else if (N instanceof de.Terminal)
              if (m < u - 1) {
                var b = m + 1, O = e[b];
                if (r(O, N.terminalType)) {
                  var S = { idx: b, def: (0, fr.default)(y), ruleStack: R, occurrenceStack: C };
                  d.push(S);
                }
              } else if (m === u - 1)
                l.push({ nextTokenType: N.terminalType, nextTokenOccurrence: N.idx, ruleStack: R, occurrenceStack: C }), s = true;
              else
                throw Error("non exhaustive match");
            else if (N instanceof de.NonTerminal) {
              var L = (0, ha.default)(R);
              L.push(N.nonTerminalName);
              var W = (0, ha.default)(C);
              W.push(N.idx);
              var S = { idx: m, def: N.definition.concat(o, (0, fr.default)(y)), ruleStack: L, occurrenceStack: W };
              d.push(S);
            } else if (N instanceof de.Option) {
              var Z = { idx: m, def: (0, fr.default)(y), ruleStack: R, occurrenceStack: C };
              d.push(Z), d.push(a);
              var Ee = { idx: m, def: N.definition.concat((0, fr.default)(y)), ruleStack: R, occurrenceStack: C };
              d.push(Ee);
            } else if (N instanceof de.RepetitionMandatory) {
              var ke = new de.Repetition({ definition: N.definition, idx: N.idx }), Je = N.definition.concat([ke], (0, fr.default)(y)), S = { idx: m, def: Je, ruleStack: R, occurrenceStack: C };
              d.push(S);
            } else if (N instanceof de.RepetitionMandatoryWithSeparator) {
              var K = new de.Terminal({ terminalType: N.separator }), ke = new de.Repetition({ definition: [K].concat(N.definition), idx: N.idx }), Je = N.definition.concat([ke], (0, fr.default)(y)), S = { idx: m, def: Je, ruleStack: R, occurrenceStack: C };
              d.push(S);
            } else if (N instanceof de.RepetitionWithSeparator) {
              var Z = { idx: m, def: (0, fr.default)(y), ruleStack: R, occurrenceStack: C };
              d.push(Z), d.push(a);
              var K = new de.Terminal({ terminalType: N.separator }), le = new de.Repetition({ definition: [K].concat(N.definition), idx: N.idx }), Je = N.definition.concat([le], (0, fr.default)(y)), Ee = { idx: m, def: Je, ruleStack: R, occurrenceStack: C };
              d.push(Ee);
            } else if (N instanceof de.Repetition) {
              var Z = { idx: m, def: (0, fr.default)(y), ruleStack: R, occurrenceStack: C };
              d.push(Z), d.push(a);
              var le = new de.Repetition({ definition: N.definition, idx: N.idx }), Je = N.definition.concat([le], (0, fr.default)(y)), Ee = { idx: m, def: Je, ruleStack: R, occurrenceStack: C };
              d.push(Ee);
            } else if (N instanceof de.Alternation)
              for (var M = N.definition.length - 1; M >= 0; M--) {
                var q = N.definition[M], F = { idx: m, def: q.definition.concat((0, fr.default)(y)), ruleStack: R, occurrenceStack: C };
                d.push(F), d.push(a);
              }
            else if (N instanceof de.Alternative)
              d.push({ idx: m, def: N.definition.concat((0, fr.default)(y)), ruleStack: R, occurrenceStack: C });
            else if (N instanceof de.Rule)
              d.push(Lne(N, m, R, C));
            else
              throw Error("non exhaustive match");
          }
        }
        return l;
      }
      st.nextPossibleTokensAfter = qne;
      function Lne(t, e, r, n) {
        var i = (0, ha.default)(r);
        i.push(t.name);
        var o = (0, ha.default)(n);
        return o.push(1), { idx: e, def: t.definition, ruleStack: i, occurrenceStack: o };
      }
    });
    var Bs = f((_e) => {
      var lq = _e && _e.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), Ta = _e && _e.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(_e, "__esModule", { value: true });
      _e.areTokenCategoriesNotUsed = _e.isStrictPrefixOfPath = _e.containsPath = _e.getLookaheadPathsForOptionalProd = _e.getLookaheadPathsForOr = _e.lookAheadSequenceFromAlternatives = _e.buildSingleAlternativeLookaheadFunction = _e.buildAlternativesLookAheadFunc = _e.buildLookaheadFuncForOptionalProd = _e.buildLookaheadFuncForOr = _e.getLookaheadPaths = _e.getProdType = _e.PROD_TYPE = void 0;
      var KT = Ta(Or()), dq = Ta(En()), va = Ta(kc()), yp = Ta(jt()), ya = Ta(Ut()), sq = Ta(Ir()), fq = Ta(Li()), uq = Lc(), Mne = Kf(), vp = fa(), So = vt(), $ne = vt(), Nt;
      (function(t) {
        t[t.OPTION = 0] = "OPTION", t[t.REPETITION = 1] = "REPETITION", t[t.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", t[t.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", t[t.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", t[t.ALTERNATION = 5] = "ALTERNATION";
      })(Nt = _e.PROD_TYPE || (_e.PROD_TYPE = {}));
      function pq(t) {
        if (t instanceof So.Option || t === "Option")
          return Nt.OPTION;
        if (t instanceof So.Repetition || t === "Repetition")
          return Nt.REPETITION;
        if (t instanceof So.RepetitionMandatory || t === "RepetitionMandatory")
          return Nt.REPETITION_MANDATORY;
        if (t instanceof So.RepetitionMandatoryWithSeparator || t === "RepetitionMandatoryWithSeparator")
          return Nt.REPETITION_MANDATORY_WITH_SEPARATOR;
        if (t instanceof So.RepetitionWithSeparator || t === "RepetitionWithSeparator")
          return Nt.REPETITION_WITH_SEPARATOR;
        if (t instanceof So.Alternation || t === "Alternation")
          return Nt.ALTERNATION;
        throw Error("non exhaustive match");
      }
      _e.getProdType = pq;
      function Fne(t) {
        var e = t.occurrence, r = t.rule, n = t.prodType, i = t.maxLookahead, o = pq(n);
        return o === Nt.ALTERNATION ? VT(e, r, i) : YT(e, r, o, i);
      }
      _e.getLookaheadPaths = Fne;
      function jne(t, e, r, n, i, o) {
        var a = VT(t, e, r), s = XT(a) ? vp.tokenStructuredMatcherNoCategories : vp.tokenStructuredMatcher;
        return o(a, n, s, i);
      }
      _e.buildLookaheadFuncForOr = jne;
      function Une(t, e, r, n, i, o) {
        var a = YT(t, e, i, r), s = XT(a) ? vp.tokenStructuredMatcherNoCategories : vp.tokenStructuredMatcher;
        return o(a[0], s, n);
      }
      _e.buildLookaheadFuncForOptionalProd = Une;
      function Gne(t, e, r, n) {
        var i = t.length, o = (0, va.default)(t, function(u) {
          return (0, va.default)(u, function(c) {
            return c.length === 1;
          });
        });
        if (e)
          return function(u) {
            for (var c = (0, yp.default)(u, function(b) {
              return b.GATE;
            }), l = 0; l < i; l++) {
              var d = t[l], h = d.length, y = c[l];
              if (y !== void 0 && y.call(this) === false)
                continue;
              e:
                for (var m = 0; m < h; m++) {
                  for (var R = d[m], C = R.length, N = 0; N < C; N++) {
                    var S = this.LA(N + 1);
                    if (r(S, R[N]) === false)
                      continue e;
                  }
                  return l;
                }
            }
          };
        if (o && !n) {
          var a = (0, yp.default)(t, function(u) {
            return (0, dq.default)(u);
          }), s = (0, fq.default)(a, function(u, c, l) {
            return (0, ya.default)(c, function(d) {
              (0, sq.default)(u, d.tokenTypeIdx) || (u[d.tokenTypeIdx] = l), (0, ya.default)(d.categoryMatches, function(h) {
                (0, sq.default)(u, h) || (u[h] = l);
              });
            }), u;
          }, {});
          return function() {
            var u = this.LA(1);
            return s[u.tokenTypeIdx];
          };
        } else
          return function() {
            for (var u = 0; u < i; u++) {
              var c = t[u], l = c.length;
              e:
                for (var d = 0; d < l; d++) {
                  for (var h = c[d], y = h.length, m = 0; m < y; m++) {
                    var R = this.LA(m + 1);
                    if (r(R, h[m]) === false)
                      continue e;
                  }
                  return u;
                }
            }
          };
      }
      _e.buildAlternativesLookAheadFunc = Gne;
      function Hne(t, e, r) {
        var n = (0, va.default)(t, function(c) {
          return c.length === 1;
        }), i = t.length;
        if (n && !r) {
          var o = (0, dq.default)(t);
          if (o.length === 1 && (0, KT.default)(o[0].categoryMatches)) {
            var a = o[0], s = a.tokenTypeIdx;
            return function() {
              return this.LA(1).tokenTypeIdx === s;
            };
          } else {
            var u = (0, fq.default)(o, function(c, l, d) {
              return c[l.tokenTypeIdx] = true, (0, ya.default)(l.categoryMatches, function(h) {
                c[h] = true;
              }), c;
            }, []);
            return function() {
              var c = this.LA(1);
              return u[c.tokenTypeIdx] === true;
            };
          }
        } else
          return function() {
            e:
              for (var c = 0; c < i; c++) {
                for (var l = t[c], d = l.length, h = 0; h < d; h++) {
                  var y = this.LA(h + 1);
                  if (e(y, l[h]) === false)
                    continue e;
                }
                return true;
              }
            return false;
          };
      }
      _e.buildSingleAlternativeLookaheadFunction = Hne;
      var Wne = function(t) {
        lq(e, t);
        function e(r, n, i) {
          var o = t.call(this) || this;
          return o.topProd = r, o.targetOccurrence = n, o.targetProdType = i, o;
        }
        return e.prototype.startWalking = function() {
          return this.walk(this.topProd), this.restDef;
        }, e.prototype.checkIsTarget = function(r, n, i, o) {
          return r.idx === this.targetOccurrence && this.targetProdType === n ? (this.restDef = i.concat(o), true) : false;
        }, e.prototype.walkOption = function(r, n, i) {
          this.checkIsTarget(r, Nt.OPTION, n, i) || t.prototype.walkOption.call(this, r, n, i);
        }, e.prototype.walkAtLeastOne = function(r, n, i) {
          this.checkIsTarget(r, Nt.REPETITION_MANDATORY, n, i) || t.prototype.walkOption.call(this, r, n, i);
        }, e.prototype.walkAtLeastOneSep = function(r, n, i) {
          this.checkIsTarget(r, Nt.REPETITION_MANDATORY_WITH_SEPARATOR, n, i) || t.prototype.walkOption.call(this, r, n, i);
        }, e.prototype.walkMany = function(r, n, i) {
          this.checkIsTarget(r, Nt.REPETITION, n, i) || t.prototype.walkOption.call(this, r, n, i);
        }, e.prototype.walkManySep = function(r, n, i) {
          this.checkIsTarget(r, Nt.REPETITION_WITH_SEPARATOR, n, i) || t.prototype.walkOption.call(this, r, n, i);
        }, e;
      }(Mne.RestWalker), hq = function(t) {
        lq(e, t);
        function e(r, n, i) {
          var o = t.call(this) || this;
          return o.targetOccurrence = r, o.targetProdType = n, o.targetRef = i, o.result = [], o;
        }
        return e.prototype.checkIsTarget = function(r, n) {
          r.idx === this.targetOccurrence && this.targetProdType === n && (this.targetRef === void 0 || r === this.targetRef) && (this.result = r.definition);
        }, e.prototype.visitOption = function(r) {
          this.checkIsTarget(r, Nt.OPTION);
        }, e.prototype.visitRepetition = function(r) {
          this.checkIsTarget(r, Nt.REPETITION);
        }, e.prototype.visitRepetitionMandatory = function(r) {
          this.checkIsTarget(r, Nt.REPETITION_MANDATORY);
        }, e.prototype.visitRepetitionMandatoryWithSeparator = function(r) {
          this.checkIsTarget(r, Nt.REPETITION_MANDATORY_WITH_SEPARATOR);
        }, e.prototype.visitRepetitionWithSeparator = function(r) {
          this.checkIsTarget(r, Nt.REPETITION_WITH_SEPARATOR);
        }, e.prototype.visitAlternation = function(r) {
          this.checkIsTarget(r, Nt.ALTERNATION);
        }, e;
      }($ne.GAstVisitor);
      function cq(t) {
        for (var e = new Array(t), r = 0; r < t; r++)
          e[r] = [];
        return e;
      }
      function BT(t) {
        for (var e = [""], r = 0; r < t.length; r++) {
          for (var n = t[r], i = [], o = 0; o < e.length; o++) {
            var a = e[o];
            i.push(a + "_" + n.tokenTypeIdx);
            for (var s = 0; s < n.categoryMatches.length; s++) {
              var u = "_" + n.categoryMatches[s];
              i.push(a + u);
            }
          }
          e = i;
        }
        return e;
      }
      function Bne(t, e, r) {
        for (var n = 0; n < t.length; n++)
          if (n !== r)
            for (var i = t[n], o = 0; o < e.length; o++) {
              var a = e[o];
              if (i[a] === true)
                return false;
            }
        return true;
      }
      function zT(t, e) {
        for (var r = (0, yp.default)(t, function(l) {
          return (0, uq.possiblePathsFrom)([l], 1);
        }), n = cq(r.length), i = (0, yp.default)(r, function(l) {
          var d = {};
          return (0, ya.default)(l, function(h) {
            var y = BT(h.partialPath);
            (0, ya.default)(y, function(m) {
              d[m] = true;
            });
          }), d;
        }), o = r, a = 1; a <= e; a++) {
          var s = o;
          o = cq(s.length);
          for (var u = function(l) {
            for (var d = s[l], h = 0; h < d.length; h++) {
              var y = d[h].partialPath, m = d[h].suffixDef, R = BT(y), C = Bne(i, R, l);
              if (C || (0, KT.default)(m) || y.length === e) {
                var N = n[l];
                if (mq(N, y) === false) {
                  N.push(y);
                  for (var S = 0; S < R.length; S++) {
                    var b = R[S];
                    i[l][b] = true;
                  }
                }
              } else {
                var O = (0, uq.possiblePathsFrom)(m, a + 1, y);
                o[l] = o[l].concat(O), (0, ya.default)(O, function(L) {
                  var W = BT(L.partialPath);
                  (0, ya.default)(W, function(Z) {
                    i[l][Z] = true;
                  });
                });
              }
            }
          }, c = 0; c < s.length; c++)
            u(c);
        }
        return n;
      }
      _e.lookAheadSequenceFromAlternatives = zT;
      function VT(t, e, r, n) {
        var i = new hq(t, Nt.ALTERNATION, n);
        return e.accept(i), zT(i.result, r);
      }
      _e.getLookaheadPathsForOr = VT;
      function YT(t, e, r, n) {
        var i = new hq(t, r);
        e.accept(i);
        var o = i.result, a = new Wne(e, t, r), s = a.startWalking(), u = new So.Alternative({ definition: o }), c = new So.Alternative({ definition: s });
        return zT([u, c], n);
      }
      _e.getLookaheadPathsForOptionalProd = YT;
      function mq(t, e) {
        e:
          for (var r = 0; r < t.length; r++) {
            var n = t[r];
            if (n.length === e.length) {
              for (var i = 0; i < n.length; i++) {
                var o = e[i], a = n[i], s = o === a || a.categoryMatchesMap[o.tokenTypeIdx] !== void 0;
                if (s === false)
                  continue e;
              }
              return true;
            }
          }
        return false;
      }
      _e.containsPath = mq;
      function Kne(t, e) {
        return t.length < e.length && (0, va.default)(t, function(r, n) {
          var i = e[n];
          return r === i || i.categoryMatchesMap[r.tokenTypeIdx];
        });
      }
      _e.isStrictPrefixOfPath = Kne;
      function XT(t) {
        return (0, va.default)(t, function(e) {
          return (0, va.default)(e, function(r) {
            return (0, va.default)(r, function(n) {
              return (0, KT.default)(n.categoryMatches);
            });
          });
        });
      }
      _e.areTokenCategoriesNotUsed = XT;
    });
    var Fc = f((me) => {
      var QT = me && me.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), JT = me && me.__assign || function() {
        return JT = Object.assign || function(t) {
          for (var e, r = 1, n = arguments.length; r < n; r++) {
            e = arguments[r];
            for (var i in e)
              Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
          }
          return t;
        }, JT.apply(this, arguments);
      }, Gt = me && me.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(me, "__esModule", { value: true });
      me.checkPrefixAlternativesAmbiguities = me.validateSomeNonEmptyLookaheadPath = me.validateTooManyAlts = me.RepetitionCollector = me.validateAmbiguousAlternationAlternatives = me.validateEmptyOrAlternative = me.getFirstNoneTerminal = me.validateNoLeftRecursion = me.validateRuleIsOverridden = me.validateRuleDoesNotAlreadyExist = me.OccurrenceValidationCollector = me.identifyProductionForDuplicates = me.validateGrammar = me.validateLookahead = void 0;
      var gq = Gt(Fs()), Tp = Gt(Or()), zne = Gt($f()), yq = Gt(En()), Vne = Gt(Oc()), Yne = Gt(Qf()), Xne = Gt(Zf()), Ao = Gt(jt()), $c = Gt(Ut()), Jne = Gt(WT()), ZT = Gt(Li()), Qne = Gt(uT()), Zne = Gt(Qn()), e_ = Gt(qi()), Hi = Gt(pp()), eie = Gt(Ii()), On = br(), t_ = vt(), Ks = Bs(), tie = Lc(), wn = vt(), r_ = vt(), rie = Gt(hp()), nie = Gt(wc()), iie = fa();
      function oie(t) {
        var e = t.lookaheadStrategy.validate({ rules: t.rules, tokenTypes: t.tokenTypes, grammarName: t.grammarName });
        return (0, Ao.default)(e, function(r) {
          return JT({ type: On.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, r);
        });
      }
      me.validateLookahead = oie;
      function aie(t, e, r, n) {
        var i = (0, Hi.default)(t, function(u) {
          return sie(u, r);
        }), o = pie(t, e, r), a = (0, Hi.default)(t, function(u) {
          return Aq(u, r);
        }), s = (0, Hi.default)(t, function(u) {
          return Rq(u, t, n, r);
        });
        return i.concat(o, a, s);
      }
      me.validateGrammar = aie;
      function sie(t, e) {
        var r = new _q();
        t.accept(r);
        var n = r.allProductions, i = (0, Jne.default)(n, vq), o = (0, Qne.default)(i, function(s) {
          return s.length > 1;
        }), a = (0, Ao.default)((0, Zne.default)(o), function(s) {
          var u = (0, gq.default)(s), c = e.buildDuplicateFoundError(t, s), l = (0, t_.getProductionDslName)(u), d = { message: c, type: On.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS, ruleName: t.name, dslName: l, occurrence: u.idx }, h = Tq(u);
          return h && (d.parameter = h), d;
        });
        return a;
      }
      function vq(t) {
        return "".concat((0, t_.getProductionDslName)(t), "_#_").concat(t.idx, "_#_").concat(Tq(t));
      }
      me.identifyProductionForDuplicates = vq;
      function Tq(t) {
        return t instanceof wn.Terminal ? t.terminalType.name : t instanceof wn.NonTerminal ? t.nonTerminalName : "";
      }
      var _q = function(t) {
        QT(e, t);
        function e() {
          var r = t !== null && t.apply(this, arguments) || this;
          return r.allProductions = [], r;
        }
        return e.prototype.visitNonTerminal = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitOption = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitRepetitionWithSeparator = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitRepetitionMandatory = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitRepetitionMandatoryWithSeparator = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitRepetition = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitAlternation = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitTerminal = function(r) {
          this.allProductions.push(r);
        }, e;
      }(r_.GAstVisitor);
      me.OccurrenceValidationCollector = _q;
      function Rq(t, e, r, n) {
        var i = [], o = (0, ZT.default)(e, function(s, u) {
          return u.name === t.name ? s + 1 : s;
        }, 0);
        if (o > 1) {
          var a = n.buildDuplicateRuleNameError({ topLevelRule: t, grammarName: r });
          i.push({ message: a, type: On.ParserDefinitionErrorType.DUPLICATE_RULE_NAME, ruleName: t.name });
        }
        return i;
      }
      me.validateRuleDoesNotAlreadyExist = Rq;
      function uie(t, e, r) {
        var n = [], i;
        return (0, e_.default)(e, t) || (i = "Invalid rule override, rule: ->".concat(t, "<- cannot be overridden in the grammar: ->").concat(r, "<-") + "as it is not defined in any of the super grammars ", n.push({ message: i, type: On.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE, ruleName: t })), n;
      }
      me.validateRuleIsOverridden = uie;
      function bq(t, e, r, n) {
        n === void 0 && (n = []);
        var i = [], o = Mc(e.definition);
        if ((0, Tp.default)(o))
          return [];
        var a = t.name, s = (0, e_.default)(o, t);
        s && i.push({ message: r.buildLeftRecursionError({ topLevelRule: t, leftRecursionPath: n }), type: On.ParserDefinitionErrorType.LEFT_RECURSION, ruleName: a });
        var u = (0, Xne.default)(o, n.concat([t])), c = (0, Hi.default)(u, function(l) {
          var d = (0, eie.default)(n);
          return d.push(l), bq(t, l, r, d);
        });
        return i.concat(c);
      }
      me.validateNoLeftRecursion = bq;
      function Mc(t) {
        var e = [];
        if ((0, Tp.default)(t))
          return e;
        var r = (0, gq.default)(t);
        if (r instanceof wn.NonTerminal)
          e.push(r.referencedRule);
        else if (r instanceof wn.Alternative || r instanceof wn.Option || r instanceof wn.RepetitionMandatory || r instanceof wn.RepetitionMandatoryWithSeparator || r instanceof wn.RepetitionWithSeparator || r instanceof wn.Repetition)
          e = e.concat(Mc(r.definition));
        else if (r instanceof wn.Alternation)
          e = (0, yq.default)((0, Ao.default)(r.definition, function(a) {
            return Mc(a.definition);
          }));
        else if (!(r instanceof wn.Terminal))
          throw Error("non exhaustive match");
        var n = (0, t_.isOptionalProd)(r), i = t.length > 1;
        if (n && i) {
          var o = (0, zne.default)(t);
          return e.concat(Mc(o));
        } else
          return e;
      }
      me.getFirstNoneTerminal = Mc;
      var n_ = function(t) {
        QT(e, t);
        function e() {
          var r = t !== null && t.apply(this, arguments) || this;
          return r.alternations = [], r;
        }
        return e.prototype.visitAlternation = function(r) {
          this.alternations.push(r);
        }, e;
      }(r_.GAstVisitor);
      function cie(t, e) {
        var r = new n_();
        t.accept(r);
        var n = r.alternations, i = (0, Hi.default)(n, function(o) {
          var a = (0, rie.default)(o.definition);
          return (0, Hi.default)(a, function(s, u) {
            var c = (0, tie.nextPossibleTokensAfter)([s], [], iie.tokenStructuredMatcher, 1);
            return (0, Tp.default)(c) ? [{ message: e.buildEmptyAlternationError({ topLevelRule: t, alternation: o, emptyChoiceIdx: u }), type: On.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT, ruleName: t.name, occurrence: o.idx, alternative: u + 1 }] : [];
          });
        });
        return i;
      }
      me.validateEmptyOrAlternative = cie;
      function lie(t, e, r) {
        var n = new n_();
        t.accept(n);
        var i = n.alternations;
        i = (0, Yne.default)(i, function(a) {
          return a.ignoreAmbiguities === true;
        });
        var o = (0, Hi.default)(i, function(a) {
          var s = a.idx, u = a.maxLookahead || e, c = (0, Ks.getLookaheadPathsForOr)(s, t, u, a), l = fie(c, a, t, r), d = Pq(c, a, t, r);
          return l.concat(d);
        });
        return o;
      }
      me.validateAmbiguousAlternationAlternatives = lie;
      var Sq = function(t) {
        QT(e, t);
        function e() {
          var r = t !== null && t.apply(this, arguments) || this;
          return r.allProductions = [], r;
        }
        return e.prototype.visitRepetitionWithSeparator = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitRepetitionMandatory = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitRepetitionMandatoryWithSeparator = function(r) {
          this.allProductions.push(r);
        }, e.prototype.visitRepetition = function(r) {
          this.allProductions.push(r);
        }, e;
      }(r_.GAstVisitor);
      me.RepetitionCollector = Sq;
      function Aq(t, e) {
        var r = new n_();
        t.accept(r);
        var n = r.alternations, i = (0, Hi.default)(n, function(o) {
          return o.definition.length > 255 ? [{ message: e.buildTooManyAlternativesError({ topLevelRule: t, alternation: o }), type: On.ParserDefinitionErrorType.TOO_MANY_ALTS, ruleName: t.name, occurrence: o.idx }] : [];
        });
        return i;
      }
      me.validateTooManyAlts = Aq;
      function die(t, e, r) {
        var n = [];
        return (0, $c.default)(t, function(i) {
          var o = new Sq();
          i.accept(o);
          var a = o.allProductions;
          (0, $c.default)(a, function(s) {
            var u = (0, Ks.getProdType)(s), c = s.maxLookahead || e, l = s.idx, d = (0, Ks.getLookaheadPathsForOptionalProd)(l, i, u, c), h = d[0];
            if ((0, Tp.default)((0, yq.default)(h))) {
              var y = r.buildEmptyRepetitionError({ topLevelRule: i, repetition: s });
              n.push({ message: y, type: On.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD, ruleName: i.name });
            }
          });
        }), n;
      }
      me.validateSomeNonEmptyLookaheadPath = die;
      function fie(t, e, r, n) {
        var i = [], o = (0, ZT.default)(t, function(s, u, c) {
          return e.definition[c].ignoreAmbiguities === true || (0, $c.default)(u, function(l) {
            var d = [c];
            (0, $c.default)(t, function(h, y) {
              c !== y && (0, Ks.containsPath)(h, l) && e.definition[y].ignoreAmbiguities !== true && d.push(y);
            }), d.length > 1 && !(0, Ks.containsPath)(i, l) && (i.push(l), s.push({ alts: d, path: l }));
          }), s;
        }, []), a = (0, Ao.default)(o, function(s) {
          var u = (0, Ao.default)(s.alts, function(l) {
            return l + 1;
          }), c = n.buildAlternationAmbiguityError({ topLevelRule: r, alternation: e, ambiguityIndices: u, prefixPath: s.path });
          return { message: c, type: On.ParserDefinitionErrorType.AMBIGUOUS_ALTS, ruleName: r.name, occurrence: e.idx, alternatives: s.alts };
        });
        return a;
      }
      function Pq(t, e, r, n) {
        var i = (0, ZT.default)(t, function(a, s, u) {
          var c = (0, Ao.default)(s, function(l) {
            return { idx: u, path: l };
          });
          return a.concat(c);
        }, []), o = (0, nie.default)((0, Hi.default)(i, function(a) {
          var s = e.definition[a.idx];
          if (s.ignoreAmbiguities === true)
            return [];
          var u = a.idx, c = a.path, l = (0, Vne.default)(i, function(h) {
            return e.definition[h.idx].ignoreAmbiguities !== true && h.idx < u && (0, Ks.isStrictPrefixOfPath)(h.path, c);
          }), d = (0, Ao.default)(l, function(h) {
            var y = [h.idx + 1, u + 1], m = e.idx === 0 ? "" : e.idx, R = n.buildAlternationPrefixAmbiguityError({ topLevelRule: r, alternation: e, ambiguityIndices: y, prefixPath: h.path });
            return { message: R, type: On.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS, ruleName: r.name, occurrence: m, alternatives: y };
          });
          return d;
        }));
        return o;
      }
      me.checkPrefixAlternativesAmbiguities = Pq;
      function pie(t, e, r) {
        var n = [], i = (0, Ao.default)(e, function(o) {
          return o.name;
        });
        return (0, $c.default)(t, function(o) {
          var a = o.name;
          if ((0, e_.default)(i, a)) {
            var s = r.buildNamespaceConflictError(o);
            n.push({ message: s, type: On.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE, ruleName: a });
          }
        }), n;
      }
    });
    var kq = f((Po) => {
      var Cq = Po && Po.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Po, "__esModule", { value: true });
      Po.validateGrammar = Po.resolveGrammar = void 0;
      var hie = Cq(Ut()), Nq = Cq(bT()), mie = zx(), gie = Fc(), Eq = Ws();
      function yie(t) {
        var e = (0, Nq.default)(t, { errMsgProvider: Eq.defaultGrammarResolverErrorProvider }), r = {};
        return (0, hie.default)(t.rules, function(n) {
          r[n.name] = n;
        }), (0, mie.resolveGrammar)(r, e.errMsgProvider);
      }
      Po.resolveGrammar = yie;
      function vie(t) {
        return t = (0, Nq.default)(t, { errMsgProvider: Eq.defaultGrammarValidatorErrorProvider }), (0, gie.validateGrammar)(t.rules, t.tokenTypes, t.errMsgProvider, t.grammarName);
      }
      Po.validateGrammar = vie;
    });
    var zs = f((ir) => {
      var jc = ir && ir.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), Tie = ir && ir.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(ir, "__esModule", { value: true });
      ir.EarlyExitException = ir.NotAllInputParsedException = ir.NoViableAltException = ir.MismatchedTokenException = ir.isRecognitionException = void 0;
      var _ie = Tie(qi()), wq = "MismatchedTokenException", Oq = "NoViableAltException", Dq = "EarlyExitException", Iq = "NotAllInputParsedException", xq = [wq, Oq, Dq, Iq];
      Object.freeze(xq);
      function Rie(t) {
        return (0, _ie.default)(xq, t.name);
      }
      ir.isRecognitionException = Rie;
      var _p = function(t) {
        jc(e, t);
        function e(r, n) {
          var i = this.constructor, o = t.call(this, r) || this;
          return o.token = n, o.resyncedTokens = [], Object.setPrototypeOf(o, i.prototype), Error.captureStackTrace && Error.captureStackTrace(o, o.constructor), o;
        }
        return e;
      }(Error), bie = function(t) {
        jc(e, t);
        function e(r, n, i) {
          var o = t.call(this, r, n) || this;
          return o.previousToken = i, o.name = wq, o;
        }
        return e;
      }(_p);
      ir.MismatchedTokenException = bie;
      var Sie = function(t) {
        jc(e, t);
        function e(r, n, i) {
          var o = t.call(this, r, n) || this;
          return o.previousToken = i, o.name = Oq, o;
        }
        return e;
      }(_p);
      ir.NoViableAltException = Sie;
      var Aie = function(t) {
        jc(e, t);
        function e(r, n) {
          var i = t.call(this, r, n) || this;
          return i.name = Iq, i;
        }
        return e;
      }(_p);
      ir.NotAllInputParsedException = Aie;
      var Pie = function(t) {
        jc(e, t);
        function e(r, n, i) {
          var o = t.call(this, r, n) || this;
          return o.previousToken = i, o.name = Dq, o;
        }
        return e;
      }(_p);
      ir.EarlyExitException = Pie;
    });
    var o_ = f((Et) => {
      var Cie = Et && Et.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), Co = Et && Et.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Et, "__esModule", { value: true });
      Et.attemptInRepetitionRecovery = Et.Recoverable = Et.InRuleRecoveryException = Et.IN_RULE_RECOVERY_EXCEPTION = Et.EOF_FOLLOW_KEY = void 0;
      var Uc = pa(), Nie = Co(Or()), qq = Co(hp()), Eie = Co(En()), i_ = Co(jt()), Lq = Co(ep()), kie = Co(Ir()), wie = Co(qi()), Oie = Co(Ii()), Die = zs(), Iie = _T(), xie = br();
      Et.EOF_FOLLOW_KEY = {};
      Et.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
      var Mq = function(t) {
        Cie(e, t);
        function e(r) {
          var n = t.call(this, r) || this;
          return n.name = Et.IN_RULE_RECOVERY_EXCEPTION, n;
        }
        return e;
      }(Error);
      Et.InRuleRecoveryException = Mq;
      var qie = function() {
        function t() {
        }
        return t.prototype.initRecoverable = function(e) {
          this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = (0, kie.default)(e, "recoveryEnabled") ? e.recoveryEnabled : xie.DEFAULT_PARSER_CONFIG.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = $q);
        }, t.prototype.getTokenToInsert = function(e) {
          var r = (0, Uc.createTokenInstance)(e, "", NaN, NaN, NaN, NaN, NaN, NaN);
          return r.isInsertedInRecovery = true, r;
        }, t.prototype.canTokenTypeBeInsertedInRecovery = function(e) {
          return true;
        }, t.prototype.canTokenTypeBeDeletedInRecovery = function(e) {
          return true;
        }, t.prototype.tryInRepetitionRecovery = function(e, r, n, i) {
          for (var o = this, a = this.findReSyncTokenType(), s = this.exportLexerState(), u = [], c = false, l = this.LA(1), d = this.LA(1), h = function() {
            var y = o.LA(0), m = o.errorMessageProvider.buildMismatchTokenMessage({ expected: i, actual: l, previous: y, ruleName: o.getCurrRuleFullName() }), R = new Die.MismatchedTokenException(m, l, o.LA(0));
            R.resyncedTokens = (0, qq.default)(u), o.SAVE_ERROR(R);
          }; !c; )
            if (this.tokenMatcher(d, i)) {
              h();
              return;
            } else if (n.call(this)) {
              h(), e.apply(this, r);
              return;
            } else
              this.tokenMatcher(d, a) ? c = true : (d = this.SKIP_TOKEN(), this.addToResyncTokens(d, u));
          this.importLexerState(s);
        }, t.prototype.shouldInRepetitionRecoveryBeTried = function(e, r, n) {
          return !(n === false || this.tokenMatcher(this.LA(1), e) || this.isBackTracking() || this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, r)));
        }, t.prototype.getFollowsForInRuleRecovery = function(e, r) {
          var n = this.getCurrentGrammarPath(e, r), i = this.getNextPossibleTokenTypes(n);
          return i;
        }, t.prototype.tryInRuleRecovery = function(e, r) {
          if (this.canRecoverWithSingleTokenInsertion(e, r)) {
            var n = this.getTokenToInsert(e);
            return n;
          }
          if (this.canRecoverWithSingleTokenDeletion(e)) {
            var i = this.SKIP_TOKEN();
            return this.consumeToken(), i;
          }
          throw new Mq("sad sad panda");
        }, t.prototype.canPerformInRuleRecovery = function(e, r) {
          return this.canRecoverWithSingleTokenInsertion(e, r) || this.canRecoverWithSingleTokenDeletion(e);
        }, t.prototype.canRecoverWithSingleTokenInsertion = function(e, r) {
          var n = this;
          if (!this.canTokenTypeBeInsertedInRecovery(e) || (0, Nie.default)(r))
            return false;
          var i = this.LA(1), o = (0, Lq.default)(r, function(a) {
            return n.tokenMatcher(i, a);
          }) !== void 0;
          return o;
        }, t.prototype.canRecoverWithSingleTokenDeletion = function(e) {
          if (!this.canTokenTypeBeDeletedInRecovery(e))
            return false;
          var r = this.tokenMatcher(this.LA(2), e);
          return r;
        }, t.prototype.isInCurrentRuleReSyncSet = function(e) {
          var r = this.getCurrFollowKey(), n = this.getFollowSetFromFollowKey(r);
          return (0, wie.default)(n, e);
        }, t.prototype.findReSyncTokenType = function() {
          for (var e = this.flattenFollowSet(), r = this.LA(1), n = 2; ; ) {
            var i = (0, Lq.default)(e, function(o) {
              var a = (0, Uc.tokenMatcher)(r, o);
              return a;
            });
            if (i !== void 0)
              return i;
            r = this.LA(n), n++;
          }
        }, t.prototype.getCurrFollowKey = function() {
          if (this.RULE_STACK.length === 1)
            return Et.EOF_FOLLOW_KEY;
          var e = this.getLastExplicitRuleShortName(), r = this.getLastExplicitRuleOccurrenceIndex(), n = this.getPreviousExplicitRuleShortName();
          return { ruleName: this.shortRuleNameToFullName(e), idxInCallingRule: r, inRule: this.shortRuleNameToFullName(n) };
        }, t.prototype.buildFullFollowKeyStack = function() {
          var e = this, r = this.RULE_STACK, n = this.RULE_OCCURRENCE_STACK;
          return (0, i_.default)(r, function(i, o) {
            return o === 0 ? Et.EOF_FOLLOW_KEY : { ruleName: e.shortRuleNameToFullName(i), idxInCallingRule: n[o], inRule: e.shortRuleNameToFullName(r[o - 1]) };
          });
        }, t.prototype.flattenFollowSet = function() {
          var e = this, r = (0, i_.default)(this.buildFullFollowKeyStack(), function(n) {
            return e.getFollowSetFromFollowKey(n);
          });
          return (0, Eie.default)(r);
        }, t.prototype.getFollowSetFromFollowKey = function(e) {
          if (e === Et.EOF_FOLLOW_KEY)
            return [Uc.EOF];
          var r = e.ruleName + e.idxInCallingRule + Iie.IN + e.inRule;
          return this.resyncFollows[r];
        }, t.prototype.addToResyncTokens = function(e, r) {
          return this.tokenMatcher(e, Uc.EOF) || r.push(e), r;
        }, t.prototype.reSyncTo = function(e) {
          for (var r = [], n = this.LA(1); this.tokenMatcher(n, e) === false; )
            n = this.SKIP_TOKEN(), this.addToResyncTokens(n, r);
          return (0, qq.default)(r);
        }, t.prototype.attemptInRepetitionRecovery = function(e, r, n, i, o, a, s) {
        }, t.prototype.getCurrentGrammarPath = function(e, r) {
          var n = this.getHumanReadableRuleStack(), i = (0, Oie.default)(this.RULE_OCCURRENCE_STACK), o = { ruleStack: n, occurrenceStack: i, lastTok: e, lastTokOccurrence: r };
          return o;
        }, t.prototype.getHumanReadableRuleStack = function() {
          var e = this;
          return (0, i_.default)(this.RULE_STACK, function(r) {
            return e.shortRuleNameToFullName(r);
          });
        }, t;
      }();
      Et.Recoverable = qie;
      function $q(t, e, r, n, i, o, a) {
        var s = this.getKeyForAutomaticLookahead(n, i), u = this.firstAfterRepMap[s];
        if (u === void 0) {
          var c = this.getCurrRuleFullName(), l = this.getGAstProductions()[c], d = new o(l, i);
          u = d.startWalking(), this.firstAfterRepMap[s] = u;
        }
        var h = u.token, y = u.occurrence, m = u.isEndOfRule;
        this.RULE_STACK.length === 1 && m && h === void 0 && (h = Uc.EOF, y = 1), !(h === void 0 || y === void 0) && this.shouldInRepetitionRecoveryBeTried(h, y, a) && this.tryInRepetitionRecovery(t, e, r, h);
      }
      Et.attemptInRepetitionRecovery = $q;
    });
    var Rp = f((Ne) => {
      Object.defineProperty(Ne, "__esModule", { value: true });
      Ne.getKeyForAutomaticLookahead = Ne.AT_LEAST_ONE_SEP_IDX = Ne.MANY_SEP_IDX = Ne.AT_LEAST_ONE_IDX = Ne.MANY_IDX = Ne.OPTION_IDX = Ne.OR_IDX = Ne.BITS_FOR_ALT_IDX = Ne.BITS_FOR_RULE_IDX = Ne.BITS_FOR_OCCURRENCE_IDX = Ne.BITS_FOR_METHOD_TYPE = void 0;
      Ne.BITS_FOR_METHOD_TYPE = 4;
      Ne.BITS_FOR_OCCURRENCE_IDX = 8;
      Ne.BITS_FOR_RULE_IDX = 12;
      Ne.BITS_FOR_ALT_IDX = 8;
      Ne.OR_IDX = 1 << Ne.BITS_FOR_OCCURRENCE_IDX;
      Ne.OPTION_IDX = 2 << Ne.BITS_FOR_OCCURRENCE_IDX;
      Ne.MANY_IDX = 3 << Ne.BITS_FOR_OCCURRENCE_IDX;
      Ne.AT_LEAST_ONE_IDX = 4 << Ne.BITS_FOR_OCCURRENCE_IDX;
      Ne.MANY_SEP_IDX = 5 << Ne.BITS_FOR_OCCURRENCE_IDX;
      Ne.AT_LEAST_ONE_SEP_IDX = 6 << Ne.BITS_FOR_OCCURRENCE_IDX;
      function Lie(t, e, r) {
        return r | e | t;
      }
      Ne.getKeyForAutomaticLookahead = Lie;
      32 - Ne.BITS_FOR_ALT_IDX;
    });
    var s_ = f((No) => {
      var bp = No && No.__spreadArray || function(t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), o[n] = e[n]);
        return t.concat(o || Array.prototype.slice.call(e));
      }, Fq = No && No.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(No, "__esModule", { value: true });
      No.LLkLookaheadStrategy = void 0;
      var a_ = Fq(pp()), Mie = Fq(Or()), Sp = Ws(), $ie = br(), Ap = Fc(), Gc = Bs(), Fie = function() {
        function t(e) {
          var r;
          this.maxLookahead = (r = e == null ? void 0 : e.maxLookahead) !== null && r !== void 0 ? r : $ie.DEFAULT_PARSER_CONFIG.maxLookahead;
        }
        return t.prototype.validate = function(e) {
          var r = this.validateNoLeftRecursion(e.rules);
          if ((0, Mie.default)(r)) {
            var n = this.validateEmptyOrAlternatives(e.rules), i = this.validateAmbiguousAlternationAlternatives(e.rules, this.maxLookahead), o = this.validateSomeNonEmptyLookaheadPath(e.rules, this.maxLookahead), a = bp(bp(bp(bp([], r, true), n, true), i, true), o, true);
            return a;
          }
          return r;
        }, t.prototype.validateNoLeftRecursion = function(e) {
          return (0, a_.default)(e, function(r) {
            return (0, Ap.validateNoLeftRecursion)(r, r, Sp.defaultGrammarValidatorErrorProvider);
          });
        }, t.prototype.validateEmptyOrAlternatives = function(e) {
          return (0, a_.default)(e, function(r) {
            return (0, Ap.validateEmptyOrAlternative)(r, Sp.defaultGrammarValidatorErrorProvider);
          });
        }, t.prototype.validateAmbiguousAlternationAlternatives = function(e, r) {
          return (0, a_.default)(e, function(n) {
            return (0, Ap.validateAmbiguousAlternationAlternatives)(n, r, Sp.defaultGrammarValidatorErrorProvider);
          });
        }, t.prototype.validateSomeNonEmptyLookaheadPath = function(e, r) {
          return (0, Ap.validateSomeNonEmptyLookaheadPath)(e, r, Sp.defaultGrammarValidatorErrorProvider);
        }, t.prototype.buildLookaheadForAlternation = function(e) {
          return (0, Gc.buildLookaheadFuncForOr)(e.prodOccurrence, e.rule, e.maxLookahead, e.hasPredicates, e.dynamicTokensEnabled, Gc.buildAlternativesLookAheadFunc);
        }, t.prototype.buildLookaheadForOptional = function(e) {
          return (0, Gc.buildLookaheadFuncForOptionalProd)(e.prodOccurrence, e.rule, e.maxLookahead, e.dynamicTokensEnabled, (0, Gc.getProdType)(e.prodType), Gc.buildSingleAlternativeLookaheadFunction);
        }, t;
      }();
      No.LLkLookaheadStrategy = Fie;
    });
    var Hq = f((si) => {
      var jie = si && si.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), Uq = si && si.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(si, "__esModule", { value: true });
      si.collectMethods = si.LooksAhead = void 0;
      var _a = Uq(Ut()), u_ = Uq(Ir()), jq = br(), Wi = Rp(), Uie = vt(), Vs = vt(), Gie = s_(), Hie = function() {
        function t() {
        }
        return t.prototype.initLooksAhead = function(e) {
          this.dynamicTokensEnabled = (0, u_.default)(e, "dynamicTokensEnabled") ? e.dynamicTokensEnabled : jq.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled, this.maxLookahead = (0, u_.default)(e, "maxLookahead") ? e.maxLookahead : jq.DEFAULT_PARSER_CONFIG.maxLookahead, this.lookaheadStrategy = (0, u_.default)(e, "lookaheadStrategy") ? e.lookaheadStrategy : new Gie.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead }), this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
        }, t.prototype.preComputeLookaheadFunctions = function(e) {
          var r = this;
          (0, _a.default)(e, function(n) {
            r.TRACE_INIT("".concat(n.name, " Rule Lookahead"), function() {
              var i = Gq(n), o = i.alternation, a = i.repetition, s = i.option, u = i.repetitionMandatory, c = i.repetitionMandatoryWithSeparator, l = i.repetitionWithSeparator;
              (0, _a.default)(o, function(d) {
                var h = d.idx === 0 ? "" : d.idx;
                r.TRACE_INIT("".concat((0, Vs.getProductionDslName)(d)).concat(h), function() {
                  var y = r.lookaheadStrategy.buildLookaheadForAlternation({ prodOccurrence: d.idx, rule: n, maxLookahead: d.maxLookahead || r.maxLookahead, hasPredicates: d.hasPredicates, dynamicTokensEnabled: r.dynamicTokensEnabled }), m = (0, Wi.getKeyForAutomaticLookahead)(r.fullRuleNameToShort[n.name], Wi.OR_IDX, d.idx);
                  r.setLaFuncCache(m, y);
                });
              }), (0, _a.default)(a, function(d) {
                r.computeLookaheadFunc(n, d.idx, Wi.MANY_IDX, "Repetition", d.maxLookahead, (0, Vs.getProductionDslName)(d));
              }), (0, _a.default)(s, function(d) {
                r.computeLookaheadFunc(n, d.idx, Wi.OPTION_IDX, "Option", d.maxLookahead, (0, Vs.getProductionDslName)(d));
              }), (0, _a.default)(u, function(d) {
                r.computeLookaheadFunc(n, d.idx, Wi.AT_LEAST_ONE_IDX, "RepetitionMandatory", d.maxLookahead, (0, Vs.getProductionDslName)(d));
              }), (0, _a.default)(c, function(d) {
                r.computeLookaheadFunc(n, d.idx, Wi.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", d.maxLookahead, (0, Vs.getProductionDslName)(d));
              }), (0, _a.default)(l, function(d) {
                r.computeLookaheadFunc(n, d.idx, Wi.MANY_SEP_IDX, "RepetitionWithSeparator", d.maxLookahead, (0, Vs.getProductionDslName)(d));
              });
            });
          });
        }, t.prototype.computeLookaheadFunc = function(e, r, n, i, o, a) {
          var s = this;
          this.TRACE_INIT("".concat(a).concat(r === 0 ? "" : r), function() {
            var u = s.lookaheadStrategy.buildLookaheadForOptional({ prodOccurrence: r, rule: e, maxLookahead: o || s.maxLookahead, dynamicTokensEnabled: s.dynamicTokensEnabled, prodType: i }), c = (0, Wi.getKeyForAutomaticLookahead)(s.fullRuleNameToShort[e.name], n, r);
            s.setLaFuncCache(c, u);
          });
        }, t.prototype.getKeyForAutomaticLookahead = function(e, r) {
          var n = this.getLastExplicitRuleShortName();
          return (0, Wi.getKeyForAutomaticLookahead)(n, e, r);
        }, t.prototype.getLaFuncFromCache = function(e) {
          return this.lookAheadFuncsCache.get(e);
        }, t.prototype.setLaFuncCache = function(e, r) {
          this.lookAheadFuncsCache.set(e, r);
        }, t;
      }();
      si.LooksAhead = Hie;
      var Wie = function(t) {
        jie(e, t);
        function e() {
          var r = t !== null && t.apply(this, arguments) || this;
          return r.dslMethods = { option: [], alternation: [], repetition: [], repetitionWithSeparator: [], repetitionMandatory: [], repetitionMandatoryWithSeparator: [] }, r;
        }
        return e.prototype.reset = function() {
          this.dslMethods = { option: [], alternation: [], repetition: [], repetitionWithSeparator: [], repetitionMandatory: [], repetitionMandatoryWithSeparator: [] };
        }, e.prototype.visitOption = function(r) {
          this.dslMethods.option.push(r);
        }, e.prototype.visitRepetitionWithSeparator = function(r) {
          this.dslMethods.repetitionWithSeparator.push(r);
        }, e.prototype.visitRepetitionMandatory = function(r) {
          this.dslMethods.repetitionMandatory.push(r);
        }, e.prototype.visitRepetitionMandatoryWithSeparator = function(r) {
          this.dslMethods.repetitionMandatoryWithSeparator.push(r);
        }, e.prototype.visitRepetition = function(r) {
          this.dslMethods.repetition.push(r);
        }, e.prototype.visitAlternation = function(r) {
          this.dslMethods.alternation.push(r);
        }, e;
      }(Uie.GAstVisitor), Pp = new Wie();
      function Gq(t) {
        Pp.reset(), t.accept(Pp);
        var e = Pp.dslMethods;
        return Pp.reset(), e;
      }
      si.collectMethods = Gq;
    });
    var Wq = f((ui) => {
      Object.defineProperty(ui, "__esModule", { value: true });
      ui.addNoneTerminalToCst = ui.addTerminalToCst = ui.setNodeLocationFull = ui.setNodeLocationOnlyOffset = void 0;
      function Bie(t, e) {
        isNaN(t.startOffset) === true ? (t.startOffset = e.startOffset, t.endOffset = e.endOffset) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset);
      }
      ui.setNodeLocationOnlyOffset = Bie;
      function Kie(t, e) {
        isNaN(t.startOffset) === true ? (t.startOffset = e.startOffset, t.startColumn = e.startColumn, t.startLine = e.startLine, t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine);
      }
      ui.setNodeLocationFull = Kie;
      function zie(t, e, r) {
        t.children[r] === void 0 ? t.children[r] = [e] : t.children[r].push(e);
      }
      ui.addTerminalToCst = zie;
      function Vie(t, e, r) {
        t.children[e] === void 0 ? t.children[e] = [r] : t.children[e].push(r);
      }
      ui.addNoneTerminalToCst = Vie;
    });
    var Bq = f((Cp) => {
      Object.defineProperty(Cp, "__esModule", { value: true });
      Cp.defineNameProp = void 0;
      var Yie = "name";
      function Xie(t, e) {
        Object.defineProperty(t, Yie, { enumerable: false, configurable: true, writable: false, value: e });
      }
      Cp.defineNameProp = Xie;
    });
    var Qq = f((Yt) => {
      var Bi = Yt && Yt.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Yt, "__esModule", { value: true });
      Yt.validateMissingCstMethods = Yt.validateVisitor = Yt.CstVisitorDefinitionError = Yt.createBaseVisitorConstructorWithDefaults = Yt.createBaseSemanticVisitorConstructor = Yt.defaultVisit = void 0;
      var Jie = Bi(Or()), Qie = Bi(wc()), Zie = Bi(qe()), Kq = Bi(jt()), eoe = Bi(Ut()), toe = Bi(Oc()), roe = Bi(Dr()), noe = Bi(vs()), ioe = Bi(ca()), zq = Bq();
      function Vq(t, e) {
        for (var r = (0, roe.default)(t), n = r.length, i = 0; i < n; i++)
          for (var o = r[i], a = t[o], s = a.length, u = 0; u < s; u++) {
            var c = a[u];
            c.tokenTypeIdx === void 0 && this[c.name](c.children, e);
          }
      }
      Yt.defaultVisit = Vq;
      function ooe(t, e) {
        var r = function() {
        };
        (0, zq.defineNameProp)(r, t + "BaseSemantics");
        var n = { visit: function(i, o) {
          if ((0, Zie.default)(i) && (i = i[0]), !(0, ioe.default)(i))
            return this[i.name](i.children, o);
        }, validateVisitor: function() {
          var i = Xq(this, e);
          if (!(0, Jie.default)(i)) {
            var o = (0, Kq.default)(i, function(a) {
              return a.msg;
            });
            throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, `>:
	`) + "".concat(o.join(`

`).replace(/\n/g, `
	`)));
          }
        } };
        return r.prototype = n, r.prototype.constructor = r, r._RULE_NAMES = e, r;
      }
      Yt.createBaseSemanticVisitorConstructor = ooe;
      function aoe(t, e, r) {
        var n = function() {
        };
        (0, zq.defineNameProp)(n, t + "BaseSemanticsWithDefaults");
        var i = Object.create(r.prototype);
        return (0, eoe.default)(e, function(o) {
          i[o] = Vq;
        }), n.prototype = i, n.prototype.constructor = n, n;
      }
      Yt.createBaseVisitorConstructorWithDefaults = aoe;
      var Yq;
      (function(t) {
        t[t.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", t[t.MISSING_METHOD = 1] = "MISSING_METHOD";
      })(Yq = Yt.CstVisitorDefinitionError || (Yt.CstVisitorDefinitionError = {}));
      function Xq(t, e) {
        var r = Jq(t, e);
        return r;
      }
      Yt.validateVisitor = Xq;
      function Jq(t, e) {
        var r = (0, toe.default)(e, function(i) {
          return (0, noe.default)(t[i]) === false;
        }), n = (0, Kq.default)(r, function(i) {
          return { msg: "Missing visitor method: <".concat(i, "> on ").concat(t.constructor.name, " CST Visitor."), type: Yq.MISSING_METHOD, methodName: i };
        });
        return (0, Qie.default)(n);
      }
      Yt.validateMissingCstMethods = Jq;
    });
    var rL = f((Xs) => {
      var Np = Xs && Xs.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Xs, "__esModule", { value: true });
      Xs.TreeBuilder = void 0;
      var Ys = Wq(), pr = Np(Vf()), soe = Np(Ir()), Zq = Np(Dr()), eL = Np(ca()), tL = Qq(), uoe = br(), coe = function() {
        function t() {
        }
        return t.prototype.initTreeBuilder = function(e) {
          if (this.CST_STACK = [], this.outputCst = e.outputCst, this.nodeLocationTracking = (0, soe.default)(e, "nodeLocationTracking") ? e.nodeLocationTracking : uoe.DEFAULT_PARSER_CONFIG.nodeLocationTracking, !this.outputCst)
            this.cstInvocationStateUpdate = pr.default, this.cstFinallyStateUpdate = pr.default, this.cstPostTerminal = pr.default, this.cstPostNonTerminal = pr.default, this.cstPostRule = pr.default;
          else if (/full/i.test(this.nodeLocationTracking))
            this.recoveryEnabled ? (this.setNodeLocationFromToken = Ys.setNodeLocationFull, this.setNodeLocationFromNode = Ys.setNodeLocationFull, this.cstPostRule = pr.default, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = pr.default, this.setNodeLocationFromNode = pr.default, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
          else if (/onlyOffset/i.test(this.nodeLocationTracking))
            this.recoveryEnabled ? (this.setNodeLocationFromToken = Ys.setNodeLocationOnlyOffset, this.setNodeLocationFromNode = Ys.setNodeLocationOnlyOffset, this.cstPostRule = pr.default, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = pr.default, this.setNodeLocationFromNode = pr.default, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
          else if (/none/i.test(this.nodeLocationTracking))
            this.setNodeLocationFromToken = pr.default, this.setNodeLocationFromNode = pr.default, this.cstPostRule = pr.default, this.setInitialNodeLocation = pr.default;
          else
            throw Error('Invalid <nodeLocationTracking> config option: "'.concat(e.nodeLocationTracking, '"'));
        }, t.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(e) {
          e.location = { startOffset: NaN, endOffset: NaN };
        }, t.prototype.setInitialNodeLocationOnlyOffsetRegular = function(e) {
          e.location = { startOffset: this.LA(1).startOffset, endOffset: NaN };
        }, t.prototype.setInitialNodeLocationFullRecovery = function(e) {
          e.location = { startOffset: NaN, startLine: NaN, startColumn: NaN, endOffset: NaN, endLine: NaN, endColumn: NaN };
        }, t.prototype.setInitialNodeLocationFullRegular = function(e) {
          var r = this.LA(1);
          e.location = { startOffset: r.startOffset, startLine: r.startLine, startColumn: r.startColumn, endOffset: NaN, endLine: NaN, endColumn: NaN };
        }, t.prototype.cstInvocationStateUpdate = function(e) {
          var r = { name: e, children: /* @__PURE__ */ Object.create(null) };
          this.setInitialNodeLocation(r), this.CST_STACK.push(r);
        }, t.prototype.cstFinallyStateUpdate = function() {
          this.CST_STACK.pop();
        }, t.prototype.cstPostRuleFull = function(e) {
          var r = this.LA(0), n = e.location;
          n.startOffset <= r.startOffset ? (n.endOffset = r.endOffset, n.endLine = r.endLine, n.endColumn = r.endColumn) : (n.startOffset = NaN, n.startLine = NaN, n.startColumn = NaN);
        }, t.prototype.cstPostRuleOnlyOffset = function(e) {
          var r = this.LA(0), n = e.location;
          n.startOffset <= r.startOffset ? n.endOffset = r.endOffset : n.startOffset = NaN;
        }, t.prototype.cstPostTerminal = function(e, r) {
          var n = this.CST_STACK[this.CST_STACK.length - 1];
          (0, Ys.addTerminalToCst)(n, r, e), this.setNodeLocationFromToken(n.location, r);
        }, t.prototype.cstPostNonTerminal = function(e, r) {
          var n = this.CST_STACK[this.CST_STACK.length - 1];
          (0, Ys.addNoneTerminalToCst)(n, r, e), this.setNodeLocationFromNode(n.location, e.location);
        }, t.prototype.getBaseCstVisitorConstructor = function() {
          if ((0, eL.default)(this.baseCstVisitorConstructor)) {
            var e = (0, tL.createBaseSemanticVisitorConstructor)(this.className, (0, Zq.default)(this.gastProductionsCache));
            return this.baseCstVisitorConstructor = e, e;
          }
          return this.baseCstVisitorConstructor;
        }, t.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
          if ((0, eL.default)(this.baseCstVisitorWithDefaultsConstructor)) {
            var e = (0, tL.createBaseVisitorConstructorWithDefaults)(this.className, (0, Zq.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
            return this.baseCstVisitorWithDefaultsConstructor = e, e;
          }
          return this.baseCstVisitorWithDefaultsConstructor;
        }, t.prototype.getLastExplicitRuleShortName = function() {
          var e = this.RULE_STACK;
          return e[e.length - 1];
        }, t.prototype.getPreviousExplicitRuleShortName = function() {
          var e = this.RULE_STACK;
          return e[e.length - 2];
        }, t.prototype.getLastExplicitRuleOccurrenceIndex = function() {
          var e = this.RULE_OCCURRENCE_STACK;
          return e[e.length - 1];
        }, t;
      }();
      Xs.TreeBuilder = coe;
    });
    var iL = f((Ep) => {
      Object.defineProperty(Ep, "__esModule", { value: true });
      Ep.LexerAdapter = void 0;
      var nL = br(), loe = function() {
        function t() {
        }
        return t.prototype.initLexerAdapter = function() {
          this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1;
        }, Object.defineProperty(t.prototype, "input", { get: function() {
          return this.tokVector;
        }, set: function(e) {
          if (this.selfAnalysisDone !== true)
            throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
          this.reset(), this.tokVector = e, this.tokVectorLength = e.length;
        }, enumerable: false, configurable: true }), t.prototype.SKIP_TOKEN = function() {
          return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : nL.END_OF_FILE;
        }, t.prototype.LA = function(e) {
          var r = this.currIdx + e;
          return r < 0 || this.tokVectorLength <= r ? nL.END_OF_FILE : this.tokVector[r];
        }, t.prototype.consumeToken = function() {
          this.currIdx++;
        }, t.prototype.exportLexerState = function() {
          return this.currIdx;
        }, t.prototype.importLexerState = function(e) {
          this.currIdx = e;
        }, t.prototype.resetLexerState = function() {
          this.currIdx = -1;
        }, t.prototype.moveToTerminatedState = function() {
          this.currIdx = this.tokVector.length - 1;
        }, t.prototype.getLexerPosition = function() {
          return this.exportLexerState();
        }, t;
      }();
      Ep.LexerAdapter = loe;
    });
    var aL = f((Js) => {
      var oL = Js && Js.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Js, "__esModule", { value: true });
      Js.RecognizerApi = void 0;
      var doe = oL(Qn()), foe = oL(qi()), poe = zs(), c_ = br(), hoe = Ws(), moe = Fc(), goe = vt(), yoe = function() {
        function t() {
        }
        return t.prototype.ACTION = function(e) {
          return e.call(this);
        }, t.prototype.consume = function(e, r, n) {
          return this.consumeInternal(r, e, n);
        }, t.prototype.subrule = function(e, r, n) {
          return this.subruleInternal(r, e, n);
        }, t.prototype.option = function(e, r) {
          return this.optionInternal(r, e);
        }, t.prototype.or = function(e, r) {
          return this.orInternal(r, e);
        }, t.prototype.many = function(e, r) {
          return this.manyInternal(e, r);
        }, t.prototype.atLeastOne = function(e, r) {
          return this.atLeastOneInternal(e, r);
        }, t.prototype.CONSUME = function(e, r) {
          return this.consumeInternal(e, 0, r);
        }, t.prototype.CONSUME1 = function(e, r) {
          return this.consumeInternal(e, 1, r);
        }, t.prototype.CONSUME2 = function(e, r) {
          return this.consumeInternal(e, 2, r);
        }, t.prototype.CONSUME3 = function(e, r) {
          return this.consumeInternal(e, 3, r);
        }, t.prototype.CONSUME4 = function(e, r) {
          return this.consumeInternal(e, 4, r);
        }, t.prototype.CONSUME5 = function(e, r) {
          return this.consumeInternal(e, 5, r);
        }, t.prototype.CONSUME6 = function(e, r) {
          return this.consumeInternal(e, 6, r);
        }, t.prototype.CONSUME7 = function(e, r) {
          return this.consumeInternal(e, 7, r);
        }, t.prototype.CONSUME8 = function(e, r) {
          return this.consumeInternal(e, 8, r);
        }, t.prototype.CONSUME9 = function(e, r) {
          return this.consumeInternal(e, 9, r);
        }, t.prototype.SUBRULE = function(e, r) {
          return this.subruleInternal(e, 0, r);
        }, t.prototype.SUBRULE1 = function(e, r) {
          return this.subruleInternal(e, 1, r);
        }, t.prototype.SUBRULE2 = function(e, r) {
          return this.subruleInternal(e, 2, r);
        }, t.prototype.SUBRULE3 = function(e, r) {
          return this.subruleInternal(e, 3, r);
        }, t.prototype.SUBRULE4 = function(e, r) {
          return this.subruleInternal(e, 4, r);
        }, t.prototype.SUBRULE5 = function(e, r) {
          return this.subruleInternal(e, 5, r);
        }, t.prototype.SUBRULE6 = function(e, r) {
          return this.subruleInternal(e, 6, r);
        }, t.prototype.SUBRULE7 = function(e, r) {
          return this.subruleInternal(e, 7, r);
        }, t.prototype.SUBRULE8 = function(e, r) {
          return this.subruleInternal(e, 8, r);
        }, t.prototype.SUBRULE9 = function(e, r) {
          return this.subruleInternal(e, 9, r);
        }, t.prototype.OPTION = function(e) {
          return this.optionInternal(e, 0);
        }, t.prototype.OPTION1 = function(e) {
          return this.optionInternal(e, 1);
        }, t.prototype.OPTION2 = function(e) {
          return this.optionInternal(e, 2);
        }, t.prototype.OPTION3 = function(e) {
          return this.optionInternal(e, 3);
        }, t.prototype.OPTION4 = function(e) {
          return this.optionInternal(e, 4);
        }, t.prototype.OPTION5 = function(e) {
          return this.optionInternal(e, 5);
        }, t.prototype.OPTION6 = function(e) {
          return this.optionInternal(e, 6);
        }, t.prototype.OPTION7 = function(e) {
          return this.optionInternal(e, 7);
        }, t.prototype.OPTION8 = function(e) {
          return this.optionInternal(e, 8);
        }, t.prototype.OPTION9 = function(e) {
          return this.optionInternal(e, 9);
        }, t.prototype.OR = function(e) {
          return this.orInternal(e, 0);
        }, t.prototype.OR1 = function(e) {
          return this.orInternal(e, 1);
        }, t.prototype.OR2 = function(e) {
          return this.orInternal(e, 2);
        }, t.prototype.OR3 = function(e) {
          return this.orInternal(e, 3);
        }, t.prototype.OR4 = function(e) {
          return this.orInternal(e, 4);
        }, t.prototype.OR5 = function(e) {
          return this.orInternal(e, 5);
        }, t.prototype.OR6 = function(e) {
          return this.orInternal(e, 6);
        }, t.prototype.OR7 = function(e) {
          return this.orInternal(e, 7);
        }, t.prototype.OR8 = function(e) {
          return this.orInternal(e, 8);
        }, t.prototype.OR9 = function(e) {
          return this.orInternal(e, 9);
        }, t.prototype.MANY = function(e) {
          this.manyInternal(0, e);
        }, t.prototype.MANY1 = function(e) {
          this.manyInternal(1, e);
        }, t.prototype.MANY2 = function(e) {
          this.manyInternal(2, e);
        }, t.prototype.MANY3 = function(e) {
          this.manyInternal(3, e);
        }, t.prototype.MANY4 = function(e) {
          this.manyInternal(4, e);
        }, t.prototype.MANY5 = function(e) {
          this.manyInternal(5, e);
        }, t.prototype.MANY6 = function(e) {
          this.manyInternal(6, e);
        }, t.prototype.MANY7 = function(e) {
          this.manyInternal(7, e);
        }, t.prototype.MANY8 = function(e) {
          this.manyInternal(8, e);
        }, t.prototype.MANY9 = function(e) {
          this.manyInternal(9, e);
        }, t.prototype.MANY_SEP = function(e) {
          this.manySepFirstInternal(0, e);
        }, t.prototype.MANY_SEP1 = function(e) {
          this.manySepFirstInternal(1, e);
        }, t.prototype.MANY_SEP2 = function(e) {
          this.manySepFirstInternal(2, e);
        }, t.prototype.MANY_SEP3 = function(e) {
          this.manySepFirstInternal(3, e);
        }, t.prototype.MANY_SEP4 = function(e) {
          this.manySepFirstInternal(4, e);
        }, t.prototype.MANY_SEP5 = function(e) {
          this.manySepFirstInternal(5, e);
        }, t.prototype.MANY_SEP6 = function(e) {
          this.manySepFirstInternal(6, e);
        }, t.prototype.MANY_SEP7 = function(e) {
          this.manySepFirstInternal(7, e);
        }, t.prototype.MANY_SEP8 = function(e) {
          this.manySepFirstInternal(8, e);
        }, t.prototype.MANY_SEP9 = function(e) {
          this.manySepFirstInternal(9, e);
        }, t.prototype.AT_LEAST_ONE = function(e) {
          this.atLeastOneInternal(0, e);
        }, t.prototype.AT_LEAST_ONE1 = function(e) {
          return this.atLeastOneInternal(1, e);
        }, t.prototype.AT_LEAST_ONE2 = function(e) {
          this.atLeastOneInternal(2, e);
        }, t.prototype.AT_LEAST_ONE3 = function(e) {
          this.atLeastOneInternal(3, e);
        }, t.prototype.AT_LEAST_ONE4 = function(e) {
          this.atLeastOneInternal(4, e);
        }, t.prototype.AT_LEAST_ONE5 = function(e) {
          this.atLeastOneInternal(5, e);
        }, t.prototype.AT_LEAST_ONE6 = function(e) {
          this.atLeastOneInternal(6, e);
        }, t.prototype.AT_LEAST_ONE7 = function(e) {
          this.atLeastOneInternal(7, e);
        }, t.prototype.AT_LEAST_ONE8 = function(e) {
          this.atLeastOneInternal(8, e);
        }, t.prototype.AT_LEAST_ONE9 = function(e) {
          this.atLeastOneInternal(9, e);
        }, t.prototype.AT_LEAST_ONE_SEP = function(e) {
          this.atLeastOneSepFirstInternal(0, e);
        }, t.prototype.AT_LEAST_ONE_SEP1 = function(e) {
          this.atLeastOneSepFirstInternal(1, e);
        }, t.prototype.AT_LEAST_ONE_SEP2 = function(e) {
          this.atLeastOneSepFirstInternal(2, e);
        }, t.prototype.AT_LEAST_ONE_SEP3 = function(e) {
          this.atLeastOneSepFirstInternal(3, e);
        }, t.prototype.AT_LEAST_ONE_SEP4 = function(e) {
          this.atLeastOneSepFirstInternal(4, e);
        }, t.prototype.AT_LEAST_ONE_SEP5 = function(e) {
          this.atLeastOneSepFirstInternal(5, e);
        }, t.prototype.AT_LEAST_ONE_SEP6 = function(e) {
          this.atLeastOneSepFirstInternal(6, e);
        }, t.prototype.AT_LEAST_ONE_SEP7 = function(e) {
          this.atLeastOneSepFirstInternal(7, e);
        }, t.prototype.AT_LEAST_ONE_SEP8 = function(e) {
          this.atLeastOneSepFirstInternal(8, e);
        }, t.prototype.AT_LEAST_ONE_SEP9 = function(e) {
          this.atLeastOneSepFirstInternal(9, e);
        }, t.prototype.RULE = function(e, r, n) {
          if (n === void 0 && (n = c_.DEFAULT_RULE_CONFIG), (0, foe.default)(this.definedRulesNames, e)) {
            var i = hoe.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({ topLevelRule: e, grammarName: this.className }), o = { message: i, type: c_.ParserDefinitionErrorType.DUPLICATE_RULE_NAME, ruleName: e };
            this.definitionErrors.push(o);
          }
          this.definedRulesNames.push(e);
          var a = this.defineRule(e, r, n);
          return this[e] = a, a;
        }, t.prototype.OVERRIDE_RULE = function(e, r, n) {
          n === void 0 && (n = c_.DEFAULT_RULE_CONFIG);
          var i = (0, moe.validateRuleIsOverridden)(e, this.definedRulesNames, this.className);
          this.definitionErrors = this.definitionErrors.concat(i);
          var o = this.defineRule(e, r, n);
          return this[e] = o, o;
        }, t.prototype.BACKTRACK = function(e, r) {
          return function() {
            this.isBackTrackingStack.push(1);
            var n = this.saveRecogState();
            try {
              return e.apply(this, r), true;
            } catch (i) {
              if ((0, poe.isRecognitionException)(i))
                return false;
              throw i;
            } finally {
              this.reloadRecogState(n), this.isBackTrackingStack.pop();
            }
          };
        }, t.prototype.getGAstProductions = function() {
          return this.gastProductionsCache;
        }, t.prototype.getSerializedGastProductions = function() {
          return (0, goe.serializeGrammar)((0, doe.default)(this.gastProductionsCache));
        }, t;
      }();
      Js.RecognizerApi = yoe;
    });
    var hL = f((Zs) => {
      var ci = Zs && Zs.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Zs, "__esModule", { value: true });
      Zs.RecognizerEngine = void 0;
      var sL = ci(Or()), l_ = ci(qe()), d_ = ci(En()), uL = ci(kc()), voe = ci(Yf()), Toe = ci(Pn()), Hc = ci(Ir()), Wc = ci(Qn()), cL = ci(Li()), lL = ci(Ii()), qr = Rp(), kp = zs(), dL = Bs(), Qs = Lc(), fL = br(), _oe = o_(), pL = pa(), Bc = fa(), Roe = function() {
        function t() {
        }
        return t.prototype.initRecognizerEngine = function(e, r) {
          if (this.className = this.constructor.name, this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = Bc.tokenStructuredMatcherNoCategories, this.subruleIdx = 0, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, (0, Hc.default)(r, "serializedGrammar"))
            throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
          if ((0, l_.default)(e)) {
            if ((0, sL.default)(e))
              throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
            if (typeof e[0].startOffset == "number")
              throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`);
          }
          if ((0, l_.default)(e))
            this.tokensMap = (0, cL.default)(e, function(s, u) {
              return s[u.name] = u, s;
            }, {});
          else if ((0, Hc.default)(e, "modes") && (0, uL.default)((0, d_.default)((0, Wc.default)(e.modes)), Bc.isTokenType)) {
            var n = (0, d_.default)((0, Wc.default)(e.modes)), i = (0, voe.default)(n);
            this.tokensMap = (0, cL.default)(i, function(s, u) {
              return s[u.name] = u, s;
            }, {});
          } else if ((0, Toe.default)(e))
            this.tokensMap = (0, lL.default)(e);
          else
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
          this.tokensMap.EOF = pL.EOF;
          var o = (0, Hc.default)(e, "modes") ? (0, d_.default)((0, Wc.default)(e.modes)) : (0, Wc.default)(e), a = (0, uL.default)(o, function(s) {
            return (0, sL.default)(s.categoryMatches);
          });
          this.tokenMatcher = a ? Bc.tokenStructuredMatcherNoCategories : Bc.tokenStructuredMatcher, (0, Bc.augmentTokenTypes)((0, Wc.default)(this.tokensMap));
        }, t.prototype.defineRule = function(e, r, n) {
          if (this.selfAnalysisDone)
            throw Error("Grammar rule <".concat(e, `> may not be defined after the 'performSelfAnalysis' method has been called'
`) + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
          var i = (0, Hc.default)(n, "resyncEnabled") ? n.resyncEnabled : fL.DEFAULT_RULE_CONFIG.resyncEnabled, o = (0, Hc.default)(n, "recoveryValueFunc") ? n.recoveryValueFunc : fL.DEFAULT_RULE_CONFIG.recoveryValueFunc, a = this.ruleShortNameIdx << qr.BITS_FOR_METHOD_TYPE + qr.BITS_FOR_OCCURRENCE_IDX;
          this.ruleShortNameIdx++, this.shortRuleNameToFull[a] = e, this.fullRuleNameToShort[e] = a;
          var s;
          this.outputCst === true ? s = function() {
            for (var l = [], d = 0; d < arguments.length; d++)
              l[d] = arguments[d];
            try {
              this.ruleInvocationStateUpdate(a, e, this.subruleIdx), r.apply(this, l);
              var h = this.CST_STACK[this.CST_STACK.length - 1];
              return this.cstPostRule(h), h;
            } catch (y) {
              return this.invokeRuleCatch(y, i, o);
            } finally {
              this.ruleFinallyStateUpdate();
            }
          } : s = function() {
            for (var l = [], d = 0; d < arguments.length; d++)
              l[d] = arguments[d];
            try {
              return this.ruleInvocationStateUpdate(a, e, this.subruleIdx), r.apply(this, l);
            } catch (h) {
              return this.invokeRuleCatch(h, i, o);
            } finally {
              this.ruleFinallyStateUpdate();
            }
          };
          var u = Object.assign(s, { ruleName: e, originalGrammarAction: r });
          return u;
        }, t.prototype.invokeRuleCatch = function(e, r, n) {
          var i = this.RULE_STACK.length === 1, o = r && !this.isBackTracking() && this.recoveryEnabled;
          if ((0, kp.isRecognitionException)(e)) {
            var a = e;
            if (o) {
              var s = this.findReSyncTokenType();
              if (this.isInCurrentRuleReSyncSet(s))
                if (a.resyncedTokens = this.reSyncTo(s), this.outputCst) {
                  var u = this.CST_STACK[this.CST_STACK.length - 1];
                  return u.recoveredNode = true, u;
                } else
                  return n();
              else {
                if (this.outputCst) {
                  var u = this.CST_STACK[this.CST_STACK.length - 1];
                  u.recoveredNode = true, a.partialCstResult = u;
                }
                throw a;
              }
            } else {
              if (i)
                return this.moveToTerminatedState(), n();
              throw a;
            }
          } else
            throw e;
        }, t.prototype.optionInternal = function(e, r) {
          var n = this.getKeyForAutomaticLookahead(qr.OPTION_IDX, r);
          return this.optionInternalLogic(e, r, n);
        }, t.prototype.optionInternalLogic = function(e, r, n) {
          var i = this, o = this.getLaFuncFromCache(n), a;
          if (typeof e != "function") {
            a = e.DEF;
            var s = e.GATE;
            if (s !== void 0) {
              var u = o;
              o = function() {
                return s.call(i) && u.call(i);
              };
            }
          } else
            a = e;
          if (o.call(this) === true)
            return a.call(this);
        }, t.prototype.atLeastOneInternal = function(e, r) {
          var n = this.getKeyForAutomaticLookahead(qr.AT_LEAST_ONE_IDX, e);
          return this.atLeastOneInternalLogic(e, r, n);
        }, t.prototype.atLeastOneInternalLogic = function(e, r, n) {
          var i = this, o = this.getLaFuncFromCache(n), a;
          if (typeof r != "function") {
            a = r.DEF;
            var s = r.GATE;
            if (s !== void 0) {
              var u = o;
              o = function() {
                return s.call(i) && u.call(i);
              };
            }
          } else
            a = r;
          if (o.call(this) === true)
            for (var c = this.doSingleRepetition(a); o.call(this) === true && c === true; )
              c = this.doSingleRepetition(a);
          else
            throw this.raiseEarlyExitException(e, dL.PROD_TYPE.REPETITION_MANDATORY, r.ERR_MSG);
          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, r], o, qr.AT_LEAST_ONE_IDX, e, Qs.NextTerminalAfterAtLeastOneWalker);
        }, t.prototype.atLeastOneSepFirstInternal = function(e, r) {
          var n = this.getKeyForAutomaticLookahead(qr.AT_LEAST_ONE_SEP_IDX, e);
          this.atLeastOneSepFirstInternalLogic(e, r, n);
        }, t.prototype.atLeastOneSepFirstInternalLogic = function(e, r, n) {
          var i = this, o = r.DEF, a = r.SEP, s = this.getLaFuncFromCache(n);
          if (s.call(this) === true) {
            o.call(this);
            for (var u = function() {
              return i.tokenMatcher(i.LA(1), a);
            }; this.tokenMatcher(this.LA(1), a) === true; )
              this.CONSUME(a), o.call(this);
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, a, u, o, Qs.NextTerminalAfterAtLeastOneSepWalker], u, qr.AT_LEAST_ONE_SEP_IDX, e, Qs.NextTerminalAfterAtLeastOneSepWalker);
          } else
            throw this.raiseEarlyExitException(e, dL.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, r.ERR_MSG);
        }, t.prototype.manyInternal = function(e, r) {
          var n = this.getKeyForAutomaticLookahead(qr.MANY_IDX, e);
          return this.manyInternalLogic(e, r, n);
        }, t.prototype.manyInternalLogic = function(e, r, n) {
          var i = this, o = this.getLaFuncFromCache(n), a;
          if (typeof r != "function") {
            a = r.DEF;
            var s = r.GATE;
            if (s !== void 0) {
              var u = o;
              o = function() {
                return s.call(i) && u.call(i);
              };
            }
          } else
            a = r;
          for (var c = true; o.call(this) === true && c === true; )
            c = this.doSingleRepetition(a);
          this.attemptInRepetitionRecovery(this.manyInternal, [e, r], o, qr.MANY_IDX, e, Qs.NextTerminalAfterManyWalker, c);
        }, t.prototype.manySepFirstInternal = function(e, r) {
          var n = this.getKeyForAutomaticLookahead(qr.MANY_SEP_IDX, e);
          this.manySepFirstInternalLogic(e, r, n);
        }, t.prototype.manySepFirstInternalLogic = function(e, r, n) {
          var i = this, o = r.DEF, a = r.SEP, s = this.getLaFuncFromCache(n);
          if (s.call(this) === true) {
            o.call(this);
            for (var u = function() {
              return i.tokenMatcher(i.LA(1), a);
            }; this.tokenMatcher(this.LA(1), a) === true; )
              this.CONSUME(a), o.call(this);
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, a, u, o, Qs.NextTerminalAfterManySepWalker], u, qr.MANY_SEP_IDX, e, Qs.NextTerminalAfterManySepWalker);
          }
        }, t.prototype.repetitionSepSecondInternal = function(e, r, n, i, o) {
          for (; n(); )
            this.CONSUME(r), i.call(this);
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, r, n, i, o], n, qr.AT_LEAST_ONE_SEP_IDX, e, o);
        }, t.prototype.doSingleRepetition = function(e) {
          var r = this.getLexerPosition();
          e.call(this);
          var n = this.getLexerPosition();
          return n > r;
        }, t.prototype.orInternal = function(e, r) {
          var n = this.getKeyForAutomaticLookahead(qr.OR_IDX, r), i = (0, l_.default)(e) ? e : e.DEF, o = this.getLaFuncFromCache(n), a = o.call(this, i);
          if (a !== void 0) {
            var s = i[a];
            return s.ALT.call(this);
          }
          this.raiseNoAltException(r, e.ERR_MSG);
        }, t.prototype.ruleFinallyStateUpdate = function() {
          if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var e = this.LA(1), r = this.errorMessageProvider.buildNotAllInputParsedMessage({ firstRedundant: e, ruleName: this.getCurrRuleFullName() });
            this.SAVE_ERROR(new kp.NotAllInputParsedException(r, e));
          }
        }, t.prototype.subruleInternal = function(e, r, n) {
          var i;
          try {
            var o = n !== void 0 ? n.ARGS : void 0;
            return this.subruleIdx = r, i = e.apply(this, o), this.cstPostNonTerminal(i, n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.ruleName), i;
          } catch (a) {
            throw this.subruleInternalError(a, n, e.ruleName);
          }
        }, t.prototype.subruleInternalError = function(e, r, n) {
          throw (0, kp.isRecognitionException)(e) && e.partialCstResult !== void 0 && (this.cstPostNonTerminal(e.partialCstResult, r !== void 0 && r.LABEL !== void 0 ? r.LABEL : n), delete e.partialCstResult), e;
        }, t.prototype.consumeInternal = function(e, r, n) {
          var i;
          try {
            var o = this.LA(1);
            this.tokenMatcher(o, e) === true ? (this.consumeToken(), i = o) : this.consumeInternalError(e, o, n);
          } catch (a) {
            i = this.consumeInternalRecovery(e, r, a);
          }
          return this.cstPostTerminal(n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.name, i), i;
        }, t.prototype.consumeInternalError = function(e, r, n) {
          var i, o = this.LA(0);
          throw n !== void 0 && n.ERR_MSG ? i = n.ERR_MSG : i = this.errorMessageProvider.buildMismatchTokenMessage({ expected: e, actual: r, previous: o, ruleName: this.getCurrRuleFullName() }), this.SAVE_ERROR(new kp.MismatchedTokenException(i, r, o));
        }, t.prototype.consumeInternalRecovery = function(e, r, n) {
          if (this.recoveryEnabled && n.name === "MismatchedTokenException" && !this.isBackTracking()) {
            var i = this.getFollowsForInRuleRecovery(e, r);
            try {
              return this.tryInRuleRecovery(e, i);
            } catch (o) {
              throw o.name === _oe.IN_RULE_RECOVERY_EXCEPTION ? n : o;
            }
          } else
            throw n;
        }, t.prototype.saveRecogState = function() {
          var e = this.errors, r = (0, lL.default)(this.RULE_STACK);
          return { errors: e, lexerState: this.exportLexerState(), RULE_STACK: r, CST_STACK: this.CST_STACK };
        }, t.prototype.reloadRecogState = function(e) {
          this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK;
        }, t.prototype.ruleInvocationStateUpdate = function(e, r, n) {
          this.RULE_OCCURRENCE_STACK.push(n), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(r);
        }, t.prototype.isBackTracking = function() {
          return this.isBackTrackingStack.length !== 0;
        }, t.prototype.getCurrRuleFullName = function() {
          var e = this.getLastExplicitRuleShortName();
          return this.shortRuleNameToFull[e];
        }, t.prototype.shortRuleNameToFullName = function(e) {
          return this.shortRuleNameToFull[e];
        }, t.prototype.isAtEndOfInput = function() {
          return this.tokenMatcher(this.LA(1), pL.EOF);
        }, t.prototype.reset = function() {
          this.resetLexerState(), this.subruleIdx = 0, this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [];
        }, t;
      }();
      Zs.RecognizerEngine = Roe;
    });
    var vL = f((eu) => {
      var yL = eu && eu.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(eu, "__esModule", { value: true });
      eu.ErrorHandler = void 0;
      var f_ = zs(), boe = yL(Ir()), mL = yL(Ii()), gL = Bs(), Soe = br(), Aoe = function() {
        function t() {
        }
        return t.prototype.initErrorHandler = function(e) {
          this._errors = [], this.errorMessageProvider = (0, boe.default)(e, "errorMessageProvider") ? e.errorMessageProvider : Soe.DEFAULT_PARSER_CONFIG.errorMessageProvider;
        }, t.prototype.SAVE_ERROR = function(e) {
          if ((0, f_.isRecognitionException)(e))
            return e.context = { ruleStack: this.getHumanReadableRuleStack(), ruleOccurrenceStack: (0, mL.default)(this.RULE_OCCURRENCE_STACK) }, this._errors.push(e), e;
          throw Error("Trying to save an Error which is not a RecognitionException");
        }, Object.defineProperty(t.prototype, "errors", { get: function() {
          return (0, mL.default)(this._errors);
        }, set: function(e) {
          this._errors = e;
        }, enumerable: false, configurable: true }), t.prototype.raiseEarlyExitException = function(e, r, n) {
          for (var i = this.getCurrRuleFullName(), o = this.getGAstProductions()[i], a = (0, gL.getLookaheadPathsForOptionalProd)(e, o, r, this.maxLookahead), s = a[0], u = [], c = 1; c <= this.maxLookahead; c++)
            u.push(this.LA(c));
          var l = this.errorMessageProvider.buildEarlyExitMessage({ expectedIterationPaths: s, actual: u, previous: this.LA(0), customUserDescription: n, ruleName: i });
          throw this.SAVE_ERROR(new f_.EarlyExitException(l, this.LA(1), this.LA(0)));
        }, t.prototype.raiseNoAltException = function(e, r) {
          for (var n = this.getCurrRuleFullName(), i = this.getGAstProductions()[n], o = (0, gL.getLookaheadPathsForOr)(e, i, this.maxLookahead), a = [], s = 1; s <= this.maxLookahead; s++)
            a.push(this.LA(s));
          var u = this.LA(0), c = this.errorMessageProvider.buildNoViableAltMessage({ expectedPathsPerAlt: o, actual: a, previous: u, customUserDescription: r, ruleName: this.getCurrRuleFullName() });
          throw this.SAVE_ERROR(new f_.NoViableAltException(c, this.LA(1), u));
        }, t;
      }();
      eu.ErrorHandler = Aoe;
    });
    var RL = f((tu) => {
      var _L = tu && tu.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(tu, "__esModule", { value: true });
      tu.ContentAssist = void 0;
      var TL = Lc(), Poe = _L(Fs()), Coe = _L(ca()), Noe = function() {
        function t() {
        }
        return t.prototype.initContentAssist = function() {
        }, t.prototype.computeContentAssist = function(e, r) {
          var n = this.gastProductionsCache[e];
          if ((0, Coe.default)(n))
            throw Error("Rule ->".concat(e, "<- does not exist in this grammar."));
          return (0, TL.nextPossibleTokensAfter)([n], r, this.tokenMatcher, this.maxLookahead);
        }, t.prototype.getNextPossibleTokenTypes = function(e) {
          var r = (0, Poe.default)(e.ruleStack), n = this.getGAstProductions(), i = n[r], o = new TL.NextAfterTokenWalker(i, e).startWalking();
          return o;
        }, t;
      }();
      tu.ContentAssist = Noe;
    });
    var wL = f((ru) => {
      var nu = ru && ru.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(ru, "__esModule", { value: true });
      ru.GastRecorder = void 0;
      var wp = nu(lp()), Eoe = nu(qe()), koe = nu(Hf()), woe = nu(Ut()), PL = nu(vs()), zc = nu(Ir()), li = vt(), Ooe = Dc(), CL = fa(), NL = pa(), Doe = br(), Ioe = Rp(), Dp = { description: "This Object indicates the Parser is during Recording Phase" };
      Object.freeze(Dp);
      var bL = true, SL = Math.pow(2, Ioe.BITS_FOR_OCCURRENCE_IDX) - 1, EL = (0, NL.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: Ooe.Lexer.NA });
      (0, CL.augmentTokenTypes)([EL]);
      var kL = (0, NL.createTokenInstance)(EL, `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, -1, -1, -1, -1, -1, -1);
      Object.freeze(kL);
      var xoe = { name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, children: {} }, qoe = function() {
        function t() {
        }
        return t.prototype.initGastRecorder = function(e) {
          this.recordingProdStack = [], this.RECORDING_PHASE = false;
        }, t.prototype.enableRecording = function() {
          var e = this;
          this.RECORDING_PHASE = true, this.TRACE_INIT("Enable Recording", function() {
            for (var r = function(i) {
              var o = i > 0 ? i : "";
              e["CONSUME".concat(o)] = function(a, s) {
                return this.consumeInternalRecord(a, i, s);
              }, e["SUBRULE".concat(o)] = function(a, s) {
                return this.subruleInternalRecord(a, i, s);
              }, e["OPTION".concat(o)] = function(a) {
                return this.optionInternalRecord(a, i);
              }, e["OR".concat(o)] = function(a) {
                return this.orInternalRecord(a, i);
              }, e["MANY".concat(o)] = function(a) {
                this.manyInternalRecord(i, a);
              }, e["MANY_SEP".concat(o)] = function(a) {
                this.manySepFirstInternalRecord(i, a);
              }, e["AT_LEAST_ONE".concat(o)] = function(a) {
                this.atLeastOneInternalRecord(i, a);
              }, e["AT_LEAST_ONE_SEP".concat(o)] = function(a) {
                this.atLeastOneSepFirstInternalRecord(i, a);
              };
            }, n = 0; n < 10; n++)
              r(n);
            e.consume = function(i, o, a) {
              return this.consumeInternalRecord(o, i, a);
            }, e.subrule = function(i, o, a) {
              return this.subruleInternalRecord(o, i, a);
            }, e.option = function(i, o) {
              return this.optionInternalRecord(o, i);
            }, e.or = function(i, o) {
              return this.orInternalRecord(o, i);
            }, e.many = function(i, o) {
              this.manyInternalRecord(i, o);
            }, e.atLeastOne = function(i, o) {
              this.atLeastOneInternalRecord(i, o);
            }, e.ACTION = e.ACTION_RECORD, e.BACKTRACK = e.BACKTRACK_RECORD, e.LA = e.LA_RECORD;
          });
        }, t.prototype.disableRecording = function() {
          var e = this;
          this.RECORDING_PHASE = false, this.TRACE_INIT("Deleting Recording methods", function() {
            for (var r = e, n = 0; n < 10; n++) {
              var i = n > 0 ? n : "";
              delete r["CONSUME".concat(i)], delete r["SUBRULE".concat(i)], delete r["OPTION".concat(i)], delete r["OR".concat(i)], delete r["MANY".concat(i)], delete r["MANY_SEP".concat(i)], delete r["AT_LEAST_ONE".concat(i)], delete r["AT_LEAST_ONE_SEP".concat(i)];
            }
            delete r.consume, delete r.subrule, delete r.option, delete r.or, delete r.many, delete r.atLeastOne, delete r.ACTION, delete r.BACKTRACK, delete r.LA;
          });
        }, t.prototype.ACTION_RECORD = function(e) {
        }, t.prototype.BACKTRACK_RECORD = function(e, r) {
          return function() {
            return true;
          };
        }, t.prototype.LA_RECORD = function(e) {
          return Doe.END_OF_FILE;
        }, t.prototype.topLevelRuleRecord = function(e, r) {
          try {
            var n = new li.Rule({ definition: [], name: e });
            return n.name = e, this.recordingProdStack.push(n), r.call(this), this.recordingProdStack.pop(), n;
          } catch (i) {
            if (i.KNOWN_RECORDER_ERROR !== true)
              try {
                i.message = i.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`;
              } catch {
                throw i;
              }
            throw i;
          }
        }, t.prototype.optionInternalRecord = function(e, r) {
          return Kc.call(this, li.Option, e, r);
        }, t.prototype.atLeastOneInternalRecord = function(e, r) {
          Kc.call(this, li.RepetitionMandatory, r, e);
        }, t.prototype.atLeastOneSepFirstInternalRecord = function(e, r) {
          Kc.call(this, li.RepetitionMandatoryWithSeparator, r, e, bL);
        }, t.prototype.manyInternalRecord = function(e, r) {
          Kc.call(this, li.Repetition, r, e);
        }, t.prototype.manySepFirstInternalRecord = function(e, r) {
          Kc.call(this, li.RepetitionWithSeparator, r, e, bL);
        }, t.prototype.orInternalRecord = function(e, r) {
          return Loe.call(this, e, r);
        }, t.prototype.subruleInternalRecord = function(e, r, n) {
          if (Op(r), !e || (0, zc.default)(e, "ruleName") === false) {
            var i = new Error("<SUBRULE".concat(AL(r), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(e), ">") + `
 inside top level rule: <`.concat(this.recordingProdStack[0].name, ">"));
            throw i.KNOWN_RECORDER_ERROR = true, i;
          }
          var o = (0, wp.default)(this.recordingProdStack), a = e.ruleName, s = new li.NonTerminal({ idx: r, nonTerminalName: a, label: n == null ? void 0 : n.LABEL, referencedRule: void 0 });
          return o.definition.push(s), this.outputCst ? xoe : Dp;
        }, t.prototype.consumeInternalRecord = function(e, r, n) {
          if (Op(r), !(0, CL.hasShortKeyProperty)(e)) {
            var i = new Error("<CONSUME".concat(AL(r), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(e), ">") + `
 inside top level rule: <`.concat(this.recordingProdStack[0].name, ">"));
            throw i.KNOWN_RECORDER_ERROR = true, i;
          }
          var o = (0, wp.default)(this.recordingProdStack), a = new li.Terminal({ idx: r, terminalType: e, label: n == null ? void 0 : n.LABEL });
          return o.definition.push(a), kL;
        }, t;
      }();
      ru.GastRecorder = qoe;
      function Kc(t, e, r, n) {
        n === void 0 && (n = false), Op(r);
        var i = (0, wp.default)(this.recordingProdStack), o = (0, PL.default)(e) ? e : e.DEF, a = new t({ definition: [], idx: r });
        return n && (a.separator = e.SEP), (0, zc.default)(e, "MAX_LOOKAHEAD") && (a.maxLookahead = e.MAX_LOOKAHEAD), this.recordingProdStack.push(a), o.call(this), i.definition.push(a), this.recordingProdStack.pop(), Dp;
      }
      function Loe(t, e) {
        var r = this;
        Op(e);
        var n = (0, wp.default)(this.recordingProdStack), i = (0, Eoe.default)(t) === false, o = i === false ? t : t.DEF, a = new li.Alternation({ definition: [], idx: e, ignoreAmbiguities: i && t.IGNORE_AMBIGUITIES === true });
        (0, zc.default)(t, "MAX_LOOKAHEAD") && (a.maxLookahead = t.MAX_LOOKAHEAD);
        var s = (0, koe.default)(o, function(u) {
          return (0, PL.default)(u.GATE);
        });
        return a.hasPredicates = s, n.definition.push(a), (0, woe.default)(o, function(u) {
          var c = new li.Alternative({ definition: [] });
          a.definition.push(c), (0, zc.default)(u, "IGNORE_AMBIGUITIES") ? c.ignoreAmbiguities = u.IGNORE_AMBIGUITIES : (0, zc.default)(u, "GATE") && (c.ignoreAmbiguities = true), r.recordingProdStack.push(c), u.ALT.call(r), r.recordingProdStack.pop();
        }), Dp;
      }
      function AL(t) {
        return t === 0 ? "" : "".concat(t);
      }
      function Op(t) {
        if (t < 0 || t > SL) {
          var e = new Error("Invalid DSL Method idx value: <".concat(t, `>
	`) + "Idx value must be a none negative value smaller than ".concat(SL + 1));
          throw e.KNOWN_RECORDER_ERROR = true, e;
        }
      }
    });
    var OL = f((iu) => {
      var Moe = iu && iu.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(iu, "__esModule", { value: true });
      iu.PerformanceTracer = void 0;
      var $oe = Moe(Ir()), Foe = qs(), joe = br(), Uoe = function() {
        function t() {
        }
        return t.prototype.initPerformanceTracer = function(e) {
          if ((0, $oe.default)(e, "traceInitPerf")) {
            var r = e.traceInitPerf, n = typeof r == "number";
            this.traceInitMaxIdent = n ? r : 1 / 0, this.traceInitPerf = n ? r > 0 : r;
          } else
            this.traceInitMaxIdent = 0, this.traceInitPerf = joe.DEFAULT_PARSER_CONFIG.traceInitPerf;
          this.traceInitIndent = -1;
        }, t.prototype.TRACE_INIT = function(e, r) {
          if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var n = new Array(this.traceInitIndent + 1).join("	");
            this.traceInitIndent < this.traceInitMaxIdent && console.log("".concat(n, "--> <").concat(e, ">"));
            var i = (0, Foe.timer)(r), o = i.time, a = i.value, s = o > 10 ? console.warn : console.log;
            return this.traceInitIndent < this.traceInitMaxIdent && s("".concat(n, "<-- <").concat(e, "> time: ").concat(o, "ms")), this.traceInitIndent--, a;
          } else
            return r();
        }, t;
      }();
      iu.PerformanceTracer = Uoe;
    });
    var DL = f((Ip) => {
      Object.defineProperty(Ip, "__esModule", { value: true });
      Ip.applyMixins = void 0;
      function Goe(t, e) {
        e.forEach(function(r) {
          var n = r.prototype;
          Object.getOwnPropertyNames(n).forEach(function(i) {
            if (i !== "constructor") {
              var o = Object.getOwnPropertyDescriptor(n, i);
              o && (o.get || o.set) ? Object.defineProperty(t.prototype, i, o) : t.prototype[i] = r.prototype[i];
            }
          });
        });
      }
      Ip.applyMixins = Goe;
    });
    var br = f((Ge) => {
      var LL = Ge && Ge.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), ou = Ge && Ge.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Ge, "__esModule", { value: true });
      Ge.EmbeddedActionsParser = Ge.CstParser = Ge.Parser = Ge.EMPTY_ALT = Ge.ParserDefinitionErrorType = Ge.DEFAULT_RULE_CONFIG = Ge.DEFAULT_PARSER_CONFIG = Ge.END_OF_FILE = void 0;
      var p_ = ou(Or()), Hoe = ou(jt()), Woe = ou(Ut()), Eo = ou(Qn()), IL = ou(Ir()), ML = ou(Ii()), Boe = qs(), Koe = gI(), xL = pa(), $L = Ws(), qL = kq(), zoe = o_(), Voe = Hq(), Yoe = rL(), Xoe = iL(), Joe = aL(), Qoe = hL(), Zoe = vL(), eae = RL(), tae = wL(), rae = OL(), nae = DL(), iae = Fc();
      Ge.END_OF_FILE = (0, xL.createTokenInstance)(xL.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
      Object.freeze(Ge.END_OF_FILE);
      Ge.DEFAULT_PARSER_CONFIG = Object.freeze({ recoveryEnabled: false, maxLookahead: 3, dynamicTokensEnabled: false, outputCst: true, errorMessageProvider: $L.defaultParserErrorProvider, nodeLocationTracking: "none", traceInitPerf: false, skipValidations: false });
      Ge.DEFAULT_RULE_CONFIG = Object.freeze({ recoveryValueFunc: function() {
      }, resyncEnabled: true });
      (function(t) {
        t[t.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", t[t.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", t[t.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", t[t.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", t[t.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", t[t.LEFT_RECURSION = 5] = "LEFT_RECURSION", t[t.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", t[t.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", t[t.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", t[t.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", t[t.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", t[t.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", t[t.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS", t[t.CUSTOM_LOOKAHEAD_VALIDATION = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
      })(Ge.ParserDefinitionErrorType || (Ge.ParserDefinitionErrorType = {}));
      function aae(t) {
        return t === void 0 && (t = void 0), function() {
          return t;
        };
      }
      Ge.EMPTY_ALT = aae;
      var xp = function() {
        function t(e, r) {
          this.definitionErrors = [], this.selfAnalysisDone = false;
          var n = this;
          if (n.initErrorHandler(r), n.initLexerAdapter(), n.initLooksAhead(r), n.initRecognizerEngine(e, r), n.initRecoverable(r), n.initTreeBuilder(r), n.initContentAssist(), n.initGastRecorder(r), n.initPerformanceTracer(r), (0, IL.default)(r, "ignoredIssues"))
            throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
          this.skipValidations = (0, IL.default)(r, "skipValidations") ? r.skipValidations : Ge.DEFAULT_PARSER_CONFIG.skipValidations;
        }
        return t.performSelfAnalysis = function(e) {
          throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
        }, t.prototype.performSelfAnalysis = function() {
          var e = this;
          this.TRACE_INIT("performSelfAnalysis", function() {
            var r;
            e.selfAnalysisDone = true;
            var n = e.className;
            e.TRACE_INIT("toFastProps", function() {
              (0, Boe.toFastProperties)(e);
            }), e.TRACE_INIT("Grammar Recording", function() {
              try {
                e.enableRecording(), (0, Woe.default)(e.definedRulesNames, function(o) {
                  var a = e[o], s = a.originalGrammarAction, u;
                  e.TRACE_INIT("".concat(o, " Rule"), function() {
                    u = e.topLevelRuleRecord(o, s);
                  }), e.gastProductionsCache[o] = u;
                });
              } finally {
                e.disableRecording();
              }
            });
            var i = [];
            if (e.TRACE_INIT("Grammar Resolving", function() {
              i = (0, qL.resolveGrammar)({ rules: (0, Eo.default)(e.gastProductionsCache) }), e.definitionErrors = e.definitionErrors.concat(i);
            }), e.TRACE_INIT("Grammar Validations", function() {
              if ((0, p_.default)(i) && e.skipValidations === false) {
                var o = (0, qL.validateGrammar)({ rules: (0, Eo.default)(e.gastProductionsCache), tokenTypes: (0, Eo.default)(e.tokensMap), errMsgProvider: $L.defaultGrammarValidatorErrorProvider, grammarName: n }), a = (0, iae.validateLookahead)({ lookaheadStrategy: e.lookaheadStrategy, rules: (0, Eo.default)(e.gastProductionsCache), tokenTypes: (0, Eo.default)(e.tokensMap), grammarName: n });
                e.definitionErrors = e.definitionErrors.concat(o, a);
              }
            }), (0, p_.default)(e.definitionErrors) && (e.recoveryEnabled && e.TRACE_INIT("computeAllProdsFollows", function() {
              var o = (0, Koe.computeAllProdsFollows)((0, Eo.default)(e.gastProductionsCache));
              e.resyncFollows = o;
            }), e.TRACE_INIT("ComputeLookaheadFunctions", function() {
              var o, a;
              (a = (o = e.lookaheadStrategy).initialize) === null || a === void 0 || a.call(o, { rules: (0, Eo.default)(e.gastProductionsCache) }), e.preComputeLookaheadFunctions((0, Eo.default)(e.gastProductionsCache));
            })), !t.DEFER_DEFINITION_ERRORS_HANDLING && !(0, p_.default)(e.definitionErrors))
              throw r = (0, Hoe.default)(e.definitionErrors, function(o) {
                return o.message;
              }), new Error(`Parser Definition Errors detected:
 `.concat(r.join(`
-------------------------------
`)));
          });
        }, t.DEFER_DEFINITION_ERRORS_HANDLING = false, t;
      }();
      Ge.Parser = xp;
      (0, nae.applyMixins)(xp, [zoe.Recoverable, Voe.LooksAhead, Yoe.TreeBuilder, Xoe.LexerAdapter, Qoe.RecognizerEngine, Joe.RecognizerApi, Zoe.ErrorHandler, eae.ContentAssist, tae.GastRecorder, rae.PerformanceTracer]);
      var sae = function(t) {
        LL(e, t);
        function e(r, n) {
          n === void 0 && (n = Ge.DEFAULT_PARSER_CONFIG);
          var i = (0, ML.default)(n);
          return i.outputCst = true, t.call(this, r, i) || this;
        }
        return e;
      }(xp);
      Ge.CstParser = sae;
      var uae = function(t) {
        LL(e, t);
        function e(r, n) {
          n === void 0 && (n = Ge.DEFAULT_PARSER_CONFIG);
          var i = (0, ML.default)(n);
          return i.outputCst = false, t.call(this, r, i) || this;
        }
        return e;
      }(xp);
      Ge.EmbeddedActionsParser = uae;
    });
    var jL = f((ko) => {
      var cae = ko && ko.__extends || function() {
        var t = function(e, r) {
          return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
            n.__proto__ = i;
          } || function(n, i) {
            for (var o in i)
              Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
          }, t(e, r);
        };
        return function(e, r) {
          if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
          t(e, r);
          function n() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
        };
      }(), au = ko && ko.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(ko, "__esModule", { value: true });
      ko.buildModel = void 0;
      var FL = vt(), Vc = au(jt()), lae = au(En()), dae = au(Qn()), fae = au(Hf()), pae = au(WT()), hae = au(Nc());
      function mae(t) {
        var e = new gae(), r = (0, dae.default)(t);
        return (0, Vc.default)(r, function(n) {
          return e.visitRule(n);
        });
      }
      ko.buildModel = mae;
      var gae = function(t) {
        cae(e, t);
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        return e.prototype.visitRule = function(r) {
          var n = this.visitEach(r.definition), i = (0, pae.default)(n, function(a) {
            return a.propertyName;
          }), o = (0, Vc.default)(i, function(a, s) {
            var u = !(0, fae.default)(a, function(l) {
              return !l.canBeNull;
            }), c = a[0].type;
            return a.length > 1 && (c = (0, Vc.default)(a, function(l) {
              return l.type;
            })), { name: s, type: c, optional: u };
          });
          return { name: r.name, properties: o };
        }, e.prototype.visitAlternative = function(r) {
          return this.visitEachAndOverrideWith(r.definition, { canBeNull: true });
        }, e.prototype.visitOption = function(r) {
          return this.visitEachAndOverrideWith(r.definition, { canBeNull: true });
        }, e.prototype.visitRepetition = function(r) {
          return this.visitEachAndOverrideWith(r.definition, { canBeNull: true });
        }, e.prototype.visitRepetitionMandatory = function(r) {
          return this.visitEach(r.definition);
        }, e.prototype.visitRepetitionMandatoryWithSeparator = function(r) {
          return this.visitEach(r.definition).concat({ propertyName: r.separator.name, canBeNull: true, type: qp(r.separator) });
        }, e.prototype.visitRepetitionWithSeparator = function(r) {
          return this.visitEachAndOverrideWith(r.definition, { canBeNull: true }).concat({ propertyName: r.separator.name, canBeNull: true, type: qp(r.separator) });
        }, e.prototype.visitAlternation = function(r) {
          return this.visitEachAndOverrideWith(r.definition, { canBeNull: true });
        }, e.prototype.visitTerminal = function(r) {
          return [{ propertyName: r.label || r.terminalType.name, canBeNull: false, type: qp(r) }];
        }, e.prototype.visitNonTerminal = function(r) {
          return [{ propertyName: r.label || r.nonTerminalName, canBeNull: false, type: qp(r) }];
        }, e.prototype.visitEachAndOverrideWith = function(r, n) {
          return (0, Vc.default)(this.visitEach(r), function(i) {
            return (0, hae.default)({}, i, n);
          });
        }, e.prototype.visitEach = function(r) {
          var n = this;
          return (0, lae.default)((0, Vc.default)(r, function(i) {
            return n.visit(i);
          }));
        }, e;
      }(FL.GAstVisitor);
      function qp(t) {
        return t instanceof FL.NonTerminal ? { kind: "rule", name: t.referencedRule.name } : { kind: "token" };
      }
    });
    var GL = f((Mve, UL) => {
      var yae = Mf();
      function vae(t, e, r) {
        var n = t.length;
        return r = r === void 0 ? n : r, !e && r >= n ? t : yae(t, e, r);
      }
      UL.exports = vae;
    });
    var h_ = f(($ve, HL) => {
      var Tae = "\\ud800-\\udfff", _ae = "\\u0300-\\u036f", Rae = "\\ufe20-\\ufe2f", bae = "\\u20d0-\\u20ff", Sae = _ae + Rae + bae, Aae = "\\ufe0e\\ufe0f", Pae = "\\u200d", Cae = RegExp("[" + Pae + Tae + Sae + Aae + "]");
      function Nae(t) {
        return Cae.test(t);
      }
      HL.exports = Nae;
    });
    var BL = f((Fve, WL) => {
      function Eae(t) {
        return t.split("");
      }
      WL.exports = Eae;
    });
    var ZL = f((jve, QL) => {
      var KL = "\\ud800-\\udfff", kae = "\\u0300-\\u036f", wae = "\\ufe20-\\ufe2f", Oae = "\\u20d0-\\u20ff", Dae = kae + wae + Oae, Iae = "\\ufe0e\\ufe0f", xae = "[" + KL + "]", m_ = "[" + Dae + "]", g_ = "\\ud83c[\\udffb-\\udfff]", qae = "(?:" + m_ + "|" + g_ + ")", zL = "[^" + KL + "]", VL = "(?:\\ud83c[\\udde6-\\uddff]){2}", YL = "[\\ud800-\\udbff][\\udc00-\\udfff]", Lae = "\\u200d", XL = qae + "?", JL = "[" + Iae + "]?", Mae = "(?:" + Lae + "(?:" + [zL, VL, YL].join("|") + ")" + JL + XL + ")*", $ae = JL + XL + Mae, Fae = "(?:" + [zL + m_ + "?", m_, VL, YL, xae].join("|") + ")", jae = RegExp(g_ + "(?=" + g_ + ")|" + Fae + $ae, "g");
      function Uae(t) {
        return t.match(jae) || [];
      }
      QL.exports = Uae;
    });
    var tM = f((Uve, eM) => {
      var Gae = BL(), Hae = h_(), Wae = ZL();
      function Bae(t) {
        return Hae(t) ? Wae(t) : Gae(t);
      }
      eM.exports = Bae;
    });
    var nM = f((Gve, rM) => {
      var Kae = GL(), zae = h_(), Vae = tM(), Yae = eT();
      function Xae(t) {
        return function(e) {
          e = Yae(e);
          var r = zae(e) ? Vae(e) : void 0, n = r ? r[0] : e.charAt(0), i = r ? Kae(r, 1).join("") : e.slice(1);
          return n[t]() + i;
        };
      }
      rM.exports = Xae;
    });
    var oM = f((Hve, iM) => {
      var Jae = nM(), Qae = Jae("toUpperCase");
      iM.exports = Qae;
    });
    var cM = f((su) => {
      var uu = su && su.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(su, "__esModule", { value: true });
      su.genDts = void 0;
      var Zae = uu(En()), ese = uu(qe()), Lp = uu(jt()), tse = uu(Li()), rse = uu(Yf()), sM = uu(oM());
      function nse(t, e) {
        var r = [];
        return r = r.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";'), r = r.concat((0, Zae.default)((0, Lp.default)(t, function(n) {
          return ise(n);
        }))), e.includeVisitorInterface && (r = r.concat(use(e.visitorInterfaceName, t))), r.join(`

`) + `
`;
      }
      su.genDts = nse;
      function ise(t) {
        var e = ose(t), r = ase(t);
        return [e, r];
      }
      function ose(t) {
        var e = uM(t.name), r = y_(t.name);
        return "export interface ".concat(e, ` extends CstNode {
  name: "`).concat(t.name, `";
  children: `).concat(r, `;
}`);
      }
      function ase(t) {
        var e = y_(t.name);
        return "export type ".concat(e, ` = {
  `).concat((0, Lp.default)(t.properties, function(r) {
          return sse(r);
        }).join(`
  `), `
};`);
      }
      function sse(t) {
        var e = lse(t.type);
        return "".concat(t.name).concat(t.optional ? "?" : "", ": ").concat(e, "[];");
      }
      function use(t, e) {
        return "export interface ".concat(t, `<IN, OUT> extends ICstVisitor<IN, OUT> {
  `).concat((0, Lp.default)(e, function(r) {
          return cse(r);
        }).join(`
  `), `
}`);
      }
      function cse(t) {
        var e = y_(t.name);
        return "".concat(t.name, "(children: ").concat(e, ", param?: IN): OUT;");
      }
      function lse(t) {
        if ((0, ese.default)(t)) {
          var e = (0, rse.default)((0, Lp.default)(t, function(n) {
            return aM(n);
          })), r = (0, tse.default)(e, function(n, i) {
            return n + " | " + i;
          });
          return "(" + r + ")";
        } else
          return aM(t);
      }
      function aM(t) {
        return t.kind === "token" ? "IToken" : uM(t.name);
      }
      function uM(t) {
        return (0, sM.default)(t) + "CstNode";
      }
      function y_(t) {
        return (0, sM.default)(t) + "CstChildren";
      }
    });
    var lM = f((cu) => {
      var Mp = cu && cu.__assign || function() {
        return Mp = Object.assign || function(t) {
          for (var e, r = 1, n = arguments.length; r < n; r++) {
            e = arguments[r];
            for (var i in e)
              Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
          }
          return t;
        }, Mp.apply(this, arguments);
      };
      Object.defineProperty(cu, "__esModule", { value: true });
      cu.generateCstDts = void 0;
      var dse = jL(), fse = cM(), pse = { includeVisitorInterface: true, visitorInterfaceName: "ICstNodeVisitor" };
      function hse(t, e) {
        var r = Mp(Mp({}, pse), e), n = (0, dse.buildModel)(t);
        return (0, fse.genDts)(n, r);
      }
      cu.generateCstDts = hse;
    });
    var fM = f(($p) => {
      Object.defineProperty($p, "__esModule", { value: true });
      $p.createSyntaxDiagramsCode = void 0;
      var dM = Ev();
      function mse(t, e) {
        var r = e === void 0 ? {} : e, n = r.resourceBase, i = n === void 0 ? "https://unpkg.com/chevrotain@".concat(dM.VERSION, "/diagrams/") : n, o = r.css, a = o === void 0 ? "https://unpkg.com/chevrotain@".concat(dM.VERSION, "/diagrams/diagrams.css") : o, s = `
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>

`, u = `
<link rel='stylesheet' href='`.concat(a, `'>
`), c = `
<script src='`.concat(i, `vendor/railroad-diagrams.js'><\/script>
<script src='`).concat(i, `src/diagrams_builder.js'><\/script>
<script src='`).concat(i, `src/diagrams_behavior.js'><\/script>
<script src='`).concat(i, `src/main.js'><\/script>
`), l = `
<div id="diagrams" align="center"></div>    
`, d = `
<script>
    window.serializedGrammar = `.concat(JSON.stringify(t, null, "  "), `;
<\/script>
`), h = `
<script>
    var diagramsDiv = document.getElementById("diagrams");
    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);
<\/script>
`;
        return s + u + c + l + d + h;
      }
      $p.createSyntaxDiagramsCode = mse;
    });
    var Ra = f((U) => {
      Object.defineProperty(U, "__esModule", { value: true });
      U.Parser = U.createSyntaxDiagramsCode = U.clearCache = U.generateCstDts = U.GAstVisitor = U.serializeProduction = U.serializeGrammar = U.Terminal = U.Rule = U.RepetitionWithSeparator = U.RepetitionMandatoryWithSeparator = U.RepetitionMandatory = U.Repetition = U.Option = U.NonTerminal = U.Alternative = U.Alternation = U.defaultLexerErrorProvider = U.NoViableAltException = U.NotAllInputParsedException = U.MismatchedTokenException = U.isRecognitionException = U.EarlyExitException = U.defaultParserErrorProvider = U.LLkLookaheadStrategy = U.getLookaheadPaths = U.tokenName = U.tokenMatcher = U.tokenLabel = U.EOF = U.createTokenInstance = U.createToken = U.LexerDefinitionErrorType = U.Lexer = U.EMPTY_ALT = U.ParserDefinitionErrorType = U.EmbeddedActionsParser = U.CstParser = U.VERSION = void 0;
      var gse = Ev();
      Object.defineProperty(U, "VERSION", { enumerable: true, get: function() {
        return gse.VERSION;
      } });
      var Fp = br();
      Object.defineProperty(U, "CstParser", { enumerable: true, get: function() {
        return Fp.CstParser;
      } });
      Object.defineProperty(U, "EmbeddedActionsParser", { enumerable: true, get: function() {
        return Fp.EmbeddedActionsParser;
      } });
      Object.defineProperty(U, "ParserDefinitionErrorType", { enumerable: true, get: function() {
        return Fp.ParserDefinitionErrorType;
      } });
      Object.defineProperty(U, "EMPTY_ALT", { enumerable: true, get: function() {
        return Fp.EMPTY_ALT;
      } });
      var pM = Dc();
      Object.defineProperty(U, "Lexer", { enumerable: true, get: function() {
        return pM.Lexer;
      } });
      Object.defineProperty(U, "LexerDefinitionErrorType", { enumerable: true, get: function() {
        return pM.LexerDefinitionErrorType;
      } });
      var lu = pa();
      Object.defineProperty(U, "createToken", { enumerable: true, get: function() {
        return lu.createToken;
      } });
      Object.defineProperty(U, "createTokenInstance", { enumerable: true, get: function() {
        return lu.createTokenInstance;
      } });
      Object.defineProperty(U, "EOF", { enumerable: true, get: function() {
        return lu.EOF;
      } });
      Object.defineProperty(U, "tokenLabel", { enumerable: true, get: function() {
        return lu.tokenLabel;
      } });
      Object.defineProperty(U, "tokenMatcher", { enumerable: true, get: function() {
        return lu.tokenMatcher;
      } });
      Object.defineProperty(U, "tokenName", { enumerable: true, get: function() {
        return lu.tokenName;
      } });
      var yse = Bs();
      Object.defineProperty(U, "getLookaheadPaths", { enumerable: true, get: function() {
        return yse.getLookaheadPaths;
      } });
      var vse = s_();
      Object.defineProperty(U, "LLkLookaheadStrategy", { enumerable: true, get: function() {
        return vse.LLkLookaheadStrategy;
      } });
      var Tse = Ws();
      Object.defineProperty(U, "defaultParserErrorProvider", { enumerable: true, get: function() {
        return Tse.defaultParserErrorProvider;
      } });
      var Yc = zs();
      Object.defineProperty(U, "EarlyExitException", { enumerable: true, get: function() {
        return Yc.EarlyExitException;
      } });
      Object.defineProperty(U, "isRecognitionException", { enumerable: true, get: function() {
        return Yc.isRecognitionException;
      } });
      Object.defineProperty(U, "MismatchedTokenException", { enumerable: true, get: function() {
        return Yc.MismatchedTokenException;
      } });
      Object.defineProperty(U, "NotAllInputParsedException", { enumerable: true, get: function() {
        return Yc.NotAllInputParsedException;
      } });
      Object.defineProperty(U, "NoViableAltException", { enumerable: true, get: function() {
        return Yc.NoViableAltException;
      } });
      var _se = qT();
      Object.defineProperty(U, "defaultLexerErrorProvider", { enumerable: true, get: function() {
        return _se.defaultLexerErrorProvider;
      } });
      var di = vt();
      Object.defineProperty(U, "Alternation", { enumerable: true, get: function() {
        return di.Alternation;
      } });
      Object.defineProperty(U, "Alternative", { enumerable: true, get: function() {
        return di.Alternative;
      } });
      Object.defineProperty(U, "NonTerminal", { enumerable: true, get: function() {
        return di.NonTerminal;
      } });
      Object.defineProperty(U, "Option", { enumerable: true, get: function() {
        return di.Option;
      } });
      Object.defineProperty(U, "Repetition", { enumerable: true, get: function() {
        return di.Repetition;
      } });
      Object.defineProperty(U, "RepetitionMandatory", { enumerable: true, get: function() {
        return di.RepetitionMandatory;
      } });
      Object.defineProperty(U, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
        return di.RepetitionMandatoryWithSeparator;
      } });
      Object.defineProperty(U, "RepetitionWithSeparator", { enumerable: true, get: function() {
        return di.RepetitionWithSeparator;
      } });
      Object.defineProperty(U, "Rule", { enumerable: true, get: function() {
        return di.Rule;
      } });
      Object.defineProperty(U, "Terminal", { enumerable: true, get: function() {
        return di.Terminal;
      } });
      var v_ = vt();
      Object.defineProperty(U, "serializeGrammar", { enumerable: true, get: function() {
        return v_.serializeGrammar;
      } });
      Object.defineProperty(U, "serializeProduction", { enumerable: true, get: function() {
        return v_.serializeProduction;
      } });
      Object.defineProperty(U, "GAstVisitor", { enumerable: true, get: function() {
        return v_.GAstVisitor;
      } });
      var Rse = lM();
      Object.defineProperty(U, "generateCstDts", { enumerable: true, get: function() {
        return Rse.generateCstDts;
      } });
      function bse() {
        console.warn(`The clearCache function was 'soft' removed from the Chevrotain API.
	 It performs no action other than printing this message.
	 Please avoid using it as it will be completely removed in the future`);
      }
      U.clearCache = bse;
      var Sse = fM();
      Object.defineProperty(U, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
        return Sse.createSyntaxDiagramsCode;
      } });
      var Ase = function() {
        function t() {
          throw new Error(`The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	
See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0`);
        }
        return t;
      }();
      U.Parser = Ase;
    });
    var TM = f((V) => {
      var hM = V && V.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(V, "__esModule", { value: true });
      V.createATN = V.RuleTransition = V.EpsilonTransition = V.AtomTransition = V.AbstractTransition = V.ATN_LOOP_END = V.ATN_PLUS_LOOP_BACK = V.ATN_STAR_LOOP_ENTRY = V.ATN_STAR_LOOP_BACK = V.ATN_BLOCK_END = V.ATN_RULE_STOP = V.ATN_TOKEN_START = V.ATN_STAR_BLOCK_START = V.ATN_PLUS_BLOCK_START = V.ATN_RULE_START = V.ATN_BASIC = V.ATN_INVALID_TYPE = V.buildATNKey = void 0;
      var mM = hM(jt()), Pse = hM(Oc()), Sr = Ra();
      function Jc(t, e, r) {
        return `${t.name}_${e}_${r}`;
      }
      V.buildATNKey = Jc;
      V.ATN_INVALID_TYPE = 0;
      V.ATN_BASIC = 1;
      V.ATN_RULE_START = 2;
      V.ATN_PLUS_BLOCK_START = 4;
      V.ATN_STAR_BLOCK_START = 5;
      V.ATN_TOKEN_START = 6;
      V.ATN_RULE_STOP = 7;
      V.ATN_BLOCK_END = 8;
      V.ATN_STAR_LOOP_BACK = 9;
      V.ATN_STAR_LOOP_ENTRY = 10;
      V.ATN_PLUS_LOOP_BACK = 11;
      V.ATN_LOOP_END = 12;
      var du = class {
        constructor(e) {
          this.target = e;
        }
        isEpsilon() {
          return false;
        }
      };
      V.AbstractTransition = du;
      var jp = class extends du {
        constructor(e, r) {
          super(e), this.tokenType = r;
        }
      };
      V.AtomTransition = jp;
      var Up = class extends du {
        constructor(e) {
          super(e);
        }
        isEpsilon() {
          return true;
        }
      };
      V.EpsilonTransition = Up;
      var Xc = class extends du {
        constructor(e, r, n) {
          super(e), this.rule = r, this.followState = n;
        }
        isEpsilon() {
          return true;
        }
      };
      V.RuleTransition = Xc;
      function Cse(t) {
        let e = { decisionMap: {}, decisionStates: [], ruleToStartState: /* @__PURE__ */ new Map(), ruleToStopState: /* @__PURE__ */ new Map(), states: [] };
        Nse(e, t);
        let r = t.length;
        for (let n = 0; n < r; n++) {
          let i = t[n], o = ba(e, i, i);
          o !== void 0 && $se(e, i, o);
        }
        return e;
      }
      V.createATN = Cse;
      function Nse(t, e) {
        let r = e.length;
        for (let n = 0; n < r; n++) {
          let i = e[n], o = Ht(t, i, void 0, { type: V.ATN_RULE_START }), a = Ht(t, i, void 0, { type: V.ATN_RULE_STOP });
          o.stop = a, t.ruleToStartState.set(i, o), t.ruleToStopState.set(i, a);
        }
      }
      function gM(t, e, r) {
        return r instanceof Sr.Terminal ? T_(t, e, r.terminalType, r) : r instanceof Sr.NonTerminal ? Mse(t, e, r) : r instanceof Sr.Alternation ? Dse(t, e, r) : r instanceof Sr.Option ? Ise(t, e, r) : r instanceof Sr.Repetition ? Ese(t, e, r) : r instanceof Sr.RepetitionWithSeparator ? kse(t, e, r) : r instanceof Sr.RepetitionMandatory ? wse(t, e, r) : r instanceof Sr.RepetitionMandatoryWithSeparator ? Ose(t, e, r) : ba(t, e, r);
      }
      function Ese(t, e, r) {
        let n = Ht(t, e, r, { type: V.ATN_STAR_BLOCK_START });
        wo(t, n);
        let i = fu(t, e, n, r, ba(t, e, r));
        return vM(t, e, r, i);
      }
      function kse(t, e, r) {
        let n = Ht(t, e, r, { type: V.ATN_STAR_BLOCK_START });
        wo(t, n);
        let i = fu(t, e, n, r, ba(t, e, r)), o = T_(t, e, r.separator, r);
        return vM(t, e, r, i, o);
      }
      function wse(t, e, r) {
        let n = Ht(t, e, r, { type: V.ATN_PLUS_BLOCK_START });
        wo(t, n);
        let i = fu(t, e, n, r, ba(t, e, r));
        return yM(t, e, r, i);
      }
      function Ose(t, e, r) {
        let n = Ht(t, e, r, { type: V.ATN_PLUS_BLOCK_START });
        wo(t, n);
        let i = fu(t, e, n, r, ba(t, e, r)), o = T_(t, e, r.separator, r);
        return yM(t, e, r, i, o);
      }
      function Dse(t, e, r) {
        let n = Ht(t, e, r, { type: V.ATN_BASIC });
        wo(t, n);
        let i = (0, mM.default)(r.definition, (a) => gM(t, e, a));
        return fu(t, e, n, r, ...i);
      }
      function Ise(t, e, r) {
        let n = Ht(t, e, r, { type: V.ATN_BASIC });
        wo(t, n);
        let i = fu(t, e, n, r, ba(t, e, r));
        return xse(t, e, r, i);
      }
      function ba(t, e, r) {
        let n = (0, Pse.default)((0, mM.default)(r.definition, (i) => gM(t, e, i)), (i) => i !== void 0);
        return n.length === 1 ? n[0] : n.length === 0 ? void 0 : Lse(t, n);
      }
      function yM(t, e, r, n, i) {
        let o = n.left, a = n.right, s = Ht(t, e, r, { type: V.ATN_PLUS_LOOP_BACK });
        wo(t, s);
        let u = Ht(t, e, r, { type: V.ATN_LOOP_END });
        return o.loopback = s, u.loopback = s, t.decisionMap[Jc(e, i ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", r.idx)] = s, kt(a, s), i === void 0 ? (kt(s, o), kt(s, u)) : (kt(s, u), kt(s, i.left), kt(i.right, o)), { left: o, right: u };
      }
      function vM(t, e, r, n, i) {
        let o = n.left, a = n.right, s = Ht(t, e, r, { type: V.ATN_STAR_LOOP_ENTRY });
        wo(t, s);
        let u = Ht(t, e, r, { type: V.ATN_LOOP_END }), c = Ht(t, e, r, { type: V.ATN_STAR_LOOP_BACK });
        return s.loopback = c, u.loopback = c, kt(s, o), kt(s, u), kt(a, c), i !== void 0 ? (kt(c, u), kt(c, i.left), kt(i.right, o)) : kt(c, s), t.decisionMap[Jc(e, i ? "RepetitionWithSeparator" : "Repetition", r.idx)] = s, { left: s, right: u };
      }
      function xse(t, e, r, n) {
        let i = n.left, o = n.right;
        return kt(i, o), t.decisionMap[Jc(e, "Option", r.idx)] = i, n;
      }
      function wo(t, e) {
        return t.decisionStates.push(e), e.decision = t.decisionStates.length - 1, e.decision;
      }
      function fu(t, e, r, n, ...i) {
        let o = Ht(t, e, n, { type: V.ATN_BLOCK_END, start: r });
        r.end = o;
        for (let s of i)
          s !== void 0 ? (kt(r, s.left), kt(s.right, o)) : kt(r, o);
        let a = { left: r, right: o };
        return t.decisionMap[Jc(e, qse(n), n.idx)] = r, a;
      }
      function qse(t) {
        if (t instanceof Sr.Alternation)
          return "Alternation";
        if (t instanceof Sr.Option)
          return "Option";
        if (t instanceof Sr.Repetition)
          return "Repetition";
        if (t instanceof Sr.RepetitionWithSeparator)
          return "RepetitionWithSeparator";
        if (t instanceof Sr.RepetitionMandatory)
          return "RepetitionMandatory";
        if (t instanceof Sr.RepetitionMandatoryWithSeparator)
          return "RepetitionMandatoryWithSeparator";
        throw new Error("Invalid production type encountered");
      }
      function Lse(t, e) {
        let r = e.length;
        for (let o = 0; o < r - 1; o++) {
          let a = e[o], s;
          a.left.transitions.length === 1 && (s = a.left.transitions[0]);
          let u = s instanceof Xc, c = s, l = e[o + 1].left;
          a.left.type === V.ATN_BASIC && a.right.type === V.ATN_BASIC && s !== void 0 && (u && c.followState === a.right || s.target === a.right) ? (u ? c.followState = l : s.target = l, Fse(t, a.right)) : kt(a.right, l);
        }
        let n = e[0], i = e[r - 1];
        return { left: n.left, right: i.right };
      }
      function T_(t, e, r, n) {
        let i = Ht(t, e, n, { type: V.ATN_BASIC }), o = Ht(t, e, n, { type: V.ATN_BASIC });
        return __(i, new jp(o, r)), { left: i, right: o };
      }
      function Mse(t, e, r) {
        let n = r.referencedRule, i = t.ruleToStartState.get(n), o = Ht(t, e, r, { type: V.ATN_BASIC }), a = Ht(t, e, r, { type: V.ATN_BASIC }), s = new Xc(i, n, a);
        return __(o, s), { left: o, right: a };
      }
      function $se(t, e, r) {
        let n = t.ruleToStartState.get(e);
        kt(n, r.left);
        let i = t.ruleToStopState.get(e);
        return kt(r.right, i), { left: n, right: i };
      }
      function kt(t, e) {
        let r = new Up(e);
        __(t, r);
      }
      function Ht(t, e, r, n) {
        let i = Object.assign({ atn: t, production: r, epsilonOnlyTransitions: false, rule: e, transitions: [], nextTokenWithinRule: [], stateNumber: t.states.length }, n);
        return t.states.push(i), i;
      }
      function __(t, e) {
        t.transitions.length === 0 && (t.epsilonOnlyTransitions = e.isEpsilon()), t.transitions.push(e);
      }
      function Fse(t, e) {
        t.states.splice(t.states.indexOf(e), 1);
      }
    });
    var RM = f((fi) => {
      var jse = fi && fi.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(fi, "__esModule", { value: true });
      fi.getATNConfigKey = fi.ATNConfigSet = fi.DFA_ERROR = void 0;
      var Use = jse(jt());
      fi.DFA_ERROR = {};
      var R_ = class {
        constructor() {
          this.map = {}, this.configs = [];
        }
        get size() {
          return this.configs.length;
        }
        finalize() {
          this.map = {};
        }
        add(e) {
          let r = _M(e);
          r in this.map || (this.map[r] = this.configs.length, this.configs.push(e));
        }
        get elements() {
          return this.configs;
        }
        get alts() {
          return (0, Use.default)(this.configs, (e) => e.alt);
        }
        get key() {
          let e = "";
          for (let r in this.map)
            e += r + ":";
          return e;
        }
      };
      fi.ATNConfigSet = R_;
      function _M(t, e = true) {
        return `${e ? `a${t.alt}` : ""}s${t.state.stateNumber}:${t.stack.map((r) => r.stateNumber.toString()).join("_")}`;
      }
      fi.getATNConfigKey = _M;
    });
    var SM = f((Xve, bM) => {
      var Gse = ws();
      function Hse(t, e, r) {
        for (var n = -1, i = t.length; ++n < i; ) {
          var o = t[n], a = e(o);
          if (a != null && (s === void 0 ? a === a && !Gse(a) : r(a, s)))
            var s = a, u = o;
        }
        return u;
      }
      bM.exports = Hse;
    });
    var PM = f((Jve, AM) => {
      function Wse(t, e) {
        return t < e;
      }
      AM.exports = Wse;
    });
    var NM = f((Qve, CM) => {
      var Bse = SM(), Kse = PM(), zse = ua();
      function Vse(t) {
        return t && t.length ? Bse(t, zse, Kse) : void 0;
      }
      CM.exports = Vse;
    });
    var kM = f((Zve, EM) => {
      var Yse = Jr(), Xse = gT();
      function Jse(t, e) {
        return t && t.length ? Xse(t, Yse(e, 2)) : [];
      }
      EM.exports = Jse;
    });
    var LM = f((pu) => {
      var Do = pu && pu.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(pu, "__esModule", { value: true });
      pu.LLStarLookaheadStrategy = void 0;
      var Lr = Ra(), Dn = TM(), Oo = RM(), Qse = Do(NM()), Zse = Do(pp()), eue = Do(kM()), Qc = Do(jt()), tue = Do(En()), b_ = Do(Ut()), rue = Do(Or()), wM = Do(Li());
      function nue(t, e) {
        let r = {};
        return (n) => {
          let i = n.toString(), o = r[i];
          return o !== void 0 || (o = { atnStartState: t, decision: e, states: {} }, r[i] = o), o;
        };
      }
      var Gp = class {
        constructor() {
          this.predicates = [];
        }
        is(e) {
          return e >= this.predicates.length || this.predicates[e];
        }
        set(e, r) {
          this.predicates[e] = r;
        }
        toString() {
          let e = "", r = this.predicates.length;
          for (let n = 0; n < r; n++)
            e += this.predicates[n] === true ? "1" : "0";
          return e;
        }
      }, OM = new Gp(), A_ = class extends Lr.LLkLookaheadStrategy {
        constructor(e) {
          var r;
          super(), this.logging = (r = e == null ? void 0 : e.logging) !== null && r !== void 0 ? r : (n) => console.log(n);
        }
        initialize(e) {
          this.atn = (0, Dn.createATN)(e.rules), this.dfas = iue(this.atn);
        }
        validateAmbiguousAlternationAlternatives() {
          return [];
        }
        validateEmptyOrAlternatives() {
          return [];
        }
        buildLookaheadForAlternation(e) {
          let { prodOccurrence: r, rule: n, hasPredicates: i, dynamicTokensEnabled: o } = e, a = this.dfas, s = this.logging, u = (0, Dn.buildATNKey)(n, "Alternation", r), l = this.atn.decisionMap[u].decision, d = (0, Qc.default)((0, Lr.getLookaheadPaths)({ maxLookahead: 1, occurrence: r, prodType: "Alternation", rule: n }), (h) => (0, Qc.default)(h, (y) => y[0]));
          if (DM(d, false) && !o) {
            let h = (0, wM.default)(d, (y, m, R) => ((0, b_.default)(m, (C) => {
              C && (y[C.tokenTypeIdx] = R, (0, b_.default)(C.categoryMatches, (N) => {
                y[N] = R;
              }));
            }), y), {});
            return i ? function(y) {
              var m;
              let R = this.LA(1), C = h[R.tokenTypeIdx];
              if (y !== void 0 && C !== void 0) {
                let N = (m = y[C]) === null || m === void 0 ? void 0 : m.GATE;
                if (N !== void 0 && N.call(this) === false)
                  return;
              }
              return C;
            } : function() {
              let y = this.LA(1);
              return h[y.tokenTypeIdx];
            };
          } else
            return i ? function(h) {
              let y = new Gp(), m = h === void 0 ? 0 : h.length;
              for (let C = 0; C < m; C++) {
                let N = h == null ? void 0 : h[C].GATE;
                y.set(C, N === void 0 || N.call(this));
              }
              let R = S_.call(this, a, l, y, s);
              return typeof R == "number" ? R : void 0;
            } : function() {
              let h = S_.call(this, a, l, OM, s);
              return typeof h == "number" ? h : void 0;
            };
        }
        buildLookaheadForOptional(e) {
          let { prodOccurrence: r, rule: n, prodType: i, dynamicTokensEnabled: o } = e, a = this.dfas, s = this.logging, u = (0, Dn.buildATNKey)(n, i, r), l = this.atn.decisionMap[u].decision, d = (0, Qc.default)((0, Lr.getLookaheadPaths)({ maxLookahead: 1, occurrence: r, prodType: i, rule: n }), (h) => (0, Qc.default)(h, (y) => y[0]));
          if (DM(d) && d[0][0] && !o) {
            let h = d[0], y = (0, tue.default)(h);
            if (y.length === 1 && (0, rue.default)(y[0].categoryMatches)) {
              let R = y[0].tokenTypeIdx;
              return function() {
                return this.LA(1).tokenTypeIdx === R;
              };
            } else {
              let m = (0, wM.default)(y, (R, C) => (C !== void 0 && (R[C.tokenTypeIdx] = true, (0, b_.default)(C.categoryMatches, (N) => {
                R[N] = true;
              })), R), {});
              return function() {
                let R = this.LA(1);
                return m[R.tokenTypeIdx] === true;
              };
            }
          }
          return function() {
            let h = S_.call(this, a, l, OM, s);
            return typeof h == "object" ? false : h === 0;
          };
        }
      };
      pu.LLStarLookaheadStrategy = A_;
      function DM(t, e = true) {
        let r = /* @__PURE__ */ new Set();
        for (let n of t) {
          let i = /* @__PURE__ */ new Set();
          for (let o of n) {
            if (o === void 0) {
              if (e)
                break;
              return false;
            }
            let a = [o.tokenTypeIdx].concat(o.categoryMatches);
            for (let s of a)
              if (r.has(s)) {
                if (!i.has(s))
                  return false;
              } else
                r.add(s), i.add(s);
          }
        }
        return true;
      }
      function iue(t) {
        let e = t.decisionStates.length, r = Array(e);
        for (let n = 0; n < e; n++)
          r[n] = nue(t.decisionStates[n], n);
        return r;
      }
      function S_(t, e, r, n) {
        let i = t[e](r), o = i.start;
        if (o === void 0) {
          let s = mue(i.atnStartState);
          o = qM(i, xM(s)), i.start = o;
        }
        return oue.apply(this, [i, o, r, n]);
      }
      function oue(t, e, r, n) {
        let i = e, o = 1, a = [], s = this.LA(o++);
        for (; ; ) {
          let u = due(i, s);
          if (u === void 0 && (u = aue.apply(this, [t, i, s, o, r, n])), u === Oo.DFA_ERROR)
            return lue(a, i, s);
          if (u.isAcceptState === true)
            return u.prediction;
          i = u, a.push(s), s = this.LA(o++);
        }
      }
      function aue(t, e, r, n, i, o) {
        let a = fue(e.configs, r, i);
        if (a.size === 0)
          return IM(t, e, r, Oo.DFA_ERROR), Oo.DFA_ERROR;
        let s = xM(a), u = hue(a, i);
        if (u !== void 0)
          s.isAcceptState = true, s.prediction = u, s.configs.uniqueAlt = u;
        else if (Tue(a)) {
          let c = (0, Qse.default)(a.alts);
          s.isAcceptState = true, s.prediction = c, s.configs.uniqueAlt = c, sue.apply(this, [t, n, a.alts, o]);
        }
        return s = IM(t, e, r, s), s;
      }
      function sue(t, e, r, n) {
        let i = [];
        for (let c = 1; c <= e; c++)
          i.push(this.LA(c).tokenType);
        let o = t.atnStartState, a = o.rule, s = o.production, u = uue({ topLevelRule: a, ambiguityIndices: r, production: s, prefixPath: i });
        n(u);
      }
      function uue(t) {
        let e = (0, Qc.default)(t.prefixPath, (i) => (0, Lr.tokenLabel)(i)).join(", "), r = t.production.idx === 0 ? "" : t.production.idx, n = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(", ")}> in <${cue(t.production)}${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
        return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
      }
      function cue(t) {
        if (t instanceof Lr.NonTerminal)
          return "SUBRULE";
        if (t instanceof Lr.Option)
          return "OPTION";
        if (t instanceof Lr.Alternation)
          return "OR";
        if (t instanceof Lr.RepetitionMandatory)
          return "AT_LEAST_ONE";
        if (t instanceof Lr.RepetitionMandatoryWithSeparator)
          return "AT_LEAST_ONE_SEP";
        if (t instanceof Lr.RepetitionWithSeparator)
          return "MANY_SEP";
        if (t instanceof Lr.Repetition)
          return "MANY";
        if (t instanceof Lr.Terminal)
          return "CONSUME";
        throw Error("non exhaustive match");
      }
      function lue(t, e, r) {
        let n = (0, Zse.default)(e.configs.elements, (o) => o.state.transitions), i = (0, eue.default)(n.filter((o) => o instanceof Dn.AtomTransition).map((o) => o.tokenType), (o) => o.tokenTypeIdx);
        return { actualToken: r, possibleTokenTypes: i, tokenPath: t };
      }
      function due(t, e) {
        return t.edges[e.tokenTypeIdx];
      }
      function fue(t, e, r) {
        let n = new Oo.ATNConfigSet(), i = [];
        for (let a of t.elements) {
          if (r.is(a.alt) === false)
            continue;
          if (a.state.type === Dn.ATN_RULE_STOP) {
            i.push(a);
            continue;
          }
          let s = a.state.transitions.length;
          for (let u = 0; u < s; u++) {
            let c = a.state.transitions[u], l = pue(c, e);
            l !== void 0 && n.add({ state: l, alt: a.alt, stack: a.stack });
          }
        }
        let o;
        if (i.length === 0 && n.size === 1 && (o = n), o === void 0) {
          o = new Oo.ATNConfigSet();
          for (let a of n.elements)
            Hp(a, o);
        }
        if (i.length > 0 && !yue(o))
          for (let a of i)
            o.add(a);
        return o;
      }
      function pue(t, e) {
        if (t instanceof Dn.AtomTransition && (0, Lr.tokenMatcher)(e, t.tokenType))
          return t.target;
      }
      function hue(t, e) {
        let r;
        for (let n of t.elements)
          if (e.is(n.alt) === true) {
            if (r === void 0)
              r = n.alt;
            else if (r !== n.alt)
              return;
          }
        return r;
      }
      function xM(t) {
        return { configs: t, edges: {}, isAcceptState: false, prediction: -1 };
      }
      function IM(t, e, r, n) {
        return n = qM(t, n), e.edges[r.tokenTypeIdx] = n, n;
      }
      function qM(t, e) {
        if (e === Oo.DFA_ERROR)
          return e;
        let r = e.configs.key, n = t.states[r];
        return n !== void 0 ? n : (e.configs.finalize(), t.states[r] = e, e);
      }
      function mue(t) {
        let e = new Oo.ATNConfigSet(), r = t.transitions.length;
        for (let n = 0; n < r; n++) {
          let o = { state: t.transitions[n].target, alt: n, stack: [] };
          Hp(o, e);
        }
        return e;
      }
      function Hp(t, e) {
        let r = t.state;
        if (r.type === Dn.ATN_RULE_STOP) {
          if (t.stack.length > 0) {
            let i = [...t.stack], a = { state: i.pop(), alt: t.alt, stack: i };
            Hp(a, e);
          } else
            e.add(t);
          return;
        }
        r.epsilonOnlyTransitions || e.add(t);
        let n = r.transitions.length;
        for (let i = 0; i < n; i++) {
          let o = r.transitions[i], a = gue(t, o);
          a !== void 0 && Hp(a, e);
        }
      }
      function gue(t, e) {
        if (e instanceof Dn.EpsilonTransition)
          return { state: e.target, alt: t.alt, stack: t.stack };
        if (e instanceof Dn.RuleTransition) {
          let r = [...t.stack, e.followState];
          return { state: e.target, alt: t.alt, stack: r };
        }
      }
      function yue(t) {
        for (let e of t.elements)
          if (e.state.type === Dn.ATN_RULE_STOP)
            return true;
        return false;
      }
      function vue(t) {
        for (let e of t.elements)
          if (e.state.type !== Dn.ATN_RULE_STOP)
            return false;
        return true;
      }
      function Tue(t) {
        if (vue(t))
          return true;
        let e = _ue(t.elements);
        return Rue(e) && !bue(e);
      }
      function _ue(t) {
        let e = /* @__PURE__ */ new Map();
        for (let r of t) {
          let n = (0, Oo.getATNConfigKey)(r, false), i = e.get(n);
          i === void 0 && (i = {}, e.set(n, i)), i[r.alt] = true;
        }
        return e;
      }
      function Rue(t) {
        for (let e of Array.from(t.values()))
          if (Object.keys(e).length > 1)
            return true;
        return false;
      }
      function bue(t) {
        for (let e of Array.from(t.values()))
          if (Object.keys(e).length === 1)
            return true;
        return false;
      }
    });
    var MM = f((Wp) => {
      Object.defineProperty(Wp, "__esModule", { value: true });
      Wp.LLStarLookaheadStrategy = void 0;
      var Sue = LM();
      Object.defineProperty(Wp, "LLStarLookaheadStrategy", { enumerable: true, get: function() {
        return Sue.LLStarLookaheadStrategy;
      } });
    });
    var C_ = f((tn) => {
      Object.defineProperty(tn, "__esModule", { value: true });
      tn.RootCstNodeImpl = tn.CompositeCstNodeImpl = tn.LeafCstNodeImpl = tn.AbstractCstNode = tn.CstNodeBuilder = void 0;
      var $M = $a(), Aue = Zt(), FM = Le(), P_ = class {
        constructor() {
          this.nodeStack = [];
        }
        get current() {
          return this.nodeStack[this.nodeStack.length - 1];
        }
        buildRootNode(e) {
          return this.rootNode = new Bp(e), this.nodeStack = [this.rootNode], this.rootNode;
        }
        buildCompositeNode(e) {
          let r = new tl();
          return r.feature = e, r.root = this.rootNode, this.current.children.push(r), this.nodeStack.push(r), r;
        }
        buildLeafNode(e, r) {
          let n = new el(e.startOffset, e.image.length, (0, FM.tokenToRange)(e), e.tokenType, false);
          return n.feature = r, n.root = this.rootNode, this.current.children.push(n), n;
        }
        removeNode(e) {
          let r = e.parent;
          if (r) {
            let n = r.children.indexOf(e);
            n >= 0 && r.children.splice(n, 1);
          }
        }
        construct(e) {
          let r = this.current;
          typeof e.$type == "string" && (this.current.element = e), e.$cstNode = r;
          let n = this.nodeStack.pop();
          (n == null ? void 0 : n.children.length) === 0 && this.removeNode(n);
        }
        addHiddenTokens(e) {
          for (let r of e) {
            let n = new el(r.startOffset, r.image.length, (0, FM.tokenToRange)(r), r.tokenType, true);
            n.root = this.rootNode, this.addHiddenToken(this.rootNode, n);
          }
        }
        addHiddenToken(e, r) {
          let { offset: n, end: i } = r;
          for (let o = 0; o < e.children.length; o++) {
            let a = e.children[o], { offset: s, end: u } = a;
            if ((0, Aue.isCompositeCstNode)(a) && n > s && i < u) {
              this.addHiddenToken(a, r);
              return;
            } else if (i <= s) {
              e.children.splice(o, 0, r);
              return;
            }
          }
          e.children.push(r);
        }
      };
      tn.CstNodeBuilder = P_;
      var Zc = class {
        get hidden() {
          return false;
        }
        get element() {
          var e, r;
          let n = typeof ((e = this._element) === null || e === void 0 ? void 0 : e.$type) == "string" ? this._element : (r = this.parent) === null || r === void 0 ? void 0 : r.element;
          if (!n)
            throw new Error("This node has no associated AST element");
          return n;
        }
        set element(e) {
          this._element = e;
        }
        get text() {
          return this.root.fullText.substring(this.offset, this.end);
        }
      };
      tn.AbstractCstNode = Zc;
      var el = class extends Zc {
        get offset() {
          return this._offset;
        }
        get length() {
          return this._length;
        }
        get end() {
          return this._offset + this._length;
        }
        get hidden() {
          return this._hidden;
        }
        get tokenType() {
          return this._tokenType;
        }
        get range() {
          return this._range;
        }
        constructor(e, r, n, i, o = false) {
          super(), this._hidden = o, this._offset = e, this._tokenType = i, this._length = r, this._range = n;
        }
      };
      tn.LeafCstNodeImpl = el;
      var tl = class extends Zc {
        constructor() {
          super(...arguments), this.children = new rl(this);
        }
        get offset() {
          var e, r;
          return (r = (e = this.firstNonHiddenNode) === null || e === void 0 ? void 0 : e.offset) !== null && r !== void 0 ? r : 0;
        }
        get length() {
          return this.end - this.offset;
        }
        get end() {
          var e, r;
          return (r = (e = this.lastNonHiddenNode) === null || e === void 0 ? void 0 : e.end) !== null && r !== void 0 ? r : 0;
        }
        get range() {
          let e = this.firstNonHiddenNode, r = this.lastNonHiddenNode;
          if (e && r) {
            if (this._rangeCache === void 0) {
              let { range: n } = e, { range: i } = r;
              this._rangeCache = { start: n.start, end: i.end.line < n.start.line ? n.start : i.end };
            }
            return this._rangeCache;
          } else
            return { start: $M.Position.create(0, 0), end: $M.Position.create(0, 0) };
        }
        get firstNonHiddenNode() {
          for (let e of this.children)
            if (!e.hidden)
              return e;
          return this.children[0];
        }
        get lastNonHiddenNode() {
          for (let e = this.children.length - 1; e >= 0; e--) {
            let r = this.children[e];
            if (!r.hidden)
              return r;
          }
          return this.children[this.children.length - 1];
        }
      };
      tn.CompositeCstNodeImpl = tl;
      var rl = class extends Array {
        constructor(e) {
          super(), this.parent = e, Object.setPrototypeOf(this, rl.prototype);
        }
        push(...e) {
          return this.addParents(e), super.push(...e);
        }
        unshift(...e) {
          return this.addParents(e), super.unshift(...e);
        }
        splice(e, r, ...n) {
          return this.addParents(n), super.splice(e, r, ...n);
        }
        addParents(e) {
          for (let r of e)
            r.parent = this.parent;
        }
      }, Bp = class extends tl {
        get text() {
          return this._text.substring(this.offset, this.end);
        }
        get fullText() {
          return this._text;
        }
        constructor(e) {
          super(), this._text = "", this._text = e ?? "";
        }
      };
      tn.RootCstNodeImpl = Bp;
    });
    var Yp = f((hr) => {
      Object.defineProperty(hr, "__esModule", { value: true });
      hr.LangiumCompletionParser = hr.LangiumParserErrorMessageProvider = hr.LangiumParser = hr.AbstractLangiumParser = hr.DatatypeSymbol = void 0;
      var zp = Ra(), Pue = MM(), Kp = we(), jM = Ft(), UM = be(), Cue = C_();
      hr.DatatypeSymbol = Symbol("Datatype");
      function N_(t) {
        return t.$type === hr.DatatypeSymbol;
      }
      var GM = "", HM = (t) => t.endsWith(GM) ? t : t + GM, nl = class {
        constructor(e) {
          this._unorderedGroups = /* @__PURE__ */ new Map(), this.lexer = e.parser.Lexer;
          let r = this.lexer.definition;
          this.wrapper = new w_(r, e.parser.ParserConfig);
        }
        alternatives(e, r) {
          this.wrapper.wrapOr(e, r);
        }
        optional(e, r) {
          this.wrapper.wrapOption(e, r);
        }
        many(e, r) {
          this.wrapper.wrapMany(e, r);
        }
        atLeastOne(e, r) {
          this.wrapper.wrapAtLeastOne(e, r);
        }
        isRecording() {
          return this.wrapper.IS_RECORDING;
        }
        get unorderedGroups() {
          return this._unorderedGroups;
        }
        getRuleStack() {
          return this.wrapper.RULE_STACK;
        }
        finalize() {
          this.wrapper.wrapSelfAnalysis();
        }
      };
      hr.AbstractLangiumParser = nl;
      var E_ = class extends nl {
        get current() {
          return this.stack[this.stack.length - 1];
        }
        constructor(e) {
          super(e), this.nodeBuilder = new Cue.CstNodeBuilder(), this.stack = [], this.assignmentMap = /* @__PURE__ */ new Map(), this.linker = e.references.Linker, this.converter = e.parser.ValueConverter, this.astReflection = e.shared.AstReflection;
        }
        rule(e, r) {
          let n = e.fragment ? void 0 : (0, jM.isDataTypeRule)(e) ? hr.DatatypeSymbol : (0, jM.getTypeName)(e), i = this.wrapper.DEFINE_RULE(HM(e.name), this.startImplementation(n, r).bind(this));
          return e.entry && (this.mainRule = i), i;
        }
        parse(e) {
          this.nodeBuilder.buildRootNode(e);
          let r = this.lexer.tokenize(e);
          this.wrapper.input = r.tokens;
          let n = this.mainRule.call(this.wrapper, {});
          return this.nodeBuilder.addHiddenTokens(r.hidden), this.unorderedGroups.clear(), { value: n, lexerErrors: r.errors, parserErrors: this.wrapper.errors };
        }
        startImplementation(e, r) {
          return (n) => {
            if (!this.isRecording()) {
              let o = { $type: e };
              this.stack.push(o), e === hr.DatatypeSymbol && (o.value = "");
            }
            let i;
            try {
              i = r(n);
            } catch {
              i = void 0;
            }
            return !this.isRecording() && i === void 0 && (i = this.construct()), i;
          };
        }
        consume(e, r, n) {
          let i = this.wrapper.wrapConsume(e, r);
          if (!this.isRecording() && !i.isInsertedInRecovery) {
            let o = this.nodeBuilder.buildLeafNode(i, n), { assignment: a, isCrossRef: s } = this.getAssignment(n), u = this.current;
            if (a) {
              let c = (0, Kp.isKeyword)(n) ? i.image : this.converter.convert(i.image, o);
              this.assign(a.operator, a.feature, c, o, s);
            } else if (N_(u)) {
              let c = i.image;
              (0, Kp.isKeyword)(n) || (c = this.converter.convert(c, o).toString()), u.value += c;
            }
          }
        }
        subrule(e, r, n, i) {
          let o;
          this.isRecording() || (o = this.nodeBuilder.buildCompositeNode(n));
          let a = this.wrapper.wrapSubrule(e, r, i);
          !this.isRecording() && o && o.length > 0 && this.performSubruleAssignment(a, n, o);
        }
        performSubruleAssignment(e, r, n) {
          let { assignment: i, isCrossRef: o } = this.getAssignment(r);
          if (i)
            this.assign(i.operator, i.feature, e, n, o);
          else if (!i) {
            let a = this.current;
            if (N_(a))
              a.value += e.toString();
            else {
              let s = e.$type, u = this.assignWithoutOverride(e, a);
              s && (u.$type = s);
              let c = u;
              this.stack.pop(), this.stack.push(c);
            }
          }
        }
        action(e, r) {
          if (!this.isRecording()) {
            let n = this.current;
            if (!n.$cstNode && r.feature && r.operator) {
              n = this.construct(false);
              let o = n.$cstNode.feature;
              this.nodeBuilder.buildCompositeNode(o);
            }
            let i = { $type: e };
            this.stack.pop(), this.stack.push(i), r.feature && r.operator && this.assign(r.operator, r.feature, n, n.$cstNode, false);
          }
        }
        construct(e = true) {
          if (this.isRecording())
            return;
          let r = this.current;
          return (0, UM.linkContentToContainer)(r), this.nodeBuilder.construct(r), e && this.stack.pop(), N_(r) ? this.converter.convert(r.value, r.$cstNode) : (this.assignMandatoryProperties(r), r);
        }
        assignMandatoryProperties(e) {
          let r = this.astReflection.getTypeMetaData(e.$type);
          for (let n of r.mandatory) {
            let i = e[n.name];
            n.type === "array" && !Array.isArray(i) ? e[n.name] = [] : n.type === "boolean" && i === void 0 && (e[n.name] = false);
          }
        }
        getAssignment(e) {
          if (!this.assignmentMap.has(e)) {
            let r = (0, UM.getContainerOfType)(e, Kp.isAssignment);
            this.assignmentMap.set(e, { assignment: r, isCrossRef: r ? (0, Kp.isCrossReference)(r.terminal) : false });
          }
          return this.assignmentMap.get(e);
        }
        assign(e, r, n, i, o) {
          let a = this.current, s;
          switch (o && typeof n == "string" ? s = this.linker.buildReference(a, r, i, n) : s = n, e) {
            case "=": {
              a[r] = s;
              break;
            }
            case "?=": {
              a[r] = true;
              break;
            }
            case "+=":
              Array.isArray(a[r]) || (a[r] = []), a[r].push(s);
          }
        }
        assignWithoutOverride(e, r) {
          for (let [n, i] of Object.entries(r)) {
            let o = e[n];
            o === void 0 ? e[n] = i : Array.isArray(o) && Array.isArray(i) && (i.push(...o), e[n] = i);
          }
          return e;
        }
        get definitionErrors() {
          return this.wrapper.definitionErrors;
        }
      };
      hr.LangiumParser = E_;
      var Vp = class {
        buildMismatchTokenMessage({ expected: e, actual: r }) {
          return `Expecting ${e.LABEL ? "`" + e.LABEL + "`" : e.name.endsWith(":KW") ? `keyword '${e.name.substring(0, e.name.length - 3)}'` : `token of type '${e.name}'`} but found \`${r.image}\`.`;
        }
        buildNotAllInputParsedMessage({ firstRedundant: e }) {
          return `Expecting end of file but found \`${e.image}\`.`;
        }
        buildNoViableAltMessage(e) {
          return zp.defaultParserErrorProvider.buildNoViableAltMessage(e);
        }
        buildEarlyExitMessage(e) {
          return zp.defaultParserErrorProvider.buildEarlyExitMessage(e);
        }
      };
      hr.LangiumParserErrorMessageProvider = Vp;
      var k_ = class extends nl {
        constructor() {
          super(...arguments), this.tokens = [], this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
        }
        action() {
        }
        construct() {
        }
        parse(e) {
          this.resetState();
          let r = this.lexer.tokenize(e);
          return this.tokens = r.tokens, this.wrapper.input = [...this.tokens], this.mainRule.call(this.wrapper, {}), this.unorderedGroups.clear(), { tokens: this.tokens, elementStack: [...this.lastElementStack], tokenIndex: this.nextTokenIndex };
        }
        rule(e, r) {
          let n = this.wrapper.DEFINE_RULE(HM(e.name), this.startImplementation(r).bind(this));
          return e.entry && (this.mainRule = n), n;
        }
        resetState() {
          this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
        }
        startImplementation(e) {
          return (r) => {
            let n = this.keepStackSize();
            try {
              e(r);
            } finally {
              this.resetStackSize(n);
            }
          };
        }
        removeUnexpectedElements() {
          this.elementStack.splice(this.stackSize);
        }
        keepStackSize() {
          let e = this.elementStack.length;
          return this.stackSize = e, e;
        }
        resetStackSize(e) {
          this.removeUnexpectedElements(), this.stackSize = e;
        }
        consume(e, r, n) {
          this.wrapper.wrapConsume(e, r), this.isRecording() || (this.lastElementStack = [...this.elementStack, n], this.nextTokenIndex = this.currIdx + 1);
        }
        subrule(e, r, n, i) {
          this.before(n), this.wrapper.wrapSubrule(e, r, i), this.after(n);
        }
        before(e) {
          this.isRecording() || this.elementStack.push(e);
        }
        after(e) {
          if (!this.isRecording()) {
            let r = this.elementStack.lastIndexOf(e);
            r >= 0 && this.elementStack.splice(r);
          }
        }
        get currIdx() {
          return this.wrapper.currIdx;
        }
      };
      hr.LangiumCompletionParser = k_;
      var Nue = { recoveryEnabled: true, nodeLocationTracking: "full", skipValidations: true, errorMessageProvider: new Vp() }, w_ = class extends zp.EmbeddedActionsParser {
        constructor(e, r) {
          let n = r && "maxLookahead" in r;
          super(e, Object.assign(Object.assign(Object.assign({}, Nue), { lookaheadStrategy: n ? new zp.LLkLookaheadStrategy({ maxLookahead: r.maxLookahead }) : new Pue.LLStarLookaheadStrategy() }), r));
        }
        get IS_RECORDING() {
          return this.RECORDING_PHASE;
        }
        DEFINE_RULE(e, r) {
          return this.RULE(e, r);
        }
        wrapSelfAnalysis() {
          this.performSelfAnalysis();
        }
        wrapConsume(e, r) {
          return this.consume(e, r);
        }
        wrapSubrule(e, r, n) {
          return this.subrule(e, r, { ARGS: [n] });
        }
        wrapOr(e, r) {
          this.or(e, r);
        }
        wrapOption(e, r) {
          this.option(e, r);
        }
        wrapMany(e, r) {
          this.many(e, r);
        }
        wrapAtLeastOne(e, r) {
          this.atLeastOne(e, r);
        }
      };
    });
    var D_ = f((hu) => {
      Object.defineProperty(hu, "__esModule", { value: true });
      hu.assertUnreachable = hu.ErrorWithLocation = void 0;
      var O_ = class extends Error {
        constructor(e, r) {
          super(e ? `${r} at ${e.range.start.line}:${e.range.start.character}` : r);
        }
      };
      hu.ErrorWithLocation = O_;
      function Eue(t) {
        throw new Error("Error! The input value was not handled.");
      }
      hu.assertUnreachable = Eue;
    });
    var x_ = f((Jp) => {
      Object.defineProperty(Jp, "__esModule", { value: true });
      Jp.createParser = void 0;
      var WM = Ra(), He = we(), il = D_(), kue = $t(), BM = Ft(), KM = yt();
      function wue(t, e, r) {
        return Oue({ parser: e, tokens: r, rules: /* @__PURE__ */ new Map(), ruleNames: /* @__PURE__ */ new Map() }, t), e;
      }
      Jp.createParser = wue;
      function Oue(t, e) {
        let r = (0, KM.getAllReachableRules)(e, false), n = (0, kue.stream)(e.rules).filter(He.isParserRule).filter((i) => r.has(i));
        for (let i of n) {
          let o = Object.assign(Object.assign({}, t), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
          o.rules.set(i.name, t.parser.rule(i, Sa(o, i.definition)));
        }
      }
      function Sa(t, e, r = false) {
        let n;
        if ((0, He.isKeyword)(e))
          n = $ue(t, e);
        else if ((0, He.isAction)(e))
          n = Due(t, e);
        else if ((0, He.isAssignment)(e))
          n = Sa(t, e.terminal);
        else if ((0, He.isCrossReference)(e))
          n = zM(t, e);
        else if ((0, He.isRuleCall)(e))
          n = Iue(t, e);
        else if ((0, He.isAlternatives)(e))
          n = que(t, e);
        else if ((0, He.isUnorderedGroup)(e))
          n = Lue(t, e);
        else if ((0, He.isGroup)(e))
          n = Mue(t, e);
        else
          throw new il.ErrorWithLocation(e.$cstNode, `Unexpected element type: ${e.$type}`);
        return VM(t, r ? void 0 : Xp(e), n, e.cardinality);
      }
      function Due(t, e) {
        let r = (0, BM.getTypeName)(e);
        return () => t.parser.action(r, e);
      }
      function Iue(t, e) {
        let r = e.rule.ref;
        if ((0, He.isParserRule)(r)) {
          let n = t.subrule++, i = e.arguments.length > 0 ? xue(r, e.arguments) : () => ({});
          return (o) => t.parser.subrule(n, YM(t, r), e, i(o));
        } else if ((0, He.isTerminalRule)(r)) {
          let n = t.consume++, i = I_(t, r.name);
          return () => t.parser.consume(n, i, e);
        } else if (r)
          (0, il.assertUnreachable)(r);
        else
          throw new il.ErrorWithLocation(e.$cstNode, `Undefined rule type: ${e.$type}`);
      }
      function xue(t, e) {
        let r = e.map((n) => Ki(n.value));
        return (n) => {
          let i = {};
          for (let o = 0; o < r.length; o++) {
            let a = t.parameters[o], s = r[o];
            i[a.name] = s(n);
          }
          return i;
        };
      }
      function Ki(t) {
        if ((0, He.isDisjunction)(t)) {
          let e = Ki(t.left), r = Ki(t.right);
          return (n) => e(n) || r(n);
        } else if ((0, He.isConjunction)(t)) {
          let e = Ki(t.left), r = Ki(t.right);
          return (n) => e(n) && r(n);
        } else if ((0, He.isNegation)(t)) {
          let e = Ki(t.value);
          return (r) => !e(r);
        } else if ((0, He.isParameterReference)(t)) {
          let e = t.parameter.ref.name;
          return (r) => r !== void 0 && r[e] === true;
        } else if ((0, He.isLiteralCondition)(t)) {
          let e = Boolean(t.true);
          return () => e;
        }
        (0, il.assertUnreachable)(t);
      }
      function que(t, e) {
        if (e.elements.length === 1)
          return Sa(t, e.elements[0]);
        {
          let r = [];
          for (let i of e.elements) {
            let o = { ALT: Sa(t, i, true) }, a = Xp(i);
            a && (o.GATE = Ki(a)), r.push(o);
          }
          let n = t.or++;
          return (i) => t.parser.alternatives(n, r.map((o) => {
            let a = { ALT: () => o.ALT(i) }, s = o.GATE;
            return s && (a.GATE = () => s(i)), a;
          }));
        }
      }
      function Lue(t, e) {
        if (e.elements.length === 1)
          return Sa(t, e.elements[0]);
        let r = [];
        for (let s of e.elements) {
          let u = { ALT: Sa(t, s, true) }, c = Xp(s);
          c && (u.GATE = Ki(c)), r.push(u);
        }
        let n = t.or++, i = (s, u) => {
          let c = u.getRuleStack().join("-");
          return `uGroup_${s}_${c}`;
        }, o = (s) => t.parser.alternatives(n, r.map((u, c) => {
          let l = { ALT: () => true }, d = t.parser;
          l.ALT = () => {
            if (u.ALT(s), !d.isRecording()) {
              let y = i(n, d);
              d.unorderedGroups.get(y) || d.unorderedGroups.set(y, []);
              let m = d.unorderedGroups.get(y);
              typeof (m == null ? void 0 : m[c]) > "u" && (m[c] = true);
            }
          };
          let h = u.GATE;
          return h ? l.GATE = () => h(s) : l.GATE = () => {
            let y = d.unorderedGroups.get(i(n, d));
            return !(y == null ? void 0 : y[c]);
          }, l;
        })), a = VM(t, Xp(e), o, "*");
        return (s) => {
          a(s), t.parser.isRecording() || t.parser.unorderedGroups.delete(i(n, t.parser));
        };
      }
      function Mue(t, e) {
        let r = e.elements.map((n) => Sa(t, n));
        return (n) => r.forEach((i) => i(n));
      }
      function Xp(t) {
        if ((0, He.isGroup)(t))
          return t.guardCondition;
      }
      function zM(t, e, r = e.terminal) {
        if (r)
          if ((0, He.isRuleCall)(r) && (0, He.isParserRule)(r.rule.ref)) {
            let n = t.subrule++;
            return (i) => t.parser.subrule(n, YM(t, r.rule.ref), e, i);
          } else if ((0, He.isRuleCall)(r) && (0, He.isTerminalRule)(r.rule.ref)) {
            let n = t.consume++, i = I_(t, r.rule.ref.name);
            return () => t.parser.consume(n, i, e);
          } else if ((0, He.isKeyword)(r)) {
            let n = t.consume++, i = I_(t, r.value);
            return () => t.parser.consume(n, i, e);
          } else
            throw new Error("Could not build cross reference parser");
        else {
          if (!e.type.ref)
            throw new Error("Could not resolve reference to type: " + e.type.$refText);
          let n = (0, KM.findNameAssignment)(e.type.ref), i = n == null ? void 0 : n.terminal;
          if (!i)
            throw new Error("Could not find name assignment for type: " + (0, BM.getTypeName)(e.type.ref));
          return zM(t, e, i);
        }
      }
      function $ue(t, e) {
        let r = t.consume++, n = t.tokens[e.value];
        if (!n)
          throw new Error("Could not find token for keyword: " + e.value);
        return () => t.parser.consume(r, n, e);
      }
      function VM(t, e, r, n) {
        let i = e && Ki(e);
        if (!n)
          if (i) {
            let o = t.or++;
            return (a) => t.parser.alternatives(o, [{ ALT: () => r(a), GATE: () => i(a) }, { ALT: (0, WM.EMPTY_ALT)(), GATE: () => !i(a) }]);
          } else
            return r;
        if (n === "*") {
          let o = t.many++;
          return (a) => t.parser.many(o, { DEF: () => r(a), GATE: i ? () => i(a) : void 0 });
        } else if (n === "+") {
          let o = t.many++;
          if (i) {
            let a = t.or++;
            return (s) => t.parser.alternatives(a, [{ ALT: () => t.parser.atLeastOne(o, { DEF: () => r(s) }), GATE: () => i(s) }, { ALT: (0, WM.EMPTY_ALT)(), GATE: () => !i(s) }]);
          } else
            return (a) => t.parser.atLeastOne(o, { DEF: () => r(a) });
        } else if (n === "?") {
          let o = t.optional++;
          return (a) => t.parser.optional(o, { DEF: () => r(a), GATE: i ? () => i(a) : void 0 });
        } else
          (0, il.assertUnreachable)(n);
      }
      function YM(t, e) {
        let r = Fue(t, e), n = t.rules.get(r);
        if (!n)
          throw new Error(`Rule "${r}" not found."`);
        return n;
      }
      function Fue(t, e) {
        if ((0, He.isParserRule)(e))
          return e.name;
        if (t.ruleNames.has(e))
          return t.ruleNames.get(e);
        {
          let r = e, n = r.$container, i = e.$type;
          for (; !(0, He.isParserRule)(n); )
            ((0, He.isGroup)(n) || (0, He.isAlternatives)(n) || (0, He.isUnorderedGroup)(n)) && (i = n.elements.indexOf(r).toString() + ":" + i), r = n, n = n.$container;
          return i = n.name + ":" + i, t.ruleNames.set(e, i), i;
        }
      }
      function I_(t, e) {
        let r = t.tokens[e];
        if (!r)
          throw new Error(`Token "${e}" not found."`);
        return r;
      }
    });
    var q_ = f((Qp) => {
      Object.defineProperty(Qp, "__esModule", { value: true });
      Qp.createCompletionParser = void 0;
      var jue = Yp(), Uue = x_();
      function Gue(t) {
        let e = t.Grammar, r = t.parser.Lexer, n = new jue.LangiumCompletionParser(t);
        return (0, Uue.createParser)(e, n, r.definition), n.finalize(), n;
      }
      Qp.createCompletionParser = Gue;
    });
    var L_ = f((mu) => {
      Object.defineProperty(mu, "__esModule", { value: true });
      mu.prepareLangiumParser = mu.createLangiumParser = void 0;
      var Hue = Yp(), Wue = x_();
      function Bue(t) {
        let e = XM(t);
        return e.finalize(), e;
      }
      mu.createLangiumParser = Bue;
      function XM(t) {
        let e = t.Grammar, r = t.parser.Lexer, n = new Hue.LangiumParser(t);
        return (0, Wue.createParser)(e, n, r.definition);
      }
      mu.prepareLangiumParser = XM;
    });
    var F_ = f((eh) => {
      Object.defineProperty(eh, "__esModule", { value: true });
      eh.DefaultTokenBuilder = void 0;
      var Kue = Ra(), M_ = we(), zue = Ft(), Vue = be(), Yue = yt(), Zp = Zo(), Xue = $t(), $_ = class {
        buildTokens(e, r) {
          let n = (0, Xue.stream)((0, Yue.getAllReachableRules)(e, false)), i = this.buildTerminalTokens(n), o = this.buildKeywordTokens(n, i, r);
          return i.forEach((a) => {
            let s = a.PATTERN;
            typeof s == "object" && s && "test" in s && (0, Zp.isWhitespaceRegExp)(s) ? o.unshift(a) : o.push(a);
          }), o;
        }
        buildTerminalTokens(e) {
          return e.filter(M_.isTerminalRule).filter((r) => !r.fragment).map((r) => this.buildTerminalToken(r)).toArray();
        }
        buildTerminalToken(e) {
          let r = (0, zue.terminalRegex)(e), n = { name: e.name, PATTERN: new RegExp(r) };
          return e.hidden && (n.GROUP = (0, Zp.isWhitespaceRegExp)(r) ? Kue.Lexer.SKIPPED : "hidden"), n;
        }
        buildKeywordTokens(e, r, n) {
          return e.filter(M_.isParserRule).flatMap((i) => (0, Vue.streamAllContents)(i).filter(M_.isKeyword)).distinct((i) => i.value).toArray().sort((i, o) => o.value.length - i.value.length).map((i) => this.buildKeywordToken(i, r, Boolean(n == null ? void 0 : n.caseInsensitive)));
        }
        buildKeywordToken(e, r, n) {
          return { name: e.value, PATTERN: this.buildKeywordPattern(e, n), LONGER_ALT: this.findLongerAlt(e, r) };
        }
        buildKeywordPattern(e, r) {
          return r ? new RegExp((0, Zp.getCaseInsensitivePattern)(e.value)) : e.value;
        }
        findLongerAlt(e, r) {
          return r.reduce((n, i) => {
            let o = i == null ? void 0 : i.PATTERN;
            return (o == null ? void 0 : o.source) && (0, Zp.partialMatches)("^" + o.source + "$", e.value) && n.push(i), n;
          }, []);
        }
      };
      eh.DefaultTokenBuilder = $_;
    });
    var U_ = f((wt) => {
      Object.defineProperty(wt, "__esModule", { value: true });
      wt.convertBoolean = wt.convertNumber = wt.convertDate = wt.convertBigint = wt.convertInt = wt.convertID = wt.convertRegexLiteral = wt.convertString = wt.DefaultValueConverter = void 0;
      var JM = we(), Jue = Ft(), Que = yt(), j_ = class {
        convert(e, r) {
          let n = r.feature;
          if ((0, JM.isCrossReference)(n) && (n = (0, Que.getCrossReferenceTerminal)(n)), (0, JM.isRuleCall)(n)) {
            let i = n.rule.ref;
            if (!i)
              throw new Error("This cst node was not parsed by a rule.");
            return this.runConverter(i, e, r);
          }
          return e;
        }
        runConverter(e, r, n) {
          var i;
          switch (e.name.toUpperCase()) {
            case "INT":
              return t1(r);
            case "STRING":
              return QM(r);
            case "ID":
              return e1(r);
            case "REGEXLITERAL":
              return ZM(r);
          }
          switch ((i = (0, Jue.getRuleType)(e)) === null || i === void 0 ? void 0 : i.toLowerCase()) {
            case "number":
              return i1(r);
            case "boolean":
              return o1(r);
            case "bigint":
              return r1(r);
            case "date":
              return n1(r);
            default:
              return r;
          }
        }
      };
      wt.DefaultValueConverter = j_;
      function QM(t) {
        let e = "";
        for (let r = 1; r < t.length - 1; r++) {
          let n = t.charAt(r);
          if (n === "\\") {
            let i = t.charAt(++r);
            e += Zue(i);
          } else
            e += n;
        }
        return e;
      }
      wt.convertString = QM;
      function Zue(t) {
        switch (t) {
          case "b":
            return "\b";
          case "f":
            return "\f";
          case "n":
            return `
`;
          case "r":
            return "\r";
          case "t":
            return "	";
          case "v":
            return "\v";
          case "0":
            return "\0";
          default:
            return t;
        }
      }
      function ZM(t) {
        return t.substring(1, t.length - 1);
      }
      wt.convertRegexLiteral = ZM;
      function e1(t) {
        return t.charAt(0) === "^" ? t.substring(1) : t;
      }
      wt.convertID = e1;
      function t1(t) {
        return parseInt(t);
      }
      wt.convertInt = t1;
      function r1(t) {
        return BigInt(t);
      }
      wt.convertBigint = r1;
      function n1(t) {
        return new Date(t);
      }
      wt.convertDate = n1;
      function i1(t) {
        return Number(t);
      }
      wt.convertNumber = i1;
      function o1(t) {
        return t.toLowerCase() === "true";
      }
      wt.convertBoolean = o1;
    });
    var W_ = f((rh) => {
      Object.defineProperty(rh, "__esModule", { value: true });
      rh.DefaultLinker = void 0;
      var ece = xe(), gu = Zt(), th = be(), tce = vr(), G_ = go(), H_ = class {
        constructor(e) {
          this.reflection = e.shared.AstReflection, this.langiumDocuments = () => e.shared.workspace.LangiumDocuments, this.scopeProvider = e.references.ScopeProvider, this.astNodeLocator = e.workspace.AstNodeLocator;
        }
        async link(e, r = ece.CancellationToken.None) {
          for (let n of (0, th.streamAst)(e.parseResult.value))
            await (0, tce.interruptAndCheck)(r), (0, th.streamReferences)(n).forEach((i) => this.doLink(i, e));
          e.state = G_.DocumentState.Linked;
        }
        doLink(e, r) {
          let n = e.reference;
          if (n._ref === void 0)
            try {
              let i = this.getCandidate(e);
              if ((0, gu.isLinkingError)(i))
                n._ref = i;
              else if (n._nodeDescription = i, this.langiumDocuments().hasDocument(i.documentUri)) {
                let o = this.loadAstNode(i);
                n._ref = o ?? this.createLinkingError(e, i);
              }
            } catch (i) {
              n._ref = Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${n.$refText}': ${i}` });
            }
          r.references.push(n);
        }
        unlink(e) {
          for (let r of e.references)
            delete r._ref, delete r._nodeDescription;
          e.references = [];
        }
        getCandidate(e) {
          let n = this.scopeProvider.getScope(e).getElement(e.reference.$refText);
          return n ?? this.createLinkingError(e);
        }
        buildReference(e, r, n, i) {
          let o = this, a = { $refNode: n, $refText: i, get ref() {
            var s;
            if ((0, gu.isAstNode)(this._ref))
              return this._ref;
            if ((0, gu.isAstNodeDescription)(this._nodeDescription)) {
              let u = o.loadAstNode(this._nodeDescription);
              this._ref = u ?? o.createLinkingError({ reference: a, container: e, property: r }, this._nodeDescription);
            } else if (this._ref === void 0) {
              let u = o.getLinkedNode({ reference: a, container: e, property: r });
              if (u.error && (0, th.getDocument)(e).state < G_.DocumentState.ComputedScopes)
                return;
              this._ref = (s = u.node) !== null && s !== void 0 ? s : u.error, this._nodeDescription = u.descr;
            }
            return (0, gu.isAstNode)(this._ref) ? this._ref : void 0;
          }, get $nodeDescription() {
            return this._nodeDescription;
          }, get error() {
            return (0, gu.isLinkingError)(this._ref) ? this._ref : void 0;
          } };
          return a;
        }
        getLinkedNode(e) {
          try {
            let r = this.getCandidate(e);
            if ((0, gu.isLinkingError)(r))
              return { error: r };
            let n = this.loadAstNode(r);
            return n ? { node: n, descr: r } : { descr: r, error: this.createLinkingError(e, r) };
          } catch (r) {
            return { error: Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${e.reference.$refText}': ${r}` }) };
          }
        }
        loadAstNode(e) {
          if (e.node)
            return e.node;
          let r = this.langiumDocuments().getOrCreateDocument(e.documentUri);
          return this.astNodeLocator.getAstNode(r.parseResult.value, e.path);
        }
        createLinkingError(e, r) {
          let n = (0, th.getDocument)(e.container);
          n.state < G_.DocumentState.ComputedScopes && console.warn(`Attempted reference resolution before document reached ComputedScopes state (${n.uri}).`);
          let i = this.reflection.getReferenceType(e);
          return Object.assign(Object.assign({}, e), { message: `Could not resolve reference to ${i} named '${e.reference.$refText}'.`, targetDescription: r });
        }
      };
      rh.DefaultLinker = H_;
    });
    var K_ = f((nh) => {
      Object.defineProperty(nh, "__esModule", { value: true });
      nh.DefaultJsonSerializer = void 0;
      var ol = Zt(), rce = be(), nce = yt();
      function a1(t) {
        return typeof t == "object" && !!t && ("$ref" in t || "$error" in t);
      }
      var B_ = class {
        constructor(e) {
          this.ignoreProperties = /* @__PURE__ */ new Set(["$container", "$containerProperty", "$containerIndex", "$document", "$cstNode"]), this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider;
        }
        serialize(e, r) {
          let n = r == null ? void 0 : r.replacer, i = (a, s) => this.replacer(a, s, r);
          return JSON.stringify(e, n ? (a, s) => n(a, s, i) : i, r == null ? void 0 : r.space);
        }
        deserialize(e) {
          let r = JSON.parse(e);
          return this.linkNode(r, r), r;
        }
        replacer(e, r, { refText: n, sourceText: i, textRegions: o } = {}) {
          var a, s, u;
          if (!this.ignoreProperties.has(e))
            if ((0, ol.isReference)(r)) {
              let c = r.ref, l = n ? r.$refText : void 0;
              return c ? { $refText: l, $ref: "#" + (c && this.astNodeLocator.getAstNodePath(c)) } : { $refText: l, $error: (s = (a = r.error) === null || a === void 0 ? void 0 : a.message) !== null && s !== void 0 ? s : "Could not resolve reference" };
            } else {
              let c;
              if (o && (0, ol.isAstNode)(r) && (c = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, r)), (!e || r.$document) && (c == null ? void 0 : c.$textRegion)))
                try {
                  c.$textRegion.documentURI = (0, rce.getDocument)(r).uri.toString();
                } catch {
                }
              return i && !e && (0, ol.isAstNode)(r) && (c ?? (c = Object.assign({}, r)), c.$sourceText = (u = r.$cstNode) === null || u === void 0 ? void 0 : u.text), c ?? r;
            }
        }
        addAstNodeRegionWithAssignmentsTo(e) {
          let r = (n) => ({ offset: n.offset, end: n.end, length: n.length, range: n.range });
          if (e.$cstNode) {
            let n = e.$textRegion = r(e.$cstNode), i = n.assignments = {};
            return Object.keys(e).filter((o) => !o.startsWith("$")).forEach((o) => {
              let a = (0, nce.findNodesForProperty)(e.$cstNode, o).map(r);
              a.length !== 0 && (i[o] = a);
            }), e;
          }
        }
        linkNode(e, r, n, i, o) {
          for (let [s, u] of Object.entries(e))
            if (Array.isArray(u))
              for (let c = 0; c < u.length; c++) {
                let l = u[c];
                a1(l) ? u[c] = this.reviveReference(e, s, r, l) : (0, ol.isAstNode)(l) && this.linkNode(l, r, e, s, c);
              }
            else
              a1(u) ? e[s] = this.reviveReference(e, s, r, u) : (0, ol.isAstNode)(u) && this.linkNode(u, r, e, s);
          let a = e;
          a.$container = n, a.$containerProperty = i, a.$containerIndex = o;
        }
        reviveReference(e, r, n, i) {
          let o = i.$refText;
          if (i.$ref) {
            let a = this.getRefNode(n, i.$ref);
            return o || (o = this.nameProvider.getName(a)), { $refText: o ?? "", ref: a };
          } else if (i.$error) {
            let a = { $refText: o ?? "" };
            return a.error = { container: e, property: r, message: i.$error, reference: a }, a;
          } else
            return;
        }
        getRefNode(e, r) {
          return this.astNodeLocator.getAstNode(e, r.substring(1));
        }
      };
      nh.DefaultJsonSerializer = B_;
    });
    var V_ = f((ih) => {
      Object.defineProperty(ih, "__esModule", { value: true });
      ih.DefaultServiceRegistry = void 0;
      var ice = vn(), z_ = class {
        register(e) {
          if (!this.singleton && !this.map) {
            this.singleton = e;
            return;
          }
          if (!this.map && (this.map = {}, this.singleton)) {
            for (let r of this.singleton.LanguageMetaData.fileExtensions)
              this.map[r] = this.singleton;
            this.singleton = void 0;
          }
          for (let r of e.LanguageMetaData.fileExtensions)
            this.map[r] !== void 0 && this.map[r] !== e && console.warn(`The file extension ${r} is used by multiple languages. It is now assigned to '${e.LanguageMetaData.languageId}'.`), this.map[r] = e;
        }
        getServices(e) {
          if (this.singleton !== void 0)
            return this.singleton;
          if (this.map === void 0)
            throw new Error("The service registry is empty. Use `register` to register the services of a language.");
          let r = ice.Utils.extname(e), n = this.map[r];
          if (!n)
            throw new Error(`The service registry contains no services for the extension '${r}'.`);
          return n;
        }
        get all() {
          return this.singleton !== void 0 ? [this.singleton] : this.map !== void 0 ? Object.values(this.map) : [];
        }
      };
      ih.DefaultServiceRegistry = z_;
    });
    var X_ = f((oh) => {
      Object.defineProperty(oh, "__esModule", { value: true });
      oh.ValidationRegistry = void 0;
      var oce = Tn(), ace = vr(), Y_ = class {
        constructor(e) {
          this.validationChecks = new oce.MultiMap(), this.reflection = e.shared.AstReflection;
        }
        register(e, r = this) {
          for (let [n, i] of Object.entries(e)) {
            let o = i;
            if (Array.isArray(o))
              for (let a of o)
                this.doRegister(n, this.wrapValidationException(a, r));
            else
              typeof o == "function" && this.doRegister(n, this.wrapValidationException(o, r));
          }
        }
        wrapValidationException(e, r) {
          return async (n, i, o) => {
            try {
              await e.call(r, n, i, o);
            } catch (a) {
              if ((0, ace.isOperationCancelled)(a))
                throw a;
              console.error("An error occurred during validation:", a);
              let s = a instanceof Error ? a.message : String(a);
              a instanceof Error && a.stack && console.error(a.stack), i("error", "An error occurred during validation: " + s, { node: n });
            }
          };
        }
        doRegister(e, r) {
          if (e === "AstNode") {
            this.validationChecks.add("AstNode", r);
            return;
          }
          for (let n of this.reflection.getAllSubTypes(e))
            this.validationChecks.add(n, r);
        }
        getChecks(e) {
          return this.validationChecks.get(e).concat(this.validationChecks.get("AstNode"));
        }
      };
      oh.ValidationRegistry = Y_;
    });
    var eR = f((yu) => {
      Object.defineProperty(yu, "__esModule", { value: true });
      yu.DefaultReferenceDescriptionProvider = yu.DefaultAstNodeDescriptionProvider = void 0;
      var sce = xe(), uce = Zt(), ah = be(), J_ = Le(), cce = vr(), lce = ki(), Q_ = class {
        constructor(e) {
          this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider;
        }
        createDescription(e, r, n = (0, ah.getDocument)(e)) {
          var i;
          r ?? (r = this.nameProvider.getName(e));
          let o = this.astNodeLocator.getAstNodePath(e);
          if (!r)
            throw new Error(`Node at path ${o} has no name.`);
          let a = (i = this.nameProvider.getNameNode(e)) !== null && i !== void 0 ? i : e.$cstNode;
          return { node: e, name: r, nameSegment: (0, J_.toDocumentSegment)(a), selectionSegment: (0, J_.toDocumentSegment)(e.$cstNode), type: e.$type, documentUri: n.uri, path: o };
        }
      };
      yu.DefaultAstNodeDescriptionProvider = Q_;
      var Z_ = class {
        constructor(e) {
          this.nodeLocator = e.workspace.AstNodeLocator;
        }
        async createDescriptions(e, r = sce.CancellationToken.None) {
          let n = [], i = e.parseResult.value;
          for (let o of (0, ah.streamAst)(i))
            await (0, cce.interruptAndCheck)(r), (0, ah.streamReferences)(o).filter((a) => !(0, uce.isLinkingError)(a)).forEach((a) => {
              let s = this.createDescription(a);
              s && n.push(s);
            });
          return n;
        }
        createDescription(e) {
          let r = e.reference.$nodeDescription, n = e.reference.$refNode;
          if (!r || !n)
            return;
          let i = (0, ah.getDocument)(e.container).uri;
          return { sourceUri: i, sourcePath: this.nodeLocator.getAstNodePath(e.container), targetUri: r.documentUri, targetPath: r.path, segment: (0, J_.toDocumentSegment)(n), local: (0, lce.equalURI)(r.documentUri, i) };
        }
      };
      yu.DefaultReferenceDescriptionProvider = Z_;
    });
    var rR = f((sh) => {
      Object.defineProperty(sh, "__esModule", { value: true });
      sh.DefaultAstNodeLocator = void 0;
      var tR = class {
        constructor() {
          this.segmentSeparator = "/", this.indexSeparator = "@";
        }
        getAstNodePath(e) {
          if (e.$container) {
            let r = this.getAstNodePath(e.$container), n = this.getPathSegment(e);
            return r + this.segmentSeparator + n;
          }
          return "";
        }
        getPathSegment({ $containerProperty: e, $containerIndex: r }) {
          if (!e)
            throw new Error("Missing '$containerProperty' in AST node.");
          return r !== void 0 ? e + this.indexSeparator + r : e;
        }
        getAstNode(e, r) {
          return r.split(this.segmentSeparator).reduce((i, o) => {
            if (!i || o.length === 0)
              return i;
            let a = o.indexOf(this.indexSeparator);
            if (a > 0) {
              let s = o.substring(0, a), u = parseInt(o.substring(a + 1)), c = i[s];
              return c == null ? void 0 : c[u];
            }
            return i[o];
          }, e);
        }
      };
      sh.DefaultAstNodeLocator = tR;
    });
    var iR = f((uh) => {
      Object.defineProperty(uh, "__esModule", { value: true });
      uh.DefaultConfigurationProvider = void 0;
      var dce = bt(), nR = class {
        constructor(e) {
          this.settings = {}, this.workspaceConfig = false, this.initialized = false, this.serviceRegistry = e.ServiceRegistry, this.connection = e.lsp.Connection, e.lsp.LanguageServer.onInitialize((r) => {
            var n, i;
            this.workspaceConfig = (i = (n = r.capabilities.workspace) === null || n === void 0 ? void 0 : n.configuration) !== null && i !== void 0 ? i : false;
          }), e.lsp.LanguageServer.onInitialized((r) => {
            var n;
            let i = this.serviceRegistry.all;
            (n = e.lsp.Connection) === null || n === void 0 || n.client.register(dce.DidChangeConfigurationNotification.type, { section: i.map((o) => this.toSectionName(o.LanguageMetaData.languageId)) });
          });
        }
        async initialize() {
          if (this.workspaceConfig && this.connection) {
            let r = this.serviceRegistry.all.map((i) => ({ section: this.toSectionName(i.LanguageMetaData.languageId) })), n = await this.connection.workspace.getConfiguration(r);
            r.forEach((i, o) => {
              this.updateSectionConfiguration(i.section, n[o]);
            });
          }
          this.initialized = true;
        }
        updateConfiguration(e) {
          e.settings && Object.keys(e.settings).forEach((r) => {
            this.updateSectionConfiguration(r, e.settings[r]);
          });
        }
        updateSectionConfiguration(e, r) {
          this.settings[e] = r;
        }
        async getConfiguration(e, r) {
          this.initialized || await this.initialize();
          let n = this.toSectionName(e);
          if (this.settings[n])
            return this.settings[n][r];
        }
        toSectionName(e) {
          return `${e}`;
        }
      };
      uh.DefaultConfigurationProvider = nR;
    });
    var sR = f((lh) => {
      Object.defineProperty(lh, "__esModule", { value: true });
      lh.DefaultDocumentBuilder = void 0;
      var ch = xe(), fce = Tn(), oR = vr(), pi = go(), aR = class {
        constructor(e) {
          this.updateListeners = [], this.buildPhaseListeners = new fce.MultiMap(), this.langiumDocuments = e.workspace.LangiumDocuments, this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.indexManager = e.workspace.IndexManager, this.serviceRegistry = e.ServiceRegistry;
        }
        async build(e, r = {}, n = ch.CancellationToken.None) {
          await this.buildDocuments(e, r, n);
        }
        async update(e, r, n = ch.CancellationToken.None) {
          for (let s of r)
            this.langiumDocuments.deleteDocument(s);
          this.indexManager.remove(r);
          for (let s of e)
            this.langiumDocuments.invalidateDocument(s);
          for (let s of this.updateListeners)
            s(e, r);
          await (0, oR.interruptAndCheck)(n);
          let i = e.map((s) => this.langiumDocuments.getOrCreateDocument(s)), o = this.collectDocuments(i, r), a = { validationChecks: "all" };
          await this.buildDocuments(o, a, n);
        }
        onUpdate(e) {
          return this.updateListeners.push(e), ch.Disposable.create(() => {
            let r = this.updateListeners.indexOf(e);
            r >= 0 && this.updateListeners.splice(r, 1);
          });
        }
        collectDocuments(e, r) {
          let n = e.map((a) => a.uri).concat(r), i = this.indexManager.getAffectedDocuments(n).toArray();
          i.forEach((a) => {
            this.serviceRegistry.getServices(a.uri).references.Linker.unlink(a), a.state = Math.min(a.state, pi.DocumentState.ComputedScopes);
          });
          let o = /* @__PURE__ */ new Set([...e, ...i, ...this.langiumDocuments.all.filter((a) => a.state < pi.DocumentState.Validated)]);
          return Array.from(o);
        }
        async buildDocuments(e, r, n) {
          await this.runCancelable(e, pi.DocumentState.Parsed, n, (o) => this.langiumDocumentFactory.update(o)), await this.runCancelable(e, pi.DocumentState.IndexedContent, n, (o) => this.indexManager.updateContent(o, n)), await this.runCancelable(e, pi.DocumentState.ComputedScopes, n, (o) => this.computeScopes(o, n)), await this.runCancelable(e, pi.DocumentState.Linked, n, (o) => this.serviceRegistry.getServices(o.uri).references.Linker.link(o, n)), await this.runCancelable(e, pi.DocumentState.IndexedReferences, n, (o) => this.indexManager.updateReferences(o, n));
          let i = e.filter((o) => this.shouldValidate(o, r));
          await this.runCancelable(i, pi.DocumentState.Validated, n, (o) => this.validate(o, n));
        }
        async runCancelable(e, r, n, i) {
          let o = e.filter((a) => a.state < r);
          for (let a of o)
            await (0, oR.interruptAndCheck)(n), await i(a);
          await this.notifyBuildPhase(o, r, n);
        }
        onBuildPhase(e, r) {
          return this.buildPhaseListeners.add(e, r), ch.Disposable.create(() => {
            this.buildPhaseListeners.delete(e, r);
          });
        }
        async notifyBuildPhase(e, r, n) {
          if (e.length === 0)
            return;
          let i = this.buildPhaseListeners.get(r);
          for (let o of i)
            await (0, oR.interruptAndCheck)(n), await o(e, n);
        }
        async computeScopes(e, r) {
          let n = this.serviceRegistry.getServices(e.uri).references.ScopeComputation;
          e.precomputedScopes = await n.computeLocalScopes(e, r), e.state = pi.DocumentState.ComputedScopes;
        }
        shouldValidate(e, r) {
          return r.validationChecks === "all";
        }
        async validate(e, r) {
          let i = await this.serviceRegistry.getServices(e.uri).validation.DocumentValidator.validateDocument(e, r);
          e.diagnostics = i, e.state = pi.DocumentState.Validated;
        }
      };
      lh.DefaultDocumentBuilder = aR;
    });
    var dR = f((dh) => {
      Object.defineProperty(dh, "__esModule", { value: true });
      dh.DefaultIndexManager = void 0;
      var s1 = xe(), pce = be(), uR = $t(), cR = ki(), u1 = go(), lR = class {
        constructor(e) {
          this.simpleIndex = /* @__PURE__ */ new Map(), this.referenceIndex = /* @__PURE__ */ new Map(), this.globalScopeCache = /* @__PURE__ */ new Map(), this.serviceRegistry = e.ServiceRegistry, this.astReflection = e.AstReflection, this.langiumDocuments = () => e.workspace.LangiumDocuments;
        }
        findAllReferences(e, r) {
          let n = (0, pce.getDocument)(e).uri, i = [];
          return this.referenceIndex.forEach((o) => {
            o.forEach((a) => {
              (0, cR.equalURI)(a.targetUri, n) && a.targetPath === r && i.push(a);
            });
          }), (0, uR.stream)(i);
        }
        allElements(e = "") {
          this.globalScopeCache.has("") || this.globalScopeCache.set("", Array.from(this.simpleIndex.values()).flat());
          let r = this.globalScopeCache.get(e);
          if (r)
            return (0, uR.stream)(r);
          {
            let n = this.globalScopeCache.get("").filter((i) => this.astReflection.isSubtype(i.type, e));
            return this.globalScopeCache.set(e, n), (0, uR.stream)(n);
          }
        }
        remove(e) {
          for (let r of e) {
            let n = r.toString();
            this.simpleIndex.delete(n), this.referenceIndex.delete(n), this.globalScopeCache.clear();
          }
        }
        async updateContent(e, r = s1.CancellationToken.None) {
          this.globalScopeCache.clear();
          let i = await this.serviceRegistry.getServices(e.uri).references.ScopeComputation.computeExports(e, r);
          for (let o of i)
            o.node = void 0;
          this.simpleIndex.set(e.uri.toString(), i), e.state = u1.DocumentState.IndexedContent;
        }
        async updateReferences(e, r = s1.CancellationToken.None) {
          let i = await this.serviceRegistry.getServices(e.uri).workspace.ReferenceDescriptionProvider.createDescriptions(e, r);
          this.referenceIndex.set(e.uri.toString(), i), e.state = u1.DocumentState.IndexedReferences;
        }
        getAffectedDocuments(e) {
          return this.langiumDocuments().all.filter((r) => {
            if (e.some((n) => (0, cR.equalURI)(r.uri, n)))
              return false;
            for (let n of e)
              if (this.isAffected(r, n))
                return true;
            return false;
          });
        }
        isAffected(e, r) {
          let n = r.toString(), i = e.uri.toString();
          if (e.references.some((a) => a.error !== void 0))
            return true;
          let o = this.referenceIndex.get(i);
          return o ? o.filter((a) => !a.local).some((a) => (0, cR.equalURI)(a.targetUri, n)) : false;
        }
      };
      dh.DefaultIndexManager = lR;
    });
    var hR = f((fh) => {
      Object.defineProperty(fh, "__esModule", { value: true });
      fh.DefaultWorkspaceManager = void 0;
      var hce = xe(), fR = vn(), mce = vr(), pR = class {
        constructor(e) {
          this.serviceRegistry = e.ServiceRegistry, this.langiumDocuments = e.workspace.LangiumDocuments, this.documentBuilder = e.workspace.DocumentBuilder, this.fileSystemProvider = e.workspace.FileSystemProvider, this.mutex = e.workspace.MutexLock, e.lsp.LanguageServer.onInitialize((r) => {
            var n;
            this.folders = (n = r.workspaceFolders) !== null && n !== void 0 ? n : void 0;
          }), e.lsp.LanguageServer.onInitialized((r) => {
            this.mutex.lock((n) => {
              var i;
              return this.initializeWorkspace((i = this.folders) !== null && i !== void 0 ? i : [], n);
            });
          });
        }
        async initializeWorkspace(e, r = hce.CancellationToken.None) {
          let n = this.serviceRegistry.all.flatMap((a) => a.LanguageMetaData.fileExtensions), i = [], o = (a) => {
            i.push(a), this.langiumDocuments.hasDocument(a.uri) || this.langiumDocuments.addDocument(a);
          };
          await this.loadAdditionalDocuments(e, o), await Promise.all(e.map((a) => [a, this.getRootFolder(a)]).map(async (a) => this.traverseFolder(...a, n, o))), await (0, mce.interruptAndCheck)(r), await this.documentBuilder.build(i, void 0, r);
        }
        loadAdditionalDocuments(e, r) {
          return Promise.resolve();
        }
        getRootFolder(e) {
          return fR.URI.parse(e.uri);
        }
        async traverseFolder(e, r, n, i) {
          let o = await this.fileSystemProvider.readDirectory(r);
          await Promise.all(o.map(async (a) => {
            if (this.includeEntry(e, a, n)) {
              if (a.isDirectory)
                await this.traverseFolder(e, a.uri, n, i);
              else if (a.isFile) {
                let s = this.langiumDocuments.getOrCreateDocument(a.uri);
                i(s);
              }
            }
          }));
        }
        includeEntry(e, r, n) {
          let i = fR.Utils.basename(r.uri);
          if (i.startsWith("."))
            return false;
          if (r.isDirectory)
            return i !== "node_modules" && i !== "out";
          if (r.isFile) {
            let o = fR.Utils.extname(r.uri);
            return n.includes(o);
          }
          return false;
        }
      };
      fh.DefaultWorkspaceManager = pR;
    });
    var vR = f((hi) => {
      Object.defineProperty(hi, "__esModule", { value: true });
      hi.isTokenTypeDictionary = hi.isIMultiModeLexerDefinition = hi.isTokenTypeArray = hi.DefaultLexer = void 0;
      var gce = Ra(), mR = class {
        constructor(e) {
          let r = e.parser.TokenBuilder.buildTokens(e.Grammar, { caseInsensitive: e.LanguageMetaData.caseInsensitive });
          this.tokenTypes = this.toTokenTypeDictionary(r);
          let n = gR(r) ? Object.values(r) : r;
          this.chevrotainLexer = new gce.Lexer(n);
        }
        get definition() {
          return this.tokenTypes;
        }
        tokenize(e) {
          var r;
          let n = this.chevrotainLexer.tokenize(e);
          return { tokens: n.tokens, errors: n.errors, hidden: (r = n.groups.hidden) !== null && r !== void 0 ? r : [] };
        }
        toTokenTypeDictionary(e) {
          if (gR(e))
            return e;
          let r = yR(e) ? Object.values(e.modes).flat() : e, n = {};
          return r.forEach((i) => n[i.name] = i), n;
        }
      };
      hi.DefaultLexer = mR;
      function c1(t) {
        return Array.isArray(t) && (t.length === 0 || "name" in t[0]);
      }
      hi.isTokenTypeArray = c1;
      function yR(t) {
        return t && "modes" in t && "defaultMode" in t;
      }
      hi.isIMultiModeLexerDefinition = yR;
      function gR(t) {
        return !c1(t) && !yR(t);
      }
      hi.isTokenTypeDictionary = gR;
    });
    var bR = f((vu) => {
      Object.defineProperty(vu, "__esModule", { value: true });
      vu.isJSDoc = vu.parseJSDoc = void 0;
      var De = xe(), yce = vn(), vce = cd(), Tce = Zo();
      function _ce(t, e, r) {
        let n, i;
        typeof t == "string" ? (i = e, n = r) : (i = t.range.start, n = e), i || (i = De.Position.create(0, 0));
        let o = f1(t), a = RR(n), s = Sce({ lines: o, position: i, options: a });
        return Ece({ index: 0, tokens: s, position: i });
      }
      vu.parseJSDoc = _ce;
      function Rce(t, e) {
        let r = RR(e), n = f1(t);
        if (n.length === 0)
          return false;
        let i = n[0], o = n[n.length - 1], a = r.start, s = r.end;
        return Boolean(a == null ? void 0 : a.exec(i)) && Boolean(s == null ? void 0 : s.exec(o));
      }
      vu.isJSDoc = Rce;
      function f1(t) {
        let e = "";
        return typeof t == "string" ? e = t : e = t.text, e.split(vce.NEWLINE_REGEXP);
      }
      var l1 = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy, bce = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
      function Sce(t) {
        var e, r, n;
        let i = [], o = t.position.line, a = t.position.character;
        for (let s = 0; s < t.lines.length; s++) {
          let u = s === 0, c = s === t.lines.length - 1, l = t.lines[s], d = 0;
          if (u && t.options.start) {
            let y = (e = t.options.start) === null || e === void 0 ? void 0 : e.exec(l);
            y && (d = y.index + y[0].length);
          } else {
            let y = (r = t.options.line) === null || r === void 0 ? void 0 : r.exec(l);
            y && (d = y.index + y[0].length);
          }
          if (c) {
            let y = (n = t.options.end) === null || n === void 0 ? void 0 : n.exec(l);
            y && (l = l.substring(0, y.index));
          }
          if (l = l.substring(0, Nce(l)), _R(l, 0) >= l.length) {
            if (i.length > 0) {
              let y = De.Position.create(o, a);
              i.push({ type: "break", content: "", range: De.Range.create(y, y) });
            }
          } else {
            l1.lastIndex = d;
            let y = l1.exec(l);
            if (y) {
              let m = y[0], R = y[1], C = De.Position.create(o, a + d), N = De.Position.create(o, a + d + m.length);
              i.push({ type: "tag", content: R, range: De.Range.create(C, N) }), d += m.length, d = _R(l, d);
            }
            if (d < l.length) {
              let m = l.substring(d), R = Array.from(m.matchAll(bce));
              i.push(...Ace(R, m, o, a + d));
            }
          }
          o++, a = 0;
        }
        return i.length > 0 && i[i.length - 1].type === "break" ? i.slice(0, -1) : i;
      }
      function Ace(t, e, r, n) {
        let i = [];
        if (t.length === 0) {
          let o = De.Position.create(r, n), a = De.Position.create(r, n + e.length);
          i.push({ type: "text", content: e, range: De.Range.create(o, a) });
        } else {
          let o = 0;
          for (let s of t) {
            let u = s.index, c = e.substring(o, u);
            c.length > 0 && i.push({ type: "text", content: e.substring(o, u), range: De.Range.create(De.Position.create(r, o + n), De.Position.create(r, u + n)) });
            let l = c.length + 1, d = s[1];
            if (i.push({ type: "inline-tag", content: d, range: De.Range.create(De.Position.create(r, o + l + n), De.Position.create(r, o + l + d.length + n)) }), l += d.length, s.length === 4) {
              l += s[2].length;
              let h = s[3];
              i.push({ type: "text", content: h, range: De.Range.create(De.Position.create(r, o + l + n), De.Position.create(r, o + l + h.length + n)) });
            } else
              i.push({ type: "text", content: "", range: De.Range.create(De.Position.create(r, o + l + n), De.Position.create(r, o + l + n)) });
            o = u + s[0].length;
          }
          let a = e.substring(o);
          a.length > 0 && i.push({ type: "text", content: a, range: De.Range.create(De.Position.create(r, o + n), De.Position.create(r, o + n + a.length)) });
        }
        return i;
      }
      var Pce = /\S/, Cce = /\s*$/;
      function _R(t, e) {
        let r = t.substring(e).match(Pce);
        return r ? e + r.index : t.length;
      }
      function Nce(t) {
        let e = t.match(Cce);
        if (e && typeof e.index == "number")
          return e.index;
      }
      function Ece(t) {
        var e, r, n, i;
        let o = De.Position.create(t.position.line, t.position.character);
        if (t.tokens.length === 0)
          return new ph([], De.Range.create(o, o));
        let a = [];
        for (; t.index < t.tokens.length; ) {
          let c = kce(t, a[a.length - 1]);
          c && a.push(c);
        }
        let s = (r = (e = a[0]) === null || e === void 0 ? void 0 : e.range.start) !== null && r !== void 0 ? r : o, u = (i = (n = a[a.length - 1]) === null || n === void 0 ? void 0 : n.range.end) !== null && i !== void 0 ? i : o;
        return new ph(a, De.Range.create(s, u));
      }
      function kce(t, e) {
        let r = t.tokens[t.index];
        if (r.type === "tag")
          return h1(t, false);
        if (r.type === "text" || r.type === "inline-tag")
          return p1(t);
        wce(r, e), t.index++;
      }
      function wce(t, e) {
        if (e) {
          let r = new hh("", t.range);
          "inlines" in e ? e.inlines.push(r) : e.content.inlines.push(r);
        }
      }
      function p1(t) {
        let e = t.tokens[t.index], r = e, n = e, i = [];
        for (; e && e.type !== "break" && e.type !== "tag"; )
          i.push(Oce(t)), n = e, e = t.tokens[t.index];
        return new sl(i, De.Range.create(r.range.start, n.range.end));
      }
      function Oce(t) {
        return t.tokens[t.index].type === "inline-tag" ? h1(t, true) : m1(t);
      }
      function h1(t, e) {
        let r = t.tokens[t.index++], n = r.content.substring(1), i = t.tokens[t.index];
        if ((i == null ? void 0 : i.type) === "text")
          if (e) {
            let o = m1(t);
            return new al(n, new sl([o], o.range), e, De.Range.create(r.range.start, o.range.end));
          } else {
            let o = p1(t);
            return new al(n, o, e, De.Range.create(r.range.start, o.range.end));
          }
        else {
          let o = r.range;
          return new al(n, new sl([], o), e, o);
        }
      }
      function m1(t) {
        let e = t.tokens[t.index++];
        return new hh(e.content, e.range);
      }
      function RR(t) {
        if (!t)
          return RR({ start: "/**", end: "*/", line: "*" });
        let { start: e, end: r, line: n } = t;
        return { start: TR(e, true), end: TR(r, false), line: TR(n, true) };
      }
      function TR(t, e) {
        if (typeof t == "string" || typeof t == "object") {
          let r = typeof t == "string" ? (0, Tce.escapeRegExp)(t) : t.source;
          return e ? new RegExp(`^\\s*${r}`) : new RegExp(`\\s*${r}\\s*$`);
        } else
          return t;
      }
      var ph = class {
        constructor(e, r) {
          this.elements = e, this.range = r;
        }
        getTag(e) {
          return this.getAllTags().find((r) => r.name === e);
        }
        getTags(e) {
          return this.getAllTags().filter((r) => r.name === e);
        }
        getAllTags() {
          return this.elements.filter((e) => "name" in e);
        }
        toString() {
          let e = "";
          for (let r of this.elements)
            if (e.length === 0)
              e = r.toString();
            else {
              let n = r.toString();
              e += d1(e) + n;
            }
          return e.trim();
        }
        toMarkdown(e) {
          let r = "";
          for (let n of this.elements)
            if (r.length === 0)
              r = n.toMarkdown(e);
            else {
              let i = n.toMarkdown(e);
              r += d1(r) + i;
            }
          return r.trim();
        }
      }, al = class {
        constructor(e, r, n, i) {
          this.name = e, this.content = r, this.inline = n, this.range = i;
        }
        toString() {
          let e = `@${this.name}`, r = this.content.toString();
          return this.content.inlines.length === 1 ? e = `${e} ${r}` : this.content.inlines.length > 1 && (e = `${e}
${r}`), this.inline ? `{${e}}` : e;
        }
        toMarkdown(e) {
          let r = this.content.toMarkdown(e);
          if (this.inline) {
            let o = Dce(this.name, r, e ?? {});
            if (typeof o == "string")
              return o;
          }
          let n = "";
          (e == null ? void 0 : e.tag) === "italic" || (e == null ? void 0 : e.tag) === void 0 ? n = "*" : (e == null ? void 0 : e.tag) === "bold" ? n = "**" : (e == null ? void 0 : e.tag) === "bold-italic" && (n = "***");
          let i = `${n}@${this.name}${n}`;
          return this.content.inlines.length === 1 ? i = `${i}  ${r}` : this.content.inlines.length > 1 && (i = `${i}
${r}`), this.inline ? `{${i}}` : i;
        }
      };
      function Dce(t, e, r) {
        var n, i;
        if (t === "linkplain" || t === "linkcode" || t === "link") {
          let o = e.indexOf(" "), a = e;
          if (o > 0) {
            let u = _R(e, o);
            a = e.substring(u), e = e.substring(0, o);
          }
          return (t === "linkcode" || t === "link" && r.link === "code") && (a = `\`${a}\``), (i = (n = r.renderLink) === null || n === void 0 ? void 0 : n.call(r, e, a)) !== null && i !== void 0 ? i : Ice(e, a);
        }
      }
      function Ice(t, e) {
        try {
          return yce.URI.parse(t, true), `[${e}](${t})`;
        } catch {
          return t;
        }
      }
      var sl = class {
        constructor(e, r) {
          this.inlines = e, this.range = r;
        }
        toString() {
          let e = "";
          for (let r = 0; r < this.inlines.length; r++) {
            let n = this.inlines[r], i = this.inlines[r + 1];
            e += n.toString(), i && i.range.start.line > n.range.start.line && (e += `
`);
          }
          return e;
        }
        toMarkdown(e) {
          let r = "";
          for (let n = 0; n < this.inlines.length; n++) {
            let i = this.inlines[n], o = this.inlines[n + 1];
            r += i.toMarkdown(e), o && o.range.start.line > i.range.start.line && (r += `
`);
          }
          return r;
        }
      }, hh = class {
        constructor(e, r) {
          this.text = e, this.range = r;
        }
        toString() {
          return this.text;
        }
        toMarkdown() {
          return this.text;
        }
      };
      function d1(t) {
        return t.endsWith(`
`) ? `
` : `

`;
      }
    });
    var y1 = f((mh) => {
      Object.defineProperty(mh, "__esModule", { value: true });
      mh.JSDocDocumentationProvider = void 0;
      var xce = Zt(), qce = be(), Lce = Le(), g1 = bR(), SR = class {
        constructor(e) {
          this.indexManager = e.shared.workspace.IndexManager, this.grammarConfig = e.parser.GrammarConfig;
        }
        getDocumentation(e) {
          let r = (0, Lce.findCommentNode)(e.$cstNode, this.grammarConfig.multilineCommentRules);
          if ((0, xce.isLeafCstNode)(r) && (0, g1.isJSDoc)(r))
            return (0, g1.parseJSDoc)(r).toMarkdown({ renderLink: (i, o) => this.documentationLinkRenderer(e, i, o) });
        }
        documentationLinkRenderer(e, r, n) {
          var i;
          let o = (i = this.findNameInPrecomputedScopes(e, r)) !== null && i !== void 0 ? i : this.findNameInGlobalScope(e, r);
          if (o && o.nameSegment) {
            let a = o.nameSegment.range.start.line + 1, s = o.nameSegment.range.start.character + 1, u = o.documentUri.with({ fragment: `L${a},${s}` });
            return `[${n}](${u.toString()})`;
          } else
            return;
        }
        findNameInPrecomputedScopes(e, r) {
          let i = (0, qce.getDocument)(e).precomputedScopes;
          if (!i)
            return;
          let o = e;
          do {
            let s = i.get(o).find((u) => u.name === r);
            if (s)
              return s;
            o = o.$container;
          } while (o);
        }
        findNameInGlobalScope(e, r) {
          return this.indexManager.allElements().find((i) => i.name === r);
        }
      };
      mh.JSDocDocumentationProvider = SR;
    });
    var AR = f((Io) => {
      var Mce = Io && Io.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), v1 = Io && Io.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Mce(e, t, r);
      };
      Object.defineProperty(Io, "__esModule", { value: true });
      v1(y1(), Io);
      v1(bR(), Io);
    });
    var hf = f((Tu) => {
      Object.defineProperty(Tu, "__esModule", { value: true });
      Tu.createDefaultSharedModule = Tu.createDefaultModule = void 0;
      var $ce = xe(), Fce = ag(), jce = Nv(), Uce = q_(), Gce = Yd(), Hce = Vy(), Wce = Xy(), Bce = qd(), Kce = Ky(), zce = Zy(), Vce = uv(), Yce = lv(), Xce = fv(), Jce = L_(), Qce = F_(), Zce = U_(), ele = W_(), tle = rs(), rle = Bd(), nle = Ed(), ile = wd(), ole = K_(), ale = V_(), sle = vr(), ule = Id(), cle = X_(), T1 = eR(), lle = rR(), dle = iR(), fle = sR(), _1 = go(), ple = dR(), hle = hR(), mle = vR(), gle = AR();
      function yle(t) {
        return { documentation: { DocumentationProvider: (e) => new gle.JSDocDocumentationProvider(e) }, parser: { GrammarConfig: (e) => (0, jce.createGrammarConfig)(e), LangiumParser: (e) => (0, Jce.createLangiumParser)(e), CompletionParser: (e) => (0, Uce.createCompletionParser)(e), ValueConverter: () => new Zce.DefaultValueConverter(), TokenBuilder: () => new Qce.DefaultTokenBuilder(), Lexer: (e) => new mle.DefaultLexer(e) }, lsp: { CompletionProvider: (e) => new Gce.DefaultCompletionProvider(e), DocumentSymbolProvider: (e) => new Wce.DefaultDocumentSymbolProvider(e), HoverProvider: (e) => new zce.MultilineCommentHoverProvider(e), FoldingRangeProvider: (e) => new Bce.DefaultFoldingRangeProvider(e), ReferencesProvider: (e) => new Yce.DefaultReferencesProvider(e), DefinitionProvider: (e) => new Kce.DefaultDefinitionProvider(e), DocumentHighlightProvider: (e) => new Hce.DefaultDocumentHighlightProvider(e), RenameProvider: (e) => new Xce.DefaultRenameProvider(e) }, workspace: { AstNodeLocator: () => new lle.DefaultAstNodeLocator(), AstNodeDescriptionProvider: (e) => new T1.DefaultAstNodeDescriptionProvider(e), ReferenceDescriptionProvider: (e) => new T1.DefaultReferenceDescriptionProvider(e) }, references: { Linker: (e) => new ele.DefaultLinker(e), NameProvider: () => new tle.DefaultNameProvider(), ScopeProvider: (e) => new ile.DefaultScopeProvider(e), ScopeComputation: (e) => new nle.DefaultScopeComputation(e), References: (e) => new rle.DefaultReferences(e) }, serializer: { JsonSerializer: (e) => new ole.DefaultJsonSerializer(e) }, validation: { DocumentValidator: (e) => new ule.DefaultDocumentValidator(e), ValidationRegistry: (e) => new cle.ValidationRegistry(e) }, shared: () => t.shared };
      }
      Tu.createDefaultModule = yle;
      function vle(t) {
        return { ServiceRegistry: () => new ale.DefaultServiceRegistry(), lsp: { Connection: () => t.connection, LanguageServer: (e) => new Vce.DefaultLanguageServer(e) }, workspace: { LangiumDocuments: (e) => new _1.DefaultLangiumDocuments(e), LangiumDocumentFactory: (e) => new _1.DefaultLangiumDocumentFactory(e), DocumentBuilder: (e) => new fle.DefaultDocumentBuilder(e), TextDocuments: () => new $ce.TextDocuments(Fce.TextDocument), IndexManager: (e) => new ple.DefaultIndexManager(e), WorkspaceManager: (e) => new hle.DefaultWorkspaceManager(e), FileSystemProvider: (e) => t.fileSystemProvider(e), MutexLock: () => new sle.MutexLock(), ConfigurationProvider: (e) => new dle.DefaultConfigurationProvider(e) } };
      }
      Tu.createDefaultSharedModule = vle;
    });
    var b1 = f((R1) => {
      Object.defineProperty(R1, "__esModule", { value: true });
    });
    var P1 = f((xo) => {
      Object.defineProperty(xo, "__esModule", { value: true });
      xo.joinTracedToNodeIf = xo.joinTracedToNode = xo.joinToNode = void 0;
      var PR = Vo();
      function S1(t, e = String, { filter: r, prefix: n, suffix: i, separator: o, appendNewLineIfNotEmpty: a } = {}) {
        return _le(t, (s, u, c, l) => {
          if (r && !r(u, c, l))
            return s;
          let d = e(u, c, l);
          return (s ?? (s = new PR.CompositeGeneratorNode())).append(n && n(u, c, l)).append(d).append(i && i(u, c, l)).appendIf(!l && d !== void 0, o).appendNewLineIfNotEmptyIf(!s.isEmpty() && !!a);
        });
      }
      xo.joinToNode = S1;
      function A1(t, e) {
        return (r, n = String, i) => (0, PR.traceToNode)(t, e)(S1(r, t && e ? (o, a, s) => (0, PR.traceToNode)(t, e, a)(n(o, a, s)) : n, i));
      }
      xo.joinTracedToNode = A1;
      function Tle(t, e, r) {
        return t ? A1(typeof e == "function" ? e() : e, r) : () => {
        };
      }
      xo.joinTracedToNodeIf = Tle;
      function _le(t, e, r) {
        let n = t[Symbol.iterator](), i = n.next(), o = 0, a = r;
        for (; !i.done; ) {
          let s = n.next();
          a = e(a, i.value, o, Boolean(s.done)), i = s, o++;
        }
        return a;
      }
    });
    var C1 = f((mr) => {
      var Rle = mr && mr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), CR = mr && mr.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Rle(e, t, r);
      };
      Object.defineProperty(mr, "__esModule", { value: true });
      mr.normalizeEOL = mr.expandToStringWithNL = mr.expandToString = void 0;
      CR(Vo(), mr);
      CR(P1(), mr);
      CR(Rg(), mr);
      var NR = cd();
      Object.defineProperty(mr, "expandToString", { enumerable: true, get: function() {
        return NR.expandToString;
      } });
      Object.defineProperty(mr, "expandToStringWithNL", { enumerable: true, get: function() {
        return NR.expandToStringWithNL;
      } });
      Object.defineProperty(mr, "normalizeEOL", { enumerable: true, get: function() {
        return NR.normalizeEOL;
      } });
    });
    var E1 = f((N1) => {
      Object.defineProperty(N1, "__esModule", { value: true });
    });
    var k1 = f((mi) => {
      var ble = mi && mi.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), gh = mi && mi.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && ble(e, t, r);
      };
      Object.defineProperty(mi, "__esModule", { value: true });
      gh(ny(), mi);
      gh(Nv(), mi);
      gh(bv(), mi);
      gh(E1(), mi);
    });
    var O1 = f((w1) => {
      Object.defineProperty(w1, "__esModule", { value: true });
    });
    var D1 = f((Ar) => {
      var Sle = Ar && Ar.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), qo = Ar && Ar.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Sle(e, t, r);
      };
      Object.defineProperty(Ar, "__esModule", { value: true });
      qo(q_(), Ar);
      qo(C_(), Ar);
      qo(L_(), Ar);
      qo(Yp(), Ar);
      qo(vR(), Ar);
      qo(O1(), Ar);
      qo(F_(), Ar);
      qo(U_(), Ar);
    });
    var I1 = f((In) => {
      var Ale = In && In.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), ul = In && In.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Ale(e, t, r);
      };
      Object.defineProperty(In, "__esModule", { value: true });
      ul(W_(), In);
      ul(rs(), In);
      ul(Bd(), In);
      ul(Ed(), In);
      ul(wd(), In);
    });
    var x1 = f((Aa) => {
      var Ple = Aa && Aa.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), Cle = Aa && Aa.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Ple(e, t, r);
      };
      Object.defineProperty(Aa, "__esModule", { value: true });
      Cle(K_(), Aa);
    });
    var q1 = f((gr) => {
      var Nle = gr && gr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), zi = gr && gr.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Nle(e, t, r);
      };
      Object.defineProperty(gr, "__esModule", { value: true });
      zi(be(), gr);
      zi(Tn(), gr);
      zi(Le(), gr);
      zi(D_(), gr);
      zi(yt(), gr);
      zi(vr(), gr);
      zi(Zo(), gr);
      zi($t(), gr);
      zi(ki(), gr);
    });
    var M1 = f((Lo) => {
      var Ele = Lo && Lo.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), L1 = Lo && Lo.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Ele(e, t, r);
      };
      Object.defineProperty(Lo, "__esModule", { value: true });
      L1(Id(), Lo);
      L1(X_(), Lo);
    });
    var $1 = f((Pr) => {
      var kle = Pr && Pr.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), Mo = Pr && Pr.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && kle(e, t, r);
      };
      Object.defineProperty(Pr, "__esModule", { value: true });
      Mo(eR(), Pr);
      Mo(rR(), Pr);
      Mo(iR(), Pr);
      Mo(sR(), Pr);
      Mo(go(), Pr);
      Mo(Sv(), Pr);
      Mo(dR(), Pr);
      Mo(hR(), Pr);
    });
    var gi = f((We) => {
      var F1 = We && We.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r);
        var i = Object.getOwnPropertyDescriptor(e, r);
        (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, n, i);
      } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r];
      }), wle = We && We.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", { enumerable: true, value: e });
      } : function(t, e) {
        t.default = e;
      }), yr = We && We.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && F1(e, t, r);
      }, Ole = We && We.__importStar || function(t) {
        if (t && t.__esModule)
          return t;
        var e = {};
        if (t != null)
          for (var r in t)
            r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && F1(e, t, r);
        return wle(e, t), e;
      };
      Object.defineProperty(We, "__esModule", { value: true });
      We.GrammarAST = void 0;
      yr(hf(), We);
      yr(zu(), We);
      yr(V_(), We);
      yr(b1(), We);
      yr(Zt(), We);
      yr(AR(), We);
      yr(C1(), We);
      yr(k1(), We);
      yr(hv(), We);
      yr(D1(), We);
      yr(I1(), We);
      yr(x1(), We);
      yr(q1(), We);
      yr(M1(), We);
      yr($1(), We);
      var Dle = Ole(we());
      We.GrammarAST = Dle;
    });
    var U1 = f(($Te, j1) => {
      j1.exports = xe();
    });
    var bu = $r(gi()), $o = $r(U1());
    var Yi = $r(gi());
    var G1 = $r(gi()), H1 = "State";
    function _u(t) {
      return B1.isInstance(t, H1);
    }
    var Ile = "Statemachine";
    function W1(t) {
      return B1.isInstance(t, Ile);
    }
    var cl = class extends G1.AbstractAstReflection {
      getAllTypes() {
        return ["State", "Statemachine", "Transition"];
      }
      computeIsSubtype(e, r) {
        switch (e) {
          default:
            return false;
        }
      }
      getReferenceType(e) {
        let r = `${e.container.$type}:${e.property}`;
        switch (r) {
          case "State:init":
          case "Statemachine:init":
          case "Transition:to":
            return H1;
          default:
            throw new Error(`${r} is not a valid reference id.`);
        }
      }
      getTypeMetaData(e) {
        switch (e) {
          case "State":
            return { name: "State", mandatory: [{ name: "loop", type: "boolean" }, { name: "sequence", type: "boolean" }, { name: "states", type: "array" }, { name: "transitions", type: "array" }] };
          case "Statemachine":
            return { name: "Statemachine", mandatory: [{ name: "loop", type: "boolean" }, { name: "sequence", type: "boolean" }, { name: "states", type: "array" }, { name: "transitions", type: "array" }] };
          default:
            return { name: e, mandatory: [] };
        }
      }
    }, B1 = new cl();
    var K1 = $r(gi()), yh, z1 = () => yh != null ? yh : yh = (0, K1.loadGrammarFromJson)(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "Statetree",
  "rules": [
    {
      "$type": "ParserRule",
      "name": "Statemachine",
      "entry": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "statemachine"
              },
              {
                "$type": "Assignment",
                "feature": "name",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@5"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@1"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Stateful",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "initialState"
              },
              {
                "$type": "Assignment",
                "feature": "init",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@2"
                  },
                  "deprecatedSyntax": false
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "transitions",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@3"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "states",
                "cardinality": "?"
              },
              {
                "$type": "Assignment",
                "feature": "sequence",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "sequence"
                }
              },
              {
                "$type": "Assignment",
                "feature": "loop",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "loop"
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "on"
              },
              {
                "$type": "Assignment",
                "feature": "event",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@5"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "Assignment",
                "feature": "states",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@2"
                  },
                  "arguments": []
                },
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "State",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "state",
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@5"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@1"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Transition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "event",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@5"
              },
              "arguments": []
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "to"
              },
              {
                "$type": "Keyword",
                "value": ":"
              },
              {
                "$type": "Keyword",
                "value": "go"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "to",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@2"
              },
              "deprecatedSyntax": false
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\s+"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "definition": {
        "$type": "RegexToken",
        "regex": "[_a-zA-Z][\\\\w_]*"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "HASH_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\#[^\\\\n\\\\r]*"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/[^\\\\n\\\\r]*"
      },
      "fragment": false
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "imports": [],
  "interfaces": [],
  "types": [],
  "usedGrammars": []
}`);
    var qle = { languageId: "statetree", fileExtensions: [".statetree"], caseInsensitive: false }, V1 = { AstReflection: () => new cl() }, Y1 = { Grammar: () => z1(), LanguageMetaData: () => qle, parser: {} };
    function X1(t) {
      let e = t.validation.ValidationRegistry, r = t.validation.StatetreeValidator, n = {};
      e.register(n, r);
    }
    var vh = class {
    };
    var Ru = $r(gi());
    var Th = class extends Ru.AbstractFormatter {
      format(e) {
        if (_u(e)) {
          let r = this.getNodeFormatter(e), n = r.keyword("{"), i = r.keyword("}");
          r.interior(n, i).prepend(Ru.Formatting.indent()), i.prepend(Ru.Formatting.newLine());
        } else
          W1(e) && this.getNodeFormatter(e).nodes(...e.states).prepend(Ru.Formatting.noIndent());
      }
    };
    var Vi = $r(gi()), ER = $r(Fn());
    var J1 = _u, _h = class extends Vi.DefaultScopeComputation {
      constructor(e) {
        super(e);
      }
      async computeExports(e, r = ER.CancellationToken.None) {
        let n = [];
        for (let i of (0, Vi.streamAllContents)(e.parseResult.value))
          if (await (0, Vi.interruptAndCheck)(r), J1(i)) {
            let o = this.nameProvider.getName(i);
            o && (_u(i.$container), n.push(this.descriptions.createDescription(i, o, e)));
          }
        return n;
      }
      async computeLocalScopes(e, r = ER.CancellationToken.None) {
        let n = e.parseResult.value, i = new Vi.MultiMap();
        return await this.processContainer(n, i, e, r), i;
      }
      async processContainer(e, r, n, i) {
        let o = [];
        for (let a of e.states)
          if (await (0, Vi.interruptAndCheck)(i), J1(a)) {
            let s = this.descriptions.createDescription(a, a.name, n);
            o.push(s);
          } else if (_u(a)) {
            let s = await this.processContainer(a, r, n, i);
            for (let u of s)
              o.push(u);
          }
        return r.addAll(e, o), o;
      }
    };
    var s$ = $r(gi());
    var Q1 = $r(vn());
    async function Z1(t, e) {
      var n;
      let r = e.shared.workspace.LangiumDocumentFactory.fromString(t, Q1.URI.parse("memory://statetree.document"));
      return await e.shared.workspace.DocumentBuilder.build([r], { validationChecks: "all" }), (n = r.parseResult) == null ? void 0 : n.value;
    }
    var rn = $r(gi());
    function e$(t, { source: e } = {}) {
      return (0, rn.toString)(r(t));
      function r(s) {
        switch (s.$type) {
          case "State":
            return a(s);
          case "Statemachine":
            let u = s.init;
            n(u);
            return rn.expandToNode`
                    ${i(s.states)}
                `;
        }
        return rn.expandToNode``;
      }
      function n(s) {
        var c;
        let u = (c = s == null ? void 0 : s.$refText) != null ? c : s == null ? void 0 : s.ref.name;
        return rn.expandToNode``.appendIf(!!u, `initialState ${u}`);
      }
      function i(s = []) {
        s == null ? void 0 : s.length;
        return (0, rn.joinToNode)(s, (c) => a(c), { appendNewLineIfNotEmpty: true });
      }
      function o(s) {
        return (0, rn.joinToNode)(s, (u) => {
          var c;
          return rn.expandToNode`${u.event} => ${(c = u.to) == null ? void 0 : c.$refText}`;
        }, { appendNewLineIfNotEmpty: true });
      }
      function a(s) {
        var c, l;
        let u = ((c = s.states) == null ? void 0 : c.length) > 0 || ((l = s.transitions) == null ? void 0 : l.length) > 0;
        return rn.expandToNode`
                ${s.name}
            `.appendIf(u, (d) => {
          d.append(rn.expandToNode`
                {
                `).indent((h) => h.append(o(s.transitions)).append(i(s.states))).append("}");
        });
      }
    }
    var Cr = $r(gi());
    function kR(t) {
      var e, r;
      if ((t.sequence || t.loop) && !t.init) {
        let n = (e = t.states) == null ? void 0 : e[0];
        n && (t.init = t$(n, { refText: n == null ? void 0 : n.name }));
      }
      return t.states = (r = t.states) == null ? void 0 : r.map((n, i) => {
        if (t.sequence || t.loop) {
          let { event: o } = t, a = i === t.states.length - 1, s = a ? a && t.loop ? 0 : -1 : i + 1;
          if (s > -1) {
            let u = t.states[s];
            n.transitions.push({ $container: t, $type: "Transition", event: o != null ? o : "*", to: t$(u, { refText: u.name }) });
          }
        }
        return kR(n);
      }), t;
    }
    function t$(t, { refNode: e, refText: r }) {
      return { $refNode: e, $refText: r, get ref() {
        return t;
      } };
    }
    function r$(t) {
      let e = kR(t), r = Cr.expandToNode`
        // statetree machine
        ${$le(e)}
    `;
      return (0, Cr.toString)(r);
    }
    function Lle(t) {
      let e = [];
      for (; t.$container; )
        e.push(t.$container), t = t.$container;
      return e;
    }
    function Mle(t) {
      return t ? Lle(t).reverse().concat(t) : [];
    }
    function n$(t) {
      var e, r, n;
      return (n = (e = t.init) == null ? void 0 : e.ref) != null ? n : (r = t.states) == null ? void 0 : r[0];
    }
    function i$(t) {
      for (; t && t.states && t.states.length > 0; )
        t = i$(n$(t));
      return t;
    }
    function $le(t, n = {}) {
      var i = n, { helpEvent: e = "?" } = i, r = xR(i, ["helpEvent"]);
      return Cr.expandToNode`
    function getNextState(stateIn = ${a$(n$(t))}, event = '*') {
        let path = stateIn, index = -1
        const next = () => path[++index]
        let state = next()
        ${o$(t, [], fl({ helpEvent: e }, r))}
    }
    `;
    }
    function o$(t, e = [], r = {}) {
      let { init: n, states: i } = t;
      if (!i || i.length === 0)
        return "";
      n != null ? n : { ref: i[0] };
      return (0, Cr.joinToNode)(i, (a) => Cr.expandToNode`
                if (state==='${a.name}') {
                ${Cr.expandToNode``.indent((s) => {
        var u;
        ((u = a.states) == null ? void 0 : u.length) > 0 && s.append(Cr.expandToNode`state = next()`.appendNewLine()), s.append(jle(a)), s.append(o$(a, e.concat(a), r)), s.append(Fle(a, r));
      })}
                }
            `, { appendNewLineIfNotEmpty: true });
    }
    function Fle(t, { helpEvent: e } = {}) {
      return e ? Cr.expandToNode`
    if (event ==='${e}') return ${JSON.stringify(t.transitions.map((r) => r.event))}` : Cr.expandToNode``;
    }
    function jle(t) {
      let { init: e, transitions: r, event: n } = t;
      return !r || r.length === 0 ? "" : (0, Cr.joinToNode)(r, (i) => {
        var s, u, c;
        let o = a$((s = i.to) == null ? void 0 : s.ref), a = (c = (u = i.event) != null ? u : n) != null ? c : "*";
        return Cr.expandToNode`if (event==='${a}') return ${o}`;
      }, { appendNewLineIfNotEmpty: true });
    }
    function a$(t) {
      return JSON.stringify(Mle(i$(t)).map((e) => e.name).filter((e) => e));
    }
    async function u$(t) {
      let e = Rh(s$.EmptyFileSystem).Statetree, r = await Z1(t, e), n = r$(r);
      return Promise.resolve(n);
    }
    async function c$(t, { source: e } = {}) {
      let r = e$(t, { source: e });
      return Promise.resolve(r);
    }
    var Ule = { references: { ScopeComputation: (t) => new _h(t) }, validation: { StatetreeValidator: () => new vh() }, lsp: { Formatter: () => new Th() } };
    function Rh(t) {
      let e = (0, Yi.inject)((0, Yi.createDefaultSharedModule)(t), V1), r = (0, Yi.inject)((0, Yi.createDefaultModule)({ shared: e }), Y1, Ule);
      return e.lsp.ExecuteCommandHandler = new wR(), e.ServiceRegistry.register(r), X1(r), { shared: e, Statetree: r };
    }
    var wR = class extends Yi.AbstractExecuteCommandHandler {
      registerCommands(e) {
        e("parseAndGenerate", (r) => u$(r[0])), e("import", (r) => c$(r[0]));
      }
    };
    var Gle = new $o.BrowserMessageReader(self), Hle = new $o.BrowserMessageWriter(self), l$ = (0, $o.createConnection)(Gle, Hle), { shared: d$, Statetree: Wle } = Rh(fl({ connection: l$ }, bu.EmptyFileSystem));
    console.log("starting language server!!");
    (0, bu.startLanguageServer)(d$);
    var Ble = new $o.NotificationType("browser/DocumentChange"), Kle = Wle.serializer.JsonSerializer;
    d$.workspace.DocumentBuilder.onBuildPhase(bu.DocumentState.Validated, (t) => {
      var e;
      for (let r of t) {
        let n = Kle.serialize(r.parseResult.value);
        l$.sendNotification(Ble, { uri: r.uri.toString(), content: n, diagnostics: (e = r.diagnostics) != null ? e : [] });
      }
    });
  })();
})();
