var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E;
import { gM as n, aS as Dimension, j2 as size, j3 as Component, aD as Emitter, dA as assertIsDefined, cZ as MutableDisposable, aU as defaultGenerator, j4 as ScopedProgressIndicator, j5 as AbstractProgressScope, hg as ServiceCollection, bK as IEditorProgressService, a6 as DisposableStore, ah as $$2, bq as show, fv as isCancellationError, bP as withNullAsUndefined, c as localize, j6 as prepareActions, bh as hide, aG as append, cJ as WorkbenchToolBar, j7 as createActionViewItem, j8 as ProgressBar, j9 as defaultProgressBarStyles, aX as dispose, bo as Event, Z as Registry, ja as SIDE_BAR_TITLE_FOREGROUND, jb as SIDE_BAR_BORDER, ca as contrastBorder, jc as SidebarFocusContext, jd as ActiveViewletContext, bY as trackFocus, aI as addDisposableListener, fU as StandardMouseEvent, aJ as EventType, je as Gesture, jf as EventType$1, jg as CompositeDragAndDropObserver, jh as SIDE_BAR_BACKGROUND, ji as SIDE_BAR_FOREGROUND, jj as SIDE_BAR_DRAG_AND_DROP_BACKGROUND, gu as __decorate, gv as __param, al as INotificationService, aa as IStorageService, ct as IContextMenuService, jk as IWorkbenchLayoutService, a$ as IKeybindingService, b1 as IInstantiationService, aQ as IThemeService, jl as IViewDescriptorService, I as IContextKeyService, h5 as IExtensionService, bF as registerAction2, f6 as Action2, fY as Categories, jm as ILoggerService, jn as IOutputService, hR as IWorkbenchEnvironmentService, fz as joinPath, D as Disposable, e6 as isUndefined, jo as CounterSet, jp as Extensions$1, jq as defaultViewIcon, a2 as URI, bB as isEqual, aK as ThemeIcon, bE as coalesce, jr as move, js as isUndefinedOrNull, jt as DisposableMap, ju as ViewVisibilityState, hh as SyncDescriptor, jv as ViewPaneContainer, jw as ViewContainerLocationToString, d3 as generateUuid, aq as toDisposable, jx as ViewPaneContainerAction, C as ContextKeyExpr, jy as ViewsSubMenu, i as MenuId, R as RawContextKey, cu as ITelemetryService, jz as IActivityService, jA as IPaneCompositePartService, jB as getCurrentAuthenticationSessionInfo, cy as Action, jC as SubmenuAction, cE as Separator, d0 as toAction, cL as registerThemingParticipant, jD as ACTIVITY_BAR_ACTIVE_BORDER, jE as ACTIVITY_BAR_ACTIVE_FOCUS_BORDER, jF as ACTIVITY_BAR_ACTIVE_BACKGROUND, fA as activeContrastBorder, dV as focusBorder, ay as IConfigurationService, fH as EventHelper, bT as StandardKeyboardEvent, jG as IHoverService, c9 as IMenuService, cd as createAndFillInActionBarActions, jH as IAuthenticationService, jI as IProductService, jJ as ISecretStorageService, jK as ICredentialsService, fM as ILogService, cn as clearNode, hw as IUserDataProfileService, aE as Widget, cA as ActionBar, jL as isAncestor, jM as toggleDropEffect, a5 as illegalArgument, j as RunOnceScheduler, g_ as ActionRunner, fd as ModifierKeyEmitter, aT as isMacintosh, jN as cleanMnemonic, jO as MENU_MNEMONIC_REGEX, aM as Codicon, jP as Direction, jQ as escape, jR as MENU_ESCAPED_MNEMONIC_REGEX, jS as ltrim, jT as rtrim, jU as scheduleAtNextAnimationFrame, jV as isFullscreen, jW as ScanCodeUtils, jX as getDomNodeZoomLevel, jY as Menu, c1 as asArray, jZ as IsDevelopmentContext, iL as IHostService, j_ as inQuickPickContext, bu as KeybindingsRegistry, j$ as getQuickNavigateHandler, a0 as CommandsRegistry, iI as IWorkspacesService, as as IQuickInputService, d7 as IWorkspaceContextService, b0 as ILabelService, a4 as IModelService, bb as ILanguageService, iK as IDialogService, aW as ResourceMap, ix as isRecentFolder, iy as isRecentWorkspace, k0 as getIconClasses, k1 as FileKind, k2 as splitRecentLabel, h as MenuRegistry, k3 as IsMacNativeContext, k4 as SubmenuItemAction, p as isNative, k5 as unmnemonicLabel, w as isWeb, dZ as Severity, bH as IsWebContext, k6 as mnemonicMenuLabel, k7 as createAndFillInContextMenuActions, k8 as defaultMenuStyles, cB as MenuItemAction, go as isIOS, k9 as BrowserFeatures, ka as IUpdateService, hy as IPreferencesService, cN as IAccessibilityService, ak as ICommandService, kb as isICommandActionToggleInfo, aL as registerIcon, kc as NumberBadge, kd as asCSSUrl, ke as StringSHA1, kf as createCSSRule, kg as getEnabledViewContainerContextKey, e9 as isString, kh as ACTIVITY_BAR_BACKGROUND, ki as ACTIVITY_BAR_BORDER, kj as ACTIVITY_BAR_FOREGROUND, kk as ACTIVITY_BAR_INACTIVE_FOREGROUND, kl as ACTIVITY_BAR_BADGE_BACKGROUND, km as ACTIVITY_BAR_BADGE_FOREGROUND, kn as ACTIVITY_BAR_DRAG_AND_DROP_BORDER, ko as PANEL_ACTIVE_TITLE_BORDER, kp as PANEL_ACTIVE_TITLE_FOREGROUND, kq as PANEL_INACTIVE_TITLE_FOREGROUND, kr as badgeBackground, ks as badgeForeground, kt as PANEL_DRAG_AND_DROP_BORDER, ku as CompositeMenuActions, kv as EDITOR_DRAG_AND_DROP_BACKGROUND, kw as ToolBar, kx as PANEL_BACKGROUND, ky as ActivePanelContext, kz as PanelFocusContext, kA as PANEL_BORDER, kB as ActiveAuxiliaryContext, kC as AuxiliaryBarFocusContext, kD as ViewContainerLocations, kE as openLinkFromMarkdown, kF as isMarkdownString, b$ as MarkdownRenderer, am as EDITOR_FONT_DEFAULTS, gY as prepend, c2 as IOpenerService, cM as editorHoverBorder, dW as IContextViewService, kG as UndoRedoSource, kH as ExplorerModel, b5 as dirname, aV as basename, kI as ResourceGlobMatcher, ed as CancellationTokenSource, kJ as ExplorerItem, he as IFileService, v as IClipboardService, gx as IEditorService, hz as IUriIdentityService, c_ as IBulkEditService, d1 as IProgressService, kK as IFilesConfigurationService, av as Color, kL as Relay, kM as tail2, bp as Sizing$1, bi as SplitView, gV as rot, cD as equals, bS as DomScrollableElement, bn as addStandardDisposableListener, gU as createStyleSheet, kN as modify, kO as measure, kP as commonPrefixLength, kQ as BreadcrumbsConfig, kR as matchesSomeScheme, br as Schemas, ap as onUnexpectedError, kS as IOutlineService, kT as breadcrumbsPickerBackground, dK as widgetShadow, dL as widgetBorder, io as isWorkspace, i5 as isWorkspaceFolder, b6 as createMatches, kU as relative, kV as ResourceLabels, kW as DEFAULT_LABELS_CONTAINER, bt as WorkbenchAsyncDataTree, kX as SIDE_GROUP, fN as ITextResourceConfigurationService, kY as WorkbenchDataTree, il as posix, kZ as parse, k_ as compareFileNames, k$ as defaultBreadcrumbsWidgetStyles, l0 as EditorResourceAccessor, l1 as SideBySideEditor, aF as PixelRatio, bC as combinedDisposable, aP as getDomNodePagePosition, l2 as ACTIVE_GROUP, fn as timeout, l3 as IEditorGroupsService, l4 as IBreadcrumbsService, bw as WorkbenchListFocusContextKey, bz as IListService, aY as extUri, l5 as tail, l6 as Themable, da as LocalSelectionTransfer, l7 as ResourceContextKey, l8 as ActiveEditorPinnedContext, l9 as ActiveEditorFirstInGroupContext, la as ActiveEditorLastInGroupContext, lb as ActiveEditorStickyContext, lc as ActiveEditorAvailableEditorIdsContext, ld as ActiveEditorCanSplitInGroupContext, le as SideBySideEditorActiveContext, lf as ActiveEditorGroupLockedContext, lg as EditorPane, d6 as withUndefinedAsNull, lh as applyAvailableEditorIds, li as SideBySideEditorInput, lj as DraggedEditorGroupIdentifier, q as isFirefox, cT as DataTransfers, lk as applyDragImage, ll as listActiveSelectionForeground, lm as listActiveSelectionBackground, ln as fillEditorsDragData, lo as IEditorResolverService, lp as CloseOneEditorAction, lq as UnpinEditorAction, d2 as isWindows, im as win32, cl as ScrollableElement, lr as assertAllDefined, ls as DEFAULT_EDITOR_ASSOCIATION, lt as DragAndDropObserver, lu as DraggedEditorIdentifier, hq as equals$1, lv as insert, lw as TAB_ACTIVE_BACKGROUND, lx as TAB_INACTIVE_BACKGROUND, ly as computeEditorAriaLabel, lz as getOrSet, lA as shorten, lB as EDITOR_GROUP_HEADER_TABS_BORDER, dN as isHighContrast, lC as TAB_BORDER, bs as basenameOrAuthority, lD as TAB_UNFOCUSED_ACTIVE_BACKGROUND, lE as TAB_ACTIVE_BORDER, lF as TAB_UNFOCUSED_ACTIVE_BORDER, lG as TAB_ACTIVE_BORDER_TOP, lH as TAB_UNFOCUSED_ACTIVE_BORDER_TOP, lI as TAB_ACTIVE_FOREGROUND, lJ as TAB_UNFOCUSED_ACTIVE_FOREGROUND, lK as TAB_UNFOCUSED_INACTIVE_BACKGROUND, lL as TAB_INACTIVE_FOREGROUND, lM as TAB_UNFOCUSED_INACTIVE_FOREGROUND, lN as TAB_ACTIVE_MODIFIED_BORDER, lO as TAB_INACTIVE_MODIFIED_BORDER, lP as TAB_UNFOCUSED_ACTIVE_MODIFIED_BORDER, lQ as TAB_UNFOCUSED_INACTIVE_MODIFIED_BORDER, lR as TAB_LAST_PINNED_BORDER, lS as UNLOCK_GROUP_COMMAND_ID, lT as findParentWithClass, db as DraggedTreeItemsIdentifier, lU as extractTreeDropData, lV as ResourcesDropHandler, lW as TAB_HOVER_BACKGROUND, lX as TAB_UNFOCUSED_HOVER_BACKGROUND, lY as TAB_HOVER_FOREGROUND, lZ as TAB_UNFOCUSED_HOVER_FOREGROUND, l_ as TAB_HOVER_BORDER, l$ as TAB_UNFOCUSED_HOVER_BORDER, m0 as isSafari, m1 as WORKBENCH_BACKGROUND, cc as editorBackground, m2 as EDITOR_GROUP_HEADER_TABS_BACKGROUND, m3 as EditorActivation, iu as IPathService, d9 as ITreeViewsDnDService, m4 as DEFAULT_EDITOR_MIN_DIMENSIONS, m5 as DEFAULT_EDITOR_MAX_DIMENSIONS, m6 as LongRunningOperation, m7 as EditorExtensions, m8 as EditorOpenSource, m9 as isEditorOpenError, c8 as Severity$1, ia as toErrorMessage, g7 as IWorkspaceTrustManagementService, ma as ResourceLabel, mb as CLOSE_EDITOR_COMMAND_ID, cz as h, hS as ILifecycleService, mc as RunOnceWorker, eL as DeferredPromise, md as isSerializedEditorGroupModel, me as EditorGroupModel, mf as EditorProgressIndicator, mg as ActiveEditorDirtyContext, mh as EditorGroupEditorsCountContext, mi as fillActiveEditorViewState, mj as isGroupEditorCloseEvent, mk as isGroupEditorOpenEvent, ml as extname, mm as TelemetryTrustedValue, mn as getMimeTypes, d$ as hash, ik as firstOrDefault, i4 as Promises, mo as EditorCloseContext, dz as isLinux, mp as EDITOR_GROUP_EMPTY_BACKGROUND, mq as EDITOR_GROUP_HEADER_BORDER, mr as EDITOR_GROUP_HEADER_NO_TABS_BACKGROUND, iJ as IFileDialogService, ms as renderFormattedText, mt as EDITOR_DROP_INTO_PROMPT_BACKGROUND, mu as EDITOR_DROP_INTO_PROMPT_FOREGROUND, mv as EDITOR_DROP_INTO_PROMPT_BORDER, ir as isTemporaryWorkspace, mw as Extensions$2, mx as containsDragType, cX as CodeDataTransfers, my as getEditorPartOptions, mz as impactsEditorPartOptions, hm as distinct, mA as EDITOR_GROUP_BORDER, mB as EDITOR_PANE_BACKGROUND, mC as addDisposableGenericMouseDownListener, mD as ExplorerFocusCondition, mE as OPEN_TO_SIDE_COMMAND_ID, mF as IExplorerService, mG as getMultiSelectedResources, mH as FilesExplorerFocusCondition, mI as ExplorerFolderContext, mJ as COMPARE_WITH_SAVED_COMMAND_ID, K as KeyChord, a_ as ITextModelService, mK as TextFileContentProvider, mL as getResourceForCommand, mM as SELECT_FOR_COMPARE_COMMAND_ID, mN as ResourceSelectedForCompareContext, mO as COMPARE_SELECTED_COMMAND_ID, mP as COMPARE_RESOURCE_COMMAND_ID, e as EditorContextKeys, mQ as COPY_PATH_COMMAND_ID, mR as COPY_RELATIVE_PATH_COMMAND_ID, mS as REVEAL_IN_EXPLORER_COMMAND_ID, mT as IViewsService, mU as VIEW_ID, mV as OpenEditorsView, mW as OPEN_WITH_EXPLORER_COMMAND_ID, mX as EditorResolution, mY as SAVE_FILE_COMMAND_ID, mZ as SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID, m_ as SAVE_FILE_AS_COMMAND_ID, m$ as SAVE_ALL_COMMAND_ID, n0 as SAVE_ALL_IN_GROUP_COMMAND_ID, n1 as getMultiSelectedEditorContexts, n2 as SAVE_FILES_COMMAND_ID, n3 as REVERT_FILE_COMMAND_ID, n4 as getOpenEditorsViewMultiSelection, n5 as REMOVE_ROOT_FOLDER_COMMAND_ID, iR as IWorkspaceEditingService, n6 as RemoveRootFolderAction, n7 as ExplorerCompressedFocusContext, n8 as ExplorerCompressedFirstFocusContext, n9 as PREVIOUS_COMPRESSED_FOLDER, na as VIEWLET_ID$1, nb as ExplorerCompressedLastFocusContext, nc as NEXT_COMPRESSED_FOLDER, nd as FIRST_COMPRESSED_FOLDER, ne as LAST_COMPRESSED_FOLDER, nf as NEW_UNTITLED_FILE_COMMAND_ID, ng as NEW_UNTITLED_FILE_LABEL, nh as NEW_FILE_COMMAND_ID, u as ICodeEditorService, h4 as ITextFileService, bj as EmbeddedCodeEditorWidget, ni as AbstractTextResourceEditorInput, nj as FILE_EDITOR_INPUT_ID, nk as BINARY_FILE_EDITOR_ID, nl as TEXT_FILE_EDITOR_ID, nm as createTextBufferFactory, nn as getLargeFileConfirmationLimit, no as isConfigured, np as ByteSize, nq as findViewStateForEditor, nr as isResourceEditorInput, ns as DiffEditorInput, nt as SAVE_FILE_AS_LABEL, nu as ExplorerRootContext, nv as ExplorerResourceNotReadonlyContext, nw as renameHandler, nx as ExplorerResourceMoveableToTrash, ny as moveFileToTrashHandler, nz as deleteFileHandler, nA as cutFileHandler, nB as copyFileHandler, nC as pasteFileHandler, nD as ExplorerResourceCut, nE as openFilePreserveFocusHandler, nF as SAVE_FILE_LABEL, nG as SAVE_FILE_WITHOUT_FORMATTING_LABEL, nH as WorkspaceFolderCountContext, nI as NEW_FILE_LABEL, nJ as NEW_FILE_COMMAND_ID$1, nK as NEW_FOLDER_LABEL, nL as NEW_FOLDER_COMMAND_ID, nM as REOPEN_WITH_COMMAND_ID, nN as OpenEditorsDirtyEditorContext, nO as OpenEditorsGroupContext, nP as OpenEditorsReadonlyEditorContext, nQ as AutoSaveAfterShortDelayContext, nR as DirtyWorkingCopiesContext, nS as WorkbenchListDoubleSelection, nT as CLOSE_OTHER_EDITORS_IN_GROUP_COMMAND_ID, nU as CLOSE_SAVED_EDITORS_COMMAND_ID, nV as CLOSE_EDITORS_IN_GROUP_COMMAND_ID, nW as ExplorerResourceAvailableEditorIdsContext, nX as COPY_FILE_LABEL, nY as PASTE_FILE_LABEL, nZ as FileCopiedContext, n_ as DOWNLOAD_COMMAND_ID, n$ as DOWNLOAD_LABEL, o0 as HasWebFileSystemAccess, o1 as UPLOAD_COMMAND_ID, o2 as UPLOAD_LABEL, o3 as ADD_ROOT_FOLDER_COMMAND_ID, o4 as ADD_ROOT_FOLDER_LABEL, o5 as EnterMultiRootWorkspaceSupportContext, o6 as WorkbenchStateContext, o7 as REMOVE_ROOT_FOLDER_LABEL, o8 as TRIGGER_RENAME_LABEL, o9 as MOVE_FILE_TO_TRASH_LABEL, b2 as IconLabel, oa as SymbolKinds, ob as CallHierarchyModel, a7 as CancellationToken, c7 as compare, k as Range, bc as PeekViewWidget, bd as peekViewBorder, be as peekViewTitleBackground, bf as peekViewTitleForeground, bg as peekViewTitleInfoForeground, oc as TreeMouseEventTarget, t as themeColorFromId, od as peekViewEditorMatchHighlight, O as OverviewRulerLane, bm as peekViewResultsBackground, b9 as IPeekViewService, oe as CallHierarchyProviderRegistry, a as registerEditorContribution, bI as EditorAction2, bv as PeekContext, of as TypeHierarchyModel, og as TypeHierarchyProviderRegistry, fV as OutlineModel, fX as OutlineElement, oh as symbolKindNames, c6 as MarkerSeverity, oi as listErrorForeground, oj as listWarningForeground, fW as OutlineGroup, ok as getAriaLabelForSymbol, b7 as HighlightedLabel, ol as IdleValue, h1 as Extensions$3, aA as TimeoutTimer, om as TreeElement, bM as raceCancellation, a3 as ILanguageFeaturesService, ej as IOutlineModelService, cp as IMarkerDecorationsService, bG as isCodeEditor, on as isDiffEditor, hU as Barrier, oo as ViewPane, ab as LRUCache, op as TreeFindMode, oq as AbstractTreeViewState, or as VIEW_CONTAINER, _ as Extensions$4, os as WorkbenchListSupportsMultiSelectContextKey, bx as WorkbenchTreeElementCanCollapse, ot as WorkbenchTreeElementHasParent, ou as ObjectTree, ov as DataTree, ow as AsyncDataTree, ox as List, oy as PagedList, oz as Table, oA as getSelectionKeyboardEvent, by as WorkbenchTreeElementCanExpand, oB as WorkbenchTreeElementHasChild, oC as range, oD as WorkbenchListHasSelectionOrFocus, oE as WorkbenchListSelectionNavigation, oF as AbstractTree, oG as RawWorkbenchListFocusContextKey, oH as WorkbenchListSupportsFind, oI as WorkbenchTreeFindOpen, oJ as WorkbenchListScrollAtTopContextKey, oK as WorkbenchListScrollAtBottomContextKey, dB as Toggle, dy as defaultToggleStyles, oL as setupCustomHover, oM as ResolvableTreeItem, oN as renderMarkdownAsPlaintext, oO as ColorScheme, oP as FolderThemeIcon, oQ as FileThemeIcon, oR as TreeItemCollapsibleState, oS as setTimeout0, oT as API_OPEN_EDITOR_COMMAND_ID, oU as API_OPEN_DIFF_EDITOR_COMMAND_ID, oV as ActionViewItem, oW as isFalsyOrWhitespace, bZ as getTotalHeight, oX as getLargestChildWidth, oY as ITreeViewsService, cU as Mimes, cW as VSDataTransfer, oZ as OnPortForward, o_ as makeAddress, o$ as OpenPortInPreviewAction, p0 as OpenPortInBrowserAction, p1 as TunnelPanel, p2 as openPreviewEnabledContext, p3 as TunnelPrivacyId, p4 as mapHasAddressLocalhostOrAllInterfaces, p5 as TunnelCloseReason, p6 as AutoTunnelSource, p7 as ExtensionKeyedWebviewOriginStore, p8 as ViewPaneShowActions, ih as Memento, p9 as WebviewWindowDragMonitor, pa as IWebviewService, pb as IWebviewViewService, gr as ExtensionsRegistry, pc as ExtensionIdentifierSet, ig as isProposedApiEnabled, pd as ExtensionIdentifier, pe as VIEWLET_ID$2, pf as VIEWLET_ID$3, pg as WebviewInput, ph as IWebviewWorkbenchService, pi as CustomEditorInput, pj as NotebookEditorInput, pk as IWorkingCopyEditorService, pl as IWorkingCopyBackupService, pm as ICustomEditorService, pn as EditorPaneDescriptor, po as WebviewEditor, pp as KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_ENABLED, pq as KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_VISIBLE, pr as KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_FOCUSED, ps as externalUriOpenersConfigurationNode, pt as getCodeEditor, pu as ShowTooltipCommand, ag as renderLabelWithIcons, g6 as Link, pv as parseLinkedText, M as MarkdownString, pw as STATUS_BAR_WARNING_ITEM_FOREGROUND, px as STATUS_BAR_WARNING_ITEM_BACKGROUND, py as STATUS_BAR_ERROR_ITEM_FOREGROUND, pz as STATUS_BAR_ERROR_ITEM_BACKGROUND, pA as ILanguageStatusService, pB as IStatusbarService, pC as ThrottledDelayer, pD as ILanguageDetectionService, pE as LanguageDetectionLanguageEventSource, pF as UntitledTextEditorInput, pG as isEditorInputWithOptions, pH as BINARY_TEXT_FILE_MODE, pI as NeverShowAgainScope, pJ as NotificationPriority, pK as isAbsolute, pL as IWorkbenchFileService, pM as IWorkingCopyService, pN as NO_TYPE_ID, pO as ITextEditorService, pP as AbstractTextCodeEditor, i6 as mark, pQ as isTextEditorViewState, pR as applyTextEditorOptions, pS as createEditorOpenError, pT as TooLargeFileOperationError, pU as createTooLargeFileError, pV as FileOperationError, pW as ExplorerViewletViewsContribution, pX as UndoCommand, ba as IUndoRedoService, pY as RedoCommand, pZ as ModesRegistry, ie as sep, p_ as PauseableEmitter, p$ as isResourceSideBySideEditorInput, q0 as isResourceDiffEditorInput, q1 as isEditorInputWithOptionsAndGroup, q2 as globMatchesResource, q3 as editorsAssociationsSettingId, q4 as flatten, q5 as RegisteredEditorPriority, q6 as priorityToRank, q7 as isResourceMergeEditorInput, q8 as isUntitledResourceEditorInput, q9 as isRelativePattern, qa as StatusBarFocused, qb as isStatusbarEntryLocation, qc as markdownStringEqual, qd as isThemeColor, qe as renderIcon, qf as syncing, qg as spinningLoading, qh as isStatusbarEntryPriority, qi as STATUS_BAR_ITEM_HOVER_BACKGROUND, qj as STATUS_BAR_ITEM_COMPACT_HOVER_BACKGROUND, qk as disposeIfDisposable, ql as STATUS_BAR_BACKGROUND, qm as STATUS_BAR_NO_FOLDER_BACKGROUND, qn as STATUS_BAR_FOREGROUND, qo as STATUS_BAR_NO_FOLDER_FOREGROUND, qp as STATUS_BAR_ITEM_FOCUS_BORDER, qq as STATUS_BAR_BORDER, qr as STATUS_BAR_NO_FOLDER_BORDER, qs as STATUS_BAR_FOCUS_BORDER, qt as getExcludes, qu as FILES_EXCLUDE_CONFIG, qv as SEARCH_EXCLUDE_CONFIG, qw as isEditorPaneWithSelection, qx as FileChangesEvent, qy as isEditorInput, qz as remove, qA as isSideBySideEditorInput, qB as LogLevel, qC as FileOperationEvent, c5 as LinkedList, ad as once, h6 as languagesExtPoint, qD as CustomEditorInfo, qE as CONTEXT_ACTIVE_CUSTOM_EDITOR_ID, qF as CONTEXT_FOCUSED_CUSTOM_EDITOR_IS_EDITABLE, qG as CustomEditorInfoCollection, qH as getColorRegistry, qI as extractLocalHostUriMetaDataForPortMapping, qJ as extname$1, qK as getMediaMime, qL as normalize, qM as isUNC, dv as ContextScopedFindInput, dw as showHistoryKeybindingHint, dx as defaultInputBoxStyles, dr as Delayer, dC as widgetClose, ds as format, cO as status, qN as parentOriginHash, qO as decodeAuthority, qP as webviewRootResourceAuthority, qQ as FileAccess, qR as COI, qS as areWebviewContentOptionsEqual, qT as webviewGenericCspSource, qU as streamToBuffer, qV as IRemoteAuthorityResolverService, qW as ITunnelService, qX as FastDomNode, qY as ILayoutService, qZ as IWorkingCopyFileService, cY as ResourceTextEdit, q_ as SingleModelEditStackElement, iY as MultiModelEditStackElement, eb as IEditorWorkerService, cP as EditOperation, eH as SnippetParser, eT as SnippetController2, q$ as ResourceFileEdit, r0 as ResourceNotebookCellEdit, r1 as BulkCellEdits, r2 as UndoRedoGroup, cs as Progress, r3 as ResourceSet, hb as StandaloneServices, r4 as BaseActionViewItem, r5 as registerAssets, r6 as changeUrlDomain, r7 as getServiceOverride$2, r8 as getServiceOverride$3, r9 as TextEditorService, ra as IEditorDropService, rb as BreadcrumbsService, rc as ContextViewService, rd as IUntitledTextEditorService, re as UntitledTextEditorService, rf as ISemanticSimilarityService, rg as SemanticSimilarityService, rh as IHistoryService, ri as WebviewViewService, rj as WebviewEditorService, rk as EditorInput, rl as registerServiceInitializePostParticipant, rm as positionToString } from "./theme-defaults-1df7f429.js";
import { rp, ro, rn } from "./theme-defaults-1df7f429.js";
import { E as Extensions, V as ViewsService } from "./viewsService-d4b94cea.js";
import { A as ActivityAction, a as ActivityActionViewItem, T as ToggleCompositePinnedAction, b as ToggleCompositeBadgeAction, C as CompositeOverflowActivityAction, c as CompositeActionViewItem, d as CompositeOverflowActivityActionViewItem, e as ToggleSidebarPositionAction, f as ToggleActivityBarVisibilityAction, P as PanelActivityAction, g as PlaceHolderToggleCompositePinnedAction$1, h as PlaceHolderPanelActivityAction, i as TogglePanelAction, j as ToggleAuxiliaryBarAction, E as ErrorPlaceholderEditor, W as WorkspaceTrustRequiredPlaceholderEditor, k as findGroup, B as BinaryEditorModel, l as BaseBinaryResourceEditor, m as ToggleStatusbarVisibilityAction, n as CodeEditorService, M as MonacoEditorService, o as MonacoDelegateEditorGroupsService } from "./editor-557b13f4.js";
import { g as getMenuBarVisibility, a as getTitleBarStyle } from "./window-67f3d505.js";
import { H as HoverWidget$1, a as HoverAction, t as toExternalVSDataTransfer, I as IWorkbenchThemeService, F as FindReplaceState, S as SimpleButton, f as findPreviousMatchIcon, b as findNextMatchIcon, N as NLS_MATCHES_LOCATION, c as NLS_NO_RESULTS } from "./index-ca8d23e0.js";
import "./workbench.contribution-0151a633.js";
import { S as SimpleIconLabel } from "./simpleIconLabel-ea6a3011.js";
import { D as DEFAULT_FONT_FAMILY } from "./style-4f366664.js";
import "./index-3bddf13b.js";
var css$p = ".monaco-workbench.nosidebar>.part.sidebar{display:none!important;visibility:hidden!important}.monaco-workbench .part.sidebar .title-actions .actions-container{justify-content:flex-end}.monaco-workbench .part.sidebar .title-actions .action-item{margin-right:4px}.monaco-workbench .part.sidebar>.title>.title-label h2{text-transform:uppercase}.monaco-workbench .viewlet .collapsible.header .title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-workbench .viewlet .collapsible.header .actions{width:0}.monaco-workbench .viewlet .collapsible.header.focused .actions,.monaco-workbench .viewlet .split-view-view:hover>.header .actions{flex:1;width:auto}.monaco-workbench .viewlet .collapsible.header .actions .action-label{background-position:50%;background-repeat:no-repeat;background-size:16px;height:22px;margin-right:0;width:28px}.monaco-workbench .viewlet .collapsible.header .actions .action-label .label,.monaco-workbench .viewlet .collapsible.header.collapsed .actions{display:none}.monaco-workbench .viewlet .collapsible.header .action-label{background-repeat:no-repeat;height:16px;margin-right:.2em;width:16px}";
n(css$p, {});
var css$o = ".monaco-workbench .part>.content>.composite{height:100%}.monaco-workbench .part>.composite.title{display:flex}.monaco-workbench .part>.composite.title>.title-actions{flex:1;padding-left:5px}";
n(css$o, {});
var css$n = ".monaco-workbench .part{box-sizing:border-box;overflow:hidden}.monaco-workbench .part>.drop-block-overlay.visible{visibility:visible}.monaco-workbench .part>.drop-block-overlay{height:100%;opacity:0;position:absolute;top:0;visibility:hidden;width:100%;z-index:12}.monaco-workbench .part>.title{box-sizing:border-box;display:none;display:flex;height:35px;overflow:hidden;padding-left:8px;padding-right:8px}.monaco-workbench .part>.title>.title-label{line-height:35px;overflow:hidden;padding-left:12px;text-overflow:ellipsis;white-space:nowrap}.monaco-workbench .part>.title>.title-label h2{cursor:default;font-size:11px;font-weight:400;margin:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-workbench .part>.title>.title-label a{cursor:default;font-size:13px;text-decoration:none}.monaco-workbench .part>.title>.title-actions{flex:1;height:35px;padding-left:5px}.monaco-workbench .part>.title>.title-actions .action-label{background-position:50%;background-repeat:no-repeat;background-size:16px;display:block}.monaco-workbench .part>.title>.title-actions .action-label .label{display:none}.monaco-workbench .part>.title>.title-actions .action-label.codicon{color:inherit}.monaco-workbench .part>.content{font-size:13px}.monaco-workbench .part.editor>.content .monaco-progress-container,.monaco-workbench .part>.content>.monaco-progress-container{height:2px;left:0;position:absolute;top:33px;z-index:5}.monaco-workbench\n	.part.editor>.content\n	.monaco-progress-container\n	.progress-bit,.monaco-workbench .part>.content>.monaco-progress-container .progress-bit{height:2px}";
n(css$n, {});
class Part extends Component {
  get dimension() {
    return this._dimension;
  }
  constructor(id, options, themeService, storageService, layoutService) {
    super(id, themeService, storageService);
    this.options = options;
    this.layoutService = layoutService;
    this._onDidVisibilityChange = this._register(new Emitter());
    this.onDidVisibilityChange = this._onDidVisibilityChange.event;
    this._onDidChange = this._register(new Emitter());
    layoutService.registerPart(this);
  }
  onThemeChange(theme) {
    if (this.parent) {
      super.onThemeChange(theme);
    }
  }
  updateStyles() {
    super.updateStyles();
  }
  create(parent, options) {
    this.parent = parent;
    this.titleArea = this.createTitleArea(parent, options);
    this.contentArea = this.createContentArea(parent, options);
    this.partLayout = new PartLayout(this.options, this.contentArea);
    this.updateStyles();
  }
  getContainer() {
    return this.parent;
  }
  createTitleArea(parent, options) {
    return void 0;
  }
  getTitleArea() {
    return this.titleArea;
  }
  createContentArea(parent, options) {
    return void 0;
  }
  getContentArea() {
    return this.contentArea;
  }
  layoutContents(width, height) {
    const partLayout = assertIsDefined(this.partLayout);
    return partLayout.layout(width, height);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  layout(width, height, _top, _left) {
    this._dimension = new Dimension(width, height);
  }
  setVisible(visible) {
    this._onDidVisibilityChange.fire(visible);
  }
}
const _PartLayout = class _PartLayout {
  constructor(options, contentArea) {
    this.options = options;
    this.contentArea = contentArea;
  }
  layout(width, height) {
    let titleSize;
    if (this.options.hasTitle) {
      titleSize = new Dimension(width, Math.min(height, _PartLayout.TITLE_HEIGHT));
    } else {
      titleSize = Dimension.None;
    }
    let contentWidth = width;
    if (this.options && typeof this.options.borderWidth === "function") {
      contentWidth -= this.options.borderWidth();
    }
    const contentSize = new Dimension(contentWidth, height - titleSize.height);
    if (this.contentArea) {
      size(this.contentArea, contentSize.width, contentSize.height);
    }
    return { titleSize, contentSize };
  }
};
_PartLayout.TITLE_HEIGHT = 35;
let PartLayout = _PartLayout;
class CompositePart extends Part {
  constructor(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, registry, activeCompositeSettingsKey, defaultCompositeId, nameForTelemetry, compositeCSSClass, titleForegroundColor, id, options) {
    super(id, options, themeService, storageService, layoutService);
    this.notificationService = notificationService;
    this.storageService = storageService;
    this.contextMenuService = contextMenuService;
    this.keybindingService = keybindingService;
    this.instantiationService = instantiationService;
    this.registry = registry;
    this.activeCompositeSettingsKey = activeCompositeSettingsKey;
    this.defaultCompositeId = defaultCompositeId;
    this.nameForTelemetry = nameForTelemetry;
    this.compositeCSSClass = compositeCSSClass;
    this.titleForegroundColor = titleForegroundColor;
    this.onDidCompositeOpen = this._register(new Emitter());
    this.onDidCompositeClose = this._register(new Emitter());
    this.mapCompositeToCompositeContainer = /* @__PURE__ */ new Map();
    this.mapActionsBindingToComposite = /* @__PURE__ */ new Map();
    this.instantiatedCompositeItems = /* @__PURE__ */ new Map();
    this.actionsListener = this._register(new MutableDisposable());
    this.lastActiveCompositeId = storageService.get(activeCompositeSettingsKey, 1, this.defaultCompositeId);
  }
  openComposite(id, focus) {
    var _a2;
    if (((_a2 = this.activeComposite) == null ? void 0 : _a2.getId()) === id) {
      if (focus) {
        this.activeComposite.focus();
      }
      return this.activeComposite;
    }
    if (!this.element) {
      return;
    }
    return this.doOpenComposite(id, focus);
  }
  doOpenComposite(id, focus = false) {
    var _a2;
    const currentCompositeOpenToken = defaultGenerator.nextId();
    this.currentCompositeOpenToken = currentCompositeOpenToken;
    if (this.activeComposite) {
      this.hideActiveComposite();
    }
    this.updateTitle(id);
    const composite = this.createComposite(id, true);
    if (this.currentCompositeOpenToken !== currentCompositeOpenToken || this.activeComposite && this.activeComposite.getId() !== composite.getId()) {
      return void 0;
    }
    if (((_a2 = this.activeComposite) == null ? void 0 : _a2.getId()) === composite.getId()) {
      if (focus) {
        composite.focus();
      }
      this.onDidCompositeOpen.fire({ composite, focus });
      return composite;
    }
    this.showComposite(composite);
    if (focus) {
      composite.focus();
    }
    if (composite) {
      this.onDidCompositeOpen.fire({ composite, focus });
    }
    return composite;
  }
  createComposite(id, isActive) {
    const compositeItem = this.instantiatedCompositeItems.get(id);
    if (compositeItem) {
      return compositeItem.composite;
    }
    const compositeDescriptor = this.registry.getComposite(id);
    if (compositeDescriptor) {
      const that = this;
      const compositeProgressIndicator = new ScopedProgressIndicator(
        assertIsDefined(this.progressBar),
        new class extends AbstractProgressScope {
          constructor() {
            super(compositeDescriptor.id, !!isActive);
            this._register(that.onDidCompositeOpen.event((e) => this.onScopeOpened(e.composite.getId())));
            this._register(that.onDidCompositeClose.event((e) => this.onScopeClosed(e.getId())));
          }
        }()
      );
      const compositeInstantiationService = this.instantiationService.createChild(new ServiceCollection(
        [IEditorProgressService, compositeProgressIndicator]
      ));
      const composite = compositeDescriptor.instantiate(compositeInstantiationService);
      const disposable = new DisposableStore();
      this.instantiatedCompositeItems.set(id, { composite, disposable, progress: compositeProgressIndicator });
      disposable.add(composite.onTitleAreaUpdate(() => this.onTitleAreaUpdate(composite.getId()), this));
      return composite;
    }
    throw new Error(`Unable to find composite with id ${id}`);
  }
  showComposite(composite) {
    this.activeComposite = composite;
    const id = this.activeComposite.getId();
    if (id !== this.defaultCompositeId) {
      this.storageService.store(this.activeCompositeSettingsKey, id, 1, 1);
    } else {
      this.storageService.remove(this.activeCompositeSettingsKey, 1);
    }
    this.lastActiveCompositeId = this.activeComposite.getId();
    let compositeContainer = this.mapCompositeToCompositeContainer.get(composite.getId());
    if (!compositeContainer) {
      compositeContainer = $$2(".composite");
      compositeContainer.classList.add(...this.compositeCSSClass.split(" "));
      compositeContainer.id = composite.getId();
      composite.create(compositeContainer);
      composite.updateStyles();
      this.mapCompositeToCompositeContainer.set(composite.getId(), compositeContainer);
    }
    if (!this.activeComposite || composite.getId() !== this.activeComposite.getId()) {
      return void 0;
    }
    const contentArea = this.getContentArea();
    contentArea == null ? void 0 : contentArea.appendChild(compositeContainer);
    show(compositeContainer);
    const toolBar = assertIsDefined(this.toolBar);
    toolBar.actionRunner = composite.getActionRunner();
    const descriptor = this.registry.getComposite(composite.getId());
    if (descriptor && descriptor.name !== composite.getTitle()) {
      this.updateTitle(composite.getId(), composite.getTitle());
    }
    let actionsBinding = this.mapActionsBindingToComposite.get(composite.getId());
    if (!actionsBinding) {
      actionsBinding = this.collectCompositeActions(composite);
      this.mapActionsBindingToComposite.set(composite.getId(), actionsBinding);
    }
    actionsBinding();
    this.actionsListener.value = toolBar.actionRunner.onDidRun((e) => {
      if (e.error && !isCancellationError(e.error)) {
        this.notificationService.error(e.error);
      }
    });
    composite.setVisible(true);
    if (!this.activeComposite || composite.getId() !== this.activeComposite.getId()) {
      return;
    }
    if (this.contentAreaSize) {
      composite.layout(this.contentAreaSize);
    }
    if (this.boundarySashes) {
      composite.setBoundarySashes(this.boundarySashes);
    }
  }
  onTitleAreaUpdate(compositeId) {
    var _a2;
    const composite = this.instantiatedCompositeItems.get(compositeId);
    if (composite) {
      this.updateTitle(compositeId, composite.composite.getTitle());
    }
    if (((_a2 = this.activeComposite) == null ? void 0 : _a2.getId()) === compositeId) {
      const actionsBinding = this.collectCompositeActions(this.activeComposite);
      this.mapActionsBindingToComposite.set(this.activeComposite.getId(), actionsBinding);
      actionsBinding();
    } else {
      this.mapActionsBindingToComposite.delete(compositeId);
    }
  }
  updateTitle(compositeId, compositeTitle) {
    const compositeDescriptor = this.registry.getComposite(compositeId);
    if (!compositeDescriptor || !this.titleLabel) {
      return;
    }
    if (!compositeTitle) {
      compositeTitle = compositeDescriptor.name;
    }
    const keybinding = this.keybindingService.lookupKeybinding(compositeId);
    this.titleLabel.updateTitle(compositeId, compositeTitle, withNullAsUndefined(keybinding == null ? void 0 : keybinding.getLabel()));
    const toolBar = assertIsDefined(this.toolBar);
    toolBar.setAriaLabel(localize("ariaCompositeToolbarLabel", "{0} actions", compositeTitle));
  }
  collectCompositeActions(composite) {
    const menuIds = composite == null ? void 0 : composite.getMenuIds();
    const primaryActions = (composite == null ? void 0 : composite.getActions().slice(0)) || [];
    const secondaryActions = (composite == null ? void 0 : composite.getSecondaryActions().slice(0)) || [];
    const toolBar = assertIsDefined(this.toolBar);
    toolBar.context = this.actionsContextProvider();
    return () => toolBar.setActions(prepareActions(primaryActions), prepareActions(secondaryActions), menuIds);
  }
  getActiveComposite() {
    return this.activeComposite;
  }
  getLastActiveCompositeId() {
    return this.lastActiveCompositeId;
  }
  hideActiveComposite() {
    var _a2;
    if (!this.activeComposite) {
      return void 0;
    }
    const composite = this.activeComposite;
    this.activeComposite = void 0;
    const compositeContainer = this.mapCompositeToCompositeContainer.get(composite.getId());
    composite.setVisible(false);
    if (compositeContainer) {
      compositeContainer.remove();
      hide(compositeContainer);
    }
    (_a2 = this.progressBar) == null ? void 0 : _a2.stop().hide();
    if (this.toolBar) {
      this.collectCompositeActions()();
    }
    this.onDidCompositeClose.fire(composite);
    return composite;
  }
  createTitleArea(parent) {
    const titleArea = append(parent, $$2(".composite"));
    titleArea.classList.add("title");
    this.titleLabel = this.createTitleLabel(titleArea);
    const titleActionsContainer = append(titleArea, $$2(".title-actions"));
    this.toolBar = this._register(this.instantiationService.createInstance(WorkbenchToolBar, titleActionsContainer, {
      actionViewItemProvider: (action) => this.actionViewItemProvider(action),
      orientation: 0,
      getKeyBinding: (action) => this.keybindingService.lookupKeybinding(action.id),
      anchorAlignmentProvider: () => this.getTitleAreaDropDownAnchorAlignment(),
      toggleMenuTitle: localize("viewsAndMoreActions", "Views and More Actions..."),
      telemetrySource: this.nameForTelemetry
    }));
    this.collectCompositeActions()();
    return titleArea;
  }
  createTitleLabel(parent) {
    const titleContainer = append(parent, $$2(".title-label"));
    const titleLabel = append(titleContainer, $$2("h2"));
    this.titleLabelElement = titleLabel;
    const $this = this;
    return {
      updateTitle: (id, title, keybinding) => {
        if (!this.activeComposite || this.activeComposite.getId() === id) {
          titleLabel.innerText = title;
          titleLabel.title = keybinding ? localize("titleTooltip", "{0} ({1})", title, keybinding) : title;
        }
      },
      updateStyles: () => {
        titleLabel.style.color = $this.titleForegroundColor ? $this.getColor($this.titleForegroundColor) || "" : "";
      }
    };
  }
  updateStyles() {
    super.updateStyles();
    const titleLabel = assertIsDefined(this.titleLabel);
    titleLabel.updateStyles();
  }
  actionViewItemProvider(action) {
    if (this.activeComposite) {
      return this.activeComposite.getActionViewItem(action);
    }
    return createActionViewItem(this.instantiationService, action);
  }
  actionsContextProvider() {
    if (this.activeComposite) {
      return this.activeComposite.getActionsContext();
    }
    return null;
  }
  createContentArea(parent) {
    const contentContainer = append(parent, $$2(".content"));
    this.progressBar = this._register(new ProgressBar(contentContainer, defaultProgressBarStyles));
    this.progressBar.hide();
    return contentContainer;
  }
  getProgressIndicator(id) {
    const compositeItem = this.instantiatedCompositeItems.get(id);
    return compositeItem ? compositeItem.progress : void 0;
  }
  getTitleAreaDropDownAnchorAlignment() {
    return 1;
  }
  layout(width, height, top, left) {
    var _a2;
    super.layout(width, height, top, left);
    this.contentAreaSize = Dimension.lift(super.layoutContents(width, height).contentSize);
    (_a2 = this.activeComposite) == null ? void 0 : _a2.layout(this.contentAreaSize);
  }
  setBoundarySashes(sashes) {
    var _a2;
    this.boundarySashes = sashes;
    (_a2 = this.activeComposite) == null ? void 0 : _a2.setBoundarySashes(sashes);
  }
  removeComposite(compositeId) {
    var _a2;
    if (((_a2 = this.activeComposite) == null ? void 0 : _a2.getId()) === compositeId) {
      return false;
    }
    this.mapCompositeToCompositeContainer.delete(compositeId);
    this.mapActionsBindingToComposite.delete(compositeId);
    const compositeItem = this.instantiatedCompositeItems.get(compositeId);
    if (compositeItem) {
      compositeItem.composite.dispose();
      dispose(compositeItem.disposable);
      this.instantiatedCompositeItems.delete(compositeId);
    }
    return true;
  }
  dispose() {
    this.mapCompositeToCompositeContainer.clear();
    this.mapActionsBindingToComposite.clear();
    this.instantiatedCompositeItems.forEach((compositeItem) => {
      compositeItem.composite.dispose();
      dispose(compositeItem.disposable);
    });
    this.instantiatedCompositeItems.clear();
    super.dispose();
  }
}
let SidebarPart = (_a = class extends CompositePart {
  get preferredWidth() {
    const viewlet = this.getActivePaneComposite();
    if (!viewlet) {
      return;
    }
    const width = viewlet.getOptimalWidth();
    if (typeof width !== "number") {
      return;
    }
    return Math.max(width, 300);
  }
  get onDidPaneCompositeRegister() {
    return this.viewletRegistry.onDidRegister;
  }
  get onDidPaneCompositeOpen() {
    return Event.map(this.onDidCompositeOpen.event, (compositeEvent) => compositeEvent.composite);
  }
  get onDidPaneCompositeClose() {
    return this.onDidCompositeClose.event;
  }
  constructor(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, viewDescriptorService, contextKeyService, extensionService) {
    super(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, Registry.as(Extensions.Viewlets), _a.activeViewletSettingsKey, viewDescriptorService.getDefaultViewContainer(0).id, "sideBar", "viewlet", SIDE_BAR_TITLE_FOREGROUND, "workbench.parts.sidebar", { hasTitle: true, borderWidth: () => this.getColor(SIDE_BAR_BORDER) || this.getColor(contrastBorder) ? 1 : 0 });
    this.viewDescriptorService = viewDescriptorService;
    this.contextKeyService = contextKeyService;
    this.extensionService = extensionService;
    this.minimumWidth = 170;
    this.maximumWidth = Number.POSITIVE_INFINITY;
    this.minimumHeight = 0;
    this.maximumHeight = Number.POSITIVE_INFINITY;
    this.priority = 1;
    this.snap = true;
    this._onDidViewletDeregister = this._register(new Emitter());
    this.onDidPaneCompositeDeregister = this._onDidViewletDeregister.event;
    this.viewletRegistry = Registry.as(Extensions.Viewlets);
    this.sideBarFocusContextKey = SidebarFocusContext.bindTo(this.contextKeyService);
    this.activeViewletContextKey = ActiveViewletContext.bindTo(this.contextKeyService);
    this.blockOpeningViewlet = false;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.onDidPaneCompositeOpen((viewlet) => {
      this.activeViewletContextKey.set(viewlet.getId());
    }));
    this._register(this.onDidPaneCompositeClose((viewlet) => {
      if (this.activeViewletContextKey.get() === viewlet.getId()) {
        this.activeViewletContextKey.reset();
      }
    }));
    this._register(this.registry.onDidDeregister(async (viewletDescriptor) => {
      var _a2, _b2;
      const activeContainers = this.viewDescriptorService.getViewContainersByLocation(0).filter((container) => this.viewDescriptorService.getViewContainerModel(container).activeViewDescriptors.length > 0);
      if (activeContainers.length) {
        if (((_a2 = this.getActiveComposite()) == null ? void 0 : _a2.getId()) === viewletDescriptor.id) {
          const defaultViewletId = (_b2 = this.viewDescriptorService.getDefaultViewContainer(0)) == null ? void 0 : _b2.id;
          const containerToOpen = activeContainers.filter((c) => c.id === defaultViewletId)[0] || activeContainers[0];
          await this.openPaneComposite(containerToOpen.id);
        }
      } else {
        this.layoutService.setPartHidden(true, "workbench.parts.sidebar");
      }
      this.removeComposite(viewletDescriptor.id);
      this._onDidViewletDeregister.fire(viewletDescriptor);
    }));
  }
  create(parent) {
    this.element = parent;
    super.create(parent);
    const focusTracker = this._register(trackFocus(parent));
    this._register(focusTracker.onDidFocus(() => this.sideBarFocusContextKey.set(true)));
    this._register(focusTracker.onDidBlur(() => this.sideBarFocusContextKey.set(false)));
  }
  createTitleArea(parent) {
    const titleArea = super.createTitleArea(parent);
    this._register(addDisposableListener(titleArea, EventType.CONTEXT_MENU, (e) => {
      this.onTitleAreaContextMenu(new StandardMouseEvent(e));
    }));
    this._register(Gesture.addTarget(titleArea));
    this._register(addDisposableListener(titleArea, EventType$1.Contextmenu, (e) => {
      this.onTitleAreaContextMenu(new StandardMouseEvent(e));
    }));
    this.titleLabelElement.draggable = true;
    const draggedItemProvider = () => {
      const activeViewlet = this.getActivePaneComposite();
      return { type: "composite", id: activeViewlet.getId() };
    };
    this._register(CompositeDragAndDropObserver.INSTANCE.registerDraggable(this.titleLabelElement, draggedItemProvider, {}));
    return titleArea;
  }
  updateStyles() {
    super.updateStyles();
    const container = assertIsDefined(this.getContainer());
    container.style.backgroundColor = this.getColor(SIDE_BAR_BACKGROUND) || "";
    container.style.color = this.getColor(SIDE_BAR_FOREGROUND) || "";
    const borderColor = this.getColor(SIDE_BAR_BORDER) || this.getColor(contrastBorder);
    const isPositionLeft = this.layoutService.getSideBarPosition() === 0;
    container.style.borderRightWidth = borderColor && isPositionLeft ? "1px" : "";
    container.style.borderRightStyle = borderColor && isPositionLeft ? "solid" : "";
    container.style.borderRightColor = isPositionLeft ? borderColor || "" : "";
    container.style.borderLeftWidth = borderColor && !isPositionLeft ? "1px" : "";
    container.style.borderLeftStyle = borderColor && !isPositionLeft ? "solid" : "";
    container.style.borderLeftColor = !isPositionLeft ? borderColor || "" : "";
    container.style.outlineColor = this.getColor(SIDE_BAR_DRAG_AND_DROP_BACKGROUND) ?? "";
  }
  layout(width, height, top, left) {
    if (!this.layoutService.isVisible("workbench.parts.sidebar")) {
      return;
    }
    super.layout(width, height, top, left);
  }
  getActivePaneComposite() {
    return this.getActiveComposite();
  }
  getLastActivePaneCompositeId() {
    return this.getLastActiveCompositeId();
  }
  hideActivePaneComposite() {
    this.hideActiveComposite();
  }
  async openPaneComposite(id, focus) {
    if (typeof id === "string" && this.getPaneComposite(id)) {
      return this.doOpenViewlet(id, focus);
    }
    await this.extensionService.whenInstalledExtensionsRegistered();
    if (typeof id === "string" && this.getPaneComposite(id)) {
      return this.doOpenViewlet(id, focus);
    }
    return void 0;
  }
  getPaneComposites() {
    return this.viewletRegistry.getPaneComposites().sort((v1, v2) => {
      if (typeof v1.order !== "number") {
        return -1;
      }
      if (typeof v2.order !== "number") {
        return 1;
      }
      return v1.order - v2.order;
    });
  }
  getPaneComposite(id) {
    return this.getPaneComposites().filter((viewlet) => viewlet.id === id)[0];
  }
  doOpenViewlet(id, focus) {
    if (this.blockOpeningViewlet) {
      return void 0;
    }
    if (!this.layoutService.isVisible("workbench.parts.sidebar")) {
      try {
        this.blockOpeningViewlet = true;
        this.layoutService.setPartHidden(false, "workbench.parts.sidebar");
      } finally {
        this.blockOpeningViewlet = false;
      }
    }
    return this.openComposite(id, focus);
  }
  getTitleAreaDropDownAnchorAlignment() {
    return this.layoutService.getSideBarPosition() === 0 ? 0 : 1;
  }
  onTitleAreaContextMenu(event) {
    const activeViewlet = this.getActivePaneComposite();
    if (activeViewlet) {
      const contextMenuActions = activeViewlet ? activeViewlet.getContextMenuActions() : [];
      if (contextMenuActions.length) {
        this.contextMenuService.showContextMenu({
          getAnchor: () => event,
          getActions: () => contextMenuActions.slice(),
          getActionViewItem: (action) => this.actionViewItemProvider(action),
          actionRunner: activeViewlet.getActionRunner(),
          skipTelemetry: true
        });
      }
    }
  }
  toJSON() {
    return {
      type: "workbench.parts.sidebar"
    };
  }
}, _a.activeViewletSettingsKey = "workbench.sidebar.activeviewletid", _a);
SidebarPart = __decorate([
  __param(0, INotificationService),
  __param(1, IStorageService),
  __param(2, IContextMenuService),
  __param(3, IWorkbenchLayoutService),
  __param(4, IKeybindingService),
  __param(5, IInstantiationService),
  __param(6, IThemeService),
  __param(7, IViewDescriptorService),
  __param(8, IContextKeyService),
  __param(9, IExtensionService)
], SidebarPart);
const VIEWS_LOG_ID = "viewsLog";
const VIEWS_LOG_NAME = localize("views log", "Views");
function getViewsLogFile(environmentService) {
  return joinPath(environmentService.windowLogsPath, "views.log");
}
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "_workbench.output.showViewsLog",
      title: { value: "Show Views Log", original: "Show Views Log" },
      category: Categories.Developer,
      f1: true
    });
  }
  async run(servicesAccessor) {
    const loggerService = servicesAccessor.get(ILoggerService);
    const outputService = servicesAccessor.get(IOutputService);
    const environmentService = servicesAccessor.get(IWorkbenchEnvironmentService);
    loggerService.setVisibility(getViewsLogFile(environmentService), true);
    outputService.showChannel(VIEWS_LOG_ID);
  }
});
function getViewsStateStorageId(viewContainerStorageId) {
  return `${viewContainerStorageId}.hidden`;
}
let ViewDescriptorsState = class ViewDescriptorsState2 extends Disposable {
  constructor(viewContainerStorageId, viewContainerName, storageService, loggerService, workbenchEnvironmentService) {
    super();
    this.viewContainerName = viewContainerName;
    this.storageService = storageService;
    this._onDidChangeStoredState = this._register(new Emitter());
    this.onDidChangeStoredState = this._onDidChangeStoredState.event;
    this.logger = loggerService.createLogger(getViewsLogFile(workbenchEnvironmentService), { id: VIEWS_LOG_ID, name: VIEWS_LOG_NAME, hidden: true });
    this.globalViewsStateStorageId = getViewsStateStorageId(viewContainerStorageId);
    this.workspaceViewsStateStorageId = viewContainerStorageId;
    this._register(this.storageService.onDidChangeValue((e) => this.onDidStorageChange(e)));
    this.state = this.initialize();
  }
  set(id, state) {
    this.state.set(id, state);
  }
  get(id) {
    return this.state.get(id);
  }
  updateState(viewDescriptors) {
    this.updateWorkspaceState(viewDescriptors);
    this.updateGlobalState(viewDescriptors);
  }
  updateWorkspaceState(viewDescriptors) {
    const storedViewsStates = this.getStoredWorkspaceState();
    for (const viewDescriptor2 of viewDescriptors) {
      const viewState = this.get(viewDescriptor2.id);
      if (viewState) {
        storedViewsStates[viewDescriptor2.id] = {
          collapsed: !!viewState.collapsed,
          isHidden: !viewState.visibleWorkspace,
          size: viewState.size,
          order: viewDescriptor2.workspace && viewState ? viewState.order : void 0
        };
      }
    }
    if (Object.keys(storedViewsStates).length > 0) {
      this.storageService.store(this.workspaceViewsStateStorageId, JSON.stringify(storedViewsStates), 1, 1);
    } else {
      this.storageService.remove(this.workspaceViewsStateStorageId, 1);
    }
  }
  updateGlobalState(viewDescriptors) {
    const storedGlobalState = this.getStoredGlobalState();
    for (const viewDescriptor2 of viewDescriptors) {
      const state = this.get(viewDescriptor2.id);
      storedGlobalState.set(viewDescriptor2.id, {
        id: viewDescriptor2.id,
        isHidden: state && viewDescriptor2.canToggleVisibility ? !state.visibleGlobal : false,
        order: !viewDescriptor2.workspace && state ? state.order : void 0
      });
    }
    this.setStoredGlobalState(storedGlobalState);
  }
  onDidStorageChange(e) {
    if (e.key === this.globalViewsStateStorageId && e.scope === 0 && this.globalViewsStatesValue !== this.getStoredGlobalViewsStatesValue()) {
      this._globalViewsStatesValue = void 0;
      const storedViewsVisibilityStates = this.getStoredGlobalState();
      const storedWorkspaceViewsStates = this.getStoredWorkspaceState();
      const changedStates = [];
      for (const [id, storedState] of storedViewsVisibilityStates) {
        const state = this.get(id);
        if (state) {
          if (state.visibleGlobal !== !storedState.isHidden) {
            if (!storedState.isHidden) {
              this.logger.info(`View visibility state changed: ${id} is now visible`, this.viewContainerName);
            }
            changedStates.push({ id, visible: !storedState.isHidden });
          }
        } else {
          const workspaceViewState = storedWorkspaceViewsStates[id];
          this.set(id, {
            active: false,
            visibleGlobal: !storedState.isHidden,
            visibleWorkspace: isUndefined(workspaceViewState == null ? void 0 : workspaceViewState.isHidden) ? void 0 : !(workspaceViewState == null ? void 0 : workspaceViewState.isHidden),
            collapsed: workspaceViewState == null ? void 0 : workspaceViewState.collapsed,
            order: workspaceViewState == null ? void 0 : workspaceViewState.order,
            size: workspaceViewState == null ? void 0 : workspaceViewState.size
          });
        }
      }
      if (changedStates.length) {
        this._onDidChangeStoredState.fire(changedStates);
        for (const changedState of changedStates) {
          const state = this.get(changedState.id);
          if (state) {
            state.visibleGlobal = changedState.visible;
          }
        }
      }
    }
  }
  initialize() {
    const viewStates = /* @__PURE__ */ new Map();
    const workspaceViewsStates = this.getStoredWorkspaceState();
    for (const id of Object.keys(workspaceViewsStates)) {
      const workspaceViewState = workspaceViewsStates[id];
      viewStates.set(id, {
        active: false,
        visibleGlobal: void 0,
        visibleWorkspace: isUndefined(workspaceViewState.isHidden) ? void 0 : !workspaceViewState.isHidden,
        collapsed: workspaceViewState.collapsed,
        order: workspaceViewState.order,
        size: workspaceViewState.size
      });
    }
    const value = this.storageService.get(this.globalViewsStateStorageId, 1, "[]");
    const { state: workspaceVisibilityStates } = this.parseStoredGlobalState(value);
    if (workspaceVisibilityStates.size > 0) {
      for (const { id, isHidden } of workspaceVisibilityStates.values()) {
        const viewState = viewStates.get(id);
        if (viewState) {
          if (isUndefined(viewState.visibleWorkspace)) {
            viewState.visibleWorkspace = !isHidden;
          }
        } else {
          viewStates.set(id, {
            active: false,
            collapsed: void 0,
            visibleGlobal: void 0,
            visibleWorkspace: !isHidden
          });
        }
      }
      this.storageService.remove(this.globalViewsStateStorageId, 1);
    }
    const { state, hasDuplicates } = this.parseStoredGlobalState(this.globalViewsStatesValue);
    if (hasDuplicates) {
      this.setStoredGlobalState(state);
    }
    for (const { id, isHidden, order } of state.values()) {
      const viewState = viewStates.get(id);
      if (viewState) {
        viewState.visibleGlobal = !isHidden;
        if (!isUndefined(order)) {
          viewState.order = order;
        }
      } else {
        viewStates.set(id, {
          active: false,
          visibleGlobal: !isHidden,
          order,
          collapsed: void 0,
          visibleWorkspace: void 0
        });
      }
    }
    return viewStates;
  }
  getStoredWorkspaceState() {
    return JSON.parse(this.storageService.get(this.workspaceViewsStateStorageId, 1, "{}"));
  }
  getStoredGlobalState() {
    return this.parseStoredGlobalState(this.globalViewsStatesValue).state;
  }
  setStoredGlobalState(storedGlobalState) {
    this.globalViewsStatesValue = JSON.stringify([...storedGlobalState.values()]);
  }
  parseStoredGlobalState(value) {
    const storedValue = JSON.parse(value);
    let hasDuplicates = false;
    const state = storedValue.reduce((result, storedState) => {
      if (typeof storedState === "string") {
        hasDuplicates = hasDuplicates || result.has(storedState);
        result.set(storedState, { id: storedState, isHidden: true });
      } else {
        hasDuplicates = hasDuplicates || result.has(storedState.id);
        result.set(storedState.id, storedState);
      }
      return result;
    }, /* @__PURE__ */ new Map());
    return { state, hasDuplicates };
  }
  get globalViewsStatesValue() {
    if (!this._globalViewsStatesValue) {
      this._globalViewsStatesValue = this.getStoredGlobalViewsStatesValue();
    }
    return this._globalViewsStatesValue;
  }
  set globalViewsStatesValue(globalViewsStatesValue) {
    if (this.globalViewsStatesValue !== globalViewsStatesValue) {
      this._globalViewsStatesValue = globalViewsStatesValue;
      this.setStoredGlobalViewsStatesValue(globalViewsStatesValue);
    }
  }
  getStoredGlobalViewsStatesValue() {
    return this.storageService.get(this.globalViewsStateStorageId, 0, "[]");
  }
  setStoredGlobalViewsStatesValue(value) {
    this.storageService.store(this.globalViewsStateStorageId, value, 0, 0);
  }
};
ViewDescriptorsState = __decorate([
  __param(2, IStorageService),
  __param(3, ILoggerService),
  __param(4, IWorkbenchEnvironmentService)
], ViewDescriptorsState);
let ViewContainerModel = class ViewContainerModel2 extends Disposable {
  get title() {
    return this._title;
  }
  get icon() {
    return this._icon;
  }
  get keybindingId() {
    return this._keybindingId;
  }
  get allViewDescriptors() {
    return this.viewDescriptorItems.map((item) => item.viewDescriptor);
  }
  get activeViewDescriptors() {
    return this.viewDescriptorItems.filter((item) => item.state.active).map((item) => item.viewDescriptor);
  }
  get visibleViewDescriptors() {
    return this.viewDescriptorItems.filter((item) => this.isViewDescriptorVisible(item)).map((item) => item.viewDescriptor);
  }
  constructor(viewContainer, instantiationService, contextKeyService, loggerService, workbenchEnvironmentService) {
    super();
    this.viewContainer = viewContainer;
    this.contextKeyService = contextKeyService;
    this.contextKeys = new CounterSet();
    this.viewDescriptorItems = [];
    this._onDidChangeContainerInfo = this._register(new Emitter());
    this.onDidChangeContainerInfo = this._onDidChangeContainerInfo.event;
    this._onDidChangeAllViewDescriptors = this._register(new Emitter());
    this.onDidChangeAllViewDescriptors = this._onDidChangeAllViewDescriptors.event;
    this._onDidChangeActiveViewDescriptors = this._register(new Emitter());
    this.onDidChangeActiveViewDescriptors = this._onDidChangeActiveViewDescriptors.event;
    this._onDidAddVisibleViewDescriptors = this._register(new Emitter());
    this.onDidAddVisibleViewDescriptors = this._onDidAddVisibleViewDescriptors.event;
    this._onDidRemoveVisibleViewDescriptors = this._register(new Emitter());
    this.onDidRemoveVisibleViewDescriptors = this._onDidRemoveVisibleViewDescriptors.event;
    this._onDidMoveVisibleViewDescriptors = this._register(new Emitter());
    this.onDidMoveVisibleViewDescriptors = this._onDidMoveVisibleViewDescriptors.event;
    this.logger = loggerService.createLogger(getViewsLogFile(workbenchEnvironmentService), { id: VIEWS_LOG_ID, name: VIEWS_LOG_NAME, hidden: true });
    this._register(Event.filter(contextKeyService.onDidChangeContext, (e) => e.affectsSome(this.contextKeys))(() => this.onDidChangeContext()));
    this.viewDescriptorsState = this._register(instantiationService.createInstance(ViewDescriptorsState, viewContainer.storageId || `${viewContainer.id}.state`, typeof viewContainer.title === "string" ? viewContainer.title : viewContainer.title.original));
    this._register(this.viewDescriptorsState.onDidChangeStoredState((items) => this.updateVisibility(items)));
    this.updateContainerInfo();
  }
  updateContainerInfo() {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const useDefaultContainerInfo = this.viewContainer.alwaysUseContainerInfo || this.visibleViewDescriptors.length === 0 || this.visibleViewDescriptors.some(
      (v) => Registry.as(Extensions$1.ViewsRegistry).getViewContainer(v.id) === this.viewContainer
    );
    const title = useDefaultContainerInfo ? typeof this.viewContainer.title === "string" ? this.viewContainer.title : this.viewContainer.title.value : ((_a2 = this.visibleViewDescriptors[0]) == null ? void 0 : _a2.containerTitle) || ((_b2 = this.visibleViewDescriptors[0]) == null ? void 0 : _b2.name) || "";
    let titleChanged = false;
    if (this._title !== title) {
      this._title = title;
      titleChanged = true;
    }
    const icon = useDefaultContainerInfo ? this.viewContainer.icon : ((_c2 = this.visibleViewDescriptors[0]) == null ? void 0 : _c2.containerIcon) || defaultViewIcon;
    let iconChanged = false;
    if (!this.isEqualIcon(icon)) {
      this._icon = icon;
      iconChanged = true;
    }
    const keybindingId = ((_d2 = this.viewContainer.openCommandActionDescriptor) == null ? void 0 : _d2.id) ?? ((_f2 = (_e2 = this.activeViewDescriptors.find((v) => v.openCommandActionDescriptor)) == null ? void 0 : _e2.openCommandActionDescriptor) == null ? void 0 : _f2.id);
    let keybindingIdChanged = false;
    if (this._keybindingId !== keybindingId) {
      this._keybindingId = keybindingId;
      keybindingIdChanged = true;
    }
    if (titleChanged || iconChanged || keybindingIdChanged) {
      this._onDidChangeContainerInfo.fire({ title: titleChanged, icon: iconChanged, keybindingId: keybindingIdChanged });
    }
  }
  isEqualIcon(icon) {
    if (URI.isUri(icon)) {
      return URI.isUri(this._icon) && isEqual(icon, this._icon);
    } else if (ThemeIcon.isThemeIcon(icon)) {
      return ThemeIcon.isThemeIcon(this._icon) && ThemeIcon.isEqual(icon, this._icon);
    }
    return icon === this._icon;
  }
  isVisible(id) {
    const viewDescriptorItem = this.viewDescriptorItems.find((v) => v.viewDescriptor.id === id);
    if (!viewDescriptorItem) {
      throw new Error(`Unknown view ${id}`);
    }
    return this.isViewDescriptorVisible(viewDescriptorItem);
  }
  setVisible(id, visible) {
    this.updateVisibility([{ id, visible }]);
  }
  updateVisibility(viewDescriptors) {
    const viewDescriptorItemsToHide = coalesce(viewDescriptors.filter(({ visible }) => !visible).map(({ id }) => this.findAndIgnoreIfNotFound(id)));
    const removed = [];
    for (const { viewDescriptorItem, visibleIndex } of viewDescriptorItemsToHide) {
      if (this.updateViewDescriptorItemVisibility(viewDescriptorItem, false)) {
        removed.push({ viewDescriptor: viewDescriptorItem.viewDescriptor, index: visibleIndex });
      }
    }
    if (removed.length) {
      this.broadCastRemovedVisibleViewDescriptors(removed);
    }
    const added = [];
    for (const { id, visible } of viewDescriptors) {
      if (!visible) {
        continue;
      }
      const foundViewDescriptor = this.findAndIgnoreIfNotFound(id);
      if (!foundViewDescriptor) {
        continue;
      }
      const { viewDescriptorItem, visibleIndex } = foundViewDescriptor;
      if (this.updateViewDescriptorItemVisibility(viewDescriptorItem, true)) {
        added.push({ index: visibleIndex, viewDescriptor: viewDescriptorItem.viewDescriptor, size: viewDescriptorItem.state.size, collapsed: !!viewDescriptorItem.state.collapsed });
      }
    }
    if (added.length) {
      this.broadCastAddedVisibleViewDescriptors(added);
    }
  }
  updateViewDescriptorItemVisibility(viewDescriptorItem, visible) {
    if (!viewDescriptorItem.viewDescriptor.canToggleVisibility) {
      return false;
    }
    if (this.isViewDescriptorVisibleWhenActive(viewDescriptorItem) === visible) {
      return false;
    }
    if (viewDescriptorItem.viewDescriptor.workspace) {
      viewDescriptorItem.state.visibleWorkspace = visible;
    } else {
      viewDescriptorItem.state.visibleGlobal = visible;
      if (visible) {
        this.logger.info(`Showing view ${viewDescriptorItem.viewDescriptor.id} in the container ${this.viewContainer.id}`);
      }
    }
    return this.isViewDescriptorVisible(viewDescriptorItem) === visible;
  }
  isCollapsed(id) {
    return !!this.find(id).viewDescriptorItem.state.collapsed;
  }
  setCollapsed(id, collapsed) {
    const { viewDescriptorItem } = this.find(id);
    if (viewDescriptorItem.state.collapsed !== collapsed) {
      viewDescriptorItem.state.collapsed = collapsed;
    }
    this.viewDescriptorsState.updateState(this.allViewDescriptors);
  }
  getSize(id) {
    return this.find(id).viewDescriptorItem.state.size;
  }
  setSizes(newSizes) {
    for (const { id, size: size2 } of newSizes) {
      const { viewDescriptorItem } = this.find(id);
      if (viewDescriptorItem.state.size !== size2) {
        viewDescriptorItem.state.size = size2;
      }
    }
    this.viewDescriptorsState.updateState(this.allViewDescriptors);
  }
  move(from, to) {
    const fromIndex = this.viewDescriptorItems.findIndex((v) => v.viewDescriptor.id === from);
    const toIndex = this.viewDescriptorItems.findIndex((v) => v.viewDescriptor.id === to);
    const fromViewDescriptor = this.viewDescriptorItems[fromIndex];
    const toViewDescriptor = this.viewDescriptorItems[toIndex];
    move(this.viewDescriptorItems, fromIndex, toIndex);
    for (let index = 0; index < this.viewDescriptorItems.length; index++) {
      this.viewDescriptorItems[index].state.order = index;
    }
    this.broadCastMovedViewDescriptors({ index: fromIndex, viewDescriptor: fromViewDescriptor.viewDescriptor }, { index: toIndex, viewDescriptor: toViewDescriptor.viewDescriptor });
  }
  add(addedViewDescriptorStates) {
    const addedItems = [];
    for (const addedViewDescriptorState of addedViewDescriptorStates) {
      const viewDescriptor2 = addedViewDescriptorState.viewDescriptor;
      if (viewDescriptor2.when) {
        for (const key of viewDescriptor2.when.keys()) {
          this.contextKeys.add(key);
        }
      }
      let state = this.viewDescriptorsState.get(viewDescriptor2.id);
      if (state) {
        if (viewDescriptor2.workspace) {
          state.visibleWorkspace = isUndefinedOrNull(addedViewDescriptorState.visible) ? isUndefinedOrNull(state.visibleWorkspace) ? !viewDescriptor2.hideByDefault : state.visibleWorkspace : addedViewDescriptorState.visible;
        } else {
          const isVisible = state.visibleGlobal;
          state.visibleGlobal = isUndefinedOrNull(addedViewDescriptorState.visible) ? isUndefinedOrNull(state.visibleGlobal) ? !viewDescriptor2.hideByDefault : state.visibleGlobal : addedViewDescriptorState.visible;
          if (state.visibleGlobal && !isVisible) {
            this.logger.info(`Added view ${viewDescriptor2.id} in the container ${this.viewContainer.id} and showing it.`, `${isVisible}`, `${viewDescriptor2.hideByDefault}`, `${addedViewDescriptorState.visible}`);
          }
        }
        state.collapsed = isUndefinedOrNull(addedViewDescriptorState.collapsed) ? isUndefinedOrNull(state.collapsed) ? !!viewDescriptor2.collapsed : state.collapsed : addedViewDescriptorState.collapsed;
      } else {
        state = {
          active: false,
          visibleGlobal: isUndefinedOrNull(addedViewDescriptorState.visible) ? !viewDescriptor2.hideByDefault : addedViewDescriptorState.visible,
          visibleWorkspace: isUndefinedOrNull(addedViewDescriptorState.visible) ? !viewDescriptor2.hideByDefault : addedViewDescriptorState.visible,
          collapsed: isUndefinedOrNull(addedViewDescriptorState.collapsed) ? !!viewDescriptor2.collapsed : addedViewDescriptorState.collapsed
        };
      }
      this.viewDescriptorsState.set(viewDescriptor2.id, state);
      state.active = this.contextKeyService.contextMatchesRules(viewDescriptor2.when);
      addedItems.push({ viewDescriptor: viewDescriptor2, state });
    }
    this.viewDescriptorItems.push(...addedItems);
    this.viewDescriptorItems.sort(this.compareViewDescriptors.bind(this));
    this._onDidChangeAllViewDescriptors.fire({ added: addedItems.map(({ viewDescriptor: viewDescriptor2 }) => viewDescriptor2), removed: [] });
    const addedActiveItems = [];
    for (const viewDescriptorItem of addedItems) {
      if (viewDescriptorItem.state.active) {
        addedActiveItems.push({ viewDescriptorItem, visible: this.isViewDescriptorVisible(viewDescriptorItem) });
      }
    }
    if (addedActiveItems.length) {
      this._onDidChangeActiveViewDescriptors.fire({ added: addedActiveItems.map(({ viewDescriptorItem }) => viewDescriptorItem.viewDescriptor), removed: [] });
    }
    const addedVisibleDescriptors = [];
    for (const { viewDescriptorItem, visible } of addedActiveItems) {
      if (visible && this.isViewDescriptorVisible(viewDescriptorItem)) {
        const { visibleIndex } = this.find(viewDescriptorItem.viewDescriptor.id);
        addedVisibleDescriptors.push({ index: visibleIndex, viewDescriptor: viewDescriptorItem.viewDescriptor, size: viewDescriptorItem.state.size, collapsed: !!viewDescriptorItem.state.collapsed });
      }
    }
    this.broadCastAddedVisibleViewDescriptors(addedVisibleDescriptors);
  }
  remove(viewDescriptors) {
    const removed = [];
    const removedItems = [];
    const removedActiveDescriptors = [];
    const removedVisibleDescriptors = [];
    for (const viewDescriptor2 of viewDescriptors) {
      if (viewDescriptor2.when) {
        for (const key of viewDescriptor2.when.keys()) {
          this.contextKeys.delete(key);
        }
      }
      const index = this.viewDescriptorItems.findIndex((i) => i.viewDescriptor.id === viewDescriptor2.id);
      if (index !== -1) {
        removed.push(viewDescriptor2);
        const viewDescriptorItem = this.viewDescriptorItems[index];
        if (viewDescriptorItem.state.active) {
          removedActiveDescriptors.push(viewDescriptorItem.viewDescriptor);
        }
        if (this.isViewDescriptorVisible(viewDescriptorItem)) {
          const { visibleIndex } = this.find(viewDescriptorItem.viewDescriptor.id);
          removedVisibleDescriptors.push({ index: visibleIndex, viewDescriptor: viewDescriptorItem.viewDescriptor });
        }
        removedItems.push(viewDescriptorItem);
      }
    }
    removedItems.forEach((item) => this.viewDescriptorItems.splice(this.viewDescriptorItems.indexOf(item), 1));
    this.broadCastRemovedVisibleViewDescriptors(removedVisibleDescriptors);
    if (removedActiveDescriptors.length) {
      this._onDidChangeActiveViewDescriptors.fire({ added: [], removed: removedActiveDescriptors });
    }
    if (removed.length) {
      this._onDidChangeAllViewDescriptors.fire({ added: [], removed });
    }
  }
  onDidChangeContext() {
    const addedActiveItems = [];
    const removedActiveItems = [];
    for (const item of this.viewDescriptorItems) {
      const wasActive = item.state.active;
      const isActive = this.contextKeyService.contextMatchesRules(item.viewDescriptor.when);
      if (wasActive !== isActive) {
        if (isActive) {
          addedActiveItems.push({ item, visibleWhenActive: this.isViewDescriptorVisibleWhenActive(item) });
        } else {
          removedActiveItems.push(item);
        }
      }
    }
    const removedVisibleDescriptors = [];
    for (const item of removedActiveItems) {
      if (this.isViewDescriptorVisible(item)) {
        const { visibleIndex } = this.find(item.viewDescriptor.id);
        removedVisibleDescriptors.push({ index: visibleIndex, viewDescriptor: item.viewDescriptor });
      }
    }
    removedActiveItems.forEach((item) => item.state.active = false);
    addedActiveItems.forEach(({ item }) => item.state.active = true);
    this.broadCastRemovedVisibleViewDescriptors(removedVisibleDescriptors);
    if (addedActiveItems.length || removedActiveItems.length) {
      this._onDidChangeActiveViewDescriptors.fire({ added: addedActiveItems.map(({ item }) => item.viewDescriptor), removed: removedActiveItems.map((item) => item.viewDescriptor) });
    }
    const addedVisibleDescriptors = [];
    for (const { item, visibleWhenActive } of addedActiveItems) {
      if (visibleWhenActive && this.isViewDescriptorVisible(item)) {
        const { visibleIndex } = this.find(item.viewDescriptor.id);
        addedVisibleDescriptors.push({ index: visibleIndex, viewDescriptor: item.viewDescriptor, size: item.state.size, collapsed: !!item.state.collapsed });
      }
    }
    this.broadCastAddedVisibleViewDescriptors(addedVisibleDescriptors);
  }
  broadCastAddedVisibleViewDescriptors(added) {
    if (added.length) {
      this._onDidAddVisibleViewDescriptors.fire(added.sort((a, b) => a.index - b.index));
      this.updateState(`Added views:${added.map((v) => v.viewDescriptor.id).join(",")} in ${this.viewContainer.id}`);
    }
  }
  broadCastRemovedVisibleViewDescriptors(removed) {
    if (removed.length) {
      this._onDidRemoveVisibleViewDescriptors.fire(removed.sort((a, b) => b.index - a.index));
      this.updateState(`Removed views:${removed.map((v) => v.viewDescriptor.id).join(",")} from ${this.viewContainer.id}`);
    }
  }
  broadCastMovedViewDescriptors(from, to) {
    this._onDidMoveVisibleViewDescriptors.fire({ from, to });
    this.updateState(`Moved view ${from.viewDescriptor.id} to ${to.viewDescriptor.id} in ${this.viewContainer.id}`);
  }
  updateState(reason) {
    this.logger.info(reason);
    this.viewDescriptorsState.updateState(this.allViewDescriptors);
    this.updateContainerInfo();
  }
  isViewDescriptorVisible(viewDescriptorItem) {
    if (!viewDescriptorItem.state.active) {
      return false;
    }
    return this.isViewDescriptorVisibleWhenActive(viewDescriptorItem);
  }
  isViewDescriptorVisibleWhenActive(viewDescriptorItem) {
    if (viewDescriptorItem.viewDescriptor.workspace) {
      return !!viewDescriptorItem.state.visibleWorkspace;
    }
    return !!viewDescriptorItem.state.visibleGlobal;
  }
  find(id) {
    const result = this.findAndIgnoreIfNotFound(id);
    if (result) {
      return result;
    }
    throw new Error(`view descriptor ${id} not found`);
  }
  findAndIgnoreIfNotFound(id) {
    for (let i = 0, visibleIndex = 0; i < this.viewDescriptorItems.length; i++) {
      const viewDescriptorItem = this.viewDescriptorItems[i];
      if (viewDescriptorItem.viewDescriptor.id === id) {
        return { index: i, visibleIndex, viewDescriptorItem };
      }
      if (this.isViewDescriptorVisible(viewDescriptorItem)) {
        visibleIndex++;
      }
    }
    return void 0;
  }
  compareViewDescriptors(a, b) {
    if (a.viewDescriptor.id === b.viewDescriptor.id) {
      return 0;
    }
    return this.getViewOrder(a) - this.getViewOrder(b) || this.getGroupOrderResult(a.viewDescriptor, b.viewDescriptor);
  }
  getViewOrder(viewDescriptorItem) {
    const viewOrder = typeof viewDescriptorItem.state.order === "number" ? viewDescriptorItem.state.order : viewDescriptorItem.viewDescriptor.order;
    return typeof viewOrder === "number" ? viewOrder : Number.MAX_VALUE;
  }
  getGroupOrderResult(a, b) {
    if (!a.group || !b.group) {
      return 0;
    }
    if (a.group === b.group) {
      return 0;
    }
    return a.group < b.group ? -1 : 1;
  }
};
ViewContainerModel = __decorate([
  __param(1, IInstantiationService),
  __param(2, IContextKeyService),
  __param(3, ILoggerService),
  __param(4, IWorkbenchEnvironmentService)
], ViewContainerModel);
function getViewContainerStorageId(viewContainerId) {
  return `${viewContainerId}.state`;
}
let ViewDescriptorService = (_b = class extends Disposable {
  get viewContainers() {
    return this.viewContainersRegistry.all;
  }
  constructor(instantiationService, contextKeyService, storageService, extensionService, telemetryService) {
    super();
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.storageService = storageService;
    this.extensionService = extensionService;
    this.telemetryService = telemetryService;
    this._onDidChangeContainer = this._register(new Emitter());
    this.onDidChangeContainer = this._onDidChangeContainer.event;
    this._onDidChangeLocation = this._register(new Emitter());
    this.onDidChangeLocation = this._onDidChangeLocation.event;
    this._onDidChangeContainerLocation = this._register(new Emitter());
    this.onDidChangeContainerLocation = this._onDidChangeContainerLocation.event;
    this.viewContainerModels = this._register(new DisposableMap());
    this.viewsVisibilityActionDisposables = this._register(new DisposableMap());
    this._onDidChangeViewContainers = this._register(new Emitter());
    this.onDidChangeViewContainers = this._onDidChangeViewContainers.event;
    this.activeViewContextKeys = /* @__PURE__ */ new Map();
    this.movableViewContextKeys = /* @__PURE__ */ new Map();
    this.defaultViewLocationContextKeys = /* @__PURE__ */ new Map();
    this.defaultViewContainerLocationContextKeys = /* @__PURE__ */ new Map();
    this.viewContainersRegistry = Registry.as(Extensions$1.ViewContainersRegistry);
    this.viewsRegistry = Registry.as(Extensions$1.ViewsRegistry);
    this.migrateToViewsCustomizationsStorage();
    this.viewContainersCustomLocations = new Map(Object.entries(this.viewCustomizations.viewContainerLocations));
    this.viewDescriptorsCustomLocations = new Map(Object.entries(this.viewCustomizations.viewLocations));
    this.viewContainerBadgeEnablementStates = new Map(Object.entries(this.viewCustomizations.viewContainerBadgeEnablementStates));
    this.viewContainers.forEach((viewContainer) => this.onDidRegisterViewContainer(viewContainer));
    this._register(this.viewsRegistry.onViewsRegistered((views) => this.onDidRegisterViews(views)));
    this._register(this.viewsRegistry.onViewsDeregistered(({ views, viewContainer }) => this.onDidDeregisterViews(views, viewContainer)));
    this._register(this.viewsRegistry.onDidChangeContainer(({ views, from, to }) => this.onDidChangeDefaultContainer(views, from, to)));
    this._register(this.viewContainersRegistry.onDidRegister(({ viewContainer }) => {
      this.onDidRegisterViewContainer(viewContainer);
      this._onDidChangeViewContainers.fire({ added: [{ container: viewContainer, location: this.getViewContainerLocation(viewContainer) }], removed: [] });
    }));
    this._register(this.viewContainersRegistry.onDidDeregister(({ viewContainer }) => {
      this.onDidDeregisterViewContainer(viewContainer);
      this._onDidChangeViewContainers.fire({ removed: [{ container: viewContainer, location: this.getViewContainerLocation(viewContainer) }], added: [] });
    }));
    this._register(this.storageService.onDidChangeValue((e) => {
      this.onDidStorageChange(e);
    }));
    this.extensionService.whenInstalledExtensionsRegistered().then(() => this.whenExtensionsRegistered());
  }
  migrateToViewsCustomizationsStorage() {
    if (this.storageService.get(_b.VIEWS_CUSTOMIZATIONS, 0)) {
      return;
    }
    const viewContainerLocationsValue = this.storageService.get("views.cachedViewContainerLocations", 0);
    const viewDescriptorLocationsValue = this.storageService.get("views.cachedViewPositions", 0);
    if (!viewContainerLocationsValue && !viewDescriptorLocationsValue) {
      return;
    }
    const viewContainerLocations = viewContainerLocationsValue ? JSON.parse(viewContainerLocationsValue) : [];
    const viewDescriptorLocations = viewDescriptorLocationsValue ? JSON.parse(viewDescriptorLocationsValue) : [];
    const viewsCustomizations = {
      viewContainerLocations: viewContainerLocations.reduce((result, [id, location]) => {
        result[id] = location;
        return result;
      }, {}),
      viewLocations: viewDescriptorLocations.reduce((result, [id, { containerId }]) => {
        result[id] = containerId;
        return result;
      }, {}),
      viewContainerBadgeEnablementStates: {}
    };
    this.storageService.store(_b.VIEWS_CUSTOMIZATIONS, JSON.stringify(viewsCustomizations), 0, 0);
    this.storageService.remove("views.cachedViewContainerLocations", 0);
    this.storageService.remove("views.cachedViewPositions", 0);
  }
  registerGroupedViews(groupedViews) {
    for (const [containerId, views] of groupedViews.entries()) {
      const viewContainer = this.viewContainersRegistry.get(containerId);
      if (!viewContainer || !this.viewContainerModels.has(viewContainer)) {
        if (this.isGeneratedContainerId(containerId)) {
          const viewContainerLocation = this.viewContainersCustomLocations.get(containerId);
          if (viewContainerLocation !== void 0) {
            this.registerGeneratedViewContainer(viewContainerLocation, containerId);
          }
        }
        continue;
      }
      const viewsToAdd = views.filter((view) => this.getViewContainerModel(viewContainer).allViewDescriptors.filter((vd) => vd.id === view.id).length === 0);
      this.addViews(viewContainer, viewsToAdd);
    }
  }
  deregisterGroupedViews(groupedViews) {
    for (const [viewContainerId, views] of groupedViews.entries()) {
      const viewContainer = this.viewContainersRegistry.get(viewContainerId);
      if (!viewContainer || !this.viewContainerModels.has(viewContainer)) {
        continue;
      }
      this.removeViews(viewContainer, views);
    }
  }
  moveOrphanViewsToDefaultLocation() {
    for (const [viewId, containerId] of this.viewDescriptorsCustomLocations.entries()) {
      if (this.viewContainersRegistry.get(containerId)) {
        continue;
      }
      const viewContainer = this.viewsRegistry.getViewContainer(viewId);
      const viewDescriptor2 = this.getViewDescriptorById(viewId);
      if (viewContainer && viewDescriptor2) {
        this.addViews(viewContainer, [viewDescriptor2]);
      }
    }
  }
  whenExtensionsRegistered() {
    this.moveOrphanViewsToDefaultLocation();
    for (const viewContainerId of [...this.viewContainersCustomLocations.keys()]) {
      this.cleanUpGeneratedViewContainer(viewContainerId);
    }
    this.saveViewCustomizations();
    this.registerViewsVisibilityActions();
  }
  onDidRegisterViews(views) {
    this.contextKeyService.bufferChangeEvents(() => {
      views.forEach(({ views: views2, viewContainer }) => {
        const regroupedViews = this.regroupViews(viewContainer.id, views2);
        this.registerGroupedViews(regroupedViews);
        views2.forEach((viewDescriptor2) => this.getOrCreateMovableViewContextKey(viewDescriptor2).set(!!viewDescriptor2.canMoveView));
      });
    });
  }
  isGeneratedContainerId(id) {
    return id.startsWith(_b.COMMON_CONTAINER_ID_PREFIX);
  }
  onDidDeregisterViews(views, viewContainer) {
    const regroupedViews = this.regroupViews(viewContainer.id, views);
    this.deregisterGroupedViews(regroupedViews);
    this.contextKeyService.bufferChangeEvents(() => {
      views.forEach((viewDescriptor2) => this.getOrCreateMovableViewContextKey(viewDescriptor2).set(false));
    });
  }
  regroupViews(containerId, views) {
    const viewsByContainer = /* @__PURE__ */ new Map();
    for (const viewDescriptor2 of views) {
      const correctContainerId = this.viewDescriptorsCustomLocations.get(viewDescriptor2.id) ?? containerId;
      let containerViews = viewsByContainer.get(correctContainerId);
      if (!containerViews) {
        viewsByContainer.set(correctContainerId, containerViews = []);
      }
      containerViews.push(viewDescriptor2);
    }
    return viewsByContainer;
  }
  getViewDescriptorById(viewId) {
    return this.viewsRegistry.getView(viewId);
  }
  getViewLocationById(viewId) {
    const container = this.getViewContainerByViewId(viewId);
    if (container === null) {
      return null;
    }
    return this.getViewContainerLocation(container);
  }
  getViewContainerByViewId(viewId) {
    const containerId = this.viewDescriptorsCustomLocations.get(viewId);
    return containerId ? this.viewContainersRegistry.get(containerId) ?? null : this.getDefaultContainerById(viewId);
  }
  getViewContainerLocation(viewContainer) {
    return this.viewContainersCustomLocations.get(viewContainer.id) ?? this.getDefaultViewContainerLocation(viewContainer);
  }
  getDefaultViewContainerLocation(viewContainer) {
    return this.viewContainersRegistry.getViewContainerLocation(viewContainer);
  }
  getDefaultContainerById(viewId) {
    return this.viewsRegistry.getViewContainer(viewId) ?? null;
  }
  getViewContainerModel(container) {
    return this.getOrRegisterViewContainerModel(container);
  }
  getViewContainerById(id) {
    return this.viewContainersRegistry.get(id) || null;
  }
  getViewContainersByLocation(location) {
    return this.viewContainers.filter((v) => this.getViewContainerLocation(v) === location);
  }
  getDefaultViewContainer(location) {
    return this.viewContainersRegistry.getDefaultViewContainer(location);
  }
  moveViewContainerToLocation(viewContainer, location, requestedIndex) {
    this.moveViewContainerToLocationWithoutSaving(viewContainer, location, requestedIndex);
    this.saveViewCustomizations();
  }
  getViewContainerBadgeEnablementState(id) {
    return this.viewContainerBadgeEnablementStates.get(id) ?? true;
  }
  setViewContainerBadgeEnablementState(id, badgesEnabled) {
    this.viewContainerBadgeEnablementStates.set(id, badgesEnabled);
    this.saveViewCustomizations();
  }
  moveViewToLocation(view, location) {
    const container = this.registerGeneratedViewContainer(location);
    this.moveViewsToContainer([view], container);
  }
  moveViewsToContainer(views, viewContainer, visibilityState) {
    if (!views.length) {
      return;
    }
    const from = this.getViewContainerByViewId(views[0].id);
    const to = viewContainer;
    if (from && to && from !== to) {
      this.moveViewsWithoutSaving(views, from, to, visibilityState);
      this.cleanUpGeneratedViewContainer(from.id);
      this.saveViewCustomizations();
      this.reportMovedViews(views, from, to);
    }
  }
  reset() {
    for (const viewContainer of this.viewContainers) {
      const viewContainerModel = this.getViewContainerModel(viewContainer);
      for (const viewDescriptor2 of viewContainerModel.allViewDescriptors) {
        const defaultContainer = this.getDefaultContainerById(viewDescriptor2.id);
        const currentContainer = this.getViewContainerByViewId(viewDescriptor2.id);
        if (currentContainer && defaultContainer && currentContainer !== defaultContainer) {
          this.moveViewsWithoutSaving([viewDescriptor2], currentContainer, defaultContainer);
        }
      }
      const defaultContainerLocation = this.getDefaultViewContainerLocation(viewContainer);
      const currentContainerLocation = this.getViewContainerLocation(viewContainer);
      if (defaultContainerLocation !== null && currentContainerLocation !== defaultContainerLocation) {
        this.moveViewContainerToLocationWithoutSaving(viewContainer, defaultContainerLocation);
      }
      this.cleanUpGeneratedViewContainer(viewContainer.id);
    }
    this.viewContainersCustomLocations.clear();
    this.viewDescriptorsCustomLocations.clear();
    this.saveViewCustomizations();
  }
  isViewContainerRemovedPermanently(viewContainerId) {
    return this.isGeneratedContainerId(viewContainerId) && !this.viewContainersCustomLocations.has(viewContainerId);
  }
  onDidChangeDefaultContainer(views, from, to) {
    const viewsToMove = views.filter(
      (view) => !this.viewDescriptorsCustomLocations.has(view.id) || !this.viewContainers.includes(from) && this.viewDescriptorsCustomLocations.get(view.id) === from.id
    );
    if (viewsToMove.length) {
      this.moveViewsWithoutSaving(viewsToMove, from, to);
    }
  }
  reportMovedViews(views, from, to) {
    const containerToString = (container) => {
      if (container.id.startsWith(_b.COMMON_CONTAINER_ID_PREFIX)) {
        return "custom";
      }
      if (!container.extensionId) {
        return container.id;
      }
      return "extension";
    };
    const oldLocation = this.getViewContainerLocation(from);
    const newLocation = this.getViewContainerLocation(to);
    const viewCount = views.length;
    const fromContainer = containerToString(from);
    const toContainer = containerToString(to);
    const fromLocation = oldLocation === 1 ? "panel" : "sidebar";
    const toLocation = newLocation === 1 ? "panel" : "sidebar";
    this.telemetryService.publicLog2("viewDescriptorService.moveViews", { viewCount, fromContainer, toContainer, fromLocation, toLocation });
  }
  moveViewsWithoutSaving(views, from, to, visibilityState = ViewVisibilityState.Expand) {
    this.removeViews(from, views);
    this.addViews(to, views, visibilityState);
    const oldLocation = this.getViewContainerLocation(from);
    const newLocation = this.getViewContainerLocation(to);
    if (oldLocation !== newLocation) {
      this._onDidChangeLocation.fire({ views, from: oldLocation, to: newLocation });
    }
    this._onDidChangeContainer.fire({ views, from, to });
  }
  moveViewContainerToLocationWithoutSaving(viewContainer, location, requestedIndex) {
    const from = this.getViewContainerLocation(viewContainer);
    const to = location;
    if (from !== to) {
      const isGeneratedViewContainer = this.isGeneratedContainerId(viewContainer.id);
      const isDefaultViewContainerLocation = to === this.getDefaultViewContainerLocation(viewContainer);
      if (isGeneratedViewContainer || !isDefaultViewContainerLocation) {
        this.viewContainersCustomLocations.set(viewContainer.id, to);
      } else {
        this.viewContainersCustomLocations.delete(viewContainer.id);
      }
      this.getOrCreateDefaultViewContainerLocationContextKey(viewContainer).set(isGeneratedViewContainer || isDefaultViewContainerLocation);
      viewContainer.requestedIndex = requestedIndex;
      this._onDidChangeContainerLocation.fire({ viewContainer, from, to });
      const views = this.getViewsByContainer(viewContainer);
      this._onDidChangeLocation.fire({ views, from, to });
    }
  }
  cleanUpGeneratedViewContainer(viewContainerId) {
    var _a2;
    if (!this.isGeneratedContainerId(viewContainerId)) {
      return;
    }
    const viewContainer = this.getViewContainerById(viewContainerId);
    if (viewContainer && ((_a2 = this.getViewContainerModel(viewContainer)) == null ? void 0 : _a2.allViewDescriptors.length)) {
      return;
    }
    if ([...this.viewDescriptorsCustomLocations.values()].includes(viewContainerId)) {
      return;
    }
    if (viewContainer) {
      this.viewContainersRegistry.deregisterViewContainer(viewContainer);
    }
    this.viewContainersCustomLocations.delete(viewContainerId);
    this.viewContainerBadgeEnablementStates.delete(viewContainerId);
    this.storageService.remove(getViewsStateStorageId((viewContainer == null ? void 0 : viewContainer.storageId) || getViewContainerStorageId(viewContainerId)), 0);
  }
  registerGeneratedViewContainer(location, existingId) {
    const id = existingId || this.generateContainerId(location);
    const container = this.viewContainersRegistry.registerViewContainer({
      id,
      ctorDescriptor: new SyncDescriptor(ViewPaneContainer, [id, { mergeViewWithContainerWhenSingleView: true }]),
      title: id,
      icon: location === 0 ? defaultViewIcon : void 0,
      storageId: getViewContainerStorageId(id),
      hideIfEmpty: true
    }, location, { doNotRegisterOpenCommand: true });
    if (this.viewContainersCustomLocations.get(container.id) !== location) {
      this.viewContainersCustomLocations.set(container.id, location);
    }
    this.getOrCreateDefaultViewContainerLocationContextKey(container).set(true);
    return container;
  }
  onDidStorageChange(e) {
    if (e.key === _b.VIEWS_CUSTOMIZATIONS && e.scope === 0 && JSON.stringify(this.viewCustomizations) !== this.getStoredViewCustomizationsValue()) {
      this.onDidViewCustomizationsStorageChange();
    }
  }
  onDidViewCustomizationsStorageChange() {
    this._viewCustomizations = void 0;
    const newViewContainerCustomizations = new Map(Object.entries(this.viewCustomizations.viewContainerLocations));
    const newViewDescriptorCustomizations = new Map(Object.entries(this.viewCustomizations.viewLocations));
    const viewContainersToMove = [];
    const viewsToMove = [];
    for (const [containerId, location] of newViewContainerCustomizations.entries()) {
      const container = this.getViewContainerById(containerId);
      if (container) {
        if (location !== this.getViewContainerLocation(container)) {
          viewContainersToMove.push([container, location]);
        }
      } else if (this.isGeneratedContainerId(containerId)) {
        this.registerGeneratedViewContainer(location, containerId);
      }
    }
    for (const viewContainer of this.viewContainers) {
      if (!newViewContainerCustomizations.has(viewContainer.id)) {
        const currentLocation = this.getViewContainerLocation(viewContainer);
        const defaultLocation = this.getDefaultViewContainerLocation(viewContainer);
        if (currentLocation !== defaultLocation) {
          viewContainersToMove.push([viewContainer, defaultLocation]);
        }
      }
    }
    for (const [viewId, viewContainerId] of newViewDescriptorCustomizations.entries()) {
      const viewDescriptor2 = this.getViewDescriptorById(viewId);
      if (viewDescriptor2) {
        const prevViewContainer = this.getViewContainerByViewId(viewId);
        const newViewContainer = this.viewContainersRegistry.get(viewContainerId);
        if (prevViewContainer && newViewContainer && newViewContainer !== prevViewContainer) {
          viewsToMove.push({ views: [viewDescriptor2], from: prevViewContainer, to: newViewContainer });
        }
      }
    }
    for (const viewContainer of this.viewContainers) {
      const viewContainerModel = this.getViewContainerModel(viewContainer);
      for (const viewDescriptor2 of viewContainerModel.allViewDescriptors) {
        if (!newViewDescriptorCustomizations.has(viewDescriptor2.id)) {
          const currentContainer = this.getViewContainerByViewId(viewDescriptor2.id);
          const defaultContainer = this.getDefaultContainerById(viewDescriptor2.id);
          if (currentContainer && defaultContainer && currentContainer !== defaultContainer) {
            viewsToMove.push({ views: [viewDescriptor2], from: currentContainer, to: defaultContainer });
          }
        }
      }
    }
    for (const [container, location] of viewContainersToMove) {
      this.moveViewContainerToLocationWithoutSaving(container, location);
    }
    for (const { views, from, to } of viewsToMove) {
      this.moveViewsWithoutSaving(views, from, to, ViewVisibilityState.Default);
    }
    this.viewContainersCustomLocations = newViewContainerCustomizations;
    this.viewDescriptorsCustomLocations = newViewDescriptorCustomizations;
  }
  generateContainerId(location) {
    return `${_b.COMMON_CONTAINER_ID_PREFIX}.${ViewContainerLocationToString(location)}.${generateUuid()}`;
  }
  saveViewCustomizations() {
    const viewCustomizations = { viewContainerLocations: {}, viewLocations: {}, viewContainerBadgeEnablementStates: {} };
    for (const [containerId, location] of this.viewContainersCustomLocations) {
      const container = this.getViewContainerById(containerId);
      if (container && !this.isGeneratedContainerId(containerId) && location === this.getDefaultViewContainerLocation(container)) {
        continue;
      }
      viewCustomizations.viewContainerLocations[containerId] = location;
    }
    for (const [viewId, viewContainerId] of this.viewDescriptorsCustomLocations) {
      const viewContainer = this.getViewContainerById(viewContainerId);
      if (viewContainer) {
        const defaultContainer = this.getDefaultContainerById(viewId);
        if ((defaultContainer == null ? void 0 : defaultContainer.id) === viewContainer.id) {
          continue;
        }
      }
      viewCustomizations.viewLocations[viewId] = viewContainerId;
    }
    for (const [viewContainerId, badgeEnablementState] of this.viewContainerBadgeEnablementStates) {
      if (badgeEnablementState === false) {
        viewCustomizations.viewContainerBadgeEnablementStates[viewContainerId] = badgeEnablementState;
      }
    }
    this.viewCustomizations = viewCustomizations;
  }
  get viewCustomizations() {
    if (!this._viewCustomizations) {
      this._viewCustomizations = JSON.parse(this.getStoredViewCustomizationsValue());
      this._viewCustomizations.viewContainerLocations = this._viewCustomizations.viewContainerLocations ?? {};
      this._viewCustomizations.viewLocations = this._viewCustomizations.viewLocations ?? {};
      this._viewCustomizations.viewContainerBadgeEnablementStates = this._viewCustomizations.viewContainerBadgeEnablementStates ?? {};
    }
    return this._viewCustomizations;
  }
  set viewCustomizations(viewCustomizations) {
    const value = JSON.stringify(viewCustomizations);
    if (JSON.stringify(this.viewCustomizations) !== value) {
      this._viewCustomizations = viewCustomizations;
      this.setStoredViewCustomizationsValue(value);
    }
  }
  getStoredViewCustomizationsValue() {
    return this.storageService.get(_b.VIEWS_CUSTOMIZATIONS, 0, "{}");
  }
  setStoredViewCustomizationsValue(value) {
    this.storageService.store(_b.VIEWS_CUSTOMIZATIONS, value, 0, 0);
  }
  getViewsByContainer(viewContainer) {
    const result = this.viewsRegistry.getViews(viewContainer).filter((viewDescriptor2) => {
      const viewDescriptorViewContainerId = this.viewDescriptorsCustomLocations.get(viewDescriptor2.id) ?? viewContainer.id;
      return viewDescriptorViewContainerId === viewContainer.id;
    });
    for (const [viewId, viewContainerId] of this.viewDescriptorsCustomLocations.entries()) {
      if (viewContainerId !== viewContainer.id) {
        continue;
      }
      if (this.viewsRegistry.getViewContainer(viewId) === viewContainer) {
        continue;
      }
      const viewDescriptor2 = this.getViewDescriptorById(viewId);
      if (viewDescriptor2) {
        result.push(viewDescriptor2);
      }
    }
    return result;
  }
  onDidRegisterViewContainer(viewContainer) {
    const defaultLocation = this.isGeneratedContainerId(viewContainer.id) ? true : this.getViewContainerLocation(viewContainer) === this.getDefaultViewContainerLocation(viewContainer);
    this.getOrCreateDefaultViewContainerLocationContextKey(viewContainer).set(defaultLocation);
    this.getOrRegisterViewContainerModel(viewContainer);
  }
  getOrRegisterViewContainerModel(viewContainer) {
    var _a2;
    let viewContainerModel = (_a2 = this.viewContainerModels.get(viewContainer)) == null ? void 0 : _a2.viewContainerModel;
    if (!viewContainerModel) {
      const disposables = new DisposableStore();
      viewContainerModel = disposables.add(this.instantiationService.createInstance(ViewContainerModel, viewContainer));
      this.onDidChangeActiveViews({ added: viewContainerModel.activeViewDescriptors, removed: [] });
      viewContainerModel.onDidChangeActiveViewDescriptors((changed) => this.onDidChangeActiveViews(changed), this, disposables);
      this.onDidChangeVisibleViews({ added: [...viewContainerModel.visibleViewDescriptors], removed: [] });
      viewContainerModel.onDidAddVisibleViewDescriptors((added) => this.onDidChangeVisibleViews({ added: added.map(({ viewDescriptor: viewDescriptor2 }) => viewDescriptor2), removed: [] }), this, disposables);
      viewContainerModel.onDidRemoveVisibleViewDescriptors((removed) => this.onDidChangeVisibleViews({ added: [], removed: removed.map(({ viewDescriptor: viewDescriptor2 }) => viewDescriptor2) }), this, disposables);
      disposables.add(toDisposable(() => this.viewsVisibilityActionDisposables.deleteAndDispose(viewContainer)));
      disposables.add(this.registerResetViewContainerAction(viewContainer));
      this.viewContainerModels.set(viewContainer, { viewContainerModel, disposables, dispose: () => disposables.dispose() });
      this.onDidRegisterViews([{ views: this.viewsRegistry.getViews(viewContainer), viewContainer }]);
      const viewsToRegister = this.getViewsByContainer(viewContainer).filter((view) => this.getDefaultContainerById(view.id) !== viewContainer);
      if (viewsToRegister.length) {
        this.addViews(viewContainer, viewsToRegister);
        this.contextKeyService.bufferChangeEvents(() => {
          viewsToRegister.forEach((viewDescriptor2) => this.getOrCreateMovableViewContextKey(viewDescriptor2).set(!!viewDescriptor2.canMoveView));
        });
      }
    }
    return viewContainerModel;
  }
  onDidDeregisterViewContainer(viewContainer) {
    this.viewContainerModels.deleteAndDispose(viewContainer);
  }
  onDidChangeActiveViews({ added, removed }) {
    this.contextKeyService.bufferChangeEvents(() => {
      added.forEach((viewDescriptor2) => this.getOrCreateActiveViewContextKey(viewDescriptor2).set(true));
      removed.forEach((viewDescriptor2) => this.getOrCreateActiveViewContextKey(viewDescriptor2).set(false));
    });
  }
  onDidChangeVisibleViews({ added, removed }) {
    this.contextKeyService.bufferChangeEvents(() => {
      added.forEach((viewDescriptor2) => this.getOrCreateVisibleViewContextKey(viewDescriptor2).set(true));
      removed.forEach((viewDescriptor2) => this.getOrCreateVisibleViewContextKey(viewDescriptor2).set(false));
    });
  }
  registerViewsVisibilityActions() {
    for (const [viewContainer, { viewContainerModel, disposables }] of this.viewContainerModels) {
      this.viewsVisibilityActionDisposables.set(viewContainer, this.registerViewsVisibilityActionsForContainer(viewContainerModel));
      disposables.add(Event.any(viewContainerModel.onDidChangeActiveViewDescriptors, viewContainerModel.onDidAddVisibleViewDescriptors, viewContainerModel.onDidRemoveVisibleViewDescriptors, viewContainerModel.onDidMoveVisibleViewDescriptors)((e) => this.viewsVisibilityActionDisposables.set(viewContainer, this.registerViewsVisibilityActionsForContainer(viewContainerModel))));
    }
  }
  registerViewsVisibilityActionsForContainer(viewContainerModel) {
    const disposables = new DisposableStore();
    viewContainerModel.activeViewDescriptors.forEach((viewDescriptor2, index) => {
      if (!viewDescriptor2.remoteAuthority) {
        disposables.add(registerAction2(class extends ViewPaneContainerAction {
          constructor() {
            super({
              id: `${viewDescriptor2.id}.toggleVisibility`,
              viewPaneContainerId: viewContainerModel.viewContainer.id,
              precondition: viewDescriptor2.canToggleVisibility && (!viewContainerModel.isVisible(viewDescriptor2.id) || viewContainerModel.visibleViewDescriptors.length > 1) ? ContextKeyExpr.true() : ContextKeyExpr.false(),
              toggled: ContextKeyExpr.has(`${viewDescriptor2.id}.visible`),
              title: viewDescriptor2.name,
              menu: [{
                id: ViewsSubMenu,
                group: "1_toggleViews",
                when: ContextKeyExpr.and(ContextKeyExpr.equals("viewContainer", viewContainerModel.viewContainer.id), ContextKeyExpr.equals(
                  "viewContainerLocation",
                  ViewContainerLocationToString(0)
                )),
                order: index
              }, {
                id: MenuId.ViewContainerTitleContext,
                when: ContextKeyExpr.and(ContextKeyExpr.equals("viewContainer", viewContainerModel.viewContainer.id)),
                order: index,
                group: "1_toggleVisibility"
              }, {
                id: MenuId.ViewTitleContext,
                when: ContextKeyExpr.and(viewContainerModel.visibleViewDescriptors.length > 1 ? ContextKeyExpr.or(...viewContainerModel.visibleViewDescriptors.map((v) => ContextKeyExpr.equals("view", v.id))) : ContextKeyExpr.false()),
                order: index,
                group: "2_toggleVisibility"
              }]
            });
          }
          async runInViewPaneContainer(serviceAccessor, viewPaneContainer) {
            viewPaneContainer.toggleViewVisibility(viewDescriptor2.id);
          }
        }));
        disposables.add(registerAction2(class extends ViewPaneContainerAction {
          constructor() {
            super({
              id: `${viewDescriptor2.id}.removeView`,
              viewPaneContainerId: viewContainerModel.viewContainer.id,
              title: localize("hideView", "Hide '{0}'", viewDescriptor2.name),
              precondition: viewDescriptor2.canToggleVisibility && (!viewContainerModel.isVisible(viewDescriptor2.id) || viewContainerModel.visibleViewDescriptors.length > 1) ? ContextKeyExpr.true() : ContextKeyExpr.false(),
              menu: [{
                id: MenuId.ViewTitleContext,
                when: ContextKeyExpr.and(ContextKeyExpr.equals("view", viewDescriptor2.id), ContextKeyExpr.has(`${viewDescriptor2.id}.visible`)),
                group: "1_hide",
                order: 1
              }]
            });
          }
          async runInViewPaneContainer(serviceAccessor, viewPaneContainer) {
            viewPaneContainer.toggleViewVisibility(viewDescriptor2.id);
          }
        }));
      }
    });
    return disposables;
  }
  registerResetViewContainerAction(viewContainer) {
    const that = this;
    return registerAction2(class ResetViewLocationAction extends Action2 {
      constructor() {
        super({
          id: `${viewContainer.id}.resetViewContainerLocation`,
          title: {
            original: "Reset Location",
            value: localize("resetViewLocation", "Reset Location")
          },
          menu: [{
            id: MenuId.ViewContainerTitleContext,
            when: ContextKeyExpr.or(ContextKeyExpr.and(ContextKeyExpr.equals("viewContainer", viewContainer.id), ContextKeyExpr.equals(`${viewContainer.id}.defaultViewContainerLocation`, false)))
          }]
        });
      }
      run() {
        that.moveViewContainerToLocation(viewContainer, that.getDefaultViewContainerLocation(viewContainer));
      }
    });
  }
  addViews(container, views, visibilityState = ViewVisibilityState.Default) {
    this.contextKeyService.bufferChangeEvents(() => {
      views.forEach((view) => {
        const isDefaultContainer = this.getDefaultContainerById(view.id) === container;
        this.getOrCreateDefaultViewLocationContextKey(view).set(isDefaultContainer);
        if (isDefaultContainer) {
          this.viewDescriptorsCustomLocations.delete(view.id);
        } else {
          this.viewDescriptorsCustomLocations.set(view.id, container.id);
        }
      });
    });
    this.getViewContainerModel(container).add(views.map((view) => {
      return {
        viewDescriptor: view,
        collapsed: visibilityState === ViewVisibilityState.Default ? void 0 : false,
        visible: visibilityState === ViewVisibilityState.Default ? void 0 : true
      };
    }));
  }
  removeViews(container, views) {
    this.contextKeyService.bufferChangeEvents(() => {
      views.forEach((view) => {
        if (this.viewDescriptorsCustomLocations.get(view.id) === container.id) {
          this.viewDescriptorsCustomLocations.delete(view.id);
        }
        this.getOrCreateDefaultViewLocationContextKey(view).set(false);
      });
    });
    this.getViewContainerModel(container).remove(views);
  }
  getOrCreateActiveViewContextKey(viewDescriptor2) {
    const activeContextKeyId = `${viewDescriptor2.id}.active`;
    let contextKey = this.activeViewContextKeys.get(activeContextKeyId);
    if (!contextKey) {
      contextKey = new RawContextKey(activeContextKeyId, false).bindTo(this.contextKeyService);
      this.activeViewContextKeys.set(activeContextKeyId, contextKey);
    }
    return contextKey;
  }
  getOrCreateVisibleViewContextKey(viewDescriptor2) {
    const activeContextKeyId = `${viewDescriptor2.id}.visible`;
    let contextKey = this.activeViewContextKeys.get(activeContextKeyId);
    if (!contextKey) {
      contextKey = new RawContextKey(activeContextKeyId, false).bindTo(this.contextKeyService);
      this.activeViewContextKeys.set(activeContextKeyId, contextKey);
    }
    return contextKey;
  }
  getOrCreateMovableViewContextKey(viewDescriptor2) {
    const movableViewContextKeyId = `${viewDescriptor2.id}.canMove`;
    let contextKey = this.movableViewContextKeys.get(movableViewContextKeyId);
    if (!contextKey) {
      contextKey = new RawContextKey(movableViewContextKeyId, false).bindTo(this.contextKeyService);
      this.movableViewContextKeys.set(movableViewContextKeyId, contextKey);
    }
    return contextKey;
  }
  getOrCreateDefaultViewLocationContextKey(viewDescriptor2) {
    const defaultViewLocationContextKeyId = `${viewDescriptor2.id}.defaultViewLocation`;
    let contextKey = this.defaultViewLocationContextKeys.get(defaultViewLocationContextKeyId);
    if (!contextKey) {
      contextKey = new RawContextKey(defaultViewLocationContextKeyId, false).bindTo(this.contextKeyService);
      this.defaultViewLocationContextKeys.set(defaultViewLocationContextKeyId, contextKey);
    }
    return contextKey;
  }
  getOrCreateDefaultViewContainerLocationContextKey(viewContainer) {
    const defaultViewContainerLocationContextKeyId = `${viewContainer.id}.defaultViewContainerLocation`;
    let contextKey = this.defaultViewContainerLocationContextKeys.get(defaultViewContainerLocationContextKeyId);
    if (!contextKey) {
      contextKey = new RawContextKey(defaultViewContainerLocationContextKeyId, false).bindTo(this.contextKeyService);
      this.defaultViewContainerLocationContextKeys.set(defaultViewContainerLocationContextKeyId, contextKey);
    }
    return contextKey;
  }
}, _b.VIEWS_CUSTOMIZATIONS = "views.customizations", _b.COMMON_CONTAINER_ID_PREFIX = "workbench.views.service", _b);
ViewDescriptorService = __decorate([
  __param(0, IInstantiationService),
  __param(1, IContextKeyService),
  __param(2, IStorageService),
  __param(3, IExtensionService),
  __param(4, ITelemetryService)
], ViewDescriptorService);
const GLOBAL_ACTIVITY_ID = "workbench.action.globalActivity";
const ACCOUNTS_ACTIVITY_ID = "workbench.action.accountsActivity";
let ViewContainerActivityByView = class ViewContainerActivityByView2 extends Disposable {
  constructor(viewId, viewDescriptorService, activityService) {
    super();
    this.viewId = viewId;
    this.viewDescriptorService = viewDescriptorService;
    this.activityService = activityService;
    this.activity = void 0;
    this.activityDisposable = Disposable.None;
    this._register(Event.filter(this.viewDescriptorService.onDidChangeContainer, (e) => e.views.some((view) => view.id === viewId))(() => this.update()));
    this._register(Event.filter(this.viewDescriptorService.onDidChangeLocation, (e) => e.views.some((view) => view.id === viewId))(() => this.update()));
  }
  setActivity(activity) {
    this.activity = activity;
    this.update();
  }
  clearActivity() {
    this.activity = void 0;
    this.update();
  }
  update() {
    this.activityDisposable.dispose();
    const container = this.viewDescriptorService.getViewContainerByViewId(this.viewId);
    if (container && this.activity) {
      this.activityDisposable = this.activityService.showViewContainerActivity(container.id, this.activity);
    }
  }
  dispose() {
    this.activityDisposable.dispose();
  }
};
ViewContainerActivityByView = __decorate([
  __param(1, IViewDescriptorService),
  __param(2, IActivityService)
], ViewContainerActivityByView);
let ActivityService = class ActivityService2 {
  constructor(paneCompositeService, viewDescriptorService, instantiationService) {
    this.paneCompositeService = paneCompositeService;
    this.viewDescriptorService = viewDescriptorService;
    this.instantiationService = instantiationService;
    this.viewActivities = /* @__PURE__ */ new Map();
  }
  showViewContainerActivity(viewContainerId, { badge, clazz, priority }) {
    const viewContainer = this.viewDescriptorService.getViewContainerById(viewContainerId);
    if (viewContainer) {
      const location = this.viewDescriptorService.getViewContainerLocation(viewContainer);
      if (location !== null) {
        return this.paneCompositeService.showActivity(viewContainer.id, location, badge, clazz, priority);
      }
    }
    return Disposable.None;
  }
  showViewActivity(viewId, activity) {
    let maybeItem = this.viewActivities.get(viewId);
    if (maybeItem) {
      maybeItem.id++;
    } else {
      maybeItem = {
        id: 1,
        activity: this.instantiationService.createInstance(ViewContainerActivityByView, viewId)
      };
      this.viewActivities.set(viewId, maybeItem);
    }
    const id = maybeItem.id;
    maybeItem.activity.setActivity(activity);
    const item = maybeItem;
    return toDisposable(() => {
      if (item.id === id) {
        item.activity.dispose();
        this.viewActivities.delete(viewId);
      }
    });
  }
  showAccountsActivity({ badge, clazz, priority }) {
    return this.paneCompositeService.showActivity(ACCOUNTS_ACTIVITY_ID, 0, badge, clazz, priority);
  }
  showGlobalActivity({ badge, clazz, priority }) {
    return this.paneCompositeService.showActivity(GLOBAL_ACTIVITY_ID, 0, badge, clazz, priority);
  }
};
ActivityService = __decorate([
  __param(0, IPaneCompositePartService),
  __param(1, IViewDescriptorService),
  __param(2, IInstantiationService)
], ActivityService);
var css$m = '.monaco-workbench .part.activitybar{height:100%;width:48px}.monaco-workbench .activitybar.bordered:before{border-color:inherit;box-sizing:border-box;content:"";float:left;height:100%;position:absolute;width:0}.monaco-workbench .activitybar.left.bordered:before{border-right-style:solid;border-right-width:1px;right:0}.monaco-workbench .activitybar.right.bordered:before{border-left-style:solid;border-left-width:1px;left:0}.monaco-workbench .activitybar>.content{display:flex;flex-direction:column;height:100%;justify-content:space-between}.monaco-workbench .activitybar>.content .monaco-action-bar{background-color:inherit;text-align:left}.monaco-workbench .activitybar .action-item:focus{outline:0!important}.monaco-workbench .activitybar>.content>.composite-bar{margin-bottom:auto}.monaco-workbench .activitybar .menubar,.monaco-workbench .activitybar .menubar.compact .toolbar-toggle-more{height:35px;width:100%}';
n(css$m, {});
var css$l = '.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item{display:block;position:relative}.monaco-workbench .activitybar>.content .composite-bar>.monaco-action-bar .action-item:after,.monaco-workbench .activitybar>.content .composite-bar>.monaco-action-bar .action-item:before{background-color:transparent;content:"";display:none;height:2px;position:absolute;transition-delay:.1s;transition-duration:0ms;transition-property:background-color;width:48px}.monaco-workbench .activitybar>.content.dragged-over .composite-bar>.monaco-action-bar .action-item:after,.monaco-workbench .activitybar>.content.dragged-over .composite-bar>.monaco-action-bar .action-item:before{display:block}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:before{margin-top:-2px;top:1px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:after{bottom:1px;margin-bottom:-2px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:first-of-type:before{margin-top:-2px;top:2px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:last-of-type:after{bottom:2px;margin-bottom:-2px}.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.bottom:after,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.bottom:before,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.top:after,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.top:before{transition-delay:0s}.monaco-workbench .activitybar>.content.dragged-over-head>.composite-bar>.monaco-action-bar .action-item:first-of-type:before,.monaco-workbench .activitybar>.content.dragged-over-tail>.composite-bar>.monaco-action-bar .action-item:last-of-type:after,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.bottom+.action-item:before,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item.top:before,.monaco-workbench .activitybar>.content>.composite-bar>.monaco-action-bar .action-item:last-of-type.bottom:after{background-color:var(--insert-border-color)}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-label{box-sizing:border-box;display:flex;height:48px;margin-right:0;overflow:hidden;position:relative;width:48px;z-index:1}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-label:not(.codicon){font-size:15px;line-height:40px;padding:0 0 0 48px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-label.codicon{align-items:center;font-size:24px;justify-content:center}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.active .action-label.codicon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .action-label.codicon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:hover .action-label.codicon{color:var(--vscode-activityBar-foreground)!important}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.active .action-label.uri-icon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .action-label.uri-icon,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:hover .action-label.uri-icon{background-color:var(--vscode-activityBar-foreground)!important}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked .active-item-indicator:before,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .active-item-indicator:before{border-left:2px solid;content:"";height:100%;position:absolute;top:0;width:0;z-index:1}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked .active-item-indicator:before{height:100%;top:0}.monaco-workbench.hc-black .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked:not(:focus) .active-item-indicator.action-item,.monaco-workbench.hc-light .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.checked:not(:focus) .active-item-indicator{display:none}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item.clicked:focus:before{border-left:none!important}.monaco-workbench .activitybar.left>.content :not(.monaco-menu)>.monaco-action-bar .action-item .active-item-indicator:before{left:0}.monaco-workbench .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .action-item .active-item-indicator:before{right:0}.monaco-workbench.hc-black .activitybar.left>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before,.monaco-workbench.hc-black .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before,.monaco-workbench.hc-light .activitybar.left>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before,.monaco-workbench.hc-light .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus:before{outline:none}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge{bottom:0;height:100%;left:0;margin:auto;overflow:hidden;position:absolute;top:0;width:100%}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge{z-index:2}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge{z-index:1}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator{pointer-events:none}.monaco-workbench.border .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .active-item-indicator{left:-2px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge .badge-content{border-radius:20px;font-size:9px;font-weight:600;height:16px;line-height:16px;min-width:8px;padding:0 4px;position:absolute;right:8px;text-align:center;top:24px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge .profile-badge-content{background-color:var(--vscode-profileBadge-background);border:2px solid var(--vscode-activityBar-background);border-radius:7px;color:var(--vscode-profileBadge-foreground);font-size:9px;font-weight:600;line-height:10px;padding:2px 3px;position:absolute;right:6px;top:24px}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:active .profile-badge-content,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:focus .profile-badge-content,.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .action-item:hover .profile-badge-content{color:var(--vscode-activityBar-foreground)}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge .codicon.badge-content{font-size:12px;font-weight:unset;justify-content:center;padding:0}.monaco-workbench .activitybar>.content :not(.monaco-menu)>.monaco-action-bar .badge .codicon.badge-content:before{text-align:center;vertical-align:baseline}.monaco-workbench .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .badge,.monaco-workbench .activitybar.right>.content :not(.monaco-menu)>.monaco-action-bar .profile-badge{left:auto;right:0}';
n(css$l, {});
let ViewContainerActivityAction = (_c = class extends ActivityAction {
  constructor(activity, paneCompositePart, layoutService, telemetryService, configurationService) {
    super(activity);
    this.paneCompositePart = paneCompositePart;
    this.layoutService = layoutService;
    this.telemetryService = telemetryService;
    this.configurationService = configurationService;
    this.lastRun = 0;
  }
  updateActivity(activity) {
    this.activity = activity;
  }
  async run(event) {
    if (event instanceof MouseEvent && event.button === 2) {
      return;
    }
    const now = Date.now();
    if (now > this.lastRun && now - this.lastRun < _c.preventDoubleClickDelay) {
      return;
    }
    this.lastRun = now;
    const sideBarVisible = this.layoutService.isVisible("workbench.parts.sidebar");
    const activeViewlet = this.paneCompositePart.getActivePaneComposite();
    const focusBehavior = this.configurationService.getValue("workbench.activityBar.iconClickBehavior");
    const focus = event && "preserveFocus" in event ? !event.preserveFocus : true;
    if (sideBarVisible && (activeViewlet == null ? void 0 : activeViewlet.getId()) === this.activity.id) {
      switch (focusBehavior) {
        case "focus":
          this.logAction("refocus");
          this.paneCompositePart.openPaneComposite(this.activity.id, focus);
          break;
        case "toggle":
        default:
          this.logAction("hide");
          this.layoutService.setPartHidden(true, "workbench.parts.sidebar");
          break;
      }
      return;
    }
    this.logAction("show");
    await this.paneCompositePart.openPaneComposite(this.activity.id, focus);
    return this.activate();
  }
  logAction(action) {
    this.telemetryService.publicLog2("activityBarAction", { viewletId: this.activity.id, action });
  }
}, _c.preventDoubleClickDelay = 300, _c);
ViewContainerActivityAction = __decorate([
  __param(2, IWorkbenchLayoutService),
  __param(3, ITelemetryService),
  __param(4, IConfigurationService)
], ViewContainerActivityAction);
let AbstractGlobalActivityActionViewItem = class AbstractGlobalActivityActionViewItem2 extends ActivityActionViewItem {
  constructor(action, contextMenuActionsProvider, options, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService) {
    super(action, options, () => true, themeService, hoverService, configurationService, keybindingService);
    this.contextMenuActionsProvider = contextMenuActionsProvider;
    this.menuService = menuService;
    this.contextMenuService = contextMenuService;
    this.contextKeyService = contextKeyService;
    this.environmentService = environmentService;
  }
  render(container) {
    super.render(container);
    this._register(addDisposableListener(this.container, EventType.MOUSE_DOWN, async (e) => {
      EventHelper.stop(e, true);
      const isLeftClick = (e == null ? void 0 : e.button) !== 2;
      if (isLeftClick) {
        this.run();
      }
    }));
    this._register(addDisposableListener(this.container, EventType.CONTEXT_MENU, async (e) => {
      const disposables = new DisposableStore();
      const actions = await this.resolveContextMenuActions(disposables);
      const event = new StandardMouseEvent(e);
      this.contextMenuService.showContextMenu({
        getAnchor: () => event,
        getActions: () => actions,
        onHide: () => disposables.dispose()
      });
    }));
    this._register(addDisposableListener(this.container, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(3) || event.equals(10)) {
        EventHelper.stop(e, true);
        this.run();
      }
    }));
    this._register(addDisposableListener(this.container, EventType$1.Tap, (e) => {
      EventHelper.stop(e, true);
      this.run();
    }));
  }
  async resolveContextMenuActions(disposables) {
    return this.contextMenuActionsProvider();
  }
};
AbstractGlobalActivityActionViewItem = __decorate([
  __param(3, IThemeService),
  __param(4, IHoverService),
  __param(5, IMenuService),
  __param(6, IContextMenuService),
  __param(7, IContextKeyService),
  __param(8, IConfigurationService),
  __param(9, IWorkbenchEnvironmentService),
  __param(10, IKeybindingService)
], AbstractGlobalActivityActionViewItem);
let MenuActivityActionViewItem = class MenuActivityActionViewItem2 extends AbstractGlobalActivityActionViewItem {
  constructor(menuId, action, contextMenuActionsProvider, icon, colors, hoverOptions, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService) {
    super(action, contextMenuActionsProvider, { draggable: false, colors, icon, hasPopup: true, hoverOptions }, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService);
    this.menuId = menuId;
  }
  async run() {
    const disposables = new DisposableStore();
    const menu = disposables.add(this.menuService.createMenu(this.menuId, this.contextKeyService));
    const actions = await this.resolveMainMenuActions(menu, disposables);
    this.contextMenuService.showContextMenu({
      getAnchor: () => this.container,
      anchorAlignment: this.configurationService.getValue("workbench.sideBar.location") === "left" ? 1 : 0,
      anchorAxisAlignment: 1,
      getActions: () => actions,
      onHide: () => disposables.dispose(),
      menuActionOptions: { renderShortTitle: true }
    });
  }
  async resolveMainMenuActions(menu, _disposable) {
    const actions = [];
    createAndFillInActionBarActions(menu, { renderShortTitle: true }, { primary: [], secondary: actions });
    return actions;
  }
};
MenuActivityActionViewItem = __decorate([
  __param(6, IThemeService),
  __param(7, IHoverService),
  __param(8, IMenuService),
  __param(9, IContextMenuService),
  __param(10, IContextKeyService),
  __param(11, IConfigurationService),
  __param(12, IWorkbenchEnvironmentService),
  __param(13, IKeybindingService)
], MenuActivityActionViewItem);
let AccountsActivityActionViewItem = (_d = class extends MenuActivityActionViewItem {
  constructor(action, contextMenuActionsProvider, colors, activityHoverOptions, themeService, hoverService, contextMenuService, menuService, contextKeyService, authenticationService, environmentService, productService, configurationService, storageService, keybindingService, secretStorageService, credentialsService, logService) {
    super(MenuId.AccountsContext, action, contextMenuActionsProvider, true, colors, activityHoverOptions, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService);
    this.authenticationService = authenticationService;
    this.productService = productService;
    this.storageService = storageService;
    this.secretStorageService = secretStorageService;
    this.credentialsService = credentialsService;
    this.logService = logService;
    this.groupedAccounts = /* @__PURE__ */ new Map();
    this.problematicProviders = /* @__PURE__ */ new Set();
    this.initialized = false;
    this.sessionFromEmbedder = getCurrentAuthenticationSessionInfo(this.credentialsService, this.secretStorageService, this.productService);
    this.registerListeners();
    this.initialize();
  }
  registerListeners() {
    this._register(this.authenticationService.onDidRegisterAuthenticationProvider(async (e) => {
      await this.addAccountsFromProvider(e.id);
    }));
    this._register(this.authenticationService.onDidUnregisterAuthenticationProvider((e) => {
      this.groupedAccounts.delete(e.id);
      this.problematicProviders.delete(e.id);
    }));
    this._register(this.authenticationService.onDidChangeSessions(async (e) => {
      for (const changed of [...e.event.changed, ...e.event.added]) {
        try {
          await this.addOrUpdateAccount(e.providerId, changed.account);
        } catch (e2) {
          this.logService.error(e2);
        }
      }
      for (const removed of e.event.removed) {
        this.removeAccount(e.providerId, removed.account);
      }
    }));
  }
  async initialize() {
    const providerIds = this.authenticationService.getProviderIds();
    const results = await Promise.allSettled(providerIds.map((providerId) => this.addAccountsFromProvider(providerId)));
    for (const result of results) {
      if (result.status === "rejected") {
        this.logService.error(result.reason);
      }
    }
    this.initialized = true;
  }
  async resolveMainMenuActions(accountsMenu, disposables) {
    await super.resolveMainMenuActions(accountsMenu, disposables);
    const providers = this.authenticationService.getProviderIds();
    const otherCommands = accountsMenu.getActions();
    let menus = [];
    for (const providerId of providers) {
      if (!this.initialized) {
        const noAccountsAvailableAction = disposables.add(new Action("noAccountsAvailable", localize("loading", "Loading..."), void 0, false));
        menus.push(noAccountsAvailableAction);
        break;
      }
      const providerLabel = this.authenticationService.getLabel(providerId);
      const accounts = this.groupedAccounts.get(providerId);
      if (!accounts) {
        if (this.problematicProviders.has(providerId)) {
          const providerUnavailableAction = disposables.add(new Action("providerUnavailable", localize("authProviderUnavailable", "{0} is currently unavailable", providerLabel), void 0, false));
          menus.push(providerUnavailableAction);
          try {
            await this.addAccountsFromProvider(providerId);
          } catch (e) {
            this.logService.error(e);
          }
        }
        continue;
      }
      for (const account of accounts) {
        const manageExtensionsAction = disposables.add(new Action(`configureSessions${account.label}`, localize("manageTrustedExtensions", "Manage Trusted Extensions"), void 0, true, () => {
          return this.authenticationService.manageTrustedExtensionsForAccount(providerId, account.label);
        }));
        const providerSubMenuActions = [manageExtensionsAction];
        if (account.canSignOut) {
          const signOutAction = disposables.add(new Action("signOut", localize("signOut", "Sign Out"), void 0, true, async () => {
            const allSessions = await this.authenticationService.getSessions(providerId);
            const sessionsForAccount = allSessions.filter((s) => s.account.id === account.id);
            return await this.authenticationService.removeAccountSessions(providerId, account.label, sessionsForAccount);
          }));
          providerSubMenuActions.push(signOutAction);
        }
        const providerSubMenu = new SubmenuAction(
          "activitybar.submenu",
          `${account.label} (${providerLabel})`,
          providerSubMenuActions
        );
        menus.push(providerSubMenu);
      }
    }
    if (providers.length && !menus.length) {
      const noAccountsAvailableAction = disposables.add(new Action("noAccountsAvailable", localize("noAccounts", "You are not signed in to any accounts"), void 0, false));
      menus.push(noAccountsAvailableAction);
    }
    if (menus.length && otherCommands.length) {
      menus.push(new Separator());
    }
    otherCommands.forEach((group, i) => {
      const actions = group[1];
      menus = menus.concat(actions);
      if (i !== otherCommands.length - 1) {
        menus.push(new Separator());
      }
    });
    return menus;
  }
  async resolveContextMenuActions(disposables) {
    const actions = await super.resolveContextMenuActions(disposables);
    actions.unshift(...[
      toAction({ id: "hideAccounts", label: localize("hideAccounts", "Hide Accounts"), run: () => this.storageService.store(_d.ACCOUNTS_VISIBILITY_PREFERENCE_KEY, false, 0, 0) }),
      new Separator()
    ]);
    return actions;
  }
  async addOrUpdateAccount(providerId, account) {
    let accounts = this.groupedAccounts.get(providerId);
    if (accounts) {
      const existingAccount = accounts.find((a) => a.id === account.id);
      if (existingAccount) {
        if (existingAccount.label !== account.label) {
          existingAccount.label = account.label;
        }
        return;
      }
    } else {
      accounts = [];
      this.groupedAccounts.set(providerId, accounts);
    }
    const sessionFromEmbedder = await this.sessionFromEmbedder;
    let canSignOut = !!(sessionFromEmbedder == null ? void 0 : sessionFromEmbedder.canSignOut);
    if (!canSignOut) {
      if (sessionFromEmbedder == null ? void 0 : sessionFromEmbedder.id) {
        const sessions = (await this.authenticationService.getSessions(providerId)).filter((s) => s.account.id === account.id);
        canSignOut = !sessions.some((s) => s.id === sessionFromEmbedder.id);
      } else {
        canSignOut = true;
      }
    }
    accounts.push({ ...account, canSignOut });
  }
  removeAccount(providerId, account) {
    const accounts = this.groupedAccounts.get(providerId);
    if (!accounts) {
      return;
    }
    const index = accounts.findIndex((a) => a.id === account.id);
    if (index === -1) {
      return;
    }
    accounts.splice(index, 1);
    if (accounts.length === 0) {
      this.groupedAccounts.delete(providerId);
    }
  }
  async addAccountsFromProvider(providerId) {
    try {
      const sessions = await this.authenticationService.getSessions(providerId);
      this.problematicProviders.delete(providerId);
      for (const session of sessions) {
        try {
          await this.addOrUpdateAccount(providerId, session.account);
        } catch (e) {
          this.logService.error(e);
        }
      }
    } catch (e) {
      this.logService.error(e);
      this.problematicProviders.add(providerId);
    }
  }
}, _d.ACCOUNTS_VISIBILITY_PREFERENCE_KEY = "workbench.activity.showAccounts", _d);
AccountsActivityActionViewItem = __decorate([
  __param(4, IThemeService),
  __param(5, IHoverService),
  __param(6, IContextMenuService),
  __param(7, IMenuService),
  __param(8, IContextKeyService),
  __param(9, IAuthenticationService),
  __param(10, IWorkbenchEnvironmentService),
  __param(11, IProductService),
  __param(12, IConfigurationService),
  __param(13, IStorageService),
  __param(14, IKeybindingService),
  __param(15, ISecretStorageService),
  __param(16, ICredentialsService),
  __param(17, ILogService)
], AccountsActivityActionViewItem);
let GlobalActivityActionViewItem = class GlobalActivityActionViewItem2 extends MenuActivityActionViewItem {
  constructor(action, contextMenuActionsProvider, colors, activityHoverOptions, userDataProfileService, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService) {
    super(MenuId.GlobalActivity, action, contextMenuActionsProvider, true, colors, activityHoverOptions, themeService, hoverService, menuService, contextMenuService, contextKeyService, configurationService, environmentService, keybindingService);
    this.userDataProfileService = userDataProfileService;
    this._register(this.userDataProfileService.onDidChangeCurrentProfile(() => this.updateProfileBadge()));
  }
  render(container) {
    super.render(container);
    this.profileBadge = append(container, $$2(".profile-badge"));
    this.profileBadgeContent = append(this.profileBadge, $$2(".profile-badge-content"));
    this.updateProfileBadge();
  }
  updateProfileBadge() {
    if (!this.profileBadge || !this.profileBadgeContent) {
      return;
    }
    clearNode(this.profileBadgeContent);
    hide(this.profileBadge);
    if (this.userDataProfileService.currentProfile.isDefault) {
      return;
    }
    if (this.action.getBadge()) {
      return;
    }
    this.profileBadgeContent.textContent = this.userDataProfileService.currentProfile.name.substring(0, 2).toUpperCase();
    show(this.profileBadge);
  }
  updateBadge() {
    super.updateBadge();
    this.updateProfileBadge();
  }
  computeTitle() {
    return this.userDataProfileService.currentProfile.isDefault ? super.computeTitle() : localize(
      "manage",
      "Manage {0} (Profile)",
      this.userDataProfileService.currentProfile.name
    );
  }
};
GlobalActivityActionViewItem = __decorate([
  __param(4, IUserDataProfileService),
  __param(5, IThemeService),
  __param(6, IHoverService),
  __param(7, IMenuService),
  __param(8, IContextMenuService),
  __param(9, IContextKeyService),
  __param(10, IConfigurationService),
  __param(11, IWorkbenchEnvironmentService),
  __param(12, IKeybindingService)
], GlobalActivityActionViewItem);
class PlaceHolderViewContainerActivityAction extends ViewContainerActivityAction {
}
class PlaceHolderToggleCompositePinnedAction extends ToggleCompositePinnedAction {
  constructor(id, compositeBar) {
    super({ id, name: id, classNames: void 0 }, compositeBar);
  }
  setActivity(activity) {
    this.label = activity.name;
  }
}
class PlaceHolderToggleCompositeBadgeAction extends ToggleCompositeBadgeAction {
  constructor(id, compositeBar) {
    super({ id, name: id, classNames: void 0 }, compositeBar);
  }
  setActivity(activity) {
    this.label = activity.name;
  }
}
class SwitchSideBarViewAction extends Action2 {
  constructor(desc, offset) {
    super(desc);
    this.offset = offset;
  }
  async run(accessor) {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    const visibleViewletIds = paneCompositeService.getVisiblePaneCompositeIds(0);
    const activeViewlet = paneCompositeService.getActivePaneComposite(0);
    if (!activeViewlet) {
      return;
    }
    let targetViewletId;
    for (let i = 0; i < visibleViewletIds.length; i++) {
      if (visibleViewletIds[i] === activeViewlet.getId()) {
        targetViewletId = visibleViewletIds[(i + visibleViewletIds.length + this.offset) % visibleViewletIds.length];
        break;
      }
    }
    await paneCompositeService.openPaneComposite(targetViewletId, 0, true);
  }
}
registerAction2(class PreviousSideBarViewAction extends SwitchSideBarViewAction {
  constructor() {
    super({
      id: "workbench.action.previousSideBarView",
      title: { value: localize("previousSideBarView", "Previous Primary Side Bar View"), original: "Previous Primary Side Bar View" },
      category: Categories.View,
      f1: true
    }, -1);
  }
});
registerAction2(class NextSideBarViewAction extends SwitchSideBarViewAction {
  constructor() {
    super({
      id: "workbench.action.nextSideBarView",
      title: { value: localize("nextSideBarView", "Next Primary Side Bar View"), original: "Next Primary Side Bar View" },
      category: Categories.View,
      f1: true
    }, 1);
  }
});
registerAction2(class FocusActivityBarAction extends Action2 {
  constructor() {
    super({
      id: "workbench.action.focusActivityBar",
      title: { value: localize("focusActivityBar", "Focus Activity Bar"), original: "Focus Activity Bar" },
      category: Categories.View,
      f1: true
    });
  }
  async run(accessor) {
    const layoutService = accessor.get(IWorkbenchLayoutService);
    layoutService.setPartHidden(false, "workbench.parts.activitybar");
    layoutService.focusPart("workbench.parts.activitybar");
  }
});
registerThemingParticipant((theme, collector) => {
  const activityBarActiveBorderColor = theme.getColor(ACTIVITY_BAR_ACTIVE_BORDER);
  if (activityBarActiveBorderColor) {
    collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked .active-item-indicator:before {
				border-left-color: ${activityBarActiveBorderColor};
			}
		`);
  }
  const activityBarActiveFocusBorderColor = theme.getColor(ACTIVITY_BAR_ACTIVE_FOCUS_BORDER);
  if (activityBarActiveFocusBorderColor) {
    collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:focus::before {
				visibility: hidden;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:focus .active-item-indicator:before {
				visibility: visible;
				border-left-color: ${activityBarActiveFocusBorderColor};
			}
		`);
  }
  const activityBarActiveBackgroundColor = theme.getColor(ACTIVITY_BAR_ACTIVE_BACKGROUND);
  if (activityBarActiveBackgroundColor) {
    collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked .active-item-indicator {
				z-index: 0;
				background-color: ${activityBarActiveBackgroundColor};
			}
		`);
  }
  const outline = theme.getColor(activeContrastBorder);
  if (outline) {
    collector.addRule(`
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:before {
				content: "";
				position: absolute;
				top: 8px;
				left: 8px;
				height: 32px;
				width: 32px;
				z-index: 1;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.profile-activity-item:before {
				top: -6px;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:hover:before {
				outline: 1px solid;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:hover:before {
				outline: 1px dashed;
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:focus .active-item-indicator:before {
				border-left-color: ${outline};
			}

			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.active:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item.checked:hover:before,
			.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:hover:before {
				outline-color: ${outline};
			}
		`);
  } else {
    const focusBorderColor = theme.getColor(focusBorder);
    if (focusBorderColor) {
      collector.addRule(`
				.monaco-workbench .activitybar > .content :not(.monaco-menu) > .monaco-action-bar .action-item:focus .active-item-indicator:before {
						border-left-color: ${focusBorderColor};
					}
				`);
    }
  }
});
class CompositeDragAndDrop {
  constructor(viewDescriptorService, targetContainerLocation, openComposite, moveComposite, getItems) {
    this.viewDescriptorService = viewDescriptorService;
    this.targetContainerLocation = targetContainerLocation;
    this.openComposite = openComposite;
    this.moveComposite = moveComposite;
    this.getItems = getItems;
  }
  drop(data, targetCompositeId, originalEvent, before) {
    const dragData = data.getData();
    if (dragData.type === "composite") {
      const currentContainer = this.viewDescriptorService.getViewContainerById(dragData.id);
      const currentLocation = this.viewDescriptorService.getViewContainerLocation(currentContainer);
      if (currentLocation === this.targetContainerLocation) {
        if (targetCompositeId) {
          this.moveComposite(dragData.id, targetCompositeId, before);
        }
      } else {
        const viewsToMove = this.viewDescriptorService.getViewContainerModel(currentContainer).allViewDescriptors;
        if (viewsToMove.some((v) => !v.canMoveView)) {
          return;
        }
        this.viewDescriptorService.moveViewContainerToLocation(currentContainer, this.targetContainerLocation, this.getTargetIndex(targetCompositeId, before));
      }
    }
    if (dragData.type === "view") {
      const viewToMove = this.viewDescriptorService.getViewDescriptorById(dragData.id);
      if (viewToMove && viewToMove.canMoveView) {
        this.viewDescriptorService.moveViewToLocation(viewToMove, this.targetContainerLocation);
        const newContainer = this.viewDescriptorService.getViewContainerByViewId(viewToMove.id);
        if (targetCompositeId) {
          this.moveComposite(newContainer.id, targetCompositeId, before);
        }
        this.openComposite(newContainer.id, true).then((composite) => {
          composite == null ? void 0 : composite.openView(viewToMove.id, true);
        });
      }
    }
  }
  onDragEnter(data, targetCompositeId, originalEvent) {
    return this.canDrop(data, targetCompositeId);
  }
  onDragOver(data, targetCompositeId, originalEvent) {
    return this.canDrop(data, targetCompositeId);
  }
  getTargetIndex(targetId, before2d) {
    if (!targetId) {
      return void 0;
    }
    const items = this.getItems();
    const before = this.targetContainerLocation === 1 ? before2d == null ? void 0 : before2d.horizontallyBefore : before2d == null ? void 0 : before2d.verticallyBefore;
    return items.filter((item) => item.visible).findIndex((item) => item.id === targetId) + (before ? 0 : 1);
  }
  canDrop(data, targetCompositeId) {
    const dragData = data.getData();
    if (dragData.type === "composite") {
      const currentContainer = this.viewDescriptorService.getViewContainerById(dragData.id);
      const currentLocation = this.viewDescriptorService.getViewContainerLocation(currentContainer);
      if (currentLocation === this.targetContainerLocation) {
        return dragData.id !== targetCompositeId;
      }
      const draggedViews = this.viewDescriptorService.getViewContainerModel(currentContainer).allViewDescriptors;
      return !draggedViews.some((view) => !view.canMoveView);
    } else {
      const viewDescriptor2 = this.viewDescriptorService.getViewDescriptorById(dragData.id);
      if (!viewDescriptor2 || !viewDescriptor2.canMoveView) {
        return false;
      }
      return true;
    }
  }
}
let CompositeBar = class CompositeBar2 extends Widget {
  constructor(items, options, instantiationService, contextMenuService, viewDescriptorService) {
    super();
    this.options = options;
    this.instantiationService = instantiationService;
    this.contextMenuService = contextMenuService;
    this.viewDescriptorService = viewDescriptorService;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.model = new CompositeBarModel(items, options);
    this.visibleComposites = [];
    this.compositeSizeInBar = /* @__PURE__ */ new Map();
    this.computeSizes(this.model.visibleItems);
  }
  getCompositeBarItems() {
    return [...this.model.items];
  }
  setCompositeBarItems(items) {
    if (this.model.setItems(items)) {
      this.updateCompositeSwitcher();
    }
  }
  getPinnedComposites() {
    return this.model.pinnedItems;
  }
  getVisibleComposites() {
    return this.model.visibleItems;
  }
  create(parent) {
    const actionBarDiv = parent.appendChild($$2(".composite-bar"));
    this.compositeSwitcherBar = this._register(new ActionBar(actionBarDiv, {
      actionViewItemProvider: (action) => {
        if (action instanceof CompositeOverflowActivityAction) {
          return this.compositeOverflowActionViewItem;
        }
        const item = this.model.findItem(action.id);
        return item && this.instantiationService.createInstance(CompositeActionViewItem, { draggable: true, colors: this.options.colors, icon: this.options.icon, hoverOptions: this.options.activityHoverOptions }, action, item.pinnedAction, item.toggleBadgeAction, (compositeId) => this.options.getContextMenuActionsForComposite(compositeId), () => this.getContextMenuActions(), this.options.dndHandler, this);
      },
      orientation: this.options.orientation,
      ariaLabel: localize("activityBarAriaLabel", "Active View Switcher"),
      ariaRole: "tablist",
      animated: false,
      preventLoopNavigation: this.options.preventLoopNavigation,
      triggerKeys: { keyDown: true }
    }));
    this._register(addDisposableListener(parent, EventType.CONTEXT_MENU, (e) => this.showContextMenu(e)));
    this._register(Gesture.addTarget(parent));
    this._register(addDisposableListener(parent, EventType$1.Contextmenu, (e) => this.showContextMenu(e)));
    let insertDropBefore = void 0;
    this._register(CompositeDragAndDropObserver.INSTANCE.registerTarget(parent, {
      onDragOver: (e) => {
        const visibleItems = this.getVisibleComposites();
        if (!visibleItems.length || e.eventData.target && isAncestor(e.eventData.target, actionBarDiv)) {
          insertDropBefore = this.updateFromDragging(parent, false, false, true);
          return;
        }
        const insertAtFront = this.insertAtFront(actionBarDiv, e.eventData);
        const target = insertAtFront ? visibleItems[0] : visibleItems[visibleItems.length - 1];
        const validDropTarget = this.options.dndHandler.onDragOver(e.dragAndDropData, target.id, e.eventData);
        toggleDropEffect(e.eventData.dataTransfer, "move", validDropTarget);
        insertDropBefore = this.updateFromDragging(parent, validDropTarget, insertAtFront, true);
      },
      onDragLeave: (e) => {
        insertDropBefore = this.updateFromDragging(parent, false, false, false);
      },
      onDragEnd: (e) => {
        insertDropBefore = this.updateFromDragging(parent, false, false, false);
      },
      onDrop: (e) => {
        const visibleItems = this.getVisibleComposites();
        if (visibleItems.length) {
          const target = this.insertAtFront(actionBarDiv, e.eventData) ? visibleItems[0] : visibleItems[visibleItems.length - 1];
          this.options.dndHandler.drop(e.dragAndDropData, target.id, e.eventData, insertDropBefore);
        }
        insertDropBefore = this.updateFromDragging(parent, false, false, false);
      }
    }));
    return actionBarDiv;
  }
  insertAtFront(element, event) {
    const rect = element.getBoundingClientRect();
    const posX = event.clientX;
    const posY = event.clientY;
    switch (this.options.orientation) {
      case 0:
        return posX < rect.left;
      case 1:
        return posY < rect.top;
    }
  }
  updateFromDragging(element, showFeedback, front, isDragging) {
    element.classList.toggle("dragged-over", isDragging);
    element.classList.toggle("dragged-over-head", showFeedback && front);
    element.classList.toggle("dragged-over-tail", showFeedback && !front);
    if (!showFeedback) {
      return void 0;
    }
    return { verticallyBefore: front, horizontallyBefore: front };
  }
  focus(index) {
    var _a2;
    (_a2 = this.compositeSwitcherBar) == null ? void 0 : _a2.focus(index);
  }
  recomputeSizes() {
    this.computeSizes(this.model.visibleItems);
  }
  layout(dimension) {
    this.dimension = dimension;
    if (dimension.height === 0 || dimension.width === 0) {
      return;
    }
    if (this.compositeSizeInBar.size === 0) {
      this.computeSizes(this.model.visibleItems);
    }
    this.updateCompositeSwitcher();
  }
  addComposite({ id, name, order, requestedIndex }) {
    if (this.model.add(id, name, order, requestedIndex)) {
      this.computeSizes([this.model.findItem(id)]);
      this.updateCompositeSwitcher();
    }
  }
  removeComposite(id) {
    if (this.isPinned(id)) {
      this.unpin(id);
    }
    if (this.model.remove(id)) {
      this.updateCompositeSwitcher();
    }
  }
  hideComposite(id) {
    if (this.model.hide(id)) {
      this.resetActiveComposite(id);
      this.updateCompositeSwitcher();
    }
  }
  activateComposite(id) {
    const previousActiveItem = this.model.activeItem;
    if (this.model.activate(id)) {
      if (this.visibleComposites.indexOf(id) === -1 || !!this.model.activeItem && !this.model.activeItem.pinned || previousActiveItem && !previousActiveItem.pinned) {
        this.updateCompositeSwitcher();
      }
    }
  }
  deactivateComposite(id) {
    const previousActiveItem = this.model.activeItem;
    if (this.model.deactivate()) {
      if (previousActiveItem && !previousActiveItem.pinned) {
        this.updateCompositeSwitcher();
      }
    }
  }
  showActivity(compositeId, badge, clazz, priority) {
    if (!badge) {
      throw illegalArgument("badge");
    }
    if (typeof priority !== "number") {
      priority = 0;
    }
    const activity = { badge, clazz, priority };
    this.model.addActivity(compositeId, activity);
    return toDisposable(() => this.model.removeActivity(compositeId, activity));
  }
  async pin(compositeId, open) {
    if (this.model.setPinned(compositeId, true)) {
      this.updateCompositeSwitcher();
      if (open) {
        await this.options.openComposite(compositeId);
        this.activateComposite(compositeId);
      }
    }
  }
  unpin(compositeId) {
    if (this.model.setPinned(compositeId, false)) {
      this.updateCompositeSwitcher();
      this.resetActiveComposite(compositeId);
    }
  }
  areBadgesEnabled(compositeId) {
    return this.viewDescriptorService.getViewContainerBadgeEnablementState(compositeId);
  }
  toggleBadgeEnablement(compositeId) {
    this.viewDescriptorService.setViewContainerBadgeEnablementState(compositeId, !this.areBadgesEnabled(compositeId));
    this.updateCompositeSwitcher();
    const item = this.model.findItem(compositeId);
    if (item) {
      item.activityAction.setBadge(item.activityAction.getBadge(), item.activityAction.getClass());
    }
  }
  resetActiveComposite(compositeId) {
    const defaultCompositeId = this.options.getDefaultCompositeId();
    if (!this.model.activeItem || this.model.activeItem.id !== compositeId) {
      return;
    }
    this.deactivateComposite(compositeId);
    if (defaultCompositeId && defaultCompositeId !== compositeId && this.isPinned(defaultCompositeId)) {
      this.options.openComposite(defaultCompositeId, true);
    } else {
      this.options.openComposite(this.visibleComposites.filter((cid) => cid !== compositeId)[0]);
    }
  }
  isPinned(compositeId) {
    const item = this.model.findItem(compositeId);
    return item == null ? void 0 : item.pinned;
  }
  move(compositeId, toCompositeId, before) {
    if (before !== void 0) {
      const fromIndex = this.model.items.findIndex((c) => c.id === compositeId);
      let toIndex = this.model.items.findIndex((c) => c.id === toCompositeId);
      if (fromIndex >= 0 && toIndex >= 0) {
        if (!before && fromIndex > toIndex) {
          toIndex++;
        }
        if (before && fromIndex < toIndex) {
          toIndex--;
        }
        if (toIndex < this.model.items.length && toIndex >= 0 && toIndex !== fromIndex) {
          if (this.model.move(this.model.items[fromIndex].id, this.model.items[toIndex].id)) {
            setTimeout(() => this.updateCompositeSwitcher(), 0);
          }
        }
      }
    } else {
      if (this.model.move(compositeId, toCompositeId)) {
        setTimeout(() => this.updateCompositeSwitcher(), 0);
      }
    }
  }
  getAction(compositeId) {
    const item = this.model.findItem(compositeId);
    return item == null ? void 0 : item.activityAction;
  }
  computeSizes(items) {
    const size2 = this.options.compositeSize;
    if (size2) {
      items.forEach((composite) => this.compositeSizeInBar.set(composite.id, size2));
    } else {
      const compositeSwitcherBar = this.compositeSwitcherBar;
      if (compositeSwitcherBar && this.dimension && this.dimension.height !== 0 && this.dimension.width !== 0) {
        const currentItemsLength = compositeSwitcherBar.viewItems.length;
        compositeSwitcherBar.push(items.map((composite) => composite.activityAction));
        items.forEach((composite, index) => this.compositeSizeInBar.set(composite.id, this.options.orientation === 1 ? compositeSwitcherBar.getHeight(currentItemsLength + index) : compositeSwitcherBar.getWidth(currentItemsLength + index)));
        items.forEach(() => compositeSwitcherBar.pull(compositeSwitcherBar.viewItems.length - 1));
      }
    }
  }
  updateCompositeSwitcher() {
    var _a2, _b2;
    const compositeSwitcherBar = this.compositeSwitcherBar;
    if (!compositeSwitcherBar || !this.dimension) {
      return;
    }
    let compositesToShow = this.model.visibleItems.filter((item) => item.pinned || this.model.activeItem && this.model.activeItem.id === item.id).map((item) => item.id);
    let maxVisible = compositesToShow.length;
    const totalComposites = compositesToShow.length;
    let size2 = 0;
    const limit = this.options.orientation === 1 ? this.dimension.height : this.dimension.width;
    for (let i = 0; i < compositesToShow.length; i++) {
      const compositeSize = this.compositeSizeInBar.get(compositesToShow[i]);
      if (size2 + compositeSize > limit) {
        maxVisible = i;
        break;
      }
      size2 += compositeSize;
    }
    if (totalComposites > maxVisible) {
      compositesToShow = compositesToShow.slice(0, maxVisible);
    }
    if (this.model.activeItem && compositesToShow.every((compositeId) => !!this.model.activeItem && compositeId !== this.model.activeItem.id)) {
      size2 += this.compositeSizeInBar.get(this.model.activeItem.id);
      compositesToShow.push(this.model.activeItem.id);
    }
    while (size2 > limit && compositesToShow.length) {
      const removedComposite = compositesToShow.length > 1 ? compositesToShow.splice(compositesToShow.length - 2, 1)[0] : compositesToShow.pop();
      size2 -= this.compositeSizeInBar.get(removedComposite);
    }
    if (totalComposites > compositesToShow.length) {
      size2 += this.options.overflowActionSize;
    }
    while (size2 > limit && compositesToShow.length) {
      const removedComposite = compositesToShow.length > 1 && compositesToShow[compositesToShow.length - 1] === ((_a2 = this.model.activeItem) == null ? void 0 : _a2.id) ? compositesToShow.splice(compositesToShow.length - 2, 1)[0] : compositesToShow.pop();
      size2 -= this.compositeSizeInBar.get(removedComposite);
    }
    if (totalComposites === compositesToShow.length && this.compositeOverflowAction) {
      compositeSwitcherBar.pull(compositeSwitcherBar.length() - 1);
      this.compositeOverflowAction.dispose();
      this.compositeOverflowAction = void 0;
      (_b2 = this.compositeOverflowActionViewItem) == null ? void 0 : _b2.dispose();
      this.compositeOverflowActionViewItem = void 0;
    }
    const compositesToRemove = [];
    this.visibleComposites.forEach((compositeId, index) => {
      if (!compositesToShow.includes(compositeId)) {
        compositesToRemove.push(index);
      }
    });
    compositesToRemove.reverse().forEach((index) => {
      const actionViewItem = compositeSwitcherBar.viewItems[index];
      compositeSwitcherBar.pull(index);
      actionViewItem.dispose();
      this.visibleComposites.splice(index, 1);
    });
    compositesToShow.forEach((compositeId, newIndex) => {
      const currentIndex = this.visibleComposites.indexOf(compositeId);
      if (newIndex !== currentIndex) {
        if (currentIndex !== -1) {
          const actionViewItem = compositeSwitcherBar.viewItems[currentIndex];
          compositeSwitcherBar.pull(currentIndex);
          actionViewItem.dispose();
          this.visibleComposites.splice(currentIndex, 1);
        }
        compositeSwitcherBar.push(this.model.findItem(compositeId).activityAction, { label: true, icon: this.options.icon, index: newIndex });
        this.visibleComposites.splice(newIndex, 0, compositeId);
      }
    });
    if (totalComposites > compositesToShow.length && !this.compositeOverflowAction) {
      this.compositeOverflowAction = this.instantiationService.createInstance(CompositeOverflowActivityAction, () => {
        var _a3;
        (_a3 = this.compositeOverflowActionViewItem) == null ? void 0 : _a3.showMenu();
      });
      this.compositeOverflowActionViewItem = this.instantiationService.createInstance(CompositeOverflowActivityActionViewItem, this.compositeOverflowAction, () => this.getOverflowingComposites(), () => this.model.activeItem ? this.model.activeItem.id : void 0, (compositeId) => {
        var _a3;
        const item = this.model.findItem(compositeId);
        return (_a3 = item == null ? void 0 : item.activity[0]) == null ? void 0 : _a3.badge;
      }, this.options.getOnCompositeClickAction, this.options.colors, this.options.activityHoverOptions);
      compositeSwitcherBar.push(this.compositeOverflowAction, { label: false, icon: true });
    }
    this._onDidChange.fire();
  }
  getOverflowingComposites() {
    let overflowingIds = this.model.visibleItems.filter((item) => item.pinned).map((item) => item.id);
    if (this.model.activeItem && !this.model.activeItem.pinned) {
      overflowingIds.push(this.model.activeItem.id);
    }
    overflowingIds = overflowingIds.filter((compositeId) => !this.visibleComposites.includes(compositeId));
    return this.model.visibleItems.filter((c) => overflowingIds.includes(c.id)).map(
      (item) => {
        var _a2;
        return { id: item.id, name: ((_a2 = this.getAction(item.id)) == null ? void 0 : _a2.label) || item.name };
      }
    );
  }
  showContextMenu(e) {
    EventHelper.stop(e, true);
    const event = new StandardMouseEvent(e);
    this.contextMenuService.showContextMenu({
      getAnchor: () => event,
      getActions: () => this.getContextMenuActions(e)
    });
  }
  getContextMenuActions(e) {
    const actions = this.model.visibleItems.map(({ id, name, activityAction }) => toAction({
      id,
      label: this.getAction(id).label || name || id,
      checked: this.isPinned(id),
      enabled: activityAction.enabled,
      run: () => {
        if (this.isPinned(id)) {
          this.unpin(id);
        } else {
          this.pin(id, true);
        }
      }
    }));
    return actions;
  }
};
CompositeBar = __decorate([
  __param(2, IInstantiationService),
  __param(3, IContextMenuService),
  __param(4, IViewDescriptorService)
], CompositeBar);
class CompositeBarModel {
  get items() {
    return this._items;
  }
  constructor(items, options) {
    this._items = [];
    this.options = options;
    this.setItems(items);
  }
  setItems(items) {
    const result = [];
    let hasChanges = false;
    if (!this.items || this.items.length === 0) {
      this._items = items.map(
        (i) => this.createCompositeBarItem(i.id, i.name, i.order, i.pinned, i.visible)
      );
      hasChanges = true;
    } else {
      const existingItems = this.items;
      for (let index = 0; index < items.length; index++) {
        const newItem = items[index];
        const existingItem = existingItems.filter(({ id }) => id === newItem.id)[0];
        if (existingItem) {
          if (existingItem.pinned !== newItem.pinned || index !== existingItems.indexOf(existingItem)) {
            existingItem.pinned = newItem.pinned;
            result.push(existingItem);
            hasChanges = true;
          } else {
            result.push(existingItem);
          }
        } else {
          result.push(this.createCompositeBarItem(newItem.id, newItem.name, newItem.order, newItem.pinned, newItem.visible));
          hasChanges = true;
        }
      }
      this._items = result;
    }
    return hasChanges;
  }
  get visibleItems() {
    return this.items.filter((item) => item.visible);
  }
  get pinnedItems() {
    return this.items.filter((item) => item.visible && item.pinned);
  }
  createCompositeBarItem(id, name, order, pinned, visible) {
    const options = this.options;
    return {
      id,
      name,
      pinned,
      order,
      visible,
      activity: [],
      get activityAction() {
        return options.getActivityAction(id);
      },
      get pinnedAction() {
        return options.getCompositePinnedAction(id);
      },
      get toggleBadgeAction() {
        return options.getCompositeBadgeAction(id);
      }
    };
  }
  add(id, name, order, requestedIndex) {
    const item = this.findItem(id);
    if (item) {
      let changed = false;
      item.name = name;
      if (!isUndefinedOrNull(order)) {
        changed = item.order !== order;
        item.order = order;
      }
      if (!item.visible) {
        item.visible = true;
        changed = true;
      }
      return changed;
    } else {
      const item2 = this.createCompositeBarItem(id, name, order, true, true);
      if (!isUndefinedOrNull(requestedIndex)) {
        let index = 0;
        let rIndex = requestedIndex;
        while (rIndex > 0 && index < this.items.length) {
          if (this.items[index++].visible) {
            rIndex--;
          }
        }
        this.items.splice(index, 0, item2);
      } else if (isUndefinedOrNull(order)) {
        this.items.push(item2);
      } else {
        let index = 0;
        while (index < this.items.length && typeof this.items[index].order === "number" && this.items[index].order < order) {
          index++;
        }
        this.items.splice(index, 0, item2);
      }
      return true;
    }
  }
  remove(id) {
    for (let index = 0; index < this.items.length; index++) {
      if (this.items[index].id === id) {
        this.items.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  hide(id) {
    for (const item of this.items) {
      if (item.id === id) {
        if (item.visible) {
          item.visible = false;
          return true;
        }
        return false;
      }
    }
    return false;
  }
  move(compositeId, toCompositeId) {
    const fromIndex = this.findIndex(compositeId);
    const toIndex = this.findIndex(toCompositeId);
    if (fromIndex === -1 || toIndex === -1) {
      return false;
    }
    const sourceItem = this.items.splice(fromIndex, 1)[0];
    this.items.splice(toIndex, 0, sourceItem);
    sourceItem.pinned = true;
    return true;
  }
  setPinned(id, pinned) {
    for (const item of this.items) {
      if (item.id === id) {
        if (item.pinned !== pinned) {
          item.pinned = pinned;
          return true;
        }
        return false;
      }
    }
    return false;
  }
  addActivity(id, activity) {
    const item = this.findItem(id);
    if (item) {
      const stack = item.activity;
      for (let i = 0; i <= stack.length; i++) {
        if (i === stack.length) {
          stack.push(activity);
          break;
        } else if (stack[i].priority <= activity.priority) {
          stack.splice(i, 0, activity);
          break;
        }
      }
      this.updateActivity(id);
      return true;
    }
    return false;
  }
  removeActivity(id, activity) {
    const item = this.findItem(id);
    if (item) {
      const index = item.activity.indexOf(activity);
      if (index !== -1) {
        item.activity.splice(index, 1);
        this.updateActivity(id);
        return true;
      }
    }
    return false;
  }
  updateActivity(id) {
    const item = this.findItem(id);
    if (item) {
      if (item.activity.length) {
        const [{ badge, clazz }] = item.activity;
        item.activityAction.setBadge(badge, clazz);
      } else {
        item.activityAction.setBadge(void 0);
      }
    }
  }
  activate(id) {
    if (!this.activeItem || this.activeItem.id !== id) {
      if (this.activeItem) {
        this.deactivate();
      }
      for (const item of this.items) {
        if (item.id === id) {
          this.activeItem = item;
          this.activeItem.activityAction.activate();
          return true;
        }
      }
    }
    return false;
  }
  deactivate() {
    if (this.activeItem) {
      this.activeItem.activityAction.deactivate();
      this.activeItem = void 0;
      return true;
    }
    return false;
  }
  findItem(id) {
    return this.items.filter((item) => item.id === id)[0];
  }
  findIndex(id) {
    for (let index = 0; index < this.items.length; index++) {
      if (this.items[index].id === id) {
        return index;
      }
    }
    return -1;
  }
}
var css$k = ".monaco-workbench .menubar .toolbar-toggle-more,.monaco-workbench .menubar>.menubar-menu-button{color:var(--vscode-titleBar-activeForeground)}.monaco-workbench .activitybar .menubar.compact .toolbar-toggle-more,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button{color:var(--vscode-activityBar-inactiveForeground)}.monaco-workbench .activitybar .menubar.compact:not(:focus-within)>.menubar-menu-button:hover,.monaco-workbench .activitybar .menubar.compact:not(:focus-within)>.menubar-menu-button:hover .toolbar-toggle-more,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button.open,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button.open .toolbar-toggle-more,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button:focus,.monaco-workbench .activitybar .menubar.compact>.menubar-menu-button:focus .toolbar-toggle-more{color:var(--vscode-activityBar-foreground)}.monaco-workbench .menubar.inactive:not(.compact)>.menubar-menu-button,.monaco-workbench .menubar.inactive:not(.compact)>.menubar-menu-button .toolbar-toggle-more{color:var(--vscode-titleBar-inactiveForeground)}.monaco-workbench .menubar:not(.compact)>.menubar-menu-button.open,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button.open .toolbar-toggle-more,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus .toolbar-toggle-more,.monaco-workbench .menubar:not(:focus-within):not(.compact)>.menubar-menu-button:hover,.monaco-workbench .menubar:not(:focus-within):not(.compact)>.menubar-menu-button:hover .toolbar-toggle-more{color:var(--vscode-menubar-selectionForeground)}.monaco-workbench .menubar:not(.compact)>.menubar-menu-button.open .menubar-menu-title,.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus .menubar-menu-title,.monaco-workbench .menubar:not(:focus-within):not(.compact)>.menubar-menu-button:hover .menubar-menu-title{background-color:var(--vscode-menubar-selectionBackground)}.monaco-workbench .menubar>.menubar-menu-button:hover .menubar-menu-title{outline:dashed 1px var(--vscode-menubar-selectionBorder)}.monaco-workbench .menubar>.menubar-menu-button.open .menubar-menu-title,.monaco-workbench .menubar>.menubar-menu-button:focus .menubar-menu-title{outline:solid 1px var(--vscode-menubar-selectionBorder)}.monaco-workbench .menubar>.menubar-menu-button.open .menubar-menu-title,.monaco-workbench .menubar>.menubar-menu-button:focus .menubar-menu-title,.monaco-workbench .menubar>.menubar-menu-button:hover .menubar-menu-title{outline-color:var(--vscode-menubar-selectionBorder);outline-offset:-1px}";
n(css$k, {});
var css$j = '.menubar{box-sizing:border-box;display:flex;flex-shrink:1;height:100%;overflow:hidden}.menubar.overflow-menu-only{width:38px}.fullscreen .menubar:not(.compact){margin:0;padding:4px 5px}.menubar>.menubar-menu-button{-webkit-app-region:no-drag;zoom:1;align-items:center;box-sizing:border-box;cursor:default;display:flex;outline:0!important;white-space:nowrap}.monaco-workbench .menubar:not(.compact)>.menubar-menu-button:focus .menubar-menu-title{outline-color:var(--vscode-focusBorder);outline-offset:-1px;outline-style:solid;outline-width:1px}.menubar.compact{flex-shrink:0;overflow:visible}.menubar.compact>.menubar-menu-button{height:100%;padding:0;width:100%}.menubar-menu-title{border-radius:5px;padding:0 8px}.menubar .menubar-menu-items-holder{left:0;opacity:1;position:fixed;z-index:2000}.menubar.compact .menubar-menu-items-holder{position:fixed}.menubar .menubar-menu-items-holder.monaco-menu-container{border:none;outline:0}.menubar .menubar-menu-items-holder.monaco-menu-container :focus{outline:0}.menubar .toolbar-toggle-more{align-items:center;display:flex;height:22px;justify-content:center;padding:0 8px;vertical-align:sub;width:22px}.menubar.compact .toolbar-toggle-more{align-items:center;cursor:pointer;display:flex;justify-content:center;left:0;position:relative;top:0;width:100%}.menubar.compact .toolbar-toggle-more:before,.menubar:not(.compact) .menubar-menu-button:first-child .toolbar-toggle-more:before{content:"\\eb94"!important}.menubar.compact>.menubar-menu-button.open .menubar-menu-title,.menubar.compact>.menubar-menu-button:focus .menubar-menu-title,.menubar.compact>.menubar-menu-button:hover .menubar-menu-title{outline-offset:-8px!important;outline-width:1px!important}';
n(css$j, {});
const $$1 = $$2;
var MenubarState;
(function(MenubarState2) {
  MenubarState2[MenubarState2["HIDDEN"] = 0] = "HIDDEN";
  MenubarState2[MenubarState2["VISIBLE"] = 1] = "VISIBLE";
  MenubarState2[MenubarState2["FOCUSED"] = 2] = "FOCUSED";
  MenubarState2[MenubarState2["OPEN"] = 3] = "OPEN";
})(MenubarState || (MenubarState = {}));
const _MenuBar = class _MenuBar extends Disposable {
  constructor(container, options, menuStyle) {
    super();
    this.container = container;
    this.options = options;
    this.menuStyle = menuStyle;
    this._mnemonicsInUse = false;
    this.openedViaKeyboard = false;
    this.awaitingAltRelease = false;
    this.ignoreNextMouseUp = false;
    this.updatePending = false;
    this.numMenusShown = 0;
    this.overflowLayoutScheduled = void 0;
    this.container.setAttribute("role", "menubar");
    if (this.isCompact) {
      this.container.classList.add("compact");
    }
    this.menus = [];
    this.mnemonics = /* @__PURE__ */ new Map();
    this._focusState = MenubarState.VISIBLE;
    this._onVisibilityChange = this._register(new Emitter());
    this._onFocusStateChange = this._register(new Emitter());
    this.createOverflowMenu();
    this.menuUpdater = this._register(new RunOnceScheduler(() => this.update(), 200));
    this.actionRunner = this.options.actionRunner ?? this._register(new ActionRunner());
    this._register(this.actionRunner.onWillRun(() => {
      this.setUnfocusedState();
    }));
    this._register(ModifierKeyEmitter.getInstance().event(this.onModifierKeyToggled, this));
    this._register(addDisposableListener(this.container, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = true;
      const key = !!e.key ? e.key.toLocaleLowerCase() : "";
      const tabNav = isMacintosh && !this.isCompact;
      if (event.equals(15) || tabNav && event.equals(2 | 1024)) {
        this.focusPrevious();
      } else if (event.equals(17) || tabNav && event.equals(2)) {
        this.focusNext();
      } else if (event.equals(9) && this.isFocused && !this.isOpen) {
        this.setUnfocusedState();
      } else if (!this.isOpen && !event.ctrlKey && this.options.enableMnemonics && this.mnemonicsInUse && this.mnemonics.has(key)) {
        const menuIndex = this.mnemonics.get(key);
        this.onMenuTriggered(menuIndex, false);
      } else {
        eventHandled = false;
      }
      if (!this.isCompact && (event.equals(2 | 1024) || event.equals(2))) {
        event.preventDefault();
      }
      if (eventHandled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }));
    this._register(addDisposableListener(window, EventType.MOUSE_DOWN, () => {
      if (this.isFocused) {
        this.setUnfocusedState();
      }
    }));
    this._register(addDisposableListener(this.container, EventType.FOCUS_IN, (e) => {
      const event = e;
      if (event.relatedTarget) {
        if (!this.container.contains(event.relatedTarget)) {
          this.focusToReturn = event.relatedTarget;
        }
      }
    }));
    this._register(addDisposableListener(this.container, EventType.FOCUS_OUT, (e) => {
      const event = e;
      if (!event.relatedTarget) {
        this.setUnfocusedState();
      } else if (event.relatedTarget && !this.container.contains(event.relatedTarget)) {
        this.focusToReturn = void 0;
        this.setUnfocusedState();
      }
    }));
    this._register(addDisposableListener(window, EventType.KEY_DOWN, (e) => {
      if (!this.options.enableMnemonics || !e.altKey || e.ctrlKey || e.defaultPrevented) {
        return;
      }
      const key = e.key.toLocaleLowerCase();
      if (!this.mnemonics.has(key)) {
        return;
      }
      this.mnemonicsInUse = true;
      this.updateMnemonicVisibility(true);
      const menuIndex = this.mnemonics.get(key);
      this.onMenuTriggered(menuIndex, false);
    }));
    this.setUnfocusedState();
  }
  push(arg) {
    const menus = asArray(arg);
    menus.forEach((menuBarMenu) => {
      const menuIndex = this.menus.length;
      const cleanMenuLabel = cleanMnemonic(menuBarMenu.label);
      const mnemonicMatches = MENU_MNEMONIC_REGEX.exec(menuBarMenu.label);
      if (mnemonicMatches) {
        const mnemonic = !!mnemonicMatches[1] ? mnemonicMatches[1] : mnemonicMatches[3];
        this.registerMnemonic(this.menus.length, mnemonic);
      }
      if (this.isCompact) {
        this.menus.push(menuBarMenu);
      } else {
        const buttonElement = $$1("div.menubar-menu-button", { "role": "menuitem", "tabindex": -1, "aria-label": cleanMenuLabel, "aria-haspopup": true });
        const titleElement = $$1("div.menubar-menu-title", { "role": "none", "aria-hidden": true });
        buttonElement.appendChild(titleElement);
        this.container.insertBefore(buttonElement, this.overflowMenu.buttonElement);
        this.updateLabels(titleElement, buttonElement, menuBarMenu.label);
        this._register(addDisposableListener(buttonElement, EventType.KEY_UP, (e) => {
          const event = new StandardKeyboardEvent(e);
          let eventHandled = true;
          if ((event.equals(18) || event.equals(3)) && !this.isOpen) {
            this.focusedMenu = { index: menuIndex };
            this.openedViaKeyboard = true;
            this.focusState = MenubarState.OPEN;
          } else {
            eventHandled = false;
          }
          if (eventHandled) {
            event.preventDefault();
            event.stopPropagation();
          }
        }));
        this._register(Gesture.addTarget(buttonElement));
        this._register(addDisposableListener(buttonElement, EventType$1.Tap, (e) => {
          if (this.isOpen && this.focusedMenu && this.focusedMenu.holder && isAncestor(e.initialTarget, this.focusedMenu.holder)) {
            return;
          }
          this.ignoreNextMouseUp = false;
          this.onMenuTriggered(menuIndex, true);
          e.preventDefault();
          e.stopPropagation();
        }));
        this._register(addDisposableListener(buttonElement, EventType.MOUSE_DOWN, (e) => {
          const mouseEvent = new StandardMouseEvent(e);
          if (!mouseEvent.leftButton) {
            e.preventDefault();
            return;
          }
          if (!this.isOpen) {
            this.ignoreNextMouseUp = true;
            this.onMenuTriggered(menuIndex, true);
          } else {
            this.ignoreNextMouseUp = false;
          }
          e.preventDefault();
          e.stopPropagation();
        }));
        this._register(addDisposableListener(buttonElement, EventType.MOUSE_UP, (e) => {
          if (e.defaultPrevented) {
            return;
          }
          if (!this.ignoreNextMouseUp) {
            if (this.isFocused) {
              this.onMenuTriggered(menuIndex, true);
            }
          } else {
            this.ignoreNextMouseUp = false;
          }
        }));
        this._register(addDisposableListener(buttonElement, EventType.MOUSE_ENTER, () => {
          if (this.isOpen && !this.isCurrentMenu(menuIndex)) {
            buttonElement.focus();
            this.cleanupCustomMenu();
            this.showCustomMenu(menuIndex, false);
          } else if (this.isFocused && !this.isOpen) {
            this.focusedMenu = { index: menuIndex };
            buttonElement.focus();
          }
        }));
        this.menus.push({
          label: menuBarMenu.label,
          actions: menuBarMenu.actions,
          buttonElement,
          titleElement
        });
      }
    });
  }
  createOverflowMenu() {
    const label = this.isCompact ? localize("mAppMenu", "Application Menu") : localize("mMore", "More");
    const buttonElement = $$1("div.menubar-menu-button", { "role": "menuitem", "tabindex": this.isCompact ? 0 : -1, "aria-label": label, "aria-haspopup": true });
    const titleElement = $$1("div.menubar-menu-title.toolbar-toggle-more" + ThemeIcon.asCSSSelector(Codicon.menuBarMore), { "role": "none", "aria-hidden": true });
    buttonElement.appendChild(titleElement);
    this.container.appendChild(buttonElement);
    buttonElement.style.visibility = "hidden";
    this._register(addDisposableListener(buttonElement, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = true;
      const triggerKeys = [3];
      if (!this.isCompact) {
        triggerKeys.push(18);
      } else {
        triggerKeys.push(10);
        if (this.options.compactMode === Direction.Right) {
          triggerKeys.push(17);
        } else if (this.options.compactMode === Direction.Left) {
          triggerKeys.push(15);
        }
      }
      if (triggerKeys.some((k) => event.equals(k)) && !this.isOpen) {
        this.focusedMenu = { index: _MenuBar.OVERFLOW_INDEX };
        this.openedViaKeyboard = true;
        this.focusState = MenubarState.OPEN;
      } else {
        eventHandled = false;
      }
      if (eventHandled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }));
    this._register(Gesture.addTarget(buttonElement));
    this._register(addDisposableListener(buttonElement, EventType$1.Tap, (e) => {
      if (this.isOpen && this.focusedMenu && this.focusedMenu.holder && isAncestor(e.initialTarget, this.focusedMenu.holder)) {
        return;
      }
      this.ignoreNextMouseUp = false;
      this.onMenuTriggered(_MenuBar.OVERFLOW_INDEX, true);
      e.preventDefault();
      e.stopPropagation();
    }));
    this._register(addDisposableListener(buttonElement, EventType.MOUSE_DOWN, (e) => {
      const mouseEvent = new StandardMouseEvent(e);
      if (!mouseEvent.leftButton) {
        e.preventDefault();
        return;
      }
      if (!this.isOpen) {
        this.ignoreNextMouseUp = true;
        this.onMenuTriggered(_MenuBar.OVERFLOW_INDEX, true);
      } else {
        this.ignoreNextMouseUp = false;
      }
      e.preventDefault();
      e.stopPropagation();
    }));
    this._register(addDisposableListener(buttonElement, EventType.MOUSE_UP, (e) => {
      if (e.defaultPrevented) {
        return;
      }
      if (!this.ignoreNextMouseUp) {
        if (this.isFocused) {
          this.onMenuTriggered(_MenuBar.OVERFLOW_INDEX, true);
        }
      } else {
        this.ignoreNextMouseUp = false;
      }
    }));
    this._register(addDisposableListener(buttonElement, EventType.MOUSE_ENTER, () => {
      if (this.isOpen && !this.isCurrentMenu(_MenuBar.OVERFLOW_INDEX)) {
        this.overflowMenu.buttonElement.focus();
        this.cleanupCustomMenu();
        this.showCustomMenu(_MenuBar.OVERFLOW_INDEX, false);
      } else if (this.isFocused && !this.isOpen) {
        this.focusedMenu = { index: _MenuBar.OVERFLOW_INDEX };
        buttonElement.focus();
      }
    }));
    this.overflowMenu = {
      buttonElement,
      titleElement,
      label: "More",
      actions: []
    };
  }
  updateMenu(menu) {
    const menuToUpdate = this.menus.filter((menuBarMenu) => menuBarMenu.label === menu.label);
    if (menuToUpdate && menuToUpdate.length) {
      menuToUpdate[0].actions = menu.actions;
    }
  }
  dispose() {
    super.dispose();
    this.menus.forEach((menuBarMenu) => {
      var _a2, _b2;
      (_a2 = menuBarMenu.titleElement) == null ? void 0 : _a2.remove();
      (_b2 = menuBarMenu.buttonElement) == null ? void 0 : _b2.remove();
    });
    this.overflowMenu.titleElement.remove();
    this.overflowMenu.buttonElement.remove();
    dispose(this.overflowLayoutScheduled);
    this.overflowLayoutScheduled = void 0;
  }
  blur() {
    this.setUnfocusedState();
  }
  getWidth() {
    if (!this.isCompact && this.menus) {
      const left = this.menus[0].buttonElement.getBoundingClientRect().left;
      const right = this.hasOverflow ? this.overflowMenu.buttonElement.getBoundingClientRect().right : this.menus[this.menus.length - 1].buttonElement.getBoundingClientRect().right;
      return right - left;
    }
    return 0;
  }
  getHeight() {
    return this.container.clientHeight;
  }
  toggleFocus() {
    if (!this.isFocused && this.options.visibility !== "hidden") {
      this.mnemonicsInUse = true;
      this.focusedMenu = { index: this.numMenusShown > 0 ? 0 : _MenuBar.OVERFLOW_INDEX };
      this.focusState = MenubarState.FOCUSED;
    } else if (!this.isOpen) {
      this.setUnfocusedState();
    }
  }
  updateOverflowAction() {
    var _a2, _b2;
    if (!this.menus || !this.menus.length) {
      return;
    }
    const overflowMenuOnlyClass = "overflow-menu-only";
    this.container.classList.toggle(overflowMenuOnlyClass, false);
    const sizeAvailable = this.container.offsetWidth;
    let currentSize = 0;
    let full = this.isCompact;
    const prevNumMenusShown = this.numMenusShown;
    this.numMenusShown = 0;
    const showableMenus = this.menus.filter((menu) => menu.buttonElement !== void 0 && menu.titleElement !== void 0);
    for (const menuBarMenu of showableMenus) {
      if (!full) {
        const size2 = menuBarMenu.buttonElement.offsetWidth;
        if (currentSize + size2 > sizeAvailable) {
          full = true;
        } else {
          currentSize += size2;
          this.numMenusShown++;
          if (this.numMenusShown > prevNumMenusShown) {
            menuBarMenu.buttonElement.style.visibility = "visible";
          }
        }
      }
      if (full) {
        menuBarMenu.buttonElement.style.visibility = "hidden";
      }
    }
    if (this.numMenusShown - 1 <= showableMenus.length / 2) {
      for (const menuBarMenu of showableMenus) {
        menuBarMenu.buttonElement.style.visibility = "hidden";
      }
      full = true;
      this.numMenusShown = 0;
      currentSize = 0;
    }
    if (this.isCompact) {
      this.overflowMenu.actions = [];
      for (let idx = this.numMenusShown; idx < this.menus.length; idx++) {
        this.overflowMenu.actions.push(new SubmenuAction(
          `menubar.submenu.${this.menus[idx].label}`,
          this.menus[idx].label,
          this.menus[idx].actions || []
        ));
      }
      const compactMenuActions = (_b2 = (_a2 = this.options).getCompactMenuActions) == null ? void 0 : _b2.call(_a2);
      if (compactMenuActions && compactMenuActions.length) {
        this.overflowMenu.actions.push(new Separator());
        this.overflowMenu.actions.push(...compactMenuActions);
      }
      this.overflowMenu.buttonElement.style.visibility = "visible";
    } else if (full) {
      while (currentSize + this.overflowMenu.buttonElement.offsetWidth > sizeAvailable && this.numMenusShown > 0) {
        this.numMenusShown--;
        const size2 = showableMenus[this.numMenusShown].buttonElement.offsetWidth;
        showableMenus[this.numMenusShown].buttonElement.style.visibility = "hidden";
        currentSize -= size2;
      }
      this.overflowMenu.actions = [];
      for (let idx = this.numMenusShown; idx < showableMenus.length; idx++) {
        this.overflowMenu.actions.push(new SubmenuAction(
          `menubar.submenu.${showableMenus[idx].label}`,
          showableMenus[idx].label,
          showableMenus[idx].actions || []
        ));
      }
      if (this.overflowMenu.buttonElement.nextElementSibling !== showableMenus[this.numMenusShown].buttonElement) {
        this.overflowMenu.buttonElement.remove();
        this.container.insertBefore(this.overflowMenu.buttonElement, showableMenus[this.numMenusShown].buttonElement);
      }
      this.overflowMenu.buttonElement.style.visibility = "visible";
    } else {
      this.overflowMenu.buttonElement.remove();
      this.container.appendChild(this.overflowMenu.buttonElement);
      this.overflowMenu.buttonElement.style.visibility = "hidden";
    }
    this.container.classList.toggle(overflowMenuOnlyClass, this.numMenusShown === 0);
  }
  updateLabels(titleElement, buttonElement, label) {
    const cleanMenuLabel = cleanMnemonic(label);
    if (this.options.enableMnemonics) {
      const cleanLabel = escape(label);
      MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;
      let escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(cleanLabel);
      while (escMatch && escMatch[1]) {
        escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(cleanLabel);
      }
      const replaceDoubleEscapes = (str) => str.replace(/&amp;&amp;/g, "&amp;");
      if (escMatch) {
        titleElement.innerText = "";
        titleElement.append(ltrim(replaceDoubleEscapes(cleanLabel.substr(0, escMatch.index)), " "), $$1("mnemonic", { "aria-hidden": "true" }, escMatch[3]), rtrim(replaceDoubleEscapes(cleanLabel.substr(escMatch.index + escMatch[0].length)), " "));
      } else {
        titleElement.innerText = replaceDoubleEscapes(cleanLabel).trim();
      }
    } else {
      titleElement.innerText = cleanMenuLabel.replace(/&&/g, "&");
    }
    const mnemonicMatches = MENU_MNEMONIC_REGEX.exec(label);
    if (mnemonicMatches) {
      const mnemonic = !!mnemonicMatches[1] ? mnemonicMatches[1] : mnemonicMatches[3];
      if (this.options.enableMnemonics) {
        buttonElement.setAttribute("aria-keyshortcuts", "Alt+" + mnemonic.toLocaleLowerCase());
      } else {
        buttonElement.removeAttribute("aria-keyshortcuts");
      }
    }
  }
  update(options) {
    if (options) {
      this.options = options;
    }
    if (this.isFocused) {
      this.updatePending = true;
      return;
    }
    this.menus.forEach((menuBarMenu) => {
      if (!menuBarMenu.buttonElement || !menuBarMenu.titleElement) {
        return;
      }
      this.updateLabels(menuBarMenu.titleElement, menuBarMenu.buttonElement, menuBarMenu.label);
    });
    if (!this.overflowLayoutScheduled) {
      this.overflowLayoutScheduled = scheduleAtNextAnimationFrame(() => {
        this.updateOverflowAction();
        this.overflowLayoutScheduled = void 0;
      });
    }
    this.setUnfocusedState();
  }
  registerMnemonic(menuIndex, mnemonic) {
    this.mnemonics.set(mnemonic.toLocaleLowerCase(), menuIndex);
  }
  hideMenubar() {
    if (this.container.style.display !== "none") {
      this.container.style.display = "none";
      this._onVisibilityChange.fire(false);
    }
  }
  showMenubar() {
    if (this.container.style.display !== "flex") {
      this.container.style.display = "flex";
      this._onVisibilityChange.fire(true);
      this.updateOverflowAction();
    }
  }
  get focusState() {
    return this._focusState;
  }
  set focusState(value) {
    var _a2, _b2;
    if (this._focusState >= MenubarState.FOCUSED && value < MenubarState.FOCUSED) {
      if (this.updatePending) {
        this.menuUpdater.schedule();
        this.updatePending = false;
      }
    }
    if (value === this._focusState) {
      return;
    }
    const isVisible = this.isVisible;
    const isOpen = this.isOpen;
    const isFocused = this.isFocused;
    this._focusState = value;
    switch (value) {
      case MenubarState.HIDDEN:
        if (isVisible) {
          this.hideMenubar();
        }
        if (isOpen) {
          this.cleanupCustomMenu();
        }
        if (isFocused) {
          this.focusedMenu = void 0;
          if (this.focusToReturn) {
            this.focusToReturn.focus();
            this.focusToReturn = void 0;
          }
        }
        break;
      case MenubarState.VISIBLE:
        if (!isVisible) {
          this.showMenubar();
        }
        if (isOpen) {
          this.cleanupCustomMenu();
        }
        if (isFocused) {
          if (this.focusedMenu) {
            if (this.focusedMenu.index === _MenuBar.OVERFLOW_INDEX) {
              this.overflowMenu.buttonElement.blur();
            } else {
              (_a2 = this.menus[this.focusedMenu.index].buttonElement) == null ? void 0 : _a2.blur();
            }
          }
          this.focusedMenu = void 0;
          if (this.focusToReturn) {
            this.focusToReturn.focus();
            this.focusToReturn = void 0;
          }
        }
        break;
      case MenubarState.FOCUSED:
        if (!isVisible) {
          this.showMenubar();
        }
        if (isOpen) {
          this.cleanupCustomMenu();
        }
        if (this.focusedMenu) {
          if (this.focusedMenu.index === _MenuBar.OVERFLOW_INDEX) {
            this.overflowMenu.buttonElement.focus();
          } else {
            (_b2 = this.menus[this.focusedMenu.index].buttonElement) == null ? void 0 : _b2.focus();
          }
        }
        break;
      case MenubarState.OPEN:
        if (!isVisible) {
          this.showMenubar();
        }
        if (this.focusedMenu) {
          this.showCustomMenu(this.focusedMenu.index, this.openedViaKeyboard);
        }
        break;
    }
    this._focusState = value;
    this._onFocusStateChange.fire(this.focusState >= MenubarState.FOCUSED);
  }
  get isVisible() {
    return this.focusState >= MenubarState.VISIBLE;
  }
  get isFocused() {
    return this.focusState >= MenubarState.FOCUSED;
  }
  get isOpen() {
    return this.focusState >= MenubarState.OPEN;
  }
  get hasOverflow() {
    return this.isCompact || this.numMenusShown < this.menus.length;
  }
  get isCompact() {
    return this.options.compactMode !== void 0;
  }
  setUnfocusedState() {
    if (this.options.visibility === "toggle" || this.options.visibility === "hidden") {
      this.focusState = MenubarState.HIDDEN;
    } else if (this.options.visibility === "classic" && isFullscreen()) {
      this.focusState = MenubarState.HIDDEN;
    } else {
      this.focusState = MenubarState.VISIBLE;
    }
    this.ignoreNextMouseUp = false;
    this.mnemonicsInUse = false;
    this.updateMnemonicVisibility(false);
  }
  focusPrevious() {
    var _a2;
    if (!this.focusedMenu || this.numMenusShown === 0) {
      return;
    }
    let newFocusedIndex = (this.focusedMenu.index - 1 + this.numMenusShown) % this.numMenusShown;
    if (this.focusedMenu.index === _MenuBar.OVERFLOW_INDEX) {
      newFocusedIndex = this.numMenusShown - 1;
    } else if (this.focusedMenu.index === 0 && this.hasOverflow) {
      newFocusedIndex = _MenuBar.OVERFLOW_INDEX;
    }
    if (newFocusedIndex === this.focusedMenu.index) {
      return;
    }
    if (this.isOpen) {
      this.cleanupCustomMenu();
      this.showCustomMenu(newFocusedIndex);
    } else if (this.isFocused) {
      this.focusedMenu.index = newFocusedIndex;
      if (newFocusedIndex === _MenuBar.OVERFLOW_INDEX) {
        this.overflowMenu.buttonElement.focus();
      } else {
        (_a2 = this.menus[newFocusedIndex].buttonElement) == null ? void 0 : _a2.focus();
      }
    }
  }
  focusNext() {
    var _a2;
    if (!this.focusedMenu || this.numMenusShown === 0) {
      return;
    }
    let newFocusedIndex = (this.focusedMenu.index + 1) % this.numMenusShown;
    if (this.focusedMenu.index === _MenuBar.OVERFLOW_INDEX) {
      newFocusedIndex = 0;
    } else if (this.focusedMenu.index === this.numMenusShown - 1) {
      newFocusedIndex = _MenuBar.OVERFLOW_INDEX;
    }
    if (newFocusedIndex === this.focusedMenu.index) {
      return;
    }
    if (this.isOpen) {
      this.cleanupCustomMenu();
      this.showCustomMenu(newFocusedIndex);
    } else if (this.isFocused) {
      this.focusedMenu.index = newFocusedIndex;
      if (newFocusedIndex === _MenuBar.OVERFLOW_INDEX) {
        this.overflowMenu.buttonElement.focus();
      } else {
        (_a2 = this.menus[newFocusedIndex].buttonElement) == null ? void 0 : _a2.focus();
      }
    }
  }
  updateMnemonicVisibility(visible) {
    if (this.menus) {
      this.menus.forEach((menuBarMenu) => {
        if (menuBarMenu.titleElement && menuBarMenu.titleElement.children.length) {
          const child = menuBarMenu.titleElement.children.item(0);
          if (child) {
            child.style.textDecoration = this.options.alwaysOnMnemonics || visible ? "underline" : "";
          }
        }
      });
    }
  }
  get mnemonicsInUse() {
    return this._mnemonicsInUse;
  }
  set mnemonicsInUse(value) {
    this._mnemonicsInUse = value;
  }
  get shouldAltKeyFocus() {
    if (isMacintosh) {
      return false;
    }
    if (!this.options.disableAltFocus) {
      return true;
    }
    if (this.options.visibility === "toggle") {
      return true;
    }
    return false;
  }
  get onVisibilityChange() {
    return this._onVisibilityChange.event;
  }
  get onFocusStateChange() {
    return this._onFocusStateChange.event;
  }
  onMenuTriggered(menuIndex, clicked) {
    if (this.isOpen) {
      if (this.isCurrentMenu(menuIndex)) {
        this.setUnfocusedState();
      } else {
        this.cleanupCustomMenu();
        this.showCustomMenu(menuIndex, this.openedViaKeyboard);
      }
    } else {
      this.focusedMenu = { index: menuIndex };
      this.openedViaKeyboard = !clicked;
      this.focusState = MenubarState.OPEN;
    }
  }
  onModifierKeyToggled(modifierKeyStatus) {
    const allModifiersReleased = !modifierKeyStatus.altKey && !modifierKeyStatus.ctrlKey && !modifierKeyStatus.shiftKey && !modifierKeyStatus.metaKey;
    if (this.options.visibility === "hidden") {
      return;
    }
    if (modifierKeyStatus.event && this.shouldAltKeyFocus) {
      if (ScanCodeUtils.toEnum(modifierKeyStatus.event.code) === 159) {
        modifierKeyStatus.event.preventDefault();
      }
    }
    if (this.isFocused && modifierKeyStatus.lastKeyPressed === "alt" && modifierKeyStatus.altKey) {
      this.setUnfocusedState();
      this.mnemonicsInUse = false;
      this.awaitingAltRelease = true;
    }
    if (allModifiersReleased && modifierKeyStatus.lastKeyPressed === "alt" && modifierKeyStatus.lastKeyReleased === "alt") {
      if (!this.awaitingAltRelease) {
        if (!this.isFocused && this.shouldAltKeyFocus) {
          this.mnemonicsInUse = true;
          this.focusedMenu = { index: this.numMenusShown > 0 ? 0 : _MenuBar.OVERFLOW_INDEX };
          this.focusState = MenubarState.FOCUSED;
        } else if (!this.isOpen) {
          this.setUnfocusedState();
        }
      }
    }
    if (!modifierKeyStatus.altKey && modifierKeyStatus.lastKeyReleased === "alt") {
      this.awaitingAltRelease = false;
    }
    if (this.options.enableMnemonics && this.menus && !this.isOpen) {
      this.updateMnemonicVisibility(!this.awaitingAltRelease && modifierKeyStatus.altKey || this.mnemonicsInUse);
    }
  }
  isCurrentMenu(menuIndex) {
    if (!this.focusedMenu) {
      return false;
    }
    return this.focusedMenu.index === menuIndex;
  }
  cleanupCustomMenu() {
    var _a2, _b2, _c2;
    if (this.focusedMenu) {
      if (this.focusedMenu.index === _MenuBar.OVERFLOW_INDEX) {
        this.overflowMenu.buttonElement.focus();
      } else {
        (_a2 = this.menus[this.focusedMenu.index].buttonElement) == null ? void 0 : _a2.focus();
      }
      if (this.focusedMenu.holder) {
        (_b2 = this.focusedMenu.holder.parentElement) == null ? void 0 : _b2.classList.remove("open");
        this.focusedMenu.holder.remove();
      }
      (_c2 = this.focusedMenu.widget) == null ? void 0 : _c2.dispose();
      this.focusedMenu = { index: this.focusedMenu.index };
    }
  }
  showCustomMenu(menuIndex, selectFirst = true) {
    const actualMenuIndex = menuIndex >= this.numMenusShown ? _MenuBar.OVERFLOW_INDEX : menuIndex;
    const customMenu = actualMenuIndex === _MenuBar.OVERFLOW_INDEX ? this.overflowMenu : this.menus[actualMenuIndex];
    if (!customMenu.actions || !customMenu.buttonElement || !customMenu.titleElement) {
      return;
    }
    const menuHolder = $$1("div.menubar-menu-items-holder", { "title": "" });
    customMenu.buttonElement.classList.add("open");
    const titleBoundingRect = customMenu.titleElement.getBoundingClientRect();
    const titleBoundingRectZoom = getDomNodeZoomLevel(customMenu.titleElement);
    if (this.options.compactMode === Direction.Right) {
      menuHolder.style.top = `${titleBoundingRect.top}px`;
      menuHolder.style.left = `${titleBoundingRect.left + this.container.clientWidth}px`;
    } else if (this.options.compactMode === Direction.Left) {
      menuHolder.style.top = `${titleBoundingRect.top}px`;
      menuHolder.style.right = `${this.container.clientWidth}px`;
      menuHolder.style.left = "auto";
    } else {
      menuHolder.style.top = `${titleBoundingRect.bottom * titleBoundingRectZoom}px`;
      menuHolder.style.left = `${titleBoundingRect.left * titleBoundingRectZoom}px`;
    }
    customMenu.buttonElement.appendChild(menuHolder);
    const menuOptions = {
      getKeyBinding: this.options.getKeybinding,
      actionRunner: this.actionRunner,
      enableMnemonics: this.options.alwaysOnMnemonics || this.mnemonicsInUse && this.options.enableMnemonics,
      ariaLabel: withNullAsUndefined(customMenu.buttonElement.getAttribute("aria-label")),
      expandDirection: this.isCompact ? this.options.compactMode : Direction.Right,
      useEventAsContext: true
    };
    const menuWidget = this._register(new Menu(menuHolder, customMenu.actions, menuOptions, this.menuStyle));
    this._register(menuWidget.onDidCancel(() => {
      this.focusState = MenubarState.FOCUSED;
    }));
    if (actualMenuIndex !== menuIndex) {
      menuWidget.trigger(menuIndex - this.numMenusShown);
    } else {
      menuWidget.focus(selectFirst);
    }
    this.focusedMenu = {
      index: actualMenuIndex,
      holder: menuHolder,
      widget: menuWidget
    };
  }
};
_MenuBar.OVERFLOW_INDEX = -1;
let MenuBar = _MenuBar;
function isFolderBackupInfo(curr) {
  return curr && curr.hasOwnProperty("folderUri");
}
function isWorkspaceBackupInfo(curr) {
  return curr && curr.hasOwnProperty("workspace");
}
const inRecentFilesPickerContextKey = "inRecentFilesPicker";
class BaseOpenRecentAction extends Action2 {
  constructor(desc) {
    super(desc);
    this.removeFromRecentlyOpened = {
      iconClass: ThemeIcon.asClassName(Codicon.removeClose),
      tooltip: localize("remove", "Remove from Recently Opened")
    };
    this.dirtyRecentlyOpenedFolder = {
      iconClass: "dirty-workspace " + ThemeIcon.asClassName(Codicon.closeDirty),
      tooltip: localize("dirtyRecentlyOpenedFolder", "Folder With Unsaved Files"),
      alwaysVisible: true
    };
    this.dirtyRecentlyOpenedWorkspace = {
      ...this.dirtyRecentlyOpenedFolder,
      tooltip: localize("dirtyRecentlyOpenedWorkspace", "Workspace With Unsaved Files")
    };
  }
  async run(accessor) {
    const workspacesService = accessor.get(IWorkspacesService);
    const quickInputService = accessor.get(IQuickInputService);
    const contextService = accessor.get(IWorkspaceContextService);
    const labelService = accessor.get(ILabelService);
    const keybindingService = accessor.get(IKeybindingService);
    const modelService = accessor.get(IModelService);
    const languageService = accessor.get(ILanguageService);
    const hostService = accessor.get(IHostService);
    const dialogService = accessor.get(IDialogService);
    const recentlyOpened = await workspacesService.getRecentlyOpened();
    const dirtyWorkspacesAndFolders = await workspacesService.getDirtyWorkspaces();
    let hasWorkspaces = false;
    const dirtyFolders = new ResourceMap();
    const dirtyWorkspaces = new ResourceMap();
    for (const dirtyWorkspace of dirtyWorkspacesAndFolders) {
      if (isFolderBackupInfo(dirtyWorkspace)) {
        dirtyFolders.set(dirtyWorkspace.folderUri, true);
      } else {
        dirtyWorkspaces.set(dirtyWorkspace.workspace.configPath, dirtyWorkspace.workspace);
        hasWorkspaces = true;
      }
    }
    const recentFolders = new ResourceMap();
    const recentWorkspaces = new ResourceMap();
    for (const recent of recentlyOpened.workspaces) {
      if (isRecentFolder(recent)) {
        recentFolders.set(recent.folderUri, true);
      } else {
        recentWorkspaces.set(recent.workspace.configPath, recent.workspace);
        hasWorkspaces = true;
      }
    }
    const workspacePicks = [];
    for (const recent of recentlyOpened.workspaces) {
      const isDirty = isRecentFolder(recent) ? dirtyFolders.has(recent.folderUri) : dirtyWorkspaces.has(recent.workspace.configPath);
      workspacePicks.push(this.toQuickPick(modelService, languageService, labelService, recent, isDirty));
    }
    for (const dirtyWorkspaceOrFolder of dirtyWorkspacesAndFolders) {
      if (isFolderBackupInfo(dirtyWorkspaceOrFolder) && !recentFolders.has(dirtyWorkspaceOrFolder.folderUri)) {
        workspacePicks.push(this.toQuickPick(modelService, languageService, labelService, dirtyWorkspaceOrFolder, true));
      } else if (isWorkspaceBackupInfo(dirtyWorkspaceOrFolder) && !recentWorkspaces.has(dirtyWorkspaceOrFolder.workspace.configPath)) {
        workspacePicks.push(this.toQuickPick(modelService, languageService, labelService, dirtyWorkspaceOrFolder, true));
      }
    }
    const filePicks = recentlyOpened.files.map(
      (p) => this.toQuickPick(modelService, languageService, labelService, p, false)
    );
    const firstEntry = recentlyOpened.workspaces[0];
    const autoFocusSecondEntry = firstEntry && contextService.isCurrentWorkspace(isRecentWorkspace(firstEntry) ? firstEntry.workspace : firstEntry.folderUri);
    let keyMods;
    const workspaceSeparator = { type: "separator", label: hasWorkspaces ? localize("workspacesAndFolders", "folders & workspaces") : localize("folders", "folders") };
    const fileSeparator = { type: "separator", label: localize("files", "files") };
    const picks = [workspaceSeparator, ...workspacePicks, fileSeparator, ...filePicks];
    const pick = await quickInputService.pick(picks, {
      contextKey: inRecentFilesPickerContextKey,
      activeItem: [...workspacePicks, ...filePicks][autoFocusSecondEntry ? 1 : 0],
      placeHolder: isMacintosh ? localize(
        "openRecentPlaceholderMac",
        "Select to open (hold Cmd-key to force new window or Option-key for same window)"
      ) : localize(
        "openRecentPlaceholder",
        "Select to open (hold Ctrl-key to force new window or Alt-key for same window)"
      ),
      matchOnDescription: true,
      onKeyMods: (mods) => keyMods = mods,
      quickNavigate: this.isQuickNavigate() ? { keybindings: keybindingService.lookupKeybindings(this.desc.id) } : void 0,
      hideInput: this.isQuickNavigate(),
      onDidTriggerItemButton: async (context) => {
        if (context.button === this.removeFromRecentlyOpened) {
          await workspacesService.removeRecentlyOpened([context.item.resource]);
          context.removeItem();
        } else if (context.button === this.dirtyRecentlyOpenedFolder || context.button === this.dirtyRecentlyOpenedWorkspace) {
          const isDirtyWorkspace = context.button === this.dirtyRecentlyOpenedWorkspace;
          const { confirmed } = await dialogService.confirm({
            title: isDirtyWorkspace ? localize("dirtyWorkspace", "Workspace with Unsaved Files") : localize("dirtyFolder", "Folder with Unsaved Files"),
            message: isDirtyWorkspace ? localize(
              "dirtyWorkspaceConfirm",
              "Do you want to open the workspace to review the unsaved files?"
            ) : localize(
              "dirtyFolderConfirm",
              "Do you want to open the folder to review the unsaved files?"
            ),
            detail: isDirtyWorkspace ? localize(
              "dirtyWorkspaceConfirmDetail",
              "Workspaces with unsaved files cannot be removed until all unsaved files have been saved or reverted."
            ) : localize(
              "dirtyFolderConfirmDetail",
              "Folders with unsaved files cannot be removed until all unsaved files have been saved or reverted."
            )
          });
          if (confirmed) {
            hostService.openWindow([context.item.openable], {
              remoteAuthority: context.item.remoteAuthority || null
            });
            quickInputService.cancel();
          }
        }
      }
    });
    if (pick) {
      return hostService.openWindow([pick.openable], {
        forceNewWindow: keyMods == null ? void 0 : keyMods.ctrlCmd,
        forceReuseWindow: keyMods == null ? void 0 : keyMods.alt,
        remoteAuthority: pick.remoteAuthority || null
      });
    }
  }
  toQuickPick(modelService, languageService, labelService, recent, isDirty) {
    let openable;
    let iconClasses;
    let fullLabel;
    let resource;
    let isWorkspace2 = false;
    if (isRecentFolder(recent)) {
      resource = recent.folderUri;
      iconClasses = getIconClasses(modelService, languageService, resource, FileKind.FOLDER);
      openable = { folderUri: resource };
      fullLabel = recent.label || labelService.getWorkspaceLabel(resource, { verbose: 2 });
    } else if (isRecentWorkspace(recent)) {
      resource = recent.workspace.configPath;
      iconClasses = getIconClasses(modelService, languageService, resource, FileKind.ROOT_FOLDER);
      openable = { workspaceUri: resource };
      fullLabel = recent.label || labelService.getWorkspaceLabel(recent.workspace, { verbose: 2 });
      isWorkspace2 = true;
    } else {
      resource = recent.fileUri;
      iconClasses = getIconClasses(modelService, languageService, resource, FileKind.FILE);
      openable = { fileUri: resource };
      fullLabel = recent.label || labelService.getUriLabel(resource);
    }
    const { name, parentPath } = splitRecentLabel(fullLabel);
    return {
      iconClasses,
      label: name,
      ariaLabel: isDirty ? isWorkspace2 ? localize(
        "recentDirtyWorkspaceAriaLabel",
        "{0}, workspace with unsaved changes",
        name
      ) : localize("recentDirtyFolderAriaLabel", "{0}, folder with unsaved changes", name) : name,
      description: parentPath,
      buttons: isDirty ? [isWorkspace2 ? this.dirtyRecentlyOpenedWorkspace : this.dirtyRecentlyOpenedFolder] : [this.removeFromRecentlyOpened],
      openable,
      resource,
      remoteAuthority: recent.remoteAuthority
    };
  }
}
const _OpenRecentAction = class _OpenRecentAction extends BaseOpenRecentAction {
  constructor() {
    super({
      id: _OpenRecentAction.ID,
      title: {
        value: localize("openRecent", "Open Recent..."),
        mnemonicTitle: localize({ key: "miMore", comment: ["&& denotes a mnemonic"] }, "&&More..."),
        original: "Open Recent..."
      },
      category: Categories.File,
      f1: true,
      keybinding: {
        weight: 200,
        primary: 2048 | 48,
        mac: { primary: 256 | 48 }
      },
      menu: {
        id: MenuId.MenubarRecentMenu,
        group: "y_more",
        order: 1
      }
    });
  }
  isQuickNavigate() {
    return false;
  }
};
_OpenRecentAction.ID = "workbench.action.openRecent";
let OpenRecentAction = _OpenRecentAction;
const _ReloadWindowAction = class _ReloadWindowAction extends Action2 {
  constructor() {
    super({
      id: _ReloadWindowAction.ID,
      title: { value: localize("reloadWindow", "Reload Window"), original: "Reload Window" },
      category: Categories.Developer,
      f1: true,
      keybinding: {
        weight: 200 + 50,
        when: IsDevelopmentContext,
        primary: 2048 | 48
      }
    });
  }
  run(accessor) {
    const hostService = accessor.get(IHostService);
    return hostService.reload();
  }
};
_ReloadWindowAction.ID = "workbench.action.reloadWindow";
let ReloadWindowAction = _ReloadWindowAction;
const recentFilesPickerContext = ContextKeyExpr.and(inQuickPickContext, ContextKeyExpr.has(inRecentFilesPickerContextKey));
const quickPickNavigateNextInRecentFilesPickerId = "workbench.action.quickOpenNavigateNextInRecentFilesPicker";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: quickPickNavigateNextInRecentFilesPickerId,
  weight: 200 + 50,
  handler: getQuickNavigateHandler(quickPickNavigateNextInRecentFilesPickerId, true),
  when: recentFilesPickerContext,
  primary: 2048 | 48,
  mac: { primary: 256 | 48 }
});
const quickPickNavigatePreviousInRecentFilesPicker = "workbench.action.quickOpenNavigatePreviousInRecentFilesPicker";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: quickPickNavigatePreviousInRecentFilesPicker,
  weight: 200 + 50,
  handler: getQuickNavigateHandler(quickPickNavigatePreviousInRecentFilesPicker, false),
  when: recentFilesPickerContext,
  primary: 2048 | 1024 | 48,
  mac: { primary: 256 | 1024 | 48 }
});
CommandsRegistry.registerCommand("workbench.action.toggleConfirmBeforeClose", (accessor) => {
  const configurationService = accessor.get(IConfigurationService);
  const setting = configurationService.inspect("window.confirmBeforeClose").userValue;
  return configurationService.updateValue("window.confirmBeforeClose", setting === "never" ? "keyboardOnly" : "never");
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarFileMenu,
  title: {
    value: "File",
    original: "File",
    mnemonicTitle: localize({ key: "mFile", comment: ["&& denotes a mnemonic"] }, "&&File")
  },
  order: 1
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarEditMenu,
  title: {
    value: "Edit",
    original: "Edit",
    mnemonicTitle: localize({ key: "mEdit", comment: ["&& denotes a mnemonic"] }, "&&Edit")
  },
  order: 2
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarSelectionMenu,
  title: {
    value: "Selection",
    original: "Selection",
    mnemonicTitle: localize({ key: "mSelection", comment: ["&& denotes a mnemonic"] }, "&&Selection")
  },
  order: 3
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarViewMenu,
  title: {
    value: "View",
    original: "View",
    mnemonicTitle: localize({ key: "mView", comment: ["&& denotes a mnemonic"] }, "&&View")
  },
  order: 4
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarGoMenu,
  title: {
    value: "Go",
    original: "Go",
    mnemonicTitle: localize({ key: "mGoto", comment: ["&& denotes a mnemonic"] }, "&&Go")
  },
  order: 5
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarTerminalMenu,
  title: {
    value: "Terminal",
    original: "Terminal",
    mnemonicTitle: localize({ key: "mTerminal", comment: ["&& denotes a mnemonic"] }, "&&Terminal")
  },
  order: 7
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarHelpMenu,
  title: {
    value: "Help",
    original: "Help",
    mnemonicTitle: localize({ key: "mHelp", comment: ["&& denotes a mnemonic"] }, "&&Help")
  },
  order: 8
});
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
  submenu: MenuId.MenubarPreferencesMenu,
  title: {
    value: "Preferences",
    original: "Preferences",
    mnemonicTitle: localize({ key: "mPreferences", comment: ["&& denotes a mnemonic"] }, "Preferences")
  },
  when: IsMacNativeContext,
  order: 9
});
const _MenubarControl = class _MenubarControl extends Disposable {
  constructor(menuService, workspacesService, contextKeyService, keybindingService, configurationService, labelService, updateService, storageService, notificationService, preferencesService, environmentService, accessibilityService, hostService, commandService) {
    super();
    this.menuService = menuService;
    this.workspacesService = workspacesService;
    this.contextKeyService = contextKeyService;
    this.keybindingService = keybindingService;
    this.configurationService = configurationService;
    this.labelService = labelService;
    this.updateService = updateService;
    this.storageService = storageService;
    this.notificationService = notificationService;
    this.preferencesService = preferencesService;
    this.environmentService = environmentService;
    this.accessibilityService = accessibilityService;
    this.hostService = hostService;
    this.commandService = commandService;
    this.keys = [
      "window.menuBarVisibility",
      "window.enableMenuBarMnemonics",
      "window.customMenuBarAltFocus",
      "workbench.sideBar.location",
      "window.nativeTabs"
    ];
    this.menus = {};
    this.topLevelTitles = {};
    this.recentlyOpened = { files: [], workspaces: [] };
    this.mainMenu = this._register(this.menuService.createMenu(MenuId.MenubarMainMenu, this.contextKeyService));
    this.mainMenuDisposables = this._register(new DisposableStore());
    this.setupMainMenu();
    this.menuUpdater = this._register(new RunOnceScheduler(() => this.doUpdateMenubar(false), 200));
    this.notifyUserOfCustomMenubarAccessibility();
  }
  registerListeners() {
    this._register(this.hostService.onDidChangeFocus((e) => this.onDidChangeWindowFocus(e)));
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e)));
    this.updateService.onStateChange(() => this.onUpdateStateChange());
    this._register(this.workspacesService.onDidChangeRecentlyOpened(() => {
      this.onDidChangeRecentlyOpened();
    }));
    this._register(this.keybindingService.onDidUpdateKeybindings(() => this.updateMenubar()));
    this._register(this.labelService.onDidChangeFormatters(() => {
      this.onDidChangeRecentlyOpened();
    }));
    this._register(this.mainMenu.onDidChange(() => {
      this.setupMainMenu();
      this.doUpdateMenubar(true);
    }));
  }
  setupMainMenu() {
    this.mainMenuDisposables.clear();
    this.menus = {};
    this.topLevelTitles = {};
    const [, mainMenuActions] = this.mainMenu.getActions()[0];
    for (const mainMenuAction of mainMenuActions) {
      if (mainMenuAction instanceof SubmenuItemAction && typeof mainMenuAction.item.title !== "string") {
        this.menus[mainMenuAction.item.title.original] = this.mainMenuDisposables.add(this.menuService.createMenu(mainMenuAction.item.submenu, this.contextKeyService, { emitEventsForSubmenuChanges: true }));
        this.topLevelTitles[mainMenuAction.item.title.original] = mainMenuAction.item.title.mnemonicTitle ?? mainMenuAction.item.title.value;
      }
    }
  }
  updateMenubar() {
    this.menuUpdater.schedule();
  }
  calculateActionLabel(action) {
    const label = action.label;
    return label;
  }
  onUpdateStateChange() {
    this.updateMenubar();
  }
  onUpdateKeybindings() {
    this.updateMenubar();
  }
  getOpenRecentActions() {
    if (!this.recentlyOpened) {
      return [];
    }
    const { workspaces, files } = this.recentlyOpened;
    const result = [];
    if (workspaces.length > 0) {
      for (let i = 0; i < _MenubarControl.MAX_MENU_RECENT_ENTRIES && i < workspaces.length; i++) {
        result.push(this.createOpenRecentMenuAction(workspaces[i]));
      }
      result.push(new Separator());
    }
    if (files.length > 0) {
      for (let i = 0; i < _MenubarControl.MAX_MENU_RECENT_ENTRIES && i < files.length; i++) {
        result.push(this.createOpenRecentMenuAction(files[i]));
      }
      result.push(new Separator());
    }
    return result;
  }
  onDidChangeWindowFocus(hasFocus) {
    if (hasFocus) {
      this.onDidChangeRecentlyOpened();
    }
  }
  onConfigurationUpdated(event) {
    if (this.keys.some((key) => event.affectsConfiguration(key))) {
      this.updateMenubar();
    }
    if (event.affectsConfiguration("editor.accessibilitySupport")) {
      this.notifyUserOfCustomMenubarAccessibility();
    }
    if (event.affectsConfiguration("window.menuBarVisibility")) {
      this.onDidChangeRecentlyOpened();
    }
  }
  get menubarHidden() {
    return isMacintosh && isNative ? false : getMenuBarVisibility(this.configurationService) === "hidden";
  }
  onDidChangeRecentlyOpened() {
    if (!this.menubarHidden) {
      this.workspacesService.getRecentlyOpened().then((recentlyOpened) => {
        this.recentlyOpened = recentlyOpened;
        this.updateMenubar();
      });
    }
  }
  createOpenRecentMenuAction(recent) {
    let label;
    let uri;
    let commandId;
    let openable;
    const remoteAuthority = recent.remoteAuthority;
    if (isRecentFolder(recent)) {
      uri = recent.folderUri;
      label = recent.label || this.labelService.getWorkspaceLabel(uri, { verbose: 2 });
      commandId = "openRecentFolder";
      openable = { folderUri: uri };
    } else if (isRecentWorkspace(recent)) {
      uri = recent.workspace.configPath;
      label = recent.label || this.labelService.getWorkspaceLabel(recent.workspace, { verbose: 2 });
      commandId = "openRecentWorkspace";
      openable = { workspaceUri: uri };
    } else {
      uri = recent.fileUri;
      label = recent.label || this.labelService.getUriLabel(uri);
      commandId = "openRecentFile";
      openable = { fileUri: uri };
    }
    const ret = new Action(commandId, unmnemonicLabel(label), void 0, void 0, (event) => {
      const browserEvent = event;
      const openInNewWindow = event && (!isMacintosh && (browserEvent.ctrlKey || browserEvent.shiftKey) || isMacintosh && (browserEvent.metaKey || browserEvent.altKey));
      return this.hostService.openWindow([openable], {
        forceNewWindow: !!openInNewWindow,
        remoteAuthority: remoteAuthority || null
      });
    });
    return Object.assign(ret, { uri, remoteAuthority });
  }
  notifyUserOfCustomMenubarAccessibility() {
    if (isWeb || isMacintosh) {
      return;
    }
    const hasBeenNotified = this.storageService.getBoolean("menubar/accessibleMenubarNotified", -1, false);
    const usingCustomMenubar = getTitleBarStyle(this.configurationService) === "custom";
    if (hasBeenNotified || usingCustomMenubar || !this.accessibilityService.isScreenReaderOptimized()) {
      return;
    }
    const message = localize(
      "menubar.customTitlebarAccessibilityNotification",
      "Accessibility support is enabled for you. For the most accessible experience, we recommend the custom title bar style."
    );
    this.notificationService.prompt(Severity.Info, message, [
      {
        label: localize("goToSetting", "Open Settings"),
        run: () => {
          return this.preferencesService.openUserSettings({ query: "window.titleBarStyle" });
        }
      }
    ]);
    this.storageService.store("menubar/accessibleMenubarNotified", true, -1, 0);
  }
};
_MenubarControl.MAX_MENU_RECENT_ENTRIES = 10;
let MenubarControl = _MenubarControl;
let CustomMenubarControl = class CustomMenubarControl2 extends MenubarControl {
  constructor(menuService, workspacesService, contextKeyService, keybindingService, configurationService, labelService, updateService, storageService, notificationService, preferencesService, environmentService, accessibilityService, layoutService, telemetryService, hostService, commandService) {
    super(menuService, workspacesService, contextKeyService, keybindingService, configurationService, labelService, updateService, storageService, notificationService, preferencesService, environmentService, accessibilityService, hostService, commandService);
    this.layoutService = layoutService;
    this.telemetryService = telemetryService;
    this.alwaysOnMnemonics = false;
    this.focusInsideMenubar = false;
    this.pendingFirstTimeUpdate = false;
    this.visible = true;
    this.webNavigationMenu = this._register(this.menuService.createMenu(MenuId.MenubarHomeMenu, this.contextKeyService));
    this.reinstallDisposables = this._register(new DisposableStore());
    this._onVisibilityChange = this._register(new Emitter());
    this._onFocusStateChange = this._register(new Emitter());
    this.actionRunner = this._register(new ActionRunner());
    this.actionRunner.onDidRun((e) => {
      this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "menu" });
    });
    this.workspacesService.getRecentlyOpened().then((recentlyOpened) => {
      this.recentlyOpened = recentlyOpened;
    });
    this.registerListeners();
    this.registerActions();
  }
  doUpdateMenubar(firstTime) {
    if (!this.focusInsideMenubar) {
      this.setupCustomMenubar(firstTime);
    }
    if (firstTime) {
      this.pendingFirstTimeUpdate = true;
    }
  }
  registerActions() {
    const that = this;
    if (isWeb) {
      this._register(registerAction2(class extends Action2 {
        constructor() {
          super({
            id: `workbench.actions.menubar.focus`,
            title: { value: localize("focusMenu", "Focus Application Menu"), original: "Focus Application Menu" },
            keybinding: {
              primary: 68,
              weight: 200,
              when: IsWebContext
            },
            f1: true
          });
        }
        async run() {
          var _a2;
          (_a2 = that.menubar) == null ? void 0 : _a2.toggleFocus();
        }
      }));
    }
  }
  getUpdateAction() {
    const state = this.updateService.state;
    switch (state.type) {
      case "idle":
        return new Action("update.check", localize(
          { key: "checkForUpdates", comment: ["&& denotes a mnemonic"] },
          "Check for &&Updates..."
        ), void 0, true, () => this.updateService.checkForUpdates(true));
      case "checking for updates":
        return new Action("update.checking", localize("checkingForUpdates", "Checking for Updates..."), void 0, false);
      case "available for download":
        return new Action("update.downloadNow", localize(
          { key: "download now", comment: ["&& denotes a mnemonic"] },
          "D&&ownload Update"
        ), void 0, true, () => this.updateService.downloadUpdate());
      case "downloading":
        return new Action("update.downloading", localize("DownloadingUpdate", "Downloading Update..."), void 0, false);
      case "downloaded":
        return new Action("update.install", localize(
          { key: "installUpdate...", comment: ["&& denotes a mnemonic"] },
          "Install &&Update..."
        ), void 0, true, () => this.updateService.applyUpdate());
      case "updating":
        return new Action("update.updating", localize("installingUpdate", "Installing Update..."), void 0, false);
      case "ready":
        return new Action("update.restart", localize(
          { key: "restartToUpdate", comment: ["&& denotes a mnemonic"] },
          "Restart to &&Update"
        ), void 0, true, () => this.updateService.quitAndInstall());
      default:
        return null;
    }
  }
  get currentMenubarVisibility() {
    return getMenuBarVisibility(this.configurationService);
  }
  get currentDisableMenuBarAltFocus() {
    const settingValue = this.configurationService.getValue("window.customMenuBarAltFocus");
    let disableMenuBarAltBehavior = false;
    if (typeof settingValue === "boolean") {
      disableMenuBarAltBehavior = !settingValue;
    }
    return disableMenuBarAltBehavior;
  }
  insertActionsBefore(nextAction, target) {
    switch (nextAction.id) {
      case OpenRecentAction.ID:
        target.push(...this.getOpenRecentActions());
        break;
      case "workbench.action.showAboutDialog":
        if (!isMacintosh && !isWeb) {
          const updateAction = this.getUpdateAction();
          if (updateAction) {
            updateAction.label = mnemonicMenuLabel(updateAction.label);
            target.push(updateAction);
            target.push(new Separator());
          }
        }
        break;
    }
  }
  get currentEnableMenuBarMnemonics() {
    let enableMenuBarMnemonics = this.configurationService.getValue("window.enableMenuBarMnemonics");
    if (typeof enableMenuBarMnemonics !== "boolean") {
      enableMenuBarMnemonics = true;
    }
    return enableMenuBarMnemonics && (!isWeb || isFullscreen());
  }
  get currentCompactMenuMode() {
    if (this.currentMenubarVisibility !== "compact") {
      return void 0;
    }
    const currentSidebarLocation = this.configurationService.getValue("workbench.sideBar.location");
    return currentSidebarLocation === "right" ? Direction.Left : Direction.Right;
  }
  onDidVisibilityChange(visible) {
    this.visible = visible;
    this.onDidChangeRecentlyOpened();
    this._onVisibilityChange.fire(visible);
  }
  toActionsArray(menu) {
    const result = [];
    createAndFillInContextMenuActions(menu, { shouldForwardArgs: true }, result);
    return result;
  }
  setupCustomMenubar(firstTime) {
    var _a2;
    if (!this.container) {
      return;
    }
    if (firstTime) {
      if (this.menubar) {
        this.reinstallDisposables.clear();
      }
      this.menubar = this.reinstallDisposables.add(new MenuBar(this.container, this.getMenuBarOptions(), defaultMenuStyles));
      this.accessibilityService.alwaysUnderlineAccessKeys().then((val) => {
        var _a3;
        this.alwaysOnMnemonics = val;
        (_a3 = this.menubar) == null ? void 0 : _a3.update(this.getMenuBarOptions());
      });
      this.reinstallDisposables.add(this.menubar.onFocusStateChange((focused) => {
        this._onFocusStateChange.fire(focused);
        if (!focused) {
          if (this.pendingFirstTimeUpdate) {
            this.setupCustomMenubar(true);
            this.pendingFirstTimeUpdate = false;
          } else {
            this.updateMenubar();
          }
          this.focusInsideMenubar = false;
        }
      }));
      this.reinstallDisposables.add(this.menubar.onVisibilityChange((e) => this.onDidVisibilityChange(e)));
      this.reinstallDisposables.add(addDisposableListener(this.container, EventType.FOCUS_IN, () => {
        this.focusInsideMenubar = true;
      }));
      this.reinstallDisposables.add(addDisposableListener(this.container, EventType.FOCUS_OUT, () => {
        this.focusInsideMenubar = false;
      }));
      if (this.menubar.isVisible) {
        this.onDidVisibilityChange(true);
      }
    } else {
      (_a2 = this.menubar) == null ? void 0 : _a2.update(this.getMenuBarOptions());
    }
    const updateActions = (menuActions, target, topLevelTitle) => {
      target.splice(0);
      for (const menuItem of menuActions) {
        this.insertActionsBefore(menuItem, target);
        if (menuItem instanceof Separator) {
          target.push(menuItem);
        } else if (menuItem instanceof SubmenuItemAction || menuItem instanceof MenuItemAction) {
          let title = typeof menuItem.item.title === "string" ? menuItem.item.title : menuItem.item.title.mnemonicTitle ?? menuItem.item.title.value;
          if (menuItem instanceof SubmenuItemAction) {
            const submenuActions = [];
            updateActions(menuItem.actions, submenuActions, topLevelTitle);
            if (submenuActions.length > 0) {
              target.push(new SubmenuAction(menuItem.id, mnemonicMenuLabel(title), submenuActions));
            }
          } else {
            if (isICommandActionToggleInfo(menuItem.item.toggled)) {
              title = menuItem.item.toggled.mnemonicTitle ?? menuItem.item.toggled.title ?? title;
            }
            const newAction = new Action(
              menuItem.id,
              mnemonicMenuLabel(title),
              menuItem.class,
              menuItem.enabled,
              () => this.commandService.executeCommand(menuItem.id)
            );
            newAction.tooltip = menuItem.tooltip;
            newAction.checked = menuItem.checked;
            target.push(newAction);
          }
        }
      }
      if (topLevelTitle === "File" && this.currentCompactMenuMode === void 0) {
        const webActions = this.getWebNavigationActions();
        if (webActions.length) {
          target.push(...webActions);
        }
      }
    };
    for (const title of Object.keys(this.topLevelTitles)) {
      const menu = this.menus[title];
      if (firstTime && menu) {
        this.reinstallDisposables.add(menu.onDidChange(() => {
          var _a3;
          if (!this.focusInsideMenubar) {
            const actions2 = [];
            updateActions(this.toActionsArray(menu), actions2, title);
            (_a3 = this.menubar) == null ? void 0 : _a3.updateMenu({ actions: actions2, label: mnemonicMenuLabel(this.topLevelTitles[title]) });
          }
        }));
        if (menu === this.menus.File) {
          this.reinstallDisposables.add(this.webNavigationMenu.onDidChange(() => {
            var _a3;
            if (!this.focusInsideMenubar) {
              const actions2 = [];
              updateActions(this.toActionsArray(menu), actions2, title);
              (_a3 = this.menubar) == null ? void 0 : _a3.updateMenu({ actions: actions2, label: mnemonicMenuLabel(this.topLevelTitles[title]) });
            }
          }));
        }
      }
      const actions = [];
      if (menu) {
        updateActions(this.toActionsArray(menu), actions, title);
      }
      if (this.menubar) {
        if (!firstTime) {
          this.menubar.updateMenu({ actions, label: mnemonicMenuLabel(this.topLevelTitles[title]) });
        } else {
          this.menubar.push({ actions, label: mnemonicMenuLabel(this.topLevelTitles[title]) });
        }
      }
    }
  }
  getWebNavigationActions() {
    if (!isWeb) {
      return [];
    }
    const webNavigationActions = [];
    for (const groups of this.webNavigationMenu.getActions()) {
      const [, actions] = groups;
      for (const action of actions) {
        if (action instanceof MenuItemAction) {
          const title = typeof action.item.title === "string" ? action.item.title : action.item.title.mnemonicTitle ?? action.item.title.value;
          webNavigationActions.push(new Action(
            action.id,
            mnemonicMenuLabel(title),
            action.class,
            action.enabled,
            async (event) => {
              this.commandService.executeCommand(action.id, event);
            }
          ));
        }
      }
      webNavigationActions.push(new Separator());
    }
    if (webNavigationActions.length) {
      webNavigationActions.pop();
    }
    return webNavigationActions;
  }
  getMenuBarOptions() {
    return {
      enableMnemonics: this.currentEnableMenuBarMnemonics,
      disableAltFocus: this.currentDisableMenuBarAltFocus,
      visibility: this.currentMenubarVisibility,
      actionRunner: this.actionRunner,
      getKeybinding: (action) => this.keybindingService.lookupKeybinding(action.id),
      alwaysOnMnemonics: this.alwaysOnMnemonics,
      compactMode: this.currentCompactMenuMode,
      getCompactMenuActions: () => {
        if (!isWeb) {
          return [];
        }
        return this.getWebNavigationActions();
      }
    };
  }
  onDidChangeWindowFocus(hasFocus) {
    var _a2;
    if (!this.visible) {
      return;
    }
    super.onDidChangeWindowFocus(hasFocus);
    if (this.container) {
      if (hasFocus) {
        this.container.classList.remove("inactive");
      } else {
        this.container.classList.add("inactive");
        (_a2 = this.menubar) == null ? void 0 : _a2.blur();
      }
    }
  }
  onUpdateStateChange() {
    if (!this.visible) {
      return;
    }
    super.onUpdateStateChange();
  }
  onDidChangeRecentlyOpened() {
    if (!this.visible) {
      return;
    }
    super.onDidChangeRecentlyOpened();
  }
  onUpdateKeybindings() {
    if (!this.visible) {
      return;
    }
    super.onUpdateKeybindings();
  }
  registerListeners() {
    super.registerListeners();
    this._register(addDisposableListener(window, EventType.RESIZE, () => {
      if (this.menubar && !(isIOS && BrowserFeatures.pointerEvents)) {
        this.menubar.blur();
      }
    }));
    if (isWeb) {
      this._register(this.layoutService.onDidChangeFullscreen((e) => this.updateMenubar()));
      this._register(this.webNavigationMenu.onDidChange(() => this.updateMenubar()));
    }
  }
  get onVisibilityChange() {
    return this._onVisibilityChange.event;
  }
  get onFocusStateChange() {
    return this._onFocusStateChange.event;
  }
  getMenubarItemsDimensions() {
    if (this.menubar) {
      return new Dimension(this.menubar.getWidth(), this.menubar.getHeight());
    }
    return new Dimension(0, 0);
  }
  create(parent) {
    this.container = parent;
    if (this.container) {
      this.doUpdateMenubar(true);
    }
    return this.container;
  }
  layout(dimension) {
    var _a2;
    (_a2 = this.menubar) == null ? void 0 : _a2.update(this.getMenuBarOptions());
  }
  toggleFocus() {
    var _a2;
    (_a2 = this.menubar) == null ? void 0 : _a2.toggleFocus();
  }
};
CustomMenubarControl = __decorate([
  __param(0, IMenuService),
  __param(1, IWorkspacesService),
  __param(2, IContextKeyService),
  __param(3, IKeybindingService),
  __param(4, IConfigurationService),
  __param(5, ILabelService),
  __param(6, IUpdateService),
  __param(7, IStorageService),
  __param(8, INotificationService),
  __param(9, IPreferencesService),
  __param(10, IWorkbenchEnvironmentService),
  __param(11, IAccessibilityService),
  __param(12, IWorkbenchLayoutService),
  __param(13, ITelemetryService),
  __param(14, IHostService),
  __param(15, ICommandService)
], CustomMenubarControl);
let ActivitybarPart = (_e = class extends Part {
  constructor(paneCompositePart, instantiationService, layoutService, themeService, storageService, extensionService, viewDescriptorService, contextKeyService, configurationService, environmentService) {
    super("workbench.parts.activitybar", { hasTitle: false }, themeService, storageService, layoutService);
    this.paneCompositePart = paneCompositePart;
    this.instantiationService = instantiationService;
    this.storageService = storageService;
    this.extensionService = extensionService;
    this.viewDescriptorService = viewDescriptorService;
    this.contextKeyService = contextKeyService;
    this.configurationService = configurationService;
    this.environmentService = environmentService;
    this.minimumWidth = 48;
    this.maximumWidth = 48;
    this.minimumHeight = 0;
    this.maximumHeight = Number.POSITIVE_INFINITY;
    this.globalActivity = [];
    this.accountsActivity = [];
    this.compositeActions = /* @__PURE__ */ new Map();
    this.viewContainerDisposables = /* @__PURE__ */ new Map();
    this.keyboardNavigationDisposables = this._register(new DisposableStore());
    this.location = 0;
    this.hasExtensionsRegistered = false;
    this.enabledViewContainersContextKeys = /* @__PURE__ */ new Map();
    this._cachedViewContainers = void 0;
    for (const cachedViewContainer of this.cachedViewContainers) {
      cachedViewContainer.visible = !this.shouldBeHidden(cachedViewContainer.id, cachedViewContainer);
    }
    this.compositeBar = this.createCompositeBar();
    this.onDidRegisterViewContainers(this.getViewContainers());
    this.registerListeners();
  }
  createCompositeBar() {
    const cachedItems = this.cachedViewContainers.map((container) => ({
      id: container.id,
      name: container.name,
      visible: container.visible,
      order: container.order,
      pinned: container.pinned
    }));
    return this._register(this.instantiationService.createInstance(CompositeBar, cachedItems, {
      icon: true,
      orientation: 1,
      activityHoverOptions: this.getActivityHoverOptions(),
      preventLoopNavigation: true,
      openComposite: async (compositeId, preserveFocus) => {
        return await this.paneCompositePart.openPaneComposite(compositeId, !preserveFocus) ?? null;
      },
      getActivityAction: (compositeId) => this.getCompositeActions(compositeId).activityAction,
      getCompositePinnedAction: (compositeId) => this.getCompositeActions(compositeId).pinnedAction,
      getCompositeBadgeAction: (compositeId) => this.getCompositeActions(compositeId).badgeAction,
      getOnCompositeClickAction: (compositeId) => toAction({ id: compositeId, label: "", run: async () => {
        var _a2;
        return ((_a2 = this.paneCompositePart.getActivePaneComposite()) == null ? void 0 : _a2.getId()) === compositeId ? this.paneCompositePart.hideActivePaneComposite() : this.paneCompositePart.openPaneComposite(compositeId);
      } }),
      fillExtraContextMenuActions: (actions, e) => {
        const menuBarVisibility = getMenuBarVisibility(this.configurationService);
        if (menuBarVisibility === "compact" || menuBarVisibility === "hidden" || menuBarVisibility === "toggle") {
          actions.unshift(...[toAction({ id: "toggleMenuVisibility", label: localize("menu", "Menu"), checked: menuBarVisibility === "compact", run: () => this.configurationService.updateValue("window.menuBarVisibility", menuBarVisibility === "compact" ? "toggle" : "compact") }), new Separator()]);
        }
        if (menuBarVisibility === "compact" && this.menuBarContainer && (e == null ? void 0 : e.target)) {
          if (isAncestor(e.target, this.menuBarContainer)) {
            actions.unshift(...[toAction({ id: "hideCompactMenu", label: localize("hideMenu", "Hide Menu"), run: () => this.configurationService.updateValue("window.menuBarVisibility", "toggle") }), new Separator()]);
          }
        }
        actions.push(new Separator());
        actions.push(toAction({ id: "toggleAccountsVisibility", label: localize("accounts", "Accounts"), checked: this.accountsVisibilityPreference, run: () => this.accountsVisibilityPreference = !this.accountsVisibilityPreference }));
        actions.push(new Separator());
        actions.push(toAction({ id: ToggleSidebarPositionAction.ID, label: ToggleSidebarPositionAction.getLabel(this.layoutService), run: () => this.instantiationService.invokeFunction((accessor) => new ToggleSidebarPositionAction().run(accessor)) }));
        actions.push(toAction({ id: ToggleActivityBarVisibilityAction.ID, label: localize("hideActivitBar", "Hide Activity Bar"), run: () => this.instantiationService.invokeFunction((accessor) => new ToggleActivityBarVisibilityAction().run(accessor)) }));
      },
      getContextMenuActionsForComposite: (compositeId) => this.getContextMenuActionsForComposite(compositeId),
      getDefaultCompositeId: () => {
        var _a2;
        return (_a2 = this.viewDescriptorService.getDefaultViewContainer(this.location)) == null ? void 0 : _a2.id;
      },
      hidePart: () => this.layoutService.setPartHidden(true, "workbench.parts.sidebar"),
      dndHandler: new CompositeDragAndDrop(
        this.viewDescriptorService,
        0,
        async (id, focus) => {
          return await this.paneCompositePart.openPaneComposite(id, focus) ?? null;
        },
        (from, to, before) => this.compositeBar.move(from, to, before == null ? void 0 : before.verticallyBefore),
        () => this.compositeBar.getCompositeBarItems()
      ),
      compositeSize: 52,
      colors: (theme) => this.getActivitybarItemColors(theme),
      overflowActionSize: _e.ACTION_HEIGHT
    }));
  }
  getActivityHoverOptions() {
    return {
      position: () => this.layoutService.getSideBarPosition() === 0 ? 1 : 0
    };
  }
  getContextMenuActionsForComposite(compositeId) {
    const actions = [];
    const viewContainer = this.viewDescriptorService.getViewContainerById(compositeId);
    const defaultLocation = this.viewDescriptorService.getDefaultViewContainerLocation(viewContainer);
    if (defaultLocation !== this.viewDescriptorService.getViewContainerLocation(viewContainer)) {
      actions.push(toAction({ id: "resetLocationAction", label: localize("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewContainerToLocation(viewContainer, defaultLocation) }));
    } else {
      const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
      if (viewContainerModel.allViewDescriptors.length === 1) {
        const viewToReset = viewContainerModel.allViewDescriptors[0];
        const defaultContainer = this.viewDescriptorService.getDefaultContainerById(viewToReset.id);
        if (defaultContainer !== viewContainer) {
          actions.push(toAction({ id: "resetLocationAction", label: localize("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewsToContainer([viewToReset], defaultContainer) }));
        }
      }
    }
    return actions;
  }
  registerListeners() {
    this._register(this.viewDescriptorService.onDidChangeViewContainers(({ added, removed }) => this.onDidChangeViewContainers(added, removed)));
    this._register(this.viewDescriptorService.onDidChangeContainerLocation(({ viewContainer, from, to }) => this.onDidChangeViewContainerLocation(viewContainer, from, to)));
    this.paneCompositePart.onDidPaneCompositeOpen((e) => this.onDidChangeViewContainerVisibility(e.getId(), true));
    this.paneCompositePart.onDidPaneCompositeClose((e) => this.onDidChangeViewContainerVisibility(e.getId(), false));
    const disposables = this._register(new DisposableStore());
    this._register(this.extensionService.onDidRegisterExtensions(() => {
      disposables.clear();
      this.onDidRegisterExtensions();
      this.compositeBar.onDidChange(() => this.saveCachedViewContainers(), this, disposables);
      this.storageService.onDidChangeValue((e) => this.onDidStorageValueChange(e), this, disposables);
    }));
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("window.menuBarVisibility")) {
        if (getMenuBarVisibility(this.configurationService) === "compact") {
          this.installMenubar();
        } else {
          this.uninstallMenubar();
        }
      }
    }));
  }
  onDidChangeViewContainers(added, removed) {
    removed.filter(({ location }) => location === 0).forEach(({ container }) => this.onDidDeregisterViewContainer(container));
    this.onDidRegisterViewContainers(added.filter(({ location }) => location === 0).map(({ container }) => container));
  }
  onDidChangeViewContainerLocation(container, from, to) {
    if (from === this.location) {
      this.onDidDeregisterViewContainer(container);
    }
    if (to === this.location) {
      this.onDidRegisterViewContainers([container]);
    }
  }
  onDidChangeViewContainerVisibility(id, visible) {
    if (visible) {
      this.onDidViewContainerVisible(id);
    } else {
      this.compositeBar.deactivateComposite(id);
    }
  }
  onDidRegisterExtensions() {
    this.hasExtensionsRegistered = true;
    for (const { id } of this.cachedViewContainers) {
      const viewContainer = this.getViewContainer(id);
      if (viewContainer) {
        this.showOrHideViewContainer(viewContainer);
      } else {
        if (this.viewDescriptorService.isViewContainerRemovedPermanently(id)) {
          this.removeComposite(id);
        } else {
          this.hideComposite(id);
        }
      }
    }
    this.saveCachedViewContainers();
  }
  onDidViewContainerVisible(id) {
    const viewContainer = this.getViewContainer(id);
    if (viewContainer) {
      this.addComposite(viewContainer);
      this.compositeBar.activateComposite(viewContainer.id);
      if (this.shouldBeHidden(viewContainer)) {
        const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
        if (viewContainerModel.activeViewDescriptors.length === 0) {
          this.hideComposite(viewContainer.id);
        }
      }
    }
  }
  showActivity(viewContainerOrActionId, badge, clazz, priority) {
    if (this.getViewContainer(viewContainerOrActionId)) {
      return this.compositeBar.showActivity(viewContainerOrActionId, badge, clazz, priority);
    }
    if (viewContainerOrActionId === GLOBAL_ACTIVITY_ID) {
      return this.showGlobalActivity(GLOBAL_ACTIVITY_ID, badge, clazz, priority);
    }
    if (viewContainerOrActionId === ACCOUNTS_ACTIVITY_ID) {
      return this.showGlobalActivity(ACCOUNTS_ACTIVITY_ID, badge, clazz, priority);
    }
    return Disposable.None;
  }
  showGlobalActivity(activityId, badge, clazz, priority) {
    if (typeof priority !== "number") {
      priority = 0;
    }
    const activity = { badge, clazz, priority };
    const activityCache = activityId === GLOBAL_ACTIVITY_ID ? this.globalActivity : this.accountsActivity;
    for (let i = 0; i <= activityCache.length; i++) {
      if (i === activityCache.length) {
        activityCache.push(activity);
        break;
      } else if (activityCache[i].priority <= priority) {
        activityCache.splice(i, 0, activity);
        break;
      }
    }
    this.updateGlobalActivity(activityId);
    return toDisposable(() => this.removeGlobalActivity(activityId, activity));
  }
  removeGlobalActivity(activityId, activity) {
    const activityCache = activityId === GLOBAL_ACTIVITY_ID ? this.globalActivity : this.accountsActivity;
    const index = activityCache.indexOf(activity);
    if (index !== -1) {
      activityCache.splice(index, 1);
      this.updateGlobalActivity(activityId);
    }
  }
  updateGlobalActivity(activityId) {
    const activityAction = activityId === GLOBAL_ACTIVITY_ID ? this.globalActivityAction : this.accountsActivityAction;
    if (!activityAction) {
      return;
    }
    const activityCache = activityId === GLOBAL_ACTIVITY_ID ? this.globalActivity : this.accountsActivity;
    if (activityCache.length) {
      const [{ badge, clazz, priority }] = activityCache;
      if (badge instanceof NumberBadge && activityCache.length > 1) {
        const cumulativeNumberBadge = this.getCumulativeNumberBadge(activityCache, priority);
        activityAction.setBadge(cumulativeNumberBadge);
      } else {
        activityAction.setBadge(badge, clazz);
      }
    } else {
      activityAction.setBadge(void 0);
    }
  }
  getCumulativeNumberBadge(activityCache, priority) {
    const numberActivities = activityCache.filter((activity) => activity.badge instanceof NumberBadge && activity.priority === priority);
    const number = numberActivities.reduce((result, activity) => {
      return result + activity.badge.number;
    }, 0);
    const descriptorFn = () => {
      return numberActivities.reduce((result, activity, index) => {
        result = result + activity.badge.getDescription();
        if (index < numberActivities.length - 1) {
          result = `${result}
`;
        }
        return result;
      }, "");
    };
    return new NumberBadge(number, descriptorFn);
  }
  uninstallMenubar() {
    if (this.menuBar) {
      this.menuBar.dispose();
      this.menuBar = void 0;
    }
    if (this.menuBarContainer) {
      this.menuBarContainer.remove();
      this.menuBarContainer = void 0;
      this.registerKeyboardNavigationListeners();
    }
  }
  installMenubar() {
    if (this.menuBar) {
      return;
    }
    this.menuBarContainer = document.createElement("div");
    this.menuBarContainer.classList.add("menubar");
    const content = assertIsDefined(this.content);
    content.prepend(this.menuBarContainer);
    this.menuBar = this._register(this.instantiationService.createInstance(CustomMenubarControl));
    this.menuBar.create(this.menuBarContainer);
    this.registerKeyboardNavigationListeners();
  }
  createContentArea(parent) {
    this.element = parent;
    this.content = document.createElement("div");
    this.content.classList.add("content");
    parent.appendChild(this.content);
    if (getMenuBarVisibility(this.configurationService) === "compact") {
      this.installMenubar();
    }
    this.compositeBarContainer = this.compositeBar.create(this.content);
    this.globalActivitiesContainer = document.createElement("div");
    this.content.appendChild(this.globalActivitiesContainer);
    this.registerKeyboardNavigationListeners();
    return this.content;
  }
  registerKeyboardNavigationListeners() {
    this.keyboardNavigationDisposables.clear();
    if (this.menuBarContainer) {
      this.keyboardNavigationDisposables.add(addDisposableListener(this.menuBarContainer, EventType.KEY_DOWN, (e) => {
        var _a2;
        const kbEvent = new StandardKeyboardEvent(e);
        if (kbEvent.equals(18) || kbEvent.equals(17)) {
          (_a2 = this.compositeBar) == null ? void 0 : _a2.focus();
        }
      }));
    }
    if (this.compositeBarContainer) {
      this.keyboardNavigationDisposables.add(addDisposableListener(this.compositeBarContainer, EventType.KEY_DOWN, (e) => {
        var _a2, _b2;
        const kbEvent = new StandardKeyboardEvent(e);
        if (kbEvent.equals(18) || kbEvent.equals(17)) {
          (_a2 = this.globalActivityActionBar) == null ? void 0 : _a2.focus(true);
        } else if (kbEvent.equals(16) || kbEvent.equals(15)) {
          (_b2 = this.menuBar) == null ? void 0 : _b2.toggleFocus();
        }
      }));
    }
    if (this.globalActivitiesContainer) {
      this.keyboardNavigationDisposables.add(addDisposableListener(this.globalActivitiesContainer, EventType.KEY_DOWN, (e) => {
        var _a2;
        const kbEvent = new StandardKeyboardEvent(e);
        if (kbEvent.equals(16) || kbEvent.equals(15)) {
          (_a2 = this.compositeBar) == null ? void 0 : _a2.focus(this.getVisiblePaneCompositeIds().length - 1);
        }
      }));
    }
  }
  createGlobalActivityActionBar(container) {
    this.globalActivityActionBar = this._register(new ActionBar(container, {
      actionViewItemProvider: (action) => {
        if (action.id === "workbench.actions.manage") {
          return this.instantiationService.createInstance(GlobalActivityActionViewItem, action, () => this.compositeBar.getContextMenuActions(), (theme) => this.getActivitybarItemColors(theme), this.getActivityHoverOptions());
        }
        if (action.id === "workbench.actions.accounts") {
          return this.instantiationService.createInstance(AccountsActivityActionViewItem, action, () => this.compositeBar.getContextMenuActions(), (theme) => this.getActivitybarItemColors(theme), this.getActivityHoverOptions());
        }
        throw new Error(`No view item for action '${action.id}'`);
      },
      orientation: 1,
      ariaLabel: localize("manage", "Manage"),
      animated: false,
      preventLoopNavigation: true
    }));
    this.globalActivityAction = this._register(new ActivityAction({
      id: "workbench.actions.manage",
      name: localize("manage", "Manage"),
      classNames: ThemeIcon.asClassNameArray(_e.GEAR_ICON)
    }));
    if (this.accountsVisibilityPreference) {
      this.accountsActivityAction = this._register(new ActivityAction({
        id: "workbench.actions.accounts",
        name: localize("accounts", "Accounts"),
        classNames: ThemeIcon.asClassNameArray(_e.ACCOUNTS_ICON)
      }));
      this.globalActivityActionBar.push(this.accountsActivityAction, { index: _e.ACCOUNTS_ACTION_INDEX });
    }
    this.globalActivityActionBar.push(this.globalActivityAction);
  }
  toggleAccountsActivity() {
    if (!!this.accountsActivityAction === this.accountsVisibilityPreference) {
      return;
    }
    if (this.globalActivityActionBar) {
      if (this.accountsActivityAction) {
        this.globalActivityActionBar.pull(_e.ACCOUNTS_ACTION_INDEX);
        this.accountsActivityAction = void 0;
      } else {
        this.accountsActivityAction = this._register(new ActivityAction({
          id: "workbench.actions.accounts",
          name: localize("accounts", "Accounts"),
          classNames: ThemeIcon.asClassNameArray(Codicon.account)
        }));
        this.globalActivityActionBar.push(this.accountsActivityAction, { index: _e.ACCOUNTS_ACTION_INDEX });
      }
    }
    this.updateGlobalActivity(ACCOUNTS_ACTIVITY_ID);
  }
  getCompositeActions(compositeId) {
    let compositeActions = this.compositeActions.get(compositeId);
    if (!compositeActions) {
      const viewContainer = this.getViewContainer(compositeId);
      if (viewContainer) {
        const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
        compositeActions = {
          activityAction: this.instantiationService.createInstance(ViewContainerActivityAction, this.toActivity(viewContainerModel), this.paneCompositePart),
          pinnedAction: new ToggleCompositePinnedAction(this.toActivity(viewContainerModel), this.compositeBar),
          badgeAction: new ToggleCompositeBadgeAction(this.toActivity(viewContainerModel), this.compositeBar)
        };
      } else {
        const cachedComposite = this.cachedViewContainers.filter((c) => c.id === compositeId)[0];
        compositeActions = {
          activityAction: this.instantiationService.createInstance(PlaceHolderViewContainerActivityAction, _e.toActivity(compositeId, compositeId, cachedComposite == null ? void 0 : cachedComposite.icon, void 0), this.paneCompositePart),
          pinnedAction: new PlaceHolderToggleCompositePinnedAction(compositeId, this.compositeBar),
          badgeAction: new PlaceHolderToggleCompositeBadgeAction(compositeId, this.compositeBar)
        };
      }
      this.compositeActions.set(compositeId, compositeActions);
    }
    return compositeActions;
  }
  onDidRegisterViewContainers(viewContainers) {
    for (const viewContainer of viewContainers) {
      this.addComposite(viewContainer);
      const cachedViewContainer = this.cachedViewContainers.filter(({ id }) => id === viewContainer.id)[0];
      if (!cachedViewContainer) {
        this.compositeBar.pin(viewContainer.id);
      }
      const visibleViewContainer = this.paneCompositePart.getActivePaneComposite();
      if ((visibleViewContainer == null ? void 0 : visibleViewContainer.getId()) === viewContainer.id) {
        this.compositeBar.activateComposite(viewContainer.id);
      }
      const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
      this.updateActivity(viewContainer, viewContainerModel);
      this.showOrHideViewContainer(viewContainer);
      const disposables = new DisposableStore();
      disposables.add(viewContainerModel.onDidChangeContainerInfo(() => this.updateActivity(viewContainer, viewContainerModel)));
      disposables.add(viewContainerModel.onDidChangeActiveViewDescriptors(() => this.showOrHideViewContainer(viewContainer)));
      this.viewContainerDisposables.set(viewContainer.id, disposables);
    }
  }
  onDidDeregisterViewContainer(viewContainer) {
    const disposable = this.viewContainerDisposables.get(viewContainer.id);
    disposable == null ? void 0 : disposable.dispose();
    this.viewContainerDisposables.delete(viewContainer.id);
    this.removeComposite(viewContainer.id);
  }
  updateActivity(viewContainer, viewContainerModel) {
    const activity = this.toActivity(viewContainerModel);
    const { activityAction, pinnedAction } = this.getCompositeActions(viewContainer.id);
    activityAction.updateActivity(activity);
    if (pinnedAction instanceof PlaceHolderToggleCompositePinnedAction) {
      pinnedAction.setActivity(activity);
    }
    this.saveCachedViewContainers();
  }
  toActivity(viewContainerModel) {
    return _e.toActivity(viewContainerModel.viewContainer.id, viewContainerModel.title, viewContainerModel.icon, viewContainerModel.keybindingId);
  }
  static toActivity(id, name, icon, keybindingId) {
    let classNames = void 0;
    let iconUrl = void 0;
    if (URI.isUri(icon)) {
      iconUrl = icon;
      const cssUrl = asCSSUrl(icon);
      const hash2 = new StringSHA1();
      hash2.update(cssUrl);
      const iconId = `activity-${id.replace(/\./g, "-")}-${hash2.digest()}`;
      const iconClass = `.monaco-workbench .activitybar .monaco-action-bar .action-label.${iconId}`;
      classNames = [iconId, "uri-icon"];
      createCSSRule(iconClass, `
				mask: ${cssUrl} no-repeat 50% 50%;
				mask-size: 24px;
				-webkit-mask: ${cssUrl} no-repeat 50% 50%;
				-webkit-mask-size: 24px;
			`);
    } else if (ThemeIcon.isThemeIcon(icon)) {
      classNames = ThemeIcon.asClassNameArray(icon);
    }
    return { id, name, classNames, iconUrl, keybindingId };
  }
  showOrHideViewContainer(viewContainer) {
    let contextKey = this.enabledViewContainersContextKeys.get(viewContainer.id);
    if (!contextKey) {
      contextKey = this.contextKeyService.createKey(getEnabledViewContainerContextKey(viewContainer.id), false);
      this.enabledViewContainersContextKeys.set(viewContainer.id, contextKey);
    }
    if (this.shouldBeHidden(viewContainer)) {
      contextKey.set(false);
      this.hideComposite(viewContainer.id);
    } else {
      contextKey.set(true);
      this.addComposite(viewContainer);
    }
  }
  shouldBeHidden(viewContainerOrId, cachedViewContainer) {
    var _a2;
    const viewContainer = isString(viewContainerOrId) ? this.getViewContainer(viewContainerOrId) : viewContainerOrId;
    const viewContainerId = isString(viewContainerOrId) ? viewContainerOrId : viewContainerOrId.id;
    if (viewContainer) {
      if (viewContainer.hideIfEmpty) {
        if (this.viewDescriptorService.getViewContainerModel(viewContainer).activeViewDescriptors.length > 0) {
          return false;
        }
      } else {
        return false;
      }
    }
    if (!this.hasExtensionsRegistered && !(this.environmentService.remoteAuthority && isNative)) {
      cachedViewContainer = cachedViewContainer || this.cachedViewContainers.find(({ id }) => id === viewContainerId);
      if (!viewContainer && (cachedViewContainer == null ? void 0 : cachedViewContainer.isBuiltin) && (cachedViewContainer == null ? void 0 : cachedViewContainer.visible)) {
        return false;
      }
      if ((_a2 = cachedViewContainer == null ? void 0 : cachedViewContainer.views) == null ? void 0 : _a2.length) {
        return cachedViewContainer.views.every(({ when }) => !!when && !this.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(when)));
      }
    }
    return true;
  }
  addComposite(viewContainer) {
    this.compositeBar.addComposite({ id: viewContainer.id, name: typeof viewContainer.title === "string" ? viewContainer.title : viewContainer.title.value, order: viewContainer.order, requestedIndex: viewContainer.requestedIndex });
  }
  hideComposite(compositeId) {
    this.compositeBar.hideComposite(compositeId);
    const compositeActions = this.compositeActions.get(compositeId);
    if (compositeActions) {
      compositeActions.activityAction.dispose();
      compositeActions.pinnedAction.dispose();
      this.compositeActions.delete(compositeId);
    }
  }
  removeComposite(compositeId) {
    this.compositeBar.removeComposite(compositeId);
    const compositeActions = this.compositeActions.get(compositeId);
    if (compositeActions) {
      compositeActions.activityAction.dispose();
      compositeActions.pinnedAction.dispose();
      this.compositeActions.delete(compositeId);
    }
  }
  getPinnedPaneCompositeIds() {
    const pinnedCompositeIds = this.compositeBar.getPinnedComposites().map((v) => v.id);
    return this.getViewContainers().filter((v) => this.compositeBar.isPinned(v.id)).sort((v1, v2) => pinnedCompositeIds.indexOf(v1.id) - pinnedCompositeIds.indexOf(v2.id)).map((v) => v.id);
  }
  getVisiblePaneCompositeIds() {
    return this.compositeBar.getVisibleComposites().filter((v) => {
      var _a2;
      return ((_a2 = this.paneCompositePart.getActivePaneComposite()) == null ? void 0 : _a2.getId()) === v.id || this.compositeBar.isPinned(v.id);
    }).map((v) => v.id);
  }
  focus() {
    this.compositeBar.focus();
  }
  updateStyles() {
    super.updateStyles();
    const container = assertIsDefined(this.getContainer());
    const background = this.getColor(ACTIVITY_BAR_BACKGROUND) || "";
    container.style.backgroundColor = background;
    const borderColor = this.getColor(ACTIVITY_BAR_BORDER) || this.getColor(contrastBorder) || "";
    container.classList.toggle("bordered", !!borderColor);
    container.style.borderColor = borderColor ? borderColor : "";
  }
  getActivitybarItemColors(theme) {
    return {
      activeForegroundColor: theme.getColor(ACTIVITY_BAR_FOREGROUND),
      inactiveForegroundColor: theme.getColor(ACTIVITY_BAR_INACTIVE_FOREGROUND),
      activeBorderColor: theme.getColor(ACTIVITY_BAR_ACTIVE_BORDER),
      activeBackground: theme.getColor(ACTIVITY_BAR_ACTIVE_BACKGROUND),
      badgeBackground: theme.getColor(ACTIVITY_BAR_BADGE_BACKGROUND),
      badgeForeground: theme.getColor(ACTIVITY_BAR_BADGE_FOREGROUND),
      dragAndDropBorder: theme.getColor(ACTIVITY_BAR_DRAG_AND_DROP_BORDER),
      activeBackgroundColor: void 0,
      inactiveBackgroundColor: void 0,
      activeBorderBottomColor: void 0
    };
  }
  layout(width, height) {
    if (!this.layoutService.isVisible("workbench.parts.activitybar")) {
      return;
    }
    const contentAreaSize = super.layoutContents(width, height).contentSize;
    let availableHeight = contentAreaSize.height;
    if (this.menuBarContainer) {
      availableHeight -= this.menuBarContainer.clientHeight;
    }
    if (this.globalActivityActionBar) {
      availableHeight -= this.globalActivityActionBar.viewItems.length * _e.ACTION_HEIGHT;
    }
    this.compositeBar.layout(new Dimension(width, availableHeight));
  }
  getViewContainer(id) {
    const viewContainer = this.viewDescriptorService.getViewContainerById(id);
    return viewContainer && this.viewDescriptorService.getViewContainerLocation(viewContainer) === this.location ? viewContainer : void 0;
  }
  getViewContainers() {
    return this.viewDescriptorService.getViewContainersByLocation(this.location);
  }
  onDidStorageValueChange(e) {
    if (e.key === _e.PINNED_VIEW_CONTAINERS && e.scope === 0 && this.pinnedViewContainersValue !== this.getStoredPinnedViewContainersValue()) {
      this._pinnedViewContainersValue = void 0;
      this._cachedViewContainers = void 0;
      const newCompositeItems = [];
      const compositeItems = this.compositeBar.getCompositeBarItems();
      for (const cachedViewContainer of this.cachedViewContainers) {
        newCompositeItems.push({
          id: cachedViewContainer.id,
          name: cachedViewContainer.name,
          order: cachedViewContainer.order,
          pinned: cachedViewContainer.pinned,
          visible: !!compositeItems.find(({ id }) => id === cachedViewContainer.id)
        });
      }
      for (let index = 0; index < compositeItems.length; index++) {
        if (!newCompositeItems.some(({ id }) => id === compositeItems[index].id)) {
          const viewContainer = this.viewDescriptorService.getViewContainerById(compositeItems[index].id);
          newCompositeItems.splice(index, 0, {
            ...compositeItems[index],
            pinned: true,
            visible: true,
            order: viewContainer == null ? void 0 : viewContainer.order
          });
        }
      }
      this.compositeBar.setCompositeBarItems(newCompositeItems);
    }
    if (e.key === AccountsActivityActionViewItem.ACCOUNTS_VISIBILITY_PREFERENCE_KEY && e.scope === 0) {
      this.toggleAccountsActivity();
    }
  }
  saveCachedViewContainers() {
    const state = [];
    const compositeItems = this.compositeBar.getCompositeBarItems();
    for (const compositeItem of compositeItems) {
      const viewContainer = this.getViewContainer(compositeItem.id);
      if (viewContainer) {
        const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
        const views = [];
        for (const { when } of viewContainerModel.allViewDescriptors) {
          views.push({ when: when ? when.serialize() : void 0 });
        }
        state.push({
          id: compositeItem.id,
          name: viewContainerModel.title,
          icon: URI.isUri(viewContainerModel.icon) && this.environmentService.remoteAuthority ? void 0 : viewContainerModel.icon,
          views,
          pinned: compositeItem.pinned,
          order: compositeItem.order,
          visible: compositeItem.visible,
          isBuiltin: !viewContainer.extensionId
        });
      } else {
        state.push({ id: compositeItem.id, pinned: compositeItem.pinned, order: compositeItem.order, visible: false, isBuiltin: false });
      }
    }
    this.storeCachedViewContainersState(state);
  }
  get cachedViewContainers() {
    if (this._cachedViewContainers === void 0) {
      this._cachedViewContainers = this.getPinnedViewContainers();
      for (const placeholderViewContainer of this.getPlaceholderViewContainers()) {
        const cachedViewContainer = this._cachedViewContainers.filter((cached) => cached.id === placeholderViewContainer.id)[0];
        if (cachedViewContainer) {
          cachedViewContainer.name = placeholderViewContainer.name;
          cachedViewContainer.icon = placeholderViewContainer.themeIcon ? placeholderViewContainer.themeIcon : placeholderViewContainer.iconUrl ? URI.revive(placeholderViewContainer.iconUrl) : void 0;
          if (URI.isUri(cachedViewContainer.icon) && this.environmentService.remoteAuthority) {
            cachedViewContainer.icon = void 0;
          }
          cachedViewContainer.views = placeholderViewContainer.views;
          cachedViewContainer.isBuiltin = placeholderViewContainer.isBuiltin;
        }
      }
    }
    return this._cachedViewContainers;
  }
  storeCachedViewContainersState(cachedViewContainers) {
    this.setPinnedViewContainers(cachedViewContainers.map(({ id, pinned, visible, order }) => ({
      id,
      pinned,
      visible,
      order
    })));
    this.setPlaceholderViewContainers(cachedViewContainers.map(({ id, icon, name, views, isBuiltin }) => ({
      id,
      iconUrl: URI.isUri(icon) ? icon : void 0,
      themeIcon: ThemeIcon.isThemeIcon(icon) ? icon : void 0,
      name,
      isBuiltin,
      views
    })));
  }
  getPinnedViewContainers() {
    return JSON.parse(this.pinnedViewContainersValue);
  }
  setPinnedViewContainers(pinnedViewContainers) {
    this.pinnedViewContainersValue = JSON.stringify(pinnedViewContainers);
  }
  get pinnedViewContainersValue() {
    if (!this._pinnedViewContainersValue) {
      this._pinnedViewContainersValue = this.getStoredPinnedViewContainersValue();
    }
    return this._pinnedViewContainersValue;
  }
  set pinnedViewContainersValue(pinnedViewContainersValue) {
    if (this.pinnedViewContainersValue !== pinnedViewContainersValue) {
      this._pinnedViewContainersValue = pinnedViewContainersValue;
      this.setStoredPinnedViewContainersValue(pinnedViewContainersValue);
    }
  }
  getStoredPinnedViewContainersValue() {
    return this.storageService.get(_e.PINNED_VIEW_CONTAINERS, 0, "[]");
  }
  setStoredPinnedViewContainersValue(value) {
    this.storageService.store(_e.PINNED_VIEW_CONTAINERS, value, 0, 0);
  }
  getPlaceholderViewContainers() {
    return JSON.parse(this.placeholderViewContainersValue);
  }
  setPlaceholderViewContainers(placeholderViewContainers) {
    this.placeholderViewContainersValue = JSON.stringify(placeholderViewContainers);
  }
  get placeholderViewContainersValue() {
    if (!this._placeholderViewContainersValue) {
      this._placeholderViewContainersValue = this.getStoredPlaceholderViewContainersValue();
    }
    return this._placeholderViewContainersValue;
  }
  set placeholderViewContainersValue(placeholderViewContainesValue) {
    if (this.placeholderViewContainersValue !== placeholderViewContainesValue) {
      this._placeholderViewContainersValue = placeholderViewContainesValue;
      this.setStoredPlaceholderViewContainersValue(placeholderViewContainesValue);
    }
  }
  getStoredPlaceholderViewContainersValue() {
    return this.storageService.get(_e.PLACEHOLDER_VIEW_CONTAINERS, 0, "[]");
  }
  setStoredPlaceholderViewContainersValue(value) {
    this.storageService.store(_e.PLACEHOLDER_VIEW_CONTAINERS, value, 0, 1);
  }
  get accountsVisibilityPreference() {
    return this.storageService.getBoolean(AccountsActivityActionViewItem.ACCOUNTS_VISIBILITY_PREFERENCE_KEY, 0, true);
  }
  set accountsVisibilityPreference(value) {
    this.storageService.store(AccountsActivityActionViewItem.ACCOUNTS_VISIBILITY_PREFERENCE_KEY, value, 0, 0);
  }
  toJSON() {
    return {
      type: "workbench.parts.activitybar"
    };
  }
}, _e.PINNED_VIEW_CONTAINERS = "workbench.activity.pinnedViewlets2", _e.PLACEHOLDER_VIEW_CONTAINERS = "workbench.activity.placeholderViewlets", _e.ACTION_HEIGHT = 48, _e.ACCOUNTS_ACTION_INDEX = 0, _e.GEAR_ICON = registerIcon("settings-view-bar-icon", Codicon.settingsGear, localize("settingsViewBarIcon", "Settings icon in the view bar.")), _e.ACCOUNTS_ICON = registerIcon("accounts-view-bar-icon", Codicon.account, localize("accountsViewBarIcon", "Accounts icon in the view bar.")), _e);
ActivitybarPart = __decorate([
  __param(1, IInstantiationService),
  __param(2, IWorkbenchLayoutService),
  __param(3, IThemeService),
  __param(4, IStorageService),
  __param(5, IExtensionService),
  __param(6, IViewDescriptorService),
  __param(7, IContextKeyService),
  __param(8, IConfigurationService),
  __param(9, IWorkbenchEnvironmentService)
], ActivitybarPart);
var css$i = ".monaco-workbench.noauxiliarybar .part.auxiliarybar{display:none!important;visibility:hidden!important}.monaco-workbench .part.auxiliarybar>.content .monaco-editor,.monaco-workbench .part.auxiliarybar>.content .monaco-editor .margin,.monaco-workbench .part.auxiliarybar>.content .monaco-editor .monaco-editor-background{background-color:var(--vscode-sideBar-background)}.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:focus .action-label,.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:hover .action-label{color:var(--vscode-sideBarTitle-foreground)!important}.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item.checked .action-label,.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:hover .action-label{outline:var(--vscode-contrastActiveBorder,unset) solid 1px!important}.monaco-workbench .part.auxiliarybar>.title>.panel-switcher-container>.monaco-action-bar .action-item:not(.checked):hover .action-label{outline:var(--vscode-contrastActiveBorder,unset) dashed 1px!important}";
n(css$i, {});
var css$h = '.monaco-workbench .part.basepanel>.composite.title>.title-actions .monaco-action-bar .actions-container{justify-content:flex-end}.monaco-workbench .part.basepanel>.composite.title>.global-actions .monaco-action-bar .action-item,.monaco-workbench .part.basepanel>.composite.title>.title-actions .monaco-action-bar .action-item{margin-right:4px}.monaco-workbench .part.basepanel>.composite.title>.title-actions .monaco-action-bar .action-item .action-label{outline-offset:-2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container.composite-bar>.monaco-action-bar .action-label.codicon-more{align-items:center;color:inherit!important;display:flex;justify-content:center;margin-left:0;margin-right:0}.monaco-workbench .part.basepanel .empty-panel-message-area{display:none;height:100%;width:100%}.monaco-workbench .part.basepanel .empty-panel-message-area.visible{align-content:center;align-items:center;display:flex;justify-content:center}.monaco-workbench .part.basepanel .empty-panel-message-area .empty-panel-message{margin:12px;text-align:center}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar{height:35px;line-height:27px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item{display:flex;font-size:11px;padding:2px 10px;text-transform:uppercase}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon{padding-left:2px;padding-right:2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .action-label:not(.codicon){height:16px;width:16px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:before{background-color:var(--insert-border-color);content:"";display:none;height:24px;opacity:0;position:absolute;transition-delay:.1s;transition-duration:0ms;transition-property:opacity;width:2px}.monaco-workbench .part.basepanel>.composite.title.dragged-over>.panel-switcher-container>.monaco-action-bar .action-item:after,.monaco-workbench .part.basepanel>.composite.title.dragged-over>.panel-switcher-container>.monaco-action-bar .action-item:before{display:block}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:before{left:1px;margin-left:-2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:after{margin-right:-2px;right:1px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:first-of-type:before{left:2px;margin-left:-2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:last-of-type:after{margin-right:-2px;right:2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.left:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.left:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.right:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.right:before{transition-delay:0s}.monaco-workbench .part.basepanel>.composite.title.dragged-over-head>.panel-switcher-container>.monaco-action-bar .action-item:first-of-type:before,.monaco-workbench .part.basepanel>.composite.title.dragged-over-tail>.panel-switcher-container>.monaco-action-bar .action-item:last-of-type:after,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.left:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.right+.action-item:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:last-of-type.right:after{opacity:1}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item .action-label{border-radius:0;margin-right:0;padding:2px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .action-label.codicon,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:not(.icon) .action-label{background:none!important}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.checked .action-label{margin-right:0}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .badge{align-items:center;display:flex;margin-left:8px}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .badge{margin-left:0}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .badge .badge-content{border-radius:11px;box-sizing:border-box;display:inline-block;font-size:11px;font-weight:400;height:18px;line-height:11px;min-width:18px;padding:3px 5px;position:relative;text-align:center}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item .active-item-indicator{bottom:0;height:100%;left:10px;overflow:hidden;pointer-events:none;position:absolute;top:-4px;width:calc(100% - 20px);z-index:1}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.icon .active-item-indicator{left:2px;top:1px;width:calc(100% - 4px)}.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item.checked .active-item-indicator:before,.monaco-workbench .part.basepanel>.composite.title>.panel-switcher-container>.monaco-action-bar .action-item:focus .active-item-indicator:before{border-top-style:solid;border-top-width:1px;bottom:0;content:"";height:0;position:absolute;width:100%;z-index:1}.monaco-workbench .part.basepanel>.title>.panel-switcher-container>.monaco-action-bar .action-item.clicked:not(.checked):focus .active-item-indicator:before{border-top-color:transparent!important}.monaco-workbench .part.basepanel.right .global-actions .codicon-panel-maximize:before,.monaco-workbench .part.basepanel.right .global-actions .codicon-panel-restore:before,.monaco-workbench .part.basepanel.right .title-actions .codicon-split-horizontal:before{display:inline-block;transform:rotate(-90deg)}.monaco-workbench .part.basepanel.left .global-actions .codicon-panel-maximize:before,.monaco-workbench .part.basepanel.left .global-actions .codicon-panel-restore:before,.monaco-workbench .part.basepanel.left .title-actions .codicon-split-horizontal:before{display:inline-block;transform:rotate(90deg)}';
n(css$h, {});
let BasePanelPart = (_f = class extends CompositePart {
  get preferredHeight() {
    return this.layoutService.dimension.height * 0.4;
  }
  get preferredWidth() {
    const activeComposite = this.getActivePaneComposite();
    if (!activeComposite) {
      return;
    }
    const width = activeComposite.getOptimalWidth();
    if (typeof width !== "number") {
      return;
    }
    return Math.max(width, 300);
  }
  get onDidPaneCompositeOpen() {
    return Event.map(this.onDidCompositeOpen.event, (compositeEvent) => compositeEvent.composite);
  }
  constructor(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, viewDescriptorService, contextKeyService, extensionService, partId, activePanelSettingsKey, pinnedPanelsKey, placeholdeViewContainersKey, panelRegistryId, backgroundColor, viewContainerLocation, activePanelContextKey, panelFocusContextKey, panelOptions) {
    var _a2;
    super(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, Registry.as(panelRegistryId), activePanelSettingsKey, ((_a2 = viewDescriptorService.getDefaultViewContainer(viewContainerLocation)) == null ? void 0 : _a2.id) || "", "panel", "panel", void 0, partId, panelOptions);
    this.viewDescriptorService = viewDescriptorService;
    this.contextKeyService = contextKeyService;
    this.extensionService = extensionService;
    this.partId = partId;
    this.pinnedPanelsKey = pinnedPanelsKey;
    this.placeholdeViewContainersKey = placeholdeViewContainersKey;
    this.backgroundColor = backgroundColor;
    this.viewContainerLocation = viewContainerLocation;
    this.activePanelContextKey = activePanelContextKey;
    this.panelFocusContextKey = panelFocusContextKey;
    this.panelOptions = panelOptions;
    this.minimumWidth = 300;
    this.maximumWidth = Number.POSITIVE_INFINITY;
    this.minimumHeight = 77;
    this.maximumHeight = Number.POSITIVE_INFINITY;
    this.snap = true;
    this.onDidPaneCompositeClose = this.onDidCompositeClose.event;
    this.compositeActions = /* @__PURE__ */ new Map();
    this.panelDisposables = /* @__PURE__ */ new Map();
    this.blockOpeningPanel = false;
    this.extensionsRegistered = false;
    this.enabledViewContainersContextKeys = /* @__PURE__ */ new Map();
    this.panelRegistry = Registry.as(panelRegistryId);
    this.dndHandler = new CompositeDragAndDrop(
      this.viewDescriptorService,
      this.viewContainerLocation,
      (id, focus) => this.openPaneComposite(id, focus).then((panel) => panel || null),
      (from, to, before) => this.compositeBar.move(from, to, before == null ? void 0 : before.horizontallyBefore),
      () => this.compositeBar.getCompositeBarItems()
    );
    this.compositeBar = this._register(this.instantiationService.createInstance(CompositeBar, this.getCachedPanels(), {
      icon: !!this.panelOptions.useIcons,
      orientation: 0,
      activityHoverOptions: this.getActivityHoverOptions(),
      openComposite: (compositeId, preserveFocus) => this.openPaneComposite(compositeId, !preserveFocus).then((panel) => panel || null),
      getActivityAction: (compositeId) => this.getCompositeActions(compositeId).activityAction,
      getCompositePinnedAction: (compositeId) => this.getCompositeActions(compositeId).pinnedAction,
      getCompositeBadgeAction: (compositeId) => this.getCompositeActions(compositeId).badgeAction,
      getOnCompositeClickAction: (compositeId) => this.instantiationService.createInstance(PanelActivityAction, assertIsDefined(this.getPaneComposite(compositeId)), this.viewContainerLocation),
      fillExtraContextMenuActions: (actions) => this.fillExtraContextMenuActions(actions),
      getContextMenuActionsForComposite: (compositeId) => this.getContextMenuActionsForComposite(compositeId),
      getDefaultCompositeId: () => {
        var _a3;
        return (_a3 = viewDescriptorService.getDefaultViewContainer(this.viewContainerLocation)) == null ? void 0 : _a3.id;
      },
      hidePart: () => this.layoutService.setPartHidden(true, this.partId),
      dndHandler: this.dndHandler,
      compositeSize: 0,
      overflowActionSize: 44,
      colors: (theme) => ({
        activeBackgroundColor: theme.getColor(this.backgroundColor),
        inactiveBackgroundColor: theme.getColor(this.backgroundColor),
        activeBorderBottomColor: theme.getColor(PANEL_ACTIVE_TITLE_BORDER),
        activeForegroundColor: theme.getColor(PANEL_ACTIVE_TITLE_FOREGROUND),
        inactiveForegroundColor: theme.getColor(PANEL_INACTIVE_TITLE_FOREGROUND),
        badgeBackground: theme.getColor(badgeBackground),
        badgeForeground: theme.getColor(badgeForeground),
        dragAndDropBorder: theme.getColor(PANEL_DRAG_AND_DROP_BORDER)
      })
    }));
    this.registerListeners();
    this.onDidRegisterPanels([...this.getPaneComposites()]);
    this.globalActions = this._register(this.instantiationService.createInstance(CompositeMenuActions, partId === "workbench.parts.panel" ? MenuId.PanelTitle : MenuId.AuxiliaryBarTitle, void 0, void 0));
    this._register(this.globalActions.onDidChange(() => this.updateGlobalToolbarActions()));
  }
  getContextMenuActionsForComposite(compositeId) {
    const result = [];
    const viewContainer = this.viewDescriptorService.getViewContainerById(compositeId);
    const defaultLocation = this.viewDescriptorService.getDefaultViewContainerLocation(viewContainer);
    if (defaultLocation !== this.viewDescriptorService.getViewContainerLocation(viewContainer)) {
      result.push(toAction({ id: "resetLocationAction", label: localize("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewContainerToLocation(viewContainer, defaultLocation) }));
    } else {
      const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
      if (viewContainerModel.allViewDescriptors.length === 1) {
        const viewToReset = viewContainerModel.allViewDescriptors[0];
        const defaultContainer = this.viewDescriptorService.getDefaultContainerById(viewToReset.id);
        if (defaultContainer !== viewContainer) {
          result.push(toAction({ id: "resetLocationAction", label: localize("resetLocation", "Reset Location"), run: () => this.viewDescriptorService.moveViewsToContainer([viewToReset], defaultContainer) }));
        }
      }
    }
    return result;
  }
  onDidRegisterPanels(panels) {
    const cachedPanels = this.getCachedPanels();
    for (const panel of panels) {
      const cachedPanel = cachedPanels.filter(({ id }) => id === panel.id)[0];
      const activePanel = this.getActivePaneComposite();
      const isActive = (activePanel == null ? void 0 : activePanel.getId()) === panel.id || this.extensionsRegistered && this.compositeBar.getVisibleComposites().length === 0;
      if (isActive || !this.shouldBeHidden(panel.id, cachedPanel)) {
        const newPanel = {
          id: panel.id,
          name: panel.name,
          order: panel.order,
          requestedIndex: panel.requestedIndex
        };
        this.compositeBar.addComposite(newPanel);
        if (!cachedPanel) {
          this.compositeBar.pin(panel.id);
        }
        if (isActive) {
          this.compositeBar.activateComposite(panel.id);
          if (!activePanel && this.element && this.layoutService.isVisible(this.partId)) {
            this.doOpenPanel(panel.id);
          }
        }
      }
    }
    for (const panel of panels) {
      const viewContainer = this.getViewContainer(panel.id);
      const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
      this.updateActivity(viewContainer, viewContainerModel);
      this.showOrHideViewContainer(viewContainer, viewContainerModel);
      const disposables = new DisposableStore();
      disposables.add(viewContainerModel.onDidChangeActiveViewDescriptors(() => this.showOrHideViewContainer(viewContainer, viewContainerModel)));
      disposables.add(viewContainerModel.onDidChangeContainerInfo(() => this.updateActivity(viewContainer, viewContainerModel)));
      this.panelDisposables.set(panel.id, disposables);
    }
  }
  async onDidDeregisterPanel(panelId) {
    var _a2, _b2;
    const disposable = this.panelDisposables.get(panelId);
    disposable == null ? void 0 : disposable.dispose();
    this.panelDisposables.delete(panelId);
    const activeContainers = this.viewDescriptorService.getViewContainersByLocation(this.viewContainerLocation).filter((container) => this.viewDescriptorService.getViewContainerModel(container).activeViewDescriptors.length > 0);
    if (activeContainers.length) {
      if (((_a2 = this.getActivePaneComposite()) == null ? void 0 : _a2.getId()) === panelId) {
        const defaultPanelId = (_b2 = this.viewDescriptorService.getDefaultViewContainer(this.viewContainerLocation)) == null ? void 0 : _b2.id;
        const containerToOpen = activeContainers.filter((c) => c.id === defaultPanelId)[0] || activeContainers[0];
        await this.openPaneComposite(containerToOpen.id);
      }
    } else {
      this.layoutService.setPartHidden(true, this.partId);
    }
    this.removeComposite(panelId);
  }
  updateActivity(viewContainer, viewContainerModel) {
    var _a2;
    const cachedTitle = (_a2 = this.getPlaceholderViewContainers().filter((panel) => panel.id === viewContainer.id)[0]) == null ? void 0 : _a2.name;
    const activity = {
      id: viewContainer.id,
      name: this.extensionsRegistered || cachedTitle === void 0 ? viewContainerModel.title : cachedTitle,
      keybindingId: viewContainerModel.keybindingId
    };
    const { activityAction, pinnedAction } = this.getCompositeActions(viewContainer.id);
    activityAction.setActivity(this.toActivity(viewContainerModel));
    if (pinnedAction instanceof PlaceHolderToggleCompositePinnedAction$1) {
      pinnedAction.setActivity(activity);
    }
    this.compositeBar.recomputeSizes();
    this.layoutCompositeBar();
    if (this.extensionsRegistered) {
      this.saveCachedPanels();
    }
  }
  toActivity(viewContainerModel) {
    return _f.toActivity(viewContainerModel.viewContainer.id, viewContainerModel.title, this.panelOptions.useIcons ? viewContainerModel.icon : void 0, viewContainerModel.keybindingId);
  }
  static toActivity(id, name, icon, keybindingId) {
    let classNames = void 0;
    let iconUrl = void 0;
    if (URI.isUri(icon)) {
      iconUrl = icon;
      const cssUrl = asCSSUrl(icon);
      const hash2 = new StringSHA1();
      hash2.update(cssUrl);
      const iconId = `activity-${id.replace(/\./g, "-")}-${hash2.digest()}`;
      classNames = [iconId, "uri-icon"];
      const iconClass = `.monaco-workbench .basepanel .monaco-action-bar .action-label.${iconId}`;
      createCSSRule(iconClass, `
				mask: ${cssUrl} no-repeat 50% 50%;
				mask-size: 16px;
				-webkit-mask: ${cssUrl} no-repeat 50% 50%;
				-webkit-mask-size: 16px;
				mask-origin: padding;
				-webkit-mask-origin: padding;
			`);
    } else if (ThemeIcon.isThemeIcon(icon)) {
      classNames = ThemeIcon.asClassNameArray(icon);
    }
    return { id, name, classNames, iconUrl, keybindingId };
  }
  showOrHideViewContainer(viewContainer, viewContainerModel) {
    let contextKey = this.enabledViewContainersContextKeys.get(viewContainer.id);
    if (!contextKey) {
      contextKey = this.contextKeyService.createKey(getEnabledViewContainerContextKey(viewContainer.id), false);
      this.enabledViewContainersContextKeys.set(viewContainer.id, contextKey);
    }
    if (viewContainerModel.activeViewDescriptors.length) {
      contextKey.set(true);
      this.compositeBar.addComposite({ id: viewContainer.id, name: typeof viewContainer.title === "string" ? viewContainer.title : viewContainer.title.value, order: viewContainer.order, requestedIndex: viewContainer.requestedIndex });
      if (this.layoutService.isRestored() && this.layoutService.isVisible(this.partId)) {
        const activeComposite = this.getActiveComposite();
        if (activeComposite === void 0 || activeComposite.getId() === viewContainer.id) {
          this.compositeBar.activateComposite(viewContainer.id);
        }
      }
      this.layoutCompositeBar();
      this.layoutEmptyMessage();
    } else if (viewContainer.hideIfEmpty) {
      contextKey.set(false);
      this.hideComposite(viewContainer.id);
    }
  }
  shouldBeHidden(panelId, cachedPanel) {
    const viewContainer = this.getViewContainer(panelId);
    if (!viewContainer || !viewContainer.hideIfEmpty) {
      return false;
    }
    return (cachedPanel == null ? void 0 : cachedPanel.views) && cachedPanel.views.length ? cachedPanel.views.every(({ when }) => !!when && !this.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(when))) : false;
  }
  registerListeners() {
    this._register(this.registry.onDidRegister((panel) => this.onDidRegisterPanels([panel])));
    this._register(this.registry.onDidDeregister((panel) => this.onDidDeregisterPanel(panel.id)));
    this._register(this.onDidPaneCompositeOpen((panel) => this.onPanelOpen(panel)));
    this._register(this.onDidPaneCompositeClose(this.onPanelClose, this));
    const disposables = this._register(new DisposableStore());
    this._register(this.extensionService.onDidRegisterExtensions(() => {
      disposables.clear();
      this.onDidRegisterExtensions();
      this.compositeBar.onDidChange(() => this.saveCachedPanels(), this, disposables);
      this.storageService.onDidChangeValue((e) => this.onDidStorageValueChange(e), this, disposables);
    }));
  }
  onDidRegisterExtensions() {
    this.extensionsRegistered = true;
    const panels = this.getPaneComposites();
    for (const { id } of this.getCachedPanels()) {
      if (panels.every((panel) => panel.id !== id)) {
        if (this.viewDescriptorService.isViewContainerRemovedPermanently(id)) {
          this.removeComposite(id);
        } else {
          this.hideComposite(id);
        }
      }
    }
    this.saveCachedPanels();
  }
  hideComposite(compositeId) {
    this.compositeBar.hideComposite(compositeId);
    const compositeActions = this.compositeActions.get(compositeId);
    if (compositeActions) {
      compositeActions.activityAction.dispose();
      compositeActions.pinnedAction.dispose();
      this.compositeActions.delete(compositeId);
    }
  }
  onPanelOpen(panel) {
    this.activePanelContextKey.set(panel.getId());
    const foundPanel = this.panelRegistry.getPaneComposite(panel.getId());
    if (foundPanel) {
      this.compositeBar.addComposite(foundPanel);
    }
    this.compositeBar.activateComposite(panel.getId());
    const panelDescriptor = this.panelRegistry.getPaneComposite(panel.getId());
    if (panelDescriptor) {
      const viewContainer = this.getViewContainer(panelDescriptor.id);
      if (viewContainer == null ? void 0 : viewContainer.hideIfEmpty) {
        const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
        if (viewContainerModel.activeViewDescriptors.length === 0) {
          this.hideComposite(panelDescriptor.id);
        }
      }
    }
    this.layoutCompositeBar();
    this.layoutEmptyMessage();
  }
  onPanelClose(panel) {
    const id = panel.getId();
    if (this.activePanelContextKey.get() === id) {
      this.activePanelContextKey.reset();
    }
    this.compositeBar.deactivateComposite(panel.getId());
    this.layoutEmptyMessage();
  }
  create(parent) {
    this.element = parent;
    super.create(parent);
    this.createEmptyPanelMessage();
    const focusTracker = this._register(trackFocus(parent));
    this._register(focusTracker.onDidFocus(() => this.panelFocusContextKey.set(true)));
    this._register(focusTracker.onDidBlur(() => this.panelFocusContextKey.set(false)));
  }
  createEmptyPanelMessage() {
    const contentArea = this.getContentArea();
    this.emptyPanelMessageElement = document.createElement("div");
    this.emptyPanelMessageElement.classList.add("empty-panel-message-area");
    const messageElement = document.createElement("div");
    messageElement.classList.add("empty-panel-message");
    messageElement.innerText = localize("panel.emptyMessage", "Drag a view here to display.");
    this.emptyPanelMessageElement.appendChild(messageElement);
    contentArea.appendChild(this.emptyPanelMessageElement);
    this._register(CompositeDragAndDropObserver.INSTANCE.registerTarget(this.emptyPanelMessageElement, {
      onDragOver: (e) => {
        EventHelper.stop(e.eventData, true);
        const validDropTarget = this.dndHandler.onDragEnter(e.dragAndDropData, void 0, e.eventData);
        toggleDropEffect(e.eventData.dataTransfer, "move", validDropTarget);
      },
      onDragEnter: (e) => {
        var _a2;
        EventHelper.stop(e.eventData, true);
        const validDropTarget = this.dndHandler.onDragEnter(e.dragAndDropData, void 0, e.eventData);
        this.emptyPanelMessageElement.style.backgroundColor = validDropTarget ? ((_a2 = this.theme.getColor(EDITOR_DRAG_AND_DROP_BACKGROUND)) == null ? void 0 : _a2.toString()) || "" : "";
      },
      onDragLeave: (e) => {
        EventHelper.stop(e.eventData, true);
        this.emptyPanelMessageElement.style.backgroundColor = "";
      },
      onDragEnd: (e) => {
        EventHelper.stop(e.eventData, true);
        this.emptyPanelMessageElement.style.backgroundColor = "";
      },
      onDrop: (e) => {
        EventHelper.stop(e.eventData, true);
        this.emptyPanelMessageElement.style.backgroundColor = "";
        this.dndHandler.drop(e.dragAndDropData, void 0, e.eventData);
      }
    }));
  }
  createTitleArea(parent) {
    const element = super.createTitleArea(parent);
    const globalTitleActionsContainer = element.appendChild($$2(".global-actions"));
    this.globalToolBar = this._register(new ToolBar(globalTitleActionsContainer, this.contextMenuService, {
      actionViewItemProvider: (action) => this.actionViewItemProvider(action),
      orientation: 0,
      getKeyBinding: (action) => this.keybindingService.lookupKeybinding(action.id),
      anchorAlignmentProvider: () => this.getTitleAreaDropDownAnchorAlignment(),
      toggleMenuTitle: localize("moreActions", "More Actions...")
    }));
    this.updateGlobalToolbarActions();
    return element;
  }
  updateStyles() {
    super.updateStyles();
    const container = assertIsDefined(this.getContainer());
    container.style.backgroundColor = this.getColor(this.backgroundColor) || "";
    const borderColor = this.getColor(contrastBorder) || "";
    container.style.borderLeftColor = borderColor;
    container.style.borderRightColor = borderColor;
    const title = this.getTitleArea();
    if (title) {
      title.style.borderTopColor = this.getColor(contrastBorder) || "";
    }
  }
  doOpenPanel(id, focus) {
    if (this.blockOpeningPanel) {
      return void 0;
    }
    if (!this.layoutService.isVisible(this.partId)) {
      try {
        this.blockOpeningPanel = true;
        this.layoutService.setPartHidden(false, this.partId);
      } finally {
        this.blockOpeningPanel = false;
      }
    }
    return this.openComposite(id, focus);
  }
  async openPaneComposite(id, focus) {
    if (typeof id === "string" && this.getPaneComposite(id)) {
      return this.doOpenPanel(id, focus);
    }
    await this.extensionService.whenInstalledExtensionsRegistered();
    if (typeof id === "string" && this.getPaneComposite(id)) {
      return this.doOpenPanel(id, focus);
    }
    return void 0;
  }
  showActivity(panelId, badge, clazz) {
    return this.compositeBar.showActivity(panelId, badge, clazz);
  }
  getPaneComposite(panelId) {
    return this.panelRegistry.getPaneComposite(panelId);
  }
  getPaneComposites() {
    return this.panelRegistry.getPaneComposites().sort((v1, v2) => {
      if (typeof v1.order !== "number") {
        return 1;
      }
      if (typeof v2.order !== "number") {
        return -1;
      }
      return v1.order - v2.order;
    });
  }
  getPinnedPaneCompositeIds() {
    const pinnedCompositeIds = this.compositeBar.getPinnedComposites().map((c) => c.id);
    return this.getPaneComposites().filter((p) => pinnedCompositeIds.includes(p.id)).sort((p1, p2) => pinnedCompositeIds.indexOf(p1.id) - pinnedCompositeIds.indexOf(p2.id)).map((p) => p.id);
  }
  getVisiblePaneCompositeIds() {
    return this.compositeBar.getVisibleComposites().filter((v) => {
      var _a2;
      return ((_a2 = this.getActivePaneComposite()) == null ? void 0 : _a2.getId()) === v.id || this.compositeBar.isPinned(v.id);
    }).map((v) => v.id);
  }
  getActivePaneComposite() {
    return this.getActiveComposite();
  }
  getLastActivePaneCompositeId() {
    return this.getLastActiveCompositeId();
  }
  hideActivePaneComposite() {
    if (this.layoutService.isVisible(this.partId)) {
      this.layoutService.setPartHidden(true, this.partId);
    }
    this.hideActiveComposite();
  }
  createTitleLabel(parent) {
    const titleArea = this.compositeBar.create(parent);
    titleArea.classList.add("panel-switcher-container");
    return {
      updateTitle: (id, title, keybinding) => {
        const action = this.compositeBar.getAction(id);
        if (action) {
          action.label = title;
        }
      },
      updateStyles: () => {
      }
    };
  }
  onTitleAreaUpdate(compositeId) {
    super.onTitleAreaUpdate(compositeId);
    this.layoutCompositeBar();
  }
  layout(width, height, top, left) {
    if (!this.layoutService.isVisible(this.partId)) {
      return;
    }
    this.contentDimension = new Dimension(width, height);
    super.layout(this.contentDimension.width, this.contentDimension.height, top, left);
    this.layoutCompositeBar();
    this.layoutEmptyMessage();
  }
  layoutCompositeBar() {
    if (this.contentDimension && this.dimension) {
      let availableWidth = this.contentDimension.width - 40;
      if (this.toolBar) {
        availableWidth = Math.max(_f.MIN_COMPOSITE_BAR_WIDTH, availableWidth - this.getToolbarWidth());
      }
      this.compositeBar.layout(new Dimension(availableWidth, this.dimension.height));
    }
  }
  layoutEmptyMessage() {
    var _a2;
    (_a2 = this.emptyPanelMessageElement) == null ? void 0 : _a2.classList.toggle("visible", this.compositeBar.getVisibleComposites().length === 0);
  }
  getViewContainer(id) {
    const viewContainer = this.viewDescriptorService.getViewContainerById(id);
    return viewContainer && this.viewDescriptorService.getViewContainerLocation(viewContainer) === this.viewContainerLocation ? viewContainer : void 0;
  }
  updateGlobalToolbarActions() {
    var _a2;
    const primaryActions = this.globalActions.getPrimaryActions();
    const secondaryActions = this.globalActions.getSecondaryActions();
    (_a2 = this.globalToolBar) == null ? void 0 : _a2.setActions(prepareActions(primaryActions), prepareActions(secondaryActions));
  }
  getCompositeActions(compositeId) {
    let compositeActions = this.compositeActions.get(compositeId);
    if (!compositeActions) {
      const viewContainer = this.getViewContainer(compositeId);
      if (viewContainer) {
        const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
        compositeActions = {
          activityAction: this.instantiationService.createInstance(PanelActivityAction, this.toActivity(viewContainerModel), this.viewContainerLocation),
          pinnedAction: new ToggleCompositePinnedAction(this.toActivity(viewContainerModel), this.compositeBar),
          badgeAction: new ToggleCompositeBadgeAction(this.toActivity(viewContainerModel), this.compositeBar)
        };
      } else {
        compositeActions = {
          activityAction: this.instantiationService.createInstance(PlaceHolderPanelActivityAction, compositeId, this.viewContainerLocation),
          pinnedAction: new PlaceHolderToggleCompositePinnedAction$1(compositeId, this.compositeBar),
          badgeAction: new PlaceHolderToggleCompositeBadgeAction(compositeId, this.compositeBar)
        };
      }
      this.compositeActions.set(compositeId, compositeActions);
    }
    return compositeActions;
  }
  removeComposite(compositeId) {
    if (super.removeComposite(compositeId)) {
      this.compositeBar.removeComposite(compositeId);
      const compositeActions = this.compositeActions.get(compositeId);
      if (compositeActions) {
        compositeActions.activityAction.dispose();
        compositeActions.pinnedAction.dispose();
        this.compositeActions.delete(compositeId);
      }
      return true;
    }
    return false;
  }
  getToolbarWidth() {
    var _a2;
    const activePanel = this.getActivePaneComposite();
    if (!activePanel || !this.toolBar) {
      return 0;
    }
    return this.toolBar.getItemsWidth() + (((_a2 = this.globalToolBar) == null ? void 0 : _a2.getItemsWidth()) ?? 0);
  }
  onDidStorageValueChange(e) {
    if (e.key === this.pinnedPanelsKey && e.scope === 0 && this.cachedPanelsValue !== this.getStoredCachedPanelsValue()) {
      this._cachedPanelsValue = void 0;
      const newCompositeItems = [];
      const compositeItems = this.compositeBar.getCompositeBarItems();
      const cachedPanels = this.getCachedPanels();
      for (const cachedPanel of cachedPanels) {
        newCompositeItems.push({
          id: cachedPanel.id,
          name: cachedPanel.name,
          order: cachedPanel.order,
          pinned: cachedPanel.pinned,
          visible: !!compositeItems.find(({ id }) => id === cachedPanel.id)
        });
      }
      for (let index = 0; index < compositeItems.length; index++) {
        if (!newCompositeItems.some(({ id }) => id === compositeItems[index].id)) {
          newCompositeItems.splice(index, 0, compositeItems[index]);
        }
      }
      this.compositeBar.setCompositeBarItems(newCompositeItems);
    }
  }
  saveCachedPanels() {
    const state = [];
    const placeholders = [];
    const compositeItems = this.compositeBar.getCompositeBarItems();
    for (const compositeItem of compositeItems) {
      const viewContainer = this.getViewContainer(compositeItem.id);
      if (viewContainer) {
        const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
        state.push({ id: compositeItem.id, name: viewContainerModel.title, pinned: compositeItem.pinned, order: compositeItem.order, visible: compositeItem.visible });
        placeholders.push({ id: compositeItem.id, name: this.getCompositeActions(compositeItem.id).activityAction.label });
      } else {
        state.push({ id: compositeItem.id, name: compositeItem.name, pinned: compositeItem.pinned, order: compositeItem.order, visible: compositeItem.visible });
      }
    }
    this.cachedPanelsValue = JSON.stringify(state);
    this.setPlaceholderViewContainers(placeholders);
  }
  getCachedPanels() {
    const registeredPanels = this.getPaneComposites();
    const storedStates = JSON.parse(this.cachedPanelsValue);
    const cachedPanels = storedStates.map((c) => {
      const serialized = typeof c === "string" ? { id: c, pinned: true, order: void 0, visible: true } : c;
      const registered = registeredPanels.some((p) => p.id === serialized.id);
      serialized.visible = registered ? isUndefinedOrNull(serialized.visible) ? true : serialized.visible : false;
      return serialized;
    });
    for (const placeholderViewContainer of this.getPlaceholderViewContainers()) {
      const cachedViewContainer = cachedPanels.filter((cached) => cached.id === placeholderViewContainer.id)[0];
      if (cachedViewContainer) {
        cachedViewContainer.name = placeholderViewContainer.name;
      }
    }
    return cachedPanels;
  }
  get cachedPanelsValue() {
    if (!this._cachedPanelsValue) {
      this._cachedPanelsValue = this.getStoredCachedPanelsValue();
    }
    return this._cachedPanelsValue;
  }
  set cachedPanelsValue(cachedViewletsValue) {
    if (this.cachedPanelsValue !== cachedViewletsValue) {
      this._cachedPanelsValue = cachedViewletsValue;
      this.setStoredCachedViewletsValue(cachedViewletsValue);
    }
  }
  getStoredCachedPanelsValue() {
    return this.storageService.get(this.pinnedPanelsKey, 0, "[]");
  }
  setStoredCachedViewletsValue(value) {
    this.storageService.store(this.pinnedPanelsKey, value, 0, 0);
  }
  getPlaceholderViewContainers() {
    return JSON.parse(this.placeholderViewContainersValue);
  }
  setPlaceholderViewContainers(placeholderViewContainers) {
    this.placeholderViewContainersValue = JSON.stringify(placeholderViewContainers);
  }
  get placeholderViewContainersValue() {
    if (!this._placeholderViewContainersValue) {
      this._placeholderViewContainersValue = this.getStoredPlaceholderViewContainersValue();
    }
    return this._placeholderViewContainersValue;
  }
  set placeholderViewContainersValue(placeholderViewContainesValue) {
    if (this.placeholderViewContainersValue !== placeholderViewContainesValue) {
      this._placeholderViewContainersValue = placeholderViewContainesValue;
      this.setStoredPlaceholderViewContainersValue(placeholderViewContainesValue);
    }
  }
  getStoredPlaceholderViewContainersValue() {
    return this.storageService.get(this.placeholdeViewContainersKey, 1, "[]");
  }
  setStoredPlaceholderViewContainersValue(value) {
    this.storageService.store(this.placeholdeViewContainersKey, value, 1, 1);
  }
}, _f.MIN_COMPOSITE_BAR_WIDTH = 50, _f);
BasePanelPart = __decorate([
  __param(0, INotificationService),
  __param(1, IStorageService),
  __param(2, IContextMenuService),
  __param(3, IWorkbenchLayoutService),
  __param(4, IKeybindingService),
  __param(5, IInstantiationService),
  __param(6, IThemeService),
  __param(7, IViewDescriptorService),
  __param(8, IContextKeyService),
  __param(9, IExtensionService)
], BasePanelPart);
let PanelPart = (_g = class extends BasePanelPart {
  constructor(notificationService, storageService, telemetryService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, viewDescriptorService, contextKeyService, extensionService, commandService, menuService) {
    super(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, viewDescriptorService, contextKeyService, extensionService, "workbench.parts.panel", _g.activePanelSettingsKey, "workbench.panel.pinnedPanels", "workbench.panel.placeholderPanels", Extensions.Panels, PANEL_BACKGROUND, 1, ActivePanelContext.bindTo(contextKeyService), PanelFocusContext.bindTo(contextKeyService), {
      useIcons: false,
      hasTitle: true
    });
    this.commandService = commandService;
    this.menuService = menuService;
  }
  updateStyles() {
    super.updateStyles();
    const container = assertIsDefined(this.getContainer());
    const borderColor = this.getColor(PANEL_BORDER) || this.getColor(contrastBorder) || "";
    container.style.borderLeftColor = borderColor;
    container.style.borderRightColor = borderColor;
    const title = this.getTitleArea();
    if (title) {
      title.style.borderTopColor = this.getColor(PANEL_BORDER) || this.getColor(contrastBorder) || "";
    }
  }
  getActivityHoverOptions() {
    return {
      position: () => this.layoutService.getPanelPosition() === 2 && !this.layoutService.isPanelMaximized() ? 3 : 2
    };
  }
  fillExtraContextMenuActions(actions) {
    const panelPositionMenu = this.menuService.createMenu(MenuId.PanelPositionMenu, this.contextKeyService);
    const panelAlignMenu = this.menuService.createMenu(MenuId.PanelAlignmentMenu, this.contextKeyService);
    const positionActions = [];
    const alignActions = [];
    createAndFillInContextMenuActions(panelPositionMenu, { shouldForwardArgs: true }, { primary: [], secondary: positionActions });
    createAndFillInContextMenuActions(panelAlignMenu, { shouldForwardArgs: true }, { primary: [], secondary: alignActions });
    panelAlignMenu.dispose();
    panelPositionMenu.dispose();
    actions.push(...[
      new Separator(),
      new SubmenuAction("workbench.action.panel.position", localize("panel position", "Panel Position"), positionActions),
      new SubmenuAction("workbench.action.panel.align", localize("align panel", "Align Panel"), alignActions),
      toAction({ id: TogglePanelAction.ID, label: localize("hidePanel", "Hide Panel"), run: () => this.commandService.executeCommand(TogglePanelAction.ID) })
    ]);
  }
  layout(width, height, top, left) {
    let dimensions;
    if (this.layoutService.getPanelPosition() === 1) {
      dimensions = new Dimension(width - 1, height);
    } else {
      dimensions = new Dimension(width, height);
    }
    super.layout(dimensions.width, dimensions.height, top, left);
  }
  toJSON() {
    return {
      type: "workbench.parts.panel"
    };
  }
}, _g.activePanelSettingsKey = "workbench.panelpart.activepanelid", _g);
PanelPart = __decorate([
  __param(0, INotificationService),
  __param(1, IStorageService),
  __param(2, ITelemetryService),
  __param(3, IContextMenuService),
  __param(4, IWorkbenchLayoutService),
  __param(5, IKeybindingService),
  __param(6, IInstantiationService),
  __param(7, IThemeService),
  __param(8, IViewDescriptorService),
  __param(9, IContextKeyService),
  __param(10, IExtensionService),
  __param(11, ICommandService),
  __param(12, IMenuService)
], PanelPart);
let AuxiliaryBarPart = (_h = class extends BasePanelPart {
  constructor(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, viewDescriptorService, contextKeyService, extensionService, commandService) {
    super(notificationService, storageService, contextMenuService, layoutService, keybindingService, instantiationService, themeService, viewDescriptorService, contextKeyService, extensionService, "workbench.parts.auxiliarybar", _h.activePanelSettingsKey, _h.pinnedPanelsKey, _h.placeholdeViewContainersKey, Extensions.Auxiliary, SIDE_BAR_BACKGROUND, 2, ActiveAuxiliaryContext.bindTo(contextKeyService), AuxiliaryBarFocusContext.bindTo(contextKeyService), {
      useIcons: true,
      hasTitle: true,
      borderWidth: () => this.getColor(SIDE_BAR_BORDER) || this.getColor(contrastBorder) ? 1 : 0
    });
    this.commandService = commandService;
    this.minimumWidth = 170;
    this.maximumWidth = Number.POSITIVE_INFINITY;
    this.minimumHeight = 0;
    this.maximumHeight = Number.POSITIVE_INFINITY;
    this.priority = 1;
  }
  updateStyles() {
    super.updateStyles();
    const container = assertIsDefined(this.getContainer());
    const borderColor = this.getColor(SIDE_BAR_BORDER) || this.getColor(contrastBorder);
    const isPositionLeft = this.layoutService.getSideBarPosition() === 1;
    container.style.color = this.getColor(SIDE_BAR_FOREGROUND) || "";
    container.style.borderLeftColor = borderColor ?? "";
    container.style.borderRightColor = borderColor ?? "";
    container.style.borderLeftStyle = borderColor && !isPositionLeft ? "solid" : "none";
    container.style.borderRightStyle = borderColor && isPositionLeft ? "solid" : "none";
    container.style.borderLeftWidth = borderColor && !isPositionLeft ? "1px" : "0px";
    container.style.borderRightWidth = borderColor && isPositionLeft ? "1px" : "0px";
  }
  getActivityHoverOptions() {
    return {
      position: () => 2
    };
  }
  fillExtraContextMenuActions(actions) {
    const currentPositionRight = this.layoutService.getSideBarPosition() === 0;
    actions.push(...[
      new Separator(),
      toAction({ id: ToggleSidebarPositionAction.ID, label: currentPositionRight ? localize("move second side bar left", "Move Secondary Side Bar Left") : localize("move second side bar right", "Move Secondary Side Bar Right"), run: () => this.commandService.executeCommand(ToggleSidebarPositionAction.ID) }),
      toAction({ id: ToggleAuxiliaryBarAction.ID, label: localize("hide second side bar", "Hide Secondary Side Bar"), run: () => this.commandService.executeCommand(ToggleAuxiliaryBarAction.ID) })
    ]);
  }
  toJSON() {
    return {
      type: "workbench.parts.auxiliarybar"
    };
  }
}, _h.activePanelSettingsKey = "workbench.auxiliarybar.activepanelid", _h.pinnedPanelsKey = "workbench.auxiliarybar.pinnedPanels", _h.placeholdeViewContainersKey = "workbench.auxiliarybar.placeholderPanels", _h);
AuxiliaryBarPart = __decorate([
  __param(0, INotificationService),
  __param(1, IStorageService),
  __param(2, IContextMenuService),
  __param(3, IWorkbenchLayoutService),
  __param(4, IKeybindingService),
  __param(5, IInstantiationService),
  __param(6, IThemeService),
  __param(7, IViewDescriptorService),
  __param(8, IContextKeyService),
  __param(9, IExtensionService),
  __param(10, ICommandService)
], AuxiliaryBarPart);
let PaneCompositeParts = class PaneCompositeParts2 extends Disposable {
  constructor(instantiationService) {
    super();
    this.paneCompositeParts = /* @__PURE__ */ new Map();
    this.paneCompositeSelectorParts = /* @__PURE__ */ new Map();
    const panelPart = instantiationService.createInstance(PanelPart);
    const sideBarPart = instantiationService.createInstance(SidebarPart);
    const auxiliaryBarPart = instantiationService.createInstance(AuxiliaryBarPart);
    const activityBarPart = instantiationService.createInstance(ActivitybarPart, sideBarPart);
    this.paneCompositeParts.set(1, panelPart);
    this.paneCompositeParts.set(0, sideBarPart);
    this.paneCompositeParts.set(2, auxiliaryBarPart);
    this.paneCompositeSelectorParts.set(1, panelPart);
    this.paneCompositeSelectorParts.set(0, activityBarPart);
    this.paneCompositeSelectorParts.set(2, auxiliaryBarPart);
    const eventDisposables = this._register(new DisposableStore());
    this.onDidPaneCompositeOpen = Event.any(...ViewContainerLocations.map((loc) => Event.map(
      this.paneCompositeParts.get(loc).onDidPaneCompositeOpen,
      (composite) => {
        return { composite, viewContainerLocation: loc };
      },
      eventDisposables
    )));
    this.onDidPaneCompositeClose = Event.any(...ViewContainerLocations.map((loc) => Event.map(
      this.paneCompositeParts.get(loc).onDidPaneCompositeClose,
      (composite) => {
        return { composite, viewContainerLocation: loc };
      },
      eventDisposables
    )));
  }
  openPaneComposite(id, viewContainerLocation, focus) {
    return this.getPartByLocation(viewContainerLocation).openPaneComposite(id, focus);
  }
  getActivePaneComposite(viewContainerLocation) {
    return this.getPartByLocation(viewContainerLocation).getActivePaneComposite();
  }
  getPaneComposite(id, viewContainerLocation) {
    return this.getPartByLocation(viewContainerLocation).getPaneComposite(id);
  }
  getPaneComposites(viewContainerLocation) {
    return this.getPartByLocation(viewContainerLocation).getPaneComposites();
  }
  getPinnedPaneCompositeIds(viewContainerLocation) {
    return this.getSelectorPartByLocation(viewContainerLocation).getPinnedPaneCompositeIds();
  }
  getVisiblePaneCompositeIds(viewContainerLocation) {
    return this.getSelectorPartByLocation(viewContainerLocation).getVisiblePaneCompositeIds();
  }
  getProgressIndicator(id, viewContainerLocation) {
    return this.getPartByLocation(viewContainerLocation).getProgressIndicator(id);
  }
  hideActivePaneComposite(viewContainerLocation) {
    this.getPartByLocation(viewContainerLocation).hideActivePaneComposite();
  }
  getLastActivePaneCompositeId(viewContainerLocation) {
    return this.getPartByLocation(viewContainerLocation).getLastActivePaneCompositeId();
  }
  showActivity(id, viewContainerLocation, badge, clazz, priority) {
    return this.getSelectorPartByLocation(viewContainerLocation).showActivity(id, badge, clazz, priority);
  }
  getPartByLocation(viewContainerLocation) {
    return assertIsDefined(this.paneCompositeParts.get(viewContainerLocation));
  }
  getSelectorPartByLocation(viewContainerLocation) {
    return assertIsDefined(this.paneCompositeSelectorParts.get(viewContainerLocation));
  }
};
PaneCompositeParts = __decorate([
  __param(0, IInstantiationService)
], PaneCompositeParts);
var css$g = '.monaco-workbench .workbench-hover{background:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);border-radius:3px;box-shadow:0 2px 8px var(--vscode-widget-shadow);color:var(--vscode-editorHoverWidget-foreground);font-size:13px;line-height:19px;max-width:700px;overflow:hidden;position:relative;z-index:40}.monaco-workbench .workbench-hover hr{border-bottom:none}.monaco-workbench .workbench-hover:not(.skip-fade-in){animation:fadein .1s linear}.monaco-workbench .workbench-hover.compact{font-size:12px}.monaco-workbench .workbench-hover.compact .hover-contents{padding:2px 8px}.monaco-workbench .workbench-hover-container.locked .workbench-hover{outline:1px solid var(--vscode-editorHoverWidget-border)}.monaco-workbench .workbench-hover-container.locked .workbench-hover:focus,.monaco-workbench .workbench-hover-lock:focus{outline:1px solid var(--vscode-focusBorder)}.monaco-workbench .workbench-hover-container.locked .workbench-hover-lock:hover{background:var(--vscode-toolbar-hoverBackground)}.monaco-workbench .workbench-hover-pointer{pointer-events:none;position:absolute;z-index:41}.monaco-workbench .workbench-hover-pointer:after{background-color:var(--vscode-editorHoverWidget-background);border-bottom:1px solid var(--vscode-editorHoverWidget-border);border-right:1px solid var(--vscode-editorHoverWidget-border);content:"";height:5px;position:absolute;width:5px}.monaco-workbench .locked .workbench-hover-pointer:after{border-bottom-width:2px;border-right-width:2px;height:4px;width:4px}.monaco-workbench .workbench-hover-pointer.left{left:-3px}.monaco-workbench .workbench-hover-pointer.right{right:3px}.monaco-workbench .workbench-hover-pointer.top{top:-3px}.monaco-workbench .workbench-hover-pointer.bottom{bottom:3px}.monaco-workbench .workbench-hover-pointer.left:after{transform:rotate(135deg)}.monaco-workbench .workbench-hover-pointer.right:after{transform:rotate(315deg)}.monaco-workbench .workbench-hover-pointer.top:after{transform:rotate(225deg)}.monaco-workbench .workbench-hover-pointer.bottom:after{transform:rotate(45deg)}.monaco-workbench .workbench-hover a{color:var(--vscode-textLink-foreground)}.monaco-workbench .workbench-hover a:focus{outline:1px solid;outline-color:var(--vscode-focusBorder);outline-offset:-1px;text-decoration:underline}.monaco-workbench .workbench-hover a:active,.monaco-workbench .workbench-hover a:hover{color:var(--vscode-textLink-activeForeground)}.monaco-workbench .workbench-hover code{background:var(--vscode-textCodeBlock-background)}.monaco-workbench .workbench-hover .hover-row .actions{background:var(--vscode-editorHoverWidget-statusBarBackground)}.monaco-workbench .workbench-hover.right-aligned{left:1px}.monaco-workbench .workbench-hover.right-aligned .hover-row.status-bar .actions{flex-direction:row-reverse}.monaco-workbench .workbench-hover.right-aligned .hover-row.status-bar .actions .action-container{margin-left:16px;margin-right:0}';
n(css$g, {});
const $ = $$2;
let HoverWidget = class HoverWidget2 extends Widget {
  get isDisposed() {
    return this._isDisposed;
  }
  get isMouseIn() {
    return this._lockMouseTracker.isMouseIn;
  }
  get domNode() {
    return this._hover.containerDomNode;
  }
  get onDispose() {
    return this._onDispose.event;
  }
  get onRequestLayout() {
    return this._onRequestLayout.event;
  }
  get anchor() {
    return this._hoverPosition === 2 ? 0 : 1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(value) {
    if (this._isLocked === value) {
      return;
    }
    this._isLocked = value;
    this._hoverContainer.classList.toggle("locked", this._isLocked);
  }
  constructor(options, _keybindingService, _configurationService, _openerService, _instantiationService) {
    super();
    this._keybindingService = _keybindingService;
    this._configurationService = _configurationService;
    this._openerService = _openerService;
    this._instantiationService = _instantiationService;
    this._messageListeners = new DisposableStore();
    this._isDisposed = false;
    this._forcePosition = false;
    this._x = 0;
    this._y = 0;
    this._isLocked = false;
    this._enableFocusTraps = false;
    this._addedFocusTrap = false;
    this._onDispose = this._register(new Emitter());
    this._onRequestLayout = this._register(new Emitter());
    this._linkHandler = options.linkHandler || ((url) => {
      return openLinkFromMarkdown(this._openerService, url, isMarkdownString(options.content) ? options.content.isTrusted : void 0);
    });
    this._target = "targetElements" in options.target ? options.target : new ElementHoverTarget(options.target);
    this._hoverPointer = options.showPointer ? $("div.workbench-hover-pointer") : void 0;
    this._hover = this._register(new HoverWidget$1());
    this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn");
    if (options.compact) {
      this._hover.containerDomNode.classList.add("workbench-hover", "compact");
    }
    if (options.skipFadeInAnimation) {
      this._hover.containerDomNode.classList.add("skip-fade-in");
    }
    if (options.additionalClasses) {
      this._hover.containerDomNode.classList.add(...options.additionalClasses);
    }
    if (options.forcePosition) {
      this._forcePosition = true;
    }
    if (options.trapFocus) {
      this._enableFocusTraps = true;
    }
    this._hoverPosition = options.hoverPosition ?? 3;
    this.onmousedown(this._hover.containerDomNode, (e) => e.stopPropagation());
    this.onkeydown(this._hover.containerDomNode, (e) => {
      if (e.equals(9)) {
        this.dispose();
      }
    });
    this._register(addDisposableListener(window, "blur", () => this.dispose()));
    const rowElement = $("div.hover-row.markdown-hover");
    const contentsElement = $("div.hover-contents");
    if (typeof options.content === "string") {
      contentsElement.textContent = options.content;
      contentsElement.style.whiteSpace = "pre-wrap";
    } else if (options.content instanceof HTMLElement) {
      contentsElement.appendChild(options.content);
      contentsElement.classList.add("html-hover-contents");
    } else {
      const markdown = options.content;
      const mdRenderer = this._instantiationService.createInstance(MarkdownRenderer, { codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || EDITOR_FONT_DEFAULTS.fontFamily });
      const { element } = mdRenderer.render(markdown, {
        actionHandler: {
          callback: (content) => this._linkHandler(content),
          disposables: this._messageListeners
        },
        asyncRenderCallback: () => {
          contentsElement.classList.add("code-hover-contents");
          this.layout();
          this._onRequestLayout.fire();
        }
      });
      contentsElement.appendChild(element);
    }
    rowElement.appendChild(contentsElement);
    this._hover.contentsDomNode.appendChild(rowElement);
    if (options.actions && options.actions.length > 0) {
      const statusBarElement = $("div.hover-row.status-bar");
      const actionsElement = $("div.actions");
      options.actions.forEach((action) => {
        const keybinding = this._keybindingService.lookupKeybinding(action.commandId);
        const keybindingLabel = keybinding ? keybinding.getLabel() : null;
        HoverAction.render(actionsElement, {
          label: action.label,
          commandId: action.commandId,
          run: (e) => {
            action.run(e);
            this.dispose();
          },
          iconClass: action.iconClass
        }, keybindingLabel);
      });
      statusBarElement.appendChild(actionsElement);
      this._hover.containerDomNode.appendChild(statusBarElement);
    }
    this._hoverContainer = $("div.workbench-hover-container");
    if (this._hoverPointer) {
      this._hoverContainer.appendChild(this._hoverPointer);
    }
    this._hoverContainer.appendChild(this._hover.containerDomNode);
    let hideOnHover;
    if (options.actions && options.actions.length > 0) {
      hideOnHover = false;
    } else {
      if (options.hideOnHover === void 0) {
        hideOnHover = typeof options.content === "string" || isMarkdownString(options.content) && !options.content.value.includes("](") && !options.content.value.includes("</a>");
      } else {
        hideOnHover = options.hideOnHover;
      }
    }
    if (hideOnHover && options.showHoverHint) {
      const statusBarElement = $("div.hover-row.status-bar");
      const infoElement = $("div.info");
      infoElement.textContent = localize("hoverhint", "Hold {0} key to mouse over", isMacintosh ? "Option" : "Alt");
      statusBarElement.appendChild(infoElement);
      this._hover.containerDomNode.appendChild(statusBarElement);
    }
    const mouseTrackerTargets = [...this._target.targetElements];
    if (!hideOnHover) {
      mouseTrackerTargets.push(this._hoverContainer);
    }
    const mouseTracker = this._register(new CompositeMouseTracker(mouseTrackerTargets));
    this._register(mouseTracker.onMouseOut(() => {
      if (!this._isLocked) {
        this.dispose();
      }
    }));
    if (hideOnHover) {
      const mouseTracker2Targets = [...this._target.targetElements, this._hoverContainer];
      this._lockMouseTracker = this._register(new CompositeMouseTracker(mouseTracker2Targets));
      this._register(this._lockMouseTracker.onMouseOut(() => {
        if (!this._isLocked) {
          this.dispose();
        }
      }));
    } else {
      this._lockMouseTracker = mouseTracker;
    }
  }
  addFocusTrap() {
    if (!this._enableFocusTraps || this._addedFocusTrap) {
      return;
    }
    this._addedFocusTrap = true;
    const firstContainerFocusElement = this._hover.containerDomNode;
    const lastContainerFocusElement = this.findLastFocusableChild(this._hover.containerDomNode);
    if (lastContainerFocusElement) {
      const beforeContainerFocusElement = prepend(this._hoverContainer, $("div"));
      const afterContainerFocusElement = append(this._hoverContainer, $("div"));
      beforeContainerFocusElement.tabIndex = 0;
      afterContainerFocusElement.tabIndex = 0;
      this._register(addDisposableListener(afterContainerFocusElement, "focus", (e) => {
        firstContainerFocusElement.focus();
        e.preventDefault();
      }));
      this._register(addDisposableListener(beforeContainerFocusElement, "focus", (e) => {
        lastContainerFocusElement.focus();
        e.preventDefault();
      }));
    }
  }
  findLastFocusableChild(root) {
    if (root.hasChildNodes()) {
      for (let i = 0; i < root.childNodes.length; i++) {
        const node = root.childNodes.item(root.childNodes.length - i - 1);
        if (node.nodeType === node.ELEMENT_NODE) {
          const parsedNode = node;
          if (typeof parsedNode.tabIndex === "number" && parsedNode.tabIndex >= 0) {
            return parsedNode;
          }
        }
        const recursivelyFoundElement = this.findLastFocusableChild(node);
        if (recursivelyFoundElement) {
          return recursivelyFoundElement;
        }
      }
    }
    return void 0;
  }
  render(container) {
    container.appendChild(this._hoverContainer);
    this.layout();
    this.addFocusTrap();
  }
  layout() {
    this._hover.containerDomNode.classList.remove("right-aligned");
    this._hover.contentsDomNode.style.maxHeight = "";
    const getZoomAccountedBoundingClientRect = (e) => {
      const zoom = getDomNodeZoomLevel(e);
      const boundingRect = e.getBoundingClientRect();
      return {
        top: boundingRect.top * zoom,
        bottom: boundingRect.bottom * zoom,
        right: boundingRect.right * zoom,
        left: boundingRect.left * zoom
      };
    };
    const targetBounds = this._target.targetElements.map((e) => getZoomAccountedBoundingClientRect(e));
    const top = Math.min(...targetBounds.map((e) => e.top));
    const right = Math.max(...targetBounds.map((e) => e.right));
    const bottom = Math.max(...targetBounds.map((e) => e.bottom));
    const left = Math.min(...targetBounds.map((e) => e.left));
    const width = right - left;
    const height = bottom - top;
    const targetRect = {
      top,
      right,
      bottom,
      left,
      width,
      height,
      center: {
        x: left + width / 2,
        y: top + height / 2
      }
    };
    this.adjustHorizontalHoverPosition(targetRect);
    this.adjustVerticalHoverPosition(targetRect);
    this.adjustHoverMaxHeight(targetRect);
    this._hoverContainer.style.padding = "";
    this._hoverContainer.style.margin = "";
    if (this._hoverPointer) {
      switch (this._hoverPosition) {
        case 1:
          targetRect.left += 3;
          targetRect.right += 3;
          this._hoverContainer.style.paddingLeft = `${3}px`;
          this._hoverContainer.style.marginLeft = `${-3}px`;
          break;
        case 0:
          targetRect.left -= 3;
          targetRect.right -= 3;
          this._hoverContainer.style.paddingRight = `${3}px`;
          this._hoverContainer.style.marginRight = `${-3}px`;
          break;
        case 2:
          targetRect.top += 3;
          targetRect.bottom += 3;
          this._hoverContainer.style.paddingTop = `${3}px`;
          this._hoverContainer.style.marginTop = `${-3}px`;
          break;
        case 3:
          targetRect.top -= 3;
          targetRect.bottom -= 3;
          this._hoverContainer.style.paddingBottom = `${3}px`;
          this._hoverContainer.style.marginBottom = `${-3}px`;
          break;
      }
      targetRect.center.x = targetRect.left + width / 2;
      targetRect.center.y = targetRect.top + height / 2;
    }
    this.computeXCordinate(targetRect);
    this.computeYCordinate(targetRect);
    if (this._hoverPointer) {
      this._hoverPointer.classList.remove("top");
      this._hoverPointer.classList.remove("left");
      this._hoverPointer.classList.remove("right");
      this._hoverPointer.classList.remove("bottom");
      this.setHoverPointerPosition(targetRect);
    }
    this._hover.onContentsChanged();
  }
  computeXCordinate(target) {
    const hoverWidth = this._hover.containerDomNode.clientWidth + 2;
    if (this._target.x !== void 0) {
      this._x = this._target.x;
    } else if (this._hoverPosition === 1) {
      this._x = target.right;
    } else if (this._hoverPosition === 0) {
      this._x = target.left - hoverWidth;
    } else {
      if (this._hoverPointer) {
        this._x = target.center.x - this._hover.containerDomNode.clientWidth / 2;
      } else {
        this._x = target.left;
      }
      if (this._x + hoverWidth >= document.documentElement.clientWidth) {
        this._hover.containerDomNode.classList.add("right-aligned");
        this._x = Math.max(document.documentElement.clientWidth - hoverWidth - 2, document.documentElement.clientLeft);
      }
    }
    if (this._x < document.documentElement.clientLeft) {
      this._x = target.left + 2;
    }
  }
  computeYCordinate(target) {
    if (this._target.y !== void 0) {
      this._y = this._target.y;
    } else if (this._hoverPosition === 3) {
      this._y = target.top;
    } else if (this._hoverPosition === 2) {
      this._y = target.bottom - 2;
    } else {
      if (this._hoverPointer) {
        this._y = target.center.y + this._hover.containerDomNode.clientHeight / 2;
      } else {
        this._y = target.bottom;
      }
    }
    if (this._y > window.innerHeight) {
      this._y = target.bottom;
    }
  }
  adjustHorizontalHoverPosition(target) {
    if (this._target.x !== void 0) {
      return;
    }
    if (this._forcePosition) {
      const padding = (this._hoverPointer ? 3 : 0) + 2;
      if (this._hoverPosition === 1) {
        this._hover.containerDomNode.style.maxWidth = `${document.documentElement.clientWidth - target.right - padding}px`;
      } else if (this._hoverPosition === 0) {
        this._hover.containerDomNode.style.maxWidth = `${target.left - padding}px`;
      }
      return;
    }
    if (this._hoverPosition === 1) {
      const roomOnRight = document.documentElement.clientWidth - target.right;
      if (roomOnRight < this._hover.containerDomNode.clientWidth) {
        const roomOnLeft = target.left;
        if (roomOnLeft >= this._hover.containerDomNode.clientWidth) {
          this._hoverPosition = 0;
        } else {
          this._hoverPosition = 2;
        }
      }
    } else if (this._hoverPosition === 0) {
      const roomOnLeft = target.left;
      if (roomOnLeft < this._hover.containerDomNode.clientWidth) {
        const roomOnRight = document.documentElement.clientWidth - target.right;
        if (roomOnRight >= this._hover.containerDomNode.clientWidth) {
          this._hoverPosition = 1;
        } else {
          this._hoverPosition = 2;
        }
      }
      if (target.left - this._hover.containerDomNode.clientWidth <= document.documentElement.clientLeft) {
        this._hoverPosition = 1;
      }
    }
  }
  adjustVerticalHoverPosition(target) {
    if (this._target.y !== void 0 || this._forcePosition) {
      return;
    }
    if (this._hoverPosition === 3) {
      if (target.top - this._hover.containerDomNode.clientHeight < 0) {
        this._hoverPosition = 2;
      }
    } else if (this._hoverPosition === 2) {
      if (target.bottom + this._hover.containerDomNode.clientHeight > window.innerHeight) {
        this._hoverPosition = 3;
      }
    }
  }
  adjustHoverMaxHeight(target) {
    let maxHeight = window.innerHeight / 2;
    if (this._forcePosition) {
      const padding = (this._hoverPointer ? 3 : 0) + 2;
      if (this._hoverPosition === 3) {
        maxHeight = Math.min(maxHeight, target.top - padding);
      } else if (this._hoverPosition === 2) {
        maxHeight = Math.min(maxHeight, window.innerHeight - target.bottom - padding);
      }
    }
    this._hover.containerDomNode.style.maxHeight = `${maxHeight}px`;
    if (this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
      const extraRightPadding = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
      if (this._hover.contentsDomNode.style.paddingRight !== extraRightPadding) {
        this._hover.contentsDomNode.style.paddingRight = extraRightPadding;
      }
    }
  }
  setHoverPointerPosition(target) {
    if (!this._hoverPointer) {
      return;
    }
    switch (this._hoverPosition) {
      case 0:
      case 1: {
        this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
        const hoverHeight = this._hover.containerDomNode.clientHeight;
        if (hoverHeight > target.height) {
          this._hoverPointer.style.top = `${target.center.y - (this._y - hoverHeight) - 3}px`;
        } else {
          this._hoverPointer.style.top = `${Math.round(hoverHeight / 2) - 3}px`;
        }
        break;
      }
      case 3:
      case 2: {
        this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
        const hoverWidth = this._hover.containerDomNode.clientWidth;
        let pointerLeftPosition = Math.round(hoverWidth / 2) - 3;
        const pointerX = this._x + pointerLeftPosition;
        if (pointerX < target.left || pointerX > target.right) {
          pointerLeftPosition = target.center.x - this._x - 3;
        }
        this._hoverPointer.style.left = `${pointerLeftPosition}px`;
        break;
      }
    }
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  hide() {
    this.dispose();
  }
  dispose() {
    if (!this._isDisposed) {
      this._onDispose.fire();
      this._hoverContainer.remove();
      this._messageListeners.dispose();
      this._target.dispose();
      super.dispose();
    }
    this._isDisposed = true;
  }
};
HoverWidget = __decorate([
  __param(1, IKeybindingService),
  __param(2, IConfigurationService),
  __param(3, IOpenerService),
  __param(4, IInstantiationService)
], HoverWidget);
class CompositeMouseTracker extends Widget {
  get onMouseOut() {
    return this._onMouseOut.event;
  }
  get isMouseIn() {
    return this._isMouseIn;
  }
  constructor(_elements) {
    super();
    this._elements = _elements;
    this._isMouseIn = true;
    this._onMouseOut = this._register(new Emitter());
    this._elements.forEach((n2) => this.onmouseover(n2, () => this._onTargetMouseOver()));
    this._elements.forEach((n2) => this.onmouseleave(n2, () => this._onTargetMouseLeave()));
  }
  _onTargetMouseOver() {
    this._isMouseIn = true;
    this._clearEvaluateMouseStateTimeout();
  }
  _onTargetMouseLeave() {
    this._isMouseIn = false;
    this._evaluateMouseState();
  }
  _evaluateMouseState() {
    this._clearEvaluateMouseStateTimeout();
    this._mouseTimeout = window.setTimeout(() => this._fireIfMouseOutside(), 0);
  }
  _clearEvaluateMouseStateTimeout() {
    if (this._mouseTimeout) {
      clearTimeout(this._mouseTimeout);
      this._mouseTimeout = void 0;
    }
  }
  _fireIfMouseOutside() {
    if (!this._isMouseIn) {
      this._onMouseOut.fire();
    }
  }
}
class ElementHoverTarget {
  constructor(_element) {
    this._element = _element;
    this.targetElements = [this._element];
  }
  dispose() {
  }
}
let HoverService = class HoverService2 {
  constructor(_instantiationService, _contextViewService, contextMenuService, _keybindingService, _accessibilityService) {
    this._instantiationService = _instantiationService;
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._accessibilityService = _accessibilityService;
    contextMenuService.onDidShowContextMenu(() => this.hideHover());
  }
  showHover(options, focus, skipLastFocusedUpdate) {
    if (getHoverOptionsIdentity(this._currentHoverOptions) === getHoverOptionsIdentity(options)) {
      return void 0;
    }
    this._currentHoverOptions = options;
    this._lastHoverOptions = options;
    const trapFocus = options.trapFocus || this._accessibilityService.isScreenReaderOptimized();
    if (!skipLastFocusedUpdate) {
      if (trapFocus && document.activeElement) {
        this._lastFocusedElementBeforeOpen = document.activeElement;
      } else {
        this._lastFocusedElementBeforeOpen = void 0;
      }
    }
    const hoverDisposables = new DisposableStore();
    const hover = this._instantiationService.createInstance(HoverWidget, options);
    hover.onDispose(() => {
      var _a2;
      (_a2 = this._lastFocusedElementBeforeOpen) == null ? void 0 : _a2.focus();
      if (this._currentHoverOptions === options) {
        this._currentHoverOptions = void 0;
      }
      hoverDisposables.dispose();
    });
    const provider = this._contextViewService;
    provider.showContextView(new HoverContextViewDelegate(hover, focus), options.container);
    hover.onRequestLayout(() => provider.layout());
    if ("targetElements" in options.target) {
      for (const element of options.target.targetElements) {
        hoverDisposables.add(addDisposableListener(element, EventType.CLICK, () => this.hideHover()));
      }
    } else {
      hoverDisposables.add(addDisposableListener(options.target, EventType.CLICK, () => this.hideHover()));
    }
    const focusedElement = document.activeElement;
    if (focusedElement) {
      hoverDisposables.add(addDisposableListener(focusedElement, EventType.KEY_DOWN, (e) => this._keyDown(e, hover, !!options.hideOnKeyDown)));
      hoverDisposables.add(addDisposableListener(document, EventType.KEY_DOWN, (e) => this._keyDown(e, hover, !!options.hideOnKeyDown)));
      hoverDisposables.add(addDisposableListener(focusedElement, EventType.KEY_UP, (e) => this._keyUp(e, hover)));
      hoverDisposables.add(addDisposableListener(document, EventType.KEY_UP, (e) => this._keyUp(e, hover)));
    }
    if ("IntersectionObserver" in window) {
      const observer = new IntersectionObserver((e) => this._intersectionChange(e, hover), { threshold: 0 });
      const firstTargetElement = "targetElements" in options.target ? options.target.targetElements[0] : options.target;
      observer.observe(firstTargetElement);
      hoverDisposables.add(toDisposable(() => observer.disconnect()));
    }
    this._currentHover = hover;
    return hover;
  }
  hideHover() {
    var _a2;
    if (((_a2 = this._currentHover) == null ? void 0 : _a2.isLocked) || !this._currentHoverOptions) {
      return;
    }
    this._currentHover = void 0;
    this._currentHoverOptions = void 0;
    this._contextViewService.hideContextView();
  }
  _intersectionChange(entries, hover) {
    const entry = entries[entries.length - 1];
    if (!entry.isIntersecting) {
      hover.dispose();
    }
  }
  showAndFocusLastHover() {
    if (!this._lastHoverOptions) {
      return;
    }
    this.showHover(this._lastHoverOptions, true, true);
  }
  _keyDown(e, hover, hideOnKeyDown) {
    var _a2, _b2;
    if (e.key === "Alt") {
      hover.isLocked = true;
      return;
    }
    const event = new StandardKeyboardEvent(e);
    const keybinding = this._keybindingService.resolveKeyboardEvent(event);
    if (keybinding.getSingleModifierDispatchChords().some((value) => !!value) || this._keybindingService.softDispatch(event, event.target).kind !== 0) {
      return;
    }
    if (hideOnKeyDown && (!((_a2 = this._currentHoverOptions) == null ? void 0 : _a2.trapFocus) || e.key !== "Tab")) {
      this.hideHover();
      (_b2 = this._lastFocusedElementBeforeOpen) == null ? void 0 : _b2.focus();
    }
  }
  _keyUp(e, hover) {
    var _a2;
    if (e.key === "Alt") {
      hover.isLocked = false;
      if (!hover.isMouseIn) {
        this.hideHover();
        (_a2 = this._lastFocusedElementBeforeOpen) == null ? void 0 : _a2.focus();
      }
    }
  }
};
HoverService = __decorate([
  __param(0, IInstantiationService),
  __param(1, IContextViewService),
  __param(2, IContextMenuService),
  __param(3, IKeybindingService),
  __param(4, IAccessibilityService)
], HoverService);
function getHoverOptionsIdentity(options) {
  if (options === void 0) {
    return void 0;
  }
  return (options == null ? void 0 : options.id) ?? options;
}
class HoverContextViewDelegate {
  get anchorPosition() {
    return this._hover.anchor;
  }
  constructor(_hover, _focus = false) {
    this._hover = _hover;
    this._focus = _focus;
  }
  render(container) {
    this._hover.render(container);
    if (this._focus) {
      this._hover.focus();
    }
    return this._hover;
  }
  getAnchor() {
    return {
      x: this._hover.x,
      y: this._hover.y
    };
  }
  layout() {
    this._hover.layout();
  }
}
registerThemingParticipant((theme, collector) => {
  const hoverBorder = theme.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
  }
});
const UNDO_REDO_SOURCE = new UndoRedoSource();
let ExplorerService = (_i = class {
  constructor(fileService, configurationService, contextService, clipboardService, editorService, uriIdentityService, bulkEditService, progressService, hostService, filesConfigurationService) {
    this.fileService = fileService;
    this.configurationService = configurationService;
    this.contextService = contextService;
    this.clipboardService = clipboardService;
    this.editorService = editorService;
    this.uriIdentityService = uriIdentityService;
    this.bulkEditService = bulkEditService;
    this.progressService = progressService;
    this.filesConfigurationService = filesConfigurationService;
    this.disposables = new DisposableStore();
    this.fileChangeEvents = [];
    this.config = this.configurationService.getValue("explorer");
    this.model = new ExplorerModel(
      this.contextService,
      this.uriIdentityService,
      this.fileService,
      this.configurationService,
      this.filesConfigurationService
    );
    this.disposables.add(this.model);
    this.disposables.add(this.fileService.onDidRunOperation((e) => this.onDidRunOperation(e)));
    this.onFileChangesScheduler = new RunOnceScheduler(async () => {
      const events = this.fileChangeEvents;
      this.fileChangeEvents = [];
      const types = [2];
      if (this.config.sortOrder === "modified") {
        types.push(0);
      }
      let shouldRefresh = false;
      this.roots.forEach((r) => {
        if (this.view && !shouldRefresh) {
          shouldRefresh = doesFileEventAffect(r, this.view, events, types);
        }
      });
      events.forEach((e) => {
        if (!shouldRefresh) {
          for (const resource of e.rawAdded) {
            const parent = this.model.findClosest(dirname(resource));
            if (parent && !parent.getChild(basename(resource))) {
              shouldRefresh = true;
              break;
            }
          }
        }
      });
      if (shouldRefresh) {
        await this.refresh(false);
      }
    }, _i.EXPLORER_FILE_CHANGES_REACT_DELAY);
    this.disposables.add(this.fileService.onDidFilesChange((e) => {
      this.fileChangeEvents.push(e);
      if (this.editable) {
        return;
      }
      if (!this.onFileChangesScheduler.isScheduled()) {
        this.onFileChangesScheduler.schedule();
      }
    }));
    this.disposables.add(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e)));
    this.disposables.add(Event.any(this.fileService.onDidChangeFileSystemProviderRegistrations, this.fileService.onDidChangeFileSystemProviderCapabilities)(async (e) => {
      let affected = false;
      this.model.roots.forEach((r) => {
        if (r.resource.scheme === e.scheme) {
          affected = true;
          r.forgetChildren();
        }
      });
      if (affected) {
        if (this.view) {
          await this.view.setTreeInput();
        }
      }
    }));
    this.disposables.add(this.model.onDidChangeRoots(() => {
      var _a2;
      (_a2 = this.view) == null ? void 0 : _a2.setTreeInput();
    }));
    this.disposables.add(hostService.onDidChangeFocus((hasFocus) => {
      if (hasFocus) {
        this.refresh(false);
      }
    }));
    this.revealExcludeMatcher = new ResourceGlobMatcher(
      (uri) => getRevealExcludes(configurationService.getValue({ resource: uri })),
      (event) => event.affectsConfiguration("explorer.autoRevealExclude"),
      contextService,
      configurationService
    );
    this.disposables.add(this.revealExcludeMatcher);
  }
  get roots() {
    return this.model.roots;
  }
  get sortOrderConfiguration() {
    return {
      sortOrder: this.config.sortOrder,
      lexicographicOptions: this.config.sortOrderLexicographicOptions
    };
  }
  registerView(contextProvider) {
    this.view = contextProvider;
  }
  getContext(respectMultiSelection, ignoreNestedChildren = false) {
    if (!this.view) {
      return [];
    }
    const items = new Set(this.view.getContext(respectMultiSelection));
    items.forEach((item) => {
      var _a2;
      try {
        if (respectMultiSelection && !ignoreNestedChildren && ((_a2 = this.view) == null ? void 0 : _a2.isItemCollapsed(item)) && item.nestedChildren) {
          for (const child of item.nestedChildren) {
            items.add(child);
          }
        }
      } catch {
        return;
      }
    });
    return [...items];
  }
  async applyBulkEdit(edit, options) {
    const cancellationTokenSource = new CancellationTokenSource();
    const promise = this.progressService.withProgress({
      location: options.progressLocation || 10,
      title: options.progressLabel,
      cancellable: edit.length > 1,
      delay: 500
    }, async (progress) => {
      await this.bulkEditService.apply(edit, {
        undoRedoSource: UNDO_REDO_SOURCE,
        label: options.undoLabel,
        code: "undoredo.explorerOperation",
        progress,
        token: cancellationTokenSource.token,
        confirmBeforeUndo: options.confirmBeforeUndo
      });
    }, () => cancellationTokenSource.cancel());
    await this.progressService.withProgress({ location: 1, delay: 500 }, () => promise);
    cancellationTokenSource.dispose();
  }
  hasViewFocus() {
    return !!this.view && this.view.hasFocus();
  }
  findClosest(resource) {
    return this.model.findClosest(resource);
  }
  findClosestRoot(resource) {
    const parentRoots = this.model.roots.filter((r) => this.uriIdentityService.extUri.isEqualOrParent(resource, r.resource)).sort((first, second) => second.resource.path.length - first.resource.path.length);
    return parentRoots.length ? parentRoots[0] : null;
  }
  async setEditable(stat, data) {
    if (!this.view) {
      return;
    }
    if (!data) {
      this.editable = void 0;
    } else {
      this.editable = { stat, data };
    }
    const isEditing = this.isEditable(stat);
    await this.view.setEditable(stat, isEditing);
    if (!this.editable && this.fileChangeEvents.length && !this.onFileChangesScheduler.isScheduled()) {
      this.onFileChangesScheduler.schedule();
    }
  }
  async setToCopy(items, cut) {
    var _a2;
    const previouslyCutItems = this.cutItems;
    this.cutItems = cut ? items : void 0;
    await this.clipboardService.writeResources(items.map((s) => s.resource));
    (_a2 = this.view) == null ? void 0 : _a2.itemsCopied(items, cut, previouslyCutItems);
  }
  isCut(item) {
    return !!this.cutItems && this.cutItems.some((i) => this.uriIdentityService.extUri.isEqual(i.resource, item.resource));
  }
  getEditable() {
    return this.editable;
  }
  getEditableData(stat) {
    return this.editable && this.editable.stat === stat ? this.editable.data : void 0;
  }
  isEditable(stat) {
    return !!this.editable && (this.editable.stat === stat || !stat);
  }
  async select(resource, reveal) {
    if (!this.view) {
      return;
    }
    const ignoreRevealExcludes = reveal === "force";
    const fileStat = this.findClosest(resource);
    if (fileStat) {
      if (!this.shouldAutoRevealItem(fileStat, ignoreRevealExcludes)) {
        return;
      }
      await this.view.selectResource(fileStat.resource, reveal);
      return Promise.resolve(void 0);
    }
    const options = { resolveTo: [resource], resolveMetadata: this.config.sortOrder === "modified" };
    const root = this.findClosestRoot(resource);
    if (!root) {
      return void 0;
    }
    try {
      const stat = await this.fileService.resolve(root.resource, options);
      const modelStat = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, stat, void 0, options.resolveTo);
      ExplorerItem.mergeLocalWithDisk(modelStat, root);
      const item = root.find(resource);
      await this.view.refresh(true, root);
      if (item && !this.shouldAutoRevealItem(item, ignoreRevealExcludes)) {
        return;
      }
      await this.view.selectResource(item ? item.resource : void 0, reveal);
    } catch (error) {
      root.error = error;
      await this.view.refresh(false, root);
    }
  }
  async refresh(reveal = true) {
    var _a2;
    this.model.roots.forEach((r) => r.forgetChildren());
    if (this.view) {
      await this.view.refresh(true);
      const resource = (_a2 = this.editorService.activeEditor) == null ? void 0 : _a2.resource;
      const autoReveal = this.configurationService.getValue().explorer.autoReveal;
      if (reveal && resource && autoReveal) {
        this.select(resource, autoReveal);
      }
    }
  }
  async onDidRunOperation(e) {
    const shouldDeepRefresh = this.config.fileNesting.enabled;
    if (e.isOperation(0) || e.isOperation(3)) {
      const addedElement = e.target;
      const parentResource = dirname(addedElement.resource);
      const parents = this.model.findAll(parentResource);
      if (parents.length) {
        await Promise.all(parents.map(async (p) => {
          var _a2;
          const resolveMetadata = this.config.sortOrder === `modified`;
          if (!p.isDirectoryResolved) {
            const stat = await this.fileService.resolve(p.resource, { resolveMetadata });
            if (stat) {
              const modelStat = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, stat, p.parent);
              ExplorerItem.mergeLocalWithDisk(modelStat, p);
            }
          }
          const childElement = ExplorerItem.create(this.fileService, this.configurationService, this.filesConfigurationService, addedElement, p.parent);
          p.removeChild(childElement);
          p.addChild(childElement);
          await ((_a2 = this.view) == null ? void 0 : _a2.refresh(shouldDeepRefresh, p));
        }));
      }
    } else if (e.isOperation(2)) {
      const oldResource = e.resource;
      const newElement = e.target;
      const oldParentResource = dirname(oldResource);
      const newParentResource = dirname(newElement.resource);
      const modelElements = this.model.findAll(oldResource);
      const sameParentMove = modelElements.every((e2) => !e2.nestedParent) && this.uriIdentityService.extUri.isEqual(oldParentResource, newParentResource);
      if (sameParentMove) {
        await Promise.all(modelElements.map(async (modelElement) => {
          var _a2;
          modelElement.rename(newElement);
          await ((_a2 = this.view) == null ? void 0 : _a2.refresh(shouldDeepRefresh, modelElement.parent));
        }));
      } else {
        const newParents = this.model.findAll(newParentResource);
        if (newParents.length && modelElements.length) {
          await Promise.all(modelElements.map(async (modelElement, index) => {
            var _a2, _b2, _c2;
            const oldParent = modelElement.parent;
            const oldNestedParent = modelElement.nestedParent;
            modelElement.move(newParents[index]);
            if (oldNestedParent) {
              await ((_a2 = this.view) == null ? void 0 : _a2.refresh(false, oldNestedParent));
            }
            await ((_b2 = this.view) == null ? void 0 : _b2.refresh(false, oldParent));
            await ((_c2 = this.view) == null ? void 0 : _c2.refresh(shouldDeepRefresh, newParents[index]));
          }));
        }
      }
    } else if (e.isOperation(1)) {
      const modelElements = this.model.findAll(e.resource);
      await Promise.all(modelElements.map(async (modelElement) => {
        var _a2, _b2;
        if (modelElement.parent) {
          const parent = modelElement.parent;
          parent.removeChild(modelElement);
          const oldNestedParent = modelElement.nestedParent;
          if (oldNestedParent) {
            oldNestedParent.removeChild(modelElement);
            await ((_a2 = this.view) == null ? void 0 : _a2.refresh(false, oldNestedParent));
          }
          await ((_b2 = this.view) == null ? void 0 : _b2.refresh(shouldDeepRefresh, parent));
        }
      }));
    }
  }
  shouldAutoRevealItem(item, ignore) {
    if (item === void 0 || ignore) {
      return true;
    }
    if (this.revealExcludeMatcher.matches(item.resource, (name) => !!(item.parent && item.parent.getChild(name)))) {
      return false;
    }
    const root = item.root;
    let currentItem = item.parent;
    while (currentItem !== root) {
      if (currentItem === void 0) {
        return true;
      }
      if (this.revealExcludeMatcher.matches(currentItem.resource)) {
        return false;
      }
      currentItem = currentItem.parent;
    }
    return true;
  }
  async onConfigurationUpdated(event) {
    var _a2, _b2;
    if (!event.affectsConfiguration("explorer")) {
      return;
    }
    let shouldRefresh = false;
    if (event.affectsConfiguration("explorer.fileNesting")) {
      shouldRefresh = true;
    }
    const configuration = this.configurationService.getValue();
    const configSortOrder = ((_a2 = configuration == null ? void 0 : configuration.explorer) == null ? void 0 : _a2.sortOrder) || "default";
    if (this.config.sortOrder !== configSortOrder) {
      shouldRefresh = this.config.sortOrder !== void 0;
    }
    const configLexicographicOptions = ((_b2 = configuration == null ? void 0 : configuration.explorer) == null ? void 0 : _b2.sortOrderLexicographicOptions) || "default";
    if (this.config.sortOrderLexicographicOptions !== configLexicographicOptions) {
      shouldRefresh = shouldRefresh || this.config.sortOrderLexicographicOptions !== void 0;
    }
    this.config = configuration.explorer;
    if (shouldRefresh) {
      await this.refresh();
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}, _i.EXPLORER_FILE_CHANGES_REACT_DELAY = 500, _i);
ExplorerService = __decorate([
  __param(0, IFileService),
  __param(1, IConfigurationService),
  __param(2, IWorkspaceContextService),
  __param(3, IClipboardService),
  __param(4, IEditorService),
  __param(5, IUriIdentityService),
  __param(6, IBulkEditService),
  __param(7, IProgressService),
  __param(8, IHostService),
  __param(9, IFilesConfigurationService)
], ExplorerService);
function doesFileEventAffect(item, view, events, types) {
  for (const [_name, child] of item.children) {
    if (view.isItemVisible(child)) {
      if (events.some((e) => e.contains(child.resource, ...types))) {
        return true;
      }
      if (child.isDirectory && child.isDirectoryResolved) {
        if (doesFileEventAffect(child, view, events, types)) {
          return true;
        }
      }
    }
  }
  return false;
}
function getRevealExcludes(configuration) {
  const revealExcludes = configuration && configuration.explorer && configuration.explorer.autoRevealExclude;
  if (!revealExcludes) {
    return {};
  }
  return revealExcludes;
}
var css$f = ".monaco-grid-view{overflow:hidden;position:relative}.monaco-grid-branch-node,.monaco-grid-view{height:100%;width:100%}";
n(css$f, {});
const defaultStyles = {
  separatorBorder: Color.transparent
};
function orthogonal(orientation) {
  return orientation === 0 ? 1 : 0;
}
class LayoutController {
  constructor(isLayoutEnabled) {
    this.isLayoutEnabled = isLayoutEnabled;
  }
}
function toAbsoluteBoundarySashes(sashes, orientation) {
  if (orientation === 1) {
    return { left: sashes.start, right: sashes.end, top: sashes.orthogonalStart, bottom: sashes.orthogonalEnd };
  } else {
    return { top: sashes.start, bottom: sashes.end, left: sashes.orthogonalStart, right: sashes.orthogonalEnd };
  }
}
function fromAbsoluteBoundarySashes(sashes, orientation) {
  if (orientation === 1) {
    return { start: sashes.left, end: sashes.right, orthogonalStart: sashes.top, orthogonalEnd: sashes.bottom };
  } else {
    return { start: sashes.top, end: sashes.bottom, orthogonalStart: sashes.left, orthogonalEnd: sashes.right };
  }
}
function validateIndex(index, numChildren) {
  if (Math.abs(index) > numChildren) {
    throw new Error("Invalid index");
  }
  return rot(index, numChildren + 1);
}
class BranchNode {
  get size() {
    return this._size;
  }
  get orthogonalSize() {
    return this._orthogonalSize;
  }
  get absoluteOffset() {
    return this._absoluteOffset;
  }
  get absoluteOrthogonalOffset() {
    return this._absoluteOrthogonalOffset;
  }
  get styles() {
    return this._styles;
  }
  get width() {
    return this.orientation === 1 ? this.size : this.orthogonalSize;
  }
  get height() {
    return this.orientation === 1 ? this.orthogonalSize : this.size;
  }
  get top() {
    return this.orientation === 1 ? this._absoluteOffset : this._absoluteOrthogonalOffset;
  }
  get left() {
    return this.orientation === 1 ? this._absoluteOrthogonalOffset : this._absoluteOffset;
  }
  get minimumSize() {
    return this.children.length === 0 ? 0 : Math.max(...this.children.map((c) => c.minimumOrthogonalSize));
  }
  get maximumSize() {
    return Math.min(...this.children.map((c) => c.maximumOrthogonalSize));
  }
  get priority() {
    if (this.children.length === 0) {
      return 0;
    }
    const priorities = this.children.map(
      (c) => typeof c.priority === "undefined" ? 0 : c.priority
    );
    if (priorities.some((p) => p === 2)) {
      return 2;
    } else if (priorities.some((p) => p === 1)) {
      return 1;
    }
    return 0;
  }
  get proportionalLayout() {
    if (this.children.length === 0) {
      return true;
    }
    return this.children.every((c) => c.proportionalLayout);
  }
  get minimumOrthogonalSize() {
    return this.splitview.minimumSize;
  }
  get maximumOrthogonalSize() {
    return this.splitview.maximumSize;
  }
  get minimumWidth() {
    return this.orientation === 1 ? this.minimumOrthogonalSize : this.minimumSize;
  }
  get minimumHeight() {
    return this.orientation === 1 ? this.minimumSize : this.minimumOrthogonalSize;
  }
  get maximumWidth() {
    return this.orientation === 1 ? this.maximumOrthogonalSize : this.maximumSize;
  }
  get maximumHeight() {
    return this.orientation === 1 ? this.maximumSize : this.maximumOrthogonalSize;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set boundarySashes(boundarySashes) {
    if (this._boundarySashes.start === boundarySashes.start && this._boundarySashes.end === boundarySashes.end && this._boundarySashes.orthogonalStart === boundarySashes.orthogonalStart && this._boundarySashes.orthogonalEnd === boundarySashes.orthogonalEnd) {
      return;
    }
    this._boundarySashes = boundarySashes;
    this.splitview.orthogonalStartSash = boundarySashes.orthogonalStart;
    this.splitview.orthogonalEndSash = boundarySashes.orthogonalEnd;
    for (let index = 0; index < this.children.length; index++) {
      const child = this.children[index];
      const first = index === 0;
      const last = index === this.children.length - 1;
      child.boundarySashes = {
        start: boundarySashes.orthogonalStart,
        end: boundarySashes.orthogonalEnd,
        orthogonalStart: first ? boundarySashes.start : child.boundarySashes.orthogonalStart,
        orthogonalEnd: last ? boundarySashes.end : child.boundarySashes.orthogonalEnd
      };
    }
  }
  get edgeSnapping() {
    return this._edgeSnapping;
  }
  set edgeSnapping(edgeSnapping) {
    if (this._edgeSnapping === edgeSnapping) {
      return;
    }
    this._edgeSnapping = edgeSnapping;
    for (const child of this.children) {
      if (child instanceof BranchNode) {
        child.edgeSnapping = edgeSnapping;
      }
    }
    this.updateSplitviewEdgeSnappingEnablement();
  }
  constructor(orientation, layoutController, styles, splitviewProportionalLayout, size2 = 0, orthogonalSize = 0, edgeSnapping = false, childDescriptors) {
    this.orientation = orientation;
    this.layoutController = layoutController;
    this.splitviewProportionalLayout = splitviewProportionalLayout;
    this.children = [];
    this._absoluteOffset = 0;
    this._absoluteOrthogonalOffset = 0;
    this.absoluteOrthogonalSize = 0;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onDidScroll = new Emitter();
    this.onDidScrollDisposable = Disposable.None;
    this.onDidScroll = this._onDidScroll.event;
    this.childrenChangeDisposable = Disposable.None;
    this._onDidSashReset = new Emitter();
    this.onDidSashReset = this._onDidSashReset.event;
    this.splitviewSashResetDisposable = Disposable.None;
    this.childrenSashResetDisposable = Disposable.None;
    this._boundarySashes = {};
    this._edgeSnapping = false;
    this._styles = styles;
    this._size = size2;
    this._orthogonalSize = orthogonalSize;
    this.element = $$2(".monaco-grid-branch-node");
    if (!childDescriptors) {
      this.splitview = new SplitView(
        this.element,
        { orientation, styles, proportionalLayout: splitviewProportionalLayout }
      );
      this.splitview.layout(size2, { orthogonalSize, absoluteOffset: 0, absoluteOrthogonalOffset: 0, absoluteSize: size2, absoluteOrthogonalSize: orthogonalSize });
    } else {
      const descriptor = {
        views: childDescriptors.map((childDescriptor) => {
          return {
            view: childDescriptor.node,
            size: childDescriptor.node.size,
            visible: childDescriptor.node instanceof LeafNode && childDescriptor.visible !== void 0 ? childDescriptor.visible : true
          };
        }),
        size: this.orthogonalSize
      };
      const options = { proportionalLayout: splitviewProportionalLayout, orientation, styles };
      this.children = childDescriptors.map((c) => c.node);
      this.splitview = new SplitView(this.element, { ...options, descriptor });
      this.children.forEach((node, index) => {
        const first = index === 0;
        const last = index === this.children.length;
        node.boundarySashes = {
          start: this.boundarySashes.orthogonalStart,
          end: this.boundarySashes.orthogonalEnd,
          orthogonalStart: first ? this.boundarySashes.start : this.splitview.sashes[index - 1],
          orthogonalEnd: last ? this.boundarySashes.end : this.splitview.sashes[index]
        };
      });
    }
    const onDidSashReset = Event.map(this.splitview.onDidSashReset, (i) => [i]);
    this.splitviewSashResetDisposable = onDidSashReset(this._onDidSashReset.fire, this._onDidSashReset);
    this.updateChildrenEvents();
  }
  style(styles) {
    this._styles = styles;
    this.splitview.style(styles);
    for (const child of this.children) {
      if (child instanceof BranchNode) {
        child.style(styles);
      }
    }
  }
  layout(size2, offset, ctx) {
    if (!this.layoutController.isLayoutEnabled) {
      return;
    }
    if (typeof ctx === "undefined") {
      throw new Error("Invalid state");
    }
    this._size = ctx.orthogonalSize;
    this._orthogonalSize = size2;
    this._absoluteOffset = ctx.absoluteOffset + offset;
    this._absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;
    this.absoluteOrthogonalSize = ctx.absoluteOrthogonalSize;
    this.splitview.layout(ctx.orthogonalSize, {
      orthogonalSize: size2,
      absoluteOffset: this._absoluteOrthogonalOffset,
      absoluteOrthogonalOffset: this._absoluteOffset,
      absoluteSize: ctx.absoluteOrthogonalSize,
      absoluteOrthogonalSize: ctx.absoluteSize
    });
    this.updateSplitviewEdgeSnappingEnablement();
  }
  setVisible(visible) {
    for (const child of this.children) {
      child.setVisible(visible);
    }
  }
  addChild(node, size2, index, skipLayout) {
    index = validateIndex(index, this.children.length);
    this.splitview.addView(node, size2, index, skipLayout);
    this.children.splice(index, 0, node);
    this.updateBoundarySashes();
    this.onDidChildrenChange();
  }
  removeChild(index, sizing) {
    index = validateIndex(index, this.children.length);
    this.splitview.removeView(index, sizing);
    this.children.splice(index, 1);
    this.updateBoundarySashes();
    this.onDidChildrenChange();
  }
  moveChild(from, to) {
    from = validateIndex(from, this.children.length);
    to = validateIndex(to, this.children.length);
    if (from === to) {
      return;
    }
    if (from < to) {
      to -= 1;
    }
    this.splitview.moveView(from, to);
    this.children.splice(to, 0, this.children.splice(from, 1)[0]);
    this.updateBoundarySashes();
    this.onDidChildrenChange();
  }
  swapChildren(from, to) {
    from = validateIndex(from, this.children.length);
    to = validateIndex(to, this.children.length);
    if (from === to) {
      return;
    }
    this.splitview.swapViews(from, to);
    [this.children[from].boundarySashes, this.children[to].boundarySashes] = [this.children[from].boundarySashes, this.children[to].boundarySashes];
    [this.children[from], this.children[to]] = [this.children[to], this.children[from]];
    this.onDidChildrenChange();
  }
  resizeChild(index, size2) {
    index = validateIndex(index, this.children.length);
    this.splitview.resizeView(index, size2);
  }
  isChildSizeMaximized(index) {
    return this.splitview.isViewSizeMaximized(index);
  }
  distributeViewSizes(recursive = false) {
    this.splitview.distributeViewSizes();
    if (recursive) {
      for (const child of this.children) {
        if (child instanceof BranchNode) {
          child.distributeViewSizes(true);
        }
      }
    }
  }
  getChildSize(index) {
    index = validateIndex(index, this.children.length);
    return this.splitview.getViewSize(index);
  }
  isChildVisible(index) {
    index = validateIndex(index, this.children.length);
    return this.splitview.isViewVisible(index);
  }
  setChildVisible(index, visible) {
    index = validateIndex(index, this.children.length);
    if (this.splitview.isViewVisible(index) === visible) {
      return;
    }
    this.splitview.setViewVisible(index, visible);
  }
  getChildCachedVisibleSize(index) {
    index = validateIndex(index, this.children.length);
    return this.splitview.getViewCachedVisibleSize(index);
  }
  updateBoundarySashes() {
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].boundarySashes = {
        start: this.boundarySashes.orthogonalStart,
        end: this.boundarySashes.orthogonalEnd,
        orthogonalStart: i === 0 ? this.boundarySashes.start : this.splitview.sashes[i - 1],
        orthogonalEnd: i === this.children.length - 1 ? this.boundarySashes.end : this.splitview.sashes[i]
      };
    }
  }
  onDidChildrenChange() {
    this.updateChildrenEvents();
    this._onDidChange.fire(void 0);
  }
  updateChildrenEvents() {
    const onDidChildrenChange = Event.map(Event.any(...this.children.map((c) => c.onDidChange)), () => void 0);
    this.childrenChangeDisposable.dispose();
    this.childrenChangeDisposable = onDidChildrenChange(this._onDidChange.fire, this._onDidChange);
    const onDidChildrenSashReset = Event.any(...this.children.map((c, i) => Event.map(c.onDidSashReset, (location) => [i, ...location])));
    this.childrenSashResetDisposable.dispose();
    this.childrenSashResetDisposable = onDidChildrenSashReset(this._onDidSashReset.fire, this._onDidSashReset);
    const onDidScroll = Event.any(Event.signal(this.splitview.onDidScroll), ...this.children.map((c) => c.onDidScroll));
    this.onDidScrollDisposable.dispose();
    this.onDidScrollDisposable = onDidScroll(this._onDidScroll.fire, this._onDidScroll);
  }
  trySet2x2(other) {
    if (this.children.length !== 2 || other.children.length !== 2) {
      return Disposable.None;
    }
    if (this.getChildSize(0) !== other.getChildSize(0)) {
      return Disposable.None;
    }
    const [firstChild, secondChild] = this.children;
    const [otherFirstChild, otherSecondChild] = other.children;
    if (!(firstChild instanceof LeafNode) || !(secondChild instanceof LeafNode)) {
      return Disposable.None;
    }
    if (!(otherFirstChild instanceof LeafNode) || !(otherSecondChild instanceof LeafNode)) {
      return Disposable.None;
    }
    if (this.orientation === 0) {
      secondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = firstChild;
      firstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = secondChild;
      otherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = otherFirstChild;
      otherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = otherSecondChild;
    } else {
      otherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = firstChild;
      otherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = secondChild;
      firstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = otherFirstChild;
      secondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = otherSecondChild;
    }
    const mySash = this.splitview.sashes[0];
    const otherSash = other.splitview.sashes[0];
    mySash.linkedSash = otherSash;
    otherSash.linkedSash = mySash;
    this._onDidChange.fire(void 0);
    other._onDidChange.fire(void 0);
    return toDisposable(() => {
      mySash.linkedSash = otherSash.linkedSash = void 0;
      firstChild.linkedHeightNode = firstChild.linkedWidthNode = void 0;
      secondChild.linkedHeightNode = secondChild.linkedWidthNode = void 0;
      otherFirstChild.linkedHeightNode = otherFirstChild.linkedWidthNode = void 0;
      otherSecondChild.linkedHeightNode = otherSecondChild.linkedWidthNode = void 0;
    });
  }
  updateSplitviewEdgeSnappingEnablement() {
    this.splitview.startSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset > 0;
    this.splitview.endSnappingEnabled = this._edgeSnapping || this._absoluteOrthogonalOffset + this._size < this.absoluteOrthogonalSize;
  }
  dispose() {
    for (const child of this.children) {
      child.dispose();
    }
    this._onDidChange.dispose();
    this._onDidSashReset.dispose();
    this.splitviewSashResetDisposable.dispose();
    this.childrenSashResetDisposable.dispose();
    this.childrenChangeDisposable.dispose();
    this.splitview.dispose();
  }
}
function createLatchedOnDidChangeViewEvent(view) {
  const [onDidChangeViewConstraints, onDidSetViewSize] = Event.split(view.onDidChange, isUndefined);
  return Event.any(onDidSetViewSize, Event.map(Event.latch(Event.map(
    onDidChangeViewConstraints,
    (_) => [view.minimumWidth, view.maximumWidth, view.minimumHeight, view.maximumHeight]
  ), equals), (_) => void 0));
}
class LeafNode {
  get size() {
    return this._size;
  }
  get orthogonalSize() {
    return this._orthogonalSize;
  }
  get linkedWidthNode() {
    return this._linkedWidthNode;
  }
  set linkedWidthNode(node) {
    this._onDidLinkedWidthNodeChange.input = node ? node._onDidViewChange : Event.None;
    this._linkedWidthNode = node;
    this._onDidSetLinkedNode.fire(void 0);
  }
  get linkedHeightNode() {
    return this._linkedHeightNode;
  }
  set linkedHeightNode(node) {
    this._onDidLinkedHeightNodeChange.input = node ? node._onDidViewChange : Event.None;
    this._linkedHeightNode = node;
    this._onDidSetLinkedNode.fire(void 0);
  }
  constructor(view, orientation, layoutController, orthogonalSize, size2 = 0) {
    this.view = view;
    this.orientation = orientation;
    this.layoutController = layoutController;
    this._size = 0;
    this.absoluteOffset = 0;
    this.absoluteOrthogonalOffset = 0;
    this.onDidScroll = Event.None;
    this.onDidSashReset = Event.None;
    this._onDidLinkedWidthNodeChange = new Relay();
    this._linkedWidthNode = void 0;
    this._onDidLinkedHeightNodeChange = new Relay();
    this._linkedHeightNode = void 0;
    this._onDidSetLinkedNode = new Emitter();
    this.disposables = new DisposableStore();
    this._boundarySashes = {};
    this.cachedWidth = 0;
    this.cachedHeight = 0;
    this.cachedTop = 0;
    this.cachedLeft = 0;
    this._orthogonalSize = orthogonalSize;
    this._size = size2;
    const onDidChange = createLatchedOnDidChangeViewEvent(view);
    this._onDidViewChange = Event.map(
      onDidChange,
      (e) => e && (this.orientation === 0 ? e.width : e.height),
      this.disposables
    );
    this.onDidChange = Event.any(this._onDidViewChange, this._onDidSetLinkedNode.event, this._onDidLinkedWidthNodeChange.event, this._onDidLinkedHeightNodeChange.event);
  }
  get width() {
    return this.orientation === 1 ? this.orthogonalSize : this.size;
  }
  get height() {
    return this.orientation === 1 ? this.size : this.orthogonalSize;
  }
  get top() {
    return this.orientation === 1 ? this.absoluteOffset : this.absoluteOrthogonalOffset;
  }
  get left() {
    return this.orientation === 1 ? this.absoluteOrthogonalOffset : this.absoluteOffset;
  }
  get element() {
    return this.view.element;
  }
  get minimumWidth() {
    return this.linkedWidthNode ? Math.max(this.linkedWidthNode.view.minimumWidth, this.view.minimumWidth) : this.view.minimumWidth;
  }
  get maximumWidth() {
    return this.linkedWidthNode ? Math.min(this.linkedWidthNode.view.maximumWidth, this.view.maximumWidth) : this.view.maximumWidth;
  }
  get minimumHeight() {
    return this.linkedHeightNode ? Math.max(this.linkedHeightNode.view.minimumHeight, this.view.minimumHeight) : this.view.minimumHeight;
  }
  get maximumHeight() {
    return this.linkedHeightNode ? Math.min(this.linkedHeightNode.view.maximumHeight, this.view.maximumHeight) : this.view.maximumHeight;
  }
  get minimumSize() {
    return this.orientation === 1 ? this.minimumHeight : this.minimumWidth;
  }
  get maximumSize() {
    return this.orientation === 1 ? this.maximumHeight : this.maximumWidth;
  }
  get priority() {
    return this.view.priority;
  }
  get proportionalLayout() {
    return this.view.proportionalLayout ?? true;
  }
  get snap() {
    return this.view.snap;
  }
  get minimumOrthogonalSize() {
    return this.orientation === 1 ? this.minimumWidth : this.minimumHeight;
  }
  get maximumOrthogonalSize() {
    return this.orientation === 1 ? this.maximumWidth : this.maximumHeight;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set boundarySashes(boundarySashes) {
    var _a2, _b2;
    this._boundarySashes = boundarySashes;
    (_b2 = (_a2 = this.view).setBoundarySashes) == null ? void 0 : _b2.call(_a2, toAbsoluteBoundarySashes(boundarySashes, this.orientation));
  }
  layout(size2, offset, ctx) {
    if (!this.layoutController.isLayoutEnabled) {
      return;
    }
    if (typeof ctx === "undefined") {
      throw new Error("Invalid state");
    }
    this._size = size2;
    this._orthogonalSize = ctx.orthogonalSize;
    this.absoluteOffset = ctx.absoluteOffset + offset;
    this.absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;
    this._layout(this.width, this.height, this.top, this.left);
  }
  _layout(width, height, top, left) {
    if (this.cachedWidth === width && this.cachedHeight === height && this.cachedTop === top && this.cachedLeft === left) {
      return;
    }
    this.cachedWidth = width;
    this.cachedHeight = height;
    this.cachedTop = top;
    this.cachedLeft = left;
    this.view.layout(width, height, top, left);
  }
  setVisible(visible) {
    var _a2, _b2;
    (_b2 = (_a2 = this.view).setVisible) == null ? void 0 : _b2.call(_a2, visible);
  }
  dispose() {
    this.disposables.dispose();
  }
}
function flipNode(node, size2, orthogonalSize) {
  if (node instanceof BranchNode) {
    const result = new BranchNode(
      orthogonal(node.orientation),
      node.layoutController,
      node.styles,
      node.splitviewProportionalLayout,
      size2,
      orthogonalSize,
      node.edgeSnapping
    );
    let totalSize = 0;
    for (let i = node.children.length - 1; i >= 0; i--) {
      const child = node.children[i];
      const childSize = child instanceof BranchNode ? child.orthogonalSize : child.size;
      let newSize = node.size === 0 ? 0 : Math.round(size2 * childSize / node.size);
      totalSize += newSize;
      if (i === 0) {
        newSize += size2 - totalSize;
      }
      result.addChild(flipNode(child, orthogonalSize, newSize), newSize, 0, true);
    }
    return result;
  } else {
    return new LeafNode(
      node.view,
      orthogonal(node.orientation),
      node.layoutController,
      orthogonalSize
    );
  }
}
class GridView {
  get root() {
    return this._root;
  }
  set root(root) {
    const oldRoot = this._root;
    if (oldRoot) {
      this.element.removeChild(oldRoot.element);
      oldRoot.dispose();
    }
    this._root = root;
    this.element.appendChild(root.element);
    this.onDidSashResetRelay.input = root.onDidSashReset;
    this._onDidChange.input = Event.map(root.onDidChange, () => void 0);
    this._onDidScroll.input = root.onDidScroll;
  }
  get width() {
    return this.root.width;
  }
  get height() {
    return this.root.height;
  }
  get minimumWidth() {
    return this.root.minimumWidth;
  }
  get minimumHeight() {
    return this.root.minimumHeight;
  }
  get maximumWidth() {
    return this.root.maximumHeight;
  }
  get maximumHeight() {
    return this.root.maximumHeight;
  }
  get orientation() {
    return this._root.orientation;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set orientation(orientation) {
    if (this._root.orientation === orientation) {
      return;
    }
    const { size: size2, orthogonalSize, absoluteOffset, absoluteOrthogonalOffset } = this._root;
    this.root = flipNode(this._root, orthogonalSize, size2);
    this.root.layout(size2, 0, { orthogonalSize, absoluteOffset: absoluteOrthogonalOffset, absoluteOrthogonalOffset: absoluteOffset, absoluteSize: size2, absoluteOrthogonalSize: orthogonalSize });
    this.boundarySashes = this.boundarySashes;
  }
  set boundarySashes(boundarySashes) {
    this._boundarySashes = boundarySashes;
    this.root.boundarySashes = fromAbsoluteBoundarySashes(boundarySashes, this.orientation);
  }
  set edgeSnapping(edgeSnapping) {
    this.root.edgeSnapping = edgeSnapping;
  }
  constructor(options = {}) {
    this.onDidSashResetRelay = new Relay();
    this._onDidScroll = new Relay();
    this._onDidChange = new Relay();
    this._boundarySashes = {};
    this.disposable2x2 = Disposable.None;
    this.onDidSashReset = this.onDidSashResetRelay.event;
    this.onDidScroll = this._onDidScroll.event;
    this.onDidChange = this._onDidChange.event;
    this.element = $$2(".monaco-grid-view");
    this.styles = options.styles || defaultStyles;
    this.proportionalLayout = typeof options.proportionalLayout !== "undefined" ? !!options.proportionalLayout : true;
    this.layoutController = new LayoutController(false);
    this.root = new BranchNode(
      0,
      this.layoutController,
      this.styles,
      this.proportionalLayout
    );
  }
  style(styles) {
    this.styles = styles;
    this.root.style(styles);
  }
  layout(width, height, top = 0, left = 0) {
    this.layoutController.isLayoutEnabled = true;
    const [size2, orthogonalSize, offset, orthogonalOffset] = this.root.orientation === 1 ? [height, width, top, left] : [width, height, left, top];
    this.root.layout(size2, 0, { orthogonalSize, absoluteOffset: offset, absoluteOrthogonalOffset: orthogonalOffset, absoluteSize: size2, absoluteOrthogonalSize: orthogonalSize });
  }
  addView(view, size2, location) {
    this.disposable2x2.dispose();
    this.disposable2x2 = Disposable.None;
    const [rest, index] = tail2(location);
    const [pathToParent, parent] = this.getNode(rest);
    if (parent instanceof BranchNode) {
      const node = new LeafNode(
        view,
        orthogonal(parent.orientation),
        this.layoutController,
        parent.orthogonalSize
      );
      parent.addChild(node, size2, index);
    } else {
      const [, grandParent] = tail2(pathToParent);
      const [, parentIndex] = tail2(rest);
      let newSiblingSize = 0;
      const newSiblingCachedVisibleSize = grandParent.getChildCachedVisibleSize(parentIndex);
      if (typeof newSiblingCachedVisibleSize === "number") {
        newSiblingSize = Sizing$1.Invisible(newSiblingCachedVisibleSize);
      }
      grandParent.removeChild(parentIndex);
      const newParent = new BranchNode(
        parent.orientation,
        parent.layoutController,
        this.styles,
        this.proportionalLayout,
        parent.size,
        parent.orthogonalSize,
        grandParent.edgeSnapping
      );
      grandParent.addChild(newParent, parent.size, parentIndex);
      const newSibling = new LeafNode(parent.view, grandParent.orientation, this.layoutController, parent.size);
      newParent.addChild(newSibling, newSiblingSize, 0);
      if (typeof size2 !== "number" && size2.type === "split") {
        size2 = Sizing$1.Split(0);
      }
      const node = new LeafNode(view, grandParent.orientation, this.layoutController, parent.size);
      newParent.addChild(node, size2, index);
    }
    this.trySet2x2();
  }
  removeView(location, sizing) {
    this.disposable2x2.dispose();
    this.disposable2x2 = Disposable.None;
    const [rest, index] = tail2(location);
    const [pathToParent, parent] = this.getNode(rest);
    if (!(parent instanceof BranchNode)) {
      throw new Error("Invalid location");
    }
    const node = parent.children[index];
    if (!(node instanceof LeafNode)) {
      throw new Error("Invalid location");
    }
    parent.removeChild(index, sizing);
    if (parent.children.length === 0) {
      throw new Error("Invalid grid state");
    }
    if (parent.children.length > 1) {
      this.trySet2x2();
      return node.view;
    }
    if (pathToParent.length === 0) {
      const sibling2 = parent.children[0];
      if (sibling2 instanceof LeafNode) {
        return node.view;
      }
      parent.removeChild(0);
      this.root = sibling2;
      this.boundarySashes = this.boundarySashes;
      this.trySet2x2();
      return node.view;
    }
    const [, grandParent] = tail2(pathToParent);
    const [, parentIndex] = tail2(rest);
    const sibling = parent.children[0];
    const isSiblingVisible = parent.isChildVisible(0);
    parent.removeChild(0);
    const sizes = grandParent.children.map((_, i) => grandParent.getChildSize(i));
    grandParent.removeChild(parentIndex, sizing);
    if (sibling instanceof BranchNode) {
      sizes.splice(parentIndex, 1, ...sibling.children.map((c) => c.size));
      for (let i = 0; i < sibling.children.length; i++) {
        const child = sibling.children[i];
        grandParent.addChild(child, child.size, parentIndex + i);
      }
    } else {
      const newSibling = new LeafNode(
        sibling.view,
        orthogonal(sibling.orientation),
        this.layoutController,
        sibling.size
      );
      const sizing2 = isSiblingVisible ? sibling.orthogonalSize : Sizing$1.Invisible(sibling.orthogonalSize);
      grandParent.addChild(newSibling, sizing2, parentIndex);
    }
    for (let i = 0; i < sizes.length; i++) {
      grandParent.resizeChild(i, sizes[i]);
    }
    this.trySet2x2();
    return node.view;
  }
  moveView(parentLocation, from, to) {
    const [, parent] = this.getNode(parentLocation);
    if (!(parent instanceof BranchNode)) {
      throw new Error("Invalid location");
    }
    parent.moveChild(from, to);
    this.trySet2x2();
  }
  swapViews(from, to) {
    const [fromRest, fromIndex] = tail2(from);
    const [, fromParent] = this.getNode(fromRest);
    if (!(fromParent instanceof BranchNode)) {
      throw new Error("Invalid from location");
    }
    const fromSize = fromParent.getChildSize(fromIndex);
    const fromNode = fromParent.children[fromIndex];
    if (!(fromNode instanceof LeafNode)) {
      throw new Error("Invalid from location");
    }
    const [toRest, toIndex] = tail2(to);
    const [, toParent] = this.getNode(toRest);
    if (!(toParent instanceof BranchNode)) {
      throw new Error("Invalid to location");
    }
    const toSize = toParent.getChildSize(toIndex);
    const toNode = toParent.children[toIndex];
    if (!(toNode instanceof LeafNode)) {
      throw new Error("Invalid to location");
    }
    if (fromParent === toParent) {
      fromParent.swapChildren(fromIndex, toIndex);
    } else {
      fromParent.removeChild(fromIndex);
      toParent.removeChild(toIndex);
      fromParent.addChild(toNode, fromSize, fromIndex);
      toParent.addChild(fromNode, toSize, toIndex);
    }
    this.trySet2x2();
  }
  resizeView(location, size2) {
    const [rest, index] = tail2(location);
    const [pathToParent, parent] = this.getNode(rest);
    if (!(parent instanceof BranchNode)) {
      throw new Error("Invalid location");
    }
    if (!size2.width && !size2.height) {
      return;
    }
    const [parentSize, grandParentSize] = parent.orientation === 1 ? [size2.width, size2.height] : [size2.height, size2.width];
    if (typeof grandParentSize === "number" && pathToParent.length > 0) {
      const [, grandParent] = tail2(pathToParent);
      const [, parentIndex] = tail2(rest);
      grandParent.resizeChild(parentIndex, grandParentSize);
    }
    if (typeof parentSize === "number") {
      parent.resizeChild(index, parentSize);
    }
    this.trySet2x2();
  }
  getViewSize(location) {
    if (!location) {
      return { width: this.root.width, height: this.root.height };
    }
    const [, node] = this.getNode(location);
    return { width: node.width, height: node.height };
  }
  getViewCachedVisibleSize(location) {
    const [rest, index] = tail2(location);
    const [, parent] = this.getNode(rest);
    if (!(parent instanceof BranchNode)) {
      throw new Error("Invalid location");
    }
    return parent.getChildCachedVisibleSize(index);
  }
  maximizeViewSize(location) {
    const [ancestors, node] = this.getNode(location);
    if (!(node instanceof LeafNode)) {
      throw new Error("Invalid location");
    }
    for (let i = 0; i < ancestors.length; i++) {
      ancestors[i].resizeChild(location[i], Number.POSITIVE_INFINITY);
    }
  }
  isViewSizeMaximized(location) {
    const [ancestors, node] = this.getNode(location);
    if (!(node instanceof LeafNode)) {
      throw new Error("Invalid location");
    }
    for (let i = 0; i < ancestors.length; i++) {
      if (!ancestors[i].isChildSizeMaximized(location[i])) {
        return false;
      }
    }
    return true;
  }
  distributeViewSizes(location) {
    if (!location) {
      this.root.distributeViewSizes(true);
      return;
    }
    const [, node] = this.getNode(location);
    if (!(node instanceof BranchNode)) {
      throw new Error("Invalid location");
    }
    node.distributeViewSizes();
    this.trySet2x2();
  }
  isViewVisible(location) {
    const [rest, index] = tail2(location);
    const [, parent] = this.getNode(rest);
    if (!(parent instanceof BranchNode)) {
      throw new Error("Invalid from location");
    }
    return parent.isChildVisible(index);
  }
  setViewVisible(location, visible) {
    const [rest, index] = tail2(location);
    const [, parent] = this.getNode(rest);
    if (!(parent instanceof BranchNode)) {
      throw new Error("Invalid from location");
    }
    parent.setChildVisible(index, visible);
  }
  getView(location) {
    const node = location ? this.getNode(location)[1] : this._root;
    return this._getViews(node, this.orientation);
  }
  static deserialize(json, deserializer, options = {}) {
    var _a2;
    if (typeof json.orientation !== "number") {
      throw new Error("Invalid JSON: 'orientation' property must be a number.");
    } else if (typeof json.width !== "number") {
      throw new Error("Invalid JSON: 'width' property must be a number.");
    } else if (typeof json.height !== "number") {
      throw new Error("Invalid JSON: 'height' property must be a number.");
    } else if (((_a2 = json.root) == null ? void 0 : _a2.type) !== "branch") {
      throw new Error("Invalid JSON: 'root' property must have 'type' value of branch.");
    }
    const orientation = json.orientation;
    const height = json.height;
    const result = new GridView(options);
    result._deserialize(json.root, orientation, deserializer, height);
    return result;
  }
  _deserialize(root, orientation, deserializer, orthogonalSize) {
    this.root = this._deserializeNode(root, orientation, deserializer, orthogonalSize);
  }
  _deserializeNode(node, orientation, deserializer, orthogonalSize) {
    let result;
    if (node.type === "branch") {
      const serializedChildren = node.data;
      const children = serializedChildren.map((serializedChild) => {
        return {
          node: this._deserializeNode(serializedChild, orthogonal(orientation), deserializer, node.size),
          visible: serializedChild.visible
        };
      });
      result = new BranchNode(
        orientation,
        this.layoutController,
        this.styles,
        this.proportionalLayout,
        node.size,
        orthogonalSize,
        void 0,
        children
      );
    } else {
      result = new LeafNode(
        deserializer.fromJSON(node.data),
        orientation,
        this.layoutController,
        orthogonalSize,
        node.size
      );
    }
    return result;
  }
  _getViews(node, orientation, cachedVisibleSize) {
    const box = { top: node.top, left: node.left, width: node.width, height: node.height };
    if (node instanceof LeafNode) {
      return { view: node.view, box, cachedVisibleSize };
    }
    const children = [];
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      const cachedVisibleSize2 = node.getChildCachedVisibleSize(i);
      children.push(this._getViews(child, orthogonal(orientation), cachedVisibleSize2));
    }
    return { children, box };
  }
  getNode(location, node = this.root, path = []) {
    if (location.length === 0) {
      return [path, node];
    }
    if (!(node instanceof BranchNode)) {
      throw new Error("Invalid location");
    }
    const [index, ...rest] = location;
    if (index < 0 || index >= node.children.length) {
      throw new Error("Invalid location");
    }
    const child = node.children[index];
    path.push(node);
    return this.getNode(rest, child, path);
  }
  trySet2x2() {
    this.disposable2x2.dispose();
    this.disposable2x2 = Disposable.None;
    if (this.root.children.length !== 2) {
      return;
    }
    const [first, second] = this.root.children;
    if (!(first instanceof BranchNode) || !(second instanceof BranchNode)) {
      return;
    }
    this.disposable2x2 = first.trySet2x2(second);
  }
  getViewMap(map, node) {
    if (!node) {
      node = this.root;
    }
    if (node instanceof BranchNode) {
      node.children.forEach((child) => this.getViewMap(map, child));
    } else {
      map.set(node.view, node.element);
    }
  }
  dispose() {
    this.onDidSashResetRelay.dispose();
    this.root.dispose();
    if (this.element && this.element.parentElement) {
      this.element.parentElement.removeChild(this.element);
    }
  }
}
function oppositeDirection(direction) {
  switch (direction) {
    case 0:
      return 1;
    case 1:
      return 0;
    case 2:
      return 3;
    case 3:
      return 2;
  }
}
function isGridBranchNode(node) {
  return !!node.children;
}
function getGridNode(node, location) {
  if (location.length === 0) {
    return node;
  }
  if (!isGridBranchNode(node)) {
    throw new Error("Invalid location");
  }
  const [index, ...rest] = location;
  return getGridNode(node.children[index], rest);
}
function intersects(one, other) {
  return !(one.start >= other.end || other.start >= one.end);
}
function getBoxBoundary(box, direction) {
  const orientation = getDirectionOrientation(direction);
  const offset = direction === 0 ? box.top : direction === 3 ? box.left + box.width : direction === 1 ? box.top + box.height : box.left;
  const range2 = {
    start: orientation === 1 ? box.top : box.left,
    end: orientation === 1 ? box.top + box.height : box.left + box.width
  };
  return { offset, range: range2 };
}
function findAdjacentBoxLeafNodes(boxNode, direction, boundary) {
  const result = [];
  function _(boxNode2, direction2, boundary2) {
    if (isGridBranchNode(boxNode2)) {
      for (const child of boxNode2.children) {
        _(child, direction2, boundary2);
      }
    } else {
      const { offset, range: range2 } = getBoxBoundary(boxNode2.box, direction2);
      if (offset === boundary2.offset && intersects(range2, boundary2.range)) {
        result.push(boxNode2);
      }
    }
  }
  _(boxNode, direction, boundary);
  return result;
}
function getLocationOrientation(rootOrientation, location) {
  return location.length % 2 === 0 ? orthogonal(rootOrientation) : rootOrientation;
}
function getDirectionOrientation(direction) {
  return direction === 0 || direction === 1 ? 0 : 1;
}
function getRelativeLocation(rootOrientation, location, direction) {
  const orientation = getLocationOrientation(rootOrientation, location);
  const directionOrientation = getDirectionOrientation(direction);
  if (orientation === directionOrientation) {
    let [rest, index] = tail2(location);
    if (direction === 3 || direction === 1) {
      index += 1;
    }
    return [...rest, index];
  } else {
    const index = direction === 3 || direction === 1 ? 1 : 0;
    return [...location, index];
  }
}
function indexInParent(element) {
  const parentElement = element.parentElement;
  if (!parentElement) {
    throw new Error("Invalid grid element");
  }
  let el = parentElement.firstElementChild;
  let index = 0;
  while (el !== element && el !== parentElement.lastElementChild && el) {
    el = el.nextElementSibling;
    index++;
  }
  return index;
}
function getGridLocation(element) {
  const parentElement = element.parentElement;
  if (!parentElement) {
    throw new Error("Invalid grid element");
  }
  if (/\bmonaco-grid-view\b/.test(parentElement.className)) {
    return [];
  }
  const index = indexInParent(parentElement);
  const ancestor = parentElement.parentElement.parentElement.parentElement.parentElement;
  return [...getGridLocation(ancestor), index];
}
var Sizing;
(function(Sizing2) {
  Sizing2.Distribute = { type: "distribute" };
  Sizing2.Split = { type: "split" };
  Sizing2.Auto = { type: "auto" };
  function Invisible(cachedVisibleSize) {
    return { type: "invisible", cachedVisibleSize };
  }
  Sizing2.Invisible = Invisible;
})(Sizing || (Sizing = {}));
class Grid extends Disposable {
  get orientation() {
    return this.gridview.orientation;
  }
  set orientation(orientation) {
    this.gridview.orientation = orientation;
  }
  get width() {
    return this.gridview.width;
  }
  get height() {
    return this.gridview.height;
  }
  get minimumWidth() {
    return this.gridview.minimumWidth;
  }
  get minimumHeight() {
    return this.gridview.minimumHeight;
  }
  get maximumWidth() {
    return this.gridview.maximumWidth;
  }
  get maximumHeight() {
    return this.gridview.maximumHeight;
  }
  get boundarySashes() {
    return this.gridview.boundarySashes;
  }
  set boundarySashes(boundarySashes) {
    this.gridview.boundarySashes = boundarySashes;
  }
  set edgeSnapping(edgeSnapping) {
    this.gridview.edgeSnapping = edgeSnapping;
  }
  get element() {
    return this.gridview.element;
  }
  constructor(view, options = {}) {
    super();
    this.views = /* @__PURE__ */ new Map();
    this.didLayout = false;
    if (view instanceof GridView) {
      this.gridview = view;
      this.gridview.getViewMap(this.views);
    } else {
      this.gridview = new GridView(options);
    }
    this._register(this.gridview);
    this._register(this.gridview.onDidSashReset(this.onDidSashReset, this));
    if (!(view instanceof GridView)) {
      this._addView(view, 0, [0]);
    }
    this.onDidChange = this.gridview.onDidChange;
    this.onDidScroll = this.gridview.onDidScroll;
  }
  style(styles) {
    this.gridview.style(styles);
  }
  layout(width, height, top = 0, left = 0) {
    this.gridview.layout(width, height, top, left);
    this.didLayout = true;
  }
  addView(newView, size2, referenceView, direction) {
    if (this.views.has(newView)) {
      throw new Error("Can't add same view twice");
    }
    const orientation = getDirectionOrientation(direction);
    if (this.views.size === 1 && this.orientation !== orientation) {
      this.orientation = orientation;
    }
    const referenceLocation = this.getViewLocation(referenceView);
    const location = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);
    let viewSize;
    if (typeof size2 === "number") {
      viewSize = size2;
    } else if (size2.type === "split") {
      const [, index] = tail2(referenceLocation);
      viewSize = Sizing$1.Split(index);
    } else if (size2.type === "distribute") {
      viewSize = Sizing$1.Distribute;
    } else if (size2.type === "auto") {
      const [, index] = tail2(referenceLocation);
      viewSize = Sizing$1.Auto(index);
    } else {
      viewSize = size2;
    }
    this._addView(newView, viewSize, location);
  }
  addViewAt(newView, size2, location) {
    if (this.views.has(newView)) {
      throw new Error("Can't add same view twice");
    }
    let viewSize;
    if (typeof size2 === "number") {
      viewSize = size2;
    } else if (size2.type === "distribute") {
      viewSize = Sizing$1.Distribute;
    } else {
      viewSize = size2;
    }
    this._addView(newView, viewSize, location);
  }
  _addView(newView, size2, location) {
    this.views.set(newView, newView.element);
    this.gridview.addView(newView, size2, location);
  }
  removeView(view, sizing) {
    if (this.views.size === 1) {
      throw new Error("Can't remove last view");
    }
    const location = this.getViewLocation(view);
    let gridViewSizing;
    if ((sizing == null ? void 0 : sizing.type) === "distribute") {
      gridViewSizing = Sizing$1.Distribute;
    } else if ((sizing == null ? void 0 : sizing.type) === "auto") {
      const index = location[location.length - 1];
      gridViewSizing = Sizing$1.Auto(index === 0 ? 1 : index - 1);
    }
    this.gridview.removeView(location, gridViewSizing);
    this.views.delete(view);
  }
  moveView(view, sizing, referenceView, direction) {
    const sourceLocation = this.getViewLocation(view);
    const [sourceParentLocation, from] = tail2(sourceLocation);
    const referenceLocation = this.getViewLocation(referenceView);
    const targetLocation = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);
    const [targetParentLocation, to] = tail2(targetLocation);
    if (equals(sourceParentLocation, targetParentLocation)) {
      this.gridview.moveView(sourceParentLocation, from, to);
    } else {
      this.removeView(view, typeof sizing === "number" ? void 0 : sizing);
      this.addView(view, sizing, referenceView, direction);
    }
  }
  moveViewTo(view, location) {
    const sourceLocation = this.getViewLocation(view);
    const [sourceParentLocation, from] = tail2(sourceLocation);
    const [targetParentLocation, to] = tail2(location);
    if (equals(sourceParentLocation, targetParentLocation)) {
      this.gridview.moveView(sourceParentLocation, from, to);
    } else {
      const size2 = this.getViewSize(view);
      const orientation = getLocationOrientation(this.gridview.orientation, sourceLocation);
      const cachedViewSize = this.getViewCachedVisibleSize(view);
      const sizing = typeof cachedViewSize === "undefined" ? orientation === 1 ? size2.width : size2.height : Sizing.Invisible(cachedViewSize);
      this.removeView(view);
      this.addViewAt(view, sizing, location);
    }
  }
  swapViews(from, to) {
    const fromLocation = this.getViewLocation(from);
    const toLocation = this.getViewLocation(to);
    return this.gridview.swapViews(fromLocation, toLocation);
  }
  resizeView(view, size2) {
    const location = this.getViewLocation(view);
    return this.gridview.resizeView(location, size2);
  }
  isViewSizeMaximized(view) {
    const location = this.getViewLocation(view);
    return this.gridview.isViewSizeMaximized(location);
  }
  getViewSize(view) {
    if (!view) {
      return this.gridview.getViewSize();
    }
    const location = this.getViewLocation(view);
    return this.gridview.getViewSize(location);
  }
  getViewCachedVisibleSize(view) {
    const location = this.getViewLocation(view);
    return this.gridview.getViewCachedVisibleSize(location);
  }
  maximizeViewSize(view) {
    const location = this.getViewLocation(view);
    this.gridview.maximizeViewSize(location);
  }
  distributeViewSizes() {
    this.gridview.distributeViewSizes();
  }
  isViewVisible(view) {
    const location = this.getViewLocation(view);
    return this.gridview.isViewVisible(location);
  }
  setViewVisible(view, visible) {
    const location = this.getViewLocation(view);
    this.gridview.setViewVisible(location, visible);
  }
  getViews() {
    return this.gridview.getView();
  }
  getNeighborViews(view, direction, wrap = false) {
    if (!this.didLayout) {
      throw new Error("Can't call getNeighborViews before first layout");
    }
    const location = this.getViewLocation(view);
    const root = this.getViews();
    const node = getGridNode(root, location);
    let boundary = getBoxBoundary(node.box, direction);
    if (wrap) {
      if (direction === 0 && node.box.top === 0) {
        boundary = { offset: root.box.top + root.box.height, range: boundary.range };
      } else if (direction === 3 && node.box.left + node.box.width === root.box.width) {
        boundary = { offset: 0, range: boundary.range };
      } else if (direction === 1 && node.box.top + node.box.height === root.box.height) {
        boundary = { offset: 0, range: boundary.range };
      } else if (direction === 2 && node.box.left === 0) {
        boundary = { offset: root.box.left + root.box.width, range: boundary.range };
      }
    }
    return findAdjacentBoxLeafNodes(root, oppositeDirection(direction), boundary).map((node2) => node2.view);
  }
  getViewLocation(view) {
    const element = this.views.get(view);
    if (!element) {
      throw new Error("View not found");
    }
    return getGridLocation(element);
  }
  onDidSashReset(location) {
    const resizeToPreferredSize = (location2) => {
      const node = this.gridview.getView(location2);
      if (isGridBranchNode(node)) {
        return false;
      }
      const direction = getLocationOrientation(this.orientation, location2);
      const size2 = direction === 1 ? node.view.preferredWidth : node.view.preferredHeight;
      if (typeof size2 !== "number") {
        return false;
      }
      const viewSize = direction === 1 ? { width: Math.round(size2) } : { height: Math.round(size2) };
      this.gridview.resizeView(location2, viewSize);
      return true;
    };
    if (resizeToPreferredSize(location)) {
      return;
    }
    const [parentLocation, index] = tail2(location);
    if (resizeToPreferredSize([...parentLocation, index + 1])) {
      return;
    }
    this.gridview.distributeViewSizes(parentLocation);
  }
}
class SerializableGrid extends Grid {
  constructor() {
    super(...arguments);
    this.initialLayoutContext = true;
  }
  static serializeNode(node, orientation) {
    const size2 = orientation === 0 ? node.box.width : node.box.height;
    if (!isGridBranchNode(node)) {
      if (typeof node.cachedVisibleSize === "number") {
        return { type: "leaf", data: node.view.toJSON(), size: node.cachedVisibleSize, visible: false };
      }
      return { type: "leaf", data: node.view.toJSON(), size: size2 };
    }
    return { type: "branch", data: node.children.map((c) => SerializableGrid.serializeNode(c, orthogonal(orientation))), size: size2 };
  }
  static deserialize(json, deserializer, options = {}) {
    if (typeof json.orientation !== "number") {
      throw new Error("Invalid JSON: 'orientation' property must be a number.");
    } else if (typeof json.width !== "number") {
      throw new Error("Invalid JSON: 'width' property must be a number.");
    } else if (typeof json.height !== "number") {
      throw new Error("Invalid JSON: 'height' property must be a number.");
    }
    const gridview = GridView.deserialize(json, deserializer, options);
    const result = new SerializableGrid(gridview, options);
    return result;
  }
  static from(gridDescriptor, options = {}) {
    return SerializableGrid.deserialize(createSerializedGrid(gridDescriptor), { fromJSON: (view) => view }, options);
  }
  serialize() {
    return {
      root: SerializableGrid.serializeNode(this.getViews(), this.orientation),
      orientation: this.orientation,
      width: this.width,
      height: this.height
    };
  }
  layout(width, height, top = 0, left = 0) {
    super.layout(width, height, top, left);
    if (this.initialLayoutContext) {
      this.initialLayoutContext = false;
      this.gridview.trySet2x2();
    }
  }
}
function isGridBranchNodeDescriptor(nodeDescriptor) {
  return !!nodeDescriptor.groups;
}
function sanitizeGridNodeDescriptor(nodeDescriptor, rootNode) {
  if (!rootNode && nodeDescriptor.groups && nodeDescriptor.groups.length <= 1) {
    nodeDescriptor.groups = void 0;
  }
  if (!isGridBranchNodeDescriptor(nodeDescriptor)) {
    return;
  }
  let totalDefinedSize = 0;
  let totalDefinedSizeCount = 0;
  for (const child of nodeDescriptor.groups) {
    sanitizeGridNodeDescriptor(child, false);
    if (child.size) {
      totalDefinedSize += child.size;
      totalDefinedSizeCount++;
    }
  }
  const totalUndefinedSize = totalDefinedSizeCount > 0 ? totalDefinedSize : 1;
  const totalUndefinedSizeCount = nodeDescriptor.groups.length - totalDefinedSizeCount;
  const eachUndefinedSize = totalUndefinedSize / totalUndefinedSizeCount;
  for (const child of nodeDescriptor.groups) {
    if (!child.size) {
      child.size = eachUndefinedSize;
    }
  }
}
function createSerializedNode(nodeDescriptor) {
  if (isGridBranchNodeDescriptor(nodeDescriptor)) {
    return { type: "branch", data: nodeDescriptor.groups.map((c) => createSerializedNode(c)), size: nodeDescriptor.size };
  } else {
    return { type: "leaf", data: nodeDescriptor.data, size: nodeDescriptor.size };
  }
}
function getDimensions(node, orientation) {
  if (node.type === "branch") {
    const childrenDimensions = node.data.map((c) => getDimensions(c, orthogonal(orientation)));
    if (orientation === 0) {
      const width = node.size || (childrenDimensions.length === 0 ? void 0 : Math.max(...childrenDimensions.map((d) => d.width || 0)));
      const height = childrenDimensions.length === 0 ? void 0 : childrenDimensions.reduce((r, d) => r + (d.height || 0), 0);
      return { width, height };
    } else {
      const width = childrenDimensions.length === 0 ? void 0 : childrenDimensions.reduce((r, d) => r + (d.width || 0), 0);
      const height = node.size || (childrenDimensions.length === 0 ? void 0 : Math.max(...childrenDimensions.map((d) => d.height || 0)));
      return { width, height };
    }
  } else {
    const width = orientation === 0 ? node.size : void 0;
    const height = orientation === 0 ? void 0 : node.size;
    return { width, height };
  }
}
function createSerializedGrid(gridDescriptor) {
  sanitizeGridNodeDescriptor(gridDescriptor, true);
  const root = createSerializedNode(gridDescriptor);
  const { width, height } = getDimensions(root, gridDescriptor.orientation);
  return {
    root,
    orientation: gridDescriptor.orientation,
    width: width || 1,
    height: height || 1
  };
}
var css$e = '.monaco-workbench .part.editor>.content .editor-group-container{height:100%}.monaco-workbench .part.editor>.content .editor-group-container.empty{opacity:.5}.monaco-workbench .part.editor>.content .editor-group-container.empty.active,.monaco-workbench .part.editor>.content .editor-group-container.empty.dragged-over{opacity:1}.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container.empty.active:focus{outline:1px solid var(--vscode-editorGroup-focusedEmptyBorder);outline-offset:-2px}.monaco-workbench .part.editor>.content.empty .editor-group-container.empty.active:focus{outline:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark{align-items:center;display:flex;flex-direction:column;height:100%;justify-content:center;margin:auto;max-width:290px}.monaco-workbench .part.editor>.content .editor-group-container:not(.empty)>.editor-group-watermark{display:none}.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container.empty>.editor-group-watermark{height:calc(100% - 70px);max-width:200px}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.letterpress{aspect-ratio:1/1;background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIG9wYWNpdHk9Ii4xIj48cGF0aCBkPSJNMjU5Ljk5NiAyNDIuMDAySC0uMDAzVjE4aDI2MHYyMjRaTTUuOTk3IDI0LjAwNnYyMTEuOTkxaDI0OFYyNC4wMDZoLTI0OFoiLz48cGF0aCBkPSJNNzcgMjJoMTh2MjE2SDc3ek0xMTIgNDJoNzB2MThoLTcwek0xMTIgMTgyaDcwdjE4aC03MHpNMTI5LjQ5OCA3N2g4OHYxOGgtODh6TTEyOS40OTggMTEyaDg4djE4aC04OHpNMTI5LjQ5OCAxNDdoODh2MThoLTg4eiIvPjwvZz48L3N2Zz4=");background-position-x:center;background-repeat:no-repeat;background-size:contain;max-height:100%;width:100%}.monaco-workbench.vs-dark .part.editor>.content .editor-group-container .editor-group-watermark>.letterpress{background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIG9wYWNpdHk9Ii4zIj48cGF0aCBkPSJNMjU5Ljk5NiAyNDIuMDAySC0uMDAzVjE4aDI2MHYyMjRaTTUuOTk3IDI0LjAwNnYyMTEuOTkxaDI0OFYyNC4wMDZoLTI0OFoiLz48cGF0aCBkPSJNNzcgMjJoMTh2MjE2SDc3ek0xMTIgNDJoNzB2MThoLTcwek0xMTIgMTgyaDcwdjE4aC03MHpNMTI5LjQ5OCA3N2g4OHYxOGgtODh6TTEyOS40OTggMTEyaDg4djE4aC04OHpNMTI5LjQ5OCAxNDdoODh2MThoLTg4eiIvPjwvZz48L3N2Zz4=")}.monaco-workbench.hc-light .part.editor>.content .editor-group-container .editor-group-watermark>.letterpress{background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIGZpbGw9IiNkOWQ5ZDkiPjxwYXRoIGQ9Ik0yNTkuOTk2IDI0Mi4wMDJILS4wMDNWMThoMjYwdjIyNFpNNS45OTcgMjQuMDA2djIxMS45OTFoMjQ4VjI0LjAwNmgtMjQ4WiIvPjxwYXRoIGQ9Ik03NyAyMmgxOHYyMTZINzd6TTExMiA0Mmg3MHYxOGgtNzB6TTExMiAxODJoNzB2MThoLTcwek0xMjkuNDk4IDc3aDg4djE4aC04OHpNMTI5LjQ5OCAxMTJoODh2MThoLTg4ek0xMjkuNDk4IDE0N2g4OHYxOGgtODh6Ii8+PC9nPjwvc3ZnPg==")}.monaco-workbench.hc-black .part.editor>.content .editor-group-container .editor-group-watermark>.letterpress{background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYwIDI2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEuNDE0MjEiPjxnIGZpbGw9IiMzQzNDM0MiPjxwYXRoIGQ9Ik0yNTkuOTk2IDI0Mi4wMDJILS4wMDNWMThoMjYwdjIyNFpNNS45OTcgMjQuMDA2djIxMS45OTFoMjQ4VjI0LjAwNmgtMjQ4WiIvPjxwYXRoIGQ9Ik03NyAyMmgxOHYyMTZINzd6TTExMiA0Mmg3MHYxOGgtNzB6TTExMiAxODJoNzB2MThoLTcwek0xMjkuNDk4IDc3aDg4djE4aC04OHpNMTI5LjQ5OCAxMTJoODh2MThoLTg4ek0xMjkuNDk4IDE0N2g4OHYxOGgtODh6Ii8+PC9nPjwvc3ZnPg==")}.monaco-workbench .part.editor>.content .editor-group-container.max-height-478px>.editor-group-watermark>.shortcuts,.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container>.editor-group-watermark>.shortcuts{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts>.watermark-box{border-collapse:separate;border-spacing:11px 17px;display:inline-table}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dl{cursor:default;display:table-row;opacity:.8}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dt{letter-spacing:.04em;text-align:right}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dd{text-align:left}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dd,.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dt{display:table-cell;vertical-align:middle}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dl,.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-watermark>.shortcuts dt{color:rgba(0,0,0,.68)}.monaco-workbench.vs-dark .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dl,.monaco-workbench.vs-dark .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dt{color:hsla(0,0%,100%,.6)}.monaco-workbench.hc-black .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dt,.monaco-workbench.hc-light .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dt{color:var(--vscode-editor-foreground)}.monaco-workbench.hc-black .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dl,.monaco-workbench.hc-light .part.editor>.content .editor-group-container .editor-group-watermark>.shortcuts dl{color:var(--vscode-editor-foreground);opacity:1}.monaco-workbench .part.editor>.content .editor-group-container>.title{box-sizing:border-box;overflow:hidden;position:relative}.monaco-workbench .part.editor>.content .editor-group-container>.title:not(.tabs){display:flex;flex-wrap:nowrap}.monaco-workbench .part.editor>.content .editor-group-container>.title.title-border-bottom:after{background-color:var(--title-border-bottom-color);bottom:0;content:"";height:1px;left:0;pointer-events:none;position:absolute;width:100%;z-index:9}.monaco-workbench .part.editor>.content .editor-group-container.empty>.title{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-container-toolbar{display:none;height:35px}.monaco-workbench .part.editor>.content:not(.empty) .editor-group-container.empty>.editor-group-container-toolbar{display:block}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-container-toolbar .actions-container{justify-content:flex-end}.monaco-workbench .part.editor>.content .editor-group-container>.editor-group-container-toolbar .action-item{margin-right:4px}.monaco-workbench .part.editor>.content .editor-group-container.empty>.editor-container{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.editor-container>.editor-instance{height:100%}.monaco-workbench .part.editor>.content .grid-view-container{height:100%;width:100%}';
n(css$e, {});
var css$d = '.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container{display:flex;position:relative}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.tabs-border-bottom:after{background-color:var(--tabs-border-bottom-color);bottom:0;content:"";height:1px;left:0;pointer-events:none;position:absolute;width:100%;z-index:9}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container>.monaco-scrollable-element{flex:1}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container>.monaco-scrollable-element .scrollbar{cursor:default;z-index:11}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container{display:flex;height:35px;scrollbar-width:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.scroll{overflow:scroll!important}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container{flex-wrap:wrap;height:auto}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container::-webkit-scrollbar{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab{box-sizing:border-box;cursor:pointer;display:flex;height:35px;padding-left:10px;position:relative;white-space:nowrap}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container>.tab:last-child{margin-right:var(--last-tab-margin-right)}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container>.tab.last-in-row:not(:last-child){border-right:0!important}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.has-icon.tab-actions-off:not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.has-icon.tab-actions-right,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.has-icon.tab-actions-off:not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.has-icon.tab-actions-right{padding-left:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit{flex-shrink:0;min-width:fit-content;width:120px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed{flex:1 0 0;max-width:var(--tab-sizing-current-width,var(--tab-sizing-fixed-max-width,160px));min-width:var(--tab-sizing-current-width,var(--tab-sizing-fixed-min-width,50px))}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.last-in-row{min-width:calc(var(--tab-sizing-current-width, var(--tab-sizing-fixed-min-width, 50px)) - 1px)}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .tabs-container>.tab.sizing-fit.last-in-row:not(:last-child){flex-grow:1}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink{flex-basis:0;flex-grow:1;max-width:fit-content;min-width:80px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-shrink{flex-basis:0;flex-grow:0;position:sticky;z-index:8}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-compact{max-width:38px;min-width:38px;width:38px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.sticky-shrink{max-width:80px;min-width:80px;width:80px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fit.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fit.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fixed.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-fixed.sticky-shrink,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-shrink.sticky-compact,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container.disable-sticky-tabs>.tab.sizing-shrink.sticky-shrink{position:static}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-left:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-off:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-left:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-off:after{content:"";display:flex;flex:0;width:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-left,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-left{min-width:80px;padding-right:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dragged{transform:translateZ(0)}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dragged-over div{pointer-events:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-left{flex-direction:row-reverse;padding-left:0;padding-right:10px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-border-bottom-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-border-top-container{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-bottom>.tab-border-bottom-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-top>.tab-border-top-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty-border-top>.tab-border-top-container{display:block;left:0;pointer-events:none;position:absolute;width:100%}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-top>.tab-border-top-container{background-color:var(--tab-border-top-color);height:1px;top:0;z-index:6}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active.tab-border-bottom>.tab-border-bottom-container{background-color:var(--tab-border-bottom-color);bottom:0;height:1px;z-index:10}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty-border-top>.tab-border-top-container{background-color:var(--tab-dirty-border-top-color);height:2px;top:0;z-index:6}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label{line-height:35px;margin-bottom:auto;margin-top:auto}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed .tab-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink .tab-label{position:relative}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.tab-label>.monaco-icon-label-container:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.tab-label>.monaco-icon-label-container:after{bottom:1px;content:"";height:calc(100% - 2px);opacity:1;padding:0;position:absolute;right:0;top:1px;width:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed:focus>.tab-label>.monaco-icon-label-container:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink:focus>.tab-label>.monaco-icon-label-container:after{opacity:0}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.tab-label.tab-label-has-badge:after,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.tab-label.tab-label-has-badge:after{padding-right:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky-compact:not(.has-icon) .monaco-icon-label{text-align:center}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit .monaco-icon-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fit .monaco-icon-label>.monaco-icon-label-container{overflow:visible}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.monaco-icon-label>.monaco-icon-label-container{flex:none;text-overflow:clip}.monaco-workbench.hc-black .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench.hc-black .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench.hc-light .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed>.monaco-icon-label>.monaco-icon-label-container,.monaco-workbench.hc-light .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink>.monaco-icon-label>.monaco-icon-label-container{text-overflow:ellipsis}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions{margin-bottom:auto;margin-top:auto;width:28px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions>.monaco-action-bar{width:28px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-fixed>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-shrink>.tab-actions{flex:0;overflow:hidden}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty.tab-actions-right.sizing-fixed>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty.tab-actions-right.sizing-shrink>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky.tab-actions-right.sizing-fixed>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky.tab-actions-right.sizing-shrink>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-fixed:hover>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-fixed>.tab-actions:focus-within,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-shrink:hover>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-right.sizing-shrink>.tab-actions:focus-within{overflow:visible}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.sticky-compact>.tab-actions,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off:not(.dirty):not(.sticky)>.tab-actions{display:none}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.active:hover>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.active>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.dirty>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.sticky>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab:hover>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab>.tab-actions .action-label:focus{opacity:1}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions .actions-container{justify-content:center}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab>.tab-actions .action-label.codicon{color:inherit;font-size:16px;height:16px;padding:2px;width:16px}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.sticky.dirty>.tab-actions .action-label:not(:hover):before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky.dirty>.tab-actions .action-label:not(:hover):before{content:"\\ebb2"}.monaco-workbench .part.editor>.content .editor-group-container.active>.title .tabs-container>.tab.dirty>.tab-actions .action-label:not(:hover):before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty>.tab-actions .action-label:not(:hover):before{content:"\\ea71"}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active:hover>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.active>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.dirty>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sticky>.tab-actions .action-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab:hover>.tab-actions .action-label{opacity:.5}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab>.tab-actions .action-label{opacity:0}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off{padding-right:10px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-fixed.tab-actions-off:not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.sizing-shrink.tab-actions-off:not(.sticky-compact){padding-right:5px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.dirty-border-top>.tab-actions{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.dirty:not(.dirty-border-top):not(.sticky-compact),.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off.sticky:not(.sticky-compact){padding-right:0}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab.tab-actions-off>.tab-actions{pointer-events:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control{cursor:default;flex:1 100%;height:22px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-icon-label{height:22px;line-height:22px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-icon-label:before{height:22px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .outline-element-icon{height:22px;line-height:22px;padding-right:3px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item{max-width:80%}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:before{align-items:center;display:flex;height:22px;justify-content:center;width:16px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:last-child{padding-right:8px}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:last-child .codicon:last-child{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title .editor-actions{cursor:default;flex:initial;height:35px;padding:0 8px 0 4px}.monaco-workbench .part.editor>.content .editor-group-container>.title .editor-actions .action-item{margin-right:4px}.monaco-workbench .part.editor>.content .editor-group-container>.title>.tabs-and-actions-container.wrapping .editor-actions{bottom:0;position:absolute;right:0}';
n(css$d, {});
var css$c = ".monaco-workbench .part.editor>.content .editor-group-container>.title{cursor:pointer}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label{flex:1;white-space:nowrap}.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label a,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label a{font-size:13px}.monaco-workbench .part.editor>.content .editor-group-container>.title .monaco-icon-label:before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .monaco-icon-label:before,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label a,.monaco-workbench .part.editor>.content .editor-group-container>.title .tabs-container>.tab .tab-label span,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label a,.monaco-workbench .part.editor>.content .editor-group-container>.title .title-label h2{cursor:pointer}.monaco-workbench .part.editor>.content .editor-group-container>.title .monaco-icon-label:before{height:35px}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .monaco-icon-label:after,.monaco-workbench .part.editor>.content .editor-group-container>.title.tabs .monaco-icon-label:after{margin-right:0}.monaco-editor-group-drag-image{border-radius:10px;display:inline-block;font-size:12px;padding:1px 7px;position:absolute}";
n(css$c, {});
const breadcrumbsWidget = "";
class BreadcrumbsItem {
  dispose() {
  }
}
class BreadcrumbsWidget {
  constructor(container, horizontalScrollbarSize, separatorIcon2, styles) {
    this._disposables = new DisposableStore();
    this._onDidSelectItem = new Emitter();
    this._onDidFocusItem = new Emitter();
    this._onDidChangeFocus = new Emitter();
    this.onDidSelectItem = this._onDidSelectItem.event;
    this.onDidFocusItem = this._onDidFocusItem.event;
    this.onDidChangeFocus = this._onDidChangeFocus.event;
    this._items = new Array();
    this._nodes = new Array();
    this._freeNodes = new Array();
    this._enabled = true;
    this._focusedItemIdx = -1;
    this._selectedItemIdx = -1;
    this._domNode = document.createElement("div");
    this._domNode.className = "monaco-breadcrumbs";
    this._domNode.tabIndex = 0;
    this._domNode.setAttribute("role", "list");
    this._scrollable = new DomScrollableElement(this._domNode, {
      vertical: 2,
      horizontal: 1,
      horizontalScrollbarSize,
      useShadows: false,
      scrollYToX: true
    });
    this._separatorIcon = separatorIcon2;
    this._disposables.add(this._scrollable);
    this._disposables.add(addStandardDisposableListener(this._domNode, "click", (e) => this._onClick(e)));
    container.appendChild(this._scrollable.getDomNode());
    const styleElement = createStyleSheet(this._domNode);
    this._style(styleElement, styles);
    const focusTracker = trackFocus(this._domNode);
    this._disposables.add(focusTracker);
    this._disposables.add(focusTracker.onDidBlur((_) => this._onDidChangeFocus.fire(false)));
    this._disposables.add(focusTracker.onDidFocus((_) => this._onDidChangeFocus.fire(true)));
  }
  setHorizontalScrollbarSize(size2) {
    this._scrollable.updateOptions({
      horizontalScrollbarSize: size2
    });
  }
  dispose() {
    var _a2;
    this._disposables.dispose();
    (_a2 = this._pendingLayout) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    this._onDidSelectItem.dispose();
    this._onDidFocusItem.dispose();
    this._onDidChangeFocus.dispose();
    this._domNode.remove();
    this._nodes.length = 0;
    this._freeNodes.length = 0;
  }
  layout(dim) {
    var _a2;
    if (dim && Dimension.equals(dim, this._dimension)) {
      return;
    }
    (_a2 = this._pendingLayout) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    if (dim) {
      this._pendingLayout = this._updateDimensions(dim);
    } else {
      this._pendingLayout = this._updateScrollbar();
    }
  }
  _updateDimensions(dim) {
    const disposables = new DisposableStore();
    disposables.add(modify(() => {
      this._dimension = dim;
      this._domNode.style.width = `${dim.width}px`;
      this._domNode.style.height = `${dim.height}px`;
      disposables.add(this._updateScrollbar());
    }));
    return disposables;
  }
  _updateScrollbar() {
    return measure(() => {
      measure(() => {
        this._scrollable.setRevealOnScroll(false);
        this._scrollable.scanDomNode();
        this._scrollable.setRevealOnScroll(true);
      });
    });
  }
  _style(styleElement, style) {
    let content = "";
    if (style.breadcrumbsBackground) {
      content += `.monaco-breadcrumbs { background-color: ${style.breadcrumbsBackground}}`;
    }
    if (style.breadcrumbsForeground) {
      content += `.monaco-breadcrumbs .monaco-breadcrumb-item { color: ${style.breadcrumbsForeground}}
`;
    }
    if (style.breadcrumbsFocusForeground) {
      content += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused { color: ${style.breadcrumbsFocusForeground}}
`;
    }
    if (style.breadcrumbsFocusAndSelectionForeground) {
      content += `.monaco-breadcrumbs .monaco-breadcrumb-item.focused.selected { color: ${style.breadcrumbsFocusAndSelectionForeground}}
`;
    }
    if (style.breadcrumbsHoverForeground) {
      content += `.monaco-breadcrumbs:not(.disabled	) .monaco-breadcrumb-item:hover:not(.focused):not(.selected) { color: ${style.breadcrumbsHoverForeground}}
`;
    }
    styleElement.innerText = content;
  }
  setEnabled(value) {
    this._enabled = value;
    this._domNode.classList.toggle("disabled", !this._enabled);
  }
  domFocus() {
    const idx = this._focusedItemIdx >= 0 ? this._focusedItemIdx : this._items.length - 1;
    if (idx >= 0 && idx < this._items.length) {
      this._focus(idx, void 0);
    } else {
      this._domNode.focus();
    }
  }
  isDOMFocused() {
    let candidate = document.activeElement;
    while (candidate) {
      if (this._domNode === candidate) {
        return true;
      }
      candidate = candidate.parentElement;
    }
    return false;
  }
  getFocused() {
    return this._items[this._focusedItemIdx];
  }
  setFocused(item, payload) {
    this._focus(this._items.indexOf(item), payload);
  }
  focusPrev(payload) {
    if (this._focusedItemIdx > 0) {
      this._focus(this._focusedItemIdx - 1, payload);
    }
  }
  focusNext(payload) {
    if (this._focusedItemIdx + 1 < this._nodes.length) {
      this._focus(this._focusedItemIdx + 1, payload);
    }
  }
  _focus(nth, payload) {
    this._focusedItemIdx = -1;
    for (let i = 0; i < this._nodes.length; i++) {
      const node = this._nodes[i];
      if (i !== nth) {
        node.classList.remove("focused");
      } else {
        this._focusedItemIdx = i;
        node.classList.add("focused");
        node.focus();
      }
    }
    this._reveal(this._focusedItemIdx, true);
    this._onDidFocusItem.fire({ type: "focus", item: this._items[this._focusedItemIdx], node: this._nodes[this._focusedItemIdx], payload });
  }
  reveal(item) {
    const idx = this._items.indexOf(item);
    if (idx >= 0) {
      this._reveal(idx, false);
    }
  }
  revealLast() {
    this._reveal(this._items.length - 1, false);
  }
  _reveal(nth, minimal) {
    if (nth < 0 || nth >= this._nodes.length) {
      return;
    }
    const node = this._nodes[nth];
    if (!node) {
      return;
    }
    const { width } = this._scrollable.getScrollDimensions();
    const { scrollLeft } = this._scrollable.getScrollPosition();
    if (!minimal || node.offsetLeft > scrollLeft + width || node.offsetLeft < scrollLeft) {
      this._scrollable.setRevealOnScroll(false);
      this._scrollable.setScrollPosition({ scrollLeft: node.offsetLeft });
      this._scrollable.setRevealOnScroll(true);
    }
  }
  getSelection() {
    return this._items[this._selectedItemIdx];
  }
  setSelection(item, payload) {
    this._select(this._items.indexOf(item), payload);
  }
  _select(nth, payload) {
    this._selectedItemIdx = -1;
    for (let i = 0; i < this._nodes.length; i++) {
      const node = this._nodes[i];
      if (i !== nth) {
        node.classList.remove("selected");
      } else {
        this._selectedItemIdx = i;
        node.classList.add("selected");
      }
    }
    this._onDidSelectItem.fire({ type: "select", item: this._items[this._selectedItemIdx], node: this._nodes[this._selectedItemIdx], payload });
  }
  getItems() {
    return this._items;
  }
  setItems(items) {
    let prefix;
    let removed = [];
    try {
      prefix = commonPrefixLength(this._items, items, (a, b) => a.equals(b));
      removed = this._items.splice(prefix, this._items.length - prefix, ...items.slice(prefix));
      this._render(prefix);
      dispose(removed);
      this._focus(-1, void 0);
    } catch (e) {
      const newError = new Error(`BreadcrumbsItem#setItems: newItems: ${items.length}, prefix: ${prefix}, removed: ${removed.length}`);
      newError.name = e.name;
      newError.stack = e.stack;
      throw newError;
    }
  }
  _render(start) {
    let didChange = false;
    for (; start < this._items.length && start < this._nodes.length; start++) {
      const item = this._items[start];
      const node = this._nodes[start];
      this._renderItem(item, node);
      didChange = true;
    }
    while (start < this._nodes.length) {
      const free = this._nodes.pop();
      if (free) {
        this._freeNodes.push(free);
        free.remove();
        didChange = true;
      }
    }
    for (; start < this._items.length; start++) {
      const item = this._items[start];
      const node = this._freeNodes.length > 0 ? this._freeNodes.pop() : document.createElement("div");
      if (node) {
        this._renderItem(item, node);
        this._domNode.appendChild(node);
        this._nodes.push(node);
        didChange = true;
      }
    }
    if (didChange) {
      this.layout(void 0);
    }
  }
  _renderItem(item, container) {
    clearNode(container);
    container.className = "";
    try {
      item.render(container);
    } catch (err) {
      container.innerText = "<<RENDER ERROR>>";
      console.error(err);
    }
    container.tabIndex = -1;
    container.setAttribute("role", "listitem");
    container.classList.add("monaco-breadcrumb-item");
    const iconContainer = $$2(ThemeIcon.asCSSSelector(this._separatorIcon));
    container.appendChild(iconContainer);
  }
  _onClick(event) {
    if (!this._enabled) {
      return;
    }
    for (let el = event.target; el; el = el.parentElement) {
      const idx = this._nodes.indexOf(el);
      if (idx >= 0) {
        this._focus(idx, event);
        this._select(idx, event);
        break;
      }
    }
  }
}
var css$b = ".monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control.hidden{display:none}.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.focused .hint-more,.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.focused .monaco-icon-label,.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.selected .hint-more,.monaco-workbench .part.editor>.content .editor-group-container .breadcrumbs-control .monaco-breadcrumb-item.selected .monaco-icon-label{text-decoration-line:underline}.monaco-workbench .monaco-breadcrumb-item.shows-symbol-icon .codicon[class*=codicon-symbol-]{padding-right:6px}.monaco-workbench .monaco-breadcrumbs-picker .arrow{border-style:solid;position:absolute;width:0}.monaco-workbench .monaco-breadcrumbs-picker .picker-item{flex:1;line-height:22px}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree{display:flex;flex-direction:column;height:100%;overflow:hidden}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree>.input{box-sizing:border-box;height:36px;padding:5px 9px;position:relative}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree>.tree{height:calc(100% - 36px)}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree.inactive>.input{display:none}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree.inactive>.tree{height:100%}.monaco-workbench .monaco-breadcrumbs-picker .highlighting-tree .monaco-highlighted-label .highlight{font-weight:700}";
n(css$b, {});
class FileElement {
  constructor(uri, kind) {
    this.uri = uri;
    this.kind = kind;
  }
}
class OutlineElement2 {
  constructor(element, outline) {
    this.element = element;
    this.outline = outline;
  }
}
let BreadcrumbsModel = class BreadcrumbsModel2 {
  constructor(resource, editor, configurationService, _workspaceService, _outlineService) {
    this.resource = resource;
    this._workspaceService = _workspaceService;
    this._outlineService = _outlineService;
    this._disposables = new DisposableStore();
    this._currentOutline = new MutableDisposable();
    this._outlineDisposables = new DisposableStore();
    this._onDidUpdate = new Emitter();
    this.onDidUpdate = this._onDidUpdate.event;
    this._cfgFilePath = BreadcrumbsConfig.FilePath.bindTo(configurationService);
    this._cfgSymbolPath = BreadcrumbsConfig.SymbolPath.bindTo(configurationService);
    this._disposables.add(this._cfgFilePath.onDidChange((_) => this._onDidUpdate.fire(this)));
    this._disposables.add(this._cfgSymbolPath.onDidChange((_) => this._onDidUpdate.fire(this)));
    this._workspaceService.onDidChangeWorkspaceFolders(this._onDidChangeWorkspaceFolders, this, this._disposables);
    this._fileInfo = this._initFilePathInfo(resource);
    if (editor) {
      this._bindToEditor(editor);
      this._disposables.add(_outlineService.onDidChange(() => this._bindToEditor(editor)));
      this._disposables.add(editor.onDidChangeControl(() => this._bindToEditor(editor)));
    }
    this._onDidUpdate.fire(this);
  }
  dispose() {
    this._disposables.dispose();
    this._cfgFilePath.dispose();
    this._cfgSymbolPath.dispose();
    this._currentOutline.dispose();
    this._outlineDisposables.dispose();
    this._onDidUpdate.dispose();
  }
  isRelative() {
    return Boolean(this._fileInfo.folder);
  }
  getElements() {
    let result = [];
    if (this._cfgFilePath.getValue() === "on") {
      result = result.concat(this._fileInfo.path);
    } else if (this._cfgFilePath.getValue() === "last" && this._fileInfo.path.length > 0) {
      result = result.concat(this._fileInfo.path.slice(-1));
    }
    if (this._cfgSymbolPath.getValue() === "off") {
      return result;
    }
    if (!this._currentOutline.value) {
      return result;
    }
    const breadcrumbsElements = this._currentOutline.value.config.breadcrumbsDataSource.getBreadcrumbElements();
    for (let i = this._cfgSymbolPath.getValue() === "last" && breadcrumbsElements.length > 0 ? breadcrumbsElements.length - 1 : 0; i < breadcrumbsElements.length; i++) {
      result.push(new OutlineElement2(breadcrumbsElements[i], this._currentOutline.value));
    }
    if (breadcrumbsElements.length === 0 && !this._currentOutline.value.isEmpty) {
      result.push(new OutlineElement2(this._currentOutline.value, this._currentOutline.value));
    }
    return result;
  }
  _initFilePathInfo(uri) {
    if (matchesSomeScheme(uri, Schemas.untitled, Schemas.data)) {
      return {
        folder: void 0,
        path: []
      };
    }
    const info = {
      folder: withNullAsUndefined(this._workspaceService.getWorkspaceFolder(uri)),
      path: []
    };
    let uriPrefix = uri;
    while (uriPrefix && uriPrefix.path !== "/") {
      if (info.folder && isEqual(info.folder.uri, uriPrefix)) {
        break;
      }
      info.path.unshift(new FileElement(uriPrefix, info.path.length === 0 ? FileKind.FILE : FileKind.FOLDER));
      const prevPathLength = uriPrefix.path.length;
      uriPrefix = dirname(uriPrefix);
      if (uriPrefix.path.length === prevPathLength) {
        break;
      }
    }
    if (info.folder && this._workspaceService.getWorkbenchState() === 3) {
      info.path.unshift(new FileElement(info.folder.uri, FileKind.ROOT_FOLDER));
    }
    return info;
  }
  _onDidChangeWorkspaceFolders() {
    this._fileInfo = this._initFilePathInfo(this.resource);
    this._onDidUpdate.fire(this);
  }
  _bindToEditor(editor) {
    const newCts = new CancellationTokenSource();
    this._currentOutline.clear();
    this._outlineDisposables.clear();
    this._outlineDisposables.add(toDisposable(() => newCts.dispose(true)));
    this._outlineService.createOutline(editor, 2, newCts.token).then((outline) => {
      if (newCts.token.isCancellationRequested) {
        outline == null ? void 0 : outline.dispose();
        outline = void 0;
      }
      this._currentOutline.value = outline;
      this._onDidUpdate.fire(this);
      if (outline) {
        this._outlineDisposables.add(outline.onDidChange(() => this._onDidUpdate.fire(this)));
      }
    }).catch((err) => {
      this._onDidUpdate.fire(this);
      onUnexpectedError(err);
    });
  }
};
BreadcrumbsModel = __decorate([
  __param(2, IConfigurationService),
  __param(3, IWorkspaceContextService),
  __param(4, IOutlineService)
], BreadcrumbsModel);
let BreadcrumbsPicker = class BreadcrumbsPicker2 {
  constructor(parent, resource, _instantiationService, _themeService, _configurationService) {
    this.resource = resource;
    this._instantiationService = _instantiationService;
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._disposables = new DisposableStore();
    this._fakeEvent = new UIEvent("fakeEvent");
    this._onWillPickElement = new Emitter();
    this.onWillPickElement = this._onWillPickElement.event;
    this._previewDispoables = new MutableDisposable();
    this._domNode = document.createElement("div");
    this._domNode.className = "monaco-breadcrumbs-picker show-file-icons";
    parent.appendChild(this._domNode);
  }
  dispose() {
    this._disposables.dispose();
    this._previewDispoables.dispose();
    this._onWillPickElement.dispose();
    this._domNode.remove();
    setTimeout(() => this._tree.dispose(), 0);
  }
  async show(input, maxHeight, width, arrowSize, arrowOffset) {
    const theme = this._themeService.getColorTheme();
    const color = theme.getColor(breadcrumbsPickerBackground);
    this._arrow = document.createElement("div");
    this._arrow.className = "arrow";
    this._arrow.style.borderColor = `transparent transparent ${color ? color.toString() : ""}`;
    this._domNode.appendChild(this._arrow);
    this._treeContainer = document.createElement("div");
    this._treeContainer.style.background = color ? color.toString() : "";
    this._treeContainer.style.paddingTop = "2px";
    this._treeContainer.style.borderRadius = "3px";
    this._treeContainer.style.boxShadow = `0 0 8px 2px ${this._themeService.getColorTheme().getColor(widgetShadow)}`;
    this._treeContainer.style.border = `1px solid ${this._themeService.getColorTheme().getColor(widgetBorder)}`;
    this._domNode.appendChild(this._treeContainer);
    this._layoutInfo = { maxHeight, width, arrowSize, arrowOffset, inputHeight: 0 };
    this._tree = this._createTree(this._treeContainer, input);
    this._disposables.add(this._tree.onDidOpen(async (e) => {
      const { element, editorOptions, sideBySide } = e;
      const didReveal = await this._revealElement(element, { ...editorOptions, preserveFocus: false }, sideBySide);
      if (!didReveal) {
        return;
      }
    }));
    this._disposables.add(this._tree.onDidChangeFocus((e) => {
      this._previewDispoables.value = this._previewElement(e.elements[0]);
    }));
    this._disposables.add(this._tree.onDidChangeContentHeight(() => {
      this._layout();
    }));
    this._domNode.focus();
    try {
      await this._setInput(input);
      this._layout();
    } catch (err) {
      onUnexpectedError(err);
    }
  }
  _layout() {
    const headerHeight = 2 * this._layoutInfo.arrowSize;
    const treeHeight = Math.min(this._layoutInfo.maxHeight - headerHeight, this._tree.contentHeight);
    const totalHeight = treeHeight + headerHeight;
    this._domNode.style.height = `${totalHeight}px`;
    this._domNode.style.width = `${this._layoutInfo.width}px`;
    this._arrow.style.top = `-${2 * this._layoutInfo.arrowSize}px`;
    this._arrow.style.borderWidth = `${this._layoutInfo.arrowSize}px`;
    this._arrow.style.marginLeft = `${this._layoutInfo.arrowOffset}px`;
    this._treeContainer.style.height = `${treeHeight}px`;
    this._treeContainer.style.width = `${this._layoutInfo.width}px`;
    this._tree.layout(treeHeight, this._layoutInfo.width);
  }
  restoreViewState() {
  }
};
BreadcrumbsPicker = __decorate([
  __param(2, IInstantiationService),
  __param(3, IThemeService),
  __param(4, IConfigurationService)
], BreadcrumbsPicker);
class FileVirtualDelegate {
  getHeight(_element) {
    return 22;
  }
  getTemplateId(_element) {
    return "FileStat";
  }
}
class FileIdentityProvider {
  getId(element) {
    if (URI.isUri(element)) {
      return element.toString();
    } else if (isWorkspace(element)) {
      return element.id;
    } else if (isWorkspaceFolder(element)) {
      return element.uri.toString();
    } else {
      return element.resource.toString();
    }
  }
}
let FileDataSource = class FileDataSource2 {
  constructor(_fileService) {
    this._fileService = _fileService;
  }
  hasChildren(element) {
    return URI.isUri(element) || isWorkspace(element) || isWorkspaceFolder(element) || element.isDirectory;
  }
  async getChildren(element) {
    if (isWorkspace(element)) {
      return element.folders;
    }
    let uri;
    if (isWorkspaceFolder(element)) {
      uri = element.uri;
    } else if (URI.isUri(element)) {
      uri = element;
    } else {
      uri = element.resource;
    }
    const stat = await this._fileService.resolve(uri);
    return stat.children ?? [];
  }
};
FileDataSource = __decorate([
  __param(0, IFileService)
], FileDataSource);
let FileRenderer = class FileRenderer2 {
  constructor(_labels, _configService) {
    this._labels = _labels;
    this._configService = _configService;
    this.templateId = "FileStat";
  }
  renderTemplate(container) {
    return this._labels.create(container, { supportHighlights: true });
  }
  renderElement(node, index, templateData) {
    const fileDecorations = this._configService.getValue("explorer.decorations");
    const { element } = node;
    let resource;
    let fileKind;
    if (isWorkspaceFolder(element)) {
      resource = element.uri;
      fileKind = FileKind.ROOT_FOLDER;
    } else {
      resource = element.resource;
      fileKind = element.isDirectory ? FileKind.FOLDER : FileKind.FILE;
    }
    templateData.setFile(resource, {
      fileKind,
      hidePath: true,
      fileDecorations,
      matches: createMatches(node.filterData),
      extraClasses: ["picker-item"]
    });
  }
  disposeTemplate(templateData) {
    templateData.dispose();
  }
};
FileRenderer = __decorate([
  __param(1, IConfigurationService)
], FileRenderer);
class FileNavigationLabelProvider {
  getKeyboardNavigationLabel(element) {
    return element.name;
  }
}
class FileAccessibilityProvider {
  getWidgetAriaLabel() {
    return localize("breadcrumbs", "Breadcrumbs");
  }
  getAriaLabel(element) {
    return element.name;
  }
}
let FileFilter = class FileFilter2 {
  constructor(_workspaceService, configService) {
    this._workspaceService = _workspaceService;
    this._cachedExpressions = /* @__PURE__ */ new Map();
    this._disposables = new DisposableStore();
    const config = BreadcrumbsConfig.FileExcludes.bindTo(configService);
    const update = () => {
      _workspaceService.getWorkspace().folders.forEach((folder) => {
        const excludesConfig = config.getValue({ resource: folder.uri });
        if (!excludesConfig) {
          return;
        }
        const adjustedConfig = {};
        for (const pattern in excludesConfig) {
          if (typeof excludesConfig[pattern] !== "boolean") {
            continue;
          }
          const patternAbs = pattern.indexOf("**/") !== 0 ? posix.join(folder.uri.path, pattern) : pattern;
          adjustedConfig[patternAbs] = excludesConfig[pattern];
        }
        this._cachedExpressions.set(folder.uri.toString(), parse(adjustedConfig));
      });
    };
    update();
    this._disposables.add(config);
    this._disposables.add(config.onDidChange(update));
    this._disposables.add(_workspaceService.onDidChangeWorkspaceFolders(update));
  }
  dispose() {
    this._disposables.dispose();
  }
  filter(element, _parentVisibility) {
    if (isWorkspaceFolder(element)) {
      return true;
    }
    const folder = this._workspaceService.getWorkspaceFolder(element.resource);
    if (!folder || !this._cachedExpressions.has(folder.uri.toString())) {
      return true;
    }
    const expression = this._cachedExpressions.get(folder.uri.toString());
    return !expression(relative(folder.uri.path, element.resource.path), basename(element.resource));
  }
};
FileFilter = __decorate([
  __param(0, IWorkspaceContextService),
  __param(1, IConfigurationService)
], FileFilter);
class FileSorter {
  compare(a, b) {
    if (isWorkspaceFolder(a) && isWorkspaceFolder(b)) {
      return a.index - b.index;
    }
    if (a.isDirectory === b.isDirectory) {
      return compareFileNames(a.name, b.name);
    } else if (a.isDirectory) {
      return -1;
    } else {
      return 1;
    }
  }
}
let BreadcrumbsFilePicker = class BreadcrumbsFilePicker2 extends BreadcrumbsPicker {
  constructor(parent, resource, instantiationService, themeService, configService, _workspaceService, _editorService) {
    super(parent, resource, instantiationService, themeService, configService);
    this._workspaceService = _workspaceService;
    this._editorService = _editorService;
  }
  _createTree(container) {
    this._treeContainer.classList.add("file-icon-themable-tree");
    this._treeContainer.classList.add("show-file-icons");
    const onFileIconThemeChange = (fileIconTheme) => {
      this._treeContainer.classList.toggle("align-icons-and-twisties", fileIconTheme.hasFileIcons && !fileIconTheme.hasFolderIcons);
      this._treeContainer.classList.toggle("hide-arrows", fileIconTheme.hidesExplorerArrows === true);
    };
    this._disposables.add(this._themeService.onDidFileIconThemeChange(onFileIconThemeChange));
    onFileIconThemeChange(this._themeService.getFileIconTheme());
    const labels = this._instantiationService.createInstance(ResourceLabels, DEFAULT_LABELS_CONTAINER);
    this._disposables.add(labels);
    return this._instantiationService.createInstance(WorkbenchAsyncDataTree, "BreadcrumbsFilePicker", container, new FileVirtualDelegate(), [this._instantiationService.createInstance(FileRenderer, labels)], this._instantiationService.createInstance(FileDataSource), {
      multipleSelectionSupport: false,
      sorter: new FileSorter(),
      filter: this._instantiationService.createInstance(FileFilter),
      identityProvider: new FileIdentityProvider(),
      keyboardNavigationLabelProvider: new FileNavigationLabelProvider(),
      accessibilityProvider: this._instantiationService.createInstance(FileAccessibilityProvider),
      showNotFoundMessage: false,
      overrideStyles: {
        listBackground: breadcrumbsPickerBackground
      }
    });
  }
  async _setInput(element) {
    const { uri, kind } = element;
    let input;
    if (kind === FileKind.ROOT_FOLDER) {
      input = this._workspaceService.getWorkspace();
    } else {
      input = dirname(uri);
    }
    const tree = this._tree;
    await tree.setInput(input);
    let focusElement;
    for (const { element: element2 } of tree.getNode().children) {
      if (isWorkspaceFolder(element2) && isEqual(element2.uri, uri)) {
        focusElement = element2;
        break;
      } else if (isEqual(element2.resource, uri)) {
        focusElement = element2;
        break;
      }
    }
    if (focusElement) {
      tree.reveal(focusElement, 0.5);
      tree.setFocus([focusElement], this._fakeEvent);
    }
    tree.domFocus();
  }
  _previewElement(_element) {
    return Disposable.None;
  }
  async _revealElement(element, options, sideBySide) {
    if (!isWorkspaceFolder(element) && element.isFile) {
      this._onWillPickElement.fire();
      await this._editorService.openEditor({ resource: element.resource, options }, sideBySide ? SIDE_GROUP : void 0);
      return true;
    }
    return false;
  }
};
BreadcrumbsFilePicker = __decorate([
  __param(2, IInstantiationService),
  __param(3, IThemeService),
  __param(4, IConfigurationService),
  __param(5, IWorkspaceContextService),
  __param(6, IEditorService)
], BreadcrumbsFilePicker);
let OutlineTreeSorter$1 = class OutlineTreeSorter {
  constructor(comparator, uri, configService) {
    this.comparator = comparator;
    this._order = configService.getValue(uri, "breadcrumbs.symbolSortOrder");
  }
  compare(a, b) {
    if (this._order === "name") {
      return this.comparator.compareByName(a, b);
    } else if (this._order === "type") {
      return this.comparator.compareByType(a, b);
    } else {
      return this.comparator.compareByPosition(a, b);
    }
  }
};
OutlineTreeSorter$1 = __decorate([
  __param(2, ITextResourceConfigurationService)
], OutlineTreeSorter$1);
class BreadcrumbsOutlinePicker extends BreadcrumbsPicker {
  _createTree(container, input) {
    const { config } = input.outline;
    return this._instantiationService.createInstance(WorkbenchDataTree, "BreadcrumbsOutlinePicker", container, config.delegate, config.renderers, config.treeDataSource, {
      ...config.options,
      sorter: this._instantiationService.createInstance(OutlineTreeSorter$1, config.comparator, void 0),
      collapseByDefault: true,
      expandOnlyOnTwistieClick: true,
      multipleSelectionSupport: false,
      showNotFoundMessage: false
    });
  }
  _setInput(input) {
    const viewState = input.outline.captureViewState();
    this.restoreViewState = () => {
      viewState.dispose();
    };
    const tree = this._tree;
    tree.setInput(input.outline);
    if (input.element !== input.outline) {
      tree.reveal(input.element, 0.5);
      tree.setFocus([input.element], this._fakeEvent);
    }
    tree.domFocus();
    return Promise.resolve();
  }
  _previewElement(element) {
    const outline = this._tree.getInput();
    return outline.preview(element);
  }
  async _revealElement(element, options, sideBySide) {
    this._onWillPickElement.fire();
    const outline = this._tree.getInput();
    await outline.reveal(element, options, sideBySide);
    return true;
  }
}
class OutlineItem extends BreadcrumbsItem {
  constructor(model, element, options) {
    super();
    this.model = model;
    this.element = element;
    this.options = options;
    this._disposables = new DisposableStore();
  }
  dispose() {
    this._disposables.dispose();
  }
  equals(other) {
    if (!(other instanceof OutlineItem)) {
      return false;
    }
    return this.element.element === other.element.element && this.options.showFileIcons === other.options.showFileIcons && this.options.showSymbolIcons === other.options.showSymbolIcons;
  }
  render(container) {
    const { element, outline } = this.element;
    if (element === outline) {
      const element2 = $$2("span", void 0, "…");
      container.appendChild(element2);
      return;
    }
    const templateId = outline.config.delegate.getTemplateId(element);
    const renderer = outline.config.renderers.find((renderer2) => renderer2.templateId === templateId);
    if (!renderer) {
      container.innerText = "<<NO RENDERER>>";
      return;
    }
    const template = renderer.renderTemplate(container);
    renderer.renderElement({
      element,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: 0,
      collapsible: false,
      collapsed: false,
      visible: true,
      filterData: void 0
    }, 0, template, void 0);
    this._disposables.add(toDisposable(() => {
      renderer.disposeTemplate(template);
    }));
  }
}
class FileItem extends BreadcrumbsItem {
  constructor(model, element, options, _labels) {
    super();
    this.model = model;
    this.element = element;
    this.options = options;
    this._labels = _labels;
    this._disposables = new DisposableStore();
  }
  dispose() {
    this._disposables.dispose();
  }
  equals(other) {
    if (!(other instanceof FileItem)) {
      return false;
    }
    return extUri.isEqual(this.element.uri, other.element.uri) && this.options.showFileIcons === other.options.showFileIcons && this.options.showSymbolIcons === other.options.showSymbolIcons;
  }
  render(container) {
    const label = this._labels.create(container);
    label.setFile(this.element.uri, {
      hidePath: true,
      hideIcon: this.element.kind === FileKind.FOLDER || !this.options.showFileIcons,
      fileKind: this.element.kind,
      fileDecorations: { colors: this.options.showDecorationColors, badges: false }
    });
    container.classList.add(FileKind[this.element.kind].toLowerCase());
    this._disposables.add(label);
  }
}
const separatorIcon = registerIcon("breadcrumb-separator", Codicon.chevronRight, localize("separatorIcon", "Icon for the separator in the breadcrumbs."));
let BreadcrumbsControl = (_j = class {
  constructor(container, _options, _editorGroup, _contextKeyService, _contextViewService, _instantiationService, _quickInputService, _fileService, _editorService, _labelService, configurationService, breadcrumbsService) {
    this._options = _options;
    this._editorGroup = _editorGroup;
    this._contextKeyService = _contextKeyService;
    this._contextViewService = _contextViewService;
    this._instantiationService = _instantiationService;
    this._quickInputService = _quickInputService;
    this._fileService = _fileService;
    this._editorService = _editorService;
    this._labelService = _labelService;
    this._disposables = new DisposableStore();
    this._breadcrumbsDisposables = new DisposableStore();
    this._model = new MutableDisposable();
    this._breadcrumbsPickerShowing = false;
    this.domNode = document.createElement("div");
    this.domNode.classList.add("breadcrumbs-control");
    append(container, this.domNode);
    this._cfUseQuickPick = BreadcrumbsConfig.UseQuickPick.bindTo(configurationService);
    this._cfShowIcons = BreadcrumbsConfig.Icons.bindTo(configurationService);
    this._cfTitleScrollbarSizing = BreadcrumbsConfig.TitleScrollbarSizing.bindTo(configurationService);
    this._labels = this._instantiationService.createInstance(ResourceLabels, DEFAULT_LABELS_CONTAINER);
    const sizing = this._cfTitleScrollbarSizing.getValue() ?? "default";
    const styles = _options.widgetStyles ?? defaultBreadcrumbsWidgetStyles;
    this._widget = new BreadcrumbsWidget(
      this.domNode,
      _j.SCROLLBAR_SIZES[sizing],
      separatorIcon,
      styles
    );
    this._widget.onDidSelectItem(this._onSelectEvent, this, this._disposables);
    this._widget.onDidFocusItem(this._onFocusEvent, this, this._disposables);
    this._widget.onDidChangeFocus(this._updateCkBreadcrumbsActive, this, this._disposables);
    this._ckBreadcrumbsPossible = _j.CK_BreadcrumbsPossible.bindTo(this._contextKeyService);
    this._ckBreadcrumbsVisible = _j.CK_BreadcrumbsVisible.bindTo(this._contextKeyService);
    this._ckBreadcrumbsActive = _j.CK_BreadcrumbsActive.bindTo(this._contextKeyService);
    this._disposables.add(breadcrumbsService.register(this._editorGroup.id, this._widget));
    this.hide();
  }
  dispose() {
    this._disposables.dispose();
    this._breadcrumbsDisposables.dispose();
    this._ckBreadcrumbsPossible.reset();
    this._ckBreadcrumbsVisible.reset();
    this._ckBreadcrumbsActive.reset();
    this._cfUseQuickPick.dispose();
    this._cfShowIcons.dispose();
    this._widget.dispose();
    this._labels.dispose();
    this.domNode.remove();
  }
  get model() {
    return this._model.value;
  }
  layout(dim) {
    this._widget.layout(dim);
  }
  isHidden() {
    return this.domNode.classList.contains("hidden");
  }
  hide() {
    this._breadcrumbsDisposables.clear();
    this._ckBreadcrumbsVisible.set(false);
    this.domNode.classList.toggle("hidden", true);
  }
  revealLast() {
    this._widget.revealLast();
  }
  update() {
    this._breadcrumbsDisposables.clear();
    const uri = EditorResourceAccessor.getCanonicalUri(this._editorGroup.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
    const wasHidden = this.isHidden();
    if (!uri || !this._fileService.hasProvider(uri)) {
      this._ckBreadcrumbsPossible.set(false);
      if (!wasHidden) {
        this.hide();
        return true;
      } else {
        return false;
      }
    }
    const fileInfoUri = EditorResourceAccessor.getOriginalUri(this._editorGroup.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
    this.domNode.classList.toggle("hidden", false);
    this._ckBreadcrumbsVisible.set(true);
    this._ckBreadcrumbsPossible.set(true);
    const model = this._instantiationService.createInstance(BreadcrumbsModel, fileInfoUri ?? uri, this._editorGroup.activeEditorPane);
    this._model.value = model;
    this.domNode.classList.toggle("backslash-path", this._labelService.getSeparator(uri.scheme, uri.authority) === "\\");
    const updateBreadcrumbs = () => {
      this.domNode.classList.toggle("relative-path", model.isRelative());
      const showIcons = this._cfShowIcons.getValue();
      const options = {
        ...this._options,
        showFileIcons: this._options.showFileIcons && showIcons,
        showSymbolIcons: this._options.showSymbolIcons && showIcons
      };
      const items = model.getElements().map((element) => element instanceof FileElement ? new FileItem(model, element, options, this._labels) : new OutlineItem(model, element, options));
      if (items.length === 0) {
        this._widget.setEnabled(false);
        this._widget.setItems([new class extends BreadcrumbsItem {
          render(container) {
            container.innerText = localize("empty", "no elements");
          }
          equals(other) {
            return other === this;
          }
        }()]);
      } else {
        this._widget.setEnabled(true);
        this._widget.setItems(items);
        this._widget.reveal(items[items.length - 1]);
      }
    };
    const listener = model.onDidUpdate(updateBreadcrumbs);
    const configListener = this._cfShowIcons.onDidChange(updateBreadcrumbs);
    updateBreadcrumbs();
    this._breadcrumbsDisposables.clear();
    this._breadcrumbsDisposables.add(listener);
    this._breadcrumbsDisposables.add(toDisposable(() => this._model.clear()));
    this._breadcrumbsDisposables.add(configListener);
    this._breadcrumbsDisposables.add(toDisposable(() => this._widget.setItems([])));
    const updateScrollbarSizing = () => {
      const sizing = this._cfTitleScrollbarSizing.getValue() ?? "default";
      this._widget.setHorizontalScrollbarSize(_j.SCROLLBAR_SIZES[sizing]);
    };
    updateScrollbarSizing();
    const updateScrollbarSizeListener = this._cfTitleScrollbarSizing.onDidChange(updateScrollbarSizing);
    this._breadcrumbsDisposables.add(updateScrollbarSizeListener);
    this._breadcrumbsDisposables.add({
      dispose: () => {
        if (this._breadcrumbsPickerShowing) {
          this._contextViewService.hideContextView({ source: this });
        }
      }
    });
    return wasHidden !== this.isHidden();
  }
  _onFocusEvent(event) {
    if (event.item && this._breadcrumbsPickerShowing) {
      this._breadcrumbsPickerIgnoreOnceItem = void 0;
      this._widget.setSelection(event.item);
    }
  }
  _onSelectEvent(event) {
    if (!event.item) {
      return;
    }
    if (event.item === this._breadcrumbsPickerIgnoreOnceItem) {
      this._breadcrumbsPickerIgnoreOnceItem = void 0;
      this._widget.setFocused(void 0);
      this._widget.setSelection(void 0);
      return;
    }
    const { element } = event.item;
    this._editorGroup.focus();
    const group = this._getEditorGroup(event.payload);
    if (group !== void 0) {
      this._widget.setFocused(void 0);
      this._widget.setSelection(void 0);
      this._revealInEditor(event, element, group);
      return;
    }
    if (this._cfUseQuickPick.getValue()) {
      this._widget.setFocused(void 0);
      this._widget.setSelection(void 0);
      this._quickInputService.quickAccess.show(element instanceof OutlineElement2 ? "@" : "");
      return;
    }
    let picker;
    let pickerAnchor;
    this._contextViewService.showContextView({
      render: (parent) => {
        if (event.item instanceof FileItem) {
          picker = this._instantiationService.createInstance(BreadcrumbsFilePicker, parent, event.item.model.resource);
        } else if (event.item instanceof OutlineItem) {
          picker = this._instantiationService.createInstance(BreadcrumbsOutlinePicker, parent, event.item.model.resource);
        }
        const selectListener = picker.onWillPickElement(() => this._contextViewService.hideContextView({ source: this, didPick: true }));
        const zoomListener = PixelRatio.onDidChange(() => this._contextViewService.hideContextView({ source: this }));
        const focusTracker = trackFocus(parent);
        const blurListener = focusTracker.onDidBlur(() => {
          this._breadcrumbsPickerIgnoreOnceItem = this._widget.isDOMFocused() ? event.item : void 0;
          this._contextViewService.hideContextView({ source: this });
        });
        this._breadcrumbsPickerShowing = true;
        this._updateCkBreadcrumbsActive();
        return combinedDisposable(picker, selectListener, zoomListener, focusTracker, blurListener);
      },
      getAnchor: () => {
        if (!pickerAnchor) {
          const maxInnerWidth = window.innerWidth - 8;
          let maxHeight = Math.min(window.innerHeight * 0.7, 300);
          const pickerWidth = Math.min(maxInnerWidth, Math.max(240, maxInnerWidth / 4.17));
          const pickerArrowSize = 8;
          let pickerArrowOffset;
          const data = getDomNodePagePosition(event.node.firstChild);
          const y = data.top + data.height + pickerArrowSize;
          if (y + maxHeight >= window.innerHeight) {
            maxHeight = window.innerHeight - y - 30;
          }
          let x = data.left;
          if (x + pickerWidth >= maxInnerWidth) {
            x = maxInnerWidth - pickerWidth;
          }
          if (event.payload instanceof StandardMouseEvent) {
            const maxPickerArrowOffset = pickerWidth - 2 * pickerArrowSize;
            pickerArrowOffset = event.payload.posx - x;
            if (pickerArrowOffset > maxPickerArrowOffset) {
              x = Math.min(maxInnerWidth - pickerWidth, x + pickerArrowOffset - maxPickerArrowOffset);
              pickerArrowOffset = maxPickerArrowOffset;
            }
          } else {
            pickerArrowOffset = data.left + data.width * 0.3 - x;
          }
          picker.show(element, maxHeight, pickerWidth, pickerArrowSize, Math.max(0, pickerArrowOffset));
          pickerAnchor = { x, y };
        }
        return pickerAnchor;
      },
      onHide: (data) => {
        if (!(data == null ? void 0 : data.didPick)) {
          picker.restoreViewState();
        }
        this._breadcrumbsPickerShowing = false;
        this._updateCkBreadcrumbsActive();
        if ((data == null ? void 0 : data.source) === this) {
          this._widget.setFocused(void 0);
          this._widget.setSelection(void 0);
        }
        picker.dispose();
      }
    });
  }
  _updateCkBreadcrumbsActive() {
    const value = this._widget.isDOMFocused() || this._breadcrumbsPickerShowing;
    this._ckBreadcrumbsActive.set(value);
  }
  async _revealInEditor(event, element, group, pinned = false) {
    if (element instanceof FileElement) {
      if (element.kind === FileKind.FILE) {
        await this._editorService.openEditor({ resource: element.uri, options: { pinned } }, group);
      } else {
        const items = this._widget.getItems();
        const idx = items.indexOf(event.item);
        this._widget.setFocused(items[idx + 1]);
        this._widget.setSelection(items[idx + 1], _j.Payload_Pick);
      }
    } else {
      element.outline.reveal(element, { pinned }, group === SIDE_GROUP);
    }
  }
  _getEditorGroup(data) {
    if (data === _j.Payload_RevealAside) {
      return SIDE_GROUP;
    } else if (data === _j.Payload_Reveal) {
      return ACTIVE_GROUP;
    } else {
      return void 0;
    }
  }
}, _j.HEIGHT = 22, _j.SCROLLBAR_SIZES = {
  default: 3,
  large: 8
}, _j.Payload_Reveal = {}, _j.Payload_RevealAside = {}, _j.Payload_Pick = {}, _j.CK_BreadcrumbsPossible = new RawContextKey("breadcrumbsPossible", false, localize("breadcrumbsPossible", "Whether the editor can show breadcrumbs")), _j.CK_BreadcrumbsVisible = new RawContextKey("breadcrumbsVisible", false, localize("breadcrumbsVisible", "Whether breadcrumbs are currently visible")), _j.CK_BreadcrumbsActive = new RawContextKey("breadcrumbsActive", false, localize("breadcrumbsActive", "Whether breadcrumbs have focus")), _j);
BreadcrumbsControl = __decorate([
  __param(3, IContextKeyService),
  __param(4, IContextViewService),
  __param(5, IInstantiationService),
  __param(6, IQuickInputService),
  __param(7, IFileService),
  __param(8, IEditorService),
  __param(9, ILabelService),
  __param(10, IConfigurationService),
  __param(11, IBreadcrumbsService)
], BreadcrumbsControl);
registerAction2(class ToggleBreadcrumb extends Action2 {
  constructor() {
    super({
      id: "breadcrumbs.toggle",
      title: {
        value: localize("cmd.toggle", "Toggle Breadcrumbs"),
        mnemonicTitle: localize(
          { key: "miBreadcrumbs", comment: ["&& denotes a mnemonic"] },
          "Toggle &&Breadcrumbs"
        ),
        original: "Toggle Breadcrumbs"
      },
      category: Categories.View,
      toggled: {
        condition: ContextKeyExpr.equals("config.breadcrumbs.enabled", true),
        title: localize("cmd.toggle2", "Breadcrumbs"),
        mnemonicTitle: localize(
          { key: "miBreadcrumbs2", comment: ["&& denotes a mnemonic"] },
          "&&Breadcrumbs"
        )
      },
      menu: [
        { id: MenuId.CommandPalette },
        { id: MenuId.MenubarAppearanceMenu, group: "4_editor", order: 2 },
        { id: MenuId.NotebookToolbar, group: "notebookLayout", order: 2 },
        { id: MenuId.StickyScrollContext }
      ]
    });
  }
  run(accessor) {
    const config = accessor.get(IConfigurationService);
    const value = BreadcrumbsConfig.IsEnabled.bindTo(config).getValue();
    BreadcrumbsConfig.IsEnabled.bindTo(config).updateValue(!value);
  }
});
function focusAndSelectHandler(accessor, select) {
  const groups = accessor.get(IEditorGroupsService);
  const breadcrumbs = accessor.get(IBreadcrumbsService);
  const widget = breadcrumbs.getWidget(groups.activeGroup.id);
  if (widget) {
    const item = tail(widget.getItems());
    widget.setFocused(item);
    if (select) {
      widget.setSelection(item, BreadcrumbsControl.Payload_Pick);
    }
  }
}
registerAction2(class FocusAndSelectBreadcrumbs extends Action2 {
  constructor() {
    super({
      id: "breadcrumbs.focusAndSelect",
      title: {
        value: localize("cmd.focusAndSelect", "Focus and Select Breadcrumbs"),
        original: "Focus and Select Breadcrumbs"
      },
      precondition: BreadcrumbsControl.CK_BreadcrumbsVisible,
      keybinding: {
        weight: 200,
        primary: 2048 | 1024 | 89,
        when: BreadcrumbsControl.CK_BreadcrumbsPossible
      },
      f1: true
    });
  }
  run(accessor, ...args) {
    focusAndSelectHandler(accessor, true);
  }
});
registerAction2(class FocusBreadcrumbs extends Action2 {
  constructor() {
    super({
      id: "breadcrumbs.focus",
      title: {
        value: localize("cmd.focus", "Focus Breadcrumbs"),
        original: "Focus Breadcrumbs"
      },
      precondition: BreadcrumbsControl.CK_BreadcrumbsVisible,
      keybinding: {
        weight: 200,
        primary: 2048 | 1024 | 85,
        when: BreadcrumbsControl.CK_BreadcrumbsPossible
      },
      f1: true
    });
  }
  run(accessor, ...args) {
    focusAndSelectHandler(accessor, false);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.toggleToOn",
  weight: 200,
  primary: 2048 | 1024 | 89,
  when: ContextKeyExpr.not("config.breadcrumbs.enabled"),
  handler: async (accessor) => {
    const instant = accessor.get(IInstantiationService);
    const config = accessor.get(IConfigurationService);
    const isEnabled = BreadcrumbsConfig.IsEnabled.bindTo(config);
    if (!isEnabled.getValue()) {
      await isEnabled.updateValue(true);
      await timeout(50);
    }
    return instant.invokeFunction(focusAndSelectHandler, true);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusNext",
  weight: 200,
  primary: 17,
  secondary: [2048 | 17],
  mac: {
    primary: 17,
    secondary: [512 | 17]
  },
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive
  ),
  handler(accessor) {
    const groups = accessor.get(IEditorGroupsService);
    const breadcrumbs = accessor.get(IBreadcrumbsService);
    const widget = breadcrumbs.getWidget(groups.activeGroup.id);
    if (!widget) {
      return;
    }
    widget.focusNext();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusPrevious",
  weight: 200,
  primary: 15,
  secondary: [2048 | 15],
  mac: {
    primary: 15,
    secondary: [512 | 15]
  },
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive
  ),
  handler(accessor) {
    const groups = accessor.get(IEditorGroupsService);
    const breadcrumbs = accessor.get(IBreadcrumbsService);
    const widget = breadcrumbs.getWidget(groups.activeGroup.id);
    if (!widget) {
      return;
    }
    widget.focusPrev();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusNextWithPicker",
  weight: 200 + 1,
  primary: 2048 | 17,
  mac: {
    primary: 512 | 17
  },
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive,
    WorkbenchListFocusContextKey
  ),
  handler(accessor) {
    const groups = accessor.get(IEditorGroupsService);
    const breadcrumbs = accessor.get(IBreadcrumbsService);
    const widget = breadcrumbs.getWidget(groups.activeGroup.id);
    if (!widget) {
      return;
    }
    widget.focusNext();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.focusPreviousWithPicker",
  weight: 200 + 1,
  primary: 2048 | 15,
  mac: {
    primary: 512 | 15
  },
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive,
    WorkbenchListFocusContextKey
  ),
  handler(accessor) {
    const groups = accessor.get(IEditorGroupsService);
    const breadcrumbs = accessor.get(IBreadcrumbsService);
    const widget = breadcrumbs.getWidget(groups.activeGroup.id);
    if (!widget) {
      return;
    }
    widget.focusPrev();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.selectFocused",
  weight: 200,
  primary: 3,
  secondary: [18],
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive
  ),
  handler(accessor) {
    const groups = accessor.get(IEditorGroupsService);
    const breadcrumbs = accessor.get(IBreadcrumbsService);
    const widget = breadcrumbs.getWidget(groups.activeGroup.id);
    if (!widget) {
      return;
    }
    widget.setSelection(widget.getFocused(), BreadcrumbsControl.Payload_Pick);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.revealFocused",
  weight: 200,
  primary: 10,
  secondary: [2048 | 3],
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive
  ),
  handler(accessor) {
    const groups = accessor.get(IEditorGroupsService);
    const breadcrumbs = accessor.get(IBreadcrumbsService);
    const widget = breadcrumbs.getWidget(groups.activeGroup.id);
    if (!widget) {
      return;
    }
    widget.setSelection(widget.getFocused(), BreadcrumbsControl.Payload_Reveal);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.selectEditor",
  weight: 200 + 1,
  primary: 9,
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive
  ),
  handler(accessor) {
    var _a2;
    const groups = accessor.get(IEditorGroupsService);
    const breadcrumbs = accessor.get(IBreadcrumbsService);
    const widget = breadcrumbs.getWidget(groups.activeGroup.id);
    if (!widget) {
      return;
    }
    widget.setFocused(void 0);
    widget.setSelection(void 0);
    (_a2 = groups.activeGroup.activeEditorPane) == null ? void 0 : _a2.focus();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "breadcrumbs.revealFocusedFromTreeAside",
  weight: 200,
  primary: 2048 | 3,
  when: ContextKeyExpr.and(
    BreadcrumbsControl.CK_BreadcrumbsVisible,
    BreadcrumbsControl.CK_BreadcrumbsActive,
    WorkbenchListFocusContextKey
  ),
  handler(accessor) {
    const editors = accessor.get(IEditorService);
    const lists = accessor.get(IListService);
    const tree = lists.lastFocusedList;
    if (!(tree instanceof WorkbenchDataTree) && !(tree instanceof WorkbenchAsyncDataTree)) {
      return;
    }
    const element = tree.getFocus()[0];
    if (URI.isUri(element == null ? void 0 : element.resource)) {
      return editors.openEditor({
        resource: element.resource,
        options: { pinned: true }
      }, SIDE_GROUP);
    }
    const input = tree.getInput();
    if (input && typeof input.outlineKind === "string") {
      return input.reveal(element, {
        pinned: true,
        preserveFocus: false
      }, true);
    }
  }
});
class EditorCommandsContextActionRunner extends ActionRunner {
  constructor(context) {
    super();
    this.context = context;
  }
  run(action, context) {
    let mergedContext = this.context;
    if (context == null ? void 0 : context.preserveFocus) {
      mergedContext = {
        ...this.context,
        preserveFocus: true
      };
    }
    return super.run(action, mergedContext);
  }
}
let TitleControl = class TitleControl2 extends Themable {
  constructor(parent, accessor, group, contextMenuService, instantiationService, contextKeyService, keybindingService, notificationService, menuService, quickInputService, themeService, configurationService, fileService, editorResolverService) {
    super(themeService);
    this.accessor = accessor;
    this.group = group;
    this.contextMenuService = contextMenuService;
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.keybindingService = keybindingService;
    this.notificationService = notificationService;
    this.menuService = menuService;
    this.quickInputService = quickInputService;
    this.configurationService = configurationService;
    this.fileService = fileService;
    this.editorResolverService = editorResolverService;
    this.editorTransfer = LocalSelectionTransfer.getInstance();
    this.groupTransfer = LocalSelectionTransfer.getInstance();
    this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
    this.breadcrumbsControl = void 0;
    this.editorToolBarMenuDisposables = this._register(new DisposableStore());
    this.resourceContext = this._register(instantiationService.createInstance(ResourceContextKey));
    this.editorPinnedContext = ActiveEditorPinnedContext.bindTo(contextKeyService);
    this.editorIsFirstContext = ActiveEditorFirstInGroupContext.bindTo(contextKeyService);
    this.editorIsLastContext = ActiveEditorLastInGroupContext.bindTo(contextKeyService);
    this.editorStickyContext = ActiveEditorStickyContext.bindTo(contextKeyService);
    this.editorAvailableEditorIds = ActiveEditorAvailableEditorIdsContext.bindTo(this.contextKeyService);
    this.editorCanSplitInGroupContext = ActiveEditorCanSplitInGroupContext.bindTo(contextKeyService);
    this.sideBySideEditorContext = SideBySideEditorActiveContext.bindTo(contextKeyService);
    this.groupLockedContext = ActiveEditorGroupLockedContext.bindTo(contextKeyService);
    this.renderDropdownAsChildElement = false;
    this.create(parent);
  }
  createBreadcrumbsControl(container, options) {
    const config = this._register(BreadcrumbsConfig.IsEnabled.bindTo(this.configurationService));
    this._register(config.onDidChange(() => {
      const value = config.getValue();
      if (!value && this.breadcrumbsControl) {
        this.breadcrumbsControl.dispose();
        this.breadcrumbsControl = void 0;
        this.handleBreadcrumbsEnablementChange();
      } else if (value && !this.breadcrumbsControl) {
        this.breadcrumbsControl = this.instantiationService.createInstance(BreadcrumbsControl, container, options, this.group);
        this.breadcrumbsControl.update();
        this.handleBreadcrumbsEnablementChange();
      }
    }));
    if (config.getValue()) {
      this.breadcrumbsControl = this.instantiationService.createInstance(BreadcrumbsControl, container, options, this.group);
    }
    this._register(this.fileService.onDidChangeFileSystemProviderRegistrations((e) => {
      var _a2, _b2;
      if (((_a2 = this.breadcrumbsControl) == null ? void 0 : _a2.model) && this.breadcrumbsControl.model.resource.scheme !== e.scheme) {
        return;
      }
      if ((_b2 = this.breadcrumbsControl) == null ? void 0 : _b2.update()) {
        this.handleBreadcrumbsEnablementChange();
      }
    }));
  }
  createEditorActionsToolBar(container) {
    const context = { groupId: this.group.id };
    this.editorActionsToolbar = this._register(this.instantiationService.createInstance(WorkbenchToolBar, container, {
      actionViewItemProvider: (action) => this.actionViewItemProvider(action),
      orientation: 0,
      ariaLabel: localize("ariaLabelEditorActions", "Editor actions"),
      getKeyBinding: (action) => this.getKeybinding(action),
      actionRunner: this._register(new EditorCommandsContextActionRunner(context)),
      anchorAlignmentProvider: () => 1,
      renderDropdownAsChildElement: this.renderDropdownAsChildElement,
      telemetrySource: "editorPart",
      resetMenu: MenuId.EditorTitle,
      maxNumberOfItems: 9
    }));
    this.editorActionsToolbar.context = context;
    this._register(this.editorActionsToolbar.actionRunner.onDidRun((e) => {
      if (e.error && !isCancellationError(e.error)) {
        this.notificationService.error(e.error);
      }
    }));
  }
  actionViewItemProvider(action) {
    const activeEditorPane = this.group.activeEditorPane;
    if (activeEditorPane instanceof EditorPane) {
      const result = activeEditorPane.getActionViewItem(action);
      if (result) {
        return result;
      }
    }
    return createActionViewItem(this.instantiationService, action, { menuAsChild: this.renderDropdownAsChildElement });
  }
  updateEditorActionsToolbar() {
    const { primary, secondary } = this.prepareEditorActions(this.getEditorActions());
    const editorActionsToolbar = assertIsDefined(this.editorActionsToolbar);
    editorActionsToolbar.setActions(prepareActions(primary), prepareActions(secondary));
  }
  getEditorActions() {
    const primary = [];
    const secondary = [];
    this.editorToolBarMenuDisposables.clear();
    this.contextKeyService.bufferChangeEvents(() => {
      const activeEditor = this.group.activeEditor;
      this.resourceContext.set(withUndefinedAsNull(EditorResourceAccessor.getOriginalUri(activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY })));
      this.editorPinnedContext.set(activeEditor ? this.group.isPinned(activeEditor) : false);
      this.editorIsFirstContext.set(activeEditor ? this.group.isFirst(activeEditor) : false);
      this.editorIsLastContext.set(activeEditor ? this.group.isLast(activeEditor) : false);
      this.editorStickyContext.set(activeEditor ? this.group.isSticky(activeEditor) : false);
      applyAvailableEditorIds(this.editorAvailableEditorIds, activeEditor, this.editorResolverService);
      this.editorCanSplitInGroupContext.set(activeEditor ? activeEditor.hasCapability(32) : false);
      this.sideBySideEditorContext.set((activeEditor == null ? void 0 : activeEditor.typeId) === SideBySideEditorInput.ID);
      this.groupLockedContext.set(this.group.isLocked);
    });
    const activeEditorPane = this.group.activeEditorPane;
    if (activeEditorPane instanceof EditorPane) {
      const scopedContextKeyService = this.getEditorPaneAwareContextKeyService();
      const titleBarMenu = this.menuService.createMenu(MenuId.EditorTitle, scopedContextKeyService, { emitEventsForSubmenuChanges: true, eventDebounceDelay: 0 });
      this.editorToolBarMenuDisposables.add(titleBarMenu);
      this.editorToolBarMenuDisposables.add(titleBarMenu.onDidChange(() => {
        this.updateEditorActionsToolbar();
      }));
      const shouldInlineGroup = (action, group) => group === "navigation" && action.actions.length <= 1;
      createAndFillInActionBarActions(titleBarMenu, { arg: this.resourceContext.get(), shouldForwardArgs: true }, { primary, secondary }, "navigation", shouldInlineGroup);
    }
    return { primary, secondary };
  }
  getEditorPaneAwareContextKeyService() {
    var _a2;
    return ((_a2 = this.group.activeEditorPane) == null ? void 0 : _a2.scopedContextKeyService) ?? this.contextKeyService;
  }
  clearEditorActionsToolbar() {
    var _a2;
    (_a2 = this.editorActionsToolbar) == null ? void 0 : _a2.setActions([], []);
  }
  enableGroupDragging(element) {
    this._register(addDisposableListener(element, EventType.DRAG_START, (e) => {
      var _a2;
      if (e.target !== element) {
        return;
      }
      this.groupTransfer.setData([new DraggedEditorGroupIdentifier(this.group.id)], DraggedEditorGroupIdentifier.prototype);
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "copyMove";
      }
      let hasDataTransfer = false;
      if (this.accessor.partOptions.showTabs) {
        hasDataTransfer = this.doFillResourceDataTransfers(this.group.getEditors(1), e);
      } else {
        if (this.group.activeEditor) {
          hasDataTransfer = this.doFillResourceDataTransfers([this.group.activeEditor], e);
        }
      }
      if (!hasDataTransfer && isFirefox) {
        (_a2 = e.dataTransfer) == null ? void 0 : _a2.setData(DataTransfers.TEXT, String(this.group.label));
      }
      if (this.group.activeEditor) {
        let label = this.group.activeEditor.getName();
        if (this.accessor.partOptions.showTabs && this.group.count > 1) {
          label = localize("draggedEditorGroup", "{0} (+{1})", label, this.group.count - 1);
        }
        applyDragImage(e, label, "monaco-editor-group-drag-image", this.getColor(listActiveSelectionBackground), this.getColor(listActiveSelectionForeground));
      }
    }));
    this._register(addDisposableListener(element, EventType.DRAG_END, () => {
      this.groupTransfer.clearData(DraggedEditorGroupIdentifier.prototype);
    }));
  }
  doFillResourceDataTransfers(editors, e) {
    if (editors.length) {
      this.instantiationService.invokeFunction(fillEditorsDragData, editors.map((editor) => ({ editor, groupId: this.group.id })), e);
      return true;
    }
    return false;
  }
  onContextMenu(editor, e, node) {
    const currentResourceContext = this.resourceContext.get();
    this.resourceContext.set(withUndefinedAsNull(EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY })));
    const currentPinnedContext = !!this.editorPinnedContext.get();
    this.editorPinnedContext.set(this.group.isPinned(editor));
    const currentEditorIsFirstContext = !!this.editorIsFirstContext.get();
    this.editorIsFirstContext.set(this.group.isFirst(editor));
    const currentEditorIsLastContext = !!this.editorIsLastContext.get();
    this.editorIsLastContext.set(this.group.isLast(editor));
    const currentStickyContext = !!this.editorStickyContext.get();
    this.editorStickyContext.set(this.group.isSticky(editor));
    const currentGroupLockedContext = !!this.groupLockedContext.get();
    this.groupLockedContext.set(this.group.isLocked);
    const currentEditorCanSplitContext = !!this.editorCanSplitInGroupContext.get();
    this.editorCanSplitInGroupContext.set(editor.hasCapability(32));
    const currentSideBySideEditorContext = !!this.sideBySideEditorContext.get();
    this.sideBySideEditorContext.set(editor.typeId === SideBySideEditorInput.ID);
    const currentEditorAvailableEditorIds = this.editorAvailableEditorIds.get() ?? "";
    applyAvailableEditorIds(this.editorAvailableEditorIds, editor, this.editorResolverService);
    let anchor = node;
    if (e instanceof MouseEvent) {
      anchor = new StandardMouseEvent(e);
    }
    this.contextMenuService.showContextMenu({
      getAnchor: () => anchor,
      menuId: MenuId.EditorTitleContext,
      menuActionOptions: { shouldForwardArgs: true, arg: this.resourceContext.get() },
      contextKeyService: this.contextKeyService,
      getActionsContext: () => ({ groupId: this.group.id, editorIndex: this.group.getIndexOfEditor(editor) }),
      getKeyBinding: (action) => this.getKeybinding(action),
      onHide: () => {
        this.resourceContext.set(currentResourceContext || null);
        this.editorPinnedContext.set(currentPinnedContext);
        this.editorIsFirstContext.set(currentEditorIsFirstContext);
        this.editorIsLastContext.set(currentEditorIsLastContext);
        this.editorStickyContext.set(currentStickyContext);
        this.groupLockedContext.set(currentGroupLockedContext);
        this.editorCanSplitInGroupContext.set(currentEditorCanSplitContext);
        this.sideBySideEditorContext.set(currentSideBySideEditorContext);
        this.editorAvailableEditorIds.set(currentEditorAvailableEditorIds);
        this.accessor.activeGroup.focus();
      }
    });
  }
  getKeybinding(action) {
    return this.keybindingService.lookupKeybinding(action.id, this.getEditorPaneAwareContextKeyService());
  }
  getKeybindingLabel(action) {
    const keybinding = this.getKeybinding(action);
    return keybinding ? withNullAsUndefined(keybinding.getLabel()) : void 0;
  }
  dispose() {
    dispose(this.breadcrumbsControl);
    this.breadcrumbsControl = void 0;
    super.dispose();
  }
};
TitleControl = __decorate([
  __param(3, IContextMenuService),
  __param(4, IInstantiationService),
  __param(5, IContextKeyService),
  __param(6, IKeybindingService),
  __param(7, INotificationService),
  __param(8, IMenuService),
  __param(9, IQuickInputService),
  __param(10, IThemeService),
  __param(11, IConfigurationService),
  __param(12, IFileService),
  __param(13, IEditorResolverService)
], TitleControl);
let TabsTitleControl = (_k = class extends TitleControl {
  constructor(parent, accessor, group, contextMenuService, instantiationService, contextKeyService, keybindingService, notificationService, menuService, quickInputService, themeService, configurationService, fileService, editorService, pathService, editorGroupService, treeViewsDragAndDropService, editorResolverService) {
    super(parent, accessor, group, contextMenuService, instantiationService, contextKeyService, keybindingService, notificationService, menuService, quickInputService, themeService, configurationService, fileService, editorResolverService);
    this.editorService = editorService;
    this.pathService = pathService;
    this.editorGroupService = editorGroupService;
    this.treeViewsDragAndDropService = treeViewsDragAndDropService;
    this.closeEditorAction = this._register(this.instantiationService.createInstance(CloseOneEditorAction, CloseOneEditorAction.ID, CloseOneEditorAction.LABEL));
    this.unpinEditorAction = this._register(this.instantiationService.createInstance(UnpinEditorAction, UnpinEditorAction.ID, UnpinEditorAction.LABEL));
    this.tabResourceLabels = this._register(this.instantiationService.createInstance(ResourceLabels, DEFAULT_LABELS_CONTAINER));
    this.tabLabels = [];
    this.tabActionBars = [];
    this.tabDisposables = [];
    this.dimensions = {
      container: Dimension.None,
      available: Dimension.None
    };
    this.layoutScheduler = this._register(new MutableDisposable());
    this.path = isWindows ? win32 : posix;
    this.lastMouseWheelEventTime = 0;
    this.isMouseOverTabs = false;
    this.updateEditorLabelScheduler = this._register(new RunOnceScheduler(() => this.doUpdateEditorLabels(), 0));
    (async () => this.path = await this.pathService.path)();
    this._register(this.tabResourceLabels.onDidChangeDecorations(() => this.doHandleDecorationsChange()));
  }
  create(parent) {
    this.titleContainer = parent;
    this.tabsAndActionsContainer = document.createElement("div");
    this.tabsAndActionsContainer.classList.add("tabs-and-actions-container");
    this.titleContainer.appendChild(this.tabsAndActionsContainer);
    this.tabsContainer = document.createElement("div");
    this.tabsContainer.setAttribute("role", "tablist");
    this.tabsContainer.draggable = true;
    this.tabsContainer.classList.add("tabs-container");
    this._register(Gesture.addTarget(this.tabsContainer));
    this.tabSizingFixedDisposables = this._register(new DisposableStore());
    this.updateTabSizing(false);
    this.tabsScrollbar = this._register(this.createTabsScrollbar(this.tabsContainer));
    this.tabsAndActionsContainer.appendChild(this.tabsScrollbar.getDomNode());
    this.registerTabsContainerListeners(this.tabsContainer, this.tabsScrollbar);
    this.editorToolbarContainer = document.createElement("div");
    this.editorToolbarContainer.classList.add("editor-actions");
    this.tabsAndActionsContainer.appendChild(this.editorToolbarContainer);
    this.createEditorActionsToolBar(this.editorToolbarContainer);
    const breadcrumbsContainer = document.createElement("div");
    breadcrumbsContainer.classList.add("tabs-breadcrumbs");
    this.titleContainer.appendChild(breadcrumbsContainer);
    this.createBreadcrumbsControl(breadcrumbsContainer, { showFileIcons: true, showSymbolIcons: true, showDecorationColors: false, showPlaceholder: true });
  }
  createTabsScrollbar(scrollable) {
    const tabsScrollbar = new ScrollableElement(scrollable, {
      horizontal: 1,
      horizontalScrollbarSize: this.getTabsScrollbarSizing(),
      vertical: 2,
      scrollYToX: true,
      useShadows: false
    });
    tabsScrollbar.onScroll((e) => {
      if (e.scrollLeftChanged) {
        scrollable.scrollLeft = e.scrollLeft;
      }
    });
    return tabsScrollbar;
  }
  updateTabsScrollbarSizing() {
    var _a2;
    (_a2 = this.tabsScrollbar) == null ? void 0 : _a2.updateOptions({
      horizontalScrollbarSize: this.getTabsScrollbarSizing()
    });
  }
  updateTabSizing(fromEvent) {
    const [tabsContainer, tabSizingFixedDisposables] = assertAllDefined(this.tabsContainer, this.tabSizingFixedDisposables);
    tabSizingFixedDisposables.clear();
    const options = this.accessor.partOptions;
    if (options.tabSizing === "fixed") {
      tabsContainer.style.setProperty("--tab-sizing-fixed-min-width", `${options.tabSizingFixedMinWidth}px`);
      tabsContainer.style.setProperty("--tab-sizing-fixed-max-width", `${options.tabSizingFixedMaxWidth}px`);
      tabSizingFixedDisposables.add(addDisposableListener(tabsContainer, EventType.MOUSE_ENTER, () => {
        this.isMouseOverTabs = true;
      }));
      tabSizingFixedDisposables.add(addDisposableListener(tabsContainer, EventType.MOUSE_LEAVE, () => {
        this.isMouseOverTabs = false;
        this.updateTabsFixedWidth(false);
      }));
    } else if (fromEvent) {
      tabsContainer.style.removeProperty("--tab-sizing-fixed-min-width");
      tabsContainer.style.removeProperty("--tab-sizing-fixed-max-width");
      this.updateTabsFixedWidth(false);
    }
  }
  updateTabsFixedWidth(fixed) {
    this.forEachTab((editor, index, tabContainer) => {
      if (fixed) {
        const { width } = tabContainer.getBoundingClientRect();
        tabContainer.style.setProperty("--tab-sizing-current-width", `${width}px`);
      } else {
        tabContainer.style.removeProperty("--tab-sizing-current-width");
      }
    });
  }
  getTabsScrollbarSizing() {
    if (this.accessor.partOptions.titleScrollbarSizing !== "large") {
      return _k.SCROLLBAR_SIZES.default;
    }
    return _k.SCROLLBAR_SIZES.large;
  }
  registerTabsContainerListeners(tabsContainer, tabsScrollbar) {
    this.enableGroupDragging(tabsContainer);
    this._register(addDisposableListener(tabsContainer, EventType.SCROLL, () => {
      if (tabsContainer.classList.contains("scroll")) {
        tabsScrollbar.setScrollPosition({
          scrollLeft: tabsContainer.scrollLeft
        });
      }
    }));
    for (const eventType of [EventType$1.Tap, EventType.DBLCLICK]) {
      this._register(addDisposableListener(tabsContainer, eventType, (e) => {
        if (eventType === EventType.DBLCLICK) {
          if (e.target !== tabsContainer) {
            return;
          }
        } else {
          if (e.tapCount !== 2) {
            return;
          }
          if (e.initialTarget !== tabsContainer) {
            return;
          }
        }
        EventHelper.stop(e);
        this.editorService.openEditor({
          resource: void 0,
          options: {
            pinned: true,
            index: this.group.count,
            override: DEFAULT_EDITOR_ASSOCIATION.id
          }
        }, this.group.id);
      }));
    }
    this._register(addDisposableListener(tabsContainer, EventType.MOUSE_DOWN, (e) => {
      if (e.button === 1) {
        e.preventDefault();
      }
    }));
    this._register(new DragAndDropObserver(tabsContainer, {
      onDragEnter: (e) => {
        tabsContainer.classList.add("scroll");
        if (e.target !== tabsContainer) {
          this.updateDropFeedback(tabsContainer, false);
          return;
        }
        if (!this.isSupportedDropTransfer(e)) {
          if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "none";
          }
          return;
        }
        let isLocalDragAndDrop = false;
        if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {
          isLocalDragAndDrop = true;
          const data = this.editorTransfer.getData(DraggedEditorIdentifier.prototype);
          if (Array.isArray(data)) {
            const localDraggedEditor = data[0].identifier;
            if (this.group.id === localDraggedEditor.groupId && this.group.getIndexOfEditor(localDraggedEditor.editor) === this.group.count - 1) {
              if (e.dataTransfer) {
                e.dataTransfer.dropEffect = "none";
              }
              return;
            }
          }
        }
        if (!isLocalDragAndDrop) {
          if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "copy";
          }
        }
        this.updateDropFeedback(tabsContainer, true);
      },
      onDragLeave: (e) => {
        this.updateDropFeedback(tabsContainer, false);
        tabsContainer.classList.remove("scroll");
      },
      onDragEnd: (e) => {
        this.updateDropFeedback(tabsContainer, false);
        tabsContainer.classList.remove("scroll");
      },
      onDrop: (e) => {
        this.updateDropFeedback(tabsContainer, false);
        tabsContainer.classList.remove("scroll");
        if (e.target === tabsContainer) {
          this.onDrop(e, this.group.count, tabsContainer);
        }
      }
    }));
    this._register(addDisposableListener(tabsContainer, EventType.MOUSE_WHEEL, (e) => {
      const activeEditor = this.group.activeEditor;
      if (!activeEditor || this.group.count < 2) {
        return;
      }
      if (this.accessor.partOptions.scrollToSwitchTabs === true) {
        if (e.shiftKey) {
          return;
        }
      } else {
        if (!e.shiftKey) {
          return;
        }
      }
      const now = Date.now();
      if (now - this.lastMouseWheelEventTime < _k.MOUSE_WHEEL_EVENT_THRESHOLD - 2 * (Math.abs(e.deltaX) + Math.abs(e.deltaY))) {
        return;
      }
      this.lastMouseWheelEventTime = now;
      let tabSwitchDirection;
      if (e.deltaX + e.deltaY < -_k.MOUSE_WHEEL_DISTANCE_THRESHOLD) {
        tabSwitchDirection = -1;
      } else if (e.deltaX + e.deltaY > _k.MOUSE_WHEEL_DISTANCE_THRESHOLD) {
        tabSwitchDirection = 1;
      } else {
        return;
      }
      const nextEditor = this.group.getEditorByIndex(this.group.getIndexOfEditor(activeEditor) + tabSwitchDirection);
      if (!nextEditor) {
        return;
      }
      this.group.openEditor(nextEditor);
      EventHelper.stop(e, true);
    }));
    const showContextMenu = (e) => {
      EventHelper.stop(e);
      let anchor = tabsContainer;
      if (e instanceof MouseEvent) {
        anchor = new StandardMouseEvent(e);
      }
      this.contextMenuService.showContextMenu({
        getAnchor: () => anchor,
        menuId: MenuId.EditorTabsBarContext,
        contextKeyService: this.contextKeyService,
        menuActionOptions: { shouldForwardArgs: true },
        getActionsContext: () => ({ groupId: this.group.id }),
        getKeyBinding: (action) => this.getKeybinding(action),
        onHide: () => this.group.focus()
      });
    };
    this._register(addDisposableListener(tabsContainer, EventType$1.Contextmenu, (e) => showContextMenu(e)));
    this._register(addDisposableListener(tabsContainer, EventType.CONTEXT_MENU, (e) => showContextMenu(e)));
  }
  doHandleDecorationsChange() {
    this.layout(this.dimensions);
  }
  updateEditorActionsToolbar() {
    super.updateEditorActionsToolbar();
    this.layout(this.dimensions);
  }
  openEditor(editor) {
    this.handleOpenedEditors();
  }
  openEditors(editors) {
    this.handleOpenedEditors();
  }
  handleOpenedEditors() {
    var _a2, _b2;
    const [tabsContainer, tabsScrollbar] = assertAllDefined(this.tabsContainer, this.tabsScrollbar);
    for (let i = tabsContainer.children.length; i < this.group.count; i++) {
      tabsContainer.appendChild(this.createTab(i, tabsContainer, tabsScrollbar));
    }
    const activeEditorChanged = this.didActiveEditorChange();
    const oldActiveTabLabel = this.activeTabLabel;
    const oldTabLabelsLength = this.tabLabels.length;
    this.computeTabLabels();
    if (activeEditorChanged || oldTabLabelsLength !== this.tabLabels.length || !this.equalsEditorInputLabel(oldActiveTabLabel, this.activeTabLabel)) {
      this.redraw({ forceRevealActiveTab: true });
      (_a2 = this.breadcrumbsControl) == null ? void 0 : _a2.update();
    } else {
      this.layout(this.dimensions, { forceRevealActiveTab: true });
      (_b2 = this.breadcrumbsControl) == null ? void 0 : _b2.revealLast();
    }
  }
  didActiveEditorChange() {
    var _a2, _b2, _c2;
    if (!((_a2 = this.activeTabLabel) == null ? void 0 : _a2.editor) && this.group.activeEditor || ((_b2 = this.activeTabLabel) == null ? void 0 : _b2.editor) && !this.group.activeEditor || (!((_c2 = this.activeTabLabel) == null ? void 0 : _c2.editor) || !this.group.isActive(this.activeTabLabel.editor))) {
      return true;
    }
    return false;
  }
  equalsEditorInputLabel(labelA, labelB) {
    if (labelA === labelB) {
      return true;
    }
    if (!labelA || !labelB) {
      return false;
    }
    return labelA.name === labelB.name && labelA.description === labelB.description && labelA.forceDescription === labelB.forceDescription && labelA.title === labelB.title && labelA.ariaLabel === labelB.ariaLabel;
  }
  beforeCloseEditor(editor) {
    if (this.isMouseOverTabs && this.accessor.partOptions.tabSizing === "fixed") {
      const closingLastTab = this.group.isLast(editor);
      this.updateTabsFixedWidth(!closingLastTab);
    }
  }
  closeEditor(editor) {
    this.handleClosedEditors();
  }
  closeEditors(editors) {
    this.handleClosedEditors();
  }
  handleClosedEditors() {
    var _a2, _b2;
    if (this.group.activeEditor) {
      const tabsContainer = assertIsDefined(this.tabsContainer);
      while (tabsContainer.children.length > this.group.count) {
        (_a2 = tabsContainer.lastChild) == null ? void 0 : _a2.remove();
        dispose(this.tabDisposables.pop());
      }
      this.computeTabLabels();
      this.redraw({ forceRevealActiveTab: true });
    } else {
      if (this.tabsContainer) {
        clearNode(this.tabsContainer);
      }
      this.tabDisposables = dispose(this.tabDisposables);
      this.tabResourceLabels.clear();
      this.tabLabels = [];
      this.activeTabLabel = void 0;
      this.tabActionBars = [];
      this.clearEditorActionsToolbar();
      (_b2 = this.breadcrumbsControl) == null ? void 0 : _b2.update();
    }
  }
  moveEditor(editor, fromIndex, targetIndex) {
    const editorLabel = this.tabLabels[fromIndex];
    this.tabLabels.splice(fromIndex, 1);
    this.tabLabels.splice(targetIndex, 0, editorLabel);
    this.forEachTab(
      (editor2, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar) => {
        this.redrawTab(editor2, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar);
      },
      Math.min(fromIndex, targetIndex),
      Math.max(fromIndex, targetIndex)
    );
    this.layout(this.dimensions, { forceRevealActiveTab: true });
  }
  pinEditor(editor) {
    this.withTab(editor, (editor2, index, tabContainer, tabLabelWidget, tabLabel) => this.redrawTabLabel(editor2, index, tabContainer, tabLabelWidget, tabLabel));
  }
  stickEditor(editor) {
    this.doHandleStickyEditorChange(editor);
  }
  unstickEditor(editor) {
    this.doHandleStickyEditorChange(editor);
  }
  doHandleStickyEditorChange(editor) {
    this.withTab(editor, (editor2, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar) => this.redrawTab(editor2, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar));
    this.forEachTab((editor2, index, tabContainer, tabLabelWidget, tabLabel) => {
      this.redrawTabBorders(index, tabContainer);
    });
    this.layout(this.dimensions, { forceRevealActiveTab: true });
  }
  setActive(isGroupActive) {
    this.forEachTab((editor, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar) => {
      this.redrawTabActiveAndDirty(isGroupActive, editor, tabContainer, tabActionBar);
    });
    this.updateEditorActionsToolbar();
    this.layout(this.dimensions, { forceRevealActiveTab: true });
  }
  updateEditorLabel(editor) {
    this.updateEditorLabelScheduler.schedule();
  }
  doUpdateEditorLabels() {
    this.computeTabLabels();
    this.forEachTab((editor, index, tabContainer, tabLabelWidget, tabLabel) => {
      this.redrawTabLabel(editor, index, tabContainer, tabLabelWidget, tabLabel);
    });
    this.layout(this.dimensions);
  }
  updateEditorDirty(editor) {
    this.withTab(editor, (editor2, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar) => this.redrawTabActiveAndDirty(this.accessor.activeGroup === this.group, editor2, tabContainer, tabActionBar));
  }
  updateOptions(oldOptions, newOptions) {
    if (oldOptions.labelFormat !== newOptions.labelFormat) {
      this.computeTabLabels();
    }
    if (oldOptions.titleScrollbarSizing !== newOptions.titleScrollbarSizing) {
      this.updateTabsScrollbarSizing();
    }
    if (oldOptions.tabSizingFixedMinWidth !== newOptions.tabSizingFixedMinWidth || oldOptions.tabSizingFixedMaxWidth !== newOptions.tabSizingFixedMaxWidth || oldOptions.tabSizing !== newOptions.tabSizing) {
      this.updateTabSizing(true);
    }
    if (oldOptions.labelFormat !== newOptions.labelFormat || oldOptions.tabCloseButton !== newOptions.tabCloseButton || oldOptions.tabSizing !== newOptions.tabSizing || oldOptions.pinnedTabSizing !== newOptions.pinnedTabSizing || oldOptions.showIcons !== newOptions.showIcons || oldOptions.hasIcons !== newOptions.hasIcons || oldOptions.highlightModifiedTabs !== newOptions.highlightModifiedTabs || oldOptions.wrapTabs !== newOptions.wrapTabs || !equals$1(oldOptions.decorations, newOptions.decorations)) {
      this.redraw();
    }
  }
  updateStyles() {
    this.redraw();
  }
  forEachTab(fn, fromIndex, toIndex) {
    this.group.editors.forEach((editor, index) => {
      if (typeof fromIndex === "number" && fromIndex > index) {
        return;
      }
      if (typeof toIndex === "number" && toIndex < index) {
        return;
      }
      this.doWithTab(index, editor, fn);
    });
  }
  withTab(editor, fn) {
    this.doWithTab(this.group.getIndexOfEditor(editor), editor, fn);
  }
  doWithTab(index, editor, fn) {
    const tabsContainer = assertIsDefined(this.tabsContainer);
    const tabContainer = tabsContainer.children[index];
    const tabResourceLabel = this.tabResourceLabels.get(index);
    const tabLabel = this.tabLabels[index];
    const tabActionBar = this.tabActionBars[index];
    if (tabContainer && tabResourceLabel && tabLabel) {
      fn(editor, index, tabContainer, tabResourceLabel, tabLabel, tabActionBar);
    }
  }
  createTab(index, tabsContainer, tabsScrollbar) {
    const tabContainer = document.createElement("div");
    tabContainer.draggable = true;
    tabContainer.setAttribute("role", "tab");
    tabContainer.classList.add("tab");
    this._register(Gesture.addTarget(tabContainer));
    const tabBorderTopContainer = document.createElement("div");
    tabBorderTopContainer.classList.add("tab-border-top-container");
    tabContainer.appendChild(tabBorderTopContainer);
    const editorLabel = this.tabResourceLabels.create(tabContainer);
    const tabActionsContainer = document.createElement("div");
    tabActionsContainer.classList.add("tab-actions");
    tabContainer.appendChild(tabActionsContainer);
    const tabActionRunner = new EditorCommandsContextActionRunner({ groupId: this.group.id, editorIndex: index });
    const tabActionBar = new ActionBar(tabActionsContainer, { ariaLabel: localize("ariaLabelTabActions", "Tab actions"), actionRunner: tabActionRunner });
    tabActionBar.onWillRun((e) => {
      if (e.action.id === this.closeEditorAction.id) {
        this.blockRevealActiveTabOnce();
      }
    });
    const tabActionBarDisposable = combinedDisposable(tabActionBar, toDisposable(insert(this.tabActionBars, tabActionBar)));
    const tabBorderBottomContainer = document.createElement("div");
    tabBorderBottomContainer.classList.add("tab-border-bottom-container");
    tabContainer.appendChild(tabBorderBottomContainer);
    const eventsDisposable = this.registerTabListeners(tabContainer, index, tabsContainer, tabsScrollbar);
    this.tabDisposables.push(combinedDisposable(eventsDisposable, tabActionBarDisposable, tabActionRunner, editorLabel));
    return tabContainer;
  }
  registerTabListeners(tab, index, tabsContainer, tabsScrollbar) {
    const disposables = new DisposableStore();
    const handleClickOrTouch = (e, preserveFocus) => {
      tab.blur();
      if (e instanceof MouseEvent && (e.button !== 0 || isMacintosh && e.ctrlKey)) {
        if (e.button === 1) {
          e.preventDefault();
        }
        return void 0;
      }
      if (this.originatesFromTabActionBar(e)) {
        return;
      }
      const input = this.group.getEditorByIndex(index);
      if (input) {
        this.group.openEditor(input, { preserveFocus, activation: EditorActivation.ACTIVATE });
      }
      return void 0;
    };
    const showContextMenu = (e) => {
      EventHelper.stop(e);
      const input = this.group.getEditorByIndex(index);
      if (input) {
        this.onContextMenu(input, e, tab);
      }
    };
    disposables.add(addDisposableListener(tab, EventType.MOUSE_DOWN, (e) => handleClickOrTouch(e, false)));
    disposables.add(addDisposableListener(tab, EventType$1.Tap, (e) => handleClickOrTouch(e, true)));
    disposables.add(addDisposableListener(tab, EventType$1.Change, (e) => {
      tabsScrollbar.setScrollPosition({ scrollLeft: tabsScrollbar.getScrollPosition().scrollLeft - e.translationX });
    }));
    disposables.add(addDisposableListener(tab, EventType.MOUSE_UP, (e) => {
      EventHelper.stop(e);
      tab.blur();
    }));
    disposables.add(addDisposableListener(tab, EventType.AUXCLICK, (e) => {
      if (e.button === 1) {
        EventHelper.stop(e, true);
        this.blockRevealActiveTabOnce();
        this.closeEditorAction.run({ groupId: this.group.id, editorIndex: index });
      }
    }));
    disposables.add(addDisposableListener(tab, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.shiftKey && event.keyCode === 68) {
        showContextMenu(e);
      }
    }));
    disposables.add(addDisposableListener(tab, EventType$1.Contextmenu, (e) => {
      showContextMenu(e);
    }));
    disposables.add(addDisposableListener(tab, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      let handled = false;
      if (event.equals(3) || event.equals(10)) {
        handled = true;
        const input = this.group.getEditorByIndex(index);
        if (input) {
          this.group.openEditor(input);
        }
      } else if ([15, 17, 16, 18, 14, 13].some((kb) => event.equals(kb))) {
        let targetIndex;
        if (event.equals(15) || event.equals(16)) {
          targetIndex = index - 1;
        } else if (event.equals(17) || event.equals(18)) {
          targetIndex = index + 1;
        } else if (event.equals(14)) {
          targetIndex = 0;
        } else {
          targetIndex = this.group.count - 1;
        }
        const target = this.group.getEditorByIndex(targetIndex);
        if (target) {
          handled = true;
          this.group.openEditor(target, { preserveFocus: true });
          tabsContainer.childNodes[targetIndex].focus();
        }
      }
      if (handled) {
        EventHelper.stop(e, true);
      }
      tabsScrollbar.setScrollPosition({
        scrollLeft: tabsContainer.scrollLeft
      });
    }));
    for (const eventType of [EventType$1.Tap, EventType.DBLCLICK]) {
      disposables.add(addDisposableListener(tab, eventType, (e) => {
        if (eventType === EventType.DBLCLICK) {
          EventHelper.stop(e);
        } else if (e.tapCount !== 2) {
          return;
        }
        const editor = this.group.getEditorByIndex(index);
        if (editor && this.group.isPinned(editor)) {
          if (this.accessor.partOptions.doubleClickTabToToggleEditorGroupSizes) {
            this.accessor.arrangeGroups(2, this.group);
          }
        } else {
          this.group.pinEditor(editor);
        }
      }));
    }
    disposables.add(addDisposableListener(tab, EventType.CONTEXT_MENU, (e) => {
      EventHelper.stop(e, true);
      const input = this.group.getEditorByIndex(index);
      if (input) {
        this.onContextMenu(input, e, tab);
      }
    }, true));
    disposables.add(addDisposableListener(tab, EventType.DRAG_START, (e) => {
      const editor = this.group.getEditorByIndex(index);
      if (!editor) {
        return;
      }
      this.editorTransfer.setData([new DraggedEditorIdentifier({ editor, groupId: this.group.id })], DraggedEditorIdentifier.prototype);
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "copyMove";
      }
      this.doFillResourceDataTransfers([editor], e);
      tab.classList.add("dragged");
      scheduleAtNextAnimationFrame(() => tab.classList.remove("dragged"));
    }));
    disposables.add(new DragAndDropObserver(tab, {
      onDragEnter: (e) => {
        tab.classList.add("dragged-over");
        if (!this.isSupportedDropTransfer(e)) {
          if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "none";
          }
          return;
        }
        let isLocalDragAndDrop = false;
        if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {
          isLocalDragAndDrop = true;
          const data = this.editorTransfer.getData(DraggedEditorIdentifier.prototype);
          if (Array.isArray(data)) {
            const localDraggedEditor = data[0].identifier;
            if (localDraggedEditor.editor === this.group.getEditorByIndex(index) && localDraggedEditor.groupId === this.group.id) {
              if (e.dataTransfer) {
                e.dataTransfer.dropEffect = "none";
              }
              return;
            }
          }
        }
        if (!isLocalDragAndDrop) {
          if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "copy";
          }
        }
        this.updateDropFeedback(tab, true, index);
      },
      onDragOver: (_, dragDuration) => {
        if (dragDuration >= _k.DRAG_OVER_OPEN_TAB_THRESHOLD) {
          const draggedOverTab = this.group.getEditorByIndex(index);
          if (draggedOverTab && this.group.activeEditor !== draggedOverTab) {
            this.group.openEditor(draggedOverTab, { preserveFocus: true });
          }
        }
      },
      onDragLeave: () => {
        tab.classList.remove("dragged-over");
        this.updateDropFeedback(tab, false, index);
      },
      onDragEnd: () => {
        tab.classList.remove("dragged-over");
        this.updateDropFeedback(tab, false, index);
        this.editorTransfer.clearData(DraggedEditorIdentifier.prototype);
      },
      onDrop: (e) => {
        tab.classList.remove("dragged-over");
        this.updateDropFeedback(tab, false, index);
        this.onDrop(e, index, tabsContainer);
      }
    }));
    return disposables;
  }
  isSupportedDropTransfer(e) {
    if (this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype)) {
      const data = this.groupTransfer.getData(DraggedEditorGroupIdentifier.prototype);
      if (Array.isArray(data)) {
        const group = data[0];
        if (group.identifier === this.group.id) {
          return false;
        }
      }
      return true;
    }
    if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {
      return true;
    }
    if (e.dataTransfer && e.dataTransfer.types.length > 0) {
      return true;
    }
    return false;
  }
  updateDropFeedback(element, isDND, index) {
    const isTab = typeof index === "number";
    const editor = typeof index === "number" ? this.group.getEditorByIndex(index) : void 0;
    const isActiveTab = isTab && !!editor && this.group.isActive(editor);
    const noDNDBackgroundColor = isTab ? this.getColor(isActiveTab ? TAB_ACTIVE_BACKGROUND : TAB_INACTIVE_BACKGROUND) : "";
    element.style.backgroundColor = (isDND ? this.getColor(EDITOR_DRAG_AND_DROP_BACKGROUND) : noDNDBackgroundColor) || "";
    const activeContrastBorderColor = this.getColor(activeContrastBorder);
    if (activeContrastBorderColor && isDND) {
      element.style.outlineWidth = "2px";
      element.style.outlineStyle = "dashed";
      element.style.outlineColor = activeContrastBorderColor;
      element.style.outlineOffset = isTab ? "-5px" : "-3px";
    } else {
      element.style.outlineWidth = "";
      element.style.outlineStyle = "";
      element.style.outlineColor = activeContrastBorderColor || "";
      element.style.outlineOffset = "";
    }
  }
  computeTabLabels() {
    const { labelFormat } = this.accessor.partOptions;
    const { verbosity, shortenDuplicates } = this.getLabelConfigFlags(labelFormat);
    const labels = [];
    let activeEditorIndex = -1;
    for (let i = 0; i < this.group.editors.length; i++) {
      const editor = this.group.editors[i];
      labels.push({
        editor,
        name: editor.getName(),
        description: editor.getDescription(verbosity),
        forceDescription: editor.hasCapability(64),
        title: editor.getTitle(2),
        ariaLabel: computeEditorAriaLabel(editor, i, this.group, this.editorGroupService.count)
      });
      if (editor === this.group.activeEditor) {
        activeEditorIndex = i;
      }
    }
    if (shortenDuplicates) {
      this.shortenTabLabels(labels);
    }
    this.tabLabels = labels;
    this.activeTabLabel = labels[activeEditorIndex];
  }
  shortenTabLabels(labels) {
    const mapNameToDuplicates = /* @__PURE__ */ new Map();
    for (const label of labels) {
      if (typeof label.description === "string") {
        getOrSet(mapNameToDuplicates, label.name, []).push(label);
      } else {
        label.description = "";
      }
    }
    for (const [, duplicateLabels] of mapNameToDuplicates) {
      if (duplicateLabels.length === 1 && !duplicateLabels[0].forceDescription) {
        duplicateLabels[0].description = "";
        continue;
      }
      const mapDescriptionToDuplicates = /* @__PURE__ */ new Map();
      for (const duplicateLabel of duplicateLabels) {
        getOrSet(mapDescriptionToDuplicates, duplicateLabel.description, []).push(duplicateLabel);
      }
      let useLongDescriptions = false;
      for (const [, duplicateLabels2] of mapDescriptionToDuplicates) {
        if (!useLongDescriptions && duplicateLabels2.length > 1) {
          const [first, ...rest] = duplicateLabels2.map(({ editor }) => editor.getDescription(2));
          useLongDescriptions = rest.some((description) => description !== first);
        }
      }
      if (useLongDescriptions) {
        mapDescriptionToDuplicates.clear();
        for (const duplicateLabel of duplicateLabels) {
          duplicateLabel.description = duplicateLabel.editor.getDescription(2);
          getOrSet(mapDescriptionToDuplicates, duplicateLabel.description, []).push(duplicateLabel);
        }
      }
      const descriptions = [];
      for (const [description] of mapDescriptionToDuplicates) {
        descriptions.push(description);
      }
      if (descriptions.length === 1) {
        for (const label of mapDescriptionToDuplicates.get(descriptions[0]) || []) {
          if (!label.forceDescription) {
            label.description = "";
          }
        }
        continue;
      }
      const shortenedDescriptions = shorten(descriptions, this.path.sep);
      descriptions.forEach((description, index) => {
        for (const label of mapDescriptionToDuplicates.get(description) || []) {
          label.description = shortenedDescriptions[index];
        }
      });
    }
  }
  getLabelConfigFlags(value) {
    switch (value) {
      case "short":
        return { verbosity: 0, shortenDuplicates: false };
      case "medium":
        return { verbosity: 1, shortenDuplicates: false };
      case "long":
        return { verbosity: 2, shortenDuplicates: false };
      default:
        return { verbosity: 1, shortenDuplicates: true };
    }
  }
  redraw(options) {
    if (this.tabsAndActionsContainer) {
      let tabsContainerBorderColor = this.getColor(EDITOR_GROUP_HEADER_TABS_BORDER);
      if (!tabsContainerBorderColor && isHighContrast(this.theme.type)) {
        tabsContainerBorderColor = this.getColor(TAB_BORDER) || this.getColor(contrastBorder);
      }
      if (tabsContainerBorderColor) {
        this.tabsAndActionsContainer.classList.add("tabs-border-bottom");
        this.tabsAndActionsContainer.style.setProperty("--tabs-border-bottom-color", tabsContainerBorderColor.toString());
      } else {
        this.tabsAndActionsContainer.classList.remove("tabs-border-bottom");
        this.tabsAndActionsContainer.style.removeProperty("--tabs-border-bottom-color");
      }
    }
    this.forEachTab((editor, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar) => {
      this.redrawTab(editor, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar);
    });
    this.updateEditorActionsToolbar();
    this.layout(this.dimensions, options);
  }
  redrawTab(editor, index, tabContainer, tabLabelWidget, tabLabel, tabActionBar) {
    const isTabSticky = this.group.isSticky(index);
    const options = this.accessor.partOptions;
    this.redrawTabLabel(editor, index, tabContainer, tabLabelWidget, tabLabel);
    const tabAction = isTabSticky ? this.unpinEditorAction : this.closeEditorAction;
    if (!tabActionBar.hasAction(tabAction)) {
      if (!tabActionBar.isEmpty()) {
        tabActionBar.clear();
      }
      tabActionBar.push(tabAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(tabAction) });
    }
    const tabActionsVisibility = isTabSticky && options.pinnedTabSizing === "compact" ? "off" : options.tabCloseButton;
    for (const option of ["off", "left", "right"]) {
      tabContainer.classList.toggle(`tab-actions-${option}`, tabActionsVisibility === option);
    }
    const tabSizing = isTabSticky && options.pinnedTabSizing === "shrink" ? "shrink" : options.tabSizing;
    for (const option of ["fit", "shrink", "fixed"]) {
      tabContainer.classList.toggle(`sizing-${option}`, tabSizing === option);
    }
    tabContainer.classList.toggle("has-icon", options.showIcons && options.hasIcons);
    tabContainer.classList.toggle("sticky", isTabSticky);
    for (const option of ["normal", "compact", "shrink"]) {
      tabContainer.classList.toggle(`sticky-${option}`, isTabSticky && options.pinnedTabSizing === option);
    }
    if (!options.wrapTabs && isTabSticky && options.pinnedTabSizing !== "normal") {
      let stickyTabWidth = 0;
      switch (options.pinnedTabSizing) {
        case "compact":
          stickyTabWidth = _k.TAB_WIDTH.compact;
          break;
        case "shrink":
          stickyTabWidth = _k.TAB_WIDTH.shrink;
          break;
      }
      tabContainer.style.left = `${index * stickyTabWidth}px`;
    } else {
      tabContainer.style.left = "auto";
    }
    this.redrawTabBorders(index, tabContainer);
    this.redrawTabActiveAndDirty(this.accessor.activeGroup === this.group, editor, tabContainer, tabActionBar);
  }
  redrawTabLabel(editor, index, tabContainer, tabLabelWidget, tabLabel) {
    var _a2, _b2, _c2;
    const options = this.accessor.partOptions;
    let name;
    let forceLabel = false;
    let fileDecorationBadges = Boolean((_a2 = options.decorations) == null ? void 0 : _a2.badges);
    let description;
    if (options.pinnedTabSizing === "compact" && this.group.isSticky(index)) {
      const isShowingIcons = options.showIcons && options.hasIcons;
      name = isShowingIcons ? "" : (_b2 = tabLabel.name) == null ? void 0 : _b2.charAt(0).toUpperCase();
      description = "";
      forceLabel = true;
      fileDecorationBadges = false;
    } else {
      name = tabLabel.name;
      description = tabLabel.description || "";
    }
    if (tabLabel.ariaLabel) {
      tabContainer.setAttribute("aria-label", tabLabel.ariaLabel);
      tabContainer.setAttribute("aria-description", "");
    }
    const title = tabLabel.title || "";
    tabContainer.title = title;
    tabLabelWidget.setResource({ name, description, resource: EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.BOTH }) }, {
      title,
      extraClasses: coalesce(["tab-label", fileDecorationBadges ? "tab-label-has-badge" : void 0].concat(editor.getLabelExtraClasses())),
      italic: !this.group.isPinned(editor),
      forceLabel,
      fileDecorations: {
        colors: Boolean((_c2 = options.decorations) == null ? void 0 : _c2.colors),
        badges: fileDecorationBadges
      }
    });
    const resource = EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });
    if (resource) {
      tabContainer.setAttribute("data-resource-name", basenameOrAuthority(resource));
    } else {
      tabContainer.removeAttribute("data-resource-name");
    }
  }
  redrawTabActiveAndDirty(isGroupActive, editor, tabContainer, tabActionBar) {
    const isTabActive = this.group.isActive(editor);
    const hasModifiedBorderTop = this.doRedrawTabDirty(isGroupActive, isTabActive, editor, tabContainer);
    this.doRedrawTabActive(isGroupActive, !hasModifiedBorderTop, editor, tabContainer, tabActionBar);
  }
  doRedrawTabActive(isGroupActive, allowBorderTop, editor, tabContainer, tabActionBar) {
    if (this.group.isActive(editor)) {
      tabContainer.classList.add("active");
      tabContainer.setAttribute("aria-selected", "true");
      tabContainer.tabIndex = 0;
      tabContainer.style.backgroundColor = this.getColor(isGroupActive ? TAB_ACTIVE_BACKGROUND : TAB_UNFOCUSED_ACTIVE_BACKGROUND) || "";
      const activeTabBorderColorBottom = this.getColor(isGroupActive ? TAB_ACTIVE_BORDER : TAB_UNFOCUSED_ACTIVE_BORDER);
      if (activeTabBorderColorBottom) {
        tabContainer.classList.add("tab-border-bottom");
        tabContainer.style.setProperty("--tab-border-bottom-color", activeTabBorderColorBottom.toString());
      } else {
        tabContainer.classList.remove("tab-border-bottom");
        tabContainer.style.removeProperty("--tab-border-bottom-color");
      }
      const activeTabBorderColorTop = allowBorderTop ? this.getColor(isGroupActive ? TAB_ACTIVE_BORDER_TOP : TAB_UNFOCUSED_ACTIVE_BORDER_TOP) : void 0;
      if (activeTabBorderColorTop) {
        tabContainer.classList.add("tab-border-top");
        tabContainer.style.setProperty("--tab-border-top-color", activeTabBorderColorTop.toString());
      } else {
        tabContainer.classList.remove("tab-border-top");
        tabContainer.style.removeProperty("--tab-border-top-color");
      }
      tabContainer.style.color = this.getColor(isGroupActive ? TAB_ACTIVE_FOREGROUND : TAB_UNFOCUSED_ACTIVE_FOREGROUND) || "";
      tabActionBar.setFocusable(true);
    } else {
      tabContainer.classList.remove("active");
      tabContainer.setAttribute("aria-selected", "false");
      tabContainer.tabIndex = -1;
      tabContainer.style.backgroundColor = this.getColor(isGroupActive ? TAB_INACTIVE_BACKGROUND : TAB_UNFOCUSED_INACTIVE_BACKGROUND) || "";
      tabContainer.style.boxShadow = "";
      tabContainer.style.color = this.getColor(isGroupActive ? TAB_INACTIVE_FOREGROUND : TAB_UNFOCUSED_INACTIVE_FOREGROUND) || "";
      tabActionBar.setFocusable(false);
    }
  }
  doRedrawTabDirty(isGroupActive, isTabActive, editor, tabContainer) {
    let hasModifiedBorderColor = false;
    if (editor.isDirty() && !editor.isSaving()) {
      tabContainer.classList.add("dirty");
      if (this.accessor.partOptions.highlightModifiedTabs) {
        let modifiedBorderColor;
        if (isGroupActive && isTabActive) {
          modifiedBorderColor = this.getColor(TAB_ACTIVE_MODIFIED_BORDER);
        } else if (isGroupActive && !isTabActive) {
          modifiedBorderColor = this.getColor(TAB_INACTIVE_MODIFIED_BORDER);
        } else if (!isGroupActive && isTabActive) {
          modifiedBorderColor = this.getColor(TAB_UNFOCUSED_ACTIVE_MODIFIED_BORDER);
        } else {
          modifiedBorderColor = this.getColor(TAB_UNFOCUSED_INACTIVE_MODIFIED_BORDER);
        }
        if (modifiedBorderColor) {
          hasModifiedBorderColor = true;
          tabContainer.classList.add("dirty-border-top");
          tabContainer.style.setProperty("--tab-dirty-border-top-color", modifiedBorderColor);
        }
      } else {
        tabContainer.classList.remove("dirty-border-top");
        tabContainer.style.removeProperty("--tab-dirty-border-top-color");
      }
    } else {
      tabContainer.classList.remove("dirty", "dirty-border-top");
      tabContainer.style.removeProperty("--tab-dirty-border-top-color");
    }
    return hasModifiedBorderColor;
  }
  redrawTabBorders(index, tabContainer) {
    const isTabSticky = this.group.isSticky(index);
    const isTabLastSticky = isTabSticky && this.group.stickyCount === index + 1;
    const borderRightColor = (isTabLastSticky ? this.getColor(TAB_LAST_PINNED_BORDER) : void 0) || this.getColor(TAB_BORDER) || this.getColor(contrastBorder);
    tabContainer.style.borderRight = borderRightColor ? `1px solid ${borderRightColor}` : "";
    tabContainer.style.outlineColor = this.getColor(activeContrastBorder) || "";
  }
  prepareEditorActions(editorActions) {
    const isGroupActive = this.accessor.activeGroup === this.group;
    if (isGroupActive) {
      return editorActions;
    } else {
      return {
        primary: editorActions.primary.filter((action) => action.id === UNLOCK_GROUP_COMMAND_ID),
        secondary: editorActions.secondary
      };
    }
  }
  getHeight() {
    const showsBreadcrumbs = this.breadcrumbsControl && !this.breadcrumbsControl.isHidden();
    if (this.dimensions.used) {
      return {
        total: this.dimensions.used.height,
        offset: showsBreadcrumbs ? this.dimensions.used.height - BreadcrumbsControl.HEIGHT : this.dimensions.used.height
      };
    } else {
      return this.computeHeight();
    }
  }
  computeHeight() {
    var _a2;
    let total;
    if (this.accessor.partOptions.wrapTabs && ((_a2 = this.tabsAndActionsContainer) == null ? void 0 : _a2.classList.contains("wrapping"))) {
      total = this.tabsAndActionsContainer.offsetHeight;
    } else {
      total = _k.TAB_HEIGHT;
    }
    const offset = total;
    if (this.breadcrumbsControl && !this.breadcrumbsControl.isHidden()) {
      total += BreadcrumbsControl.HEIGHT;
    }
    return { total, offset };
  }
  layout(dimensions, options) {
    Object.assign(this.dimensions, dimensions);
    if (!this.layoutScheduler.value) {
      const scheduledLayout = scheduleAtNextAnimationFrame(() => {
        var _a2;
        this.doLayout(this.dimensions, (_a2 = this.layoutScheduler.value) == null ? void 0 : _a2.options);
        this.layoutScheduler.clear();
      });
      this.layoutScheduler.value = { options, dispose: () => scheduledLayout.dispose() };
    }
    if (options == null ? void 0 : options.forceRevealActiveTab) {
      this.layoutScheduler.value.options = {
        ...this.layoutScheduler.value.options,
        forceRevealActiveTab: true
      };
    }
    if (!this.dimensions.used) {
      this.dimensions.used = new Dimension(dimensions.container.width, this.computeHeight().total);
    }
    return this.dimensions.used;
  }
  doLayout(dimensions, options) {
    const activeTabAndIndex = this.group.activeEditor ? this.getTabAndIndex(this.group.activeEditor) : void 0;
    if (activeTabAndIndex && dimensions.container !== Dimension.None && dimensions.available !== Dimension.None) {
      this.doLayoutBreadcrumbs(dimensions);
      const [activeTab, activeIndex] = activeTabAndIndex;
      this.doLayoutTabs(activeTab, activeIndex, dimensions, options);
    }
    const oldDimension = this.dimensions.used;
    const newDimension = this.dimensions.used = new Dimension(dimensions.container.width, this.computeHeight().total);
    if (oldDimension && oldDimension.height !== newDimension.height) {
      this.group.relayout();
    }
  }
  handleBreadcrumbsEnablementChange() {
    this.group.relayout();
  }
  doLayoutBreadcrumbs(dimensions) {
    if (this.breadcrumbsControl && !this.breadcrumbsControl.isHidden()) {
      this.breadcrumbsControl.layout(new Dimension(dimensions.container.width, BreadcrumbsControl.HEIGHT));
    }
  }
  doLayoutTabs(activeTab, activeIndex, dimensions, options) {
    const tabsWrapMultiLine = this.doLayoutTabsWrapping(dimensions);
    if (!tabsWrapMultiLine) {
      this.doLayoutTabsNonWrapping(activeTab, activeIndex, options);
    }
  }
  doLayoutTabsWrapping(dimensions) {
    const [tabsAndActionsContainer, tabsContainer, editorToolbarContainer, tabsScrollbar] = assertAllDefined(this.tabsAndActionsContainer, this.tabsContainer, this.editorToolbarContainer, this.tabsScrollbar);
    const didTabsWrapMultiLine = tabsAndActionsContainer.classList.contains("wrapping");
    let tabsWrapMultiLine = didTabsWrapMultiLine;
    function updateTabsWrapping(enabled) {
      tabsWrapMultiLine = enabled;
      tabsAndActionsContainer.classList.toggle("wrapping", tabsWrapMultiLine);
      tabsContainer.style.setProperty("--last-tab-margin-right", tabsWrapMultiLine ? `${editorToolbarContainer.offsetWidth}px` : "0");
    }
    if (this.accessor.partOptions.wrapTabs) {
      const visibleTabsWidth = tabsContainer.offsetWidth;
      const allTabsWidth = tabsContainer.scrollWidth;
      const lastTabFitsWrapped = () => {
        const lastTab = this.getLastTab();
        if (!lastTab) {
          return true;
        }
        const lastTabOverlapWithToolbarWidth = lastTab.offsetWidth + editorToolbarContainer.offsetWidth - dimensions.available.width;
        if (lastTabOverlapWithToolbarWidth > 1) {
          return false;
        }
        return true;
      };
      if (tabsWrapMultiLine || allTabsWidth > visibleTabsWidth && lastTabFitsWrapped()) {
        updateTabsWrapping(true);
      }
      if (tabsWrapMultiLine) {
        if (tabsContainer.offsetHeight > dimensions.available.height || allTabsWidth === visibleTabsWidth && tabsContainer.offsetHeight === _k.TAB_HEIGHT || !lastTabFitsWrapped()) {
          updateTabsWrapping(false);
        }
      }
    } else if (didTabsWrapMultiLine) {
      updateTabsWrapping(false);
    }
    if (tabsWrapMultiLine && !didTabsWrapMultiLine) {
      const visibleTabsWidth = tabsContainer.offsetWidth;
      tabsScrollbar.setScrollDimensions({
        width: visibleTabsWidth,
        scrollWidth: visibleTabsWidth
      });
    }
    if (tabsWrapMultiLine) {
      const tabs = /* @__PURE__ */ new Map();
      let currentTabsPosY = void 0;
      let lastTab = void 0;
      for (const child of tabsContainer.children) {
        const tab = child;
        const tabPosY = tab.offsetTop;
        if (tabPosY !== currentTabsPosY) {
          currentTabsPosY = tabPosY;
          if (lastTab) {
            tabs.set(lastTab, true);
          }
        }
        lastTab = tab;
        tabs.set(tab, false);
      }
      if (lastTab) {
        tabs.set(lastTab, true);
      }
      for (const [tab, lastInRow] of tabs) {
        tab.classList.toggle("last-in-row", lastInRow);
      }
    }
    return tabsWrapMultiLine;
  }
  doLayoutTabsNonWrapping(activeTab, activeIndex, options) {
    const [tabsContainer, tabsScrollbar] = assertAllDefined(this.tabsContainer, this.tabsScrollbar);
    const visibleTabsWidth = tabsContainer.offsetWidth;
    const allTabsWidth = tabsContainer.scrollWidth;
    let stickyTabsWidth = 0;
    if (this.group.stickyCount > 0) {
      let stickyTabWidth = 0;
      switch (this.accessor.partOptions.pinnedTabSizing) {
        case "compact":
          stickyTabWidth = _k.TAB_WIDTH.compact;
          break;
        case "shrink":
          stickyTabWidth = _k.TAB_WIDTH.shrink;
          break;
      }
      stickyTabsWidth = this.group.stickyCount * stickyTabWidth;
    }
    let activeTabPositionStatic = this.accessor.partOptions.pinnedTabSizing !== "normal" && this.group.isSticky(activeIndex);
    let availableTabsContainerWidth = visibleTabsWidth - stickyTabsWidth;
    if (this.group.stickyCount > 0 && availableTabsContainerWidth < _k.TAB_WIDTH.fit) {
      tabsContainer.classList.add("disable-sticky-tabs");
      availableTabsContainerWidth = visibleTabsWidth;
      stickyTabsWidth = 0;
      activeTabPositionStatic = false;
    } else {
      tabsContainer.classList.remove("disable-sticky-tabs");
    }
    let activeTabPosX;
    let activeTabWidth;
    if (!this.blockRevealActiveTab) {
      activeTabPosX = activeTab.offsetLeft;
      activeTabWidth = activeTab.offsetWidth;
    }
    const { width: oldVisibleTabsWidth, scrollWidth: oldAllTabsWidth } = tabsScrollbar.getScrollDimensions();
    tabsScrollbar.setScrollDimensions({
      width: visibleTabsWidth,
      scrollWidth: allTabsWidth
    });
    const dimensionsChanged = oldVisibleTabsWidth !== visibleTabsWidth || oldAllTabsWidth !== allTabsWidth;
    if (this.blockRevealActiveTab || typeof activeTabPosX !== "number" || typeof activeTabWidth !== "number" || activeTabPositionStatic || !dimensionsChanged && !(options == null ? void 0 : options.forceRevealActiveTab)) {
      this.blockRevealActiveTab = false;
      return;
    }
    const tabsContainerScrollPosX = tabsScrollbar.getScrollPosition().scrollLeft;
    const activeTabFits = activeTabWidth <= availableTabsContainerWidth;
    const adjustedActiveTabPosX = activeTabPosX - stickyTabsWidth;
    if (activeTabFits && tabsContainerScrollPosX + availableTabsContainerWidth < adjustedActiveTabPosX + activeTabWidth) {
      tabsScrollbar.setScrollPosition({
        scrollLeft: tabsContainerScrollPosX + (adjustedActiveTabPosX + activeTabWidth - (tabsContainerScrollPosX + availableTabsContainerWidth))
      });
    } else if (tabsContainerScrollPosX > adjustedActiveTabPosX || !activeTabFits) {
      tabsScrollbar.setScrollPosition({
        scrollLeft: adjustedActiveTabPosX
      });
    }
  }
  getTabAndIndex(editor) {
    const editorIndex = this.group.getIndexOfEditor(editor);
    const tab = this.getTabAtIndex(editorIndex);
    if (tab) {
      return [tab, editorIndex];
    }
    return void 0;
  }
  getTabAtIndex(editorIndex) {
    if (editorIndex >= 0) {
      const tabsContainer = assertIsDefined(this.tabsContainer);
      return tabsContainer.children[editorIndex];
    }
    return void 0;
  }
  getLastTab() {
    return this.getTabAtIndex(this.group.count - 1);
  }
  blockRevealActiveTabOnce() {
    this.blockRevealActiveTab = true;
  }
  originatesFromTabActionBar(e) {
    let element;
    if (e instanceof MouseEvent) {
      element = e.target || e.srcElement;
    } else {
      element = e.initialTarget;
    }
    return !!findParentWithClass(element, "action-item", "tab");
  }
  async onDrop(e, targetIndex, tabsContainer) {
    EventHelper.stop(e, true);
    this.updateDropFeedback(tabsContainer, false);
    tabsContainer.classList.remove("scroll");
    if (this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype)) {
      const data = this.groupTransfer.getData(DraggedEditorGroupIdentifier.prototype);
      if (Array.isArray(data)) {
        const sourceGroup = this.accessor.getGroup(data[0].identifier);
        if (sourceGroup) {
          const mergeGroupOptions = { index: targetIndex };
          if (!this.isMoveOperation(e, sourceGroup.id)) {
            mergeGroupOptions.mode = 0;
          }
          this.accessor.mergeGroup(sourceGroup, this.group, mergeGroupOptions);
        }
        this.group.focus();
        this.groupTransfer.clearData(DraggedEditorGroupIdentifier.prototype);
      }
    } else if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {
      const data = this.editorTransfer.getData(DraggedEditorIdentifier.prototype);
      if (Array.isArray(data)) {
        const draggedEditor = data[0].identifier;
        const sourceGroup = this.accessor.getGroup(draggedEditor.groupId);
        if (sourceGroup) {
          if (this.isMoveOperation(e, draggedEditor.groupId, draggedEditor.editor)) {
            sourceGroup.moveEditor(draggedEditor.editor, this.group, { index: targetIndex });
          } else {
            sourceGroup.copyEditor(draggedEditor.editor, this.group, { index: targetIndex });
          }
        }
        this.group.focus();
        this.editorTransfer.clearData(DraggedEditorIdentifier.prototype);
      }
    } else if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
      const data = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype);
      if (Array.isArray(data)) {
        const editors = [];
        for (const id of data) {
          const dataTransferItem = await this.treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
          if (dataTransferItem) {
            const treeDropData = await extractTreeDropData(dataTransferItem);
            editors.push(...treeDropData.map(
              (editor) => ({ ...editor, options: { ...editor.options, pinned: true, index: targetIndex } })
            ));
          }
        }
        this.editorService.openEditors(editors, this.group, { validateTrust: true });
      }
      this.treeItemsTransfer.clearData(DraggedTreeItemsIdentifier.prototype);
    } else {
      const dropHandler = this.instantiationService.createInstance(ResourcesDropHandler, { allowWorkspaceOpen: false });
      dropHandler.handleDrop(e, () => this.group, () => this.group.focus(), targetIndex);
    }
  }
  isMoveOperation(e, sourceGroup, sourceEditor) {
    if (sourceEditor == null ? void 0 : sourceEditor.hasCapability(8)) {
      return true;
    }
    const isCopy = e.ctrlKey && !isMacintosh || e.altKey && isMacintosh;
    return !isCopy || sourceGroup === this.group.id;
  }
  dispose() {
    super.dispose();
    this.tabDisposables = dispose(this.tabDisposables);
  }
}, _k.SCROLLBAR_SIZES = {
  default: 3,
  large: 10
}, _k.TAB_WIDTH = {
  compact: 38,
  shrink: 80,
  fit: 120
}, _k.TAB_HEIGHT = 35, _k.DRAG_OVER_OPEN_TAB_THRESHOLD = 1500, _k.MOUSE_WHEEL_EVENT_THRESHOLD = 150, _k.MOUSE_WHEEL_DISTANCE_THRESHOLD = 1.5, _k);
TabsTitleControl = __decorate([
  __param(3, IContextMenuService),
  __param(4, IInstantiationService),
  __param(5, IContextKeyService),
  __param(6, IKeybindingService),
  __param(7, INotificationService),
  __param(8, IMenuService),
  __param(9, IQuickInputService),
  __param(10, IThemeService),
  __param(11, IConfigurationService),
  __param(12, IFileService),
  __param(13, IEditorService),
  __param(14, IPathService),
  __param(15, IEditorGroupsService),
  __param(16, ITreeViewsDnDService),
  __param(17, IEditorResolverService)
], TabsTitleControl);
registerThemingParticipant((theme, collector) => {
  const borderColor = theme.getColor(TAB_BORDER);
  if (borderColor) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title > .tabs-and-actions-container.wrapping .tabs-container > .tab {
				border-bottom: 1px solid ${borderColor};
			}
		`);
  }
  const activeContrastBorderColor = theme.getColor(activeContrastBorder);
  if (activeContrastBorderColor) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab.active,
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab.active:hover  {
				outline: 1px solid;
				outline-offset: -5px;
			}

			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active {
				outline: 1px dotted;
				outline-offset: -5px;
			}

			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {
				outline: 1px dashed;
				outline-offset: -5px;
			}

			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active:hover > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.dirty > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab.sticky > .tab-actions .action-label,
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover > .tab-actions .action-label {
				opacity: 1 !important;
			}
		`);
  }
  const contrastBorderColor = theme.getColor(contrastBorder);
  if (contrastBorderColor) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .editor-actions {
				outline: 1px solid ${contrastBorderColor}
			}
		`);
  }
  const tabHoverBackground = theme.getColor(TAB_HOVER_BACKGROUND);
  if (tabHoverBackground) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover  {
				background-color: ${tabHoverBackground} !important;
			}
		`);
  }
  const tabUnfocusedHoverBackground = theme.getColor(TAB_UNFOCUSED_HOVER_BACKGROUND);
  if (tabUnfocusedHoverBackground) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {
				background-color: ${tabUnfocusedHoverBackground} !important;
			}
		`);
  }
  const tabHoverForeground = theme.getColor(TAB_HOVER_FOREGROUND);
  if (tabHoverForeground) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover  {
				color: ${tabHoverForeground} !important;
			}
		`);
  }
  const tabUnfocusedHoverForeground = theme.getColor(TAB_UNFOCUSED_HOVER_FOREGROUND);
  if (tabUnfocusedHoverForeground) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {
				color: ${tabUnfocusedHoverForeground} !important;
			}
		`);
  }
  const tabHoverBorder = theme.getColor(TAB_HOVER_BORDER);
  if (tabHoverBorder) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover > .tab-border-bottom-container {
				display: block;
				position: absolute;
				left: 0;
				pointer-events: none;
				width: 100%;
				z-index: 10;
				bottom: 0;
				height: 1px;
				background-color: ${tabHoverBorder};
			}
		`);
  }
  const tabUnfocusedHoverBorder = theme.getColor(TAB_UNFOCUSED_HOVER_BORDER);
  if (tabUnfocusedHoverBorder) {
    collector.addRule(`
			.monaco-workbench .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover > .tab-border-bottom-container  {
				display: block;
				position: absolute;
				left: 0;
				pointer-events: none;
				width: 100%;
				z-index: 10;
				bottom: 0;
				height: 1px;
				background-color: ${tabUnfocusedHoverBorder};
			}
		`);
  }
  if (!isHighContrast(theme.type) && !isSafari && !activeContrastBorderColor) {
    const workbenchBackground = WORKBENCH_BACKGROUND(theme);
    const editorBackgroundColor = theme.getColor(editorBackground);
    const editorGroupHeaderTabsBackground = theme.getColor(EDITOR_GROUP_HEADER_TABS_BACKGROUND);
    const editorDragAndDropBackground = theme.getColor(EDITOR_DRAG_AND_DROP_BACKGROUND);
    let adjustedTabBackground;
    if (editorGroupHeaderTabsBackground && editorBackgroundColor) {
      adjustedTabBackground = editorGroupHeaderTabsBackground.flatten(editorBackgroundColor, editorBackgroundColor, workbenchBackground);
    }
    let adjustedTabDragBackground;
    if (editorGroupHeaderTabsBackground && editorBackgroundColor && editorDragAndDropBackground && editorBackgroundColor) {
      adjustedTabDragBackground = editorGroupHeaderTabsBackground.flatten(editorBackgroundColor, editorDragAndDropBackground, editorBackgroundColor, workbenchBackground);
    }
    const makeTabHoverBackgroundRule = (color, colorDrag, hasFocus = false) => `
			.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${hasFocus ? ".active" : ""} > .title .tabs-container > .tab.sizing-shrink:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after,
			.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${hasFocus ? ".active" : ""} > .title .tabs-container > .tab.sizing-fixed:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after {
				background: linear-gradient(to left, ${color}, transparent) !important;
			}

			.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${hasFocus ? ".active" : ""} > .title .tabs-container > .tab.sizing-shrink:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after,
			.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${hasFocus ? ".active" : ""} > .title .tabs-container > .tab.sizing-fixed:not(.dragged):not(.sticky-compact):hover > .tab-label > .monaco-icon-label-container::after {
				background: linear-gradient(to left, ${colorDrag}, transparent) !important;
			}
		`;
    if (tabHoverBackground && adjustedTabBackground && adjustedTabDragBackground) {
      const adjustedColor = tabHoverBackground.flatten(adjustedTabBackground);
      const adjustedColorDrag = tabHoverBackground.flatten(adjustedTabDragBackground);
      collector.addRule(makeTabHoverBackgroundRule(adjustedColor, adjustedColorDrag, true));
    }
    if (tabUnfocusedHoverBackground && adjustedTabBackground && adjustedTabDragBackground) {
      const adjustedColor = tabUnfocusedHoverBackground.flatten(adjustedTabBackground);
      const adjustedColorDrag = tabUnfocusedHoverBackground.flatten(adjustedTabDragBackground);
      collector.addRule(makeTabHoverBackgroundRule(adjustedColor, adjustedColorDrag));
    }
    if (editorDragAndDropBackground && adjustedTabDragBackground) {
      const adjustedColorDrag = editorDragAndDropBackground.flatten(adjustedTabDragBackground);
      collector.addRule(`
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container.active > .title .tabs-container > .tab.sizing-shrink.dragged-over:not(.active):not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container:not(.active) > .title .tabs-container > .tab.sizing-shrink.dragged-over:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container.active > .title .tabs-container > .tab.sizing-fixed.dragged-over:not(.active):not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container:not(.active) > .title .tabs-container > .tab.sizing-fixed.dragged-over:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after {
					background: linear-gradient(to left, ${adjustedColorDrag}, transparent) !important;
				}
		`);
    }
    const makeTabBackgroundRule = (color, colorDrag, focused, active) => `
				.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${focused ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-shrink${active ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content:not(.dragged-over) .editor-group-container${focused ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-fixed${active ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after {
					background: linear-gradient(to left, ${color}, transparent);
				}

				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${focused ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-shrink${active ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after,
				.monaco-workbench .part.editor > .content.dragged-over .editor-group-container${focused ? ".active" : ":not(.active)"} > .title .tabs-container > .tab.sizing-fixed${active ? ".active" : ""}:not(.dragged):not(.sticky-compact) > .tab-label > .monaco-icon-label-container::after {
					background: linear-gradient(to left, ${colorDrag}, transparent);
				}
		`;
    const tabActiveBackground = theme.getColor(TAB_ACTIVE_BACKGROUND);
    if (tabActiveBackground && adjustedTabBackground && adjustedTabDragBackground) {
      const adjustedColor = tabActiveBackground.flatten(adjustedTabBackground);
      const adjustedColorDrag = tabActiveBackground.flatten(adjustedTabDragBackground);
      collector.addRule(makeTabBackgroundRule(adjustedColor, adjustedColorDrag, true, true));
    }
    const tabUnfocusedActiveBackground = theme.getColor(TAB_UNFOCUSED_ACTIVE_BACKGROUND);
    if (tabUnfocusedActiveBackground && adjustedTabBackground && adjustedTabDragBackground) {
      const adjustedColor = tabUnfocusedActiveBackground.flatten(adjustedTabBackground);
      const adjustedColorDrag = tabUnfocusedActiveBackground.flatten(adjustedTabDragBackground);
      collector.addRule(makeTabBackgroundRule(adjustedColor, adjustedColorDrag, false, true));
    }
    const tabInactiveBackground = theme.getColor(TAB_INACTIVE_BACKGROUND);
    if (tabInactiveBackground && adjustedTabBackground && adjustedTabDragBackground) {
      const adjustedColor = tabInactiveBackground.flatten(adjustedTabBackground);
      const adjustedColorDrag = tabInactiveBackground.flatten(adjustedTabDragBackground);
      collector.addRule(makeTabBackgroundRule(adjustedColor, adjustedColorDrag, true, false));
    }
    const tabUnfocusedInactiveBackground = theme.getColor(TAB_UNFOCUSED_INACTIVE_BACKGROUND);
    if (tabUnfocusedInactiveBackground && adjustedTabBackground && adjustedTabDragBackground) {
      const adjustedColor = tabUnfocusedInactiveBackground.flatten(adjustedTabBackground);
      const adjustedColorDrag = tabUnfocusedInactiveBackground.flatten(adjustedTabDragBackground);
      collector.addRule(makeTabBackgroundRule(adjustedColor, adjustedColorDrag, false, false));
    }
  }
});
let EditorPanes = class EditorPanes2 extends Disposable {
  get minimumWidth() {
    var _a2;
    return ((_a2 = this._activeEditorPane) == null ? void 0 : _a2.minimumWidth) ?? DEFAULT_EDITOR_MIN_DIMENSIONS.width;
  }
  get minimumHeight() {
    var _a2;
    return ((_a2 = this._activeEditorPane) == null ? void 0 : _a2.minimumHeight) ?? DEFAULT_EDITOR_MIN_DIMENSIONS.height;
  }
  get maximumWidth() {
    var _a2;
    return ((_a2 = this._activeEditorPane) == null ? void 0 : _a2.maximumWidth) ?? DEFAULT_EDITOR_MAX_DIMENSIONS.width;
  }
  get maximumHeight() {
    var _a2;
    return ((_a2 = this._activeEditorPane) == null ? void 0 : _a2.maximumHeight) ?? DEFAULT_EDITOR_MAX_DIMENSIONS.height;
  }
  get activeEditorPane() {
    return this._activeEditorPane;
  }
  constructor(editorGroupParent, editorPanesParent, groupView, layoutService, instantiationService, editorProgressService, workspaceTrustService, logService, dialogService) {
    super();
    this.editorGroupParent = editorGroupParent;
    this.editorPanesParent = editorPanesParent;
    this.groupView = groupView;
    this.layoutService = layoutService;
    this.instantiationService = instantiationService;
    this.editorProgressService = editorProgressService;
    this.workspaceTrustService = workspaceTrustService;
    this.logService = logService;
    this.dialogService = dialogService;
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidChangeSizeConstraints = this._register(new Emitter());
    this.onDidChangeSizeConstraints = this._onDidChangeSizeConstraints.event;
    this._activeEditorPane = null;
    this.editorPanes = [];
    this.activeEditorPaneDisposables = this._register(new DisposableStore());
    this.editorOperation = this._register(new LongRunningOperation(this.editorProgressService));
    this.editorPanesRegistry = Registry.as(EditorExtensions.EditorPane);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.workspaceTrustService.onDidChangeTrust(() => this.onDidChangeWorkspaceTrust()));
  }
  onDidChangeWorkspaceTrust() {
    var _a2, _b2;
    const editor = (_a2 = this._activeEditorPane) == null ? void 0 : _a2.input;
    const options = (_b2 = this._activeEditorPane) == null ? void 0 : _b2.options;
    if (editor == null ? void 0 : editor.hasCapability(16)) {
      this.groupView.openEditor(editor, options);
    }
  }
  async openEditor(editor, options, context = /* @__PURE__ */ Object.create(null)) {
    try {
      return await this.doOpenEditor(this.getEditorPaneDescriptor(editor), editor, options, context);
    } catch (error) {
      if (options == null ? void 0 : options.ignoreError) {
        return { error };
      }
      return this.doShowError(error, editor, options, context);
    }
  }
  async doShowError(error, editor, options, context) {
    this.logService.error(error);
    let errorHandled = false;
    if ((options == null ? void 0 : options.source) === EditorOpenSource.USER && (!isEditorOpenError(error) || error.allowDialog)) {
      errorHandled = await this.doShowErrorDialog(error, editor);
    }
    if (errorHandled) {
      return { error };
    }
    const editorPlaceholderOptions = { ...options };
    if (!isCancellationError(error)) {
      editorPlaceholderOptions.error = error;
    }
    return {
      ...await this.doOpenEditor(ErrorPlaceholderEditor.DESCRIPTOR, editor, editorPlaceholderOptions, context),
      error
    };
  }
  async doShowErrorDialog(error, editor) {
    let severity = Severity$1.Error;
    let message = void 0;
    let detail = toErrorMessage(error);
    let errorActions = void 0;
    if (isEditorOpenError(error)) {
      errorActions = error.actions;
      severity = error.forceSeverity ?? Severity$1.Error;
      if (error.forceMessage) {
        message = error.message;
        detail = void 0;
      }
    }
    if (!message) {
      message = localize("editorOpenErrorDialog", "Unable to open '{0}'", editor.getName());
    }
    const buttons = [];
    if (errorActions && errorActions.length > 0) {
      for (const errorAction of errorActions) {
        buttons.push({
          label: errorAction.label,
          run: () => errorAction
        });
      }
    } else {
      buttons.push({
        label: localize({ key: "ok", comment: ["&& denotes a mnemonic"] }, "&&OK"),
        run: () => void 0
      });
    }
    let cancelButton = void 0;
    if (buttons.length === 1) {
      cancelButton = {
        run: () => {
          errorHandled = true;
          return void 0;
        }
      };
    }
    let errorHandled = false;
    const { result } = await this.dialogService.prompt({
      type: severity,
      message,
      detail,
      buttons,
      cancelButton
    });
    if (result) {
      const errorActionResult = result.run();
      if (errorActionResult instanceof Promise) {
        errorActionResult.catch((error2) => this.dialogService.error(toErrorMessage(error2)));
      }
      errorHandled = true;
    }
    return errorHandled;
  }
  async doOpenEditor(descriptor, editor, options, context = /* @__PURE__ */ Object.create(null)) {
    const pane = this.doShowEditorPane(descriptor);
    const activeElement = document.activeElement;
    const { changed, cancelled } = await this.doSetInput(pane, editor, options, context);
    const focus = !options || !options.preserveFocus;
    if (!cancelled && focus && this.shouldRestoreFocus(activeElement)) {
      pane.focus();
    }
    return { pane, changed, cancelled };
  }
  shouldRestoreFocus(expectedActiveElement) {
    if (!this.layoutService.isRestored()) {
      return true;
    }
    if (!expectedActiveElement) {
      return true;
    }
    const activeElement = document.activeElement;
    if (!activeElement || activeElement === document.body) {
      return true;
    }
    const same = expectedActiveElement === activeElement;
    if (same) {
      return true;
    }
    if (activeElement.tagName !== "INPUT" && activeElement.tagName !== "TEXTAREA") {
      return true;
    }
    if (isAncestor(activeElement, this.editorGroupParent)) {
      return true;
    }
    return false;
  }
  getEditorPaneDescriptor(editor) {
    if (editor.hasCapability(16) && !this.workspaceTrustService.isWorkspaceTrusted()) {
      return WorkspaceTrustRequiredPlaceholderEditor.DESCRIPTOR;
    }
    return assertIsDefined(this.editorPanesRegistry.getEditorPane(editor));
  }
  doShowEditorPane(descriptor) {
    if (this._activeEditorPane && descriptor.describes(this._activeEditorPane)) {
      return this._activeEditorPane;
    }
    this.doHideActiveEditorPane();
    const editorPane = this.doCreateEditorPane(descriptor);
    this.doSetActiveEditorPane(editorPane);
    const container = assertIsDefined(editorPane.getContainer());
    this.editorPanesParent.appendChild(container);
    show(container);
    editorPane.setVisible(true, this.groupView);
    if (this.pagePosition) {
      editorPane.layout(new Dimension(this.pagePosition.width, this.pagePosition.height), { top: this.pagePosition.top, left: this.pagePosition.left });
    }
    if (this.boundarySashes) {
      editorPane.setBoundarySashes(this.boundarySashes);
    }
    return editorPane;
  }
  doCreateEditorPane(descriptor) {
    const editorPane = this.doInstantiateEditorPane(descriptor);
    if (!editorPane.getContainer()) {
      const editorPaneContainer = document.createElement("div");
      editorPaneContainer.classList.add("editor-instance");
      editorPane.create(editorPaneContainer);
    }
    return editorPane;
  }
  doInstantiateEditorPane(descriptor) {
    const existingEditorPane = this.editorPanes.find((editorPane2) => descriptor.describes(editorPane2));
    if (existingEditorPane) {
      return existingEditorPane;
    }
    const editorPane = this._register(descriptor.instantiate(this.instantiationService));
    this.editorPanes.push(editorPane);
    return editorPane;
  }
  doSetActiveEditorPane(editorPane) {
    this._activeEditorPane = editorPane;
    this.activeEditorPaneDisposables.clear();
    if (editorPane) {
      this.activeEditorPaneDisposables.add(editorPane.onDidChangeSizeConstraints((e) => this._onDidChangeSizeConstraints.fire(e)));
      this.activeEditorPaneDisposables.add(editorPane.onDidFocus(() => this._onDidFocus.fire()));
    }
    this._onDidChangeSizeConstraints.fire(void 0);
  }
  async doSetInput(editorPane, editor, options, context) {
    var _a2;
    const inputMatches = (_a2 = editorPane.input) == null ? void 0 : _a2.matches(editor);
    if (inputMatches && !(options == null ? void 0 : options.forceReload)) {
      editorPane.setOptions(options);
      return { changed: false, cancelled: false };
    }
    const operation = this.editorOperation.start(this.layoutService.isRestored() ? 800 : 3200);
    let cancelled = false;
    try {
      editorPane.clearInput();
      await editorPane.setInput(editor, options, context, operation.token);
      if (!operation.isCurrent()) {
        cancelled = true;
      }
    } catch (error) {
      if (!operation.isCurrent()) {
        cancelled = true;
      } else {
        throw error;
      }
    } finally {
      operation.stop();
    }
    return { changed: !inputMatches, cancelled };
  }
  doHideActiveEditorPane() {
    if (!this._activeEditorPane) {
      return;
    }
    this.editorOperation.stop();
    this.safeRun(() => {
      var _a2;
      return (_a2 = this._activeEditorPane) == null ? void 0 : _a2.clearInput();
    });
    this.safeRun(() => {
      var _a2;
      return (_a2 = this._activeEditorPane) == null ? void 0 : _a2.setVisible(false, this.groupView);
    });
    const editorPaneContainer = this._activeEditorPane.getContainer();
    if (editorPaneContainer) {
      this.editorPanesParent.removeChild(editorPaneContainer);
      hide(editorPaneContainer);
    }
    this.doSetActiveEditorPane(null);
  }
  closeEditor(editor) {
    var _a2;
    if (((_a2 = this._activeEditorPane) == null ? void 0 : _a2.input) && editor.matches(this._activeEditorPane.input)) {
      this.doHideActiveEditorPane();
    }
  }
  setVisible(visible) {
    this.safeRun(() => {
      var _a2;
      return (_a2 = this._activeEditorPane) == null ? void 0 : _a2.setVisible(visible, this.groupView);
    });
  }
  layout(pagePosition) {
    this.pagePosition = pagePosition;
    this.safeRun(() => {
      var _a2;
      return (_a2 = this._activeEditorPane) == null ? void 0 : _a2.layout(new Dimension(pagePosition.width, pagePosition.height), pagePosition);
    });
  }
  setBoundarySashes(sashes) {
    this.boundarySashes = sashes;
    this.safeRun(() => {
      var _a2;
      return (_a2 = this._activeEditorPane) == null ? void 0 : _a2.setBoundarySashes(sashes);
    });
  }
  safeRun(fn) {
    try {
      fn();
    } catch (error) {
      this.logService.error(error);
    }
  }
};
EditorPanes = __decorate([
  __param(3, IWorkbenchLayoutService),
  __param(4, IInstantiationService),
  __param(5, IEditorProgressService),
  __param(6, IWorkspaceTrustManagementService),
  __param(7, ILogService),
  __param(8, IDialogService)
], EditorPanes);
var css$a = '.monaco-workbench .part.editor>.content .editor-group-container>.title>.label-container{align-items:center;display:flex;flex:auto;height:35px;justify-content:flex-start;overflow:hidden}.monaco-workbench .part.editor>.content .editor-group-container>.title>.label-container>.title-label{line-height:35px;overflow:hidden;padding-left:20px;position:relative;text-overflow:ellipsis}.monaco-workbench .part.editor>.content .editor-group-container>.title>.label-container>.title-label>.monaco-icon-label-container{flex:initial}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .no-tabs.title-label{flex:none}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control{flex:1 50%;margin-left:.45em;overflow:hidden}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item{font-size:.9em}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control.preview .monaco-breadcrumb-item{font-style:italic}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:before{background-image:none;content:"/";height:inherit;opacity:1;width:inherit}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control.backslash-path .monaco-breadcrumb-item:before{content:"\\\\"}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item.root_folder+.monaco-breadcrumb-item:before,.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item.root_folder:before,.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control.relative-path .monaco-breadcrumb-item:nth-child(2):before,.monaco-workbench.windows .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:nth-child(2):before{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item.root_folder:after{content:"\\00a0•\\00a0";padding:0}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item:last-child{padding-right:4px}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item .codicon[class*=codicon-symbol-]{padding:0 1px}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-breadcrumb-item .codicon:last-child{display:none}.monaco-workbench .part.editor>.content .editor-group-container>.title.breadcrumbs .breadcrumbs-control .monaco-icon-label:before{height:18px;padding-right:2px}.monaco-workbench .part.editor>.content .editor-group-container>.title>.title-actions{display:flex;flex:initial;height:35px;opacity:.5;padding-right:8px}.monaco-workbench .part.editor>.content .editor-group-container>.title>.title-actions .action-item{margin-right:4px}.monaco-workbench .part.editor>.content .editor-group-container.active>.title>.title-actions{opacity:1}';
n(css$a, {});
const _NoTabsTitleControl = class _NoTabsTitleControl extends TitleControl {
  constructor() {
    super(...arguments);
    this.activeLabel = /* @__PURE__ */ Object.create(null);
  }
  create(parent) {
    const titleContainer = this.titleContainer = parent;
    titleContainer.draggable = true;
    this.registerContainerListeners(titleContainer);
    this._register(Gesture.addTarget(titleContainer));
    const labelContainer = document.createElement("div");
    labelContainer.classList.add("label-container");
    titleContainer.appendChild(labelContainer);
    this.editorLabel = this._register(this.instantiationService.createInstance(ResourceLabel, labelContainer, void 0)).element;
    this._register(addDisposableListener(this.editorLabel.element, EventType.CLICK, (e) => this.onTitleLabelClick(e)));
    this.createBreadcrumbsControl(labelContainer, { showFileIcons: false, showSymbolIcons: true, showDecorationColors: false, widgetStyles: { ...defaultBreadcrumbsWidgetStyles, breadcrumbsBackground: Color.transparent.toString() }, showPlaceholder: false });
    titleContainer.classList.toggle("breadcrumbs", Boolean(this.breadcrumbsControl));
    this._register(toDisposable(() => titleContainer.classList.remove("breadcrumbs")));
    const actionsContainer = document.createElement("div");
    actionsContainer.classList.add("title-actions");
    titleContainer.appendChild(actionsContainer);
    this.createEditorActionsToolBar(actionsContainer);
  }
  registerContainerListeners(titleContainer) {
    this.enableGroupDragging(titleContainer);
    this._register(addDisposableListener(titleContainer, EventType.DBLCLICK, (e) => this.onTitleDoubleClick(e)));
    this._register(addDisposableListener(titleContainer, EventType.AUXCLICK, (e) => this.onTitleAuxClick(e)));
    this._register(addDisposableListener(titleContainer, EventType$1.Tap, (e) => this.onTitleTap(e)));
    for (const event of [EventType.CONTEXT_MENU, EventType$1.Contextmenu]) {
      this._register(addDisposableListener(titleContainer, event, (e) => {
        if (this.group.activeEditor) {
          this.onContextMenu(this.group.activeEditor, e, titleContainer);
        }
      }));
    }
  }
  onTitleLabelClick(e) {
    EventHelper.stop(e, false);
    setTimeout(() => this.quickInputService.quickAccess.show());
  }
  onTitleDoubleClick(e) {
    EventHelper.stop(e);
    this.group.pinEditor();
  }
  onTitleAuxClick(e) {
    if (e.button === 1 && this.group.activeEditor) {
      EventHelper.stop(e, true);
      this.group.closeEditor(this.group.activeEditor);
    }
  }
  onTitleTap(e) {
    const target = e.initialTarget;
    if (!(target instanceof HTMLElement) || !this.editorLabel || !isAncestor(target, this.editorLabel.element)) {
      return;
    }
    setTimeout(() => this.quickInputService.quickAccess.show(), 50);
  }
  openEditor(editor) {
    this.doHandleOpenEditor();
  }
  openEditors(editors) {
    this.doHandleOpenEditor();
  }
  doHandleOpenEditor() {
    const activeEditorChanged = this.ifActiveEditorChanged(() => this.redraw());
    if (!activeEditorChanged) {
      this.ifActiveEditorPropertiesChanged(() => this.redraw());
    }
  }
  beforeCloseEditor(editor) {
  }
  closeEditor(editor) {
    this.ifActiveEditorChanged(() => this.redraw());
  }
  closeEditors(editors) {
    this.ifActiveEditorChanged(() => this.redraw());
  }
  moveEditor(editor, fromIndex, targetIndex) {
    this.ifActiveEditorChanged(() => this.redraw());
  }
  pinEditor(editor) {
    this.ifEditorIsActive(editor, () => this.redraw());
  }
  stickEditor(editor) {
  }
  unstickEditor(editor) {
  }
  setActive(isActive) {
    this.redraw();
  }
  updateEditorLabel(editor) {
    this.ifEditorIsActive(editor, () => this.redraw());
  }
  updateEditorDirty(editor) {
    this.ifEditorIsActive(editor, () => {
      const titleContainer = assertIsDefined(this.titleContainer);
      if (editor.isDirty() && !editor.isSaving()) {
        titleContainer.classList.add("dirty");
      } else {
        titleContainer.classList.remove("dirty");
      }
    });
  }
  updateOptions(oldOptions, newOptions) {
    if (oldOptions.labelFormat !== newOptions.labelFormat || !equals$1(oldOptions.decorations, newOptions.decorations)) {
      this.redraw();
    }
  }
  updateStyles() {
    this.redraw();
  }
  handleBreadcrumbsEnablementChange() {
    const titleContainer = assertIsDefined(this.titleContainer);
    titleContainer.classList.toggle("breadcrumbs", Boolean(this.breadcrumbsControl));
    this.redraw();
  }
  ifActiveEditorChanged(fn) {
    if (!this.activeLabel.editor && this.group.activeEditor || this.activeLabel.editor && !this.group.activeEditor || (!this.activeLabel.editor || !this.group.isActive(this.activeLabel.editor))) {
      fn();
      return true;
    }
    return false;
  }
  ifActiveEditorPropertiesChanged(fn) {
    if (!this.activeLabel.editor || !this.group.activeEditor) {
      return;
    }
    if (this.activeLabel.pinned !== this.group.isPinned(this.group.activeEditor)) {
      fn();
    }
  }
  ifEditorIsActive(editor, fn) {
    if (this.group.isActive(editor)) {
      fn();
    }
  }
  redraw() {
    var _a2, _b2;
    const editor = withNullAsUndefined(this.group.activeEditor);
    const options = this.accessor.partOptions;
    const isEditorPinned = editor ? this.group.isPinned(editor) : false;
    const isGroupActive = this.accessor.activeGroup === this.group;
    this.activeLabel = { editor, pinned: isEditorPinned };
    if (this.breadcrumbsControl) {
      if (isGroupActive) {
        this.breadcrumbsControl.update();
        this.breadcrumbsControl.domNode.classList.toggle("preview", !isEditorPinned);
      } else {
        this.breadcrumbsControl.hide();
      }
    }
    const [titleContainer, editorLabel] = assertAllDefined(this.titleContainer, this.editorLabel);
    if (!editor) {
      titleContainer.classList.remove("dirty");
      editorLabel.clear();
      this.clearEditorActionsToolbar();
    } else {
      this.updateEditorDirty(editor);
      const { labelFormat } = this.accessor.partOptions;
      let description;
      if (this.breadcrumbsControl && !this.breadcrumbsControl.isHidden()) {
        description = "";
      } else if (labelFormat === "default" && !isGroupActive) {
        description = "";
      } else {
        description = editor.getDescription(this.getVerbosity(labelFormat)) || "";
      }
      let title = editor.getTitle(2);
      if (description === title) {
        title = "";
      }
      editorLabel.setResource({
        resource: EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.BOTH }),
        name: editor.getName(),
        description
      }, {
        title,
        italic: !isEditorPinned,
        extraClasses: ["no-tabs", "title-label"].concat(editor.getLabelExtraClasses()),
        fileDecorations: {
          colors: Boolean((_a2 = options.decorations) == null ? void 0 : _a2.colors),
          badges: Boolean((_b2 = options.decorations) == null ? void 0 : _b2.badges)
        }
      });
      if (isGroupActive) {
        titleContainer.style.color = this.getColor(TAB_ACTIVE_FOREGROUND) || "";
      } else {
        titleContainer.style.color = this.getColor(TAB_UNFOCUSED_ACTIVE_FOREGROUND) || "";
      }
      this.updateEditorActionsToolbar();
    }
  }
  getVerbosity(style) {
    switch (style) {
      case "short":
        return 0;
      case "long":
        return 2;
      default:
        return 1;
    }
  }
  prepareEditorActions(editorActions) {
    const isGroupActive = this.accessor.activeGroup === this.group;
    if (isGroupActive) {
      return editorActions;
    } else {
      return {
        primary: editorActions.primary.filter((action) => action.id === CLOSE_EDITOR_COMMAND_ID || action.id === UNLOCK_GROUP_COMMAND_ID),
        secondary: editorActions.secondary
      };
    }
  }
  getHeight() {
    return {
      total: _NoTabsTitleControl.HEIGHT,
      offset: 0
    };
  }
  layout(dimensions) {
    var _a2;
    (_a2 = this.breadcrumbsControl) == null ? void 0 : _a2.layout(void 0);
    return new Dimension(dimensions.container.width, this.getHeight().total);
  }
};
_NoTabsTitleControl.HEIGHT = 35;
let NoTabsTitleControl = _NoTabsTitleControl;
const showCommands = { text: localize("watermark.showCommands", "Show All Commands"), id: "workbench.action.showCommands" };
const quickAccess = { text: localize("watermark.quickAccess", "Go to File"), id: "workbench.action.quickOpen" };
const openFileNonMacOnly = { text: localize("watermark.openFile", "Open File"), id: "workbench.action.files.openFile", mac: false };
const openFolderNonMacOnly = { text: localize("watermark.openFolder", "Open Folder"), id: "workbench.action.files.openFolder", mac: false };
const openFileOrFolderMacOnly = { text: localize("watermark.openFileFolder", "Open File or Folder"), id: "workbench.action.files.openFileFolder", mac: true };
const openRecent = { text: localize("watermark.openRecent", "Open Recent"), id: "workbench.action.openRecent" };
const newUntitledFile = { text: localize("watermark.newUntitledFile", "New Untitled Text File"), id: "workbench.action.files.newUntitledFile" };
const newUntitledFileMacOnly = Object.assign({ mac: true }, newUntitledFile);
const findInFiles = { text: localize("watermark.findInFiles", "Find in Files"), id: "workbench.action.findInFiles" };
const toggleTerminal = { text: localize(
  { key: "watermark.toggleTerminal", comment: ["toggle is a verb here"] },
  "Toggle Terminal"
), id: "workbench.action.terminal.toggleTerminal", when: ContextKeyExpr.equals("terminalProcessSupported", true) };
const startDebugging = { text: localize("watermark.startDebugging", "Start Debugging"), id: "workbench.action.debug.start", when: ContextKeyExpr.equals("terminalProcessSupported", true) };
const toggleFullscreen = { text: localize(
  { key: "watermark.toggleFullscreen", comment: ["toggle is a verb here"] },
  "Toggle Full Screen"
), id: "workbench.action.toggleFullScreen", when: ContextKeyExpr.equals("terminalProcessSupported", true).negate() };
const showSettings = { text: localize("watermark.showSettings", "Show Settings"), id: "workbench.action.openSettings", when: ContextKeyExpr.equals("terminalProcessSupported", true).negate() };
const noFolderEntries = [
  showCommands,
  openFileNonMacOnly,
  openFolderNonMacOnly,
  openFileOrFolderMacOnly,
  openRecent,
  newUntitledFileMacOnly
];
const folderEntries = [
  showCommands,
  quickAccess,
  findInFiles,
  startDebugging,
  toggleTerminal,
  toggleFullscreen,
  showSettings
];
let EditorGroupWatermark = class EditorGroupWatermark2 extends Disposable {
  constructor(container, lifecycleService, keybindingService, contextService, contextKeyService, configurationService, telemetryService) {
    super();
    this.lifecycleService = lifecycleService;
    this.keybindingService = keybindingService;
    this.contextService = contextService;
    this.contextKeyService = contextKeyService;
    this.configurationService = configurationService;
    this.telemetryService = telemetryService;
    this.transientDisposables = this._register(new DisposableStore());
    this.enabled = false;
    const elements = h(".editor-group-watermark", [
      h(".letterpress"),
      h(".shortcuts@shortcuts")
    ]);
    append(container, elements.root);
    this.shortcuts = elements.shortcuts;
    this.registerListeners();
    this.workbenchState = contextService.getWorkbenchState();
    this.render();
  }
  registerListeners() {
    this.lifecycleService.onDidShutdown(() => this.dispose());
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("workbench.tips.enabled")) {
        this.render();
      }
    }));
    this._register(this.contextService.onDidChangeWorkbenchState((workbenchState) => {
      if (this.workbenchState === workbenchState) {
        return;
      }
      this.workbenchState = workbenchState;
      this.render();
    }));
    const allEntriesWhenClauses = [...noFolderEntries, ...folderEntries].filter((entry) => entry.when !== void 0).map((entry) => entry.when);
    const allKeys = /* @__PURE__ */ new Set();
    allEntriesWhenClauses.forEach((when) => when.keys().forEach((key) => allKeys.add(key)));
    this._register(this.contextKeyService.onDidChangeContext((e) => {
      if (e.affectsSome(allKeys)) {
        this.render();
      }
    }));
  }
  render() {
    const enabled = this.configurationService.getValue("workbench.tips.enabled");
    if (enabled === this.enabled) {
      return;
    }
    this.enabled = enabled;
    this.clear();
    if (!enabled) {
      return;
    }
    const box = append(this.shortcuts, $$2(".watermark-box"));
    const folder = this.workbenchState !== 1;
    (folder ? folderEntries : noFolderEntries).filter((entry) => !("when" in entry) || this.contextKeyService.contextMatchesRules(entry.when)).filter((entry) => !("mac" in entry) || entry.mac === (isMacintosh && !isWeb)).filter((entry) => !!CommandsRegistry.getCommand(entry.id));
    const update = () => {
      clearNode(box);
    };
    update();
    this.transientDisposables.add(this.keybindingService.onDidUpdateKeybindings(update));
    this.telemetryService.publicLog("watermark:open");
  }
  clear() {
    clearNode(this.shortcuts);
    this.transientDisposables.clear();
  }
  dispose() {
    super.dispose();
    this.clear();
  }
};
EditorGroupWatermark = __decorate([
  __param(1, ILifecycleService),
  __param(2, IKeybindingService),
  __param(3, IWorkspaceContextService),
  __param(4, IContextKeyService),
  __param(5, IConfigurationService),
  __param(6, ITelemetryService)
], EditorGroupWatermark);
let EditorGroupView = class EditorGroupView2 extends Themable {
  static createNew(accessor, index, instantiationService) {
    return instantiationService.createInstance(EditorGroupView2, accessor, null, index);
  }
  static createFromSerialized(serialized, accessor, index, instantiationService) {
    return instantiationService.createInstance(EditorGroupView2, accessor, serialized, index);
  }
  static createCopy(copyFrom, accessor, index, instantiationService) {
    return instantiationService.createInstance(EditorGroupView2, accessor, copyFrom, index);
  }
  constructor(accessor, from, _index, instantiationService, contextKeyService, themeService, telemetryService, keybindingService, menuService, contextMenuService, fileDialogService, editorService, filesConfigurationService, uriIdentityService, logService) {
    super(themeService);
    this.accessor = accessor;
    this._index = _index;
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.telemetryService = telemetryService;
    this.keybindingService = keybindingService;
    this.menuService = menuService;
    this.contextMenuService = contextMenuService;
    this.fileDialogService = fileDialogService;
    this.editorService = editorService;
    this.filesConfigurationService = filesConfigurationService;
    this.uriIdentityService = uriIdentityService;
    this.logService = logService;
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this._onDidModelChange = this._register(new Emitter());
    this.onDidModelChange = this._onDidModelChange.event;
    this._onDidActiveEditorChange = this._register(new Emitter());
    this.onDidActiveEditorChange = this._onDidActiveEditorChange.event;
    this._onDidOpenEditorFail = this._register(new Emitter());
    this.onDidOpenEditorFail = this._onDidOpenEditorFail.event;
    this._onWillCloseEditor = this._register(new Emitter());
    this.onWillCloseEditor = this._onWillCloseEditor.event;
    this._onDidCloseEditor = this._register(new Emitter());
    this.onDidCloseEditor = this._onDidCloseEditor.event;
    this._onWillMoveEditor = this._register(new Emitter());
    this.onWillMoveEditor = this._onWillMoveEditor.event;
    this._onWillOpenEditor = this._register(new Emitter());
    this.onWillOpenEditor = this._onWillOpenEditor.event;
    this.disposedEditorsWorker = this._register(new RunOnceWorker((editors) => this.handleDisposedEditors(editors), 0));
    this.mapEditorToPendingConfirmation = /* @__PURE__ */ new Map();
    this.containerToolBarMenuDisposable = this._register(new MutableDisposable());
    this.whenRestoredPromise = new DeferredPromise();
    this.whenRestored = this.whenRestoredPromise.p;
    this._disposed = false;
    this.element = document.createElement("div");
    this._onDidChange = this._register(new Relay());
    this.onDidChange = this._onDidChange.event;
    if (from instanceof EditorGroupView2) {
      this.model = this._register(from.model.clone());
    } else if (isSerializedEditorGroupModel(from)) {
      this.model = this._register(instantiationService.createInstance(EditorGroupModel, from));
    } else {
      this.model = this._register(instantiationService.createInstance(EditorGroupModel, void 0));
    }
    {
      this.scopedContextKeyService = this._register(this.contextKeyService.createScoped(this.element));
      this.element.classList.add("editor-group-container");
      this.registerContainerListeners();
      this.createContainerToolbar();
      this.createContainerContextMenu();
      this._register(this.instantiationService.createInstance(EditorGroupWatermark, this.element));
      this.progressBar = this._register(new ProgressBar(this.element, defaultProgressBarStyles));
      this.progressBar.hide();
      this.scopedInstantiationService = this.instantiationService.createChild(new ServiceCollection(
        [IContextKeyService, this.scopedContextKeyService],
        [IEditorProgressService, this._register(new EditorProgressIndicator(this.progressBar, this))]
      ));
      this.handleGroupContextKeys();
      this.titleContainer = document.createElement("div");
      this.titleContainer.classList.add("title");
      this.element.appendChild(this.titleContainer);
      this.titleAreaControl = this.createTitleAreaControl();
      this.editorContainer = document.createElement("div");
      this.editorContainer.classList.add("editor-container");
      this.element.appendChild(this.editorContainer);
      this.editorPane = this._register(this.scopedInstantiationService.createInstance(EditorPanes, this.element, this.editorContainer, this));
      this._onDidChange.input = this.editorPane.onDidChangeSizeConstraints;
      this.doTrackFocus();
      this.updateTitleContainer();
      this.updateContainer();
      this.updateStyles();
    }
    const restoreEditorsPromise = this.restoreEditors(from) ?? Promise.resolve();
    restoreEditorsPromise.finally(() => {
      this.whenRestoredPromise.complete();
    });
    this.registerListeners();
  }
  handleGroupContextKeys() {
    const groupActiveEditorDirtyContext = ActiveEditorDirtyContext.bindTo(this.scopedContextKeyService);
    const groupActiveEditorPinnedContext = ActiveEditorPinnedContext.bindTo(this.scopedContextKeyService);
    const groupActiveEditorFirstContext = ActiveEditorFirstInGroupContext.bindTo(this.scopedContextKeyService);
    const groupActiveEditorLastContext = ActiveEditorLastInGroupContext.bindTo(this.scopedContextKeyService);
    const groupActiveEditorStickyContext = ActiveEditorStickyContext.bindTo(this.scopedContextKeyService);
    const groupEditorsCountContext = EditorGroupEditorsCountContext.bindTo(this.scopedContextKeyService);
    const groupLockedContext = ActiveEditorGroupLockedContext.bindTo(this.scopedContextKeyService);
    const activeEditorListener = new MutableDisposable();
    const observeActiveEditor = () => {
      activeEditorListener.clear();
      const activeEditor = this.model.activeEditor;
      if (activeEditor) {
        groupActiveEditorDirtyContext.set(activeEditor.isDirty() && !activeEditor.isSaving());
        activeEditorListener.value = activeEditor.onDidChangeDirty(() => {
          groupActiveEditorDirtyContext.set(activeEditor.isDirty() && !activeEditor.isSaving());
        });
      } else {
        groupActiveEditorDirtyContext.set(false);
      }
    };
    this._register(this.onDidModelChange((e) => {
      switch (e.kind) {
        case 2:
          groupLockedContext.set(this.isLocked);
          break;
        case 6:
        case 4:
        case 3:
        case 5:
          groupActiveEditorFirstContext.set(this.model.isFirst(this.model.activeEditor));
          groupActiveEditorLastContext.set(this.model.isLast(this.model.activeEditor));
          break;
        case 9:
          if (e.editor && e.editor === this.model.activeEditor) {
            groupActiveEditorPinnedContext.set(this.model.isPinned(this.model.activeEditor));
          }
          break;
        case 10:
          if (e.editor && e.editor === this.model.activeEditor) {
            groupActiveEditorStickyContext.set(this.model.isSticky(this.model.activeEditor));
          }
          break;
      }
      groupEditorsCountContext.set(this.count);
    }));
    this._register(this.onDidActiveEditorChange(() => {
      observeActiveEditor();
    }));
    observeActiveEditor();
  }
  registerContainerListeners() {
    this._register(addDisposableListener(this.element, EventType.DBLCLICK, (e) => {
      if (this.isEmpty) {
        EventHelper.stop(e);
        this.editorService.openEditor({
          resource: void 0,
          options: {
            pinned: true,
            override: DEFAULT_EDITOR_ASSOCIATION.id
          }
        }, this.id);
      }
    }));
    this._register(addDisposableListener(this.element, EventType.AUXCLICK, (e) => {
      if (this.isEmpty && e.button === 1) {
        EventHelper.stop(e, true);
        this.accessor.removeGroup(this);
      }
    }));
  }
  createContainerToolbar() {
    const toolbarContainer = document.createElement("div");
    toolbarContainer.classList.add("editor-group-container-toolbar");
    this.element.appendChild(toolbarContainer);
    const containerToolbar = this._register(new ActionBar(toolbarContainer, {
      ariaLabel: localize("ariaLabelGroupActions", "Empty editor group actions")
    }));
    const containerToolbarMenu = this._register(this.menuService.createMenu(MenuId.EmptyEditorGroup, this.scopedContextKeyService));
    const updateContainerToolbar = () => {
      const actions = { primary: [], secondary: [] };
      this.containerToolBarMenuDisposable.value = toDisposable(() => containerToolbar.clear());
      createAndFillInActionBarActions(containerToolbarMenu, { arg: { groupId: this.id }, shouldForwardArgs: true }, actions, "navigation");
      for (const action of [...actions.primary, ...actions.secondary]) {
        const keybinding = this.keybindingService.lookupKeybinding(action.id);
        containerToolbar.push(action, { icon: true, label: false, keybinding: keybinding == null ? void 0 : keybinding.getLabel() });
      }
    };
    updateContainerToolbar();
    this._register(containerToolbarMenu.onDidChange(updateContainerToolbar));
  }
  createContainerContextMenu() {
    this._register(addDisposableListener(this.element, EventType.CONTEXT_MENU, (e) => this.onShowContainerContextMenu(e)));
    this._register(addDisposableListener(this.element, EventType$1.Contextmenu, () => this.onShowContainerContextMenu()));
  }
  onShowContainerContextMenu(e) {
    if (!this.isEmpty) {
      return;
    }
    let anchor = this.element;
    if (e instanceof MouseEvent) {
      anchor = new StandardMouseEvent(e);
    }
    this.contextMenuService.showContextMenu({
      menuId: MenuId.EmptyEditorGroupContext,
      contextKeyService: this.contextKeyService,
      getAnchor: () => anchor,
      onHide: () => {
        this.focus();
      }
    });
  }
  doTrackFocus() {
    const containerFocusTracker = this._register(trackFocus(this.element));
    this._register(containerFocusTracker.onDidFocus(() => {
      if (this.isEmpty) {
        this._onDidFocus.fire();
      }
    }));
    const handleTitleClickOrTouch = (e) => {
      let target;
      if (e instanceof MouseEvent) {
        if (e.button !== 0 || isMacintosh && e.ctrlKey) {
          return void 0;
        }
        target = e.target;
      } else {
        target = e.initialTarget;
      }
      if (findParentWithClass(target, "monaco-action-bar", this.titleContainer) || findParentWithClass(target, "monaco-breadcrumb-item", this.titleContainer)) {
        return;
      }
      setTimeout(() => {
        this.focus();
      });
    };
    this._register(addDisposableListener(this.titleContainer, EventType.MOUSE_DOWN, (e) => handleTitleClickOrTouch(e)));
    this._register(addDisposableListener(this.titleContainer, EventType$1.Tap, (e) => handleTitleClickOrTouch(e)));
    this._register(this.editorPane.onDidFocus(() => {
      this._onDidFocus.fire();
    }));
  }
  updateContainer() {
    if (this.isEmpty) {
      this.element.classList.add("empty");
      this.element.tabIndex = 0;
      this.element.setAttribute("aria-label", localize("emptyEditorGroup", "{0} (empty)", this.label));
    } else {
      this.element.classList.remove("empty");
      this.element.removeAttribute("tabIndex");
      this.element.removeAttribute("aria-label");
    }
    this.updateStyles();
  }
  updateTitleContainer() {
    this.titleContainer.classList.toggle("tabs", this.accessor.partOptions.showTabs);
    this.titleContainer.classList.toggle("show-file-icons", this.accessor.partOptions.showIcons);
  }
  createTitleAreaControl() {
    if (this.titleAreaControl) {
      this.titleAreaControl.dispose();
      clearNode(this.titleContainer);
    }
    if (this.accessor.partOptions.showTabs) {
      this.titleAreaControl = this.scopedInstantiationService.createInstance(TabsTitleControl, this.titleContainer, this.accessor, this);
    } else {
      this.titleAreaControl = this.scopedInstantiationService.createInstance(NoTabsTitleControl, this.titleContainer, this.accessor, this);
    }
    return this.titleAreaControl;
  }
  restoreEditors(from) {
    if (this.count === 0) {
      return;
    }
    let options;
    if (from instanceof EditorGroupView2) {
      options = fillActiveEditorViewState(from);
    } else {
      options = /* @__PURE__ */ Object.create(null);
    }
    const activeEditor = this.model.activeEditor;
    if (!activeEditor) {
      return;
    }
    options.pinned = this.model.isPinned(activeEditor);
    options.sticky = this.model.isSticky(activeEditor);
    options.preserveFocus = true;
    const activeElement = document.activeElement;
    return this.doShowEditor(activeEditor, { active: true, isNew: false }, options).then(() => {
      if (this.accessor.activeGroup === this && activeElement === document.activeElement) {
        this.focus();
      }
    });
  }
  registerListeners() {
    this._register(this.model.onDidModelChange((e) => this.onDidGroupModelChange(e)));
    this._register(this.accessor.onDidChangeEditorPartOptions((e) => this.onDidChangeEditorPartOptions(e)));
    this._register(this.accessor.onDidVisibilityChange((e) => this.onDidVisibilityChange(e)));
  }
  onDidGroupModelChange(e) {
    this._onDidModelChange.fire(e);
    if (!e.editor) {
      return;
    }
    switch (e.kind) {
      case 3:
        if (isGroupEditorOpenEvent(e)) {
          this.onDidOpenEditor(e.editor, e.editorIndex);
        }
        break;
      case 4:
        if (isGroupEditorCloseEvent(e)) {
          this.handleOnDidCloseEditor(e.editor, e.editorIndex, e.context, e.sticky);
        }
        break;
      case 12:
        this.onWillDisposeEditor(e.editor);
        break;
      case 11:
        this.onDidChangeEditorDirty(e.editor);
        break;
      case 7:
        this.onDidChangeEditorLabel(e.editor);
        break;
    }
  }
  onDidOpenEditor(editor, editorIndex) {
    this.telemetryService.publicLog("editorOpened", this.toEditorTelemetryDescriptor(editor));
    this.updateContainer();
  }
  handleOnDidCloseEditor(editor, editorIndex, context, sticky) {
    this._onWillCloseEditor.fire({ groupId: this.id, editor, context, index: editorIndex, sticky });
    const editorsToClose = [editor];
    if (editor instanceof SideBySideEditorInput) {
      editorsToClose.push(editor.primary, editor.secondary);
    }
    for (const editor2 of editorsToClose) {
      if (this.canDispose(editor2)) {
        editor2.dispose();
      }
    }
    this.telemetryService.publicLog("editorClosed", this.toEditorTelemetryDescriptor(editor));
    this.updateContainer();
    this._onDidCloseEditor.fire({ groupId: this.id, editor, context, index: editorIndex, sticky });
  }
  canDispose(editor) {
    for (const groupView of this.accessor.groups) {
      if (groupView instanceof EditorGroupView2 && groupView.model.contains(editor, {
        strictEquals: true,
        supportSideBySide: SideBySideEditor.ANY
      })) {
        return false;
      }
    }
    return true;
  }
  toEditorTelemetryDescriptor(editor) {
    const descriptor = editor.getTelemetryDescriptor();
    const resource = EditorResourceAccessor.getOriginalUri(editor);
    const path = resource ? resource.scheme === Schemas.file ? resource.fsPath : resource.path : void 0;
    if (resource && path) {
      let resourceExt = extname(resource);
      const queryStringLocation = resourceExt.indexOf("?");
      resourceExt = queryStringLocation !== -1 ? resourceExt.substr(0, queryStringLocation) : resourceExt;
      descriptor["resource"] = { mimeType: new TelemetryTrustedValue(getMimeTypes(resource).join(", ")), scheme: resource.scheme, ext: resourceExt, path: hash(path) };
      return descriptor;
    }
    return descriptor;
  }
  onWillDisposeEditor(editor) {
    this.disposedEditorsWorker.work(editor);
  }
  handleDisposedEditors(disposedEditors) {
    let activeEditor;
    const inactiveEditors = [];
    for (const disposedEditor of disposedEditors) {
      const editorFindResult = this.model.findEditor(disposedEditor);
      if (!editorFindResult) {
        continue;
      }
      const editor = editorFindResult[0];
      if (!editor.isDisposed()) {
        continue;
      }
      if (this.model.isActive(editor)) {
        activeEditor = editor;
      } else {
        inactiveEditors.push(editor);
      }
    }
    for (const inactiveEditor of inactiveEditors) {
      this.doCloseEditor(inactiveEditor, false);
    }
    if (activeEditor) {
      this.doCloseEditor(activeEditor, false);
    }
  }
  onDidChangeEditorPartOptions(event) {
    this.updateTitleContainer();
    if (event.oldPartOptions.showTabs !== event.newPartOptions.showTabs) {
      this.createTitleAreaControl();
      this.relayout();
      if (this.model.activeEditor) {
        this.titleAreaControl.openEditor(this.model.activeEditor);
      }
    } else {
      this.titleAreaControl.updateOptions(event.oldPartOptions, event.newPartOptions);
    }
    this.updateStyles();
    if (event.oldPartOptions.enablePreview && !event.newPartOptions.enablePreview) {
      if (this.model.previewEditor) {
        this.pinEditor(this.model.previewEditor);
      }
    }
  }
  onDidChangeEditorDirty(editor) {
    this.pinEditor(editor);
    this.titleAreaControl.updateEditorDirty(editor);
  }
  onDidChangeEditorLabel(editor) {
    this.titleAreaControl.updateEditorLabel(editor);
  }
  onDidVisibilityChange(visible) {
    this.editorPane.setVisible(visible);
  }
  get index() {
    return this._index;
  }
  get label() {
    return localize("groupLabel", "Group {0}", this._index + 1);
  }
  get ariaLabel() {
    return localize("groupAriaLabel", "Editor Group {0}", this._index + 1);
  }
  get disposed() {
    return this._disposed;
  }
  get isEmpty() {
    return this.count === 0;
  }
  get titleHeight() {
    return this.titleAreaControl.getHeight();
  }
  notifyIndexChanged(newIndex) {
    if (this._index !== newIndex) {
      this._index = newIndex;
      this.model.setIndex(newIndex);
    }
  }
  setActive(isActive) {
    this.active = isActive;
    this.element.classList.toggle("active", isActive);
    this.element.classList.toggle("inactive", !isActive);
    this.titleAreaControl.setActive(isActive);
    this.updateStyles();
    this.model.setActive(void 0);
  }
  get id() {
    return this.model.id;
  }
  get editors() {
    return this.model.getEditors(1);
  }
  get count() {
    return this.model.count;
  }
  get stickyCount() {
    return this.model.stickyCount;
  }
  get activeEditorPane() {
    return this.editorPane ? withNullAsUndefined(this.editorPane.activeEditorPane) : void 0;
  }
  get activeEditor() {
    return this.model.activeEditor;
  }
  get previewEditor() {
    return this.model.previewEditor;
  }
  isPinned(editorOrIndex) {
    return this.model.isPinned(editorOrIndex);
  }
  isSticky(editorOrIndex) {
    return this.model.isSticky(editorOrIndex);
  }
  isActive(editor) {
    return this.model.isActive(editor);
  }
  contains(candidate, options) {
    return this.model.contains(candidate, options);
  }
  getEditors(order, options) {
    return this.model.getEditors(order, options);
  }
  findEditors(resource, options) {
    const canonicalResource = this.uriIdentityService.asCanonicalUri(resource);
    return this.getEditors(1).filter((editor) => {
      if (editor.resource && isEqual(editor.resource, canonicalResource)) {
        return true;
      }
      if ((options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.PRIMARY || (options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.ANY) {
        const primaryResource = EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });
        if (primaryResource && isEqual(primaryResource, canonicalResource)) {
          return true;
        }
      }
      if ((options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.SECONDARY || (options == null ? void 0 : options.supportSideBySide) === SideBySideEditor.ANY) {
        const secondaryResource = EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.SECONDARY });
        if (secondaryResource && isEqual(secondaryResource, canonicalResource)) {
          return true;
        }
      }
      return false;
    });
  }
  getEditorByIndex(index) {
    return this.model.getEditorByIndex(index);
  }
  getIndexOfEditor(editor) {
    return this.model.indexOf(editor);
  }
  isFirst(editor) {
    return this.model.isFirst(editor);
  }
  isLast(editor) {
    return this.model.isLast(editor);
  }
  focus() {
    if (this.activeEditorPane) {
      this.activeEditorPane.focus();
    } else {
      this.element.focus();
    }
    this._onDidFocus.fire();
  }
  pinEditor(candidate = this.activeEditor || void 0) {
    if (candidate && !this.model.isPinned(candidate)) {
      const editor = this.model.pin(candidate);
      if (editor) {
        this.titleAreaControl.pinEditor(editor);
      }
    }
  }
  stickEditor(candidate = this.activeEditor || void 0) {
    this.doStickEditor(candidate, true);
  }
  unstickEditor(candidate = this.activeEditor || void 0) {
    this.doStickEditor(candidate, false);
  }
  doStickEditor(candidate, sticky) {
    if (candidate && this.model.isSticky(candidate) !== sticky) {
      const oldIndexOfEditor = this.getIndexOfEditor(candidate);
      const editor = sticky ? this.model.stick(candidate) : this.model.unstick(candidate);
      if (!editor) {
        return;
      }
      const newIndexOfEditor = this.getIndexOfEditor(editor);
      if (newIndexOfEditor !== oldIndexOfEditor) {
        this.titleAreaControl.moveEditor(editor, oldIndexOfEditor, newIndexOfEditor);
      }
      if (sticky) {
        this.titleAreaControl.stickEditor(editor);
      } else {
        this.titleAreaControl.unstickEditor(editor);
      }
    }
  }
  async openEditor(editor, options) {
    return this.doOpenEditor(editor, options, {
      supportSideBySide: SideBySideEditor.BOTH
    });
  }
  async doOpenEditor(editor, options, internalOptions) {
    var _a2;
    if (!editor || editor.isDisposed()) {
      return;
    }
    this._onWillOpenEditor.fire({ editor, groupId: this.id });
    const pinned = (options == null ? void 0 : options.sticky) || !this.accessor.partOptions.enablePreview || editor.isDirty() || ((options == null ? void 0 : options.pinned) ?? typeof (options == null ? void 0 : options.index) === "number") || typeof (options == null ? void 0 : options.index) === "number" && this.model.isSticky(options.index) || editor.hasCapability(512);
    const openEditorOptions = {
      index: options ? options.index : void 0,
      pinned,
      sticky: (options == null ? void 0 : options.sticky) || typeof (options == null ? void 0 : options.index) === "number" && this.model.isSticky(options.index),
      active: this.count === 0 || !options || !options.inactive,
      supportSideBySide: internalOptions == null ? void 0 : internalOptions.supportSideBySide
    };
    if ((options == null ? void 0 : options.sticky) && typeof (options == null ? void 0 : options.index) === "number" && !this.model.isSticky(options.index)) {
      openEditorOptions.sticky = false;
    }
    if (!openEditorOptions.active && !openEditorOptions.pinned && this.model.activeEditor && !this.model.isPinned(this.model.activeEditor)) {
      openEditorOptions.active = true;
    }
    let activateGroup = false;
    let restoreGroup = false;
    if ((options == null ? void 0 : options.activation) === EditorActivation.ACTIVATE) {
      activateGroup = true;
    } else if ((options == null ? void 0 : options.activation) === EditorActivation.RESTORE) {
      restoreGroup = true;
    } else if ((options == null ? void 0 : options.activation) === EditorActivation.PRESERVE) {
      activateGroup = false;
      restoreGroup = false;
    } else if (openEditorOptions.active) {
      activateGroup = !options || !options.preserveFocus;
      restoreGroup = !activateGroup;
    }
    if (typeof openEditorOptions.index === "number") {
      const indexOfEditor = this.model.indexOf(editor);
      if (indexOfEditor !== -1 && indexOfEditor !== openEditorOptions.index) {
        this.doMoveEditorInsideGroup(editor, openEditorOptions);
      }
    }
    const { editor: openedEditor, isNew } = this.model.openEditor(editor, openEditorOptions);
    if (isNew && this.count === 1 && this.accessor.groups.length > 1) {
      if (openedEditor.editorId && ((_a2 = this.accessor.partOptions.autoLockGroups) == null ? void 0 : _a2.has(openedEditor.editorId))) {
        this.lock(true);
      }
    }
    const showEditorResult = this.doShowEditor(openedEditor, { active: !!openEditorOptions.active, isNew }, options, internalOptions);
    if (activateGroup) {
      this.accessor.activateGroup(this);
    } else if (restoreGroup) {
      this.accessor.restoreGroup(this);
    }
    return showEditorResult;
  }
  doShowEditor(editor, context, options, internalOptions) {
    let openEditorPromise;
    if (context.active) {
      openEditorPromise = (async () => {
        const { pane, changed, cancelled, error } = await this.editorPane.openEditor(editor, options, { newInGroup: context.isNew });
        if (cancelled) {
          return void 0;
        }
        if (changed) {
          this._onDidActiveEditorChange.fire({ editor });
        }
        if (error) {
          this._onDidOpenEditorFail.fire(editor);
        }
        if (!pane && this.activeEditor === editor) {
          const focusNext = !options || !options.preserveFocus;
          this.doCloseEditor(editor, focusNext, { fromError: true });
        }
        return pane;
      })();
    } else {
      openEditorPromise = Promise.resolve(void 0);
    }
    if (!(internalOptions == null ? void 0 : internalOptions.skipTitleUpdate)) {
      this.titleAreaControl.openEditor(editor);
    }
    return openEditorPromise;
  }
  async openEditors(editors) {
    const editorsToOpen = coalesce(editors).filter(({ editor }) => !editor.isDisposed());
    const firstEditor = firstOrDefault(editorsToOpen);
    if (!firstEditor) {
      return;
    }
    const openEditorsOptions = {
      supportSideBySide: SideBySideEditor.BOTH
    };
    await this.doOpenEditor(firstEditor.editor, firstEditor.options, openEditorsOptions);
    const inactiveEditors = editorsToOpen.slice(1);
    const startingIndex = this.getIndexOfEditor(firstEditor.editor) + 1;
    await Promises.settled(inactiveEditors.map(({ editor, options }, index) => {
      return this.doOpenEditor(editor, {
        ...options,
        inactive: true,
        pinned: true,
        index: startingIndex + index
      }, {
        ...openEditorsOptions,
        skipTitleUpdate: true
      });
    }));
    this.titleAreaControl.openEditors(inactiveEditors.map(({ editor }) => editor));
    return withNullAsUndefined(this.editorPane.activeEditorPane);
  }
  moveEditors(editors, target) {
    const internalOptions = {
      skipTitleUpdate: this !== target
    };
    for (const { editor, options } of editors) {
      this.moveEditor(editor, target, options, internalOptions);
    }
    if (internalOptions.skipTitleUpdate) {
      const movedEditors = editors.map(({ editor }) => editor);
      target.titleAreaControl.openEditors(movedEditors);
      this.titleAreaControl.closeEditors(movedEditors);
    }
  }
  moveEditor(editor, target, options, internalOptions) {
    if (this === target) {
      this.doMoveEditorInsideGroup(editor, options);
    } else {
      this.doMoveOrCopyEditorAcrossGroups(editor, target, options, { ...internalOptions, keepCopy: false });
    }
  }
  doMoveEditorInsideGroup(candidate, options) {
    const moveToIndex = options ? options.index : void 0;
    if (typeof moveToIndex !== "number") {
      return;
    }
    const currentIndex = this.model.indexOf(candidate);
    if (currentIndex === -1 || currentIndex === moveToIndex) {
      return;
    }
    const editor = this.model.getEditorByIndex(currentIndex);
    if (!editor) {
      return;
    }
    this.model.moveEditor(editor, moveToIndex);
    this.model.pin(editor);
    this.titleAreaControl.moveEditor(editor, currentIndex, moveToIndex);
    this.titleAreaControl.pinEditor(editor);
  }
  doMoveOrCopyEditorAcrossGroups(editor, target, openOptions, internalOptions) {
    const keepCopy = internalOptions == null ? void 0 : internalOptions.keepCopy;
    const options = fillActiveEditorViewState(this, editor, {
      ...openOptions,
      pinned: true,
      sticky: !keepCopy && this.model.isSticky(editor)
    });
    if (!keepCopy) {
      this._onWillMoveEditor.fire({
        groupId: this.id,
        editor,
        target: target.id
      });
    }
    target.doOpenEditor(keepCopy ? editor.copy() : editor, options, internalOptions);
    if (!keepCopy) {
      this.doCloseEditor(editor, false, { ...internalOptions, context: EditorCloseContext.MOVE });
    }
  }
  copyEditors(editors, target) {
    const internalOptions = {
      skipTitleUpdate: this !== target
    };
    for (const { editor, options } of editors) {
      this.copyEditor(editor, target, options, internalOptions);
    }
    if (internalOptions.skipTitleUpdate) {
      const copiedEditors = editors.map(({ editor }) => editor);
      target.titleAreaControl.openEditors(copiedEditors);
    }
  }
  copyEditor(editor, target, options, internalOptions) {
    if (this === target) {
      this.doMoveEditorInsideGroup(editor, options);
    } else {
      this.doMoveOrCopyEditorAcrossGroups(editor, target, options, { ...internalOptions, keepCopy: true });
    }
  }
  async closeEditor(editor = this.activeEditor || void 0, options) {
    return this.doCloseEditorWithConfirmationHandling(editor, options);
  }
  async doCloseEditorWithConfirmationHandling(editor = this.activeEditor || void 0, options, internalOptions) {
    if (!editor) {
      return false;
    }
    const veto = await this.handleCloseConfirmation([editor]);
    if (veto) {
      return false;
    }
    this.doCloseEditor(editor, (options == null ? void 0 : options.preserveFocus) ? false : void 0, internalOptions);
    return true;
  }
  doCloseEditor(editor, focusNext = this.accessor.activeGroup === this, internalOptions) {
    if (!(internalOptions == null ? void 0 : internalOptions.skipTitleUpdate)) {
      this.titleAreaControl.beforeCloseEditor(editor);
    }
    if (this.model.isActive(editor)) {
      this.doCloseActiveEditor(focusNext, internalOptions);
    } else {
      this.doCloseInactiveEditor(editor, internalOptions);
    }
    if (!(internalOptions == null ? void 0 : internalOptions.skipTitleUpdate)) {
      this.titleAreaControl.closeEditor(editor);
    }
  }
  doCloseActiveEditor(focusNext = this.accessor.activeGroup === this, internalOptions) {
    const editorToClose = this.activeEditor;
    const restoreFocus = this.shouldRestoreFocus(this.element);
    const closeEmptyGroup = this.accessor.partOptions.closeEmptyGroups;
    if (closeEmptyGroup && this.active && this.count === 1) {
      const mostRecentlyActiveGroups = this.accessor.getGroups(1);
      const nextActiveGroup = mostRecentlyActiveGroups[1];
      if (nextActiveGroup) {
        if (restoreFocus) {
          nextActiveGroup.focus();
        } else {
          this.accessor.activateGroup(nextActiveGroup);
        }
      }
    }
    if (editorToClose) {
      this.model.closeEditor(editorToClose, internalOptions == null ? void 0 : internalOptions.context);
    }
    const nextActiveEditor = this.model.activeEditor;
    if (nextActiveEditor) {
      const preserveFocus = !focusNext;
      let activation = void 0;
      if (preserveFocus && this.accessor.activeGroup !== this) {
        activation = EditorActivation.PRESERVE;
      }
      const options = {
        preserveFocus,
        activation,
        ignoreError: internalOptions == null ? void 0 : internalOptions.fromError
      };
      this.doOpenEditor(nextActiveEditor, options);
    } else {
      if (editorToClose) {
        this.editorPane.closeEditor(editorToClose);
      }
      if (restoreFocus && !closeEmptyGroup) {
        this.focus();
      }
      this._onDidActiveEditorChange.fire({ editor: void 0 });
      if (closeEmptyGroup) {
        this.accessor.removeGroup(this);
      }
    }
  }
  shouldRestoreFocus(target) {
    const activeElement = document.activeElement;
    if (activeElement === document.body) {
      return true;
    }
    return isAncestor(activeElement, target);
  }
  doCloseInactiveEditor(editor, internalOptions) {
    this.model.closeEditor(editor, internalOptions == null ? void 0 : internalOptions.context);
  }
  async handleCloseConfirmation(editors) {
    if (!editors.length) {
      return false;
    }
    const editor = editors.shift();
    let handleCloseConfirmationPromise = this.mapEditorToPendingConfirmation.get(editor);
    if (!handleCloseConfirmationPromise) {
      handleCloseConfirmationPromise = this.doHandleCloseConfirmation(editor);
      this.mapEditorToPendingConfirmation.set(editor, handleCloseConfirmationPromise);
    }
    let veto;
    try {
      veto = await handleCloseConfirmationPromise;
    } finally {
      this.mapEditorToPendingConfirmation.delete(editor);
    }
    if (veto) {
      return veto;
    }
    return this.handleCloseConfirmation(editors);
  }
  async doHandleCloseConfirmation(editor, options) {
    var _a2;
    if (!this.shouldConfirmClose(editor)) {
      return false;
    }
    if (editor instanceof SideBySideEditorInput && this.model.contains(editor.primary)) {
      return false;
    }
    if (this.accessor.groups.some((groupView) => {
      if (groupView === this) {
        return false;
      }
      const otherGroup = groupView;
      if (otherGroup.contains(editor, { supportSideBySide: SideBySideEditor.BOTH })) {
        return true;
      }
      if (editor instanceof SideBySideEditorInput && otherGroup.contains(editor.primary)) {
        return true;
      }
      return false;
    })) {
      return false;
    }
    let confirmation = 2;
    let saveReason = 1;
    let autoSave = false;
    if (!editor.hasCapability(4) && !(options == null ? void 0 : options.skipAutoSave) && !editor.closeHandler) {
      if (this.filesConfigurationService.getAutoSaveMode() === 3) {
        autoSave = true;
        confirmation = 0;
        saveReason = 3;
      } else if (isNative && (isWindows || isLinux) && this.filesConfigurationService.getAutoSaveMode() === 4) {
        autoSave = true;
        confirmation = 0;
        saveReason = 4;
      }
    }
    if (!autoSave) {
      if (!this.activeEditor || !this.activeEditor.matches(editor)) {
        await this.doOpenEditor(editor);
      }
      if (typeof ((_a2 = editor.closeHandler) == null ? void 0 : _a2.confirm) === "function") {
        confirmation = await editor.closeHandler.confirm([{ editor, groupId: this.id }]);
      } else {
        let name;
        if (editor instanceof SideBySideEditorInput) {
          name = editor.primary.getName();
        } else {
          name = editor.getName();
        }
        confirmation = await this.fileDialogService.showSaveConfirm([name]);
      }
    }
    if (!editor.closeHandler && !this.shouldConfirmClose(editor)) {
      return confirmation === 2 ? true : false;
    }
    switch (confirmation) {
      case 0: {
        const result = await editor.save(this.id, { reason: saveReason });
        if (!result && autoSave) {
          return this.doHandleCloseConfirmation(editor, { skipAutoSave: true });
        }
        return editor.isDirty();
      }
      case 1:
        try {
          await editor.revert(this.id);
          return editor.isDirty();
        } catch (error) {
          this.logService.error(error);
          await editor.revert(this.id, { soft: true });
          return editor.isDirty();
        }
      case 2:
        return true;
    }
  }
  shouldConfirmClose(editor) {
    if (editor.closeHandler) {
      return editor.closeHandler.showConfirm();
    }
    return editor.isDirty() && !editor.isSaving();
  }
  async closeEditors(args, options) {
    if (this.isEmpty) {
      return true;
    }
    const editors = this.doGetEditorsToClose(args);
    const veto = await this.handleCloseConfirmation(editors.slice(0));
    if (veto) {
      return false;
    }
    this.doCloseEditors(editors, options);
    return true;
  }
  doGetEditorsToClose(args) {
    if (Array.isArray(args)) {
      return args;
    }
    const filter = args;
    const hasDirection = typeof filter.direction === "number";
    let editorsToClose = this.model.getEditors(hasDirection ? 1 : 0, filter);
    if (filter.savedOnly) {
      editorsToClose = editorsToClose.filter((editor) => !editor.isDirty() || editor.isSaving());
    } else if (hasDirection && filter.except) {
      editorsToClose = filter.direction === 0 ? editorsToClose.slice(0, this.model.indexOf(filter.except, editorsToClose)) : editorsToClose.slice(this.model.indexOf(filter.except, editorsToClose) + 1);
    } else if (filter.except) {
      editorsToClose = editorsToClose.filter((editor) => filter.except && !editor.matches(filter.except));
    }
    return editorsToClose;
  }
  doCloseEditors(editors, options) {
    let closeActiveEditor = false;
    for (const editor of editors) {
      if (!this.isActive(editor)) {
        this.doCloseInactiveEditor(editor);
      } else {
        closeActiveEditor = true;
      }
    }
    if (closeActiveEditor) {
      this.doCloseActiveEditor((options == null ? void 0 : options.preserveFocus) ? false : void 0);
    }
    if (editors.length) {
      this.titleAreaControl.closeEditors(editors);
    }
  }
  async closeAllEditors(options) {
    if (this.isEmpty) {
      if (this.accessor.partOptions.closeEmptyGroups) {
        this.accessor.removeGroup(this);
      }
      return true;
    }
    const veto = await this.handleCloseConfirmation(this.model.getEditors(0, options));
    if (veto) {
      return false;
    }
    this.doCloseAllEditors(options);
    return true;
  }
  doCloseAllEditors(options) {
    const editorsToClose = [];
    for (const editor of this.model.getEditors(1, options)) {
      if (!this.isActive(editor)) {
        this.doCloseInactiveEditor(editor);
      }
      editorsToClose.push(editor);
    }
    if (this.activeEditor && editorsToClose.includes(this.activeEditor)) {
      this.doCloseActiveEditor();
    }
    if (editorsToClose.length) {
      this.titleAreaControl.closeEditors(editorsToClose);
    }
  }
  async replaceEditors(editors) {
    let activeReplacement;
    const inactiveReplacements = [];
    for (let { editor, replacement, forceReplaceDirty, options } of editors) {
      const index = this.getIndexOfEditor(editor);
      if (index >= 0) {
        const isActiveEditor = this.isActive(editor);
        if (options) {
          options.index = index;
        } else {
          options = { index };
        }
        options.inactive = !isActiveEditor;
        options.pinned = options.pinned ?? true;
        const editorToReplace = { editor, replacement, forceReplaceDirty, options };
        if (isActiveEditor) {
          activeReplacement = editorToReplace;
        } else {
          inactiveReplacements.push(editorToReplace);
        }
      }
    }
    for (const { editor, replacement, forceReplaceDirty, options } of inactiveReplacements) {
      await this.doOpenEditor(replacement, options);
      if (!editor.matches(replacement)) {
        let closed = false;
        if (forceReplaceDirty) {
          this.doCloseEditor(editor, false, { context: EditorCloseContext.REPLACE });
          closed = true;
        } else {
          closed = await this.doCloseEditorWithConfirmationHandling(editor, { preserveFocus: true }, { context: EditorCloseContext.REPLACE });
        }
        if (!closed) {
          return;
        }
      }
    }
    if (activeReplacement) {
      const openEditorResult = this.doOpenEditor(activeReplacement.replacement, activeReplacement.options);
      if (!activeReplacement.editor.matches(activeReplacement.replacement)) {
        if (activeReplacement.forceReplaceDirty) {
          this.doCloseEditor(activeReplacement.editor, false, { context: EditorCloseContext.REPLACE });
        } else {
          await this.doCloseEditorWithConfirmationHandling(activeReplacement.editor, { preserveFocus: true }, { context: EditorCloseContext.REPLACE });
        }
      }
      await openEditorResult;
    }
  }
  get isLocked() {
    if (this.accessor.groups.length === 1) {
      return false;
    }
    return this.model.isLocked;
  }
  lock(locked) {
    if (this.accessor.groups.length === 1) {
      locked = false;
    }
    this.model.lock(locked);
  }
  updateStyles() {
    const isEmpty = this.isEmpty;
    if (isEmpty) {
      this.element.style.backgroundColor = this.getColor(EDITOR_GROUP_EMPTY_BACKGROUND) || "";
    } else {
      this.element.style.backgroundColor = "";
    }
    const borderColor = this.getColor(EDITOR_GROUP_HEADER_BORDER) || this.getColor(contrastBorder);
    if (!isEmpty && borderColor) {
      this.titleContainer.classList.add("title-border-bottom");
      this.titleContainer.style.setProperty("--title-border-bottom-color", borderColor);
    } else {
      this.titleContainer.classList.remove("title-border-bottom");
      this.titleContainer.style.removeProperty("--title-border-bottom-color");
    }
    const { showTabs } = this.accessor.partOptions;
    this.titleContainer.style.backgroundColor = this.getColor(showTabs ? EDITOR_GROUP_HEADER_TABS_BACKGROUND : EDITOR_GROUP_HEADER_NO_TABS_BACKGROUND) || "";
    this.editorContainer.style.backgroundColor = this.getColor(editorBackground) || "";
  }
  get minimumWidth() {
    return this.editorPane.minimumWidth;
  }
  get minimumHeight() {
    return this.editorPane.minimumHeight;
  }
  get maximumWidth() {
    return this.editorPane.maximumWidth;
  }
  get maximumHeight() {
    return this.editorPane.maximumHeight;
  }
  get proportionalLayout() {
    if (!this.lastLayout) {
      return true;
    }
    return !(this.lastLayout.width === this.minimumWidth || this.lastLayout.height === this.minimumHeight);
  }
  layout(width, height, top, left) {
    this.lastLayout = { width, height, top, left };
    this.element.classList.toggle("max-height-478px", height <= 478);
    const titleAreaSize = this.titleAreaControl.layout({
      container: new Dimension(width, height),
      available: new Dimension(width, height - this.editorPane.minimumHeight)
    });
    const editorHeight = Math.max(0, height - titleAreaSize.height);
    this.editorContainer.style.height = `${editorHeight}px`;
    this.editorPane.layout({ width, height: editorHeight, top: top + titleAreaSize.height, left });
  }
  relayout() {
    if (this.lastLayout) {
      const { width, height, top, left } = this.lastLayout;
      this.layout(width, height, top, left);
    }
  }
  setBoundarySashes(sashes) {
    this.editorPane.setBoundarySashes(sashes);
  }
  toJSON() {
    return this.model.serialize();
  }
  dispose() {
    this._disposed = true;
    this._onWillDispose.fire();
    this.titleAreaControl.dispose();
    super.dispose();
  }
};
EditorGroupView = __decorate([
  __param(3, IInstantiationService),
  __param(4, IContextKeyService),
  __param(5, IThemeService),
  __param(6, ITelemetryService),
  __param(7, IKeybindingService),
  __param(8, IMenuService),
  __param(9, IContextMenuService),
  __param(10, IFileDialogService),
  __param(11, IEditorService),
  __param(12, IFilesConfigurationService),
  __param(13, IUriIdentityService),
  __param(14, ILogService)
], EditorGroupView);
var css$9 = "#monaco-workbench-editor-drop-overlay{height:100%;left:0;position:absolute;width:100%;z-index:10000}#monaco-workbench-editor-drop-overlay>.editor-group-overlay-indicator{align-items:center;display:flex;height:100%;justify-content:center;left:0;opacity:0;pointer-events:none;position:absolute;top:0;width:100%}.monaco-workbench:not(.reduce-motion) #monaco-workbench-editor-drop-overlay>.editor-group-overlay-indicator{transition:opacity .15s ease-out}#monaco-workbench-editor-drop-overlay .editor-group-overlay-drop-into-prompt{line-height:normal;margin:.2em;opacity:0;padding:.6em;text-align:center}.monaco-workbench:not(.reduce-motion) #monaco-workbench-editor-drop-overlay .editor-group-overlay-drop-into-prompt{transition:opacity .15s ease-out}#monaco-workbench-editor-drop-overlay .editor-group-overlay-drop-into-prompt i{background-color:hsla(0,0%,100%,.05);border:1px solid hsla(0,0%,80%,.4);border-radius:5px;font-style:normal;margin:0 1px;padding:0 8px}.monaco-workbench:not(.reduce-motion) #monaco-workbench-editor-drop-overlay>.editor-group-overlay-indicator.overlay-move-transition{transition:top 70ms ease-out,left 70ms ease-out,width 70ms ease-out,height 70ms ease-out,opacity .15s ease-out}";
n(css$9, {});
function isDropIntoEditorEnabledGlobally(configurationService) {
  return configurationService.getValue("editor.dropIntoEditor.enabled");
}
function isDragIntoEditorEvent(e) {
  return e.shiftKey;
}
let DropOverlay = (_l = class extends Themable {
  get disposed() {
    return !!this._disposed;
  }
  constructor(accessor, groupView, themeService, configurationService, instantiationService, editorService, editorGroupService, treeViewsDragAndDropService, contextService) {
    super(themeService);
    this.accessor = accessor;
    this.groupView = groupView;
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.editorService = editorService;
    this.editorGroupService = editorGroupService;
    this.treeViewsDragAndDropService = treeViewsDragAndDropService;
    this.contextService = contextService;
    this.editorTransfer = LocalSelectionTransfer.getInstance();
    this.groupTransfer = LocalSelectionTransfer.getInstance();
    this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
    this.cleanupOverlayScheduler = this._register(new RunOnceScheduler(() => this.dispose(), 300));
    this.enableDropIntoEditor = isDropIntoEditorEnabledGlobally(this.configurationService) && this.isDropIntoActiveEditorEnabled();
    this.create();
  }
  create() {
    const overlayOffsetHeight = this.getOverlayOffsetHeight();
    const container = this.container = document.createElement("div");
    container.id = _l.OVERLAY_ID;
    container.style.top = `${overlayOffsetHeight}px`;
    this.groupView.element.appendChild(container);
    this.groupView.element.classList.add("dragged-over");
    this._register(toDisposable(() => {
      this.groupView.element.removeChild(container);
      this.groupView.element.classList.remove("dragged-over");
    }));
    this.overlay = document.createElement("div");
    this.overlay.classList.add("editor-group-overlay-indicator");
    container.appendChild(this.overlay);
    if (this.enableDropIntoEditor) {
      this.dropIntoPromptElement = renderFormattedText(localize(
        "dropIntoEditorPrompt",
        "Hold __{0}__ to drop into editor",
        isMacintosh ? "⇧" : "Shift"
      ), {});
      this.dropIntoPromptElement.classList.add("editor-group-overlay-drop-into-prompt");
      this.overlay.appendChild(this.dropIntoPromptElement);
    }
    this.registerListeners(container);
    this.updateStyles();
  }
  updateStyles() {
    const overlay = assertIsDefined(this.overlay);
    overlay.style.backgroundColor = this.getColor(EDITOR_DRAG_AND_DROP_BACKGROUND) || "";
    const activeContrastBorderColor = this.getColor(activeContrastBorder);
    overlay.style.outlineColor = activeContrastBorderColor || "";
    overlay.style.outlineOffset = activeContrastBorderColor ? "-2px" : "";
    overlay.style.outlineStyle = activeContrastBorderColor ? "dashed" : "";
    overlay.style.outlineWidth = activeContrastBorderColor ? "2px" : "";
    if (this.dropIntoPromptElement) {
      this.dropIntoPromptElement.style.backgroundColor = this.getColor(EDITOR_DROP_INTO_PROMPT_BACKGROUND) ?? "";
      this.dropIntoPromptElement.style.color = this.getColor(EDITOR_DROP_INTO_PROMPT_FOREGROUND) ?? "";
      const borderColor = this.getColor(EDITOR_DROP_INTO_PROMPT_BORDER);
      if (borderColor) {
        this.dropIntoPromptElement.style.borderWidth = "1px";
        this.dropIntoPromptElement.style.borderStyle = "solid";
        this.dropIntoPromptElement.style.borderColor = borderColor;
      } else {
        this.dropIntoPromptElement.style.borderWidth = "0";
      }
    }
  }
  registerListeners(container) {
    this._register(new DragAndDropObserver(container, {
      onDragEnter: (e) => void 0,
      onDragOver: (e) => {
        if (this.enableDropIntoEditor && isDragIntoEditorEvent(e)) {
          this.dispose();
          return;
        }
        const isDraggingGroup = this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype);
        const isDraggingEditor = this.editorTransfer.hasData(DraggedEditorIdentifier.prototype);
        if (!isDraggingEditor && !isDraggingGroup && e.dataTransfer) {
          e.dataTransfer.dropEffect = "copy";
        }
        let isCopy = true;
        if (isDraggingGroup) {
          isCopy = this.isCopyOperation(e);
        } else if (isDraggingEditor) {
          const data = this.editorTransfer.getData(DraggedEditorIdentifier.prototype);
          if (Array.isArray(data)) {
            isCopy = this.isCopyOperation(e, data[0].identifier);
          }
        }
        if (!isCopy) {
          const sourceGroupView = this.findSourceGroupView();
          if (sourceGroupView === this.groupView) {
            if (isDraggingGroup || isDraggingEditor && sourceGroupView.count < 2) {
              this.hideOverlay();
              return;
            }
          }
        }
        let splitOnDragAndDrop = !!this.editorGroupService.partOptions.splitOnDragAndDrop;
        if (this.isToggleSplitOperation(e)) {
          splitOnDragAndDrop = !splitOnDragAndDrop;
        }
        this.positionOverlay(e.offsetX, e.offsetY, isDraggingGroup, splitOnDragAndDrop);
        if (this.cleanupOverlayScheduler.isScheduled()) {
          this.cleanupOverlayScheduler.cancel();
        }
      },
      onDragLeave: (e) => this.dispose(),
      onDragEnd: (e) => this.dispose(),
      onDrop: (e) => {
        EventHelper.stop(e, true);
        this.dispose();
        if (this.currentDropOperation) {
          this.handleDrop(e, this.currentDropOperation.splitDirection);
        }
      }
    }));
    this._register(addDisposableListener(container, EventType.MOUSE_OVER, () => {
      if (!this.cleanupOverlayScheduler.isScheduled()) {
        this.cleanupOverlayScheduler.schedule();
      }
    }));
  }
  isDropIntoActiveEditorEnabled() {
    var _a2;
    return !!((_a2 = this.groupView.activeEditor) == null ? void 0 : _a2.hasCapability(128));
  }
  findSourceGroupView() {
    if (this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype)) {
      const data = this.groupTransfer.getData(DraggedEditorGroupIdentifier.prototype);
      if (Array.isArray(data)) {
        return this.accessor.getGroup(data[0].identifier);
      }
    } else if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {
      const data = this.editorTransfer.getData(DraggedEditorIdentifier.prototype);
      if (Array.isArray(data)) {
        return this.accessor.getGroup(data[0].identifier.groupId);
      }
    }
    return void 0;
  }
  async handleDrop(event, splitDirection) {
    const ensureTargetGroup = () => {
      let targetGroup;
      if (typeof splitDirection === "number") {
        targetGroup = this.accessor.addGroup(this.groupView, splitDirection);
      } else {
        targetGroup = this.groupView;
      }
      return targetGroup;
    };
    if (this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype)) {
      const data = this.groupTransfer.getData(DraggedEditorGroupIdentifier.prototype);
      if (Array.isArray(data)) {
        const sourceGroup = this.accessor.getGroup(data[0].identifier);
        if (sourceGroup) {
          if (typeof splitDirection !== "number" && sourceGroup === this.groupView) {
            return;
          }
          let targetGroup;
          if (typeof splitDirection === "number") {
            if (this.isCopyOperation(event)) {
              targetGroup = this.accessor.copyGroup(sourceGroup, this.groupView, splitDirection);
            } else {
              targetGroup = this.accessor.moveGroup(sourceGroup, this.groupView, splitDirection);
            }
          } else {
            let mergeGroupOptions = void 0;
            if (this.isCopyOperation(event)) {
              mergeGroupOptions = { mode: 0 };
            }
            this.accessor.mergeGroup(sourceGroup, this.groupView, mergeGroupOptions);
          }
          if (targetGroup) {
            this.accessor.activateGroup(targetGroup);
          }
        }
        this.groupTransfer.clearData(DraggedEditorGroupIdentifier.prototype);
      }
    } else if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {
      const data = this.editorTransfer.getData(DraggedEditorIdentifier.prototype);
      if (Array.isArray(data)) {
        const draggedEditor = data[0].identifier;
        const sourceGroup = this.accessor.getGroup(draggedEditor.groupId);
        if (sourceGroup) {
          const copyEditor = this.isCopyOperation(event, draggedEditor);
          let targetGroup = void 0;
          if (this.editorGroupService.partOptions.closeEmptyGroups && sourceGroup.count === 1 && typeof splitDirection === "number" && !copyEditor) {
            targetGroup = this.accessor.moveGroup(sourceGroup, this.groupView, splitDirection);
          } else {
            targetGroup = ensureTargetGroup();
            if (sourceGroup === targetGroup) {
              return;
            }
            const options = fillActiveEditorViewState(sourceGroup, draggedEditor.editor, {
              pinned: true,
              sticky: sourceGroup.isSticky(draggedEditor.editor)
            });
            if (!copyEditor) {
              sourceGroup.moveEditor(draggedEditor.editor, targetGroup, options);
            } else {
              sourceGroup.copyEditor(draggedEditor.editor, targetGroup, options);
            }
          }
          targetGroup.focus();
        }
        this.editorTransfer.clearData(DraggedEditorIdentifier.prototype);
      }
    } else if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
      const data = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype);
      if (Array.isArray(data)) {
        const editors = [];
        for (const id of data) {
          const dataTransferItem = await this.treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
          if (dataTransferItem) {
            const treeDropData = await extractTreeDropData(dataTransferItem);
            editors.push(...treeDropData.map((editor) => ({ ...editor, options: { ...editor.options, pinned: true } })));
          }
        }
        if (editors.length) {
          this.editorService.openEditors(editors, ensureTargetGroup(), { validateTrust: true });
        }
      }
      this.treeItemsTransfer.clearData(DraggedTreeItemsIdentifier.prototype);
    } else {
      const dropHandler = this.instantiationService.createInstance(ResourcesDropHandler, { allowWorkspaceOpen: !isWeb || isTemporaryWorkspace(this.contextService.getWorkspace()) });
      dropHandler.handleDrop(event, () => ensureTargetGroup(), (targetGroup) => targetGroup == null ? void 0 : targetGroup.focus());
    }
  }
  isCopyOperation(e, draggedEditor) {
    if (draggedEditor == null ? void 0 : draggedEditor.editor.hasCapability(8)) {
      return false;
    }
    return e.ctrlKey && !isMacintosh || e.altKey && isMacintosh;
  }
  isToggleSplitOperation(e) {
    return e.altKey && !isMacintosh || e.shiftKey && isMacintosh;
  }
  positionOverlay(mousePosX, mousePosY, isDraggingGroup, enableSplitting) {
    const preferSplitVertically = this.accessor.partOptions.openSideBySideDirection === "right";
    const editorControlWidth = this.groupView.element.clientWidth;
    const editorControlHeight = this.groupView.element.clientHeight - this.getOverlayOffsetHeight();
    let edgeWidthThresholdFactor;
    let edgeHeightThresholdFactor;
    if (enableSplitting) {
      if (isDraggingGroup) {
        edgeWidthThresholdFactor = preferSplitVertically ? 0.3 : 0.1;
      } else {
        edgeWidthThresholdFactor = 0.1;
      }
      if (isDraggingGroup) {
        edgeHeightThresholdFactor = preferSplitVertically ? 0.1 : 0.3;
      } else {
        edgeHeightThresholdFactor = 0.1;
      }
    } else {
      edgeWidthThresholdFactor = 0;
      edgeHeightThresholdFactor = 0;
    }
    const edgeWidthThreshold = editorControlWidth * edgeWidthThresholdFactor;
    const edgeHeightThreshold = editorControlHeight * edgeHeightThresholdFactor;
    const splitWidthThreshold = editorControlWidth / 3;
    const splitHeightThreshold = editorControlHeight / 3;
    let splitDirection;
    if (mousePosX > edgeWidthThreshold && mousePosX < editorControlWidth - edgeWidthThreshold && mousePosY > edgeHeightThreshold && mousePosY < editorControlHeight - edgeHeightThreshold) {
      splitDirection = void 0;
    } else {
      if (preferSplitVertically) {
        if (mousePosX < splitWidthThreshold) {
          splitDirection = 2;
        } else if (mousePosX > splitWidthThreshold * 2) {
          splitDirection = 3;
        } else if (mousePosY < editorControlHeight / 2) {
          splitDirection = 0;
        } else {
          splitDirection = 1;
        }
      } else {
        if (mousePosY < splitHeightThreshold) {
          splitDirection = 0;
        } else if (mousePosY > splitHeightThreshold * 2) {
          splitDirection = 1;
        } else if (mousePosX < editorControlWidth / 2) {
          splitDirection = 2;
        } else {
          splitDirection = 3;
        }
      }
    }
    switch (splitDirection) {
      case 0:
        this.doPositionOverlay({ top: "0", left: "0", width: "100%", height: "50%" });
        this.toggleDropIntoPrompt(false);
        break;
      case 1:
        this.doPositionOverlay({ top: "50%", left: "0", width: "100%", height: "50%" });
        this.toggleDropIntoPrompt(false);
        break;
      case 2:
        this.doPositionOverlay({ top: "0", left: "0", width: "50%", height: "100%" });
        this.toggleDropIntoPrompt(false);
        break;
      case 3:
        this.doPositionOverlay({ top: "0", left: "50%", width: "50%", height: "100%" });
        this.toggleDropIntoPrompt(false);
        break;
      default:
        this.doPositionOverlay({ top: "0", left: "0", width: "100%", height: "100%" });
        this.toggleDropIntoPrompt(true);
    }
    const overlay = assertIsDefined(this.overlay);
    overlay.style.opacity = "1";
    setTimeout(() => overlay.classList.add("overlay-move-transition"), 0);
    this.currentDropOperation = { splitDirection };
  }
  doPositionOverlay(options) {
    const [container, overlay] = assertAllDefined(this.container, this.overlay);
    const offsetHeight = this.getOverlayOffsetHeight();
    if (offsetHeight) {
      container.style.height = `calc(100% - ${offsetHeight}px)`;
    } else {
      container.style.height = "100%";
    }
    overlay.style.top = options.top;
    overlay.style.left = options.left;
    overlay.style.width = options.width;
    overlay.style.height = options.height;
  }
  getOverlayOffsetHeight() {
    if (!this.groupView.isEmpty && this.accessor.partOptions.showTabs) {
      return this.groupView.titleHeight.offset;
    }
    return 0;
  }
  hideOverlay() {
    const overlay = assertIsDefined(this.overlay);
    this.doPositionOverlay({ top: "0", left: "0", width: "100%", height: "100%" });
    overlay.style.opacity = "0";
    overlay.classList.remove("overlay-move-transition");
    this.currentDropOperation = void 0;
  }
  toggleDropIntoPrompt(showing) {
    if (!this.dropIntoPromptElement) {
      return;
    }
    this.dropIntoPromptElement.style.opacity = showing ? "1" : "0";
  }
  contains(element) {
    return element === this.container || element === this.overlay;
  }
  dispose() {
    super.dispose();
    this._disposed = true;
  }
}, _l.OVERLAY_ID = "monaco-workbench-editor-drop-overlay", _l);
DropOverlay = __decorate([
  __param(2, IThemeService),
  __param(3, IConfigurationService),
  __param(4, IInstantiationService),
  __param(5, IEditorService),
  __param(6, IEditorGroupsService),
  __param(7, ITreeViewsDnDService),
  __param(8, IWorkspaceContextService)
], DropOverlay);
let EditorDropTarget = class EditorDropTarget2 extends Themable {
  constructor(accessor, container, delegate, themeService, configurationService, instantiationService) {
    super(themeService);
    this.accessor = accessor;
    this.container = container;
    this.delegate = delegate;
    this.configurationService = configurationService;
    this.instantiationService = instantiationService;
    this.counter = 0;
    this.editorTransfer = LocalSelectionTransfer.getInstance();
    this.groupTransfer = LocalSelectionTransfer.getInstance();
    this.registerListeners();
  }
  get overlay() {
    if (this._overlay && !this._overlay.disposed) {
      return this._overlay;
    }
    return void 0;
  }
  registerListeners() {
    this._register(addDisposableListener(this.container, EventType.DRAG_ENTER, (e) => this.onDragEnter(e)));
    this._register(addDisposableListener(this.container, EventType.DRAG_LEAVE, () => this.onDragLeave()));
    [this.container, window].forEach((node) => this._register(addDisposableListener(node, EventType.DRAG_END, () => this.onDragEnd())));
  }
  onDragEnter(event) {
    if (isDropIntoEditorEnabledGlobally(this.configurationService) && isDragIntoEditorEvent(event)) {
      return;
    }
    this.counter++;
    if (!this.editorTransfer.hasData(DraggedEditorIdentifier.prototype) && !this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype) && event.dataTransfer) {
      const dndContributions = Registry.as(Extensions$2.DragAndDropContribution).getAll();
      const dndContributionKeys = Array.from(dndContributions).map((e) => e.dataFormatKey);
      if (!containsDragType(event, DataTransfers.FILES, CodeDataTransfers.FILES, DataTransfers.RESOURCES, CodeDataTransfers.EDITORS, ...dndContributionKeys)) {
        event.dataTransfer.dropEffect = "none";
        return;
      }
    }
    this.updateContainer(true);
    const target = event.target;
    if (target) {
      if (this.overlay && !this.overlay.contains(target)) {
        this.disposeOverlay();
      }
      if (!this.overlay) {
        const targetGroupView = this.findTargetGroupView(target);
        if (targetGroupView) {
          this._overlay = this.instantiationService.createInstance(DropOverlay, this.accessor, targetGroupView);
        }
      }
    }
  }
  onDragLeave() {
    this.counter--;
    if (this.counter === 0) {
      this.updateContainer(false);
    }
  }
  onDragEnd() {
    this.counter = 0;
    this.updateContainer(false);
    this.disposeOverlay();
  }
  findTargetGroupView(child) {
    const groups = this.accessor.groups;
    return groups.find((groupView) => {
      var _a2, _b2;
      return isAncestor(child, groupView.element) || ((_b2 = (_a2 = this.delegate).containsGroup) == null ? void 0 : _b2.call(_a2, groupView));
    });
  }
  updateContainer(isDraggedOver) {
    this.container.classList.toggle("dragged-over", isDraggedOver);
  }
  dispose() {
    super.dispose();
    this.disposeOverlay();
  }
  disposeOverlay() {
    if (this.overlay) {
      this.overlay.dispose();
      this._overlay = void 0;
    }
  }
};
EditorDropTarget = __decorate([
  __param(3, IThemeService),
  __param(4, IConfigurationService),
  __param(5, IInstantiationService)
], EditorDropTarget);
const defaultState = {
  targetWidth: 900,
  leftMarginRatio: 0.1909,
  rightMarginRatio: 0.1909
};
const distributeSizing = { type: "distribute" };
function createEmptyView(background) {
  const element = $$2(".centered-layout-margin");
  element.style.height = "100%";
  if (background) {
    element.style.backgroundColor = background.toString();
  }
  return {
    element,
    layout: () => void 0,
    minimumSize: 60,
    maximumSize: Number.POSITIVE_INFINITY,
    onDidChange: Event.None
  };
}
function toSplitViewView(view, getHeight) {
  return {
    element: view.element,
    get maximumSize() {
      return view.maximumWidth;
    },
    get minimumSize() {
      return view.minimumWidth;
    },
    onDidChange: Event.map(view.onDidChange, (e) => e && e.width),
    layout: (size2, offset, ctx) => view.layout(size2, getHeight(), (ctx == null ? void 0 : ctx.top) ?? 0, ((ctx == null ? void 0 : ctx.left) ?? 0) + offset)
  };
}
class CenteredViewLayout {
  constructor(container, view, state = { ...defaultState }) {
    this.container = container;
    this.view = view;
    this.state = state;
    this.lastLayoutPosition = { width: 0, height: 0, left: 0, top: 0 };
    this.didLayout = false;
    this.splitViewDisposables = new DisposableStore();
    this.centeredLayoutFixedWidth = true;
    this._boundarySashes = {};
    this.container.appendChild(this.view.element);
    this.container.style.overflow = "hidden";
  }
  get minimumWidth() {
    return this.splitView ? this.splitView.minimumSize : this.view.minimumWidth;
  }
  get maximumWidth() {
    return this.splitView ? this.splitView.maximumSize : this.view.maximumWidth;
  }
  get minimumHeight() {
    return this.view.minimumHeight;
  }
  get maximumHeight() {
    return this.view.maximumHeight;
  }
  get onDidChange() {
    return this.view.onDidChange;
  }
  get boundarySashes() {
    return this._boundarySashes;
  }
  set boundarySashes(boundarySashes) {
    this._boundarySashes = boundarySashes;
    if (!this.splitView) {
      return;
    }
    this.splitView.orthogonalStartSash = boundarySashes.top;
    this.splitView.orthogonalEndSash = boundarySashes.bottom;
  }
  layout(width, height, top, left) {
    this.lastLayoutPosition = { width, height, top, left };
    if (this.splitView) {
      this.splitView.layout(width, this.lastLayoutPosition);
      if (!this.didLayout || this.centeredLayoutFixedWidth) {
        this.resizeSplitViews();
      }
    } else {
      this.view.layout(width, height, top, left);
    }
    this.didLayout = true;
  }
  resizeSplitViews() {
    if (!this.splitView) {
      return;
    }
    if (this.centeredLayoutFixedWidth) {
      const centerViewWidth = Math.min(this.lastLayoutPosition.width, this.state.targetWidth);
      const marginWidthFloat = (this.lastLayoutPosition.width - centerViewWidth) / 2;
      this.splitView.resizeView(0, Math.floor(marginWidthFloat));
      this.splitView.resizeView(1, centerViewWidth);
      this.splitView.resizeView(2, Math.ceil(marginWidthFloat));
    } else {
      const leftMargin = this.state.leftMarginRatio * this.lastLayoutPosition.width;
      const rightMargin = this.state.rightMarginRatio * this.lastLayoutPosition.width;
      const center = this.lastLayoutPosition.width - leftMargin - rightMargin;
      this.splitView.resizeView(0, leftMargin);
      this.splitView.resizeView(1, center);
      this.splitView.resizeView(2, rightMargin);
    }
  }
  setFixedWidth(option) {
    this.centeredLayoutFixedWidth = option;
    if (!!this.splitView) {
      this.updateState();
      this.resizeSplitViews();
    }
  }
  updateState() {
    if (!!this.splitView) {
      this.state.targetWidth = this.splitView.getViewSize(1);
      this.state.leftMarginRatio = this.splitView.getViewSize(0) / this.lastLayoutPosition.width;
      this.state.rightMarginRatio = this.splitView.getViewSize(2) / this.lastLayoutPosition.width;
    }
  }
  isActive() {
    return !!this.splitView;
  }
  styles(style) {
    this.style = style;
    if (this.splitView && this.emptyViews) {
      this.splitView.style(this.style);
      this.emptyViews[0].element.style.backgroundColor = this.style.background.toString();
      this.emptyViews[1].element.style.backgroundColor = this.style.background.toString();
    }
  }
  activate(active) {
    var _a2;
    if (active === this.isActive()) {
      return;
    }
    if (active) {
      this.container.removeChild(this.view.element);
      this.splitView = new SplitView(this.container, {
        inverseAltBehavior: true,
        orientation: 1,
        styles: this.style
      });
      this.splitView.orthogonalStartSash = this.boundarySashes.top;
      this.splitView.orthogonalEndSash = this.boundarySashes.bottom;
      this.splitViewDisposables.add(this.splitView.onDidSashChange(() => {
        if (!!this.splitView) {
          this.updateState();
        }
      }));
      this.splitViewDisposables.add(this.splitView.onDidSashReset(() => {
        this.state = { ...defaultState };
        this.resizeSplitViews();
      }));
      this.splitView.layout(this.lastLayoutPosition.width, this.lastLayoutPosition);
      const backgroundColor = this.style ? this.style.background : void 0;
      this.emptyViews = [createEmptyView(backgroundColor), createEmptyView(backgroundColor)];
      this.splitView.addView(this.emptyViews[0], distributeSizing, 0);
      this.splitView.addView(toSplitViewView(this.view, () => this.lastLayoutPosition.height), distributeSizing, 1);
      this.splitView.addView(this.emptyViews[1], distributeSizing, 2);
      this.resizeSplitViews();
    } else {
      if (this.splitView) {
        this.container.removeChild(this.splitView.el);
      }
      this.splitViewDisposables.clear();
      (_a2 = this.splitView) == null ? void 0 : _a2.dispose();
      this.splitView = void 0;
      this.emptyViews = void 0;
      this.container.appendChild(this.view.element);
      this.view.layout(this.lastLayoutPosition.width, this.lastLayoutPosition.height, this.lastLayoutPosition.top, this.lastLayoutPosition.left);
    }
  }
  isDefault(state) {
    if (this.centeredLayoutFixedWidth) {
      return state.targetWidth === defaultState.targetWidth;
    } else {
      return state.leftMarginRatio === defaultState.leftMarginRatio && state.rightMarginRatio === defaultState.rightMarginRatio;
    }
  }
  dispose() {
    this.splitViewDisposables.dispose();
    if (this.splitView) {
      this.splitView.dispose();
      this.splitView = void 0;
    }
  }
}
class GridWidgetView {
  constructor() {
    this.element = $$2(".grid-view-container");
    this._onDidChange = new Relay();
    this.onDidChange = this._onDidChange.event;
  }
  get minimumWidth() {
    return this.gridWidget ? this.gridWidget.minimumWidth : 0;
  }
  get maximumWidth() {
    return this.gridWidget ? this.gridWidget.maximumWidth : Number.POSITIVE_INFINITY;
  }
  get minimumHeight() {
    return this.gridWidget ? this.gridWidget.minimumHeight : 0;
  }
  get maximumHeight() {
    return this.gridWidget ? this.gridWidget.maximumHeight : Number.POSITIVE_INFINITY;
  }
  get gridWidget() {
    return this._gridWidget;
  }
  set gridWidget(grid) {
    this.element.innerText = "";
    if (grid) {
      this.element.appendChild(grid.element);
      this._onDidChange.input = grid.onDidChange;
    } else {
      this._onDidChange.input = Event.None;
    }
    this._gridWidget = grid;
  }
  layout(width, height, top, left) {
    var _a2;
    (_a2 = this.gridWidget) == null ? void 0 : _a2.layout(width, height, top, left);
  }
  dispose() {
    this._onDidChange.dispose();
  }
}
let EditorPart = (_m = class extends Part {
  constructor(instantiationService, themeService, configurationService, storageService, layoutService) {
    super("workbench.parts.editor", { hasTitle: false }, themeService, storageService, layoutService);
    this.instantiationService = instantiationService;
    this.configurationService = configurationService;
    this._onDidLayout = this._register(new Emitter());
    this.onDidLayout = this._onDidLayout.event;
    this._onDidChangeActiveGroup = this._register(new Emitter());
    this.onDidChangeActiveGroup = this._onDidChangeActiveGroup.event;
    this._onDidChangeGroupIndex = this._register(new Emitter());
    this.onDidChangeGroupIndex = this._onDidChangeGroupIndex.event;
    this._onDidChangeGroupLocked = this._register(new Emitter());
    this.onDidChangeGroupLocked = this._onDidChangeGroupLocked.event;
    this._onDidActivateGroup = this._register(new Emitter());
    this.onDidActivateGroup = this._onDidActivateGroup.event;
    this._onDidAddGroup = this._register(new Emitter());
    this.onDidAddGroup = this._onDidAddGroup.event;
    this._onDidRemoveGroup = this._register(new Emitter());
    this.onDidRemoveGroup = this._onDidRemoveGroup.event;
    this._onDidMoveGroup = this._register(new Emitter());
    this.onDidMoveGroup = this._onDidMoveGroup.event;
    this.onDidSetGridWidget = this._register(new Emitter());
    this._onDidChangeSizeConstraints = this._register(new Relay());
    this.onDidChangeSizeConstraints = Event.any(this.onDidSetGridWidget.event, this._onDidChangeSizeConstraints.event);
    this._onDidScroll = this._register(new Relay());
    this.onDidScroll = Event.any(this.onDidSetGridWidget.event, this._onDidScroll.event);
    this._onDidChangeEditorPartOptions = this._register(new Emitter());
    this.onDidChangeEditorPartOptions = this._onDidChangeEditorPartOptions.event;
    this.workspaceMemento = this.getMemento(1, 1);
    this.profileMemento = this.getMemento(0, 1);
    this.groupViews = /* @__PURE__ */ new Map();
    this.mostRecentActiveGroups = [];
    this.gridWidgetView = this._register(new GridWidgetView());
    this.enforcedPartOptions = [];
    this._partOptions = getEditorPartOptions(this.configurationService, this.themeService);
    this._top = 0;
    this._left = 0;
    this.sideGroup = {
      openEditor: (editor, options) => {
        const [group] = this.instantiationService.invokeFunction((accessor) => findGroup(accessor, { editor, options }, SIDE_GROUP));
        return group.openEditor(editor, options);
      }
    };
    this._isReady = false;
    this.whenReadyPromise = new DeferredPromise();
    this.whenReady = this.whenReadyPromise.p;
    this.whenRestoredPromise = new DeferredPromise();
    this.whenRestored = this.whenRestoredPromise.p;
    this.priority = 2;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onConfigurationUpdated(e)));
    this._register(this.themeService.onDidFileIconThemeChange(() => this.handleChangedPartOptions()));
  }
  onConfigurationUpdated(event) {
    if (impactsEditorPartOptions(event)) {
      this.handleChangedPartOptions();
    }
  }
  handleChangedPartOptions() {
    const oldPartOptions = this._partOptions;
    const newPartOptions = getEditorPartOptions(this.configurationService, this.themeService);
    for (const enforcedPartOptions of this.enforcedPartOptions) {
      Object.assign(newPartOptions, enforcedPartOptions);
    }
    this._partOptions = newPartOptions;
    this._onDidChangeEditorPartOptions.fire({ oldPartOptions, newPartOptions });
  }
  get partOptions() {
    return this._partOptions;
  }
  enforcePartOptions(options) {
    this.enforcedPartOptions.push(options);
    this.handleChangedPartOptions();
    return toDisposable(() => {
      this.enforcedPartOptions.splice(this.enforcedPartOptions.indexOf(options), 1);
      this.handleChangedPartOptions();
    });
  }
  get contentDimension() {
    return this._contentDimension;
  }
  get activeGroup() {
    return this._activeGroup;
  }
  get groups() {
    return Array.from(this.groupViews.values());
  }
  get count() {
    return this.groupViews.size;
  }
  get orientation() {
    return this.gridWidget && this.gridWidget.orientation === 0 ? 1 : 0;
  }
  get isReady() {
    return this._isReady;
  }
  get hasRestorableState() {
    return !!this.workspaceMemento[_m.EDITOR_PART_UI_STATE_STORAGE_KEY];
  }
  getGroups(order = 0) {
    switch (order) {
      case 0:
        return this.groups;
      case 1: {
        const mostRecentActive = coalesce(this.mostRecentActiveGroups.map((groupId) => this.getGroup(groupId)));
        return distinct([...mostRecentActive, ...this.groups]);
      }
      case 2: {
        const views = [];
        if (this.gridWidget) {
          this.fillGridNodes(views, this.gridWidget.getViews());
        }
        return views;
      }
    }
  }
  fillGridNodes(target, node) {
    if (isGridBranchNode(node)) {
      node.children.forEach((child) => this.fillGridNodes(target, child));
    } else {
      target.push(node.view);
    }
  }
  getGroup(identifier) {
    return this.groupViews.get(identifier);
  }
  findGroup(scope, source = this.activeGroup, wrap) {
    if (typeof scope.direction === "number") {
      return this.doFindGroupByDirection(scope.direction, source, wrap);
    }
    if (typeof scope.location === "number") {
      return this.doFindGroupByLocation(scope.location, source, wrap);
    }
    throw new Error("invalid arguments");
  }
  doFindGroupByDirection(direction, source, wrap) {
    const sourceGroupView = this.assertGroupView(source);
    const neighbours = this.gridWidget.getNeighborViews(sourceGroupView, this.toGridViewDirection(direction), wrap);
    neighbours.sort((n1, n2) => this.mostRecentActiveGroups.indexOf(n1.id) - this.mostRecentActiveGroups.indexOf(n2.id));
    return neighbours[0];
  }
  doFindGroupByLocation(location, source, wrap) {
    const sourceGroupView = this.assertGroupView(source);
    const groups = this.getGroups(2);
    const index = groups.indexOf(sourceGroupView);
    switch (location) {
      case 0:
        return groups[0];
      case 1:
        return groups[groups.length - 1];
      case 2: {
        let nextGroup = groups[index + 1];
        if (!nextGroup && wrap) {
          nextGroup = this.doFindGroupByLocation(0, source);
        }
        return nextGroup;
      }
      case 3: {
        let previousGroup = groups[index - 1];
        if (!previousGroup && wrap) {
          previousGroup = this.doFindGroupByLocation(1, source);
        }
        return previousGroup;
      }
    }
  }
  activateGroup(group) {
    const groupView = this.assertGroupView(group);
    this.doSetGroupActive(groupView);
    this._onDidActivateGroup.fire(groupView);
    return groupView;
  }
  restoreGroup(group) {
    const groupView = this.assertGroupView(group);
    this.doRestoreGroup(groupView);
    return groupView;
  }
  getSize(group) {
    const groupView = this.assertGroupView(group);
    return this.gridWidget.getViewSize(groupView);
  }
  setSize(group, size2) {
    const groupView = this.assertGroupView(group);
    this.gridWidget.resizeView(groupView, size2);
  }
  arrangeGroups(arrangement, target = this.activeGroup) {
    if (this.count < 2) {
      return;
    }
    if (!this.gridWidget) {
      return;
    }
    switch (arrangement) {
      case 1:
        this.gridWidget.distributeViewSizes();
        break;
      case 0:
        this.gridWidget.maximizeViewSize(target);
        break;
      case 2:
        if (this.isGroupMaximized(target)) {
          this.arrangeGroups(1);
        } else {
          this.arrangeGroups(0);
        }
        break;
    }
  }
  isGroupMaximized(targetGroup) {
    return this.gridWidget.isViewSizeMaximized(targetGroup);
  }
  setGroupOrientation(orientation) {
    if (!this.gridWidget) {
      return;
    }
    const newOrientation = orientation === 0 ? 1 : 0;
    if (this.gridWidget.orientation !== newOrientation) {
      this.gridWidget.orientation = newOrientation;
    }
  }
  applyLayout(layout) {
    const restoreFocus = this.shouldRestoreFocus(this.container);
    let layoutGroupsCount = 0;
    function countGroups(groups) {
      for (const group of groups) {
        if (Array.isArray(group.groups)) {
          countGroups(group.groups);
        } else {
          layoutGroupsCount++;
        }
      }
    }
    countGroups(layout.groups);
    let currentGroupViews = this.getGroups(2);
    if (layoutGroupsCount < currentGroupViews.length) {
      const lastGroupInLayout = currentGroupViews[layoutGroupsCount - 1];
      currentGroupViews.forEach((group, index) => {
        if (index >= layoutGroupsCount) {
          this.mergeGroup(group, lastGroupInLayout);
        }
      });
      currentGroupViews = this.getGroups(2);
    }
    const activeGroup = this.activeGroup;
    const gridDescriptor = createSerializedGrid({
      orientation: this.toGridViewOrientation(
        layout.orientation,
        this.isTwoDimensionalGrid() ? this.gridWidget.orientation : orthogonal(this.gridWidget.orientation)
      ),
      groups: layout.groups
    });
    this.doCreateGridControlWithState(gridDescriptor, activeGroup.id, currentGroupViews);
    this.doLayout(this._contentDimension);
    this.updateContainer();
    for (const groupView of this.getGroups(2)) {
      if (!currentGroupViews.includes(groupView)) {
        this._onDidAddGroup.fire(groupView);
      }
    }
    this.notifyGroupIndexChange();
    if (restoreFocus) {
      this._activeGroup.focus();
    }
  }
  getLayout() {
    const serializedGrid = this.gridWidget.serialize();
    const orientation = serializedGrid.orientation === 1 ? 0 : 1;
    const root = this.serializedNodeToGroupLayoutArgument(serializedGrid.root);
    return {
      orientation,
      groups: root.groups
    };
  }
  serializedNodeToGroupLayoutArgument(serializedNode) {
    if (serializedNode.type === "branch") {
      return {
        size: serializedNode.size,
        groups: serializedNode.data.map((node) => this.serializedNodeToGroupLayoutArgument(node))
      };
    }
    return { size: serializedNode.size };
  }
  shouldRestoreFocus(target) {
    if (!target) {
      return false;
    }
    const activeElement = document.activeElement;
    if (activeElement === document.body) {
      return true;
    }
    return isAncestor(activeElement, target);
  }
  isTwoDimensionalGrid() {
    const views = this.gridWidget.getViews();
    if (isGridBranchNode(views)) {
      return views.children.some((child) => isGridBranchNode(child));
    }
    return false;
  }
  addGroup(location, direction, options) {
    const locationView = this.assertGroupView(location);
    const group = this.doAddGroup(locationView, direction);
    if (options == null ? void 0 : options.activate) {
      this.doSetGroupActive(group);
    }
    return group;
  }
  doAddGroup(locationView, direction, groupToCopy) {
    const shouldMaximize = this.groupViews.size > 1 && this.isGroupMaximized(locationView);
    const newGroupView = this.doCreateGroupView(groupToCopy);
    this.gridWidget.addView(newGroupView, this.getSplitSizingStyle(), locationView, this.toGridViewDirection(direction));
    this.updateContainer();
    this._onDidAddGroup.fire(newGroupView);
    this.notifyGroupIndexChange();
    if (shouldMaximize) {
      this.arrangeGroups(0, newGroupView);
    }
    return newGroupView;
  }
  getSplitSizingStyle() {
    switch (this._partOptions.splitSizing) {
      case "distribute":
        return Sizing.Distribute;
      case "split":
        return Sizing.Split;
      default:
        return Sizing.Auto;
    }
  }
  doCreateGroupView(from) {
    let groupView;
    if (from instanceof EditorGroupView) {
      groupView = EditorGroupView.createCopy(from, this, this.count, this.instantiationService);
    } else if (isSerializedEditorGroupModel(from)) {
      groupView = EditorGroupView.createFromSerialized(from, this, this.count, this.instantiationService);
    } else {
      groupView = EditorGroupView.createNew(this, this.count, this.instantiationService);
    }
    this.groupViews.set(groupView.id, groupView);
    const groupDisposables = new DisposableStore();
    groupDisposables.add(groupView.onDidFocus(() => {
      this.doSetGroupActive(groupView);
    }));
    groupDisposables.add(groupView.onDidModelChange((e) => {
      switch (e.kind) {
        case 2:
          this._onDidChangeGroupLocked.fire(groupView);
          break;
        case 1:
          this._onDidChangeGroupIndex.fire(groupView);
          break;
      }
    }));
    groupDisposables.add(groupView.onDidActiveEditorChange(() => {
      this.updateContainer();
    }));
    Event.once(groupView.onWillDispose)(() => {
      dispose(groupDisposables);
      this.groupViews.delete(groupView.id);
      this.doUpdateMostRecentActive(groupView);
    });
    return groupView;
  }
  doSetGroupActive(group) {
    if (this._activeGroup === group) {
      return;
    }
    const previousActiveGroup = this._activeGroup;
    this._activeGroup = group;
    this.doUpdateMostRecentActive(group, true);
    previousActiveGroup == null ? void 0 : previousActiveGroup.setActive(false);
    group.setActive(true);
    this.doRestoreGroup(group);
    this._onDidChangeActiveGroup.fire(group);
  }
  doRestoreGroup(group) {
    if (this.gridWidget) {
      const viewSize = this.gridWidget.getViewSize(group);
      if (viewSize.width === group.minimumWidth || viewSize.height === group.minimumHeight) {
        this.arrangeGroups(0, group);
      }
    }
  }
  doUpdateMostRecentActive(group, makeMostRecentlyActive) {
    const index = this.mostRecentActiveGroups.indexOf(group.id);
    if (index !== -1) {
      this.mostRecentActiveGroups.splice(index, 1);
    }
    if (makeMostRecentlyActive) {
      this.mostRecentActiveGroups.unshift(group.id);
    }
  }
  toGridViewDirection(direction) {
    switch (direction) {
      case 0:
        return 0;
      case 1:
        return 1;
      case 2:
        return 2;
      case 3:
        return 3;
    }
  }
  toGridViewOrientation(orientation, fallback) {
    if (typeof orientation === "number") {
      return orientation === 0 ? 1 : 0;
    }
    return fallback;
  }
  removeGroup(group) {
    const groupView = this.assertGroupView(group);
    if (this.count === 1) {
      return;
    }
    if (groupView.isEmpty) {
      return this.doRemoveEmptyGroup(groupView);
    }
    this.doRemoveGroupWithEditors(groupView);
  }
  doRemoveGroupWithEditors(groupView) {
    const mostRecentlyActiveGroups = this.getGroups(1);
    let lastActiveGroup;
    if (this._activeGroup === groupView) {
      lastActiveGroup = mostRecentlyActiveGroups[1];
    } else {
      lastActiveGroup = mostRecentlyActiveGroups[0];
    }
    this.mergeGroup(groupView, lastActiveGroup);
  }
  doRemoveEmptyGroup(groupView) {
    var _a2;
    const restoreFocus = this.shouldRestoreFocus(this.container);
    if (this._activeGroup === groupView) {
      const mostRecentlyActiveGroups = this.getGroups(1);
      const nextActiveGroup = mostRecentlyActiveGroups[1];
      this.activateGroup(nextActiveGroup);
    }
    this.gridWidget.removeView(groupView, this.getSplitSizingStyle());
    groupView.dispose();
    if (restoreFocus) {
      this._activeGroup.focus();
    }
    this.notifyGroupIndexChange();
    this.updateContainer();
    if (this.count === 1) {
      (_a2 = firstOrDefault(this.groups)) == null ? void 0 : _a2.lock(false);
    }
    this._onDidRemoveGroup.fire(groupView);
  }
  moveGroup(group, location, direction) {
    const sourceView = this.assertGroupView(group);
    const targetView = this.assertGroupView(location);
    if (sourceView.id === targetView.id) {
      throw new Error("Cannot move group into its own");
    }
    const restoreFocus = this.shouldRestoreFocus(sourceView.element);
    this.gridWidget.moveView(sourceView, this.getSplitSizingStyle(), targetView, this.toGridViewDirection(direction));
    if (restoreFocus) {
      sourceView.focus();
    }
    this._onDidMoveGroup.fire(sourceView);
    this.notifyGroupIndexChange();
    return sourceView;
  }
  copyGroup(group, location, direction) {
    const groupView = this.assertGroupView(group);
    const locationView = this.assertGroupView(location);
    const restoreFocus = this.shouldRestoreFocus(groupView.element);
    const copiedGroupView = this.doAddGroup(locationView, direction, groupView);
    if (restoreFocus) {
      copiedGroupView.focus();
    }
    return copiedGroupView;
  }
  mergeGroup(group, target, options) {
    const sourceView = this.assertGroupView(group);
    const targetView = this.assertGroupView(target);
    const editors = [];
    let index = options && typeof options.index === "number" ? options.index : targetView.count;
    for (const editor of sourceView.editors) {
      const inactive = !sourceView.isActive(editor) || this._activeGroup !== sourceView;
      const sticky = sourceView.isSticky(editor);
      const options2 = { index: !sticky ? index : void 0, inactive, preserveFocus: inactive };
      editors.push({ editor, options: options2 });
      index++;
    }
    if ((options == null ? void 0 : options.mode) === 0) {
      sourceView.copyEditors(editors, targetView);
    } else {
      sourceView.moveEditors(editors, targetView);
    }
    if (sourceView.isEmpty && !sourceView.disposed) {
      this.removeGroup(sourceView);
    }
    return targetView;
  }
  mergeAllGroups(target = this.activeGroup) {
    for (const group of this.getGroups(1)) {
      if (group === target) {
        continue;
      }
      this.mergeGroup(group, target);
    }
    return target;
  }
  assertGroupView(group) {
    let groupView;
    if (typeof group === "number") {
      groupView = this.getGroup(group);
    } else {
      groupView = group;
    }
    if (!groupView) {
      throw new Error("Invalid editor group provided!");
    }
    return groupView;
  }
  createEditorDropTarget(container, delegate) {
    return this.instantiationService.createInstance(EditorDropTarget, this, container, delegate);
  }
  get minimumWidth() {
    return Math.min(this.centeredLayoutWidget.minimumWidth, this.layoutService.getMaximumEditorDimensions().width);
  }
  get maximumWidth() {
    return this.centeredLayoutWidget.maximumWidth;
  }
  get minimumHeight() {
    return Math.min(this.centeredLayoutWidget.minimumHeight, this.layoutService.getMaximumEditorDimensions().height);
  }
  get maximumHeight() {
    return this.centeredLayoutWidget.maximumHeight;
  }
  get snap() {
    return this.layoutService.getPanelAlignment() === "center";
  }
  get onDidChange() {
    return Event.any(this.centeredLayoutWidget.onDidChange, this.onDidSetGridWidget.event);
  }
  get gridSeparatorBorder() {
    return this.theme.getColor(EDITOR_GROUP_BORDER) || this.theme.getColor(contrastBorder) || Color.transparent;
  }
  updateStyles() {
    const container = assertIsDefined(this.container);
    container.style.backgroundColor = this.getColor(editorBackground) || "";
    const separatorBorderStyle = { separatorBorder: this.gridSeparatorBorder, background: this.theme.getColor(EDITOR_PANE_BACKGROUND) || Color.transparent };
    this.gridWidget.style(separatorBorderStyle);
    this.centeredLayoutWidget.styles(separatorBorderStyle);
  }
  createContentArea(parent, options) {
    this.element = parent;
    this.container = document.createElement("div");
    this.container.classList.add("content");
    parent.appendChild(this.container);
    this.doCreateGridControl(options);
    this.centeredLayoutWidget = this._register(new CenteredViewLayout(
      this.container,
      this.gridWidgetView,
      this.profileMemento[_m.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY]
    ));
    this._register(this.onDidChangeEditorPartOptions((e) => this.centeredLayoutWidget.setFixedWidth(e.newPartOptions.centeredLayoutFixedWidth ?? false)));
    this.setupDragAndDropSupport(parent, this.container);
    this.whenReadyPromise.complete();
    this._isReady = true;
    Promises.settled(this.groups.map((group) => group.whenRestored)).finally(() => {
      this.whenRestoredPromise.complete();
    });
    return this.container;
  }
  setupDragAndDropSupport(parent, container) {
    this._register(this.createEditorDropTarget(container, /* @__PURE__ */ Object.create(null)));
    const overlay = document.createElement("div");
    overlay.classList.add("drop-block-overlay");
    parent.appendChild(overlay);
    this._register(addDisposableGenericMouseDownListener(overlay, () => overlay.classList.remove("visible")));
    this._register(CompositeDragAndDropObserver.INSTANCE.registerTarget(this.element, {
      onDragStart: (e) => overlay.classList.add("visible"),
      onDragEnd: (e) => overlay.classList.remove("visible")
    }));
    let horizontalOpenerTimeout;
    let verticalOpenerTimeout;
    let lastOpenHorizontalPosition;
    let lastOpenVerticalPosition;
    const openPartAtPosition = (position) => {
      if (!this.layoutService.isVisible("workbench.parts.panel") && position === this.layoutService.getPanelPosition()) {
        this.layoutService.setPartHidden(false, "workbench.parts.panel");
      } else if (!this.layoutService.isVisible("workbench.parts.auxiliarybar") && position === (this.layoutService.getSideBarPosition() === 1 ? 0 : 1)) {
        this.layoutService.setPartHidden(false, "workbench.parts.auxiliarybar");
      }
    };
    const clearAllTimeouts = () => {
      if (horizontalOpenerTimeout) {
        clearTimeout(horizontalOpenerTimeout);
        horizontalOpenerTimeout = void 0;
      }
      if (verticalOpenerTimeout) {
        clearTimeout(verticalOpenerTimeout);
        verticalOpenerTimeout = void 0;
      }
    };
    this._register(CompositeDragAndDropObserver.INSTANCE.registerTarget(overlay, {
      onDragOver: (e) => {
        EventHelper.stop(e.eventData, true);
        if (e.eventData.dataTransfer) {
          e.eventData.dataTransfer.dropEffect = "none";
        }
        const boundingRect = overlay.getBoundingClientRect();
        let openHorizontalPosition = void 0;
        let openVerticalPosition = void 0;
        const proximity = 100;
        if (e.eventData.clientX < boundingRect.left + proximity) {
          openHorizontalPosition = 0;
        }
        if (e.eventData.clientX > boundingRect.right - proximity) {
          openHorizontalPosition = 1;
        }
        if (e.eventData.clientY > boundingRect.bottom - proximity) {
          openVerticalPosition = 2;
        }
        if (horizontalOpenerTimeout && openHorizontalPosition !== lastOpenHorizontalPosition) {
          clearTimeout(horizontalOpenerTimeout);
          horizontalOpenerTimeout = void 0;
        }
        if (verticalOpenerTimeout && openVerticalPosition !== lastOpenVerticalPosition) {
          clearTimeout(verticalOpenerTimeout);
          verticalOpenerTimeout = void 0;
        }
        if (!horizontalOpenerTimeout && openHorizontalPosition !== void 0) {
          lastOpenHorizontalPosition = openHorizontalPosition;
          horizontalOpenerTimeout = setTimeout(() => openPartAtPosition(openHorizontalPosition), 200);
        }
        if (!verticalOpenerTimeout && openVerticalPosition !== void 0) {
          lastOpenVerticalPosition = openVerticalPosition;
          verticalOpenerTimeout = setTimeout(() => openPartAtPosition(openVerticalPosition), 200);
        }
      },
      onDragLeave: () => clearAllTimeouts(),
      onDragEnd: () => clearAllTimeouts(),
      onDrop: () => clearAllTimeouts()
    }));
  }
  centerLayout(active) {
    this.centeredLayoutWidget.activate(active);
    this._activeGroup.focus();
  }
  isLayoutCentered() {
    if (this.centeredLayoutWidget) {
      return this.centeredLayoutWidget.isActive();
    }
    return false;
  }
  doCreateGridControl(options) {
    let restoreError = false;
    if (!options || options.restorePreviousState) {
      restoreError = !this.doCreateGridControlWithPreviousState();
    }
    if (!this.gridWidget || restoreError) {
      const initialGroup = this.doCreateGroupView();
      this.doSetGridWidget(new SerializableGrid(initialGroup));
      this.doSetGroupActive(initialGroup);
    }
    this.updateContainer();
    this.notifyGroupIndexChange();
  }
  doCreateGridControlWithPreviousState() {
    const uiState = this.workspaceMemento[_m.EDITOR_PART_UI_STATE_STORAGE_KEY];
    if (uiState == null ? void 0 : uiState.serializedGrid) {
      try {
        this.mostRecentActiveGroups = uiState.mostRecentActiveGroups;
        this.doCreateGridControlWithState(uiState.serializedGrid, uiState.activeGroup);
        this._activeGroup.focus();
      } catch (error) {
        onUnexpectedError(new Error(
          `Error restoring editor grid widget: ${error} (with state: ${JSON.stringify(uiState)})`
        ));
        this.groupViews.forEach((group) => group.dispose());
        this.groupViews.clear();
        this.mostRecentActiveGroups = [];
        return false;
      }
    }
    return true;
  }
  doCreateGridControlWithState(serializedGrid, activeGroupId, editorGroupViewsToReuse) {
    let reuseGroupViews;
    if (editorGroupViewsToReuse) {
      reuseGroupViews = editorGroupViewsToReuse.slice(0);
    } else {
      reuseGroupViews = [];
    }
    const groupViews = [];
    const gridWidget = SerializableGrid.deserialize(serializedGrid, {
      fromJSON: (serializedEditorGroup) => {
        let groupView;
        if (reuseGroupViews.length > 0) {
          groupView = reuseGroupViews.shift();
        } else {
          groupView = this.doCreateGroupView(serializedEditorGroup);
        }
        groupViews.push(groupView);
        if (groupView.id === activeGroupId) {
          this.doSetGroupActive(groupView);
        }
        return groupView;
      }
    }, { styles: { separatorBorder: this.gridSeparatorBorder } });
    if (!this._activeGroup) {
      this.doSetGroupActive(groupViews[0]);
    }
    if (this.mostRecentActiveGroups.some((groupId) => !this.getGroup(groupId))) {
      this.mostRecentActiveGroups = groupViews.map((group) => group.id);
    }
    this.doSetGridWidget(gridWidget);
  }
  doSetGridWidget(gridWidget) {
    let boundarySashes = {};
    if (this.gridWidget) {
      boundarySashes = this.gridWidget.boundarySashes;
      this.gridWidget.dispose();
    }
    this.gridWidget = gridWidget;
    this.gridWidget.boundarySashes = boundarySashes;
    this.gridWidgetView.gridWidget = gridWidget;
    this._onDidChangeSizeConstraints.input = gridWidget.onDidChange;
    this._onDidScroll.input = gridWidget.onDidScroll;
    this.onDidSetGridWidget.fire(void 0);
  }
  updateContainer() {
    const container = assertIsDefined(this.container);
    container.classList.toggle("empty", this.isEmpty);
  }
  notifyGroupIndexChange() {
    this.getGroups(2).forEach((group, index) => group.notifyIndexChanged(index));
  }
  get isEmpty() {
    return this.count === 1 && this._activeGroup.isEmpty;
  }
  setBoundarySashes(sashes) {
    this.gridWidget.boundarySashes = sashes;
    this.centeredLayoutWidget.boundarySashes = sashes;
  }
  layout(width, height, top, left) {
    this._top = top;
    this._left = left;
    const contentAreaSize = super.layoutContents(width, height).contentSize;
    this.doLayout(Dimension.lift(contentAreaSize), top, left);
  }
  doLayout(dimension, top = this._top, left = this._left) {
    this._contentDimension = dimension;
    this.centeredLayoutWidget.layout(this._contentDimension.width, this._contentDimension.height, top, left);
    this._onDidLayout.fire(dimension);
  }
  saveState() {
    if (this.gridWidget) {
      const uiState = {
        serializedGrid: this.gridWidget.serialize(),
        activeGroup: this._activeGroup.id,
        mostRecentActiveGroups: this.mostRecentActiveGroups
      };
      if (this.isEmpty) {
        delete this.workspaceMemento[_m.EDITOR_PART_UI_STATE_STORAGE_KEY];
      } else {
        this.workspaceMemento[_m.EDITOR_PART_UI_STATE_STORAGE_KEY] = uiState;
      }
    }
    if (this.centeredLayoutWidget) {
      const centeredLayoutState = this.centeredLayoutWidget.state;
      if (this.centeredLayoutWidget.isDefault(centeredLayoutState)) {
        delete this.profileMemento[_m.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY];
      } else {
        this.profileMemento[_m.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY] = centeredLayoutState;
      }
    }
    super.saveState();
  }
  toJSON() {
    return {
      type: "workbench.parts.editor"
    };
  }
  dispose() {
    var _a2;
    this.groupViews.forEach((group) => group.dispose());
    this.groupViews.clear();
    (_a2 = this.gridWidget) == null ? void 0 : _a2.dispose();
    super.dispose();
  }
}, _m.EDITOR_PART_UI_STATE_STORAGE_KEY = "editorpart.state", _m.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY = "editorpart.centeredview", _m);
EditorPart = __decorate([
  __param(0, IInstantiationService),
  __param(1, IThemeService),
  __param(2, IConfigurationService),
  __param(3, IStorageService),
  __param(4, IWorkbenchLayoutService)
], EditorPart);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200,
  when: ExplorerFocusCondition,
  primary: 2048 | 3,
  mac: {
    primary: 256 | 3
  },
  id: OPEN_TO_SIDE_COMMAND_ID,
  handler: async (accessor, resource) => {
    const editorService = accessor.get(IEditorService);
    const listService = accessor.get(IListService);
    const fileService = accessor.get(IFileService);
    const explorerService = accessor.get(IExplorerService);
    const resources = getMultiSelectedResources(resource, listService, editorService, explorerService);
    if (resources.length) {
      const untitledResources = resources.filter((resource2) => resource2.scheme === Schemas.untitled);
      const fileResources = resources.filter((resource2) => resource2.scheme !== Schemas.untitled);
      const items = await Promise.all(fileResources.map(async (resource2) => {
        const item = explorerService.findClosest(resource2);
        if (item) {
          return item;
        }
        return await fileService.stat(resource2);
      }));
      const files = items.filter((i) => !i.isDirectory);
      const editors = files.map((f) => ({
        resource: f.resource,
        options: { pinned: true }
      })).concat(...untitledResources.map(
        (untitledResource) => ({ resource: untitledResource, options: { pinned: true } })
      ));
      await editorService.openEditors(editors, SIDE_GROUP);
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerFolderContext.toNegated()),
  primary: 3,
  mac: {
    primary: 2048 | 18
  },
  id: "explorer.openAndPassFocus",
  handler: async (accessor, _resource) => {
    const editorService = accessor.get(IEditorService);
    const explorerService = accessor.get(IExplorerService);
    const resources = explorerService.getContext(true);
    if (resources.length) {
      await editorService.openEditors(resources.map(
        (r) => ({ resource: r.resource, options: { preserveFocus: false, pinned: true } })
      ));
    }
  }
});
const COMPARE_WITH_SAVED_SCHEMA = "showModifications";
let providerDisposables = [];
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: COMPARE_WITH_SAVED_COMMAND_ID,
  when: void 0,
  weight: 200,
  primary: KeyChord(2048 | 41, 34),
  handler: async (accessor, resource) => {
    const instantiationService = accessor.get(IInstantiationService);
    const textModelService = accessor.get(ITextModelService);
    const editorService = accessor.get(IEditorService);
    const fileService = accessor.get(IFileService);
    let registerEditorListener = false;
    if (providerDisposables.length === 0) {
      registerEditorListener = true;
      const provider = instantiationService.createInstance(TextFileContentProvider);
      providerDisposables.push(provider);
      providerDisposables.push(textModelService.registerTextModelContentProvider(COMPARE_WITH_SAVED_SCHEMA, provider));
    }
    const uri = getResourceForCommand(resource, accessor.get(IListService), editorService);
    if (uri && fileService.hasProvider(uri)) {
      const name = basename(uri);
      const editorLabel = localize("modifiedLabel", "{0} (in file) ↔ {1}", name, name);
      try {
        await TextFileContentProvider.open(uri, COMPARE_WITH_SAVED_SCHEMA, editorLabel, editorService, { pinned: true });
        if (registerEditorListener) {
          providerDisposables.push(editorService.onDidVisibleEditorsChange(() => {
            if (!editorService.editors.some(
              (editor) => !!EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.SECONDARY, filterByScheme: COMPARE_WITH_SAVED_SCHEMA })
            )) {
              providerDisposables = dispose(providerDisposables);
            }
          }));
        }
      } catch {
        providerDisposables = dispose(providerDisposables);
      }
    }
  }
});
let globalResourceToCompare;
let resourceSelectedForCompareContext;
CommandsRegistry.registerCommand({
  id: SELECT_FOR_COMPARE_COMMAND_ID,
  handler: (accessor, resource) => {
    const listService = accessor.get(IListService);
    globalResourceToCompare = getResourceForCommand(resource, listService, accessor.get(IEditorService));
    if (!resourceSelectedForCompareContext) {
      resourceSelectedForCompareContext = ResourceSelectedForCompareContext.bindTo(accessor.get(IContextKeyService));
    }
    resourceSelectedForCompareContext.set(true);
  }
});
CommandsRegistry.registerCommand({
  id: COMPARE_SELECTED_COMMAND_ID,
  handler: async (accessor, resource) => {
    const editorService = accessor.get(IEditorService);
    const explorerService = accessor.get(IExplorerService);
    const resources = getMultiSelectedResources(resource, accessor.get(IListService), editorService, explorerService);
    if (resources.length === 2) {
      return editorService.openEditor({
        original: { resource: resources[0] },
        modified: { resource: resources[1] },
        options: { pinned: true }
      });
    }
    return true;
  }
});
CommandsRegistry.registerCommand({
  id: COMPARE_RESOURCE_COMMAND_ID,
  handler: (accessor, resource) => {
    const editorService = accessor.get(IEditorService);
    const listService = accessor.get(IListService);
    const rightResource = getResourceForCommand(resource, listService, editorService);
    if (globalResourceToCompare && rightResource) {
      editorService.openEditor({
        original: { resource: globalResourceToCompare },
        modified: { resource: rightResource },
        options: { pinned: true }
      });
    }
  }
});
async function resourcesToClipboard(resources, relative2, clipboardService, labelService, configurationService) {
  if (resources.length) {
    const lineDelimiter = isWindows ? "\r\n" : "\n";
    let separator = void 0;
    if (relative2) {
      const relativeSeparator = configurationService.getValue("explorer.copyRelativePathSeparator");
      if (relativeSeparator === "/" || relativeSeparator === "\\") {
        separator = relativeSeparator;
      }
    }
    const text = resources.map(
      (resource) => labelService.getUriLabel(resource, { relative: relative2, noPrefix: true, separator })
    ).join(lineDelimiter);
    await clipboardService.writeText(text);
  }
}
const copyPathCommandHandler = async (accessor, resource) => {
  const resources = getMultiSelectedResources(resource, accessor.get(IListService), accessor.get(IEditorService), accessor.get(IExplorerService));
  await resourcesToClipboard(resources, false, accessor.get(IClipboardService), accessor.get(ILabelService), accessor.get(IConfigurationService));
};
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200,
  when: EditorContextKeys.focus.toNegated(),
  primary: 2048 | 512 | 33,
  win: {
    primary: 1024 | 512 | 33
  },
  id: COPY_PATH_COMMAND_ID,
  handler: copyPathCommandHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200,
  when: EditorContextKeys.focus,
  primary: KeyChord(2048 | 41, 2048 | 512 | 33),
  win: {
    primary: 1024 | 512 | 33
  },
  id: COPY_PATH_COMMAND_ID,
  handler: copyPathCommandHandler
});
const copyRelativePathCommandHandler = async (accessor, resource) => {
  const resources = getMultiSelectedResources(resource, accessor.get(IListService), accessor.get(IEditorService), accessor.get(IExplorerService));
  await resourcesToClipboard(resources, true, accessor.get(IClipboardService), accessor.get(ILabelService), accessor.get(IConfigurationService));
};
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200,
  when: EditorContextKeys.focus.toNegated(),
  primary: 2048 | 1024 | 512 | 33,
  win: {
    primary: KeyChord(2048 | 41, 2048 | 1024 | 33)
  },
  id: COPY_RELATIVE_PATH_COMMAND_ID,
  handler: copyRelativePathCommandHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200,
  when: EditorContextKeys.focus,
  primary: KeyChord(2048 | 41, 2048 | 1024 | 512 | 33),
  win: {
    primary: KeyChord(2048 | 41, 2048 | 1024 | 33)
  },
  id: COPY_RELATIVE_PATH_COMMAND_ID,
  handler: copyRelativePathCommandHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200,
  when: void 0,
  primary: KeyChord(2048 | 41, 46),
  id: "workbench.action.files.copyPathOfActiveFile",
  handler: async (accessor) => {
    const editorService = accessor.get(IEditorService);
    const activeInput = editorService.activeEditor;
    const resource = EditorResourceAccessor.getOriginalUri(activeInput, { supportSideBySide: SideBySideEditor.PRIMARY });
    const resources = resource ? [resource] : [];
    await resourcesToClipboard(resources, false, accessor.get(IClipboardService), accessor.get(ILabelService), accessor.get(IConfigurationService));
  }
});
CommandsRegistry.registerCommand({
  id: REVEAL_IN_EXPLORER_COMMAND_ID,
  handler: async (accessor, resource) => {
    const viewService = accessor.get(IViewsService);
    const contextService = accessor.get(IWorkspaceContextService);
    const explorerService = accessor.get(IExplorerService);
    const uri = getResourceForCommand(resource, accessor.get(IListService), accessor.get(IEditorService));
    if (uri && contextService.isInsideWorkspace(uri)) {
      const explorerView = await viewService.openView(VIEW_ID, false);
      if (explorerView) {
        explorerView.setExpanded(true);
        await explorerService.select(uri, "force");
        explorerView.focus();
      }
    } else {
      const openEditorsView = await viewService.openView(OpenEditorsView.ID, false);
      if (openEditorsView) {
        openEditorsView.setExpanded(true);
        openEditorsView.focus();
      }
    }
  }
});
CommandsRegistry.registerCommand({
  id: OPEN_WITH_EXPLORER_COMMAND_ID,
  handler: async (accessor, resource) => {
    const editorService = accessor.get(IEditorService);
    const uri = getResourceForCommand(resource, accessor.get(IListService), accessor.get(IEditorService));
    if (uri) {
      return editorService.openEditor({ resource: uri, options: { override: EditorResolution.PICK, source: EditorOpenSource.USER } });
    }
    return void 0;
  }
});
async function saveSelectedEditors(accessor, options) {
  var _a2;
  const listService = accessor.get(IListService);
  const editorGroupService = accessor.get(IEditorGroupsService);
  const codeEditorService = accessor.get(ICodeEditorService);
  const textFileService = accessor.get(ITextFileService);
  let editors = getOpenEditorsViewMultiSelection(listService);
  if (!editors) {
    const activeGroup = editorGroupService.activeGroup;
    if (activeGroup.activeEditor) {
      editors = [];
      if (activeGroup.activeEditor instanceof SideBySideEditorInput && !(options == null ? void 0 : options.saveAs) && !(activeGroup.activeEditor.primary.hasCapability(4) || activeGroup.activeEditor.secondary.hasCapability(4))) {
        editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.primary });
        editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.secondary });
      } else {
        editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor });
      }
    }
  }
  if (!editors || editors.length === 0) {
    return;
  }
  await doSaveEditors(accessor, editors, options);
  const focusedCodeEditor = codeEditorService.getFocusedCodeEditor();
  if (focusedCodeEditor instanceof EmbeddedCodeEditorWidget) {
    const resource = (_a2 = focusedCodeEditor.getModel()) == null ? void 0 : _a2.uri;
    if (resource && !editors.some(
      ({ editor }) => isEqual(EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }), resource)
    )) {
      const model = textFileService.files.get(resource);
      if (!(model == null ? void 0 : model.isReadonly())) {
        await textFileService.save(resource, options);
      }
    }
  }
}
function saveDirtyEditorsOfGroups(accessor, groups, options) {
  const dirtyEditors = [];
  for (const group of groups) {
    for (const editor of group.getEditors(0)) {
      if (editor.isDirty()) {
        dirtyEditors.push({ groupId: group.id, editor });
      }
    }
  }
  return doSaveEditors(accessor, dirtyEditors, options);
}
async function doSaveEditors(accessor, editors, options) {
  const editorService = accessor.get(IEditorService);
  const notificationService = accessor.get(INotificationService);
  const instantiationService = accessor.get(IInstantiationService);
  try {
    await editorService.save(editors, options);
  } catch (error) {
    if (!isCancellationError(error)) {
      notificationService.notify({
        id: editors.map(({ editor }) => {
          var _a2;
          return hash((_a2 = editor.resource) == null ? void 0 : _a2.toString());
        }).join(),
        severity: Severity.Error,
        message: localize(
          { key: "genericSaveError", comment: ["{0} is the resource that failed to save and {1} the error message"] },
          "Failed to save '{0}': {1}",
          editors.map(({ editor }) => editor.getName()).join(", "),
          toErrorMessage(error, false)
        ),
        actions: {
          primary: [
            toAction({ id: "workbench.action.files.saveEditors", label: localize("retry", "Retry"), run: () => instantiationService.invokeFunction((accessor2) => doSaveEditors(accessor2, editors, options)) }),
            toAction({ id: "workbench.action.files.revertEditors", label: localize("discard", "Discard"), run: () => editorService.revert(editors) })
          ]
        }
      });
    }
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  when: void 0,
  weight: 200,
  primary: 2048 | 49,
  id: SAVE_FILE_COMMAND_ID,
  handler: (accessor) => {
    return saveSelectedEditors(accessor, { reason: 1, force: true });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  when: void 0,
  weight: 200,
  primary: KeyChord(2048 | 41, 49),
  win: { primary: KeyChord(2048 | 41, 2048 | 1024 | 49) },
  id: SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID,
  handler: (accessor) => {
    return saveSelectedEditors(accessor, { reason: 1, force: true, skipSaveParticipants: true });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: SAVE_FILE_AS_COMMAND_ID,
  weight: 200,
  when: void 0,
  primary: 2048 | 1024 | 49,
  handler: (accessor) => {
    return saveSelectedEditors(accessor, { reason: 1, saveAs: true });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  when: void 0,
  weight: 200,
  primary: void 0,
  mac: { primary: 2048 | 512 | 49 },
  win: { primary: KeyChord(2048 | 41, 49) },
  id: SAVE_ALL_COMMAND_ID,
  handler: (accessor) => {
    return saveDirtyEditorsOfGroups(accessor, accessor.get(IEditorGroupsService).getGroups(1), { reason: 1 });
  }
});
CommandsRegistry.registerCommand({
  id: SAVE_ALL_IN_GROUP_COMMAND_ID,
  handler: (accessor, _, editorContext) => {
    const editorGroupService = accessor.get(IEditorGroupsService);
    const contexts = getMultiSelectedEditorContexts(editorContext, accessor.get(IListService), accessor.get(IEditorGroupsService));
    let groups = void 0;
    if (!contexts.length) {
      groups = editorGroupService.getGroups(1);
    } else {
      groups = coalesce(contexts.map((context) => editorGroupService.getGroup(context.groupId)));
    }
    return saveDirtyEditorsOfGroups(accessor, groups, { reason: 1 });
  }
});
CommandsRegistry.registerCommand({
  id: SAVE_FILES_COMMAND_ID,
  handler: async (accessor) => {
    const editorService = accessor.get(IEditorService);
    const res = await editorService.saveAll({ includeUntitled: false, reason: 1 });
    return res.success;
  }
});
CommandsRegistry.registerCommand({
  id: REVERT_FILE_COMMAND_ID,
  handler: async (accessor) => {
    const notificationService = accessor.get(INotificationService);
    const listService = accessor.get(IListService);
    const editorGroupService = accessor.get(IEditorGroupsService);
    const editorService = accessor.get(IEditorService);
    let editors = getOpenEditorsViewMultiSelection(listService);
    if (!editors) {
      const activeGroup = editorGroupService.activeGroup;
      if (activeGroup.activeEditor) {
        editors = [{ groupId: activeGroup.id, editor: activeGroup.activeEditor }];
      }
    }
    if (!editors || editors.length === 0) {
      return;
    }
    try {
      await editorService.revert(editors.filter(({ editor }) => !editor.hasCapability(4)), { force: true });
    } catch (error) {
      notificationService.error(localize("genericRevertError", "Failed to revert '{0}': {1}", editors.map(({ editor }) => editor.getName()).join(", "), toErrorMessage(error, false)));
    }
  }
});
CommandsRegistry.registerCommand({
  id: REMOVE_ROOT_FOLDER_COMMAND_ID,
  handler: (accessor, resource) => {
    const workspaceEditingService = accessor.get(IWorkspaceEditingService);
    const contextService = accessor.get(IWorkspaceContextService);
    const uriIdentityService = accessor.get(IUriIdentityService);
    const workspace = contextService.getWorkspace();
    const resources = getMultiSelectedResources(resource, accessor.get(IListService), accessor.get(IEditorService), accessor.get(IExplorerService)).filter(
      (resource2) => workspace.folders.some((folder) => uriIdentityService.extUri.isEqual(folder.uri, resource2))
    );
    if (resources.length === 0) {
      const commandService = accessor.get(ICommandService);
      return commandService.executeCommand(RemoveRootFolderAction.ID);
    }
    return workspaceEditingService.removeFolders(resources);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: ContextKeyExpr.and(
    FilesExplorerFocusCondition,
    ExplorerCompressedFocusContext,
    ExplorerCompressedFirstFocusContext.negate()
  ),
  primary: 15,
  id: PREVIOUS_COMPRESSED_FOLDER,
  handler: (accessor) => {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    const viewlet = paneCompositeService.getActivePaneComposite(0);
    if ((viewlet == null ? void 0 : viewlet.getId()) !== VIEWLET_ID$1) {
      return;
    }
    const explorer = viewlet.getViewPaneContainer();
    const view = explorer.getExplorerView();
    view.previousCompressedStat();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: ContextKeyExpr.and(
    FilesExplorerFocusCondition,
    ExplorerCompressedFocusContext,
    ExplorerCompressedLastFocusContext.negate()
  ),
  primary: 17,
  id: NEXT_COMPRESSED_FOLDER,
  handler: (accessor) => {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    const viewlet = paneCompositeService.getActivePaneComposite(0);
    if ((viewlet == null ? void 0 : viewlet.getId()) !== VIEWLET_ID$1) {
      return;
    }
    const explorer = viewlet.getViewPaneContainer();
    const view = explorer.getExplorerView();
    view.nextCompressedStat();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: ContextKeyExpr.and(
    FilesExplorerFocusCondition,
    ExplorerCompressedFocusContext,
    ExplorerCompressedFirstFocusContext.negate()
  ),
  primary: 14,
  id: FIRST_COMPRESSED_FOLDER,
  handler: (accessor) => {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    const viewlet = paneCompositeService.getActivePaneComposite(0);
    if ((viewlet == null ? void 0 : viewlet.getId()) !== VIEWLET_ID$1) {
      return;
    }
    const explorer = viewlet.getViewPaneContainer();
    const view = explorer.getExplorerView();
    view.firstCompressedStat();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200 + 10,
  when: ContextKeyExpr.and(
    FilesExplorerFocusCondition,
    ExplorerCompressedFocusContext,
    ExplorerCompressedLastFocusContext.negate()
  ),
  primary: 13,
  id: LAST_COMPRESSED_FOLDER,
  handler: (accessor) => {
    const paneCompositeService = accessor.get(IPaneCompositePartService);
    const viewlet = paneCompositeService.getActivePaneComposite(0);
    if ((viewlet == null ? void 0 : viewlet.getId()) !== VIEWLET_ID$1) {
      return;
    }
    const explorer = viewlet.getViewPaneContainer();
    const view = explorer.getExplorerView();
    view.lastCompressedStat();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  weight: 200,
  when: null,
  primary: isWeb ? isWindows ? KeyChord(2048 | 41, 44) : 2048 | 512 | 44 : 2048 | 44,
  secondary: isWeb ? [2048 | 44] : void 0,
  id: NEW_UNTITLED_FILE_COMMAND_ID,
  description: {
    description: NEW_UNTITLED_FILE_LABEL,
    args: [
      {
        isOptional: true,
        name: "New Untitled Text File arguments",
        description: "The editor view type or language ID if known",
        schema: {
          "type": "object",
          "properties": {
            "viewType": {
              "type": "string"
            },
            "languageId": {
              "type": "string"
            }
          }
        }
      }
    ]
  },
  handler: async (accessor, args) => {
    const editorService = accessor.get(IEditorService);
    await editorService.openEditor({
      resource: void 0,
      options: {
        override: args == null ? void 0 : args.viewType,
        pinned: true
      },
      languageId: args == null ? void 0 : args.languageId
    });
  }
});
CommandsRegistry.registerCommand({
  id: NEW_FILE_COMMAND_ID,
  handler: async (accessor, args) => {
    const editorService = accessor.get(IEditorService);
    const dialogService = accessor.get(IFileDialogService);
    const fileService = accessor.get(IFileService);
    const createFileLocalized = localize("newFileCommand.saveLabel", "Create File");
    const defaultFileUri = joinPath(await dialogService.defaultFilePath(), (args == null ? void 0 : args.fileName) ?? "Untitled.txt");
    const saveUri = await dialogService.showSaveDialog({ saveLabel: createFileLocalized, title: createFileLocalized, defaultUri: defaultFileUri });
    if (!saveUri) {
      return;
    }
    await fileService.createFile(saveUri, void 0, { overwrite: true });
    await editorService.openEditor({
      resource: saveUri,
      options: {
        override: args == null ? void 0 : args.viewType,
        pinned: true
      },
      languageId: args == null ? void 0 : args.languageId
    });
  }
});
let FileEditorInput = class FileEditorInput2 extends AbstractTextResourceEditorInput {
  get typeId() {
    return FILE_EDITOR_INPUT_ID;
  }
  get editorId() {
    return DEFAULT_EDITOR_ASSOCIATION.id;
  }
  get capabilities() {
    let capabilities = 32;
    if (this.model) {
      if (this.model.isReadonly()) {
        capabilities |= 2;
      }
    } else {
      if (this.fileService.hasProvider(this.resource)) {
        if (this.filesConfigurationService.isReadonly(this.resource)) {
          capabilities |= 2;
        }
      } else {
        capabilities |= 4;
      }
    }
    if (!(capabilities & 2)) {
      capabilities |= 128;
    }
    return capabilities;
  }
  constructor(resource, preferredResource, preferredName, preferredDescription, preferredEncoding, preferredLanguageId, preferredContents, instantiationService, textFileService, textModelResolverService, labelService, fileService, filesConfigurationService, editorService, pathService, textResourceConfigurationService) {
    super(resource, preferredResource, editorService, textFileService, labelService, fileService, filesConfigurationService);
    this.instantiationService = instantiationService;
    this.textModelResolverService = textModelResolverService;
    this.pathService = pathService;
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.forceOpenAs = 0;
    this.model = void 0;
    this.cachedTextFileModelReference = void 0;
    this.modelListeners = this._register(new DisposableStore());
    this.model = this.textFileService.files.get(resource);
    if (preferredName) {
      this.setPreferredName(preferredName);
    }
    if (preferredDescription) {
      this.setPreferredDescription(preferredDescription);
    }
    if (preferredEncoding) {
      this.setPreferredEncoding(preferredEncoding);
    }
    if (preferredLanguageId) {
      this.setPreferredLanguageId(preferredLanguageId);
    }
    if (typeof preferredContents === "string") {
      this.setPreferredContents(preferredContents);
    }
    this._register(this.textFileService.files.onDidCreate((model) => this.onDidCreateTextFileModel(model)));
    if (this.model) {
      this.registerModelListeners(this.model);
    }
  }
  onDidCreateTextFileModel(model) {
    if (isEqual(model.resource, this.resource)) {
      this.model = model;
      this.registerModelListeners(model);
    }
  }
  registerModelListeners(model) {
    this.modelListeners.clear();
    this.modelListeners.add(model.onDidChangeDirty(() => this._onDidChangeDirty.fire()));
    this.modelListeners.add(model.onDidChangeReadonly(() => this._onDidChangeCapabilities.fire()));
    this.modelListeners.add(model.onDidSaveError(() => this._onDidChangeDirty.fire()));
    this.modelListeners.add(Event.once(model.onWillDispose)(() => {
      this.modelListeners.clear();
      this.model = void 0;
    }));
  }
  getName() {
    return this.preferredName || super.getName();
  }
  setPreferredName(name) {
    if (!this.allowLabelOverride()) {
      return;
    }
    if (this.preferredName !== name) {
      this.preferredName = name;
      this._onDidChangeLabel.fire();
    }
  }
  allowLabelOverride() {
    return this.resource.scheme !== this.pathService.defaultUriScheme && this.resource.scheme !== Schemas.vscodeUserData && this.resource.scheme !== Schemas.file && this.resource.scheme !== Schemas.vscodeRemote;
  }
  getPreferredName() {
    return this.preferredName;
  }
  isReadonly() {
    return this.model ? this.model.isReadonly() : this.filesConfigurationService.isReadonly(this.resource);
  }
  getDescription(verbosity) {
    return this.preferredDescription || super.getDescription(verbosity);
  }
  setPreferredDescription(description) {
    if (!this.allowLabelOverride()) {
      return;
    }
    if (this.preferredDescription !== description) {
      this.preferredDescription = description;
      this._onDidChangeLabel.fire();
    }
  }
  getPreferredDescription() {
    return this.preferredDescription;
  }
  getEncoding() {
    if (this.model) {
      return this.model.getEncoding();
    }
    return this.preferredEncoding;
  }
  getPreferredEncoding() {
    return this.preferredEncoding;
  }
  async setEncoding(encoding, mode) {
    var _a2;
    this.setPreferredEncoding(encoding);
    return (_a2 = this.model) == null ? void 0 : _a2.setEncoding(encoding, mode);
  }
  setPreferredEncoding(encoding) {
    this.preferredEncoding = encoding;
    this.setForceOpenAsText();
  }
  getLanguageId() {
    if (this.model) {
      return this.model.getLanguageId();
    }
    return this.preferredLanguageId;
  }
  getPreferredLanguageId() {
    return this.preferredLanguageId;
  }
  setLanguageId(languageId, source) {
    var _a2;
    this.setPreferredLanguageId(languageId);
    (_a2 = this.model) == null ? void 0 : _a2.setLanguageId(languageId, source);
  }
  setPreferredLanguageId(languageId) {
    this.preferredLanguageId = languageId;
    this.setForceOpenAsText();
  }
  setPreferredContents(contents) {
    this.preferredContents = contents;
    this.setForceOpenAsText();
  }
  setForceOpenAsText() {
    this.forceOpenAs = 1;
  }
  setForceOpenAsBinary() {
    this.forceOpenAs = 2;
  }
  isDirty() {
    var _a2;
    return !!((_a2 = this.model) == null ? void 0 : _a2.isDirty());
  }
  isSaving() {
    var _a2, _b2, _c2;
    if (((_a2 = this.model) == null ? void 0 : _a2.hasState(0)) || ((_b2 = this.model) == null ? void 0 : _b2.hasState(3)) || ((_c2 = this.model) == null ? void 0 : _c2.hasState(5))) {
      return false;
    }
    if (this.filesConfigurationService.getAutoSaveMode() === 1) {
      return true;
    }
    return super.isSaving();
  }
  prefersEditorPane(editorPanes) {
    if (this.forceOpenAs === 2) {
      return editorPanes.find((editorPane) => editorPane.typeId === BINARY_FILE_EDITOR_ID);
    }
    return editorPanes.find((editorPane) => editorPane.typeId === TEXT_FILE_EDITOR_ID);
  }
  resolve(options) {
    if (this.forceOpenAs === 2) {
      return this.doResolveAsBinary();
    }
    return this.doResolveAsText(options);
  }
  async doResolveAsText(options) {
    try {
      const preferredContents = this.preferredContents;
      this.preferredContents = void 0;
      await this.textFileService.files.resolve(this.resource, {
        languageId: this.preferredLanguageId,
        encoding: this.preferredEncoding,
        contents: typeof preferredContents === "string" ? createTextBufferFactory(preferredContents) : void 0,
        reload: { async: true },
        allowBinary: this.forceOpenAs === 1,
        reason: 1,
        limits: this.ensureLimits(options)
      });
      if (!this.cachedTextFileModelReference) {
        this.cachedTextFileModelReference = await this.textModelResolverService.createModelReference(this.resource);
      }
      const model = this.cachedTextFileModelReference.object;
      if (this.isDisposed()) {
        this.disposeModelReference();
      }
      return model;
    } catch (error) {
      if (error.textFileOperationResult === 0) {
        return this.doResolveAsBinary();
      }
      throw error;
    }
  }
  ensureLimits(options) {
    if (options == null ? void 0 : options.limits) {
      return options.limits;
    }
    const defaultSizeLimit = getLargeFileConfirmationLimit(this.resource);
    let configuredSizeLimit = void 0;
    const configuredSizeLimitMb = this.textResourceConfigurationService.inspect(this.resource, null, "workbench.editorLargeFileConfirmation");
    if (isConfigured(configuredSizeLimitMb)) {
      configuredSizeLimit = configuredSizeLimitMb.value * ByteSize.MB;
    }
    return {
      size: configuredSizeLimit ?? defaultSizeLimit
    };
  }
  async doResolveAsBinary() {
    const model = this.instantiationService.createInstance(BinaryEditorModel, this.preferredResource, this.getName());
    await model.resolve();
    return model;
  }
  isResolved() {
    return !!this.model;
  }
  async rename(group, target) {
    return {
      editor: {
        resource: target,
        encoding: this.getEncoding(),
        options: {
          viewState: findViewStateForEditor(this, group, this.editorService)
        }
      }
    };
  }
  toUntyped(options) {
    const untypedInput = {
      resource: this.preferredResource,
      forceFile: true,
      options: {
        override: this.editorId
      }
    };
    if (typeof (options == null ? void 0 : options.preserveViewState) === "number") {
      untypedInput.encoding = this.getEncoding();
      untypedInput.languageId = this.getLanguageId();
      untypedInput.contents = (() => {
        const model = this.textFileService.files.get(this.resource);
        if (model == null ? void 0 : model.isDirty()) {
          return model.textEditorModel.getValue();
        }
        return void 0;
      })();
      untypedInput.options = {
        ...untypedInput.options,
        viewState: findViewStateForEditor(this, options.preserveViewState, this.editorService)
      };
    }
    return untypedInput;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (otherInput instanceof FileEditorInput2) {
      return isEqual(otherInput.resource, this.resource);
    }
    if (isResourceEditorInput(otherInput)) {
      return super.matches(otherInput);
    }
    return false;
  }
  dispose() {
    this.model = void 0;
    this.disposeModelReference();
    super.dispose();
  }
  disposeModelReference() {
    dispose(this.cachedTextFileModelReference);
    this.cachedTextFileModelReference = void 0;
  }
};
FileEditorInput = __decorate([
  __param(7, IInstantiationService),
  __param(8, ITextFileService),
  __param(9, ITextModelService),
  __param(10, ILabelService),
  __param(11, IFileService),
  __param(12, IFilesConfigurationService),
  __param(13, IEditorService),
  __param(14, IPathService),
  __param(15, ITextResourceConfigurationService)
], FileEditorInput);
const CONFLICT_RESOLUTION_CONTEXT = "saveConflictResolutionContext";
const CONFLICT_RESOLUTION_SCHEME = "conflictResolution";
const LEARN_MORE_DIRTY_WRITE_IGNORE_KEY = "learnMoreDirtyWriteError";
const conflictEditorHelp = localize(
  "userGuide",
  "Use the actions in the editor tool bar to either undo your changes or overwrite the content of the file with your changes."
);
let TextFileSaveErrorHandler = class TextFileSaveErrorHandler2 extends Disposable {
  constructor(notificationService, textFileService, contextKeyService, editorService, textModelService, instantiationService, storageService) {
    super();
    this.notificationService = notificationService;
    this.textFileService = textFileService;
    this.contextKeyService = contextKeyService;
    this.editorService = editorService;
    this.instantiationService = instantiationService;
    this.storageService = storageService;
    this.messages = new ResourceMap();
    this.conflictResolutionContext = new RawContextKey(CONFLICT_RESOLUTION_CONTEXT, false, true).bindTo(this.contextKeyService);
    this.activeConflictResolutionResource = void 0;
    const provider = this._register(instantiationService.createInstance(TextFileContentProvider));
    this._register(textModelService.registerTextModelContentProvider(CONFLICT_RESOLUTION_SCHEME, provider));
    this.textFileService.files.saveErrorHandler = this;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.textFileService.files.onDidSave((e) => this.onFileSavedOrReverted(e.model.resource)));
    this._register(this.textFileService.files.onDidRevert((model) => this.onFileSavedOrReverted(model.resource)));
    this._register(this.editorService.onDidActiveEditorChange(() => this.onActiveEditorChanged()));
  }
  onActiveEditorChanged() {
    let isActiveEditorSaveConflictResolution = false;
    let activeConflictResolutionResource;
    const activeInput = this.editorService.activeEditor;
    if (activeInput instanceof DiffEditorInput) {
      const resource = activeInput.original.resource;
      if ((resource == null ? void 0 : resource.scheme) === CONFLICT_RESOLUTION_SCHEME) {
        isActiveEditorSaveConflictResolution = true;
        activeConflictResolutionResource = activeInput.modified.resource;
      }
    }
    this.conflictResolutionContext.set(isActiveEditorSaveConflictResolution);
    this.activeConflictResolutionResource = activeConflictResolutionResource;
  }
  onFileSavedOrReverted(resource) {
    const messageHandle = this.messages.get(resource);
    if (messageHandle) {
      messageHandle.close();
      this.messages.delete(resource);
    }
  }
  onSaveError(error, model) {
    var _a2;
    const fileOperationError = error;
    const resource = model.resource;
    let message;
    const primaryActions = [];
    const secondaryActions = [];
    if (fileOperationError.fileOperationResult === 3) {
      if (this.activeConflictResolutionResource && isEqual(this.activeConflictResolutionResource, model.resource)) {
        if (this.storageService.getBoolean(LEARN_MORE_DIRTY_WRITE_IGNORE_KEY, -1)) {
          return;
        }
        message = conflictEditorHelp;
        primaryActions.push(this.instantiationService.createInstance(ResolveConflictLearnMoreAction));
        secondaryActions.push(this.instantiationService.createInstance(DoNotShowResolveConflictLearnMoreAction));
      } else {
        message = localize(
          "staleSaveError",
          "Failed to save '{0}': The content of the file is newer. Please compare your version with the file contents or overwrite the content of the file with your changes.",
          basename(resource)
        );
        primaryActions.push(this.instantiationService.createInstance(ResolveSaveConflictAction, model));
        primaryActions.push(this.instantiationService.createInstance(SaveModelIgnoreModifiedSinceAction, model));
        secondaryActions.push(this.instantiationService.createInstance(ConfigureSaveConflictAction));
      }
    } else {
      const isWriteLocked = fileOperationError.fileOperationResult === 5;
      const triedToUnlock = isWriteLocked && ((_a2 = fileOperationError.options) == null ? void 0 : _a2.unlock);
      const isPermissionDenied = fileOperationError.fileOperationResult === 6;
      const canSaveElevated = resource.scheme === Schemas.file;
      if (canSaveElevated && (isPermissionDenied || triedToUnlock)) {
        primaryActions.push(this.instantiationService.createInstance(SaveModelElevatedAction, model, !!triedToUnlock));
      } else if (isWriteLocked) {
        primaryActions.push(this.instantiationService.createInstance(UnlockModelAction, model));
      } else {
        primaryActions.push(this.instantiationService.createInstance(RetrySaveModelAction, model));
      }
      primaryActions.push(this.instantiationService.createInstance(SaveModelAsAction, model));
      primaryActions.push(this.instantiationService.createInstance(DiscardModelAction, model));
      if (isWriteLocked) {
        if (triedToUnlock && canSaveElevated) {
          message = isWindows ? localize(
            "readonlySaveErrorAdmin",
            "Failed to save '{0}': File is read-only. Select 'Overwrite as Admin' to retry as administrator.",
            basename(resource)
          ) : localize(
            "readonlySaveErrorSudo",
            "Failed to save '{0}': File is read-only. Select 'Overwrite as Sudo' to retry as superuser.",
            basename(resource)
          );
        } else {
          message = localize(
            "readonlySaveError",
            "Failed to save '{0}': File is read-only. Select 'Overwrite' to attempt to make it writeable.",
            basename(resource)
          );
        }
      } else if (canSaveElevated && isPermissionDenied) {
        message = isWindows ? localize(
          "permissionDeniedSaveError",
          "Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.",
          basename(resource)
        ) : localize(
          "permissionDeniedSaveErrorSudo",
          "Failed to save '{0}': Insufficient permissions. Select 'Retry as Sudo' to retry as superuser.",
          basename(resource)
        );
      } else {
        message = localize(
          { key: "genericSaveError", comment: ["{0} is the resource that failed to save and {1} the error message"] },
          "Failed to save '{0}': {1}",
          basename(resource),
          toErrorMessage(error, false)
        );
      }
    }
    const actions = { primary: primaryActions, secondary: secondaryActions };
    const handle = this.notificationService.notify({
      id: `${hash(model.resource.toString())}`,
      severity: Severity.Error,
      message,
      actions
    });
    Event.once(handle.onDidClose)(() => {
      dispose(primaryActions);
      dispose(secondaryActions);
    });
    this.messages.set(model.resource, handle);
  }
  dispose() {
    super.dispose();
    this.messages.clear();
  }
};
TextFileSaveErrorHandler = __decorate([
  __param(0, INotificationService),
  __param(1, ITextFileService),
  __param(2, IContextKeyService),
  __param(3, IEditorService),
  __param(4, ITextModelService),
  __param(5, IInstantiationService),
  __param(6, IStorageService)
], TextFileSaveErrorHandler);
let ResolveConflictLearnMoreAction = class ResolveConflictLearnMoreAction2 extends Action {
  constructor(openerService) {
    super("workbench.files.action.resolveConflictLearnMore", localize("learnMore", "Learn More"));
    this.openerService = openerService;
  }
  async run() {
    await this.openerService.open(URI.parse("https://go.microsoft.com/fwlink/?linkid=868264"));
  }
};
ResolveConflictLearnMoreAction = __decorate([
  __param(0, IOpenerService)
], ResolveConflictLearnMoreAction);
let DoNotShowResolveConflictLearnMoreAction = class DoNotShowResolveConflictLearnMoreAction2 extends Action {
  constructor(storageService) {
    super("workbench.files.action.resolveConflictLearnMoreDoNotShowAgain", localize("dontShowAgain", "Don't Show Again"));
    this.storageService = storageService;
  }
  async run(notification) {
    this.storageService.store(LEARN_MORE_DIRTY_WRITE_IGNORE_KEY, true, -1, 0);
    notification.dispose();
  }
};
DoNotShowResolveConflictLearnMoreAction = __decorate([
  __param(0, IStorageService)
], DoNotShowResolveConflictLearnMoreAction);
let ResolveSaveConflictAction = class ResolveSaveConflictAction2 extends Action {
  constructor(model, editorService, notificationService, instantiationService, productService) {
    super("workbench.files.action.resolveConflict", localize("compareChanges", "Compare"));
    this.model = model;
    this.editorService = editorService;
    this.notificationService = notificationService;
    this.instantiationService = instantiationService;
    this.productService = productService;
  }
  async run() {
    if (!this.model.isDisposed()) {
      const resource = this.model.resource;
      const name = basename(resource);
      const editorLabel = localize(
        "saveConflictDiffLabel",
        "{0} (in file) ↔ {1} (in {2}) - Resolve save conflict",
        name,
        name,
        this.productService.nameLong
      );
      await TextFileContentProvider.open(resource, CONFLICT_RESOLUTION_SCHEME, editorLabel, this.editorService, { pinned: true });
      const actions = { primary: [this.instantiationService.createInstance(ResolveConflictLearnMoreAction)] };
      const handle = this.notificationService.notify({
        id: `${hash(resource.toString())}`,
        severity: Severity.Info,
        message: conflictEditorHelp,
        actions,
        neverShowAgain: { id: LEARN_MORE_DIRTY_WRITE_IGNORE_KEY, isSecondary: true }
      });
      Event.once(handle.onDidClose)(() => dispose(actions.primary));
    }
  }
};
ResolveSaveConflictAction = __decorate([
  __param(1, IEditorService),
  __param(2, INotificationService),
  __param(3, IInstantiationService),
  __param(4, IProductService)
], ResolveSaveConflictAction);
class SaveModelElevatedAction extends Action {
  constructor(model, triedToUnlock) {
    super("workbench.files.action.saveModelElevated", triedToUnlock ? isWindows ? localize("overwriteElevated", "Overwrite as Admin...") : localize("overwriteElevatedSudo", "Overwrite as Sudo...") : isWindows ? localize("saveElevated", "Retry as Admin...") : localize("saveElevatedSudo", "Retry as Sudo..."));
    this.model = model;
    this.triedToUnlock = triedToUnlock;
  }
  async run() {
    if (!this.model.isDisposed()) {
      await this.model.save({
        writeElevated: true,
        writeUnlock: this.triedToUnlock,
        reason: 1
      });
    }
  }
}
class RetrySaveModelAction extends Action {
  constructor(model) {
    super("workbench.files.action.saveModel", localize("retry", "Retry"));
    this.model = model;
  }
  async run() {
    if (!this.model.isDisposed()) {
      await this.model.save({ reason: 1 });
    }
  }
}
class DiscardModelAction extends Action {
  constructor(model) {
    super("workbench.files.action.discardModel", localize("discard", "Discard"));
    this.model = model;
  }
  async run() {
    if (!this.model.isDisposed()) {
      await this.model.revert();
    }
  }
}
let SaveModelAsAction = class SaveModelAsAction2 extends Action {
  constructor(model, editorService) {
    super("workbench.files.action.saveModelAs", SAVE_FILE_AS_LABEL);
    this.model = model;
    this.editorService = editorService;
  }
  async run() {
    if (!this.model.isDisposed()) {
      const editor = this.findEditor();
      if (editor) {
        await this.editorService.save(editor, { saveAs: true, reason: 1 });
      }
    }
  }
  findEditor() {
    let preferredMatchingEditor;
    const editors = this.editorService.findEditors(this.model.resource, { supportSideBySide: SideBySideEditor.PRIMARY });
    for (const identifier of editors) {
      if (identifier.editor instanceof FileEditorInput) {
        preferredMatchingEditor = identifier;
        break;
      } else if (!preferredMatchingEditor) {
        preferredMatchingEditor = identifier;
      }
    }
    return preferredMatchingEditor;
  }
};
SaveModelAsAction = __decorate([
  __param(1, IEditorService)
], SaveModelAsAction);
class UnlockModelAction extends Action {
  constructor(model) {
    super("workbench.files.action.unlock", localize("overwrite", "Overwrite"));
    this.model = model;
  }
  async run() {
    if (!this.model.isDisposed()) {
      await this.model.save({ writeUnlock: true, reason: 1 });
    }
  }
}
class SaveModelIgnoreModifiedSinceAction extends Action {
  constructor(model) {
    super("workbench.files.action.saveIgnoreModifiedSince", localize("overwrite", "Overwrite"));
    this.model = model;
  }
  async run() {
    if (!this.model.isDisposed()) {
      await this.model.save({ ignoreModifiedSince: true, reason: 1 });
    }
  }
}
let ConfigureSaveConflictAction = class ConfigureSaveConflictAction2 extends Action {
  constructor(preferencesService) {
    super("workbench.files.action.configureSaveConflict", localize("configure", "Configure"));
    this.preferencesService = preferencesService;
  }
  async run() {
    this.preferencesService.openSettings({ query: "files.saveConflictResolution" });
  }
};
ConfigureSaveConflictAction = __decorate([
  __param(0, IPreferencesService)
], ConfigureSaveConflictAction);
const explorerCommandsWeightBonus = 10;
const RENAME_ID = "renameFile";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: RENAME_ID,
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerRootContext.toNegated(), ExplorerResourceNotReadonlyContext),
  primary: 60,
  mac: {
    primary: 3
  },
  handler: renameHandler
});
const MOVE_FILE_TO_TRASH_ID = "moveFileToTrash";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: MOVE_FILE_TO_TRASH_ID,
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(
    FilesExplorerFocusCondition,
    ExplorerResourceNotReadonlyContext,
    ExplorerResourceMoveableToTrash
  ),
  primary: 20,
  mac: {
    primary: 2048 | 1,
    secondary: [20]
  },
  handler: moveFileToTrashHandler
});
const DELETE_FILE_ID = "deleteFile";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: DELETE_FILE_ID,
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerResourceNotReadonlyContext),
  primary: 1024 | 20,
  mac: {
    primary: 2048 | 512 | 1
  },
  handler: deleteFileHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: DELETE_FILE_ID,
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(
    FilesExplorerFocusCondition,
    ExplorerResourceNotReadonlyContext,
    ExplorerResourceMoveableToTrash.toNegated()
  ),
  primary: 20,
  mac: {
    primary: 2048 | 1
  },
  handler: deleteFileHandler
});
const CUT_FILE_ID = "filesExplorer.cut";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: CUT_FILE_ID,
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerRootContext.toNegated(), ExplorerResourceNotReadonlyContext),
  primary: 2048 | 54,
  handler: cutFileHandler
});
const COPY_FILE_ID = "filesExplorer.copy";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: COPY_FILE_ID,
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerRootContext.toNegated()),
  primary: 2048 | 33,
  handler: copyFileHandler
});
const PASTE_FILE_ID = "filesExplorer.paste";
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: PASTE_FILE_ID,
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerResourceNotReadonlyContext),
  primary: 2048 | 52,
  handler: pasteFileHandler
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "filesExplorer.cancelCut",
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerResourceCut),
  primary: 9,
  handler: async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    await explorerService.setToCopy([], true);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "filesExplorer.openFilePreserveFocus",
  weight: 200 + explorerCommandsWeightBonus,
  when: ContextKeyExpr.and(FilesExplorerFocusCondition, ExplorerFolderContext.toNegated()),
  primary: 10,
  handler: openFilePreserveFocusHandler
});
const copyPathCommand = {
  id: COPY_PATH_COMMAND_ID,
  title: localize("copyPath", "Copy Path")
};
const copyRelativePathCommand = {
  id: COPY_RELATIVE_PATH_COMMAND_ID,
  title: localize("copyRelativePath", "Copy Relative Path")
};
appendEditorTitleContextMenuItem(COPY_PATH_COMMAND_ID, copyPathCommand.title, ResourceContextKey.IsFileSystemResource, "1_cutcopypaste");
appendEditorTitleContextMenuItem(COPY_RELATIVE_PATH_COMMAND_ID, copyRelativePathCommand.title, ResourceContextKey.IsFileSystemResource, "1_cutcopypaste");
appendEditorTitleContextMenuItem(REVEAL_IN_EXPLORER_COMMAND_ID, localize("revealInSideBar", "Reveal in Explorer View"), ResourceContextKey.IsFileSystemResource, "2_files", 1);
function appendEditorTitleContextMenuItem(id, title, when, group, order) {
  MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, {
    command: { id, title },
    when,
    group,
    order
  });
}
appendSaveConflictEditorTitleAction("workbench.files.action.acceptLocalChanges", localize("acceptLocalChanges", "Use your changes and overwrite file contents"), Codicon.check, -10);
appendSaveConflictEditorTitleAction("workbench.files.action.revertLocalChanges", localize("revertLocalChanges", "Discard your changes and revert to file contents"), Codicon.discard, -9);
function appendSaveConflictEditorTitleAction(id, title, icon, order, command) {
  MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
    command: { id, title, icon },
    when: ContextKeyExpr.equals(CONFLICT_RESOLUTION_CONTEXT, true),
    group: "navigation",
    order
  });
}
function appendToCommandPalette(id, title, category, when) {
  MenuRegistry.appendMenuItem(MenuId.CommandPalette, {
    command: {
      id,
      title,
      category
    },
    when
  });
}
appendToCommandPalette(COPY_PATH_COMMAND_ID, { value: localize("copyPathOfActive", "Copy Path of Active File"), original: "Copy Path of Active File" }, Categories.File);
appendToCommandPalette(COPY_RELATIVE_PATH_COMMAND_ID, { value: localize("copyRelativePathOfActive", "Copy Relative Path of Active File"), original: "Copy Relative Path of Active File" }, Categories.File);
appendToCommandPalette(SAVE_FILE_COMMAND_ID, { value: SAVE_FILE_LABEL, original: "Save" }, Categories.File);
appendToCommandPalette(SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID, { value: SAVE_FILE_WITHOUT_FORMATTING_LABEL, original: "Save without Formatting" }, Categories.File);
appendToCommandPalette(SAVE_ALL_IN_GROUP_COMMAND_ID, { value: localize("saveAllInGroup", "Save All in Group"), original: "Save All in Group" }, Categories.File);
appendToCommandPalette(SAVE_FILES_COMMAND_ID, { value: localize("saveFiles", "Save All Files"), original: "Save All Files" }, Categories.File);
appendToCommandPalette(REVERT_FILE_COMMAND_ID, { value: localize("revert", "Revert File"), original: "Revert File" }, Categories.File);
appendToCommandPalette(COMPARE_WITH_SAVED_COMMAND_ID, { value: localize("compareActiveWithSaved", "Compare Active File with Saved"), original: "Compare Active File with Saved" }, Categories.File);
appendToCommandPalette(SAVE_FILE_AS_COMMAND_ID, { value: SAVE_FILE_AS_LABEL, original: "Save As..." }, Categories.File);
appendToCommandPalette(NEW_FILE_COMMAND_ID$1, { value: NEW_FILE_LABEL, original: "New File" }, Categories.File, WorkspaceFolderCountContext.notEqualsTo("0"));
appendToCommandPalette(NEW_FOLDER_COMMAND_ID, { value: NEW_FOLDER_LABEL, original: "New Folder" }, Categories.File, WorkspaceFolderCountContext.notEqualsTo("0"));
appendToCommandPalette(NEW_UNTITLED_FILE_COMMAND_ID, { value: NEW_UNTITLED_FILE_LABEL, original: "New Untitled Text File" }, Categories.File);
const isFileOrUntitledResourceContextKey = ContextKeyExpr.or(ResourceContextKey.IsFileSystemResource, ResourceContextKey.Scheme.isEqualTo(Schemas.untitled));
const openToSideCommand = {
  id: OPEN_TO_SIDE_COMMAND_ID,
  title: localize("openToSide", "Open to the Side")
};
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "navigation",
  order: 10,
  command: openToSideCommand,
  when: isFileOrUntitledResourceContextKey
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "1_open",
  order: 10,
  command: {
    id: REOPEN_WITH_COMMAND_ID,
    title: localize("reopenWith", "Reopen Editor With...")
  },
  when: ActiveEditorAvailableEditorIdsContext
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "1_cutcopypaste",
  order: 10,
  command: copyPathCommand,
  when: ResourceContextKey.IsFileSystemResource
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "1_cutcopypaste",
  order: 20,
  command: copyRelativePathCommand,
  when: ResourceContextKey.IsFileSystemResource
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "2_save",
  order: 10,
  command: {
    id: SAVE_FILE_COMMAND_ID,
    title: SAVE_FILE_LABEL,
    precondition: OpenEditorsDirtyEditorContext
  },
  when: ContextKeyExpr.or(ResourceContextKey.Scheme.isEqualTo(Schemas.untitled), ContextKeyExpr.and(OpenEditorsGroupContext.toNegated(), OpenEditorsReadonlyEditorContext.toNegated(), AutoSaveAfterShortDelayContext.toNegated()))
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "2_save",
  order: 20,
  command: {
    id: REVERT_FILE_COMMAND_ID,
    title: localize("revert", "Revert File"),
    precondition: OpenEditorsDirtyEditorContext
  },
  when: ContextKeyExpr.and(OpenEditorsGroupContext.toNegated(), OpenEditorsReadonlyEditorContext.toNegated(), ResourceContextKey.Scheme.notEqualsTo(Schemas.untitled), AutoSaveAfterShortDelayContext.toNegated())
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "2_save",
  order: 30,
  command: {
    id: SAVE_ALL_IN_GROUP_COMMAND_ID,
    title: localize("saveAll", "Save All"),
    precondition: DirtyWorkingCopiesContext
  },
  when: OpenEditorsGroupContext
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "3_compare",
  order: 10,
  command: {
    id: COMPARE_WITH_SAVED_COMMAND_ID,
    title: localize("compareWithSaved", "Compare with Saved"),
    precondition: OpenEditorsDirtyEditorContext
  },
  when: ContextKeyExpr.and(ResourceContextKey.IsFileSystemResource, AutoSaveAfterShortDelayContext.toNegated(), WorkbenchListDoubleSelection.toNegated())
});
const compareResourceCommand = {
  id: COMPARE_RESOURCE_COMMAND_ID,
  title: localize("compareWithSelected", "Compare with Selected")
};
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "3_compare",
  order: 20,
  command: compareResourceCommand,
  when: ContextKeyExpr.and(
    ResourceContextKey.HasResource,
    ResourceSelectedForCompareContext,
    isFileOrUntitledResourceContextKey,
    WorkbenchListDoubleSelection.toNegated()
  )
});
const selectForCompareCommand = {
  id: SELECT_FOR_COMPARE_COMMAND_ID,
  title: localize("compareSource", "Select for Compare")
};
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "3_compare",
  order: 30,
  command: selectForCompareCommand,
  when: ContextKeyExpr.and(
    ResourceContextKey.HasResource,
    isFileOrUntitledResourceContextKey,
    WorkbenchListDoubleSelection.toNegated()
  )
});
const compareSelectedCommand = {
  id: COMPARE_SELECTED_COMMAND_ID,
  title: localize("compareSelected", "Compare Selected")
};
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "3_compare",
  order: 30,
  command: compareSelectedCommand,
  when: ContextKeyExpr.and(
    ResourceContextKey.HasResource,
    WorkbenchListDoubleSelection,
    isFileOrUntitledResourceContextKey
  )
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "4_close",
  order: 10,
  command: {
    id: CLOSE_EDITOR_COMMAND_ID,
    title: localize("close", "Close")
  },
  when: OpenEditorsGroupContext.toNegated()
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "4_close",
  order: 20,
  command: {
    id: CLOSE_OTHER_EDITORS_IN_GROUP_COMMAND_ID,
    title: localize("closeOthers", "Close Others")
  },
  when: OpenEditorsGroupContext.toNegated()
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "4_close",
  order: 30,
  command: {
    id: CLOSE_SAVED_EDITORS_COMMAND_ID,
    title: localize("closeSaved", "Close Saved")
  }
});
MenuRegistry.appendMenuItem(MenuId.OpenEditorsContext, {
  group: "4_close",
  order: 40,
  command: {
    id: CLOSE_EDITORS_IN_GROUP_COMMAND_ID,
    title: localize("closeAll", "Close All")
  }
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "navigation",
  order: 4,
  command: {
    id: NEW_FILE_COMMAND_ID$1,
    title: NEW_FILE_LABEL,
    precondition: ExplorerResourceNotReadonlyContext
  },
  when: ExplorerFolderContext
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "navigation",
  order: 6,
  command: {
    id: NEW_FOLDER_COMMAND_ID,
    title: NEW_FOLDER_LABEL,
    precondition: ExplorerResourceNotReadonlyContext
  },
  when: ExplorerFolderContext
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "navigation",
  order: 10,
  command: openToSideCommand,
  when: ContextKeyExpr.and(ExplorerFolderContext.toNegated(), ResourceContextKey.HasResource)
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "navigation",
  order: 20,
  command: {
    id: OPEN_WITH_EXPLORER_COMMAND_ID,
    title: localize("explorerOpenWith", "Open With...")
  },
  when: ContextKeyExpr.and(ExplorerFolderContext.toNegated(), ExplorerResourceAvailableEditorIdsContext)
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "3_compare",
  order: 20,
  command: compareResourceCommand,
  when: ContextKeyExpr.and(ExplorerFolderContext.toNegated(), ResourceContextKey.HasResource, ResourceSelectedForCompareContext, WorkbenchListDoubleSelection.toNegated())
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "3_compare",
  order: 30,
  command: selectForCompareCommand,
  when: ContextKeyExpr.and(ExplorerFolderContext.toNegated(), ResourceContextKey.HasResource, WorkbenchListDoubleSelection.toNegated())
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "3_compare",
  order: 30,
  command: compareSelectedCommand,
  when: ContextKeyExpr.and(ExplorerFolderContext.toNegated(), ResourceContextKey.HasResource, WorkbenchListDoubleSelection)
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "5_cutcopypaste",
  order: 8,
  command: {
    id: CUT_FILE_ID,
    title: localize("cut", "Cut")
  },
  when: ContextKeyExpr.and(ExplorerRootContext.toNegated(), ExplorerResourceNotReadonlyContext)
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "5_cutcopypaste",
  order: 10,
  command: {
    id: COPY_FILE_ID,
    title: COPY_FILE_LABEL
  },
  when: ExplorerRootContext.toNegated()
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "5_cutcopypaste",
  order: 20,
  command: {
    id: PASTE_FILE_ID,
    title: PASTE_FILE_LABEL,
    precondition: ContextKeyExpr.and(ExplorerResourceNotReadonlyContext, FileCopiedContext)
  },
  when: ExplorerFolderContext
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "5b_importexport",
  order: 10,
  command: {
    id: DOWNLOAD_COMMAND_ID,
    title: DOWNLOAD_LABEL
  },
  when: ContextKeyExpr.or(ContextKeyExpr.and(IsWebContext.toNegated(), ResourceContextKey.Scheme.notEqualsTo(Schemas.file)), ContextKeyExpr.and(IsWebContext, ExplorerFolderContext.toNegated(), ExplorerRootContext.toNegated()), ContextKeyExpr.and(IsWebContext, HasWebFileSystemAccess))
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "5b_importexport",
  order: 20,
  command: {
    id: UPLOAD_COMMAND_ID,
    title: UPLOAD_LABEL
  },
  when: ContextKeyExpr.and(
    IsWebContext,
    ExplorerFolderContext,
    ExplorerResourceNotReadonlyContext
  )
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "6_copypath",
  order: 10,
  command: copyPathCommand,
  when: ResourceContextKey.IsFileSystemResource
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "6_copypath",
  order: 20,
  command: copyRelativePathCommand,
  when: ResourceContextKey.IsFileSystemResource
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "2_workspace",
  order: 10,
  command: {
    id: ADD_ROOT_FOLDER_COMMAND_ID,
    title: ADD_ROOT_FOLDER_LABEL
  },
  when: ContextKeyExpr.and(ExplorerRootContext, ContextKeyExpr.or(EnterMultiRootWorkspaceSupportContext, WorkbenchStateContext.isEqualTo("workspace")))
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "2_workspace",
  order: 30,
  command: {
    id: REMOVE_ROOT_FOLDER_COMMAND_ID,
    title: REMOVE_ROOT_FOLDER_LABEL
  },
  when: ContextKeyExpr.and(ExplorerRootContext, ExplorerFolderContext, ContextKeyExpr.and(WorkspaceFolderCountContext.notEqualsTo("0"), ContextKeyExpr.or(EnterMultiRootWorkspaceSupportContext, WorkbenchStateContext.isEqualTo("workspace"))))
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "7_modification",
  order: 10,
  command: {
    id: RENAME_ID,
    title: TRIGGER_RENAME_LABEL,
    precondition: ExplorerResourceNotReadonlyContext
  },
  when: ExplorerRootContext.toNegated()
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "7_modification",
  order: 20,
  command: {
    id: MOVE_FILE_TO_TRASH_ID,
    title: MOVE_FILE_TO_TRASH_LABEL,
    precondition: ExplorerResourceNotReadonlyContext
  },
  alt: {
    id: DELETE_FILE_ID,
    title: localize("deleteFile", "Delete Permanently"),
    precondition: ExplorerResourceNotReadonlyContext
  },
  when: ContextKeyExpr.and(ExplorerRootContext.toNegated(), ExplorerResourceMoveableToTrash)
});
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, {
  group: "7_modification",
  order: 20,
  command: {
    id: DELETE_FILE_ID,
    title: localize("deleteFile", "Delete Permanently"),
    precondition: ExplorerResourceNotReadonlyContext
  },
  when: ContextKeyExpr.and(ExplorerRootContext.toNegated(), ExplorerResourceMoveableToTrash.toNegated())
});
for (const menuId of [MenuId.EmptyEditorGroupContext, MenuId.EditorTabsBarContext]) {
  MenuRegistry.appendMenuItem(menuId, { command: { id: NEW_UNTITLED_FILE_COMMAND_ID, title: localize("newFile", "New Text File") }, group: "1_file", order: 10 });
  MenuRegistry.appendMenuItem(menuId, { command: { id: "workbench.action.quickOpen", title: localize("openFile", "Open File...") }, group: "1_file", order: 20 });
}
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "3_global_nav",
  command: {
    id: "workbench.action.quickOpen",
    title: localize(
      { key: "miGotoFile", comment: ["&& denotes a mnemonic"] },
      "Go to &&File..."
    )
  },
  order: 1
});
var css$8 = ".monaco-workbench .call-hierarchy .message,.monaco-workbench .call-hierarchy .results{display:none}.monaco-workbench .call-hierarchy[data-state=data] .results{display:inherit;height:100%}.monaco-workbench .call-hierarchy[data-state=message] .message{align-items:center;display:flex;height:100%;justify-content:center}.monaco-workbench .call-hierarchy .editor,.monaco-workbench .call-hierarchy .tree{height:100%}.monaco-editor .call-hierarchy .tree{background-color:var(--vscode-peekViewResult-background);color:var(--vscode-peekViewResult-fileForeground)}.monaco-workbench .call-hierarchy .tree .callhierarchy-element{align-items:center;display:flex;flex:1;flex-flow:row nowrap}.monaco-workbench .call-hierarchy .tree .callhierarchy-element .monaco-icon-label{padding-left:4px}.monaco-editor .call-hierarchy .tree .monaco-list:focus .monaco-list-rows>.monaco-list-row.selected:not(.highlighted){background-color:var(--vscode-peekViewResult-selectionBackground);color:var(--vscode-peekViewResult-selectionForeground)!important}.monaco-editor .call-hierarchy .call-decoration{background-color:var(--vscode-peekViewEditor-matchHighlightBackground);border:2px solid var(--vscode-peekViewEditor-matchHighlightBorder);box-sizing:border-box}.monaco-editor .call-hierarchy .editor .monaco-editor .inputarea.ime-input,.monaco-editor .call-hierarchy .editor .monaco-editor .monaco-editor-background{background-color:var(--vscode-peekViewEditor-background)}.monaco-editor .call-hierarchy .editor .monaco-editor .margin{background-color:var(--vscode-peekViewEditorGutter-background)}";
n(css$8, {});
class Call {
  constructor(item, locations, model, parent) {
    this.item = item;
    this.locations = locations;
    this.model = model;
    this.parent = parent;
  }
  static compare(a, b) {
    let res = compare(a.item.uri.toString(), b.item.uri.toString());
    if (res === 0) {
      res = Range.compareRangesUsingStarts(a.item.range, b.item.range);
    }
    return res;
  }
}
let DataSource$1 = class DataSource {
  constructor(getDirection) {
    this.getDirection = getDirection;
  }
  hasChildren() {
    return true;
  }
  async getChildren(element) {
    if (element instanceof CallHierarchyModel) {
      return element.roots.map((root) => new Call(root, void 0, element, void 0));
    }
    const { model, item } = element;
    if (this.getDirection() === "outgoingCalls") {
      return (await model.resolveOutgoingCalls(item, CancellationToken.None)).map((call) => {
        return new Call(call.to, call.fromRanges.map((range2) => ({ range: range2, uri: item.uri })), model, element);
      });
    } else {
      return (await model.resolveIncomingCalls(item, CancellationToken.None)).map((call) => {
        return new Call(call.from, call.fromRanges.map((range2) => ({ range: range2, uri: call.from.uri })), model, element);
      });
    }
  }
};
let Sorter$1 = class Sorter {
  compare(element, otherElement) {
    return Call.compare(element, otherElement);
  }
};
let IdentityProvider$1 = class IdentityProvider {
  constructor(getDirection) {
    this.getDirection = getDirection;
  }
  getId(element) {
    let res = this.getDirection() + JSON.stringify(element.item.uri) + JSON.stringify(element.item.range);
    if (element.parent) {
      res += this.getId(element.parent);
    }
    return res;
  }
};
class CallRenderingTemplate {
  constructor(icon, label) {
    this.icon = icon;
    this.label = label;
  }
}
const _CallRenderer = class _CallRenderer {
  constructor() {
    this.templateId = _CallRenderer.id;
  }
  renderTemplate(container) {
    container.classList.add("callhierarchy-element");
    const icon = document.createElement("div");
    container.appendChild(icon);
    const label = new IconLabel(container, { supportHighlights: true });
    return new CallRenderingTemplate(icon, label);
  }
  renderElement(node, _index, template) {
    var _a2;
    const { element, filterData } = node;
    const deprecated = (_a2 = element.item.tags) == null ? void 0 : _a2.includes(1);
    template.icon.className = "";
    template.icon.classList.add("inline", ...ThemeIcon.asClassNameArray(SymbolKinds.toIcon(element.item.kind)));
    template.label.setLabel(element.item.name, element.item.detail, { labelEscapeNewLines: true, matches: createMatches(filterData), strikethrough: deprecated });
  }
  disposeTemplate(template) {
    template.label.dispose();
  }
};
_CallRenderer.id = "CallRenderer";
let CallRenderer = _CallRenderer;
let VirtualDelegate$1 = class VirtualDelegate {
  getHeight(_element) {
    return 22;
  }
  getTemplateId(_element) {
    return CallRenderer.id;
  }
};
let AccessibilityProvider$1 = class AccessibilityProvider {
  constructor(getDirection) {
    this.getDirection = getDirection;
  }
  getWidgetAriaLabel() {
    return localize("tree.aria", "Call Hierarchy");
  }
  getAriaLabel(element) {
    if (this.getDirection() === "outgoingCalls") {
      return localize("from", "calls from {0}", element.item.name);
    } else {
      return localize("to", "callers of {0}", element.item.name);
    }
  }
};
let LayoutInfo$1 = class LayoutInfo {
  static store(info, storageService) {
    storageService.store("callHierarchyPeekLayout", JSON.stringify(info), 0, 1);
  }
  static retrieve(storageService) {
    const value = storageService.get("callHierarchyPeekLayout", 0, "{}");
    const defaultInfo = { ratio: 0.7, height: 17 };
    try {
      return { ...defaultInfo, ...JSON.parse(value) };
    } catch {
      return defaultInfo;
    }
  }
  constructor(ratio, height) {
    this.ratio = ratio;
    this.height = height;
  }
};
class CallHierarchyTree extends WorkbenchAsyncDataTree {
}
let CallHierarchyTreePeekWidget = (_n = class extends PeekViewWidget {
  constructor(editor, _where, _direction, themeService, _peekViewService, _editorService, _textModelService, _storageService, _menuService, _contextKeyService, _instantiationService) {
    super(editor, { showFrame: true, showArrow: true, isResizeable: true, isAccessible: true }, _instantiationService);
    this._where = _where;
    this._direction = _direction;
    this._peekViewService = _peekViewService;
    this._editorService = _editorService;
    this._textModelService = _textModelService;
    this._storageService = _storageService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._treeViewStates = /* @__PURE__ */ new Map();
    this._previewDisposable = new DisposableStore();
    this.create();
    this._peekViewService.addExclusiveWidget(editor, this);
    this._applyTheme(themeService.getColorTheme());
    this._disposables.add(themeService.onDidColorThemeChange(this._applyTheme, this));
    this._disposables.add(this._previewDisposable);
  }
  dispose() {
    LayoutInfo$1.store(this._layoutInfo, this._storageService);
    this._splitView.dispose();
    this._tree.dispose();
    this._editor.dispose();
    super.dispose();
  }
  get direction() {
    return this._direction;
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  _fillHead(container) {
    super._fillHead(container, true);
    const menu = this._menuService.createMenu(_n.TitleMenu, this._contextKeyService);
    const updateToolbar = () => {
      const actions = [];
      createAndFillInActionBarActions(menu, void 0, actions);
      this._actionbarWidget.clear();
      this._actionbarWidget.push(actions, { label: false, icon: true });
    };
    this._disposables.add(menu);
    this._disposables.add(menu.onDidChange(updateToolbar));
    updateToolbar();
  }
  _fillBody(parent) {
    this._layoutInfo = LayoutInfo$1.retrieve(this._storageService);
    this._dim = new Dimension(0, 0);
    this._parent = parent;
    parent.classList.add("call-hierarchy");
    const message = document.createElement("div");
    message.classList.add("message");
    parent.appendChild(message);
    this._message = message;
    this._message.tabIndex = 0;
    const container = document.createElement("div");
    container.classList.add("results");
    parent.appendChild(container);
    this._splitView = new SplitView(container, { orientation: 1 });
    const editorContainer = document.createElement("div");
    editorContainer.classList.add("editor");
    container.appendChild(editorContainer);
    const editorOptions = {
      scrollBeyondLastLine: false,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false,
        alwaysConsumeMouseWheel: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: {
        enabled: false
      }
    };
    this._editor = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, editorContainer, editorOptions, {}, this.editor);
    const treeContainer = document.createElement("div");
    treeContainer.classList.add("tree");
    container.appendChild(treeContainer);
    const options = {
      sorter: new Sorter$1(),
      accessibilityProvider: new AccessibilityProvider$1(() => this._direction),
      identityProvider: new IdentityProvider$1(() => this._direction),
      expandOnlyOnTwistieClick: true,
      overrideStyles: {
        listBackground: peekViewResultsBackground
      }
    };
    this._tree = this._instantiationService.createInstance(CallHierarchyTree, "CallHierarchyPeek", treeContainer, new VirtualDelegate$1(), [this._instantiationService.createInstance(CallRenderer)], this._instantiationService.createInstance(DataSource$1, () => this._direction), options);
    this._splitView.addView({
      onDidChange: Event.None,
      element: editorContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        if (this._dim.height) {
          this._editor.layout({ height: this._dim.height, width });
        }
      }
    }, Sizing$1.Distribute);
    this._splitView.addView({
      onDidChange: Event.None,
      element: treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        if (this._dim.height) {
          this._tree.layout(this._dim.height, width);
        }
      }
    }, Sizing$1.Distribute);
    this._disposables.add(this._splitView.onDidSashChange(() => {
      if (this._dim.width) {
        this._layoutInfo.ratio = this._splitView.getViewSize(0) / this._dim.width;
      }
    }));
    this._disposables.add(this._tree.onDidChangeFocus(this._updatePreview, this));
    this._disposables.add(this._editor.onMouseDown((e) => {
      const { event, target } = e;
      if (event.detail !== 2) {
        return;
      }
      const [focus] = this._tree.getFocus();
      if (!focus) {
        return;
      }
      this.dispose();
      this._editorService.openEditor({
        resource: focus.item.uri,
        options: { selection: target.range }
      });
    }));
    this._disposables.add(this._tree.onMouseDblClick((e) => {
      if (e.target === TreeMouseEventTarget.Twistie) {
        return;
      }
      if (e.element) {
        this.dispose();
        this._editorService.openEditor({
          resource: e.element.item.uri,
          options: { selection: e.element.item.selectionRange, pinned: true }
        });
      }
    }));
    this._disposables.add(this._tree.onDidChangeSelection((e) => {
      const [element] = e.elements;
      if (element && e.browserEvent instanceof KeyboardEvent) {
        this.dispose();
        this._editorService.openEditor({
          resource: element.item.uri,
          options: { selection: element.item.selectionRange, pinned: true }
        });
      }
    }));
  }
  async _updatePreview() {
    const [element] = this._tree.getFocus();
    if (!element) {
      return;
    }
    this._previewDisposable.clear();
    const options = {
      description: "call-hierarchy-decoration",
      stickiness: 1,
      className: "call-decoration",
      overviewRuler: {
        color: themeColorFromId(peekViewEditorMatchHighlight),
        position: OverviewRulerLane.Center
      }
    };
    let previewUri;
    if (this._direction === "outgoingCalls") {
      previewUri = element.parent ? element.parent.item.uri : element.model.root.uri;
    } else {
      previewUri = element.item.uri;
    }
    const value = await this._textModelService.createModelReference(previewUri);
    this._editor.setModel(value.object.textEditorModel);
    const decorations = [];
    let fullRange;
    let locations = element.locations;
    if (!locations) {
      locations = [{ uri: element.item.uri, range: element.item.selectionRange }];
    }
    for (const loc of locations) {
      if (loc.uri.toString() === previewUri.toString()) {
        decorations.push({ range: loc.range, options });
        fullRange = !fullRange ? loc.range : Range.plusRange(loc.range, fullRange);
      }
    }
    if (fullRange) {
      this._editor.revealRangeInCenter(fullRange, 1);
      const decorationsCollection = this._editor.createDecorationsCollection(decorations);
      this._previewDisposable.add(toDisposable(() => decorationsCollection.clear()));
    }
    this._previewDisposable.add(value);
    const title = this._direction === "outgoingCalls" ? localize("callFrom", "Calls from '{0}'", element.model.root.name) : localize("callsTo", "Callers of '{0}'", element.model.root.name);
    this.setTitle(title);
  }
  showLoading() {
    this._parent.dataset["state"] = "loading";
    this.setTitle(localize("title.loading", "Loading..."));
    this._show();
  }
  showMessage(message) {
    this._parent.dataset["state"] = "message";
    this.setTitle("");
    this.setMetaTitle("");
    this._message.innerText = message;
    this._show();
    this._message.focus();
  }
  async showModel(model) {
    this._show();
    const viewState = this._treeViewStates.get(this._direction);
    await this._tree.setInput(model, viewState);
    const root = this._tree.getNode(model).children[0];
    await this._tree.expand(root.element);
    if (root.children.length === 0) {
      this.showMessage(this._direction === "outgoingCalls" ? localize("empt.callsFrom", "No calls from '{0}'", model.root.name) : localize("empt.callsTo", "No callers of '{0}'", model.root.name));
    } else {
      this._parent.dataset["state"] = "data";
      if (!viewState || this._tree.getFocus().length === 0) {
        this._tree.setFocus([root.children[0].element]);
      }
      this._tree.domFocus();
      this._updatePreview();
    }
  }
  getModel() {
    return this._tree.getInput();
  }
  getFocused() {
    return this._tree.getFocus()[0];
  }
  async updateDirection(newDirection) {
    const model = this._tree.getInput();
    if (model && newDirection !== this._direction) {
      this._treeViewStates.set(this._direction, this._tree.getViewState());
      this._direction = newDirection;
      await this.showModel(model);
    }
  }
  _show() {
    if (!this._isShowing) {
      this.editor.revealLineInCenterIfOutsideViewport(this._where.lineNumber, 0);
      super.show(Range.fromPositions(this._where), this._layoutInfo.height);
    }
  }
  _onWidth(width) {
    if (this._dim) {
      this._doLayoutBody(this._dim.height, width);
    }
  }
  _doLayoutBody(height, width) {
    if (this._dim.height !== height || this._dim.width !== width) {
      super._doLayoutBody(height, width);
      this._dim = new Dimension(width, height);
      this._layoutInfo.height = this._viewZone ? this._viewZone.heightInLines : this._layoutInfo.height;
      this._splitView.layout(width);
      this._splitView.resizeView(0, width * this._layoutInfo.ratio);
    }
  }
}, _n.TitleMenu = new MenuId("callhierarchy/title"), _n);
CallHierarchyTreePeekWidget = __decorate([
  __param(3, IThemeService),
  __param(4, IPeekViewService),
  __param(5, IEditorService),
  __param(6, ITextModelService),
  __param(7, IStorageService),
  __param(8, IMenuService),
  __param(9, IContextKeyService),
  __param(10, IInstantiationService)
], CallHierarchyTreePeekWidget);
const _ctxHasCallHierarchyProvider = new RawContextKey("editorHasCallHierarchyProvider", false, localize(
  "editorHasCallHierarchyProvider",
  "Whether a call hierarchy provider is available"
));
const _ctxCallHierarchyVisible = new RawContextKey("callHierarchyVisible", false, localize("callHierarchyVisible", "Whether call hierarchy peek is currently showing"));
const _ctxCallHierarchyDirection = new RawContextKey(
  "callHierarchyDirection",
  void 0,
  { type: "string", description: localize(
    "callHierarchyDirection",
    "Whether call hierarchy shows incoming or outgoing calls"
  ) }
);
function sanitizedDirection$1(candidate) {
  return candidate === "outgoingCalls" || candidate === "incomingCalls" ? candidate : "incomingCalls";
}
let CallHierarchyController = (_o = class {
  static get(editor) {
    return editor.getContribution(_o.Id);
  }
  constructor(_editor, _contextKeyService, _storageService, _editorService, _instantiationService) {
    this._editor = _editor;
    this._contextKeyService = _contextKeyService;
    this._storageService = _storageService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._dispoables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._ctxIsVisible = _ctxCallHierarchyVisible.bindTo(this._contextKeyService);
    this._ctxHasProvider = _ctxHasCallHierarchyProvider.bindTo(this._contextKeyService);
    this._ctxDirection = _ctxCallHierarchyDirection.bindTo(this._contextKeyService);
    this._dispoables.add(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelLanguage, CallHierarchyProviderRegistry.onDidChange)(() => {
      this._ctxHasProvider.set(_editor.hasModel() && CallHierarchyProviderRegistry.has(_editor.getModel()));
    }));
    this._dispoables.add(this._sessionDisposables);
  }
  dispose() {
    this._ctxHasProvider.reset();
    this._ctxIsVisible.reset();
    this._dispoables.dispose();
  }
  async startCallHierarchyFromEditor() {
    this._sessionDisposables.clear();
    if (!this._editor.hasModel()) {
      return;
    }
    const document2 = this._editor.getModel();
    const position = this._editor.getPosition();
    if (!CallHierarchyProviderRegistry.has(document2)) {
      return;
    }
    const cts = new CancellationTokenSource();
    const model = CallHierarchyModel.create(document2, position, cts.token);
    const direction = sanitizedDirection$1(this._storageService.get(_o._StorageDirection, 0, "incomingCalls"));
    this._showCallHierarchyWidget(position, direction, model, cts);
  }
  async startCallHierarchyFromCallHierarchy() {
    var _a2;
    if (!this._widget) {
      return;
    }
    const model = this._widget.getModel();
    const call = this._widget.getFocused();
    if (!call || !model) {
      return;
    }
    const newEditor = await this._editorService.openCodeEditor({ resource: call.item.uri }, this._editor);
    if (!newEditor) {
      return;
    }
    const newModel = model.fork(call.item);
    this._sessionDisposables.clear();
    (_a2 = _o.get(newEditor)) == null ? void 0 : _a2._showCallHierarchyWidget(Range.lift(newModel.root.selectionRange).getStartPosition(), this._widget.direction, Promise.resolve(newModel), new CancellationTokenSource());
  }
  _showCallHierarchyWidget(position, direction, model, cts) {
    this._ctxIsVisible.set(true);
    this._ctxDirection.set(direction);
    Event.any(this._editor.onDidChangeModel, this._editor.onDidChangeModelLanguage)(this.endCallHierarchy, this, this._sessionDisposables);
    this._widget = this._instantiationService.createInstance(CallHierarchyTreePeekWidget, this._editor, position, direction);
    this._widget.showLoading();
    this._sessionDisposables.add(this._widget.onDidClose(() => {
      this.endCallHierarchy();
      this._storageService.store(_o._StorageDirection, this._widget.direction, 0, 0);
    }));
    this._sessionDisposables.add({ dispose() {
      cts.dispose(true);
    } });
    this._sessionDisposables.add(this._widget);
    model.then((model2) => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      if (model2) {
        this._sessionDisposables.add(model2);
        this._widget.showModel(model2);
      } else {
        this._widget.showMessage(localize("no.item", "No results"));
      }
    }).catch((err) => {
      if (isCancellationError(err)) {
        this.endCallHierarchy();
        return;
      }
      this._widget.showMessage(localize("error", "Failed to show call hierarchy"));
    });
  }
  showOutgoingCalls() {
    var _a2;
    (_a2 = this._widget) == null ? void 0 : _a2.updateDirection("outgoingCalls");
    this._ctxDirection.set("outgoingCalls");
  }
  showIncomingCalls() {
    var _a2;
    (_a2 = this._widget) == null ? void 0 : _a2.updateDirection("incomingCalls");
    this._ctxDirection.set("incomingCalls");
  }
  endCallHierarchy() {
    this._sessionDisposables.clear();
    this._ctxIsVisible.set(false);
    this._editor.focus();
  }
}, _o.Id = "callHierarchy", _o._StorageDirection = "callHierarchy/defaultDirection", _o);
CallHierarchyController = __decorate([
  __param(1, IContextKeyService),
  __param(2, IStorageService),
  __param(3, ICodeEditorService),
  __param(4, IInstantiationService)
], CallHierarchyController);
registerEditorContribution(CallHierarchyController.Id, CallHierarchyController, 0);
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.showCallHierarchy",
      title: { value: localize("title", "Peek Call Hierarchy"), original: "Peek Call Hierarchy" },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "navigation",
        order: 1e3,
        when: ContextKeyExpr.and(_ctxHasCallHierarchyProvider, PeekContext.notInPeekEditor)
      },
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        weight: 200,
        primary: 1024 + 512 + 38
      },
      precondition: ContextKeyExpr.and(_ctxHasCallHierarchyProvider, PeekContext.notInPeekEditor)
    });
  }
  async runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = CallHierarchyController.get(editor)) == null ? void 0 : _a2.startCallHierarchyFromEditor();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.showIncomingCalls",
      title: { value: localize("title.incoming", "Show Incoming Calls"), original: "Show Incoming Calls" },
      icon: registerIcon("callhierarchy-incoming", Codicon.callIncoming, localize(
        "showIncomingCallsIcons",
        "Icon for incoming calls in the call hierarchy view."
      )),
      precondition: ContextKeyExpr.and(_ctxCallHierarchyVisible, _ctxCallHierarchyDirection.isEqualTo("outgoingCalls")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: CallHierarchyTreePeekWidget.TitleMenu,
        when: _ctxCallHierarchyDirection.isEqualTo("outgoingCalls"),
        order: 1
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = CallHierarchyController.get(editor)) == null ? void 0 : _a2.showIncomingCalls();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.showOutgoingCalls",
      title: { value: localize("title.outgoing", "Show Outgoing Calls"), original: "Show Outgoing Calls" },
      icon: registerIcon("callhierarchy-outgoing", Codicon.callOutgoing, localize(
        "showOutgoingCallsIcon",
        "Icon for outgoing calls in the call hierarchy view."
      )),
      precondition: ContextKeyExpr.and(_ctxCallHierarchyVisible, _ctxCallHierarchyDirection.isEqualTo("incomingCalls")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: CallHierarchyTreePeekWidget.TitleMenu,
        when: _ctxCallHierarchyDirection.isEqualTo("incomingCalls"),
        order: 1
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = CallHierarchyController.get(editor)) == null ? void 0 : _a2.showOutgoingCalls();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.refocusCallHierarchy",
      title: { value: localize("title.refocus", "Refocus Call Hierarchy"), original: "Refocus Call Hierarchy" },
      precondition: _ctxCallHierarchyVisible,
      keybinding: {
        weight: 200,
        primary: 1024 + 3
      }
    });
  }
  async runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = CallHierarchyController.get(editor)) == null ? void 0 : _a2.startCallHierarchyFromCallHierarchy();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.closeCallHierarchy",
      title: localize("close", "Close"),
      icon: Codicon.close,
      precondition: _ctxCallHierarchyVisible,
      keybinding: {
        weight: 200 + 10,
        primary: 9,
        when: ContextKeyExpr.not("config.editor.stablePeek")
      },
      menu: {
        id: CallHierarchyTreePeekWidget.TitleMenu,
        order: 1e3
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = CallHierarchyController.get(editor)) == null ? void 0 : _a2.endCallHierarchy();
  }
});
var css$7 = ".monaco-workbench .type-hierarchy .message,.monaco-workbench .type-hierarchy .results{display:none}.monaco-workbench .type-hierarchy[data-state=data] .results{display:inherit;height:100%}.monaco-workbench .type-hierarchy[data-state=message] .message{align-items:center;display:flex;height:100%;justify-content:center}.monaco-workbench .type-hierarchy .editor,.monaco-workbench .type-hierarchy .tree{height:100%}.monaco-editor .type-hierarchy .tree{background-color:var(--vscode-peekViewResult-background);color:var(--vscode-peekViewResult-fileForeground)}.monaco-editor .type-hierarchy .tree .monaco-list:focus .monaco-list-rows>.monaco-list-row.selected:not(.highlighted){background-color:var(--vscode-peekViewResult-selectionBackground);color:var(--vscode-peekViewResult-selectionForeground)!important}.monaco-workbench .type-hierarchy .tree .typehierarchy-element{align-items:center;display:flex;flex:1;flex-flow:row nowrap}.monaco-workbench .type-hierarchy .tree .typehierarchy-element .monaco-icon-label{padding-left:4px}.monaco-editor .type-hierarchy .type-decoration{background-color:var(--vscode-peekViewEditor-matchHighlightBackground);border:2px solid var(--vscode-peekViewEditor-matchHighlightBorder);box-sizing:border-box}.monaco-editor .type-hierarchy .editor .monaco-editor .inputarea.ime-input,.monaco-editor .type-hierarchy .editor .monaco-editor .monaco-editor-background{background-color:var(--vscode-peekViewEditor-background)}.monaco-editor .type-hierarchy .editor .monaco-editor .margin{background-color:var(--vscode-peekViewEditorGutter-background)}";
n(css$7, {});
class Type {
  constructor(item, model, parent) {
    this.item = item;
    this.model = model;
    this.parent = parent;
  }
  static compare(a, b) {
    let res = compare(a.item.uri.toString(), b.item.uri.toString());
    if (res === 0) {
      res = Range.compareRangesUsingStarts(a.item.range, b.item.range);
    }
    return res;
  }
}
class DataSource2 {
  constructor(getDirection) {
    this.getDirection = getDirection;
  }
  hasChildren() {
    return true;
  }
  async getChildren(element) {
    if (element instanceof TypeHierarchyModel) {
      return element.roots.map((root) => new Type(root, element, void 0));
    }
    const { model, item } = element;
    if (this.getDirection() === "supertypes") {
      return (await model.provideSupertypes(item, CancellationToken.None)).map((item2) => {
        return new Type(item2, model, element);
      });
    } else {
      return (await model.provideSubtypes(item, CancellationToken.None)).map((item2) => {
        return new Type(item2, model, element);
      });
    }
  }
}
class Sorter2 {
  compare(element, otherElement) {
    return Type.compare(element, otherElement);
  }
}
class IdentityProvider2 {
  constructor(getDirection) {
    this.getDirection = getDirection;
  }
  getId(element) {
    let res = this.getDirection() + JSON.stringify(element.item.uri) + JSON.stringify(element.item.range);
    if (element.parent) {
      res += this.getId(element.parent);
    }
    return res;
  }
}
class TypeRenderingTemplate {
  constructor(icon, label) {
    this.icon = icon;
    this.label = label;
  }
}
const _TypeRenderer = class _TypeRenderer {
  constructor() {
    this.templateId = _TypeRenderer.id;
  }
  renderTemplate(container) {
    container.classList.add("typehierarchy-element");
    const icon = document.createElement("div");
    container.appendChild(icon);
    const label = new IconLabel(container, { supportHighlights: true });
    return new TypeRenderingTemplate(icon, label);
  }
  renderElement(node, _index, template) {
    var _a2;
    const { element, filterData } = node;
    const deprecated = (_a2 = element.item.tags) == null ? void 0 : _a2.includes(1);
    template.icon.classList.add("inline", ...ThemeIcon.asClassNameArray(SymbolKinds.toIcon(element.item.kind)));
    template.label.setLabel(element.item.name, element.item.detail, { labelEscapeNewLines: true, matches: createMatches(filterData), strikethrough: deprecated });
  }
  disposeTemplate(template) {
    template.label.dispose();
  }
};
_TypeRenderer.id = "TypeRenderer";
let TypeRenderer = _TypeRenderer;
class VirtualDelegate2 {
  getHeight(_element) {
    return 22;
  }
  getTemplateId(_element) {
    return TypeRenderer.id;
  }
}
class AccessibilityProvider2 {
  constructor(getDirection) {
    this.getDirection = getDirection;
  }
  getWidgetAriaLabel() {
    return localize("tree.aria", "Type Hierarchy");
  }
  getAriaLabel(element) {
    if (this.getDirection() === "supertypes") {
      return localize("supertypes", "supertypes of {0}", element.item.name);
    } else {
      return localize("subtypes", "subtypes of {0}", element.item.name);
    }
  }
}
class LayoutInfo2 {
  static store(info, storageService) {
    storageService.store("typeHierarchyPeekLayout", JSON.stringify(info), 0, 1);
  }
  static retrieve(storageService) {
    const value = storageService.get("typeHierarchyPeekLayout", 0, "{}");
    const defaultInfo = { ratio: 0.7, height: 17 };
    try {
      return { ...defaultInfo, ...JSON.parse(value) };
    } catch {
      return defaultInfo;
    }
  }
  constructor(ratio, height) {
    this.ratio = ratio;
    this.height = height;
  }
}
class TypeHierarchyTree extends WorkbenchAsyncDataTree {
}
let TypeHierarchyTreePeekWidget = (_p = class extends PeekViewWidget {
  constructor(editor, _where, _direction, themeService, _peekViewService, _editorService, _textModelService, _storageService, _menuService, _contextKeyService, _instantiationService) {
    super(editor, { showFrame: true, showArrow: true, isResizeable: true, isAccessible: true }, _instantiationService);
    this._where = _where;
    this._direction = _direction;
    this._peekViewService = _peekViewService;
    this._editorService = _editorService;
    this._textModelService = _textModelService;
    this._storageService = _storageService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._treeViewStates = /* @__PURE__ */ new Map();
    this._previewDisposable = new DisposableStore();
    this.create();
    this._peekViewService.addExclusiveWidget(editor, this);
    this._applyTheme(themeService.getColorTheme());
    this._disposables.add(themeService.onDidColorThemeChange(this._applyTheme, this));
    this._disposables.add(this._previewDisposable);
  }
  dispose() {
    LayoutInfo2.store(this._layoutInfo, this._storageService);
    this._splitView.dispose();
    this._tree.dispose();
    this._editor.dispose();
    super.dispose();
  }
  get direction() {
    return this._direction;
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  _fillHead(container) {
    super._fillHead(container, true);
    const menu = this._menuService.createMenu(_p.TitleMenu, this._contextKeyService);
    const updateToolbar = () => {
      const actions = [];
      createAndFillInActionBarActions(menu, void 0, actions);
      this._actionbarWidget.clear();
      this._actionbarWidget.push(actions, { label: false, icon: true });
    };
    this._disposables.add(menu);
    this._disposables.add(menu.onDidChange(updateToolbar));
    updateToolbar();
  }
  _fillBody(parent) {
    this._layoutInfo = LayoutInfo2.retrieve(this._storageService);
    this._dim = new Dimension(0, 0);
    this._parent = parent;
    parent.classList.add("type-hierarchy");
    const message = document.createElement("div");
    message.classList.add("message");
    parent.appendChild(message);
    this._message = message;
    this._message.tabIndex = 0;
    const container = document.createElement("div");
    container.classList.add("results");
    parent.appendChild(container);
    this._splitView = new SplitView(container, { orientation: 1 });
    const editorContainer = document.createElement("div");
    editorContainer.classList.add("editor");
    container.appendChild(editorContainer);
    const editorOptions = {
      scrollBeyondLastLine: false,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false,
        alwaysConsumeMouseWheel: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: {
        enabled: false
      }
    };
    this._editor = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, editorContainer, editorOptions, {}, this.editor);
    const treeContainer = document.createElement("div");
    treeContainer.classList.add("tree");
    container.appendChild(treeContainer);
    const options = {
      sorter: new Sorter2(),
      accessibilityProvider: new AccessibilityProvider2(() => this._direction),
      identityProvider: new IdentityProvider2(() => this._direction),
      expandOnlyOnTwistieClick: true,
      overrideStyles: {
        listBackground: peekViewResultsBackground
      }
    };
    this._tree = this._instantiationService.createInstance(TypeHierarchyTree, "TypeHierarchyPeek", treeContainer, new VirtualDelegate2(), [this._instantiationService.createInstance(TypeRenderer)], this._instantiationService.createInstance(DataSource2, () => this._direction), options);
    this._splitView.addView({
      onDidChange: Event.None,
      element: editorContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        if (this._dim.height) {
          this._editor.layout({ height: this._dim.height, width });
        }
      }
    }, Sizing$1.Distribute);
    this._splitView.addView({
      onDidChange: Event.None,
      element: treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        if (this._dim.height) {
          this._tree.layout(this._dim.height, width);
        }
      }
    }, Sizing$1.Distribute);
    this._disposables.add(this._splitView.onDidSashChange(() => {
      if (this._dim.width) {
        this._layoutInfo.ratio = this._splitView.getViewSize(0) / this._dim.width;
      }
    }));
    this._disposables.add(this._tree.onDidChangeFocus(this._updatePreview, this));
    this._disposables.add(this._editor.onMouseDown((e) => {
      const { event, target } = e;
      if (event.detail !== 2) {
        return;
      }
      const [focus] = this._tree.getFocus();
      if (!focus) {
        return;
      }
      this.dispose();
      this._editorService.openEditor({
        resource: focus.item.uri,
        options: { selection: target.range }
      });
    }));
    this._disposables.add(this._tree.onMouseDblClick((e) => {
      if (e.target === TreeMouseEventTarget.Twistie) {
        return;
      }
      if (e.element) {
        this.dispose();
        this._editorService.openEditor({
          resource: e.element.item.uri,
          options: { selection: e.element.item.selectionRange, pinned: true }
        });
      }
    }));
    this._disposables.add(this._tree.onDidChangeSelection((e) => {
      const [element] = e.elements;
      if (element && e.browserEvent instanceof KeyboardEvent) {
        this.dispose();
        this._editorService.openEditor({
          resource: element.item.uri,
          options: { selection: element.item.selectionRange, pinned: true }
        });
      }
    }));
  }
  async _updatePreview() {
    const [element] = this._tree.getFocus();
    if (!element) {
      return;
    }
    this._previewDisposable.clear();
    const options = {
      description: "type-hierarchy-decoration",
      stickiness: 1,
      className: "type-decoration",
      overviewRuler: {
        color: themeColorFromId(peekViewEditorMatchHighlight),
        position: OverviewRulerLane.Center
      }
    };
    let previewUri;
    if (this._direction === "supertypes") {
      previewUri = element.parent ? element.parent.item.uri : element.model.root.uri;
    } else {
      previewUri = element.item.uri;
    }
    const value = await this._textModelService.createModelReference(previewUri);
    this._editor.setModel(value.object.textEditorModel);
    const decorations = [];
    let fullRange;
    const loc = { uri: element.item.uri, range: element.item.selectionRange };
    if (loc.uri.toString() === previewUri.toString()) {
      decorations.push({ range: loc.range, options });
      fullRange = !fullRange ? loc.range : Range.plusRange(loc.range, fullRange);
    }
    if (fullRange) {
      this._editor.revealRangeInCenter(fullRange, 1);
      const decorationsCollection = this._editor.createDecorationsCollection(decorations);
      this._previewDisposable.add(toDisposable(() => decorationsCollection.clear()));
    }
    this._previewDisposable.add(value);
    const title = this._direction === "supertypes" ? localize("supertypes", "Supertypes of '{0}'", element.model.root.name) : localize("subtypes", "Subtypes of '{0}'", element.model.root.name);
    this.setTitle(title);
  }
  showLoading() {
    this._parent.dataset["state"] = "loading";
    this.setTitle(localize("title.loading", "Loading..."));
    this._show();
  }
  showMessage(message) {
    this._parent.dataset["state"] = "message";
    this.setTitle("");
    this.setMetaTitle("");
    this._message.innerText = message;
    this._show();
    this._message.focus();
  }
  async showModel(model) {
    this._show();
    const viewState = this._treeViewStates.get(this._direction);
    await this._tree.setInput(model, viewState);
    const root = this._tree.getNode(model).children[0];
    await this._tree.expand(root.element);
    if (root.children.length === 0) {
      this.showMessage(this._direction === "supertypes" ? localize("empt.supertypes", "No supertypes of '{0}'", model.root.name) : localize("empt.subtypes", "No subtypes of '{0}'", model.root.name));
    } else {
      this._parent.dataset["state"] = "data";
      if (!viewState || this._tree.getFocus().length === 0) {
        this._tree.setFocus([root.children[0].element]);
      }
      this._tree.domFocus();
      this._updatePreview();
    }
  }
  getModel() {
    return this._tree.getInput();
  }
  getFocused() {
    return this._tree.getFocus()[0];
  }
  async updateDirection(newDirection) {
    const model = this._tree.getInput();
    if (model && newDirection !== this._direction) {
      this._treeViewStates.set(this._direction, this._tree.getViewState());
      this._direction = newDirection;
      await this.showModel(model);
    }
  }
  _show() {
    if (!this._isShowing) {
      this.editor.revealLineInCenterIfOutsideViewport(this._where.lineNumber, 0);
      super.show(Range.fromPositions(this._where), this._layoutInfo.height);
    }
  }
  _onWidth(width) {
    if (this._dim) {
      this._doLayoutBody(this._dim.height, width);
    }
  }
  _doLayoutBody(height, width) {
    if (this._dim.height !== height || this._dim.width !== width) {
      super._doLayoutBody(height, width);
      this._dim = new Dimension(width, height);
      this._layoutInfo.height = this._viewZone ? this._viewZone.heightInLines : this._layoutInfo.height;
      this._splitView.layout(width);
      this._splitView.resizeView(0, width * this._layoutInfo.ratio);
    }
  }
}, _p.TitleMenu = new MenuId("typehierarchy/title"), _p);
TypeHierarchyTreePeekWidget = __decorate([
  __param(3, IThemeService),
  __param(4, IPeekViewService),
  __param(5, IEditorService),
  __param(6, ITextModelService),
  __param(7, IStorageService),
  __param(8, IMenuService),
  __param(9, IContextKeyService),
  __param(10, IInstantiationService)
], TypeHierarchyTreePeekWidget);
const _ctxHasTypeHierarchyProvider = new RawContextKey("editorHasTypeHierarchyProvider", false, localize(
  "editorHasTypeHierarchyProvider",
  "Whether a type hierarchy provider is available"
));
const _ctxTypeHierarchyVisible = new RawContextKey("typeHierarchyVisible", false, localize("typeHierarchyVisible", "Whether type hierarchy peek is currently showing"));
const _ctxTypeHierarchyDirection = new RawContextKey(
  "typeHierarchyDirection",
  void 0,
  { type: "string", description: localize(
    "typeHierarchyDirection",
    "whether type hierarchy shows super types or subtypes"
  ) }
);
function sanitizedDirection(candidate) {
  return candidate === "subtypes" || candidate === "supertypes" ? candidate : "subtypes";
}
let TypeHierarchyController = (_q = class {
  static get(editor) {
    return editor.getContribution(_q.Id);
  }
  constructor(_editor, _contextKeyService, _storageService, _editorService, _instantiationService) {
    this._editor = _editor;
    this._contextKeyService = _contextKeyService;
    this._storageService = _storageService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._ctxHasProvider = _ctxHasTypeHierarchyProvider.bindTo(this._contextKeyService);
    this._ctxIsVisible = _ctxTypeHierarchyVisible.bindTo(this._contextKeyService);
    this._ctxDirection = _ctxTypeHierarchyDirection.bindTo(this._contextKeyService);
    this._disposables.add(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelLanguage, TypeHierarchyProviderRegistry.onDidChange)(() => {
      this._ctxHasProvider.set(_editor.hasModel() && TypeHierarchyProviderRegistry.has(_editor.getModel()));
    }));
    this._disposables.add(this._sessionDisposables);
  }
  dispose() {
    this._disposables.dispose();
  }
  async startTypeHierarchyFromEditor() {
    this._sessionDisposables.clear();
    if (!this._editor.hasModel()) {
      return;
    }
    const document2 = this._editor.getModel();
    const position = this._editor.getPosition();
    if (!TypeHierarchyProviderRegistry.has(document2)) {
      return;
    }
    const cts = new CancellationTokenSource();
    const model = TypeHierarchyModel.create(document2, position, cts.token);
    const direction = sanitizedDirection(this._storageService.get(_q._storageDirectionKey, 0, "subtypes"));
    this._showTypeHierarchyWidget(position, direction, model, cts);
  }
  _showTypeHierarchyWidget(position, direction, model, cts) {
    this._ctxIsVisible.set(true);
    this._ctxDirection.set(direction);
    Event.any(this._editor.onDidChangeModel, this._editor.onDidChangeModelLanguage)(this.endTypeHierarchy, this, this._sessionDisposables);
    this._widget = this._instantiationService.createInstance(TypeHierarchyTreePeekWidget, this._editor, position, direction);
    this._widget.showLoading();
    this._sessionDisposables.add(this._widget.onDidClose(() => {
      this.endTypeHierarchy();
      this._storageService.store(_q._storageDirectionKey, this._widget.direction, 0, 0);
    }));
    this._sessionDisposables.add({ dispose() {
      cts.dispose(true);
    } });
    this._sessionDisposables.add(this._widget);
    model.then((model2) => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      if (model2) {
        this._sessionDisposables.add(model2);
        this._widget.showModel(model2);
      } else {
        this._widget.showMessage(localize("no.item", "No results"));
      }
    }).catch((err) => {
      if (isCancellationError(err)) {
        this.endTypeHierarchy();
        return;
      }
      this._widget.showMessage(localize("error", "Failed to show type hierarchy"));
    });
  }
  async startTypeHierarchyFromTypeHierarchy() {
    var _a2;
    if (!this._widget) {
      return;
    }
    const model = this._widget.getModel();
    const typeItem = this._widget.getFocused();
    if (!typeItem || !model) {
      return;
    }
    const newEditor = await this._editorService.openCodeEditor({ resource: typeItem.item.uri }, this._editor);
    if (!newEditor) {
      return;
    }
    const newModel = model.fork(typeItem.item);
    this._sessionDisposables.clear();
    (_a2 = _q.get(newEditor)) == null ? void 0 : _a2._showTypeHierarchyWidget(Range.lift(newModel.root.selectionRange).getStartPosition(), this._widget.direction, Promise.resolve(newModel), new CancellationTokenSource());
  }
  showSupertypes() {
    var _a2;
    (_a2 = this._widget) == null ? void 0 : _a2.updateDirection("supertypes");
    this._ctxDirection.set("supertypes");
  }
  showSubtypes() {
    var _a2;
    (_a2 = this._widget) == null ? void 0 : _a2.updateDirection("subtypes");
    this._ctxDirection.set("subtypes");
  }
  endTypeHierarchy() {
    this._sessionDisposables.clear();
    this._ctxIsVisible.set(false);
    this._editor.focus();
  }
}, _q.Id = "typeHierarchy", _q._storageDirectionKey = "typeHierarchy/defaultDirection", _q);
TypeHierarchyController = __decorate([
  __param(1, IContextKeyService),
  __param(2, IStorageService),
  __param(3, ICodeEditorService),
  __param(4, IInstantiationService)
], TypeHierarchyController);
registerEditorContribution(TypeHierarchyController.Id, TypeHierarchyController, 0);
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.showTypeHierarchy",
      title: { value: localize("title", "Peek Type Hierarchy"), original: "Peek Type Hierarchy" },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "navigation",
        order: 1e3,
        when: ContextKeyExpr.and(_ctxHasTypeHierarchyProvider, PeekContext.notInPeekEditor)
      },
      precondition: ContextKeyExpr.and(_ctxHasTypeHierarchyProvider, PeekContext.notInPeekEditor)
    });
  }
  async runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = TypeHierarchyController.get(editor)) == null ? void 0 : _a2.startTypeHierarchyFromEditor();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.showSupertypes",
      title: { value: localize("title.supertypes", "Show Supertypes"), original: "Show Supertypes" },
      icon: Codicon.typeHierarchySuper,
      precondition: ContextKeyExpr.and(_ctxTypeHierarchyVisible, _ctxTypeHierarchyDirection.isEqualTo("subtypes")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: TypeHierarchyTreePeekWidget.TitleMenu,
        when: _ctxTypeHierarchyDirection.isEqualTo("subtypes"),
        order: 1
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = TypeHierarchyController.get(editor)) == null ? void 0 : _a2.showSupertypes();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.showSubtypes",
      title: { value: localize("title.subtypes", "Show Subtypes"), original: "Show Subtypes" },
      icon: Codicon.typeHierarchySub,
      precondition: ContextKeyExpr.and(_ctxTypeHierarchyVisible, _ctxTypeHierarchyDirection.isEqualTo("supertypes")),
      keybinding: {
        weight: 200,
        primary: 1024 + 512 + 38
      },
      menu: {
        id: TypeHierarchyTreePeekWidget.TitleMenu,
        when: _ctxTypeHierarchyDirection.isEqualTo("supertypes"),
        order: 1
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = TypeHierarchyController.get(editor)) == null ? void 0 : _a2.showSubtypes();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.refocusTypeHierarchy",
      title: { value: localize("title.refocusTypeHierarchy", "Refocus Type Hierarchy"), original: "Refocus Type Hierarchy" },
      precondition: _ctxTypeHierarchyVisible,
      keybinding: {
        weight: 200,
        primary: 1024 + 3
      }
    });
  }
  async runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = TypeHierarchyController.get(editor)) == null ? void 0 : _a2.startTypeHierarchyFromTypeHierarchy();
  }
});
registerAction2(class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.closeTypeHierarchy",
      title: localize("close", "Close"),
      icon: Codicon.close,
      precondition: _ctxTypeHierarchyVisible,
      keybinding: {
        weight: 200 + 10,
        primary: 9,
        when: ContextKeyExpr.not("config.editor.stablePeek")
      },
      menu: {
        id: TypeHierarchyTreePeekWidget.TitleMenu,
        order: 1e3
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    var _a2;
    return (_a2 = TypeHierarchyController.get(editor)) == null ? void 0 : _a2.endTypeHierarchy();
  }
});
var css$6 = ".monaco-list .monaco-list-row.focused.selected .outline-element .monaco-highlighted-label,.monaco-list .monaco-list-row.focused.selected .outline-element-decoration{color:inherit!important}.monaco-list .outline-element{align-items:center;display:flex;flex:1;flex-flow:row nowrap}.monaco-list .outline-element .monaco-highlighted-label{color:var(--outline-element-color)}.monaco-breadcrumbs .outline-element .outline-element-decoration,.monaco-list .outline-element .outline-element-decoration{color:var(--outline-element-color);font-size:90%;font-weight:600;margin-left:auto;opacity:.75;padding:0 12px 0 5px;text-align:center}.monaco-breadcrumbs .outline-element .monaco-icon-label-container .monaco-icon-description-container,.monaco-breadcrumbs .outline-element .outline-element-decoration{display:none}.monaco-list .outline-element .outline-element-decoration.bubble{font-family:codicon;font-size:14px;opacity:.4;padding-right:8px}.monaco-list .outline-element .outline-element-icon{margin-right:4px}";
n(css$6, {});
class DocumentSymbolNavigationLabelProvider {
  getKeyboardNavigationLabel(element) {
    if (element instanceof OutlineGroup) {
      return element.label;
    } else {
      return element.symbol.name;
    }
  }
}
class DocumentSymbolAccessibilityProvider {
  constructor(_ariaLabel) {
    this._ariaLabel = _ariaLabel;
  }
  getWidgetAriaLabel() {
    return this._ariaLabel;
  }
  getAriaLabel(element) {
    if (element instanceof OutlineGroup) {
      return element.label;
    } else {
      return getAriaLabelForSymbol(element.symbol.name, element.symbol.kind);
    }
  }
}
class DocumentSymbolIdentityProvider {
  getId(element) {
    return element.id;
  }
}
const _DocumentSymbolGroupTemplate = class _DocumentSymbolGroupTemplate {
  constructor(labelContainer, label) {
    this.labelContainer = labelContainer;
    this.label = label;
  }
};
_DocumentSymbolGroupTemplate.id = "DocumentSymbolGroupTemplate";
let DocumentSymbolGroupTemplate = _DocumentSymbolGroupTemplate;
const _DocumentSymbolTemplate = class _DocumentSymbolTemplate {
  constructor(container, iconLabel, iconClass, decoration) {
    this.container = container;
    this.iconLabel = iconLabel;
    this.iconClass = iconClass;
    this.decoration = decoration;
  }
};
_DocumentSymbolTemplate.id = "DocumentSymbolTemplate";
let DocumentSymbolTemplate = _DocumentSymbolTemplate;
class DocumentSymbolVirtualDelegate {
  getHeight(_element) {
    return 22;
  }
  getTemplateId(element) {
    return element instanceof OutlineGroup ? DocumentSymbolGroupTemplate.id : DocumentSymbolTemplate.id;
  }
}
class DocumentSymbolGroupRenderer {
  constructor() {
    this.templateId = DocumentSymbolGroupTemplate.id;
  }
  renderTemplate(container) {
    const labelContainer = $$2(".outline-element-label");
    container.classList.add("outline-element");
    append(container, labelContainer);
    return new DocumentSymbolGroupTemplate(labelContainer, new HighlightedLabel(labelContainer));
  }
  renderElement(node, _index, template) {
    template.label.set(node.element.label, createMatches(node.filterData));
  }
  disposeTemplate(_template) {
  }
}
let DocumentSymbolRenderer = class DocumentSymbolRenderer2 {
  constructor(_renderMarker, _configurationService, _themeService) {
    this._renderMarker = _renderMarker;
    this._configurationService = _configurationService;
    this._themeService = _themeService;
    this.templateId = DocumentSymbolTemplate.id;
  }
  renderTemplate(container) {
    container.classList.add("outline-element");
    const iconLabel = new IconLabel(container, { supportHighlights: true });
    const iconClass = $$2(".outline-element-icon");
    const decoration = $$2(".outline-element-decoration");
    container.prepend(iconClass);
    container.appendChild(decoration);
    return new DocumentSymbolTemplate(container, iconLabel, iconClass, decoration);
  }
  renderElement(node, _index, template) {
    const { element } = node;
    const extraClasses = ["nowrap"];
    const options = {
      matches: createMatches(node.filterData),
      labelEscapeNewLines: true,
      extraClasses,
      title: localize(
        "title.template",
        "{0} ({1})",
        element.symbol.name,
        symbolKindNames[element.symbol.kind]
      )
    };
    if (this._configurationService.getValue("outline.icons")) {
      template.iconClass.className = "";
      template.iconClass.classList.add("outline-element-icon", "inline", ...ThemeIcon.asClassNameArray(SymbolKinds.toIcon(element.symbol.kind)));
    }
    if (element.symbol.tags.indexOf(1) >= 0) {
      extraClasses.push(`deprecated`);
      options.matches = [];
    }
    template.iconLabel.setLabel(element.symbol.name, element.symbol.detail, options);
    if (this._renderMarker) {
      this._renderMarkerInfo(element, template);
    }
  }
  _renderMarkerInfo(element, template) {
    if (!element.marker) {
      hide(template.decoration);
      template.container.style.removeProperty("--outline-element-color");
      return;
    }
    const { count, topSev } = element.marker;
    const color = this._themeService.getColorTheme().getColor(topSev === MarkerSeverity.Error ? listErrorForeground : listWarningForeground);
    const cssColor = color ? color.toString() : "inherit";
    if (this._configurationService.getValue("outline.problems.colors")) {
      template.container.style.setProperty("--outline-element-color", cssColor);
    } else {
      template.container.style.removeProperty("--outline-element-color");
    }
    if (!this._configurationService.getValue("outline.problems.badges")) {
      hide(template.decoration);
    } else if (count > 0) {
      show(template.decoration);
      template.decoration.classList.remove("bubble");
      template.decoration.innerText = count < 10 ? count.toString() : "+9";
      template.decoration.title = count === 1 ? localize("1.problem", "1 problem in this element") : localize("N.problem", "{0} problems in this element", count);
      template.decoration.style.setProperty("--outline-element-color", cssColor);
    } else {
      show(template.decoration);
      template.decoration.classList.add("bubble");
      template.decoration.innerText = "";
      template.decoration.title = localize("deep.problem", "Contains elements with problems");
      template.decoration.style.setProperty("--outline-element-color", cssColor);
    }
  }
  disposeTemplate(_template) {
    _template.iconLabel.dispose();
  }
};
DocumentSymbolRenderer = __decorate([
  __param(1, IConfigurationService),
  __param(2, IThemeService)
], DocumentSymbolRenderer);
let DocumentSymbolFilter = (_r = class {
  constructor(_prefix, _textResourceConfigService) {
    this._prefix = _prefix;
    this._textResourceConfigService = _textResourceConfigService;
  }
  filter(element) {
    const outline = OutlineModel.get(element);
    if (!(element instanceof OutlineElement)) {
      return true;
    }
    const configName = _r.kindToConfigName[element.symbol.kind];
    const configKey = `${this._prefix}.${configName}`;
    return this._textResourceConfigService.getValue(outline == null ? void 0 : outline.uri, configKey);
  }
}, _r.kindToConfigName = Object.freeze({
  [0]: "showFiles",
  [1]: "showModules",
  [2]: "showNamespaces",
  [3]: "showPackages",
  [4]: "showClasses",
  [5]: "showMethods",
  [6]: "showProperties",
  [7]: "showFields",
  [8]: "showConstructors",
  [9]: "showEnums",
  [10]: "showInterfaces",
  [11]: "showFunctions",
  [12]: "showVariables",
  [13]: "showConstants",
  [14]: "showStrings",
  [15]: "showNumbers",
  [16]: "showBooleans",
  [17]: "showArrays",
  [18]: "showObjects",
  [19]: "showKeys",
  [20]: "showNull",
  [21]: "showEnumMembers",
  [22]: "showStructs",
  [23]: "showEvents",
  [24]: "showOperators",
  [25]: "showTypeParameters"
}), _r);
DocumentSymbolFilter = __decorate([
  __param(1, ITextResourceConfigurationService)
], DocumentSymbolFilter);
class DocumentSymbolComparator {
  constructor() {
    this._collator = new IdleValue(() => new Intl.Collator(void 0, { numeric: true }));
  }
  compareByPosition(a, b) {
    if (a instanceof OutlineGroup && b instanceof OutlineGroup) {
      return a.order - b.order;
    } else if (a instanceof OutlineElement && b instanceof OutlineElement) {
      return Range.compareRangesUsingStarts(a.symbol.range, b.symbol.range) || this._collator.value.compare(a.symbol.name, b.symbol.name);
    }
    return 0;
  }
  compareByType(a, b) {
    if (a instanceof OutlineGroup && b instanceof OutlineGroup) {
      return a.order - b.order;
    } else if (a instanceof OutlineElement && b instanceof OutlineElement) {
      return a.symbol.kind - b.symbol.kind || this._collator.value.compare(a.symbol.name, b.symbol.name);
    }
    return 0;
  }
  compareByName(a, b) {
    if (a instanceof OutlineGroup && b instanceof OutlineGroup) {
      return a.order - b.order;
    } else if (a instanceof OutlineElement && b instanceof OutlineElement) {
      return this._collator.value.compare(a.symbol.name, b.symbol.name) || Range.compareRangesUsingStarts(a.symbol.range, b.symbol.range);
    }
    return 0;
  }
}
let DocumentSymbolBreadcrumbsSource = class DocumentSymbolBreadcrumbsSource2 {
  constructor(_editor, _textResourceConfigurationService) {
    this._editor = _editor;
    this._textResourceConfigurationService = _textResourceConfigurationService;
    this._breadcrumbs = [];
  }
  getBreadcrumbElements() {
    return this._breadcrumbs;
  }
  clear() {
    this._breadcrumbs = [];
  }
  update(model, position) {
    const newElements = this._computeBreadcrumbs(model, position);
    this._breadcrumbs = newElements;
  }
  _computeBreadcrumbs(model, position) {
    let item = model.getItemEnclosingPosition(position);
    if (!item) {
      return [];
    }
    const chain = [];
    while (item) {
      chain.push(item);
      const parent = item.parent;
      if (parent instanceof OutlineModel) {
        break;
      }
      if (parent instanceof OutlineGroup && parent.parent && parent.parent.children.size === 1) {
        break;
      }
      item = parent;
    }
    const result = [];
    for (let i = chain.length - 1; i >= 0; i--) {
      const element = chain[i];
      if (this._isFiltered(element)) {
        break;
      }
      result.push(element);
    }
    if (result.length === 0) {
      return [];
    }
    return result;
  }
  _isFiltered(element) {
    if (!(element instanceof OutlineElement)) {
      return false;
    }
    const key = `breadcrumbs.${DocumentSymbolFilter.kindToConfigName[element.symbol.kind]}`;
    let uri;
    if (this._editor && this._editor.getModel()) {
      const model = this._editor.getModel();
      uri = model.uri;
    }
    return !this._textResourceConfigurationService.getValue(uri, key);
  }
};
DocumentSymbolBreadcrumbsSource = __decorate([
  __param(1, ITextResourceConfigurationService)
], DocumentSymbolBreadcrumbsSource);
let DocumentSymbolsOutline = class DocumentSymbolsOutline2 {
  get activeElement() {
    const posistion = this._editor.getPosition();
    if (!posistion || !this._outlineModel) {
      return void 0;
    } else {
      return this._outlineModel.getItemEnclosingPosition(posistion);
    }
  }
  constructor(_editor, target, firstLoadBarrier, _languageFeaturesService, _codeEditorService, _outlineModelService, _configurationService, _markerDecorationsService, textResourceConfigurationService, instantiationService) {
    var _a2;
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._codeEditorService = _codeEditorService;
    this._outlineModelService = _outlineModelService;
    this._configurationService = _configurationService;
    this._markerDecorationsService = _markerDecorationsService;
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._outlineDisposables = new DisposableStore();
    this.outlineKind = "documentSymbols";
    this._breadcrumbsDataSource = new DocumentSymbolBreadcrumbsSource(_editor, textResourceConfigurationService);
    const delegate = new DocumentSymbolVirtualDelegate();
    const renderers = [new DocumentSymbolGroupRenderer(), instantiationService.createInstance(DocumentSymbolRenderer, true)];
    const treeDataSource = {
      getChildren: (parent) => {
        if (parent instanceof OutlineElement || parent instanceof OutlineGroup) {
          return parent.children.values();
        }
        if (parent === this && this._outlineModel) {
          return this._outlineModel.children.values();
        }
        return [];
      }
    };
    const comparator = new DocumentSymbolComparator();
    const initialState = textResourceConfigurationService.getValue((_a2 = _editor.getModel()) == null ? void 0 : _a2.uri, "outline.collapseItems");
    const options = {
      collapseByDefault: target === 2 || target === 1 && initialState === "alwaysCollapse",
      expandOnlyOnTwistieClick: true,
      multipleSelectionSupport: false,
      identityProvider: new DocumentSymbolIdentityProvider(),
      keyboardNavigationLabelProvider: new DocumentSymbolNavigationLabelProvider(),
      accessibilityProvider: new DocumentSymbolAccessibilityProvider(localize("document", "Document Symbols")),
      filter: target === 1 ? instantiationService.createInstance(DocumentSymbolFilter, "outline") : target === 2 ? instantiationService.createInstance(DocumentSymbolFilter, "breadcrumbs") : void 0
    };
    this.config = {
      breadcrumbsDataSource: this._breadcrumbsDataSource,
      delegate,
      renderers,
      treeDataSource,
      comparator,
      options,
      quickPickDataSource: { getQuickPickElements: () => {
        throw new Error("not implemented");
      } }
    };
    this._disposables.add(_languageFeaturesService.documentSymbolProvider.onDidChange((_) => this._createOutline()));
    this._disposables.add(this._editor.onDidChangeModel((_) => this._createOutline()));
    this._disposables.add(this._editor.onDidChangeModelLanguage((_) => this._createOutline()));
    const updateSoon = new TimeoutTimer();
    this._disposables.add(updateSoon);
    this._disposables.add(this._editor.onDidChangeModelContent((event) => {
      const model = this._editor.getModel();
      if (model) {
        const timeout2 = _outlineModelService.getDebounceValue(model);
        updateSoon.cancelAndSet(() => this._createOutline(event), timeout2);
      }
    }));
    this._disposables.add(this._editor.onDidDispose(() => this._outlineDisposables.clear()));
    this._createOutline().finally(() => firstLoadBarrier.open());
  }
  dispose() {
    this._disposables.dispose();
    this._outlineDisposables.dispose();
  }
  get isEmpty() {
    return !this._outlineModel || TreeElement.empty(this._outlineModel);
  }
  get uri() {
    var _a2;
    return (_a2 = this._outlineModel) == null ? void 0 : _a2.uri;
  }
  async reveal(entry, options, sideBySide) {
    const model = OutlineModel.get(entry);
    if (!model || !(entry instanceof OutlineElement)) {
      return;
    }
    await this._codeEditorService.openCodeEditor({
      resource: model.uri,
      options: {
        ...options,
        selection: Range.collapseToStart(entry.symbol.selectionRange),
        selectionRevealType: 3
      }
    }, this._editor, sideBySide);
  }
  preview(entry) {
    if (!(entry instanceof OutlineElement)) {
      return Disposable.None;
    }
    const { symbol } = entry;
    this._editor.revealRangeInCenterIfOutsideViewport(symbol.range, 0);
    const decorationsCollection = this._editor.createDecorationsCollection([{
      range: symbol.range,
      options: {
        description: "document-symbols-outline-range-highlight",
        className: "rangeHighlight",
        isWholeLine: true
      }
    }]);
    return toDisposable(() => decorationsCollection.clear());
  }
  captureViewState() {
    const viewState = this._editor.saveViewState();
    return toDisposable(() => {
      if (viewState) {
        this._editor.restoreViewState(viewState);
      }
    });
  }
  async _createOutline(contentChangeEvent) {
    this._outlineDisposables.clear();
    if (!contentChangeEvent) {
      this._setOutlineModel(void 0);
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const buffer = this._editor.getModel();
    if (!this._languageFeaturesService.documentSymbolProvider.has(buffer)) {
      return;
    }
    const cts = new CancellationTokenSource();
    const versionIdThen = buffer.getVersionId();
    const timeoutTimer = new TimeoutTimer();
    this._outlineDisposables.add(timeoutTimer);
    this._outlineDisposables.add(toDisposable(() => cts.dispose(true)));
    try {
      const model = await this._outlineModelService.getOrCreate(buffer, cts.token);
      if (cts.token.isCancellationRequested) {
        return;
      }
      if (TreeElement.empty(model) || !this._editor.hasModel()) {
        this._setOutlineModel(model);
        return;
      }
      if (contentChangeEvent && this._outlineModel && buffer.getLineCount() >= 25) {
        const newSize = TreeElement.size(model);
        const newLength = buffer.getValueLength();
        const newRatio = newSize / newLength;
        const oldSize = TreeElement.size(this._outlineModel);
        const oldLength = newLength - contentChangeEvent.changes.reduce((prev, value) => prev + value.rangeLength, 0);
        const oldRatio = oldSize / oldLength;
        if (newRatio <= oldRatio * 0.5 || newRatio >= oldRatio * 1.5) {
          const value = await raceCancellation(timeout(2e3).then(() => true), cts.token, false);
          if (!value) {
            return;
          }
        }
      }
      this._applyMarkersToOutline(model);
      this._outlineDisposables.add(this._markerDecorationsService.onDidChangeMarker((textModel) => {
        if (isEqual(model.uri, textModel.uri)) {
          this._applyMarkersToOutline(model);
          this._onDidChange.fire({});
        }
      }));
      this._outlineDisposables.add(this._configurationService.onDidChangeConfiguration((e) => {
        if (e.affectsConfiguration("outline.problems.enabled")) {
          if (this._configurationService.getValue("outline.problems.enabled")) {
            this._applyMarkersToOutline(model);
          } else {
            model.updateMarker([]);
          }
          this._onDidChange.fire({});
        }
        if (e.affectsConfiguration("outline")) {
          this._onDidChange.fire({});
        }
        if (e.affectsConfiguration("breadcrumbs") && this._editor.hasModel()) {
          this._breadcrumbsDataSource.update(model, this._editor.getPosition());
          this._onDidChange.fire({});
        }
      }));
      this._outlineDisposables.add(this._configurationService.onDidChangeConfiguration((e) => {
        if (e.affectsConfiguration("outline.icons")) {
          this._onDidChange.fire({});
        }
        if (e.affectsConfiguration("outline")) {
          this._onDidChange.fire({});
        }
      }));
      this._outlineDisposables.add(this._editor.onDidChangeCursorPosition((_) => {
        timeoutTimer.cancelAndSet(() => {
          if (!buffer.isDisposed() && versionIdThen === buffer.getVersionId() && this._editor.hasModel()) {
            this._breadcrumbsDataSource.update(model, this._editor.getPosition());
            this._onDidChange.fire({ affectOnlyActiveElement: true });
          }
        }, 150);
      }));
      this._setOutlineModel(model);
    } catch (err) {
      this._setOutlineModel(void 0);
      onUnexpectedError(err);
    }
  }
  _applyMarkersToOutline(model) {
    if (!model || !this._configurationService.getValue("outline.problems.enabled")) {
      return;
    }
    const markers = [];
    for (const [range2, marker] of this._markerDecorationsService.getLiveMarkers(model.uri)) {
      if (marker.severity === MarkerSeverity.Error || marker.severity === MarkerSeverity.Warning) {
        markers.push({ ...range2, severity: marker.severity });
      }
    }
    model.updateMarker(markers);
  }
  _setOutlineModel(model) {
    var _a2;
    const position = this._editor.getPosition();
    if (!position || !model) {
      this._outlineModel = void 0;
      this._breadcrumbsDataSource.clear();
    } else {
      if (!((_a2 = this._outlineModel) == null ? void 0 : _a2.merge(model))) {
        this._outlineModel = model;
      }
      this._breadcrumbsDataSource.update(model, position);
    }
    this._onDidChange.fire({});
  }
};
DocumentSymbolsOutline = __decorate([
  __param(3, ILanguageFeaturesService),
  __param(4, ICodeEditorService),
  __param(5, IOutlineModelService),
  __param(6, IConfigurationService),
  __param(7, IMarkerDecorationsService),
  __param(8, ITextResourceConfigurationService),
  __param(9, IInstantiationService)
], DocumentSymbolsOutline);
let DocumentSymbolsOutlineCreator = class DocumentSymbolsOutlineCreator2 {
  constructor(outlineService) {
    const reg = outlineService.registerOutlineCreator(this);
    this.dispose = () => reg.dispose();
  }
  matches(candidate) {
    const ctrl = candidate.getControl();
    return isCodeEditor(ctrl) || isDiffEditor(ctrl);
  }
  async createOutline(pane, target, _token) {
    const control = pane.getControl();
    let editor;
    if (isCodeEditor(control)) {
      editor = control;
    } else if (isDiffEditor(control)) {
      editor = control.getModifiedEditor();
    }
    if (!editor) {
      return void 0;
    }
    const firstLoadBarrier = new Barrier();
    const result = editor.invokeWithinContext((accessor) => accessor.get(IInstantiationService).createInstance(DocumentSymbolsOutline, editor, target, firstLoadBarrier));
    await firstLoadBarrier.wait();
    return result;
  }
};
DocumentSymbolsOutlineCreator = __decorate([
  __param(0, IOutlineService)
], DocumentSymbolsOutlineCreator);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(DocumentSymbolsOutlineCreator, 4);
var css$5 = ".monaco-workbench .outline-pane{display:flex;flex-direction:column}.monaco-workbench .outline-pane .outline-progress{height:2px;padding-bottom:3px;position:absolute;width:100%}.monaco-workbench .outline-pane .outline-progress .monaco-progress-container,.monaco-workbench .outline-pane .outline-progress .monaco-progress-container .progress-bit{height:2px}.monaco-workbench .outline-pane .outline-tree{height:100%}.monaco-workbench .outline-pane .outline-message{display:none;opacity:.5;padding:10px 22px 0;pointer-events:none;position:absolute;z-index:1}.monaco-workbench .outline-pane.message .outline-message{display:inherit}.monaco-workbench .outline-pane.message .outline-progress{display:none}";
n(css$5, {});
class OutlineViewState {
  constructor() {
    this._followCursor = false;
    this._filterOnType = true;
    this._sortBy = 0;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._onDidChange.dispose();
  }
  set followCursor(value) {
    if (value !== this._followCursor) {
      this._followCursor = value;
      this._onDidChange.fire({ followCursor: true });
    }
  }
  get followCursor() {
    return this._followCursor;
  }
  get filterOnType() {
    return this._filterOnType;
  }
  set filterOnType(value) {
    if (value !== this._filterOnType) {
      this._filterOnType = value;
      this._onDidChange.fire({ filterOnType: true });
    }
  }
  set sortBy(value) {
    if (value !== this._sortBy) {
      this._sortBy = value;
      this._onDidChange.fire({ sortBy: true });
    }
  }
  get sortBy() {
    return this._sortBy;
  }
  persist(storageService) {
    storageService.store("outline/state", JSON.stringify({
      followCursor: this.followCursor,
      sortBy: this.sortBy,
      filterOnType: this.filterOnType
    }), 1, 1);
  }
  restore(storageService) {
    const raw = storageService.get("outline/state", 1);
    if (!raw) {
      return;
    }
    let data;
    try {
      data = JSON.parse(raw);
    } catch (e) {
      return;
    }
    this.followCursor = data.followCursor;
    this.sortBy = data.sortBy ?? 0;
    if (typeof data.filterOnType === "boolean") {
      this.filterOnType = data.filterOnType;
    }
  }
}
var IOutlinePane;
(function(IOutlinePane2) {
  IOutlinePane2.Id = "outline";
})(IOutlinePane || (IOutlinePane = {}));
const ctxFollowsCursor = new RawContextKey("outlineFollowsCursor", false);
const ctxFilterOnType = new RawContextKey("outlineFiltersOnType", false);
const ctxSortMode = new RawContextKey("outlineSortMode", 0);
const ctxAllCollapsed = new RawContextKey("outlineAllCollapsed", false);
class OutlineTreeSorter2 {
  constructor(_comparator, order) {
    this._comparator = _comparator;
    this.order = order;
  }
  compare(a, b) {
    if (this.order === 2) {
      return this._comparator.compareByType(a, b);
    } else if (this.order === 1) {
      return this._comparator.compareByName(a, b);
    } else {
      return this._comparator.compareByPosition(a, b);
    }
  }
}
let OutlinePane = (_s = class extends ViewPane {
  constructor(options, _outlineService, _instantiationService, viewDescriptorService, _storageService, _editorService, configurationService, keybindingService, contextKeyService, contextMenuService, openerService, themeService, telemetryService) {
    super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, _instantiationService, openerService, themeService, telemetryService);
    this._outlineService = _outlineService;
    this._instantiationService = _instantiationService;
    this._storageService = _storageService;
    this._editorService = _editorService;
    this._disposables = new DisposableStore();
    this._editorControlDisposables = new DisposableStore();
    this._editorPaneDisposables = new DisposableStore();
    this._outlineViewState = new OutlineViewState();
    this._editorListener = new MutableDisposable();
    this._treeStates = new LRUCache(10);
    this._outlineViewState.restore(this._storageService);
    this._disposables.add(this._outlineViewState);
    contextKeyService.bufferChangeEvents(() => {
      this._ctxFollowsCursor = ctxFollowsCursor.bindTo(contextKeyService);
      this._ctxFilterOnType = ctxFilterOnType.bindTo(contextKeyService);
      this._ctxSortMode = ctxSortMode.bindTo(contextKeyService);
      this._ctxAllCollapsed = ctxAllCollapsed.bindTo(contextKeyService);
    });
    const updateContext = () => {
      this._ctxFollowsCursor.set(this._outlineViewState.followCursor);
      this._ctxFilterOnType.set(this._outlineViewState.filterOnType);
      this._ctxSortMode.set(this._outlineViewState.sortBy);
    };
    updateContext();
    this._disposables.add(this._outlineViewState.onDidChange(updateContext));
  }
  dispose() {
    this._disposables.dispose();
    this._editorPaneDisposables.dispose();
    this._editorControlDisposables.dispose();
    this._editorListener.dispose();
    super.dispose();
  }
  focus() {
    var _a2;
    (_a2 = this._tree) == null ? void 0 : _a2.domFocus();
  }
  renderBody(container) {
    super.renderBody(container);
    this._domNode = container;
    container.classList.add("outline-pane");
    const progressContainer = $$2(".outline-progress");
    this._message = $$2(".outline-message");
    this._progressBar = new ProgressBar(progressContainer, defaultProgressBarStyles);
    this._treeContainer = $$2(".outline-tree");
    append(container, progressContainer, this._message, this._treeContainer);
    this._disposables.add(this.onDidChangeBodyVisibility((visible) => {
      if (!visible) {
        this._editorListener.clear();
        this._editorPaneDisposables.clear();
        this._editorControlDisposables.clear();
      } else if (!this._editorListener.value) {
        const event = Event.any(this._editorService.onDidActiveEditorChange, this._outlineService.onDidChange);
        this._editorListener.value = event(() => this._handleEditorChanged(this._editorService.activeEditorPane));
        this._handleEditorChanged(this._editorService.activeEditorPane);
      }
    }));
  }
  layoutBody(height, width) {
    var _a2;
    super.layoutBody(height, width);
    (_a2 = this._tree) == null ? void 0 : _a2.layout(height, width);
    this._treeDimensions = new Dimension(width, height);
  }
  collapseAll() {
    var _a2;
    (_a2 = this._tree) == null ? void 0 : _a2.collapseAll();
  }
  expandAll() {
    var _a2;
    (_a2 = this._tree) == null ? void 0 : _a2.expandAll();
  }
  get outlineViewState() {
    return this._outlineViewState;
  }
  _showMessage(message) {
    this._domNode.classList.add("message");
    this._progressBar.stop().hide();
    this._message.innerText = message;
  }
  _captureViewState(uri) {
    if (this._tree) {
      const oldOutline = this._tree.getInput();
      if (!uri) {
        uri = oldOutline == null ? void 0 : oldOutline.uri;
      }
      if (oldOutline && uri) {
        this._treeStates.set(`${oldOutline.outlineKind}/${uri}`, this._tree.getViewState());
        return true;
      }
    }
    return false;
  }
  _handleEditorChanged(pane) {
    this._editorPaneDisposables.clear();
    if (pane) {
      this._editorPaneDisposables.add(pane.onDidChangeControl(() => {
        this._handleEditorControlChanged(pane);
      }));
    }
    this._handleEditorControlChanged(pane);
  }
  async _handleEditorControlChanged(pane) {
    var _a2, _b2;
    const resource = EditorResourceAccessor.getOriginalUri(pane == null ? void 0 : pane.input);
    const didCapture = this._captureViewState();
    this._editorControlDisposables.clear();
    if (!pane || !this._outlineService.canCreateOutline(pane) || !resource) {
      return this._showMessage(localize("no-editor", "The active editor cannot provide outline information."));
    }
    let loadingMessage;
    if (!didCapture) {
      loadingMessage = new TimeoutTimer(() => {
        this._showMessage(localize("loading", "Loading document symbols for '{0}'...", basename(resource)));
      }, 100);
    }
    this._progressBar.infinite().show(500);
    const cts = new CancellationTokenSource();
    this._editorControlDisposables.add(toDisposable(() => cts.dispose(true)));
    const newOutline = await this._outlineService.createOutline(pane, 1, cts.token);
    loadingMessage == null ? void 0 : loadingMessage.dispose();
    if (!newOutline) {
      return;
    }
    if (cts.token.isCancellationRequested) {
      newOutline == null ? void 0 : newOutline.dispose();
      return;
    }
    this._editorControlDisposables.add(newOutline);
    this._progressBar.stop().hide();
    const sorter = new OutlineTreeSorter2(newOutline.config.comparator, this._outlineViewState.sortBy);
    const tree = this._instantiationService.createInstance(WorkbenchDataTree, "OutlinePane", this._treeContainer, newOutline.config.delegate, newOutline.config.renderers, newOutline.config.treeDataSource, {
      ...newOutline.config.options,
      sorter,
      expandOnDoubleClick: false,
      expandOnlyOnTwistieClick: true,
      multipleSelectionSupport: false,
      hideTwistiesOfChildlessElements: true,
      defaultFindMode: this._outlineViewState.filterOnType ? TreeFindMode.Filter : TreeFindMode.Highlight,
      overrideStyles: { listBackground: this.getBackgroundColor() }
    });
    const updateTree = () => {
      if (newOutline.isEmpty) {
        this._showMessage(localize("no-symbols", "No symbols found in document '{0}'", basename(resource)));
        this._captureViewState(resource);
        tree.setInput(void 0);
      } else if (!tree.getInput()) {
        this._domNode.classList.remove("message");
        const state = this._treeStates.get(`${newOutline.outlineKind}/${newOutline.uri}`);
        tree.setInput(newOutline, state && AbstractTreeViewState.lift(state));
      } else {
        this._domNode.classList.remove("message");
        tree.updateChildren();
      }
    };
    updateTree();
    this._editorControlDisposables.add(newOutline.onDidChange(updateTree));
    tree.findMode = this._outlineViewState.filterOnType ? TreeFindMode.Filter : TreeFindMode.Highlight;
    this._editorControlDisposables.add(this.viewDescriptorService.onDidChangeLocation(({ views }) => {
      if (views.some((v) => v.id === this.id)) {
        tree.updateOptions({ overrideStyles: { listBackground: this.getBackgroundColor() } });
      }
    }));
    this._editorControlDisposables.add(tree.onDidChangeFindMode((mode) => this._outlineViewState.filterOnType = mode === TreeFindMode.Filter));
    this._editorControlDisposables.add(tree.onDidOpen((e) => newOutline.reveal(e.element, e.editorOptions, e.sideBySide)));
    const revealActiveElement = () => {
      if (!this._outlineViewState.followCursor || !newOutline.activeElement) {
        return;
      }
      let item = newOutline.activeElement;
      while (item) {
        const top = tree.getRelativeTop(item);
        if (top === null) {
          tree.reveal(item, 0.5);
        }
        if (tree.getRelativeTop(item) !== null) {
          tree.setFocus([item]);
          tree.setSelection([item]);
          break;
        }
        item = tree.getParentElement(item);
      }
    };
    revealActiveElement();
    this._editorControlDisposables.add(newOutline.onDidChange(revealActiveElement));
    this._editorControlDisposables.add(this._outlineViewState.onDidChange((e) => {
      this._outlineViewState.persist(this._storageService);
      if (e.filterOnType) {
        tree.findMode = this._outlineViewState.filterOnType ? TreeFindMode.Filter : TreeFindMode.Highlight;
      }
      if (e.followCursor) {
        revealActiveElement();
      }
      if (e.sortBy) {
        sorter.order = this._outlineViewState.sortBy;
        tree.resort();
      }
    }));
    let viewState;
    this._editorControlDisposables.add(tree.onDidChangeFindPattern((pattern) => {
      if (tree.findMode === TreeFindMode.Highlight) {
        return;
      }
      if (!viewState && pattern) {
        viewState = tree.getViewState();
        tree.expandAll();
      } else if (!pattern && viewState) {
        tree.setInput(tree.getInput(), viewState);
        viewState = void 0;
      }
    }));
    const updateAllCollapsedCtx = () => {
      this._ctxAllCollapsed.set(tree.getNode(null).children.every((node) => !node.collapsible || node.collapsed));
    };
    this._editorControlDisposables.add(tree.onDidChangeCollapseState(updateAllCollapsedCtx));
    this._editorControlDisposables.add(tree.onDidChangeModel(updateAllCollapsedCtx));
    updateAllCollapsedCtx();
    tree.layout((_a2 = this._treeDimensions) == null ? void 0 : _a2.height, (_b2 = this._treeDimensions) == null ? void 0 : _b2.width);
    this._tree = tree;
    this._editorControlDisposables.add(toDisposable(() => {
      tree.dispose();
      this._tree = void 0;
    }));
  }
}, _s.Id = "outline", _s);
OutlinePane = __decorate([
  __param(1, IOutlineService),
  __param(2, IInstantiationService),
  __param(3, IViewDescriptorService),
  __param(4, IStorageService),
  __param(5, IEditorService),
  __param(6, IConfigurationService),
  __param(7, IKeybindingService),
  __param(8, IContextKeyService),
  __param(9, IContextMenuService),
  __param(10, IOpenerService),
  __param(11, IThemeService),
  __param(12, ITelemetryService)
], OutlinePane);
const outlineViewIcon = registerIcon("outline-view-icon", Codicon.symbolClass, localize("outlineViewIcon", "View icon of the outline view."));
Registry.as(Extensions$1.ViewsRegistry).registerViews([{
  id: IOutlinePane.Id,
  name: localize("name", "Outline"),
  containerIcon: outlineViewIcon,
  ctorDescriptor: new SyncDescriptor(OutlinePane),
  canToggleVisibility: true,
  canMoveView: true,
  hideByDefault: false,
  collapsed: true,
  order: 2,
  weight: 30,
  focusCommand: { id: "outline.focus" }
}], VIEW_CONTAINER);
Registry.as(Extensions$4.Configuration).registerConfiguration({
  "id": "outline",
  "order": 117,
  "title": localize("outlineConfigurationTitle", "Outline"),
  "type": "object",
  "properties": {
    ["outline.icons"]: {
      "description": localize("outline.showIcons", "Render Outline elements with icons."),
      "type": "boolean",
      "default": true
    },
    ["outline.collapseItems"]: {
      "description": localize(
        "outline.initialState",
        "Controls whether Outline items are collapsed or expanded."
      ),
      "type": "string",
      scope: 5,
      "enum": [
        "alwaysCollapse",
        "alwaysExpand"
      ],
      "enumDescriptions": [
        localize("outline.initialState.collapsed", "Collapse all items."),
        localize("outline.initialState.expanded", "Expand all items.")
      ],
      "default": "alwaysExpand"
    },
    ["outline.problems.enabled"]: {
      "description": localize("outline.showProblem", "Show errors and warnings on Outline elements."),
      "type": "boolean",
      "default": true
    },
    ["outline.problems.colors"]: {
      "description": localize(
        "outline.problem.colors",
        "Use colors for errors and warnings on Outline elements."
      ),
      "type": "boolean",
      "default": true
    },
    ["outline.problems.badges"]: {
      "description": localize(
        "outline.problems.badges",
        "Use badges for errors and warnings on Outline elements."
      ),
      "type": "boolean",
      "default": true
    },
    "outline.showFiles": {
      type: "boolean",
      scope: 5,
      default: true,
      markdownDescription: localize("filteredTypes.file", "When enabled, Outline shows `file`-symbols.")
    },
    "outline.showModules": {
      type: "boolean",
      scope: 5,
      default: true,
      markdownDescription: localize("filteredTypes.module", "When enabled, Outline shows `module`-symbols.")
    },
    "outline.showNamespaces": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.namespace",
        "When enabled, Outline shows `namespace`-symbols."
      )
    },
    "outline.showPackages": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.package", "When enabled, Outline shows `package`-symbols.")
    },
    "outline.showClasses": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.class", "When enabled, Outline shows `class`-symbols.")
    },
    "outline.showMethods": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.method", "When enabled, Outline shows `method`-symbols.")
    },
    "outline.showProperties": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.property",
        "When enabled, Outline shows `property`-symbols."
      )
    },
    "outline.showFields": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.field", "When enabled, Outline shows `field`-symbols.")
    },
    "outline.showConstructors": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.constructor",
        "When enabled, Outline shows `constructor`-symbols."
      )
    },
    "outline.showEnums": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.enum", "When enabled, Outline shows `enum`-symbols.")
    },
    "outline.showInterfaces": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.interface",
        "When enabled, Outline shows `interface`-symbols."
      )
    },
    "outline.showFunctions": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.function",
        "When enabled, Outline shows `function`-symbols."
      )
    },
    "outline.showVariables": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.variable",
        "When enabled, Outline shows `variable`-symbols."
      )
    },
    "outline.showConstants": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.constant",
        "When enabled, Outline shows `constant`-symbols."
      )
    },
    "outline.showStrings": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.string", "When enabled, Outline shows `string`-symbols.")
    },
    "outline.showNumbers": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.number", "When enabled, Outline shows `number`-symbols.")
    },
    "outline.showBooleans": {
      type: "boolean",
      scope: 5,
      default: true,
      markdownDescription: localize("filteredTypes.boolean", "When enabled, Outline shows `boolean`-symbols.")
    },
    "outline.showArrays": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.array", "When enabled, Outline shows `array`-symbols.")
    },
    "outline.showObjects": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.object", "When enabled, Outline shows `object`-symbols.")
    },
    "outline.showKeys": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.key", "When enabled, Outline shows `key`-symbols.")
    },
    "outline.showNull": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.null", "When enabled, Outline shows `null`-symbols.")
    },
    "outline.showEnumMembers": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.enumMember",
        "When enabled, Outline shows `enumMember`-symbols."
      )
    },
    "outline.showStructs": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.struct", "When enabled, Outline shows `struct`-symbols.")
    },
    "outline.showEvents": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize("filteredTypes.event", "When enabled, Outline shows `event`-symbols.")
    },
    "outline.showOperators": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.operator",
        "When enabled, Outline shows `operator`-symbols."
      )
    },
    "outline.showTypeParameters": {
      type: "boolean",
      default: true,
      scope: 5,
      markdownDescription: localize(
        "filteredTypes.typeParameter",
        "When enabled, Outline shows `typeParameter`-symbols."
      )
    }
  }
});
function ensureDOMFocus(widget) {
  if (widget && widget.getHTMLElement() !== document.activeElement) {
    widget.domFocus();
  }
}
async function updateFocus(widget, updateFocusFn) {
  if (!WorkbenchListSelectionNavigation.getValue(widget.contextKeyService)) {
    return updateFocusFn(widget);
  }
  const focus = widget.getFocus();
  const selection = widget.getSelection();
  await updateFocusFn(widget);
  const newFocus = widget.getFocus();
  if (selection.length > 1 || !equals(focus, selection) || equals(focus, newFocus)) {
    return;
  }
  const fakeKeyboardEvent = new KeyboardEvent("keydown");
  widget.setSelection(newFocus, fakeKeyboardEvent);
}
async function navigate(widget, updateFocusFn) {
  if (!widget) {
    return;
  }
  await updateFocus(widget, updateFocusFn);
  const listFocus = widget.getFocus();
  if (listFocus.length) {
    widget.reveal(listFocus[0]);
  }
  widget.setAnchor(listFocus[0]);
  ensureDOMFocus(widget);
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.focusDown",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 18,
  mac: {
    primary: 18,
    secondary: [256 | 44]
  },
  handler: (accessor, arg2) => {
    navigate(accessor.get(IListService).lastFocusedList, async (widget) => {
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      await widget.focusNext(typeof arg2 === "number" ? arg2 : 1, false, fakeKeyboardEvent);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.focusUp",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 16,
  mac: {
    primary: 16,
    secondary: [256 | 46]
  },
  handler: (accessor, arg2) => {
    navigate(accessor.get(IListService).lastFocusedList, async (widget) => {
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      await widget.focusPrevious(typeof arg2 === "number" ? arg2 : 1, false, fakeKeyboardEvent);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.focusPageDown",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 12,
  handler: (accessor) => {
    navigate(accessor.get(IListService).lastFocusedList, async (widget) => {
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      await widget.focusNextPage(fakeKeyboardEvent);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.focusPageUp",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 11,
  handler: (accessor) => {
    navigate(accessor.get(IListService).lastFocusedList, async (widget) => {
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      await widget.focusPreviousPage(fakeKeyboardEvent);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.focusFirst",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 14,
  handler: (accessor) => {
    navigate(accessor.get(IListService).lastFocusedList, async (widget) => {
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      await widget.focusFirst(fakeKeyboardEvent);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.focusLast",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 13,
  handler: (accessor) => {
    navigate(accessor.get(IListService).lastFocusedList, async (widget) => {
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      await widget.focusLast(fakeKeyboardEvent);
    });
  }
});
function expandMultiSelection(focused, previousFocus) {
  if (focused instanceof List || focused instanceof PagedList || focused instanceof Table) {
    const list = focused;
    const focus = list.getFocus() ? list.getFocus()[0] : void 0;
    const selection = list.getSelection();
    if (selection && typeof focus === "number" && selection.indexOf(focus) >= 0) {
      list.setSelection(selection.filter((s) => s !== previousFocus));
    } else {
      if (typeof focus === "number") {
        list.setSelection(selection.concat(focus));
      }
    }
  } else if (focused instanceof ObjectTree || focused instanceof DataTree || focused instanceof AsyncDataTree) {
    const list = focused;
    const focus = list.getFocus() ? list.getFocus()[0] : void 0;
    if (previousFocus === focus) {
      return;
    }
    const selection = list.getSelection();
    const fakeKeyboardEvent = new KeyboardEvent("keydown", { shiftKey: true });
    if (selection && selection.indexOf(focus) >= 0) {
      list.setSelection(selection.filter((s) => s !== previousFocus), fakeKeyboardEvent);
    } else {
      list.setSelection(selection.concat(focus), fakeKeyboardEvent);
    }
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.expandSelectionDown",
  weight: 200,
  when: ContextKeyExpr.and(WorkbenchListFocusContextKey, WorkbenchListSupportsMultiSelectContextKey),
  primary: 1024 | 18,
  handler: (accessor, arg2) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (!widget) {
      return;
    }
    const previousFocus = widget.getFocus() ? widget.getFocus()[0] : void 0;
    const fakeKeyboardEvent = new KeyboardEvent("keydown");
    widget.focusNext(typeof arg2 === "number" ? arg2 : 1, false, fakeKeyboardEvent);
    expandMultiSelection(widget, previousFocus);
    const focus = widget.getFocus();
    if (focus.length) {
      widget.reveal(focus[0]);
    }
    ensureDOMFocus(widget);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.expandSelectionUp",
  weight: 200,
  when: ContextKeyExpr.and(WorkbenchListFocusContextKey, WorkbenchListSupportsMultiSelectContextKey),
  primary: 1024 | 16,
  handler: (accessor, arg2) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (!widget) {
      return;
    }
    const previousFocus = widget.getFocus() ? widget.getFocus()[0] : void 0;
    const fakeKeyboardEvent = new KeyboardEvent("keydown");
    widget.focusPrevious(typeof arg2 === "number" ? arg2 : 1, false, fakeKeyboardEvent);
    expandMultiSelection(widget, previousFocus);
    const focus = widget.getFocus();
    if (focus.length) {
      widget.reveal(focus[0]);
    }
    ensureDOMFocus(widget);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.collapse",
  weight: 200,
  when: ContextKeyExpr.and(WorkbenchListFocusContextKey, ContextKeyExpr.or(WorkbenchTreeElementCanCollapse, WorkbenchTreeElementHasParent)),
  primary: 15,
  mac: {
    primary: 15,
    secondary: [2048 | 16]
  },
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (!widget || !(widget instanceof ObjectTree || widget instanceof DataTree || widget instanceof AsyncDataTree)) {
      return;
    }
    const tree = widget;
    const focusedElements = tree.getFocus();
    if (focusedElements.length === 0) {
      return;
    }
    const focus = focusedElements[0];
    if (!tree.collapse(focus)) {
      const parent = tree.getParentElement(focus);
      if (parent) {
        navigate(widget, (widget2) => {
          const fakeKeyboardEvent = new KeyboardEvent("keydown");
          widget2.setFocus([parent], fakeKeyboardEvent);
        });
      }
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.collapseAll",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 2048 | 15,
  mac: {
    primary: 2048 | 15,
    secondary: [2048 | 1024 | 16]
  },
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    if (focused && !(focused instanceof List || focused instanceof PagedList || focused instanceof Table)) {
      focused.collapseAll();
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.collapseAllToFocus",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    const fakeKeyboardEvent = getSelectionKeyboardEvent("keydown", true);
    if (focused instanceof ObjectTree || focused instanceof DataTree || focused instanceof AsyncDataTree) {
      const tree = focused;
      const focus = tree.getFocus();
      if (focus.length > 0) {
        tree.collapse(focus[0], true);
      }
      tree.setSelection(focus, fakeKeyboardEvent);
      tree.setAnchor(focus[0]);
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.focusParent",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (!widget || !(widget instanceof ObjectTree || widget instanceof DataTree || widget instanceof AsyncDataTree)) {
      return;
    }
    const tree = widget;
    const focusedElements = tree.getFocus();
    if (focusedElements.length === 0) {
      return;
    }
    const focus = focusedElements[0];
    const parent = tree.getParentElement(focus);
    if (parent) {
      navigate(widget, (widget2) => {
        const fakeKeyboardEvent = new KeyboardEvent("keydown");
        widget2.setFocus([parent], fakeKeyboardEvent);
      });
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.expand",
  weight: 200,
  when: ContextKeyExpr.and(WorkbenchListFocusContextKey, ContextKeyExpr.or(WorkbenchTreeElementCanExpand, WorkbenchTreeElementHasChild)),
  primary: 17,
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (!widget) {
      return;
    }
    if (widget instanceof ObjectTree || widget instanceof DataTree) {
      const focusedElements = widget.getFocus();
      if (focusedElements.length === 0) {
        return;
      }
      const focus = focusedElements[0];
      if (!widget.expand(focus)) {
        const child = widget.getFirstElementChild(focus);
        if (child) {
          const node = widget.getNode(child);
          if (node.visible) {
            navigate(widget, (widget2) => {
              const fakeKeyboardEvent = new KeyboardEvent("keydown");
              widget2.setFocus([child], fakeKeyboardEvent);
            });
          }
        }
      }
    } else if (widget instanceof AsyncDataTree) {
      const focusedElements = widget.getFocus();
      if (focusedElements.length === 0) {
        return;
      }
      const focus = focusedElements[0];
      widget.expand(focus).then((didExpand) => {
        if (focus && !didExpand) {
          const child = widget.getFirstElementChild(focus);
          if (child) {
            const node = widget.getNode(child);
            if (node.visible) {
              navigate(widget, (widget2) => {
                const fakeKeyboardEvent = new KeyboardEvent("keydown");
                widget2.setFocus([child], fakeKeyboardEvent);
              });
            }
          }
        }
      });
    }
  }
});
function selectElement(accessor, retainCurrentFocus) {
  const focused = accessor.get(IListService).lastFocusedList;
  const fakeKeyboardEvent = getSelectionKeyboardEvent("keydown", retainCurrentFocus);
  if (focused instanceof List || focused instanceof PagedList || focused instanceof Table) {
    const list = focused;
    list.setSelection(list.getFocus(), fakeKeyboardEvent);
    list.setAnchor(list.getFocus()[0]);
  } else if (focused instanceof ObjectTree || focused instanceof DataTree || focused instanceof AsyncDataTree) {
    const tree = focused;
    const focus = tree.getFocus();
    if (focus.length > 0) {
      let toggleCollapsed = true;
      if (tree.expandOnlyOnTwistieClick === true) {
        toggleCollapsed = false;
      } else if (typeof tree.expandOnlyOnTwistieClick !== "boolean" && tree.expandOnlyOnTwistieClick(focus[0])) {
        toggleCollapsed = false;
      }
      if (toggleCollapsed) {
        tree.toggleCollapsed(focus[0]);
      }
    }
    tree.setSelection(focus, fakeKeyboardEvent);
    tree.setAnchor(focus[0]);
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.select",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [2048 | 18]
  },
  handler: (accessor) => {
    selectElement(accessor, false);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.selectAndPreserveFocus",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  handler: (accessor) => {
    selectElement(accessor, true);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.selectAll",
  weight: 200,
  when: ContextKeyExpr.and(WorkbenchListFocusContextKey, WorkbenchListSupportsMultiSelectContextKey),
  primary: 2048 | 31,
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    if (focused instanceof List || focused instanceof PagedList || focused instanceof Table) {
      const list = focused;
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      list.setSelection(range(list.length), fakeKeyboardEvent);
    } else if (focused instanceof ObjectTree || focused instanceof DataTree || focused instanceof AsyncDataTree) {
      const tree = focused;
      const focus = tree.getFocus();
      const selection = tree.getSelection();
      let start = void 0;
      if (focus.length > 0 && (selection.length === 0 || !selection.includes(focus[0]))) {
        start = focus[0];
      }
      if (!start && selection.length > 0) {
        start = selection[0];
      }
      let scope = void 0;
      if (!start) {
        scope = void 0;
      } else {
        scope = tree.getParentElement(start);
      }
      const newSelection = [];
      const visit = (node) => {
        for (const child of node.children) {
          if (child.visible) {
            newSelection.push(child.element);
            if (!child.collapsed) {
              visit(child);
            }
          }
        }
      };
      visit(tree.getNode(scope));
      if (scope && selection.length === newSelection.length) {
        newSelection.unshift(scope);
      }
      const fakeKeyboardEvent = new KeyboardEvent("keydown");
      tree.setSelection(newSelection, fakeKeyboardEvent);
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.toggleSelection",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 2048 | 1024 | 3,
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (!widget) {
      return;
    }
    const focus = widget.getFocus();
    if (focus.length === 0) {
      return;
    }
    const selection = widget.getSelection();
    const index = selection.indexOf(focus[0]);
    if (index > -1) {
      widget.setSelection([...selection.slice(0, index), ...selection.slice(index + 1)]);
    } else {
      widget.setSelection([...selection, focus[0]]);
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.toggleExpand",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  primary: 10,
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    if (focused instanceof ObjectTree || focused instanceof DataTree || focused instanceof AsyncDataTree) {
      const tree = focused;
      const focus = tree.getFocus();
      if (focus.length > 0 && tree.isCollapsible(focus[0])) {
        tree.toggleCollapsed(focus[0]);
        return;
      }
    }
    selectElement(accessor, true);
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.clear",
  weight: 200,
  when: ContextKeyExpr.and(WorkbenchListFocusContextKey, WorkbenchListHasSelectionOrFocus),
  primary: 9,
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (!widget) {
      return;
    }
    const selection = widget.getSelection();
    const fakeKeyboardEvent = new KeyboardEvent("keydown");
    if (selection.length > 1) {
      const useSelectionNavigation = WorkbenchListSelectionNavigation.getValue(widget.contextKeyService);
      if (useSelectionNavigation) {
        const focus = widget.getFocus();
        widget.setSelection([focus[0]], fakeKeyboardEvent);
      } else {
        widget.setSelection([], fakeKeyboardEvent);
      }
    } else {
      widget.setSelection([], fakeKeyboardEvent);
      widget.setFocus([], fakeKeyboardEvent);
    }
    widget.setAnchor(void 0);
  }
});
CommandsRegistry.registerCommand({
  id: "list.triggerTypeNavigation",
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    widget == null ? void 0 : widget.triggerTypeNavigation();
  }
});
CommandsRegistry.registerCommand({
  id: "list.toggleFindMode",
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (widget instanceof AbstractTree || widget instanceof AsyncDataTree) {
      const tree = widget;
      tree.findMode = tree.findMode === TreeFindMode.Filter ? TreeFindMode.Highlight : TreeFindMode.Filter;
    }
  }
});
CommandsRegistry.registerCommandAlias("list.toggleKeyboardNavigation", "list.triggerTypeNavigation");
CommandsRegistry.registerCommandAlias("list.toggleFilterOnType", "list.toggleFindMode");
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.find",
  weight: 200,
  when: ContextKeyExpr.and(RawWorkbenchListFocusContextKey, WorkbenchListSupportsFind),
  primary: 2048 | 36,
  secondary: [61],
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (widget instanceof List || widget instanceof PagedList || widget instanceof Table)
      ;
    else if (widget instanceof AbstractTree || widget instanceof AsyncDataTree) {
      const tree = widget;
      tree.openFind();
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.closeFind",
  weight: 200,
  when: ContextKeyExpr.and(RawWorkbenchListFocusContextKey, WorkbenchTreeFindOpen),
  primary: 9,
  handler: (accessor) => {
    const widget = accessor.get(IListService).lastFocusedList;
    if (widget instanceof AbstractTree || widget instanceof AsyncDataTree) {
      const tree = widget;
      tree.closeFind();
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.scrollUp",
  weight: 200,
  when: ContextKeyExpr.and(WorkbenchListFocusContextKey, (_t = WorkbenchListScrollAtTopContextKey) == null ? void 0 : _t.negate()),
  primary: 2048 | 16,
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    if (!focused) {
      return;
    }
    focused.scrollTop -= 10;
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.scrollDown",
  weight: 200,
  when: ContextKeyExpr.and(
    WorkbenchListFocusContextKey,
    (_u = WorkbenchListScrollAtBottomContextKey) == null ? void 0 : _u.negate()
  ),
  primary: 2048 | 18,
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    if (!focused) {
      return;
    }
    focused.scrollTop += 10;
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.scrollLeft",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    if (!focused) {
      return;
    }
    focused.scrollLeft -= 10;
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "list.scrollRight",
  weight: 200,
  when: WorkbenchListFocusContextKey,
  handler: (accessor) => {
    const focused = accessor.get(IListService).lastFocusedList;
    if (!focused) {
      return;
    }
    focused.scrollLeft += 10;
  }
});
var css$4 = '.file-icon-themable-tree .align-icon-with-twisty .monaco-tl-twistie:not(.force-twistie):not(.collapsible),.file-icon-themable-tree .monaco-tl-twistie.force-no-twistie,.file-icon-themable-tree.align-icons-and-twisties .monaco-tl-twistie:not(.force-twistie):not(.collapsible),.file-icon-themable-tree.hide-arrows .monaco-tl-twistie:not(.force-twistie){background-image:none!important;padding-right:0!important;visibility:hidden;width:0!important}.file-icon-themable-tree .monaco-list-row .content .monaco-highlighted-label .highlight,.monaco-tl-contents .monaco-highlighted-label .highlight{background-color:var(--vscode-list-filterMatchBackground);color:unset!important;outline:1px dotted var(--vscode-list-filterMatchBorder);outline-offset:-1px}.monaco-workbench .tree-explorer-viewlet-tree-view{height:100%}.monaco-workbench .tree-explorer-viewlet-tree-view .message{display:flex;padding:4px 12px 4px 18px;user-select:text;-webkit-user-select:text}.monaco-workbench .tree-explorer-viewlet-tree-view .message p{margin-bottom:0;margin-top:0;padding-bottom:4px}.monaco-workbench .tree-explorer-viewlet-tree-view .message ul{padding-left:24px}.monaco-workbench .tree-explorer-viewlet-tree-view .message a{color:var(--vscode-textLink-foreground)}.monaco-workbench .tree-explorer-viewlet-tree-view .message.hide{display:none}.monaco-workbench .tree-explorer-viewlet-tree-view .customview-tree{height:100%}.monaco-workbench .tree-explorer-viewlet-tree-view .customview-tree.hide{display:none}.monaco-workbench .pane>.pane-body>.welcome-view{box-sizing:border-box;display:flex;flex-direction:column;height:100%;width:100%}.monaco-workbench .pane>.pane-body.welcome>:not(.welcome-view),.monaco-workbench .pane>.pane-body:not(.welcome)>.welcome-view{display:none}.monaco-workbench .pane>.pane-body .welcome-view-content{align-items:center;box-sizing:border-box;display:flex;flex-direction:column;padding:0 20px 1em}.monaco-workbench .pane>.pane-body .welcome-view-content>.button-container{max-width:300px;width:100%}.monaco-workbench:not(.reduce-motion) .pane>.pane-body .welcome-view-content>.button-container{transition:max-width .2s ease-out}.monaco-workbench .pane>.pane-body .welcome-view-content.wide>.button-container{max-width:100%}.monaco-workbench .pane>.pane-body .welcome-view-content>.button-container>.monaco-button{max-width:300px}.monaco-workbench .pane>.pane-body .welcome-view-content>p{width:100%}.monaco-workbench .pane>.pane-body .welcome-view-content>*{margin-block-end:0;margin-block-start:1em;margin-inline-end:0;margin-inline-start:0}.customview-tree .monaco-list-row .monaco-tl-contents.align-icon-with-twisty:before{display:none}.customview-tree .monaco-list-row .monaco-tl-contents:not(.align-icon-with-twisty):before{display:inline-block}.customview-tree .monaco-list .monaco-list-row{padding-left:0;padding-right:12px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item{display:flex;flex:1;flex-wrap:nowrap;height:22px;line-height:22px;overflow:hidden;padding-left:3px;text-overflow:ellipsis}.customview-tree .monaco-list .monaco-list-row.selected .custom-view-tree-node-item .custom-view-tree-node-item-checkbox{background-color:var(--vscode-checkbox-selectBackground);border:1px solid var(--vscode-checkbox-selectBorder)}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-checkbox{background-color:var(--vscode-checkbox-background);border:1px solid var(--vscode-checkbox-border);height:16px;margin:3px 6px 3px 0;opacity:1;padding:0;width:16px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-checkbox.codicon{font-size:13px;line-height:15px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .monaco-inputbox{flex:1;line-height:normal}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-resourceLabel{flex:1;overflow:hidden;text-overflow:ellipsis}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .monaco-icon-label-container:after{content:"";display:block}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon,.timeline-tree-view .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-icon{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;align-items:center;background-position:0;background-repeat:no-repeat;background-size:16px;display:flex;height:22px;justify-content:center;padding-right:6px;width:16px}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon.disabled{opacity:.6}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon.codicon.codicon-modifier-spin{margin-left:-6px;padding-left:6px}.customview-tree .monaco-list .monaco-list-row.selected .custom-view-tree-node-item>.custom-view-tree-node-item-resourceLabel>.custom-view-tree-node-item-icon.codicon{color:currentColor!important}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-resourceLabel .monaco-icon-label-container>.monaco-icon-name-container{flex:1}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .custom-view-tree-node-item-resourceLabel:after{margin-right:4px;padding-right:0}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .actions{display:none}.customview-tree .monaco-list .monaco-list-row .custom-view-tree-node-item .actions .action-label{padding:2px}.customview-tree .monaco-list .monaco-list-row.focused .custom-view-tree-node-item .actions,.customview-tree .monaco-list .monaco-list-row.selected .custom-view-tree-node-item .actions,.customview-tree .monaco-list .monaco-list-row:hover .custom-view-tree-node-item .actions{display:block}.viewpane-filter-container{cursor:default;display:flex}.viewpane-filter-container.grow{flex:1}.viewpane-filter-container>.viewpane-filter{align-items:center;display:flex;flex:1;position:relative}.viewpane-filter-container>.viewpane-filter .monaco-inputbox{flex:1;font-size:12px;height:24px}.pane-header .viewpane-filter-container>.viewpane-filter .monaco-inputbox .monaco-inputbox{height:20px;line-height:18px}.monaco-workbench.vs .viewpane-filter-container>.viewpane-filter .monaco-inputbox{height:25px}.viewpane-filter-container>.viewpane-filter>.viewpane-filter-controls{align-items:center;bottom:0;display:flex;position:absolute;right:0;top:0}.viewpane-filter-container>.viewpane-filter>.viewpane-filter-controls>.viewpane-filter-badge{border-radius:2px;margin:4px 0;padding:0 8px}.viewpane-filter.small>.viewpane-filter-controls>.viewpane-filter-badge,.viewpane-filter>.viewpane-filter-controls>.viewpane-filter-badge.hidden{display:none}.viewpane-filter>.viewpane-filter-controls>.monaco-action-bar .action-item .action-label.codicon.filter{padding:2px}.panel>.title .monaco-action-bar .action-item.viewpane-filter-container{margin-right:10px;max-width:400px;min-width:150px}.pane-body .viewpane-filter-container:not(:empty){flex:1;height:auto;margin:10px 20px}.pane-body .viewpane-filter-container>.viewpane-filter>.viewpane-filter-controls .monaco-action-bar .action-item{margin-right:4px}.viewpane-filter>.viewpane-filter-controls .monaco-action-bar .action-label.codicon.codicon-filter.checked{background-color:var(--vscode-inputOption-activeBackground);border-color:var(--vscode-inputOption-activeBorder);color:var(--vscode-inputOption-activeForeground)}';
n(css$4, {});
class CollapseAllAction extends Action {
  constructor(viewer, enabled) {
    super("vs.tree.collapse", localize("collapse all", "Collapse All"), "collapse-all", enabled);
    this.viewer = viewer;
  }
  async run() {
    this.viewer.collapseAll();
    this.viewer.setSelection([]);
    this.viewer.setFocus([]);
  }
}
class CheckboxStateHandler extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidChangeCheckboxState = this._register(new Emitter());
    this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
  }
  setCheckboxState(node) {
    this._onDidChangeCheckboxState.fire([node]);
  }
}
const _TreeItemCheckbox = class _TreeItemCheckbox extends Disposable {
  constructor(container, checkboxStateHandler, hoverDelegate) {
    super();
    this.checkboxStateHandler = checkboxStateHandler;
    this.hoverDelegate = hoverDelegate;
    this.isDisposed = false;
    this._onDidChangeState = new Emitter();
    this.onDidChangeState = this._onDidChangeState.event;
    this.checkboxContainer = container;
  }
  render(node) {
    if (node.checkbox) {
      if (!this.toggle) {
        this.createCheckbox(node);
      } else {
        this.toggle.checked = node.checkbox.isChecked;
        this.toggle.setIcon(this.toggle.checked ? Codicon.check : void 0);
      }
    }
  }
  createCheckbox(node) {
    if (node.checkbox) {
      this.toggle = new Toggle({
        isChecked: node.checkbox.isChecked,
        title: "",
        icon: node.checkbox.isChecked ? Codicon.check : void 0,
        ...defaultToggleStyles
      });
      this.setHover(node.checkbox);
      this.setAccessibilityInformation(node.checkbox);
      this.toggle.domNode.classList.add(_TreeItemCheckbox.checkboxClass);
      append(this.checkboxContainer, this.toggle.domNode);
      this.registerListener(node);
    }
  }
  registerListener(node) {
    if (this.toggle) {
      this._register({ dispose: () => this.removeCheckbox() });
      this._register(this.toggle);
      this._register(this.toggle.onChange(() => {
        this.setCheckbox(node);
      }));
    }
  }
  setHover(checkbox) {
    if (this.toggle) {
      if (!this.hover) {
        this.hover = setupCustomHover(this.hoverDelegate, this.toggle.domNode, this.checkboxHoverContent(checkbox));
        this._register(this.hover);
      } else {
        this.hover.update(checkbox.tooltip);
      }
    }
  }
  setCheckbox(node) {
    if (this.toggle && node.checkbox) {
      node.checkbox.isChecked = this.toggle.checked;
      this.toggle.setIcon(this.toggle.checked ? Codicon.check : void 0);
      this.setHover(node.checkbox);
      this.setAccessibilityInformation(node.checkbox);
      this.checkboxStateHandler.setCheckboxState(node);
    }
  }
  checkboxHoverContent(checkbox) {
    return checkbox.tooltip ? checkbox.tooltip : checkbox.isChecked ? localize("checked", "Checked") : localize("unchecked", "Unchecked");
  }
  setAccessibilityInformation(checkbox) {
    if (this.toggle && checkbox.accessibilityInformation) {
      this.toggle.domNode.ariaLabel = checkbox.accessibilityInformation.label;
      if (checkbox.accessibilityInformation.role) {
        this.toggle.domNode.role = checkbox.accessibilityInformation.role;
      }
    }
  }
  removeCheckbox() {
    const children = this.checkboxContainer.children;
    for (const child of children) {
      this.checkboxContainer.removeChild(child);
    }
  }
};
_TreeItemCheckbox.checkboxClass = "custom-view-tree-node-item-checkbox";
let TreeItemCheckbox = _TreeItemCheckbox;
let TreeViewPane = class TreeViewPane2 extends ViewPane {
  constructor(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService, notificationService) {
    super({ ...options, titleMenuId: MenuId.ViewTitle, donotForwardArgs: false }, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    const { treeView } = Registry.as(Extensions$1.ViewsRegistry).getView(options.id);
    this.treeView = treeView;
    this._register(this.treeView.onDidChangeActions(() => this.updateActions(), this));
    this._register(this.treeView.onDidChangeTitle((newTitle) => this.updateTitle(newTitle)));
    this._register(this.treeView.onDidChangeDescription((newDescription) => this.updateTitleDescription(newDescription)));
    this._register(toDisposable(() => {
      if (this._container && this.treeView.container && this._container === this.treeView.container) {
        this.treeView.setVisibility(false);
      }
    }));
    this._register(this.onDidChangeBodyVisibility(() => this.updateTreeVisibility()));
    this._register(this.treeView.onDidChangeWelcomeState(() => this._onDidChangeViewWelcomeState.fire()));
    if (options.title !== this.treeView.title) {
      this.updateTitle(this.treeView.title);
    }
    if (options.titleDescription !== this.treeView.description) {
      this.updateTitleDescription(this.treeView.description);
    }
    this._actionRunner = new MultipleSelectionActionRunner(notificationService, () => this.treeView.getSelection());
    this.updateTreeVisibility();
  }
  focus() {
    super.focus();
    this.treeView.focus();
  }
  renderBody(container) {
    this._container = container;
    super.renderBody(container);
    this.renderTreeView(container);
  }
  shouldShowWelcome() {
    return (this.treeView.dataProvider === void 0 || !!this.treeView.dataProvider.isTreeEmpty) && this.treeView.message === void 0;
  }
  layoutBody(height, width) {
    super.layoutBody(height, width);
    this.layoutTreeView(height, width);
  }
  getOptimalWidth() {
    return this.treeView.getOptimalWidth();
  }
  renderTreeView(container) {
    this.treeView.show(container);
  }
  layoutTreeView(height, width) {
    this.treeView.layout(height, width);
  }
  updateTreeVisibility() {
    this.treeView.setVisibility(this.isBodyVisible());
  }
  getActionRunner() {
    return this._actionRunner;
  }
  getActionsContext() {
    return { $treeViewId: this.id, $focusedTreeItem: true, $selectedTreeItems: true };
  }
};
TreeViewPane = __decorate([
  __param(1, IKeybindingService),
  __param(2, IContextMenuService),
  __param(3, IConfigurationService),
  __param(4, IContextKeyService),
  __param(5, IViewDescriptorService),
  __param(6, IInstantiationService),
  __param(7, IOpenerService),
  __param(8, IThemeService),
  __param(9, ITelemetryService),
  __param(10, INotificationService)
], TreeViewPane);
class Root {
  constructor() {
    this.label = { label: "root" };
    this.handle = "0";
    this.parentHandle = void 0;
    this.collapsibleState = TreeItemCollapsibleState.Expanded;
    this.children = void 0;
  }
}
function isTreeCommandEnabled(treeCommand, contextKeyService) {
  const command = CommandsRegistry.getCommand(treeCommand.originalId ? treeCommand.originalId : treeCommand.id);
  if (command) {
    const commandAction = MenuRegistry.getCommand(command.id);
    const precondition = commandAction && commandAction.precondition;
    if (precondition) {
      return contextKeyService.contextMatchesRules(precondition);
    }
  }
  return true;
}
function isRenderedMessageValue(messageValue) {
  return !!messageValue && typeof messageValue !== "string" && "element" in messageValue && "dispose" in messageValue;
}
const noDataProviderMessage = localize(
  "no-dataprovider",
  "There is no data provider registered that can provide view data."
);
const RawCustomTreeViewContextKey = new RawContextKey("customTreeView", false);
class Tree extends WorkbenchAsyncDataTree {
}
let AbstractTreeView = class AbstractTreeView2 extends Disposable {
  constructor(id, _title, themeService, instantiationService, commandService, configurationService, progressService, contextMenuService, keybindingService, notificationService, viewDescriptorService, hoverService, contextKeyService, activityService, logService) {
    super();
    this.id = id;
    this._title = _title;
    this.themeService = themeService;
    this.instantiationService = instantiationService;
    this.commandService = commandService;
    this.configurationService = configurationService;
    this.progressService = progressService;
    this.contextMenuService = contextMenuService;
    this.keybindingService = keybindingService;
    this.notificationService = notificationService;
    this.viewDescriptorService = viewDescriptorService;
    this.hoverService = hoverService;
    this.contextKeyService = contextKeyService;
    this.activityService = activityService;
    this.logService = logService;
    this.isVisible = false;
    this._hasIconForParentNode = false;
    this._hasIconForLeafNode = false;
    this.focused = false;
    this._canSelectMany = false;
    this._manuallyManageCheckboxes = false;
    this.elementsToRefresh = [];
    this.lastSelection = [];
    this._onDidExpandItem = this._register(new Emitter());
    this.onDidExpandItem = this._onDidExpandItem.event;
    this._onDidCollapseItem = this._register(new Emitter());
    this.onDidCollapseItem = this._onDidCollapseItem.event;
    this._onDidChangeSelectionAndFocus = this._register(new Emitter());
    this.onDidChangeSelectionAndFocus = this._onDidChangeSelectionAndFocus.event;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._onDidChangeActions = this._register(new Emitter());
    this.onDidChangeActions = this._onDidChangeActions.event;
    this._onDidChangeWelcomeState = this._register(new Emitter());
    this.onDidChangeWelcomeState = this._onDidChangeWelcomeState.event;
    this._onDidChangeTitle = this._register(new Emitter());
    this.onDidChangeTitle = this._onDidChangeTitle.event;
    this._onDidChangeDescription = this._register(new Emitter());
    this.onDidChangeDescription = this._onDidChangeDescription.event;
    this._onDidChangeCheckboxState = this._register(new Emitter());
    this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
    this._onDidCompleteRefresh = this._register(new Emitter());
    this._isInitialized = false;
    this._height = 0;
    this._width = 0;
    this.refreshing = false;
    this.root = new Root();
    this.lastActive = this.root;
  }
  initialize() {
    if (this._isInitialized) {
      return;
    }
    this._isInitialized = true;
    this.contextKeyService.bufferChangeEvents(() => {
      this.initializeShowCollapseAllAction();
      this.initializeCollapseAllToggle();
      this.initializeShowRefreshAction();
    });
    this.treeViewDnd = this.instantiationService.createInstance(CustomTreeViewDragAndDrop, this.id);
    if (this._dragAndDropController) {
      this.treeViewDnd.controller = this._dragAndDropController;
    }
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("explorer.decorations")) {
        this.doRefresh([this.root]);
      }
    }));
    this._register(this.viewDescriptorService.onDidChangeLocation(({ views, from, to }) => {
      var _a2;
      if (views.some((v) => v.id === this.id)) {
        (_a2 = this.tree) == null ? void 0 : _a2.updateOptions({ overrideStyles: { listBackground: this.viewLocation === 1 ? PANEL_BACKGROUND : SIDE_BAR_BACKGROUND } });
      }
    }));
    this.registerActions();
    this.create();
  }
  get viewContainer() {
    return this.viewDescriptorService.getViewContainerByViewId(this.id);
  }
  get viewLocation() {
    return this.viewDescriptorService.getViewLocationById(this.id);
  }
  get dragAndDropController() {
    return this._dragAndDropController;
  }
  set dragAndDropController(dnd) {
    this._dragAndDropController = dnd;
    if (this.treeViewDnd) {
      this.treeViewDnd.controller = dnd;
    }
  }
  get dataProvider() {
    return this._dataProvider;
  }
  set dataProvider(dataProvider) {
    if (dataProvider) {
      const self2 = this;
      this._dataProvider = new class {
        constructor() {
          this._isEmpty = true;
          this._onDidChangeEmpty = new Emitter();
          this.onDidChangeEmpty = this._onDidChangeEmpty.event;
        }
        get isTreeEmpty() {
          return this._isEmpty;
        }
        async getChildren(node) {
          let children;
          const checkboxesUpdated = [];
          if (node && node.children) {
            children = node.children;
          } else {
            node = node ?? self2.root;
            node.children = await (node instanceof Root ? dataProvider.getChildren() : dataProvider.getChildren(node));
            children = node.children ?? [];
            children.forEach((child) => {
              var _a2, _b2;
              child.parent = node;
              if (!self2.manuallyManageCheckboxes && ((_a2 = node == null ? void 0 : node.checkbox) == null ? void 0 : _a2.isChecked) === true && ((_b2 = child.checkbox) == null ? void 0 : _b2.isChecked) === false) {
                child.checkbox.isChecked = true;
                checkboxesUpdated.push(child);
              }
            });
          }
          if (node instanceof Root) {
            const oldEmpty = this._isEmpty;
            this._isEmpty = children.length === 0;
            if (oldEmpty !== this._isEmpty) {
              this._onDidChangeEmpty.fire();
            }
          }
          if (checkboxesUpdated.length > 0) {
            self2._onDidChangeCheckboxState.fire(checkboxesUpdated);
          }
          return children;
        }
      }();
      if (this._dataProvider.onDidChangeEmpty) {
        this._register(this._dataProvider.onDidChangeEmpty(() => {
          this.updateCollapseAllToggle();
          this._onDidChangeWelcomeState.fire();
        }));
      }
      this.updateMessage();
      this.refresh();
    } else {
      this._dataProvider = void 0;
      this.updateMessage();
    }
    this._onDidChangeWelcomeState.fire();
  }
  get message() {
    return this._message;
  }
  set message(message) {
    this._message = message;
    this.updateMessage();
    this._onDidChangeWelcomeState.fire();
  }
  get title() {
    return this._title;
  }
  set title(name) {
    this._title = name;
    this._onDidChangeTitle.fire(this._title);
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
    this._onDidChangeDescription.fire(this._description);
  }
  get badge() {
    return this._badge;
  }
  set badge(badge) {
    var _a2, _b2;
    if (((_a2 = this._badge) == null ? void 0 : _a2.value) === (badge == null ? void 0 : badge.value) && ((_b2 = this._badge) == null ? void 0 : _b2.tooltip) === (badge == null ? void 0 : badge.tooltip)) {
      return;
    }
    if (this._badgeActivity) {
      this._badgeActivity.dispose();
      this._badgeActivity = void 0;
    }
    this._badge = badge;
    if (badge) {
      const activity = {
        badge: new NumberBadge(badge.value, () => badge.tooltip),
        priority: 50
      };
      this._badgeActivity = this.activityService.showViewActivity(this.id, activity);
    }
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(canSelectMany) {
    var _a2;
    const oldCanSelectMany = this._canSelectMany;
    this._canSelectMany = canSelectMany;
    if (this._canSelectMany !== oldCanSelectMany) {
      (_a2 = this.tree) == null ? void 0 : _a2.updateOptions({ multipleSelectionSupport: this.canSelectMany });
    }
  }
  get manuallyManageCheckboxes() {
    return this._manuallyManageCheckboxes;
  }
  set manuallyManageCheckboxes(manuallyManageCheckboxes) {
    this._manuallyManageCheckboxes = manuallyManageCheckboxes;
  }
  get hasIconForParentNode() {
    return this._hasIconForParentNode;
  }
  get hasIconForLeafNode() {
    return this._hasIconForLeafNode;
  }
  get visible() {
    return this.isVisible;
  }
  initializeShowCollapseAllAction(startingValue = false) {
    if (!this.collapseAllContext) {
      this.collapseAllContextKey = new RawContextKey(`treeView.${this.id}.enableCollapseAll`, startingValue, localize(
        "treeView.enableCollapseAll",
        "Whether the the tree view with id {0} enables collapse all.",
        this.id
      ));
      this.collapseAllContext = this.collapseAllContextKey.bindTo(this.contextKeyService);
    }
    return true;
  }
  get showCollapseAllAction() {
    var _a2;
    this.initializeShowCollapseAllAction();
    return !!((_a2 = this.collapseAllContext) == null ? void 0 : _a2.get());
  }
  set showCollapseAllAction(showCollapseAllAction) {
    var _a2;
    this.initializeShowCollapseAllAction(showCollapseAllAction);
    (_a2 = this.collapseAllContext) == null ? void 0 : _a2.set(showCollapseAllAction);
  }
  initializeShowRefreshAction(startingValue = false) {
    if (!this.refreshContext) {
      this.refreshContextKey = new RawContextKey(`treeView.${this.id}.enableRefresh`, startingValue, localize(
        "treeView.enableRefresh",
        "Whether the tree view with id {0} enables refresh.",
        this.id
      ));
      this.refreshContext = this.refreshContextKey.bindTo(this.contextKeyService);
    }
  }
  get showRefreshAction() {
    var _a2;
    this.initializeShowRefreshAction();
    return !!((_a2 = this.refreshContext) == null ? void 0 : _a2.get());
  }
  set showRefreshAction(showRefreshAction) {
    var _a2;
    this.initializeShowRefreshAction(showRefreshAction);
    (_a2 = this.refreshContext) == null ? void 0 : _a2.set(showRefreshAction);
  }
  registerActions() {
    const that = this;
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: `workbench.actions.treeView.${that.id}.refresh`,
          title: localize("refresh", "Refresh"),
          menu: {
            id: MenuId.ViewTitle,
            when: ContextKeyExpr.and(ContextKeyExpr.equals("view", that.id), that.refreshContextKey),
            group: "navigation",
            order: Number.MAX_SAFE_INTEGER - 1
          },
          icon: Codicon.refresh
        });
      }
      async run() {
        return that.refresh();
      }
    }));
    this._register(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: `workbench.actions.treeView.${that.id}.collapseAll`,
          title: localize("collapseAll", "Collapse All"),
          menu: {
            id: MenuId.ViewTitle,
            when: ContextKeyExpr.and(ContextKeyExpr.equals("view", that.id), that.collapseAllContextKey),
            group: "navigation",
            order: Number.MAX_SAFE_INTEGER
          },
          precondition: that.collapseAllToggleContextKey,
          icon: Codicon.collapseAll
        });
      }
      async run() {
        if (that.tree) {
          return new CollapseAllAction(that.tree, true).run();
        }
      }
    }));
  }
  setVisibility(isVisible) {
    this.initialize();
    isVisible = !!isVisible;
    if (this.isVisible === isVisible) {
      return;
    }
    this.isVisible = isVisible;
    if (this.tree) {
      if (this.isVisible) {
        show(this.tree.getHTMLElement());
      } else {
        hide(this.tree.getHTMLElement());
      }
      if (this.isVisible && this.elementsToRefresh.length && this.dataProvider) {
        this.doRefresh(this.elementsToRefresh);
        this.elementsToRefresh = [];
      }
    }
    setTimeout0(() => {
      if (this.dataProvider) {
        this._onDidChangeVisibility.fire(this.isVisible);
      }
    });
    if (this.visible) {
      this.activate();
    }
  }
  focus(reveal = true, revealItem) {
    if (this.tree && this.root.children && this.root.children.length > 0) {
      const element = revealItem ?? this.tree.getSelection()[0];
      if (element && reveal) {
        this.tree.reveal(element, 0.5);
      }
      this.tree.domFocus();
    } else if (this.tree) {
      this.tree.domFocus();
    } else {
      this.domNode.focus();
    }
  }
  show(container) {
    this._container = container;
    append(container, this.domNode);
  }
  create() {
    this.domNode = $$2(".tree-explorer-viewlet-tree-view");
    this.messageElement = append(this.domNode, $$2(".message"));
    this.updateMessage();
    this.treeContainer = append(this.domNode, $$2(".customview-tree"));
    this.treeContainer.classList.add("file-icon-themable-tree", "show-file-icons");
    const focusTracker = this._register(trackFocus(this.domNode));
    this._register(focusTracker.onDidFocus(() => this.focused = true));
    this._register(focusTracker.onDidBlur(() => this.focused = false));
  }
  createTree() {
    const actionViewItemProvider = createActionViewItem.bind(void 0, this.instantiationService);
    const treeMenus = this._register(this.instantiationService.createInstance(TreeMenus, this.id));
    this.treeLabels = this._register(this.instantiationService.createInstance(ResourceLabels, this));
    const dataSource = this.instantiationService.createInstance(TreeDataSource, this, (task) => this.progressService.withProgress({ location: this.id }, () => task));
    const aligner = new Aligner(this.themeService);
    const checkboxStateHandler = this._register(new CheckboxStateHandler());
    const renderer = this.instantiationService.createInstance(TreeRenderer, this.id, treeMenus, this.treeLabels, actionViewItemProvider, aligner, checkboxStateHandler, this.manuallyManageCheckboxes);
    this._register(renderer.onDidChangeCheckboxState((e) => this._onDidChangeCheckboxState.fire(e)));
    const widgetAriaLabel = this._title;
    this.tree = this._register(this.instantiationService.createInstance(Tree, this.id, this.treeContainer, new TreeViewDelegate(), [renderer], dataSource, {
      identityProvider: new TreeViewIdentityProvider(),
      accessibilityProvider: {
        getAriaLabel(element) {
          if (element.accessibilityInformation) {
            return element.accessibilityInformation.label;
          }
          if (isString(element.tooltip)) {
            return element.tooltip;
          } else {
            if (element.resourceUri && !element.label) {
              return null;
            }
            let buildAriaLabel = "";
            if (element.label) {
              buildAriaLabel += element.label.label + " ";
            }
            if (element.description) {
              buildAriaLabel += element.description;
            }
            return buildAriaLabel;
          }
        },
        getRole(element) {
          var _a2;
          return ((_a2 = element.accessibilityInformation) == null ? void 0 : _a2.role) ?? "treeitem";
        },
        getWidgetAriaLabel() {
          return widgetAriaLabel;
        }
      },
      keyboardNavigationLabelProvider: {
        getKeyboardNavigationLabel: (item) => {
          return item.label ? item.label.label : item.resourceUri ? basename(URI.revive(item.resourceUri)) : void 0;
        }
      },
      expandOnlyOnTwistieClick: (e) => {
        return !!e.command || !!e.checkbox || this.configurationService.getValue("workbench.tree.expandMode") === "doubleClick";
      },
      collapseByDefault: (e) => {
        return e.collapsibleState !== TreeItemCollapsibleState.Expanded;
      },
      multipleSelectionSupport: this.canSelectMany,
      dnd: this.treeViewDnd,
      overrideStyles: {
        listBackground: this.viewLocation === 1 ? PANEL_BACKGROUND : SIDE_BAR_BACKGROUND
      }
    }));
    treeMenus.setContextKeyService(this.tree.contextKeyService);
    aligner.tree = this.tree;
    const actionRunner = new MultipleSelectionActionRunner(this.notificationService, () => this.tree.getSelection());
    renderer.actionRunner = actionRunner;
    this.tree.contextKeyService.createKey(this.id, true);
    const customTreeKey = RawCustomTreeViewContextKey.bindTo(this.tree.contextKeyService);
    customTreeKey.set(true);
    this._register(this.tree.onContextMenu((e) => this.onContextMenu(treeMenus, e, actionRunner)));
    this._register(this.tree.onDidChangeSelection((e) => {
      var _a2;
      this.lastSelection = e.elements;
      this.lastActive = ((_a2 = this.tree) == null ? void 0 : _a2.getFocus()[0]) ?? this.lastActive;
      this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive });
    }));
    this._register(this.tree.onDidChangeFocus((e) => {
      var _a2;
      if (e.elements.length && e.elements[0] !== this.lastActive) {
        this.lastActive = e.elements[0];
        this.lastSelection = ((_a2 = this.tree) == null ? void 0 : _a2.getSelection()) ?? this.lastSelection;
        this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive });
      }
    }));
    this._register(this.tree.onDidChangeCollapseState((e) => {
      if (!e.node.element) {
        return;
      }
      const element = Array.isArray(e.node.element.element) ? e.node.element.element[0] : e.node.element.element;
      if (e.node.collapsed) {
        this._onDidCollapseItem.fire(element);
      } else {
        this._onDidExpandItem.fire(element);
      }
    }));
    this.tree.setInput(this.root).then(() => this.updateContentAreas());
    this._register(this.tree.onDidOpen(async (e) => {
      if (!e.browserEvent) {
        return;
      }
      if (e.browserEvent.target && e.browserEvent.target.classList.contains(TreeItemCheckbox.checkboxClass)) {
        return;
      }
      const selection = this.tree.getSelection();
      const command = await this.resolveCommand(selection.length === 1 ? selection[0] : void 0);
      if (command && isTreeCommandEnabled(command, this.contextKeyService)) {
        let args = command.arguments || [];
        if (command.id === API_OPEN_EDITOR_COMMAND_ID || command.id === API_OPEN_DIFF_EDITOR_COMMAND_ID) {
          args = [...args, e];
        }
        try {
          await this.commandService.executeCommand(command.id, ...args);
        } catch (err) {
          this.notificationService.error(err);
        }
      }
    }));
    this._register(treeMenus.onDidChange((changed) => {
      var _a2, _b2;
      if ((_a2 = this.tree) == null ? void 0 : _a2.hasNode(changed)) {
        (_b2 = this.tree) == null ? void 0 : _b2.rerender(changed);
      }
    }));
  }
  async resolveCommand(element) {
    let command = element == null ? void 0 : element.command;
    if (element && !command) {
      if (element instanceof ResolvableTreeItem && element.hasResolve) {
        await element.resolve(new CancellationTokenSource().token);
        command = element.command;
      }
    }
    return command;
  }
  onContextMenu(treeMenus, treeEvent, actionRunner) {
    this.hoverService.hideHover();
    const node = treeEvent.element;
    if (node === null) {
      return;
    }
    const event = treeEvent.browserEvent;
    event.preventDefault();
    event.stopPropagation();
    this.tree.setFocus([node]);
    const actions = treeMenus.getResourceContextActions(node);
    if (!actions.length) {
      return;
    }
    this.contextMenuService.showContextMenu({
      getAnchor: () => treeEvent.anchor,
      getActions: () => actions,
      getActionViewItem: (action) => {
        const keybinding = this.keybindingService.lookupKeybinding(action.id);
        if (keybinding) {
          return new ActionViewItem(action, action, { label: true, keybinding: keybinding.getLabel() });
        }
        return void 0;
      },
      onHide: (wasCancelled) => {
        if (wasCancelled) {
          this.tree.domFocus();
        }
      },
      getActionsContext: () => ({ $treeViewId: this.id, $treeItemHandle: node.handle }),
      actionRunner
    });
  }
  updateMessage() {
    if (this._message) {
      this.showMessage(this._message);
    } else if (!this.dataProvider) {
      this.showMessage(noDataProviderMessage);
    } else {
      this.hideMessage();
    }
    this.updateContentAreas();
  }
  showMessage(message) {
    if (isRenderedMessageValue(this._messageValue)) {
      this._messageValue.dispose();
    }
    if (isMarkdownString(message) && !this.markdownRenderer) {
      this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    }
    this._messageValue = isMarkdownString(message) ? this.markdownRenderer.render(message) : message;
    if (!this.messageElement) {
      return;
    }
    this.messageElement.classList.remove("hide");
    this.resetMessageElement();
    if (typeof this._messageValue === "string" && !isFalsyOrWhitespace(this._messageValue)) {
      this.messageElement.textContent = this._messageValue;
    } else if (isRenderedMessageValue(this._messageValue)) {
      this.messageElement.appendChild(this._messageValue.element);
    }
    this.layout(this._height, this._width);
  }
  hideMessage() {
    var _a2;
    this.resetMessageElement();
    (_a2 = this.messageElement) == null ? void 0 : _a2.classList.add("hide");
    this.layout(this._height, this._width);
  }
  resetMessageElement() {
    if (this.messageElement) {
      clearNode(this.messageElement);
    }
  }
  layout(height, width) {
    var _a2;
    if (height && width && this.messageElement && this.treeContainer) {
      this._height = height;
      this._width = width;
      const treeHeight = height - getTotalHeight(this.messageElement);
      this.treeContainer.style.height = treeHeight + "px";
      (_a2 = this.tree) == null ? void 0 : _a2.layout(treeHeight, width);
    }
  }
  getOptimalWidth() {
    if (this.tree) {
      const parentNode = this.tree.getHTMLElement();
      const childNodes = [].slice.call(parentNode.querySelectorAll(".outline-item-label > a"));
      return getLargestChildWidth(parentNode, childNodes);
    }
    return 0;
  }
  async refresh(elements) {
    if (this.dataProvider && this.tree) {
      if (this.refreshing) {
        await Event.toPromise(this._onDidCompleteRefresh.event);
      }
      if (!elements) {
        elements = [this.root];
        this.elementsToRefresh = [];
      }
      for (const element of elements) {
        element.children = void 0;
      }
      if (this.isVisible) {
        return this.doRefresh(elements);
      } else {
        if (this.elementsToRefresh.length) {
          const seen = /* @__PURE__ */ new Set();
          this.elementsToRefresh.forEach((element) => seen.add(element.handle));
          for (const element of elements) {
            if (!seen.has(element.handle)) {
              this.elementsToRefresh.push(element);
            }
          }
        } else {
          this.elementsToRefresh.push(...elements);
        }
      }
    }
    return void 0;
  }
  async expand(itemOrItems) {
    const tree = this.tree;
    if (!tree) {
      return;
    }
    try {
      itemOrItems = Array.isArray(itemOrItems) ? itemOrItems : [itemOrItems];
      for (const element of itemOrItems) {
        await tree.expand(element, false);
      }
    } catch (e) {
    }
  }
  isCollapsed(item) {
    var _a2;
    return !!((_a2 = this.tree) == null ? void 0 : _a2.isCollapsed(item));
  }
  setSelection(items) {
    var _a2;
    (_a2 = this.tree) == null ? void 0 : _a2.setSelection(items);
  }
  getSelection() {
    var _a2;
    return ((_a2 = this.tree) == null ? void 0 : _a2.getSelection()) ?? [];
  }
  setFocus(item) {
    if (this.tree) {
      if (item) {
        this.focus(true, item);
        this.tree.setFocus([item]);
      } else {
        this.tree.setFocus([]);
      }
    }
  }
  async reveal(item) {
    if (this.tree) {
      return this.tree.reveal(item);
    }
  }
  async doRefresh(elements) {
    const tree = this.tree;
    if (tree && this.visible) {
      this.refreshing = true;
      const oldSelection = tree.getSelection();
      try {
        await Promise.all(elements.map((element) => tree.updateChildren(element, true, true)));
      } catch (e) {
        this.logService.error(e);
      }
      const newSelection = tree.getSelection();
      if (oldSelection.length !== newSelection.length || oldSelection.some((value, index) => value.handle !== newSelection[index].handle)) {
        this.lastSelection = newSelection;
        this._onDidChangeSelectionAndFocus.fire({ selection: this.lastSelection, focus: this.lastActive });
      }
      this.refreshing = false;
      this._onDidCompleteRefresh.fire();
      this.updateContentAreas();
      if (this.focused) {
        this.focus(false);
      }
      this.updateCollapseAllToggle();
    }
  }
  initializeCollapseAllToggle() {
    if (!this.collapseAllToggleContext) {
      this.collapseAllToggleContextKey = new RawContextKey(`treeView.${this.id}.toggleCollapseAll`, false, localize(
        "treeView.toggleCollapseAll",
        "Whether collapse all is toggled for the tree view with id {0}.",
        this.id
      ));
      this.collapseAllToggleContext = this.collapseAllToggleContextKey.bindTo(this.contextKeyService);
    }
  }
  updateCollapseAllToggle() {
    var _a2;
    if (this.showCollapseAllAction) {
      this.initializeCollapseAllToggle();
      (_a2 = this.collapseAllToggleContext) == null ? void 0 : _a2.set(!!this.root.children && this.root.children.length > 0 && this.root.children.some((value) => value.collapsibleState !== TreeItemCollapsibleState.None));
    }
  }
  updateContentAreas() {
    const isTreeEmpty = !this.root.children || this.root.children.length === 0;
    if (this._messageValue && isTreeEmpty && !this.refreshing && this.treeContainer) {
      if (!this.dragAndDropController) {
        this.treeContainer.classList.add("hide");
      }
      this.domNode.setAttribute("tabindex", "0");
    } else if (this.treeContainer) {
      this.treeContainer.classList.remove("hide");
      this.domNode.removeAttribute("tabindex");
    }
  }
  get container() {
    return this._container;
  }
};
AbstractTreeView = __decorate([
  __param(2, IThemeService),
  __param(3, IInstantiationService),
  __param(4, ICommandService),
  __param(5, IConfigurationService),
  __param(6, IProgressService),
  __param(7, IContextMenuService),
  __param(8, IKeybindingService),
  __param(9, INotificationService),
  __param(10, IViewDescriptorService),
  __param(11, IHoverService),
  __param(12, IContextKeyService),
  __param(13, IActivityService),
  __param(14, ILogService)
], AbstractTreeView);
class TreeViewIdentityProvider {
  getId(element) {
    return element.handle;
  }
}
class TreeViewDelegate {
  getHeight(element) {
    return TreeRenderer.ITEM_HEIGHT;
  }
  getTemplateId(element) {
    return TreeRenderer.TREE_TEMPLATE_ID;
  }
}
class TreeDataSource {
  constructor(treeView, withProgress) {
    this.treeView = treeView;
    this.withProgress = withProgress;
  }
  hasChildren(element) {
    return !!this.treeView.dataProvider && element.collapsibleState !== TreeItemCollapsibleState.None;
  }
  async getChildren(element) {
    let result = [];
    if (this.treeView.dataProvider) {
      try {
        result = await this.withProgress(this.treeView.dataProvider.getChildren(element)) ?? [];
      } catch (e) {
        if (!e.message.startsWith("Bad progress location:")) {
          throw e;
        }
      }
    }
    return result;
  }
}
let TreeRenderer = (_v = class extends Disposable {
  constructor(treeViewId, menus, labels, actionViewItemProvider, aligner, checkboxStateHandler, manuallyManageCheckboxes, themeService, configurationService, labelService, hoverService, treeViewsService, contextKeyService) {
    super();
    this.treeViewId = treeViewId;
    this.menus = menus;
    this.labels = labels;
    this.actionViewItemProvider = actionViewItemProvider;
    this.aligner = aligner;
    this.checkboxStateHandler = checkboxStateHandler;
    this.manuallyManageCheckboxes = manuallyManageCheckboxes;
    this.themeService = themeService;
    this.configurationService = configurationService;
    this.labelService = labelService;
    this.hoverService = hoverService;
    this.treeViewsService = treeViewsService;
    this.contextKeyService = contextKeyService;
    this._onDidChangeCheckboxState = this._register(new Emitter());
    this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;
    this._hasCheckbox = false;
    this._renderedElements = /* @__PURE__ */ new Map();
    this._hoverDelegate = {
      showHover: (options) => this.hoverService.showHover(options),
      delay: this.configurationService.getValue("workbench.hover.delay")
    };
    this._register(this.themeService.onDidFileIconThemeChange(() => this.rerender()));
    this._register(this.themeService.onDidColorThemeChange(() => this.rerender()));
    this._register(checkboxStateHandler.onDidChangeCheckboxState((items) => {
      this.updateCheckboxes(items);
    }));
  }
  get templateId() {
    return _v.TREE_TEMPLATE_ID;
  }
  set actionRunner(actionRunner) {
    this._actionRunner = actionRunner;
  }
  renderTemplate(container) {
    container.classList.add("custom-view-tree-node-item");
    const checkboxContainer = append(container, $$2(""));
    const resourceLabel = this.labels.create(container, { supportHighlights: true, hoverDelegate: this._hoverDelegate });
    const icon = prepend(resourceLabel.element, $$2(".custom-view-tree-node-item-icon"));
    const actionsContainer = append(resourceLabel.element, $$2(".actions"));
    const actionBar = new ActionBar(actionsContainer, {
      actionViewItemProvider: this.actionViewItemProvider
    });
    return { resourceLabel, icon, checkboxContainer, actionBar, container, elementDisposable: new DisposableStore() };
  }
  getHover(label, resource, node) {
    if (!(node instanceof ResolvableTreeItem) || !node.hasResolve) {
      if (resource && !node.tooltip) {
        return void 0;
      } else if (node.tooltip === void 0) {
        return label;
      } else if (!isString(node.tooltip)) {
        return { markdown: node.tooltip, markdownNotSupportedFallback: resource ? void 0 : renderMarkdownAsPlaintext(node.tooltip) };
      } else if (node.tooltip !== "") {
        return node.tooltip;
      } else {
        return void 0;
      }
    }
    return {
      markdown: typeof node.tooltip === "string" ? node.tooltip : (token) => {
        return new Promise((resolve) => {
          node.resolve(token).then(() => resolve(node.tooltip));
        });
      },
      markdownNotSupportedFallback: resource ? void 0 : label ?? ""
    };
  }
  renderElement(element, index, templateData) {
    var _a2;
    const node = element.element;
    const resource = node.resourceUri ? URI.revive(node.resourceUri) : null;
    const treeItemLabel = node.label ? node.label : resource ? { label: basename(resource) } : void 0;
    const description = isString(node.description) ? node.description : resource && node.description === true ? this.labelService.getUriLabel(dirname(resource), { relative: true }) : void 0;
    const label = treeItemLabel ? treeItemLabel.label : void 0;
    const matches = treeItemLabel && treeItemLabel.highlights && label ? treeItemLabel.highlights.map(([start, end]) => {
      if (start < 0) {
        start = label.length + start;
      }
      if (end < 0) {
        end = label.length + end;
      }
      if (start >= label.length || end > label.length) {
        return { start: 0, end: 0 };
      }
      if (start > end) {
        const swap = start;
        start = end;
        end = swap;
      }
      return { start, end };
    }) : void 0;
    const icon = this.themeService.getColorTheme().type === ColorScheme.LIGHT ? node.icon : node.iconDark;
    const iconUrl = icon ? URI.revive(icon) : void 0;
    const title = this.getHover(label, resource, node);
    templateData.actionBar.clear();
    templateData.icon.style.color = "";
    let commandEnabled = true;
    if (node.command) {
      commandEnabled = isTreeCommandEnabled(node.command, this.contextKeyService);
    }
    this.renderCheckbox(node, templateData);
    if (resource) {
      const fileDecorations = this.configurationService.getValue("explorer.decorations");
      const labelResource = resource ? resource : URI.parse("missing:_icon_resource");
      templateData.resourceLabel.setResource({ name: label, description, resource: labelResource }, {
        fileKind: this.getFileKind(node),
        title,
        hideIcon: this.shouldHideResourceLabelIcon(iconUrl, node.themeIcon),
        fileDecorations,
        extraClasses: ["custom-view-tree-node-item-resourceLabel"],
        matches: matches ? matches : createMatches(element.filterData),
        strikethrough: treeItemLabel == null ? void 0 : treeItemLabel.strikethrough,
        disabledCommand: !commandEnabled,
        labelEscapeNewLines: true
      });
    } else {
      templateData.resourceLabel.setResource({ name: label, description }, {
        title,
        hideIcon: true,
        extraClasses: ["custom-view-tree-node-item-resourceLabel"],
        matches: matches ? matches : createMatches(element.filterData),
        strikethrough: treeItemLabel == null ? void 0 : treeItemLabel.strikethrough,
        disabledCommand: !commandEnabled,
        labelEscapeNewLines: true
      });
    }
    if (iconUrl) {
      templateData.icon.className = "custom-view-tree-node-item-icon";
      templateData.icon.style.backgroundImage = asCSSUrl(iconUrl);
    } else {
      let iconClass;
      if (this.shouldShowThemeIcon(!!resource, node.themeIcon)) {
        iconClass = ThemeIcon.asClassName(node.themeIcon);
        if (node.themeIcon.color) {
          templateData.icon.style.color = ((_a2 = this.themeService.getColorTheme().getColor(node.themeIcon.color.id)) == null ? void 0 : _a2.toString()) ?? "";
        }
      }
      templateData.icon.className = iconClass ? `custom-view-tree-node-item-icon ${iconClass}` : "";
      templateData.icon.style.backgroundImage = "";
    }
    if (!commandEnabled) {
      templateData.icon.className = templateData.icon.className + " disabled";
      if (templateData.container.parentElement) {
        templateData.container.parentElement.className = templateData.container.parentElement.className + " disabled";
      }
    }
    templateData.actionBar.context = { $treeViewId: this.treeViewId, $treeItemHandle: node.handle };
    const menuActions = this.menus.getResourceActions(node);
    if (menuActions.menu) {
      templateData.elementDisposable.add(menuActions.menu);
    }
    templateData.actionBar.push(menuActions.actions, { icon: true, label: false });
    if (this._actionRunner) {
      templateData.actionBar.actionRunner = this._actionRunner;
    }
    this.setAlignment(templateData.container, node);
    this.treeViewsService.addRenderedTreeItemElement(node, templateData.container);
    this._renderedElements.set(element.element.handle, { original: element, rendered: templateData });
  }
  rerender() {
    const keys = new Set(this._renderedElements.keys());
    for (const key of keys) {
      const value = this._renderedElements.get(key);
      if (value) {
        this.disposeElement(value.original, 0, value.rendered);
        this.renderElement(value.original, 0, value.rendered);
      }
    }
  }
  renderCheckbox(node, templateData) {
    if (node.checkbox) {
      if (!this._hasCheckbox) {
        this._hasCheckbox = true;
        this.rerender();
      }
      if (!templateData.checkbox) {
        const checkbox = new TreeItemCheckbox(
          templateData.checkboxContainer,
          this.checkboxStateHandler,
          this._hoverDelegate
        );
        templateData.checkbox = checkbox;
      }
      templateData.checkbox.render(node);
    } else if (templateData.checkbox) {
      templateData.checkbox.dispose();
      templateData.checkbox = void 0;
    }
  }
  setAlignment(container, treeItem) {
    container.parentElement.classList.toggle("align-icon-with-twisty", !this._hasCheckbox && this.aligner.alignIconWithTwisty(treeItem));
  }
  shouldHideResourceLabelIcon(iconUrl, icon) {
    return !!iconUrl || !!icon && !this.isFileKindThemeIcon(icon);
  }
  shouldShowThemeIcon(hasResource, icon) {
    if (!icon) {
      return false;
    }
    return !(hasResource && this.isFileKindThemeIcon(icon));
  }
  isFolderThemeIcon(icon) {
    return (icon == null ? void 0 : icon.id) === FolderThemeIcon.id;
  }
  isFileKindThemeIcon(icon) {
    if (icon) {
      return icon.id === FileThemeIcon.id || this.isFolderThemeIcon(icon);
    } else {
      return false;
    }
  }
  getFileKind(node) {
    if (node.themeIcon) {
      switch (node.themeIcon.id) {
        case FileThemeIcon.id:
          return FileKind.FILE;
        case FolderThemeIcon.id:
          return FileKind.FOLDER;
      }
    }
    return node.collapsibleState === TreeItemCollapsibleState.Collapsed || node.collapsibleState === TreeItemCollapsibleState.Expanded ? FileKind.FOLDER : FileKind.FILE;
  }
  updateCheckboxes(items) {
    const additionalItems = [];
    if (!this.manuallyManageCheckboxes) {
      for (const item of items) {
        if (item.checkbox !== void 0) {
          let checkChildren = function(currentItem) {
            for (const child of currentItem.children ?? []) {
              if (child.checkbox !== void 0 && currentItem.checkbox !== void 0 && child.checkbox.isChecked !== currentItem.checkbox.isChecked) {
                child.checkbox.isChecked = currentItem.checkbox.isChecked;
                additionalItems.push(child);
                checkChildren(child);
              }
            }
          }, checkParents = function(currentItem) {
            if (currentItem.parent && currentItem.parent.checkbox !== void 0 && currentItem.parent.children) {
              if (visitedParents.has(currentItem.parent)) {
                return;
              } else {
                visitedParents.add(currentItem.parent);
              }
              let someUnchecked = false;
              let someChecked = false;
              for (const child of currentItem.parent.children) {
                if (someUnchecked && someChecked) {
                  break;
                }
                if (child.checkbox !== void 0) {
                  if (child.checkbox.isChecked) {
                    someChecked = true;
                  } else {
                    someUnchecked = true;
                  }
                }
              }
              if (someChecked && !someUnchecked && currentItem.parent.checkbox.isChecked !== true) {
                currentItem.parent.checkbox.isChecked = true;
                additionalItems.push(currentItem.parent);
                checkParents(currentItem.parent);
              } else if (someUnchecked && currentItem.parent.checkbox.isChecked !== false) {
                currentItem.parent.checkbox.isChecked = false;
                additionalItems.push(currentItem.parent);
                checkParents(currentItem.parent);
              }
            }
          };
          checkChildren(item);
          const visitedParents = /* @__PURE__ */ new Set();
          checkParents(item);
        }
      }
    }
    items = items.concat(additionalItems);
    items.forEach((item) => {
      var _a2;
      const renderedItem = this._renderedElements.get(item.handle);
      if (renderedItem) {
        (_a2 = renderedItem.rendered.checkbox) == null ? void 0 : _a2.render(item);
      }
    });
    this._onDidChangeCheckboxState.fire(items);
  }
  disposeElement(resource, index, templateData) {
    var _a2;
    templateData.elementDisposable.clear();
    this._renderedElements.delete(resource.element.handle);
    this.treeViewsService.removeRenderedTreeItemElement(resource.element);
    (_a2 = templateData.checkbox) == null ? void 0 : _a2.dispose();
    templateData.checkbox = void 0;
  }
  disposeTemplate(templateData) {
    templateData.resourceLabel.dispose();
    templateData.actionBar.dispose();
    templateData.elementDisposable.dispose();
  }
}, _v.ITEM_HEIGHT = 22, _v.TREE_TEMPLATE_ID = "treeExplorer", _v);
TreeRenderer = __decorate([
  __param(7, IThemeService),
  __param(8, IConfigurationService),
  __param(9, ILabelService),
  __param(10, IHoverService),
  __param(11, ITreeViewsService),
  __param(12, IContextKeyService)
], TreeRenderer);
class Aligner extends Disposable {
  constructor(themeService) {
    super();
    this.themeService = themeService;
  }
  set tree(tree) {
    this._tree = tree;
  }
  alignIconWithTwisty(treeItem) {
    if (treeItem.collapsibleState !== TreeItemCollapsibleState.None) {
      return false;
    }
    if (!this.hasIcon(treeItem)) {
      return false;
    }
    if (this._tree) {
      const parent = this._tree.getParentElement(treeItem) || this._tree.getInput();
      if (this.hasIcon(parent)) {
        return !!parent.children && parent.children.some(
          (c) => c.collapsibleState !== TreeItemCollapsibleState.None && !this.hasIcon(c)
        );
      }
      return !!parent.children && parent.children.every((c) => c.collapsibleState === TreeItemCollapsibleState.None || !this.hasIcon(c));
    } else {
      return false;
    }
  }
  hasIcon(node) {
    const icon = this.themeService.getColorTheme().type === ColorScheme.LIGHT ? node.icon : node.iconDark;
    if (icon) {
      return true;
    }
    if (node.resourceUri || node.themeIcon) {
      const fileIconTheme = this.themeService.getFileIconTheme();
      const isFolder = node.themeIcon ? node.themeIcon.id === FolderThemeIcon.id : node.collapsibleState !== TreeItemCollapsibleState.None;
      if (isFolder) {
        return fileIconTheme.hasFileIcons && fileIconTheme.hasFolderIcons;
      }
      return fileIconTheme.hasFileIcons;
    }
    return false;
  }
}
class MultipleSelectionActionRunner extends ActionRunner {
  constructor(notificationService, getSelectedResources) {
    super();
    this.getSelectedResources = getSelectedResources;
    this._register(this.onDidRun((e) => {
      if (e.error && !isCancellationError(e.error)) {
        notificationService.error(localize(
          "command-error",
          "Error running command {1}: {0}. This is likely caused by the extension that contributes {1}.",
          e.error.message,
          e.action.id
        ));
      }
    }));
  }
  async runAction(action, context) {
    const selection = this.getSelectedResources();
    let selectionHandleArgs = void 0;
    let actionInSelected = false;
    if (selection.length > 1) {
      selectionHandleArgs = selection.map((selected) => {
        if (selected.handle === context.$treeItemHandle || context.$selectedTreeItems) {
          actionInSelected = true;
        }
        return { $treeViewId: context.$treeViewId, $treeItemHandle: selected.handle };
      });
    }
    if (!actionInSelected) {
      selectionHandleArgs = void 0;
    }
    await action.run(context, selectionHandleArgs);
  }
}
let TreeMenus = class TreeMenus2 extends Disposable {
  constructor(id, menuService) {
    super();
    this.id = id;
    this.menuService = menuService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  getResourceActions(element) {
    const actions = this.getActions(MenuId.ViewItemContext, element, true);
    return { menu: actions.menu, actions: actions.primary };
  }
  getResourceContextActions(element) {
    return this.getActions(MenuId.ViewItemContext, element).secondary;
  }
  setContextKeyService(service) {
    this.contextKeyService = service;
  }
  getActions(menuId, element, listen = false) {
    if (!this.contextKeyService) {
      return { primary: [], secondary: [] };
    }
    const contextKeyService = this.contextKeyService.createOverlay([
      ["view", this.id],
      ["viewItem", element.contextValue]
    ]);
    const menu = this.menuService.createMenu(menuId, contextKeyService);
    const primary = [];
    const secondary = [];
    const result = { primary, secondary, menu };
    createAndFillInContextMenuActions(menu, { shouldForwardArgs: true }, result, "inline");
    if (listen) {
      this._register(menu.onDidChange(() => this._onDidChange.fire(element)));
    } else {
      menu.dispose();
    }
    return result;
  }
  dispose() {
    this.contextKeyService = void 0;
    super.dispose();
  }
};
TreeMenus = __decorate([
  __param(1, IMenuService)
], TreeMenus);
let CustomTreeView = class CustomTreeView2 extends AbstractTreeView {
  constructor(id, title, extensionId, themeService, instantiationService, commandService, configurationService, progressService, contextMenuService, keybindingService, notificationService, viewDescriptorService, contextKeyService, hoverService, extensionService, activityService, telemetryService, logService) {
    super(id, title, themeService, instantiationService, commandService, configurationService, progressService, contextMenuService, keybindingService, notificationService, viewDescriptorService, hoverService, contextKeyService, activityService, logService);
    this.extensionId = extensionId;
    this.extensionService = extensionService;
    this.telemetryService = telemetryService;
    this.activated = false;
  }
  activate() {
    if (!this.activated) {
      this.telemetryService.publicLog2("Extension:ViewActivate", {
        extensionId: new TelemetryTrustedValue(this.extensionId),
        id: this.id
      });
      this.createTree();
      this.progressService.withProgress({ location: this.id }, () => this.extensionService.activateByEvent(`onView:${this.id}`)).then(() => timeout(2e3)).then(() => {
        this.updateMessage();
      });
      this.activated = true;
    }
  }
};
CustomTreeView = __decorate([
  __param(3, IThemeService),
  __param(4, IInstantiationService),
  __param(5, ICommandService),
  __param(6, IConfigurationService),
  __param(7, IProgressService),
  __param(8, IContextMenuService),
  __param(9, IKeybindingService),
  __param(10, INotificationService),
  __param(11, IViewDescriptorService),
  __param(12, IContextKeyService),
  __param(13, IHoverService),
  __param(14, IExtensionService),
  __param(15, IActivityService),
  __param(16, ITelemetryService),
  __param(17, ILogService)
], CustomTreeView);
let CustomTreeViewDragAndDrop = class CustomTreeViewDragAndDrop2 {
  constructor(treeId, labelService, instantiationService, treeViewsDragAndDropService, logService) {
    this.treeId = treeId;
    this.labelService = labelService;
    this.instantiationService = instantiationService;
    this.treeViewsDragAndDropService = treeViewsDragAndDropService;
    this.logService = logService;
    this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
    this.treeMimeType = `application/vnd.code.tree.${treeId.toLowerCase()}`;
  }
  set controller(controller) {
    this.dndController = controller;
  }
  handleDragAndLog(dndController, itemHandles, uuid, dragCancellationToken) {
    return dndController.handleDrag(itemHandles, uuid, dragCancellationToken).then((additionalDataTransfer) => {
      if (additionalDataTransfer) {
        const unlistedTypes = [];
        for (const item of additionalDataTransfer) {
          if (item[0] !== this.treeMimeType && dndController.dragMimeTypes.findIndex((value) => value === item[0]) < 0) {
            unlistedTypes.push(item[0]);
          }
        }
        if (unlistedTypes.length) {
          this.logService.warn(`Drag and drop controller for tree ${this.treeId} adds the following data transfer types but does not declare them in dragMimeTypes: ${unlistedTypes.join(", ")}`);
        }
      }
      return additionalDataTransfer;
    });
  }
  addExtensionProvidedTransferTypes(originalEvent, itemHandles) {
    var _a2;
    if (!originalEvent.dataTransfer || !this.dndController) {
      return;
    }
    const uuid = generateUuid();
    this.dragCancellationToken = new CancellationTokenSource();
    this.treeViewsDragAndDropService.addDragOperationTransfer(uuid, this.handleDragAndLog(this.dndController, itemHandles, uuid, this.dragCancellationToken.token));
    this.treeItemsTransfer.setData([new DraggedTreeItemsIdentifier(uuid)], DraggedTreeItemsIdentifier.prototype);
    originalEvent.dataTransfer.clearData(Mimes.text);
    if (this.dndController.dragMimeTypes.find((element) => element === Mimes.uriList)) {
      (_a2 = originalEvent.dataTransfer) == null ? void 0 : _a2.setData(DataTransfers.RESOURCES, "");
    }
    this.dndController.dragMimeTypes.forEach((supportedType) => {
      var _a3;
      (_a3 = originalEvent.dataTransfer) == null ? void 0 : _a3.setData(supportedType, "");
    });
  }
  addResourceInfoToTransfer(originalEvent, resources) {
    if (resources.length && originalEvent.dataTransfer) {
      this.instantiationService.invokeFunction((accessor) => fillEditorsDragData(accessor, resources, originalEvent));
      const fileResources = resources.filter((s) => s.scheme === Schemas.file).map((r) => r.fsPath);
      if (fileResources.length) {
        originalEvent.dataTransfer.setData(CodeDataTransfers.FILES, JSON.stringify(fileResources));
      }
    }
  }
  onDragStart(data, originalEvent) {
    if (originalEvent.dataTransfer) {
      const treeItemsData = data.getData();
      const resources = [];
      const sourceInfo = {
        id: this.treeId,
        itemHandles: []
      };
      treeItemsData.forEach((item) => {
        sourceInfo.itemHandles.push(item.handle);
        if (item.resourceUri) {
          resources.push(URI.revive(item.resourceUri));
        }
      });
      this.addResourceInfoToTransfer(originalEvent, resources);
      this.addExtensionProvidedTransferTypes(originalEvent, sourceInfo.itemHandles);
      originalEvent.dataTransfer.setData(this.treeMimeType, JSON.stringify(sourceInfo));
    }
  }
  debugLog(types) {
    if (types.size) {
      this.logService.debug(`TreeView dragged mime types: ${Array.from(types).join(", ")}`);
    } else {
      this.logService.debug(`TreeView dragged with no supported mime types.`);
    }
  }
  onDragOver(data, targetElement, targetIndex, originalEvent) {
    const dataTransfer = toExternalVSDataTransfer(originalEvent.dataTransfer);
    const types = new Set(Array.from(dataTransfer, (x) => x[0]));
    if (originalEvent.dataTransfer) {
      for (const item of originalEvent.dataTransfer.items) {
        if (item.kind === "file" || item.type === DataTransfers.RESOURCES.toLowerCase()) {
          types.add(Mimes.uriList);
          break;
        }
      }
    }
    this.debugLog(types);
    const dndController = this.dndController;
    if (!dndController || !originalEvent.dataTransfer || dndController.dropMimeTypes.length === 0) {
      return false;
    }
    const dragContainersSupportedType = Array.from(types).some((value, index) => {
      if (value === this.treeMimeType) {
        return true;
      } else {
        return dndController.dropMimeTypes.indexOf(value) >= 0;
      }
    });
    if (dragContainersSupportedType) {
      return { accept: true, bubble: 0, autoExpand: true };
    }
    return false;
  }
  getDragURI(element) {
    if (!this.dndController) {
      return null;
    }
    return element.resourceUri ? URI.revive(element.resourceUri).toString() : element.handle;
  }
  getDragLabel(elements) {
    if (!this.dndController) {
      return void 0;
    }
    if (elements.length > 1) {
      return String(elements.length);
    }
    const element = elements[0];
    return element.label ? element.label.label : element.resourceUri ? this.labelService.getUriLabel(URI.revive(element.resourceUri)) : void 0;
  }
  async drop(data, targetNode, targetIndex, originalEvent) {
    const dndController = this.dndController;
    if (!originalEvent.dataTransfer || !dndController) {
      return;
    }
    let treeSourceInfo;
    let willDropUuid;
    if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
      willDropUuid = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype)[0].identifier;
    }
    const originalDataTransfer = toExternalVSDataTransfer(originalEvent.dataTransfer, true);
    const outDataTransfer = new VSDataTransfer();
    for (const [type, item] of originalDataTransfer) {
      if (type === this.treeMimeType || dndController.dropMimeTypes.includes(type) || item.asFile() && dndController.dropMimeTypes.includes(DataTransfers.FILES.toLowerCase())) {
        outDataTransfer.append(type, item);
        if (type === this.treeMimeType) {
          try {
            treeSourceInfo = JSON.parse(await item.asString());
          } catch {
          }
        }
      }
    }
    const additionalDataTransfer = await this.treeViewsDragAndDropService.removeDragOperationTransfer(willDropUuid);
    if (additionalDataTransfer) {
      for (const [type, item] of additionalDataTransfer) {
        outDataTransfer.append(type, item);
      }
    }
    return dndController.handleDrop(outDataTransfer, targetNode, CancellationToken.None, willDropUuid, treeSourceInfo == null ? void 0 : treeSourceInfo.id, treeSourceInfo == null ? void 0 : treeSourceInfo.itemHandles);
  }
  onDragEnd(originalEvent) {
    var _a2, _b2;
    if (((_a2 = originalEvent.dataTransfer) == null ? void 0 : _a2.dropEffect) === "none") {
      (_b2 = this.dragCancellationToken) == null ? void 0 : _b2.cancel();
    }
  }
};
CustomTreeViewDragAndDrop = __decorate([
  __param(1, ILabelService),
  __param(2, IInstantiationService),
  __param(3, ITreeViewsDnDService),
  __param(4, ILogService)
], CustomTreeViewDragAndDrop);
const VIEWLET_ID = "workbench.view.remote";
const _OnAutoForwardedAction = class _OnAutoForwardedAction extends Disposable {
  constructor(notificationService, remoteExplorerService, openerService, externalOpenerService, tunnelService, hostService, logService, contextKeyService) {
    super();
    this.notificationService = notificationService;
    this.remoteExplorerService = remoteExplorerService;
    this.openerService = openerService;
    this.externalOpenerService = externalOpenerService;
    this.tunnelService = tunnelService;
    this.hostService = hostService;
    this.logService = logService;
    this.contextKeyService = contextKeyService;
    this.alreadyOpenedOnce = /* @__PURE__ */ new Set();
    this.lastNotifyTime = /* @__PURE__ */ new Date();
    this.lastNotifyTime.setFullYear(this.lastNotifyTime.getFullYear() - 1);
  }
  async doAction(tunnels) {
    var _a2, _b2;
    this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Starting action for ${(_a2 = tunnels[0]) == null ? void 0 : _a2.tunnelRemotePort}`);
    this.doActionTunnels = tunnels;
    const tunnel = await this.portNumberHeuristicDelay();
    this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Heuristic chose ${tunnel == null ? void 0 : tunnel.tunnelRemotePort}`);
    if (tunnel) {
      const allAttributes = await this.remoteExplorerService.tunnelModel.getAttributes([{ port: tunnel.tunnelRemotePort, host: tunnel.tunnelRemoteHost }]);
      const attributes = (_b2 = allAttributes == null ? void 0 : allAttributes.get(tunnel.tunnelRemotePort)) == null ? void 0 : _b2.onAutoForward;
      this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) onAutoForward action is ${attributes}`);
      switch (attributes) {
        case OnPortForward.OpenBrowserOnce: {
          if (this.alreadyOpenedOnce.has(tunnel.localAddress)) {
            break;
          }
          this.alreadyOpenedOnce.add(tunnel.localAddress);
        }
        case OnPortForward.OpenBrowser: {
          const address = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
          await OpenPortInBrowserAction.run(this.remoteExplorerService.tunnelModel, this.openerService, address);
          break;
        }
        case OnPortForward.OpenPreview: {
          const address = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
          await OpenPortInPreviewAction.run(this.remoteExplorerService.tunnelModel, this.openerService, this.externalOpenerService, address);
          break;
        }
        case OnPortForward.Silent:
          break;
        default: {
          const elapsed = (/* @__PURE__ */ new Date()).getTime() - this.lastNotifyTime.getTime();
          this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) time elapsed since last notification ${elapsed} ms`);
          if (elapsed > _OnAutoForwardedAction.NOTIFY_COOL_DOWN) {
            await this.showNotification(tunnel);
          }
        }
      }
    }
  }
  hide(removedPorts) {
    var _a2;
    if (this.doActionTunnels) {
      this.doActionTunnels = this.doActionTunnels.filter((value) => !removedPorts.includes(value.tunnelRemotePort));
    }
    if (this.lastShownPort && removedPorts.indexOf(this.lastShownPort) >= 0) {
      (_a2 = this.lastNotification) == null ? void 0 : _a2.close();
    }
  }
  async portNumberHeuristicDelay() {
    this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Starting heuristic delay`);
    if (!this.doActionTunnels || this.doActionTunnels.length === 0) {
      return;
    }
    this.doActionTunnels = this.doActionTunnels.sort((a, b) => a.tunnelRemotePort - b.tunnelRemotePort);
    const firstTunnel = this.doActionTunnels.shift();
    if (firstTunnel.tunnelRemotePort % 1e3 === 0) {
      this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Heuristic chose tunnel because % 1000: ${firstTunnel.tunnelRemotePort}`);
      this.newerTunnel = firstTunnel;
      return firstTunnel;
    } else if (firstTunnel.tunnelRemotePort < 1e4 && firstTunnel.tunnelRemotePort !== 9229) {
      this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Heuristic chose tunnel because < 10000: ${firstTunnel.tunnelRemotePort}`);
      this.newerTunnel = firstTunnel;
      return firstTunnel;
    }
    this.logService.trace(`ForwardedPorts: (OnAutoForwardedAction) Waiting for "better" tunnel than ${firstTunnel.tunnelRemotePort}`);
    this.newerTunnel = void 0;
    return new Promise((resolve) => {
      setTimeout(() => {
        var _a2;
        if (this.newerTunnel) {
          resolve(void 0);
        } else if ((_a2 = this.doActionTunnels) == null ? void 0 : _a2.includes(firstTunnel)) {
          resolve(firstTunnel);
        } else {
          resolve(void 0);
        }
      }, 3e3);
    });
  }
  basicMessage(tunnel) {
    return localize(
      "remote.tunnelsView.automaticForward",
      "Your application running on port {0} is available.  ",
      tunnel.tunnelRemotePort
    );
  }
  linkMessage() {
    return localize(
      { key: "remote.tunnelsView.notificationLink2", comment: ["[See all forwarded ports]({0}) is a link. Only translate `See all forwarded ports`. Do not change brackets and parentheses or {0}"] },
      "[See all forwarded ports]({0})",
      `command:${TunnelPanel.ID}.focus`
    );
  }
  async showNotification(tunnel) {
    var _a2;
    if (!await this.hostService.hadLastFocus()) {
      return;
    }
    (_a2 = this.lastNotification) == null ? void 0 : _a2.close();
    let message = this.basicMessage(tunnel);
    const choices = [this.openBrowserChoice(tunnel)];
    if (!isWeb || openPreviewEnabledContext.getValue(this.contextKeyService)) {
      choices.push(this.openPreviewChoice(tunnel));
    }
    if (tunnel.tunnelLocalPort !== tunnel.tunnelRemotePort && this.tunnelService.canElevate && this.tunnelService.isPortPrivileged(tunnel.tunnelRemotePort)) {
      message += localize(
        "remote.tunnelsView.elevationMessage",
        "You'll need to run as superuser to use port {0} locally.  ",
        tunnel.tunnelRemotePort
      );
      choices.unshift(this.elevateChoice(tunnel));
    }
    if (tunnel.privacy === TunnelPrivacyId.Private && isWeb && this.tunnelService.canChangePrivacy) {
      choices.push(this.makePublicChoice(tunnel));
    }
    message += this.linkMessage();
    this.lastNotification = this.notificationService.prompt(Severity$1.Info, message, choices, { neverShowAgain: { id: "remote.tunnelsView.autoForwardNeverShow", isSecondary: true } });
    this.lastShownPort = tunnel.tunnelRemotePort;
    this.lastNotifyTime = /* @__PURE__ */ new Date();
    this.lastNotification.onDidClose(() => {
      this.lastNotification = void 0;
      this.lastShownPort = void 0;
    });
  }
  makePublicChoice(tunnel) {
    return {
      label: localize("remote.tunnelsView.makePublic", "Make Public"),
      run: async () => {
        const oldTunnelDetails = mapHasAddressLocalhostOrAllInterfaces(this.remoteExplorerService.tunnelModel.forwarded, tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
        await this.remoteExplorerService.close({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort }, TunnelCloseReason.Other);
        return this.remoteExplorerService.forward({
          remote: { host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort },
          local: tunnel.tunnelLocalPort,
          name: oldTunnelDetails == null ? void 0 : oldTunnelDetails.name,
          elevateIfNeeded: true,
          privacy: TunnelPrivacyId.Public,
          source: oldTunnelDetails == null ? void 0 : oldTunnelDetails.source
        });
      }
    };
  }
  openBrowserChoice(tunnel) {
    const address = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
    return {
      label: OpenPortInBrowserAction.LABEL,
      run: () => OpenPortInBrowserAction.run(this.remoteExplorerService.tunnelModel, this.openerService, address)
    };
  }
  openPreviewChoice(tunnel) {
    const address = makeAddress(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort);
    return {
      label: OpenPortInPreviewAction.LABEL,
      run: () => OpenPortInPreviewAction.run(this.remoteExplorerService.tunnelModel, this.openerService, this.externalOpenerService, address)
    };
  }
  elevateChoice(tunnel) {
    return {
      label: localize(
        "remote.tunnelsView.elevationButton",
        "Use Port {0} as Sudo...",
        tunnel.tunnelRemotePort
      ),
      run: async () => {
        var _a2;
        await this.remoteExplorerService.close({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort }, TunnelCloseReason.Other);
        const newTunnel = await this.remoteExplorerService.forward({
          remote: { host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort },
          local: tunnel.tunnelRemotePort,
          elevateIfNeeded: true,
          source: AutoTunnelSource
        });
        if (!newTunnel) {
          return;
        }
        (_a2 = this.lastNotification) == null ? void 0 : _a2.close();
        this.lastShownPort = newTunnel.tunnelRemotePort;
        this.lastNotification = this.notificationService.prompt(Severity$1.Info, this.basicMessage(newTunnel) + this.linkMessage(), [this.openBrowserChoice(newTunnel), this.openPreviewChoice(tunnel)], { neverShowAgain: { id: "remote.tunnelsView.autoForwardNeverShow", isSecondary: true } });
        this.lastNotification.onDidClose(() => {
          this.lastNotification = void 0;
          this.lastShownPort = void 0;
        });
      }
    };
  }
};
_OnAutoForwardedAction.NOTIFY_COOL_DOWN = 5e3;
let OnAutoForwardedAction = _OnAutoForwardedAction;
const storageKeys = {
  webviewState: "webviewState"
};
let WebviewViewPane = class WebviewViewPane2 extends ViewPane {
  static getOriginStore(storageService) {
    this._originStore ?? (this._originStore = new ExtensionKeyedWebviewOriginStore("webviewViews.origins", storageService));
    return this._originStore;
  }
  constructor(options, configurationService, contextKeyService, contextMenuService, instantiationService, keybindingService, openerService, telemetryService, themeService, viewDescriptorService, activityService, extensionService, progressService, storageService, viewService, webviewService, webviewViewService) {
    super({ ...options, titleMenuId: MenuId.ViewTitle, showActions: ViewPaneShowActions.WhenExpanded }, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
    this.activityService = activityService;
    this.extensionService = extensionService;
    this.progressService = progressService;
    this.storageService = storageService;
    this.viewService = viewService;
    this.webviewService = webviewService;
    this.webviewViewService = webviewViewService;
    this._webview = this._register(new MutableDisposable());
    this._webviewDisposables = this._register(new DisposableStore());
    this._activated = false;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._onDispose = this._register(new Emitter());
    this.onDispose = this._onDispose.event;
    this.extensionId = options.fromExtensionId;
    this.defaultTitle = this.title;
    this.memento = new Memento(`webviewView.${this.id}`, storageService);
    this.viewState = this.memento.getMemento(1, 1);
    this._register(this.onDidChangeBodyVisibility(() => this.updateTreeVisibility()));
    this._register(this.webviewViewService.onNewResolverRegistered((e) => {
      if (e.viewType === this.id) {
        this.updateTreeVisibility();
      }
    }));
    this.updateTreeVisibility();
  }
  dispose() {
    this._onDispose.fire();
    clearTimeout(this._repositionTimeout);
    super.dispose();
  }
  focus() {
    var _a2;
    super.focus();
    (_a2 = this._webview.value) == null ? void 0 : _a2.focus();
  }
  renderBody(container) {
    super.renderBody(container);
    this._container = container;
    this._rootContainer = void 0;
    if (!this._resizeObserver) {
      this._resizeObserver = new ResizeObserver(() => {
        setTimeout(() => {
          this.layoutWebview();
        }, 0);
      });
      this._register(toDisposable(() => {
        this._resizeObserver.disconnect();
      }));
      this._resizeObserver.observe(container);
    }
  }
  saveState() {
    if (this._webview.value) {
      this.viewState[storageKeys.webviewState] = this._webview.value.state;
    }
    this.memento.saveMemento();
    super.saveState();
  }
  layoutBody(height, width) {
    super.layoutBody(height, width);
    this.layoutWebview(new Dimension(width, height));
  }
  updateTreeVisibility() {
    var _a2, _b2;
    if (this.isBodyVisible()) {
      this.activate();
      (_a2 = this._webview.value) == null ? void 0 : _a2.claim(this, void 0);
    } else {
      (_b2 = this._webview.value) == null ? void 0 : _b2.release(this);
    }
  }
  activate() {
    if (this._activated) {
      return;
    }
    this._activated = true;
    const origin = this.extensionId ? WebviewViewPane2.getOriginStore(this.storageService).getOrigin(this.id, this.extensionId) : void 0;
    const webview = this.webviewService.createWebviewOverlay({
      origin,
      providedViewType: this.id,
      title: this.title,
      options: { purpose: "webviewView" },
      contentOptions: {},
      extension: this.extensionId ? { id: this.extensionId } : void 0
    });
    webview.state = this.viewState[storageKeys.webviewState];
    this._webview.value = webview;
    if (this._container) {
      this.layoutWebview();
    }
    this._webviewDisposables.add(toDisposable(() => {
      var _a2;
      (_a2 = this._webview.value) == null ? void 0 : _a2.release(this);
    }));
    this._webviewDisposables.add(webview.onDidUpdateState(() => {
      this.viewState[storageKeys.webviewState] = webview.state;
    }));
    for (const event of [EventType.DRAG, EventType.DRAG_END, EventType.DRAG_ENTER, EventType.DRAG_LEAVE, EventType.DRAG_START]) {
      this._webviewDisposables.add(addDisposableListener(this._webview.value.container, event, (e) => {
        e.preventDefault();
        e.stopImmediatePropagation();
        this.dropTargetElement.dispatchEvent(new DragEvent(e.type, e));
      }));
    }
    this._webviewDisposables.add(new WebviewWindowDragMonitor(() => this._webview.value));
    const source = this._webviewDisposables.add(new CancellationTokenSource());
    this.withProgress(async () => {
      await this.extensionService.activateByEvent(`onView:${this.id}`);
      const self2 = this;
      const webviewView = {
        webview,
        onDidChangeVisibility: this.onDidChangeBodyVisibility,
        onDispose: this.onDispose,
        get title() {
          return self2.setTitle;
        },
        set title(value) {
          self2.updateTitle(value);
        },
        get description() {
          return self2.titleDescription;
        },
        set description(value) {
          self2.updateTitleDescription(value);
        },
        get badge() {
          return self2.badge;
        },
        set badge(badge) {
          self2.updateBadge(badge);
        },
        dispose: () => {
          this._activated = false;
          this._webview.clear();
          this._webviewDisposables.clear();
        },
        show: (preserveFocus) => {
          this.viewService.openView(this.id, !preserveFocus);
        }
      };
      await this.webviewViewService.resolve(this.id, webviewView, source.token);
    });
  }
  updateTitle(value) {
    this.setTitle = value;
    super.updateTitle(typeof value === "string" ? value : this.defaultTitle);
  }
  updateBadge(badge) {
    var _a2, _b2;
    if (((_a2 = this.badge) == null ? void 0 : _a2.value) === (badge == null ? void 0 : badge.value) && ((_b2 = this.badge) == null ? void 0 : _b2.tooltip) === (badge == null ? void 0 : badge.tooltip)) {
      return;
    }
    if (this.activity) {
      this.activity.dispose();
      this.activity = void 0;
    }
    this.badge = badge;
    if (badge) {
      const activity = {
        badge: new NumberBadge(badge.value, () => badge.tooltip),
        priority: 150
      };
      this.activityService.showViewActivity(this.id, activity);
    }
  }
  async withProgress(task) {
    return this.progressService.withProgress({ location: this.id, delay: 500 }, task);
  }
  onDidScrollRoot() {
    this.layoutWebview();
  }
  doLayoutWebview(dimension) {
    const webviewEntry = this._webview.value;
    if (!this._container || !webviewEntry) {
      return;
    }
    if (!this._rootContainer || !this._rootContainer.isConnected) {
      this._rootContainer = this.findRootContainer(this._container);
    }
    webviewEntry.layoutWebviewOverElement(this._container, dimension, this._rootContainer);
  }
  layoutWebview(dimension) {
    this.doLayoutWebview(dimension);
    clearTimeout(this._repositionTimeout);
    this._repositionTimeout = setTimeout(() => this.doLayoutWebview(dimension), 200);
  }
  findRootContainer(container) {
    return withNullAsUndefined(findParentWithClass(container, "monaco-scrollable-element"));
  }
};
WebviewViewPane = __decorate([
  __param(1, IConfigurationService),
  __param(2, IContextKeyService),
  __param(3, IContextMenuService),
  __param(4, IInstantiationService),
  __param(5, IKeybindingService),
  __param(6, IOpenerService),
  __param(7, ITelemetryService),
  __param(8, IThemeService),
  __param(9, IViewDescriptorService),
  __param(10, IActivityService),
  __param(11, IExtensionService),
  __param(12, IProgressService),
  __param(13, IStorageService),
  __param(14, IViewsService),
  __param(15, IWebviewService),
  __param(16, IWebviewViewService)
], WebviewViewPane);
const viewsContainerSchema = {
  type: "object",
  properties: {
    id: {
      description: localize(
        { key: "vscode.extension.contributes.views.containers.id", comment: ["Contribution refers to those that an extension contributes to VS Code through an extension/contribution point. "] },
        "Unique id used to identify the container in which views can be contributed using 'views' contribution point"
      ),
      type: "string",
      pattern: "^[a-zA-Z0-9_-]+$"
    },
    title: {
      description: localize(
        "vscode.extension.contributes.views.containers.title",
        "Human readable string used to render the container"
      ),
      type: "string"
    },
    icon: {
      description: localize(
        "vscode.extension.contributes.views.containers.icon",
        "Path to the container icon. Icons are 24x24 centered on a 50x40 block and have a fill color of 'rgb(215, 218, 224)' or '#d7dae0'. It is recommended that icons be in SVG, though any image file type is accepted."
      ),
      type: "string"
    }
  },
  required: ["id", "title", "icon"]
};
const viewsContainersContribution = {
  description: localize(
    "vscode.extension.contributes.viewsContainers",
    "Contributes views containers to the editor"
  ),
  type: "object",
  properties: {
    "activitybar": {
      description: localize(
        "views.container.activitybar",
        "Contribute views containers to Activity Bar"
      ),
      type: "array",
      items: viewsContainerSchema
    },
    "panel": {
      description: localize("views.container.panel", "Contribute views containers to Panel"),
      type: "array",
      items: viewsContainerSchema
    }
  }
};
var ViewType;
(function(ViewType2) {
  ViewType2["Tree"] = "tree";
  ViewType2["Webview"] = "webview";
})(ViewType || (ViewType = {}));
var InitialVisibility;
(function(InitialVisibility2) {
  InitialVisibility2["Visible"] = "visible";
  InitialVisibility2["Hidden"] = "hidden";
  InitialVisibility2["Collapsed"] = "collapsed";
})(InitialVisibility || (InitialVisibility = {}));
const viewDescriptor = {
  type: "object",
  required: ["id", "name"],
  defaultSnippets: [{ body: { id: "${1:id}", name: "${2:name}" } }],
  properties: {
    type: {
      markdownDescription: localize(
        "vscode.extension.contributes.view.type",
        "Type of the view. This can either be `tree` for a tree view based view or `webview` for a webview based view. The default is `tree`."
      ),
      type: "string",
      enum: [
        "tree",
        "webview"
      ],
      markdownEnumDescriptions: [
        localize(
          "vscode.extension.contributes.view.tree",
          "The view is backed by a `TreeView` created by `createTreeView`."
        ),
        localize(
          "vscode.extension.contributes.view.webview",
          "The view is backed by a `WebviewView` registered by `registerWebviewViewProvider`."
        )
      ]
    },
    id: {
      markdownDescription: localize(
        "vscode.extension.contributes.view.id",
        "Identifier of the view. This should be unique across all views. It is recommended to include your extension id as part of the view id. Use this to register a data provider through `vscode.window.registerTreeDataProviderForView` API. Also to trigger activating your extension by registering `onView:${id}` event to `activationEvents`."
      ),
      type: "string"
    },
    name: {
      description: localize(
        "vscode.extension.contributes.view.name",
        "The human-readable name of the view. Will be shown"
      ),
      type: "string"
    },
    when: {
      description: localize(
        "vscode.extension.contributes.view.when",
        "Condition which must be true to show this view"
      ),
      type: "string"
    },
    icon: {
      description: localize(
        "vscode.extension.contributes.view.icon",
        "Path to the view icon. View icons are displayed when the name of the view cannot be shown. It is recommended that icons be in SVG, though any image file type is accepted."
      ),
      type: "string"
    },
    contextualTitle: {
      description: localize(
        "vscode.extension.contributes.view.contextualTitle",
        "Human-readable context for when the view is moved out of its original location. By default, the view's container name will be used."
      ),
      type: "string"
    },
    visibility: {
      description: localize(
        "vscode.extension.contributes.view.initialState",
        "Initial state of the view when the extension is first installed. Once the user has changed the view state by collapsing, moving, or hiding the view, the initial state will not be used again."
      ),
      type: "string",
      enum: [
        "visible",
        "hidden",
        "collapsed"
      ],
      default: "visible",
      enumDescriptions: [
        localize(
          "vscode.extension.contributes.view.initialState.visible",
          "The default initial state for the view. In most containers the view will be expanded, however; some built-in containers (explorer, scm, and debug) show all contributed views collapsed regardless of the `visibility`."
        ),
        localize(
          "vscode.extension.contributes.view.initialState.hidden",
          "The view will not be shown in the view container, but will be discoverable through the views menu and other view entry points and can be un-hidden by the user."
        ),
        localize(
          "vscode.extension.contributes.view.initialState.collapsed",
          "The view will show in the view container, but will be collapsed."
        )
      ]
    },
    initialSize: {
      type: "number",
      description: localize(
        "vscode.extension.contributs.view.size",
        "The initial size of the view. The size will behave like the css 'flex' property, and will set the initial size when the view is first shown. In the side bar, this is the height of the view. This value is only respected when the same extension owns both the view and the view container."
      )
    }
  }
};
const remoteViewDescriptor = {
  type: "object",
  required: ["id", "name"],
  properties: {
    id: {
      description: localize(
        "vscode.extension.contributes.view.id",
        "Identifier of the view. This should be unique across all views. It is recommended to include your extension id as part of the view id. Use this to register a data provider through `vscode.window.registerTreeDataProviderForView` API. Also to trigger activating your extension by registering `onView:${id}` event to `activationEvents`."
      ),
      type: "string"
    },
    name: {
      description: localize(
        "vscode.extension.contributes.view.name",
        "The human-readable name of the view. Will be shown"
      ),
      type: "string"
    },
    when: {
      description: localize(
        "vscode.extension.contributes.view.when",
        "Condition which must be true to show this view"
      ),
      type: "string"
    },
    group: {
      description: localize("vscode.extension.contributes.view.group", "Nested group in the viewlet"),
      type: "string"
    },
    remoteName: {
      description: localize(
        "vscode.extension.contributes.view.remoteName",
        "The name of the remote type associated with this view"
      ),
      type: ["string", "array"],
      items: {
        type: "string"
      }
    }
  }
};
const viewsContribution = {
  description: localize("vscode.extension.contributes.views", "Contributes views to the editor"),
  type: "object",
  properties: {
    "explorer": {
      description: localize(
        "views.explorer",
        "Contributes views to Explorer container in the Activity bar"
      ),
      type: "array",
      items: viewDescriptor,
      default: []
    },
    "debug": {
      description: localize("views.debug", "Contributes views to Debug container in the Activity bar"),
      type: "array",
      items: viewDescriptor,
      default: []
    },
    "scm": {
      description: localize("views.scm", "Contributes views to SCM container in the Activity bar"),
      type: "array",
      items: viewDescriptor,
      default: []
    },
    "test": {
      description: localize("views.test", "Contributes views to Test container in the Activity bar"),
      type: "array",
      items: viewDescriptor,
      default: []
    },
    "remote": {
      description: localize(
        "views.remote",
        "Contributes views to Remote container in the Activity bar. To contribute to this container, enableProposedApi needs to be turned on"
      ),
      type: "array",
      items: remoteViewDescriptor,
      default: []
    }
  },
  additionalProperties: {
    description: localize("views.contributed", "Contributes views to contributed views container"),
    type: "array",
    items: viewDescriptor,
    default: []
  }
};
const viewsContainersExtensionPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "viewsContainers",
  jsonSchema: viewsContainersContribution
});
const viewsExtensionPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "views",
  deps: [viewsContainersExtensionPoint],
  jsonSchema: viewsContribution,
  activationEventsGenerator: (viewExtensionPointTypeArray, result) => {
    for (const viewExtensionPointType of viewExtensionPointTypeArray) {
      for (const viewDescriptors of Object.values(viewExtensionPointType)) {
        for (const viewDescriptor2 of viewDescriptors) {
          if (viewDescriptor2.id) {
            result.push(`onView:${viewDescriptor2.id}`);
          }
        }
      }
    }
  }
});
const CUSTOM_VIEWS_START_ORDER = 7;
let ViewsExtensionHandler = class ViewsExtensionHandler2 {
  constructor(instantiationService, logService) {
    this.instantiationService = instantiationService;
    this.logService = logService;
    this.viewContainersRegistry = Registry.as(Extensions$1.ViewContainersRegistry);
    this.viewsRegistry = Registry.as(Extensions$1.ViewsRegistry);
    this.handleAndRegisterCustomViewContainers();
    this.handleAndRegisterCustomViews();
    let showTreeHoverCancellation = new CancellationTokenSource();
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "workbench.action.showTreeHover",
      handler: async (accessor, ...args) => {
        showTreeHoverCancellation.cancel();
        showTreeHoverCancellation = new CancellationTokenSource();
        const listService = accessor.get(IListService);
        const treeViewsService = accessor.get(ITreeViewsService);
        const hoverService = accessor.get(IHoverService);
        const lastFocusedList = listService.lastFocusedList;
        if (!(lastFocusedList instanceof AsyncDataTree)) {
          return;
        }
        const focus = lastFocusedList.getFocus();
        if (!focus || focus.length === 0) {
          return;
        }
        const treeItem = focus[0];
        if (treeItem instanceof ResolvableTreeItem) {
          await treeItem.resolve(showTreeHoverCancellation.token);
        }
        if (!treeItem.tooltip) {
          return;
        }
        const element = treeViewsService.getRenderedTreeElement(treeItem);
        if (!element) {
          return;
        }
        hoverService.showHover({
          content: treeItem.tooltip,
          target: element,
          hoverPosition: 2,
          hideOnHover: false
        }, true);
      },
      weight: 200,
      primary: KeyChord(2048 | 41, 2048 | 39),
      when: ContextKeyExpr.and(RawCustomTreeViewContextKey, WorkbenchListFocusContextKey)
    });
  }
  handleAndRegisterCustomViewContainers() {
    viewsContainersExtensionPoint.setHandler((extensions, { added, removed }) => {
      if (removed.length) {
        this.removeCustomViewContainers(removed);
      }
      if (added.length) {
        this.addCustomViewContainers(added, this.viewContainersRegistry.all);
      }
    });
  }
  addCustomViewContainers(extensionPoints, existingViewContainers) {
    const viewContainersRegistry = Registry.as(Extensions$1.ViewContainersRegistry);
    let activityBarOrder = CUSTOM_VIEWS_START_ORDER + viewContainersRegistry.all.filter((v) => !!v.extensionId && viewContainersRegistry.getViewContainerLocation(v) === 0).length;
    let panelOrder = 5 + viewContainersRegistry.all.filter((v) => !!v.extensionId && viewContainersRegistry.getViewContainerLocation(v) === 1).length + 1;
    for (const { value, collector, description } of extensionPoints) {
      Object.entries(value).forEach(([key, value2]) => {
        if (!this.isValidViewsContainer(value2, collector)) {
          return;
        }
        switch (key) {
          case "activitybar":
            activityBarOrder = this.registerCustomViewContainers(value2, description, activityBarOrder, existingViewContainers, 0);
            break;
          case "panel":
            panelOrder = this.registerCustomViewContainers(value2, description, panelOrder, existingViewContainers, 1);
            break;
        }
      });
    }
  }
  removeCustomViewContainers(extensionPoints) {
    const viewContainersRegistry = Registry.as(Extensions$1.ViewContainersRegistry);
    const removedExtensions = extensionPoints.reduce((result, e) => {
      result.add(e.description.identifier);
      return result;
    }, new ExtensionIdentifierSet());
    for (const viewContainer of viewContainersRegistry.all) {
      if (viewContainer.extensionId && removedExtensions.has(viewContainer.extensionId)) {
        const views = this.viewsRegistry.getViews(viewContainer);
        if (views.length) {
          this.viewsRegistry.moveViews(views, this.getDefaultViewContainer());
        }
        this.deregisterCustomViewContainer(viewContainer);
      }
    }
  }
  isValidViewsContainer(viewsContainersDescriptors, collector) {
    if (!Array.isArray(viewsContainersDescriptors)) {
      collector.error(localize("viewcontainer requirearray", "views containers must be an array"));
      return false;
    }
    for (const descriptor of viewsContainersDescriptors) {
      if (typeof descriptor.id !== "string" && isFalsyOrWhitespace(descriptor.id)) {
        collector.error(localize(
          "requireidstring",
          "property `{0}` is mandatory and must be of type `string` with non-empty value. Only alphanumeric characters, '_', and '-' are allowed.",
          "id"
        ));
        return false;
      }
      if (!/^[a-z0-9_-]+$/i.test(descriptor.id)) {
        collector.error(localize(
          "requireidstring",
          "property `{0}` is mandatory and must be of type `string` with non-empty value. Only alphanumeric characters, '_', and '-' are allowed.",
          "id"
        ));
        return false;
      }
      if (typeof descriptor.title !== "string") {
        collector.error(localize(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "title"
        ));
        return false;
      }
      if (typeof descriptor.icon !== "string") {
        collector.error(localize(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "icon"
        ));
        return false;
      }
      if (isFalsyOrWhitespace(descriptor.title)) {
        collector.warn(localize(
          "requirenonemptystring",
          "property `{0}` is mandatory and must be of type `string` with non-empty value",
          "title"
        ));
        return true;
      }
    }
    return true;
  }
  registerCustomViewContainers(containers, extension, order, existingViewContainers, location) {
    containers.forEach((descriptor) => {
      const themeIcon = ThemeIcon.fromString(descriptor.icon);
      const icon = themeIcon || joinPath(extension.extensionLocation, descriptor.icon);
      const id = `workbench.view.extension.${descriptor.id}`;
      const title = descriptor.title || id;
      const viewContainer = this.registerCustomViewContainer(id, title, icon, order++, extension.identifier, location);
      if (existingViewContainers.length) {
        const viewsToMove = [];
        for (const existingViewContainer of existingViewContainers) {
          if (viewContainer !== existingViewContainer) {
            viewsToMove.push(...this.viewsRegistry.getViews(existingViewContainer).filter((view) => view.originalContainerId === descriptor.id));
          }
        }
        if (viewsToMove.length) {
          this.viewsRegistry.moveViews(viewsToMove, viewContainer);
        }
      }
    });
    return order;
  }
  registerCustomViewContainer(id, title, icon, order, extensionId, location) {
    let viewContainer = this.viewContainersRegistry.get(id);
    if (!viewContainer) {
      viewContainer = this.viewContainersRegistry.registerViewContainer({
        id,
        title,
        extensionId,
        ctorDescriptor: new SyncDescriptor(ViewPaneContainer, [id, { mergeViewWithContainerWhenSingleView: true }]),
        hideIfEmpty: true,
        order,
        icon
      }, location);
    }
    return viewContainer;
  }
  deregisterCustomViewContainer(viewContainer) {
    this.viewContainersRegistry.deregisterViewContainer(viewContainer);
    Registry.as(Extensions.Viewlets).deregisterPaneComposite(viewContainer.id);
  }
  handleAndRegisterCustomViews() {
    viewsExtensionPoint.setHandler((extensions, { added, removed }) => {
      if (removed.length) {
        this.removeViews(removed);
      }
      if (added.length) {
        this.addViews(added);
      }
    });
  }
  addViews(extensions) {
    const viewIds = /* @__PURE__ */ new Set();
    const allViewDescriptors = [];
    for (const extension of extensions) {
      const { value, collector } = extension;
      Object.entries(value).forEach(([key, value2]) => {
        var _a2;
        if (!this.isValidViewDescriptors(value2, collector)) {
          return;
        }
        if (key === "remote" && !isProposedApiEnabled(extension.description, "contribViewsRemote")) {
          collector.warn(localize(
            "ViewContainerRequiresProposedAPI",
            `View container '{0}' requires 'enabledApiProposals: ["contribViewsRemote"]' to be added to 'Remote'.`,
            key
          ));
          return;
        }
        const viewContainer = this.getViewContainer(key);
        if (!viewContainer) {
          collector.warn(localize(
            "ViewContainerDoesnotExist",
            "View container '{0}' does not exist and all views registered to it will be added to 'Explorer'.",
            key
          ));
        }
        const container = viewContainer || this.getDefaultViewContainer();
        const viewDescriptors = [];
        for (let index = 0; index < value2.length; index++) {
          const item = value2[index];
          if (viewIds.has(item.id)) {
            collector.error(localize(
              "duplicateView1",
              "Cannot register multiple views with same id `{0}`",
              item.id
            ));
            continue;
          }
          if (this.viewsRegistry.getView(item.id) !== null) {
            collector.error(localize("duplicateView2", "A view with id `{0}` is already registered.", item.id));
            continue;
          }
          const order = ExtensionIdentifier.equals(extension.description.identifier, container.extensionId) ? index + 1 : container.viewOrderDelegate ? container.viewOrderDelegate.getOrder(item.group) : void 0;
          let icon;
          if (typeof item.icon === "string") {
            icon = ThemeIcon.fromString(item.icon) || joinPath(extension.description.extensionLocation, item.icon);
          }
          const initialVisibility = this.convertInitialVisibility(item.visibility);
          const type = this.getViewType(item.type);
          if (!type) {
            collector.error(localize("unknownViewType", "Unknown view type `{0}`.", item.type));
            continue;
          }
          let weight = void 0;
          if (typeof item.initialSize === "number") {
            if (((_a2 = container.extensionId) == null ? void 0 : _a2.value) === extension.description.identifier.value) {
              weight = item.initialSize;
            } else {
              this.logService.warn(`${extension.description.identifier.value} tried to set the view size of ${item.id} but it was ignored because the view container does not belong to it.`);
            }
          }
          const viewDescriptor2 = {
            type,
            ctorDescriptor: type === ViewType.Tree ? new SyncDescriptor(TreeViewPane) : new SyncDescriptor(WebviewViewPane),
            id: item.id,
            name: item.name,
            when: ContextKeyExpr.deserialize(item.when),
            containerIcon: icon || (viewContainer == null ? void 0 : viewContainer.icon),
            containerTitle: item.contextualTitle || (viewContainer == null ? void 0 : viewContainer.title),
            canToggleVisibility: true,
            canMoveView: (viewContainer == null ? void 0 : viewContainer.id) !== VIEWLET_ID,
            treeView: type === ViewType.Tree ? this.instantiationService.createInstance(CustomTreeView, item.id, item.name, extension.description.identifier.value) : void 0,
            collapsed: this.showCollapsed(container) || initialVisibility === InitialVisibility.Collapsed,
            order,
            extensionId: extension.description.identifier,
            originalContainerId: key,
            group: item.group,
            remoteAuthority: item.remoteName || item.remoteAuthority,
            virtualWorkspace: item.virtualWorkspace,
            hideByDefault: initialVisibility === InitialVisibility.Hidden,
            workspace: (viewContainer == null ? void 0 : viewContainer.id) === VIEWLET_ID ? true : void 0,
            weight
          };
          viewIds.add(viewDescriptor2.id);
          viewDescriptors.push(viewDescriptor2);
        }
        allViewDescriptors.push({ viewContainer: container, views: viewDescriptors });
      });
    }
    this.viewsRegistry.registerViews2(allViewDescriptors);
  }
  getViewType(type) {
    if (type === ViewType.Webview) {
      return ViewType.Webview;
    }
    if (!type || type === ViewType.Tree) {
      return ViewType.Tree;
    }
    return void 0;
  }
  getDefaultViewContainer() {
    return this.viewContainersRegistry.get(VIEWLET_ID$1);
  }
  removeViews(extensions) {
    const removedExtensions = extensions.reduce((result, e) => {
      result.add(e.description.identifier);
      return result;
    }, new ExtensionIdentifierSet());
    for (const viewContainer of this.viewContainersRegistry.all) {
      const removedViews = this.viewsRegistry.getViews(viewContainer).filter((v) => v.extensionId && removedExtensions.has(v.extensionId));
      if (removedViews.length) {
        this.viewsRegistry.deregisterViews(removedViews, viewContainer);
        for (const view of removedViews) {
          const anyView = view;
          if (anyView.treeView) {
            anyView.treeView.dispose();
          }
        }
      }
    }
  }
  convertInitialVisibility(value) {
    if (Object.values(InitialVisibility).includes(value)) {
      return value;
    }
    return void 0;
  }
  isValidViewDescriptors(viewDescriptors, collector) {
    if (!Array.isArray(viewDescriptors)) {
      collector.error(localize("requirearray", "views must be an array"));
      return false;
    }
    for (const descriptor of viewDescriptors) {
      if (typeof descriptor.id !== "string") {
        collector.error(localize(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "id"
        ));
        return false;
      }
      if (typeof descriptor.name !== "string") {
        collector.error(localize(
          "requirestring",
          "property `{0}` is mandatory and must be of type `string`",
          "name"
        ));
        return false;
      }
      if (descriptor.when && typeof descriptor.when !== "string") {
        collector.error(localize(
          "optstring",
          "property `{0}` can be omitted or must be of type `string`",
          "when"
        ));
        return false;
      }
      if (descriptor.icon && typeof descriptor.icon !== "string") {
        collector.error(localize(
          "optstring",
          "property `{0}` can be omitted or must be of type `string`",
          "icon"
        ));
        return false;
      }
      if (descriptor.contextualTitle && typeof descriptor.contextualTitle !== "string") {
        collector.error(localize(
          "optstring",
          "property `{0}` can be omitted or must be of type `string`",
          "contextualTitle"
        ));
        return false;
      }
      if (descriptor.visibility && !this.convertInitialVisibility(descriptor.visibility)) {
        collector.error(localize(
          "optenum",
          "property `{0}` can be omitted or must be one of {1}",
          "visibility",
          Object.values(InitialVisibility).join(", ")
        ));
        return false;
      }
    }
    return true;
  }
  getViewContainer(value) {
    switch (value) {
      case "explorer":
        return this.viewContainersRegistry.get(VIEWLET_ID$1);
      case "debug":
        return this.viewContainersRegistry.get(VIEWLET_ID$3);
      case "scm":
        return this.viewContainersRegistry.get(VIEWLET_ID$2);
      case "remote":
        return this.viewContainersRegistry.get(VIEWLET_ID);
      default:
        return this.viewContainersRegistry.get(`workbench.view.extension.${value}`);
    }
  }
  showCollapsed(container) {
    switch (container.id) {
      case VIEWLET_ID$1:
      case VIEWLET_ID$2:
      case VIEWLET_ID$3:
        return true;
    }
    return false;
  }
};
ViewsExtensionHandler = __decorate([
  __param(0, IInstantiationService),
  __param(1, ILogService)
], ViewsExtensionHandler);
const workbenchRegistry = Registry.as(Extensions$3.Workbench);
workbenchRegistry.registerWorkbenchContribution(ViewsExtensionHandler, 1);
let WebviewEditorInputSerializer = (_w = class {
  constructor(_webviewWorkbenchService) {
    this._webviewWorkbenchService = _webviewWorkbenchService;
  }
  canSerialize(input) {
    return this._webviewWorkbenchService.shouldPersist(input);
  }
  serialize(input) {
    if (!this._webviewWorkbenchService.shouldPersist(input)) {
      return void 0;
    }
    const data = this.toJson(input);
    try {
      return JSON.stringify(data);
    } catch {
      return void 0;
    }
  }
  deserialize(_instantiationService, serializedEditorInput) {
    const data = this.fromJson(JSON.parse(serializedEditorInput));
    return this._webviewWorkbenchService.openRevivedWebview({
      webviewInitInfo: {
        providedViewType: data.providedId,
        origin: data.origin,
        title: data.title,
        options: data.webviewOptions,
        contentOptions: data.contentOptions,
        extension: data.extension
      },
      viewType: data.viewType,
      title: data.title,
      iconPath: data.iconPath,
      state: data.state,
      group: data.group
    });
  }
  fromJson(data) {
    return {
      ...data,
      extension: reviveWebviewExtensionDescription(data.extensionId, data.extensionLocation),
      iconPath: reviveIconPath(data.iconPath),
      state: reviveState(data.state),
      webviewOptions: restoreWebviewOptions(data.options),
      contentOptions: restoreWebviewContentOptions(data.options)
    };
  }
  toJson(input) {
    var _a2, _b2;
    return {
      origin: input.webview.origin,
      viewType: input.viewType,
      providedId: input.providedId,
      title: input.getName(),
      options: { ...input.webview.options, ...input.webview.contentOptions },
      extensionLocation: (_a2 = input.extension) == null ? void 0 : _a2.location,
      extensionId: (_b2 = input.extension) == null ? void 0 : _b2.id.value,
      state: input.webview.state,
      iconPath: input.iconPath ? { light: input.iconPath.light, dark: input.iconPath.dark } : void 0,
      group: input.group
    };
  }
}, _w.ID = WebviewInput.typeId, _w);
WebviewEditorInputSerializer = __decorate([
  __param(0, IWebviewWorkbenchService)
], WebviewEditorInputSerializer);
function reviveWebviewExtensionDescription(extensionId, extensionLocation) {
  if (!extensionId) {
    return void 0;
  }
  const location = reviveUri(extensionLocation);
  if (!location) {
    return void 0;
  }
  return {
    id: new ExtensionIdentifier(extensionId),
    location
  };
}
function reviveIconPath(data) {
  if (!data) {
    return void 0;
  }
  const light = reviveUri(data.light);
  const dark = reviveUri(data.dark);
  return light && dark ? { light, dark } : void 0;
}
function reviveUri(data) {
  if (!data) {
    return void 0;
  }
  try {
    if (typeof data === "string") {
      return URI.parse(data);
    }
    return URI.from(data);
  } catch {
    return void 0;
  }
}
function reviveState(state) {
  return typeof state === "string" ? state : void 0;
}
function restoreWebviewOptions(options) {
  return options;
}
function restoreWebviewContentOptions(options) {
  var _a2;
  return {
    ...options,
    localResourceRoots: (_a2 = options.localResourceRoots) == null ? void 0 : _a2.map((uri) => reviveUri(uri))
  };
}
_x = class extends WebviewEditorInputSerializer {
  constructor(webviewWorkbenchService, _instantiationService, _webviewService) {
    super(webviewWorkbenchService);
    this._instantiationService = _instantiationService;
    this._webviewService = _webviewService;
  }
  serialize(input) {
    const dirty = input.isDirty();
    const data = {
      ...this.toJson(input),
      editorResource: input.resource.toJSON(),
      dirty,
      backupId: dirty ? input.backupId : void 0
    };
    try {
      return JSON.stringify(data);
    } catch {
      return void 0;
    }
  }
  fromJson(data) {
    return {
      ...super.fromJson(data),
      editorResource: URI.from(data.editorResource),
      dirty: data.dirty
    };
  }
  deserialize(_instantiationService, serializedEditorInput) {
    const data = this.fromJson(JSON.parse(serializedEditorInput));
    const webview = reviveWebview(this._webviewService, data);
    const customInput = this._instantiationService.createInstance(CustomEditorInput, { resource: data.editorResource, viewType: data.viewType }, webview, { startsDirty: data.dirty, backupId: data.backupId });
    if (typeof data.group === "number") {
      customInput.updateGroup(data.group);
    }
    return customInput;
  }
}, _x.ID = CustomEditorInput.typeId, _x;
function reviveWebview(webviewService, data) {
  const webview = webviewService.createWebviewOverlay({
    providedViewType: data.viewType,
    origin: data.origin,
    title: void 0,
    options: {
      purpose: "customEditor",
      enableFindWidget: data.webviewOptions.enableFindWidget,
      retainContextWhenHidden: data.webviewOptions.retainContextWhenHidden
    },
    contentOptions: data.contentOptions,
    extension: data.extension
  });
  webview.state = data.state;
  return webview;
}
let ComplexCustomWorkingCopyEditorHandler = class ComplexCustomWorkingCopyEditorHandler2 extends Disposable {
  constructor(_instantiationService, _workingCopyEditorService, _workingCopyBackupService, _webviewService, _customEditorService) {
    super();
    this._instantiationService = _instantiationService;
    this._workingCopyBackupService = _workingCopyBackupService;
    this._webviewService = _webviewService;
    this._register(_workingCopyEditorService.registerHandler(this));
  }
  handles(workingCopy) {
    return workingCopy.resource.scheme === Schemas.vscodeCustomEditor;
  }
  isOpen(workingCopy, editor) {
    if (!this.handles(workingCopy)) {
      return false;
    }
    if (workingCopy.resource.authority === "jupyter-notebook-ipynb" && editor instanceof NotebookEditorInput) {
      try {
        const data = JSON.parse(workingCopy.resource.query);
        const workingCopyResource = URI.from(data);
        return isEqual(workingCopyResource, editor.resource);
      } catch {
        return false;
      }
    }
    if (!(editor instanceof CustomEditorInput)) {
      return false;
    }
    if (workingCopy.resource.authority !== editor.viewType.replace(/[^a-z0-9\-_]/gi, "-").toLowerCase()) {
      return false;
    }
    try {
      const data = JSON.parse(workingCopy.resource.query);
      const workingCopyResource = URI.from(data);
      return isEqual(workingCopyResource, editor.resource);
    } catch {
      return false;
    }
  }
  async createEditor(workingCopy) {
    var _a2, _b2;
    const backup = await this._workingCopyBackupService.resolve(workingCopy);
    if (!(backup == null ? void 0 : backup.meta)) {
      throw new Error(`No backup found for custom editor: ${workingCopy.resource}`);
    }
    const backupData = backup.meta;
    const extension = reviveWebviewExtensionDescription((_a2 = backupData.extension) == null ? void 0 : _a2.id, (_b2 = backupData.extension) == null ? void 0 : _b2.location);
    const webview = reviveWebview(this._webviewService, {
      viewType: backupData.viewType,
      origin: backupData.webview.origin,
      webviewOptions: restoreWebviewOptions(backupData.webview.options),
      contentOptions: restoreWebviewContentOptions(backupData.webview.options),
      state: backupData.webview.state,
      extension
    });
    const editor = this._instantiationService.createInstance(CustomEditorInput, { resource: URI.revive(backupData.editorResource), viewType: backupData.viewType }, webview, { backupId: backupData.backupId });
    editor.updateGroup(0);
    return editor;
  }
};
ComplexCustomWorkingCopyEditorHandler = __decorate([
  __param(0, IInstantiationService),
  __param(1, IWorkingCopyEditorService),
  __param(2, IWorkingCopyBackupService),
  __param(3, IWebviewService),
  __param(4, ICustomEditorService)
], ComplexCustomWorkingCopyEditorHandler);
Registry.as(EditorExtensions.EditorPane).registerEditorPane(EditorPaneDescriptor.create(WebviewEditor, WebviewEditor.ID, "Webview Editor"), [
  new SyncDescriptor(CustomEditorInput)
]);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(ComplexCustomWorkingCopyEditorHandler, 1);
const webviewActiveContextKeyExpr = ContextKeyExpr.and(ContextKeyExpr.equals("activeEditor", WebviewEditor.ID), EditorContextKeys.focus.toNegated());
const _ShowWebViewEditorFindWidgetAction = class _ShowWebViewEditorFindWidgetAction extends Action2 {
  constructor() {
    super({
      id: _ShowWebViewEditorFindWidgetAction.ID,
      title: _ShowWebViewEditorFindWidgetAction.LABEL,
      keybinding: {
        when: ContextKeyExpr.and(
          webviewActiveContextKeyExpr,
          KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_ENABLED
        ),
        primary: 2048 | 36,
        weight: 100
      }
    });
  }
  run(accessor) {
    var _a2;
    (_a2 = getActiveWebviewEditor(accessor)) == null ? void 0 : _a2.showFind();
  }
};
_ShowWebViewEditorFindWidgetAction.ID = "editor.action.webvieweditor.showFind";
_ShowWebViewEditorFindWidgetAction.LABEL = localize("editor.action.webvieweditor.showFind", "Show find");
let ShowWebViewEditorFindWidgetAction = _ShowWebViewEditorFindWidgetAction;
const _HideWebViewEditorFindCommand = class _HideWebViewEditorFindCommand extends Action2 {
  constructor() {
    super({
      id: _HideWebViewEditorFindCommand.ID,
      title: _HideWebViewEditorFindCommand.LABEL,
      keybinding: {
        when: ContextKeyExpr.and(
          webviewActiveContextKeyExpr,
          KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_VISIBLE
        ),
        primary: 9,
        weight: 100
      }
    });
  }
  run(accessor) {
    var _a2;
    (_a2 = getActiveWebviewEditor(accessor)) == null ? void 0 : _a2.hideFind();
  }
};
_HideWebViewEditorFindCommand.ID = "editor.action.webvieweditor.hideFind";
_HideWebViewEditorFindCommand.LABEL = localize("editor.action.webvieweditor.hideFind", "Stop find");
let HideWebViewEditorFindCommand = _HideWebViewEditorFindCommand;
const _WebViewEditorFindNextCommand = class _WebViewEditorFindNextCommand extends Action2 {
  constructor() {
    super({
      id: _WebViewEditorFindNextCommand.ID,
      title: _WebViewEditorFindNextCommand.LABEL,
      keybinding: {
        when: ContextKeyExpr.and(
          webviewActiveContextKeyExpr,
          KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_FOCUSED
        ),
        primary: 3,
        weight: 100
      }
    });
  }
  run(accessor) {
    var _a2;
    (_a2 = getActiveWebviewEditor(accessor)) == null ? void 0 : _a2.runFindAction(false);
  }
};
_WebViewEditorFindNextCommand.ID = "editor.action.webvieweditor.findNext";
_WebViewEditorFindNextCommand.LABEL = localize("editor.action.webvieweditor.findNext", "Find next");
let WebViewEditorFindNextCommand = _WebViewEditorFindNextCommand;
const _WebViewEditorFindPreviousCommand = class _WebViewEditorFindPreviousCommand extends Action2 {
  constructor() {
    super({
      id: _WebViewEditorFindPreviousCommand.ID,
      title: _WebViewEditorFindPreviousCommand.LABEL,
      keybinding: {
        when: ContextKeyExpr.and(
          webviewActiveContextKeyExpr,
          KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_FOCUSED
        ),
        primary: 1024 | 3,
        weight: 100
      }
    });
  }
  run(accessor) {
    var _a2;
    (_a2 = getActiveWebviewEditor(accessor)) == null ? void 0 : _a2.runFindAction(true);
  }
};
_WebViewEditorFindPreviousCommand.ID = "editor.action.webvieweditor.findPrevious";
_WebViewEditorFindPreviousCommand.LABEL = localize("editor.action.webvieweditor.findPrevious", "Find previous");
let WebViewEditorFindPreviousCommand = _WebViewEditorFindPreviousCommand;
const _ReloadWebviewAction = class _ReloadWebviewAction extends Action2 {
  constructor() {
    super({
      id: _ReloadWebviewAction.ID,
      title: { value: _ReloadWebviewAction.LABEL, original: "Reload Webviews" },
      category: Categories.Developer,
      menu: [{
        id: MenuId.CommandPalette
      }]
    });
  }
  async run(accessor) {
    const webviewService = accessor.get(IWebviewService);
    for (const webview of webviewService.webviews) {
      webview.reload();
    }
  }
};
_ReloadWebviewAction.ID = "workbench.action.webview.reloadWebviewAction";
_ReloadWebviewAction.LABEL = localize("refreshWebviewLabel", "Reload Webviews");
let ReloadWebviewAction = _ReloadWebviewAction;
function getActiveWebviewEditor(accessor) {
  const editorService = accessor.get(IEditorService);
  const activeEditor = editorService.activeEditor;
  return activeEditor instanceof WebviewInput ? activeEditor.webview : void 0;
}
Registry.as(EditorExtensions.EditorPane).registerEditorPane(EditorPaneDescriptor.create(WebviewEditor, WebviewEditor.ID, localize("webview.editor.label", "webview editor")), [new SyncDescriptor(WebviewInput)]);
let WebviewPanelContribution = class WebviewPanelContribution2 extends Disposable {
  constructor(editorGroupService) {
    super();
    this.editorGroupService = editorGroupService;
    this.editorGroupService.whenReady.then(() => this.editorGroupService.groups.forEach((group) => {
      this.registerGroupListener(group);
    }));
    this._register(this.editorGroupService.onDidAddGroup((group) => this.registerGroupListener(group)));
  }
  registerGroupListener(group) {
    const listener = group.onWillOpenEditor((e) => this.onEditorOpening(e.editor, group));
    Event.once(group.onWillDispose)(() => {
      listener.dispose();
    });
  }
  onEditorOpening(editor, group) {
    if (!(editor instanceof WebviewInput) || editor.typeId !== WebviewInput.typeId) {
      return void 0;
    }
    if (group.contains(editor)) {
      return void 0;
    }
    let previousGroup;
    const groups = this.editorGroupService.groups;
    for (const group2 of groups) {
      if (group2.contains(editor)) {
        previousGroup = group2;
        break;
      }
    }
    if (!previousGroup) {
      return void 0;
    }
    previousGroup.closeEditor(editor);
  }
};
WebviewPanelContribution = __decorate([
  __param(0, IEditorGroupsService)
], WebviewPanelContribution);
const workbenchContributionsRegistry = Registry.as(Extensions$3.Workbench);
workbenchContributionsRegistry.registerWorkbenchContribution(WebviewPanelContribution, 1);
registerAction2(ShowWebViewEditorFindWidgetAction);
registerAction2(HideWebViewEditorFindCommand);
registerAction2(WebViewEditorFindNextCommand);
registerAction2(WebViewEditorFindPreviousCommand);
registerAction2(ReloadWebviewAction);
Registry.as(Extensions$4.Configuration).registerConfiguration(externalUriOpenersConfigurationNode);
var css$3 = '@keyframes wiggle{0%{transform:rotate(0) scale(1)}15%,45%{transform:rotate(.04turn) scale(1.1)}30%,60%{transform:rotate(-.04turn) scale(1.2)}to{transform:rotate(0) scale(1)}}.monaco-workbench .statusbar DIV#status\\.languageStatus A>SPAN.codicon.wiggle{animation-duration:.8s;animation-iteration-count:1;animation-name:wiggle}@keyframes flash{0%{background-color:initial}50%{background-color:var(--vscode-statusBarItem-prominentBackground)}to{background-color:initial}}.monaco-workbench .statusbar DIV#status\\.languageStatus.flash A{animation-duration:.8s;animation-iteration-count:1;animation-name:flash}.monaco-workbench .hover-language-status{display:flex;padding:4px 8px}.monaco-workbench .hover-language-status:not(:last-child){border-bottom:1px solid var(--vscode-notifications-border)}.monaco-workbench .hover-language-status>.severity{display:none;flex:1;margin:auto;padding-right:8px}.monaco-workbench .hover-language-status>.severity.sev3{color:var(--vscode-notificationsErrorIcon-foreground)}.monaco-workbench .hover-language-status>.severity.sev2{color:var(--vscode-notificationsInfoIcon-foreground)}.monaco-workbench .hover-language-status>.severity.show{display:inherit}.monaco-workbench .hover-language-status>.element{display:flex;flex-grow:100;justify-content:space-between;vertical-align:middle}.monaco-workbench .hover-language-status>.element>.left>.detail:not(:empty):before{content:"\\2013";opacity:.6;padding:0 4px}.monaco-workbench .hover-language-status>.element>.left>.label:empty{display:none}.monaco-workbench .hover-language-status>.element .left{margin:auto 0}.monaco-workbench .hover-language-status>.element .right{display:flex;margin:auto 0}.monaco-workbench .hover-language-status>.element .right:not(:empty){padding-left:16px}.monaco-workbench .hover-language-status>.element .right .monaco-link{margin:auto 0;white-space:nowrap}.monaco-workbench .hover-language-status>.element .right .monaco-action-bar:not(:first-child){padding-left:8px}';
n(css$3, {});
class LanguageStatusViewModel {
  constructor(combined, dedicated) {
    this.combined = combined;
    this.dedicated = dedicated;
  }
  isEqual(other) {
    return equals(this.combined, other.combined) && equals(this.dedicated, other.dedicated);
  }
}
let StoredCounter = class StoredCounter2 {
  constructor(_storageService, _key) {
    this._storageService = _storageService;
    this._key = _key;
  }
  get value() {
    return this._storageService.getNumber(this._key, 0, 0);
  }
  increment() {
    const n2 = this.value + 1;
    this._storageService.store(this._key, n2, 0, 1);
    return n2;
  }
};
StoredCounter = __decorate([
  __param(0, IStorageService)
], StoredCounter);
let EditorStatusContribution = (_y = class {
  constructor(_languageStatusService, _statusBarService, _editorService, _openerService, _storageService) {
    this._languageStatusService = _languageStatusService;
    this._statusBarService = _statusBarService;
    this._editorService = _editorService;
    this._openerService = _openerService;
    this._storageService = _storageService;
    this._disposables = new DisposableStore();
    this._dedicated = /* @__PURE__ */ new Set();
    this._dedicatedEntries = /* @__PURE__ */ new Map();
    this._renderDisposables = new DisposableStore();
    _storageService.onDidChangeValue(this._handleStorageChange, this, this._disposables);
    this._restoreState();
    this._interactionCounter = new StoredCounter(_storageService, "languageStatus.interactCount");
    _languageStatusService.onDidChange(this._update, this, this._disposables);
    _editorService.onDidActiveEditorChange(this._update, this, this._disposables);
    this._update();
    _statusBarService.onDidChangeEntryVisibility((e) => {
      if (!e.visible && this._dedicated.has(e.id)) {
        this._dedicated.delete(e.id);
        this._update();
        this._storeState();
      }
    }, this._disposables);
  }
  dispose() {
    var _a2;
    this._disposables.dispose();
    (_a2 = this._combinedEntry) == null ? void 0 : _a2.dispose();
    dispose(this._dedicatedEntries.values());
    this._renderDisposables.dispose();
  }
  _handleStorageChange(e) {
    if (e.key !== _y._keyDedicatedItems) {
      return;
    }
    this._restoreState();
    this._update();
  }
  _restoreState() {
    const raw = this._storageService.get(_y._keyDedicatedItems, 0, "[]");
    try {
      const ids = JSON.parse(raw);
      this._dedicated = new Set(ids);
    } catch {
      this._dedicated.clear();
    }
  }
  _storeState() {
    if (this._dedicated.size === 0) {
      this._storageService.remove(_y._keyDedicatedItems, 0);
    } else {
      const raw = JSON.stringify(Array.from(this._dedicated.keys()));
      this._storageService.store(_y._keyDedicatedItems, raw, 0, 0);
    }
  }
  _createViewModel(editor) {
    if (!(editor == null ? void 0 : editor.hasModel())) {
      return new LanguageStatusViewModel([], []);
    }
    const all = this._languageStatusService.getLanguageStatus(editor.getModel());
    const combined = [];
    const dedicated = [];
    for (const item of all) {
      if (this._dedicated.has(item.id)) {
        dedicated.push(item);
      }
      combined.push(item);
    }
    return new LanguageStatusViewModel(combined, dedicated);
  }
  _update() {
    var _a2, _b2;
    const editor = getCodeEditor(this._editorService.activeTextEditorControl);
    const model = this._createViewModel(editor);
    if ((_a2 = this._model) == null ? void 0 : _a2.isEqual(model)) {
      return;
    }
    this._renderDisposables.clear();
    this._model = model;
    editor == null ? void 0 : editor.onDidChangeModelLanguage(this._update, this, this._renderDisposables);
    if (model.combined.length === 0) {
      (_b2 = this._combinedEntry) == null ? void 0 : _b2.dispose();
      this._combinedEntry = void 0;
    } else {
      const [first] = model.combined;
      const showSeverity = first.severity >= Severity$1.Warning;
      const text = _y._severityToComboCodicon(first.severity);
      let isOneBusy = false;
      const ariaLabels = [];
      const element = document.createElement("div");
      for (const status2 of model.combined) {
        const isPinned = model.dedicated.includes(status2);
        element.appendChild(this._renderStatus(status2, showSeverity, isPinned, this._renderDisposables));
        ariaLabels.push(this._asAriaLabel(status2));
        isOneBusy = isOneBusy || !isPinned && status2.busy;
      }
      const props = {
        name: localize("langStatus.name", "Editor Language Status"),
        ariaLabel: localize(
          "langStatus.aria",
          "Editor Language Status: {0}",
          ariaLabels.join(", next: ")
        ),
        tooltip: element,
        command: ShowTooltipCommand,
        text: isOneBusy ? `${text}  $(sync~spin)` : text
      };
      if (!this._combinedEntry) {
        this._combinedEntry = this._statusBarService.addEntry(props, _y._id, 1, { id: "status.editor.mode", alignment: 0, compact: true });
      } else {
        this._combinedEntry.update(props);
      }
      const userHasInteractedWithStatus = this._interactionCounter.value >= 3;
      const node = document.querySelector(".monaco-workbench .statusbar DIV#status\\.languageStatus A>SPAN.codicon");
      const container = document.querySelector(".monaco-workbench .statusbar DIV#status\\.languageStatus");
      if (node instanceof HTMLElement && container) {
        const _wiggle = "wiggle";
        const _flash = "flash";
        if (!isOneBusy) {
          node.classList.toggle(_wiggle, showSeverity || !userHasInteractedWithStatus);
          this._renderDisposables.add(addDisposableListener(node, "animationend", (_e2) => node.classList.remove(_wiggle)));
          container.classList.toggle(_flash, showSeverity);
          this._renderDisposables.add(addDisposableListener(container, "animationend", (_e2) => container.classList.remove(_flash)));
        } else {
          node.classList.remove(_wiggle);
          container.classList.remove(_flash);
        }
      }
      if (!userHasInteractedWithStatus) {
        const hoverTarget = document.querySelector(".monaco-workbench .context-view");
        if (hoverTarget instanceof HTMLElement) {
          const observer = new MutationObserver(() => {
            if (document.contains(element)) {
              this._interactionCounter.increment();
              observer.disconnect();
            }
          });
          observer.observe(hoverTarget, { childList: true, subtree: true });
          this._renderDisposables.add(toDisposable(() => observer.disconnect()));
        }
      }
    }
    const newDedicatedEntries = /* @__PURE__ */ new Map();
    for (const status2 of model.dedicated) {
      const props = _y._asStatusbarEntry(status2);
      let entry = this._dedicatedEntries.get(status2.id);
      if (!entry) {
        entry = this._statusBarService.addEntry(props, status2.id, 1, { id: "status.editor.mode", alignment: 1 });
      } else {
        entry.update(props);
        this._dedicatedEntries.delete(status2.id);
      }
      newDedicatedEntries.set(status2.id, entry);
    }
    dispose(this._dedicatedEntries.values());
    this._dedicatedEntries = newDedicatedEntries;
  }
  _renderStatus(status2, showSeverity, isPinned, store) {
    const parent = document.createElement("div");
    parent.classList.add("hover-language-status");
    const severity = document.createElement("div");
    severity.classList.add("severity", `sev${status2.severity}`);
    severity.classList.toggle("show", showSeverity);
    const severityText = _y._severityToSingleCodicon(status2.severity);
    append(severity, ...renderLabelWithIcons(severityText));
    parent.appendChild(severity);
    const element = document.createElement("div");
    element.classList.add("element");
    parent.appendChild(element);
    const left = document.createElement("div");
    left.classList.add("left");
    element.appendChild(left);
    const label = document.createElement("span");
    label.classList.add("label");
    append(label, ...renderLabelWithIcons(status2.busy ? `$(sync~spin)  ${status2.label}` : status2.label));
    left.appendChild(label);
    const detail = document.createElement("span");
    detail.classList.add("detail");
    this._renderTextPlus(detail, status2.detail, store);
    left.appendChild(detail);
    const right = document.createElement("div");
    right.classList.add("right");
    element.appendChild(right);
    const { command } = status2;
    if (command) {
      store.add(new Link(right, {
        label: command.title,
        title: command.tooltip,
        href: URI.from({
          scheme: "command",
          path: command.id,
          query: command.arguments && JSON.stringify(command.arguments)
        }).toString()
      }, void 0, this._openerService));
    }
    const actionBar = new ActionBar(right, {});
    store.add(actionBar);
    let action;
    if (!isPinned) {
      action = new Action("pin", localize("pin", "Add to Status Bar"), ThemeIcon.asClassName(Codicon.pin), true, () => {
        this._dedicated.add(status2.id);
        this._statusBarService.updateEntryVisibility(status2.id, true);
        this._update();
        this._storeState();
      });
    } else {
      action = new Action("unpin", localize("unpin", "Remove from Status Bar"), ThemeIcon.asClassName(Codicon.pinned), true, () => {
        this._dedicated.delete(status2.id);
        this._statusBarService.updateEntryVisibility(status2.id, false);
        this._update();
        this._storeState();
      });
    }
    actionBar.push(action, { icon: true, label: false });
    store.add(action);
    return parent;
  }
  static _severityToComboCodicon(sev) {
    switch (sev) {
      case Severity$1.Error:
        return "$(bracket-error)";
      case Severity$1.Warning:
        return "$(bracket-dot)";
      default:
        return "$(bracket)";
    }
  }
  static _severityToSingleCodicon(sev) {
    switch (sev) {
      case Severity$1.Error:
        return "$(error)";
      case Severity$1.Warning:
        return "$(info)";
      default:
        return "$(check)";
    }
  }
  _renderTextPlus(target, text, store) {
    for (const node of parseLinkedText(text).nodes) {
      if (typeof node === "string") {
        const parts = renderLabelWithIcons(node);
        append(target, ...parts);
      } else {
        store.add(new Link(target, node, void 0, this._openerService));
      }
    }
  }
  _asAriaLabel(status2) {
    if (status2.accessibilityInfo) {
      return status2.accessibilityInfo.label;
    } else if (status2.detail) {
      return localize("aria.1", "{0}, {1}", status2.label, status2.detail);
    } else {
      return localize("aria.2", "{0}", status2.label);
    }
  }
  static _asStatusbarEntry(item) {
    var _a2, _b2, _c2;
    let color;
    let backgroundColor;
    if (item.severity === Severity$1.Warning) {
      color = themeColorFromId(STATUS_BAR_WARNING_ITEM_FOREGROUND);
      backgroundColor = themeColorFromId(STATUS_BAR_WARNING_ITEM_BACKGROUND);
    } else if (item.severity === Severity$1.Error) {
      color = themeColorFromId(STATUS_BAR_ERROR_ITEM_FOREGROUND);
      backgroundColor = themeColorFromId(STATUS_BAR_ERROR_ITEM_BACKGROUND);
    }
    return {
      name: localize("name.pattern", "{0} (Language Status)", item.name),
      text: item.busy ? `${item.label}  $(sync~spin)` : item.label,
      ariaLabel: ((_a2 = item.accessibilityInfo) == null ? void 0 : _a2.label) ?? item.label,
      role: (_b2 = item.accessibilityInfo) == null ? void 0 : _b2.role,
      tooltip: ((_c2 = item.command) == null ? void 0 : _c2.tooltip) || new MarkdownString(item.detail, { isTrusted: true, supportThemeIcons: true }),
      color,
      backgroundColor,
      command: item.command
    };
  }
}, _y._id = "status.languageStatus", _y._keyDedicatedItems = "languageStatus.dedicated", _y);
EditorStatusContribution = __decorate([
  __param(0, ILanguageStatusService),
  __param(1, IStatusbarService),
  __param(2, IEditorService),
  __param(3, IOpenerService),
  __param(4, IStorageService)
], EditorStatusContribution);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(EditorStatusContribution, 3);
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "editor.inlayHints.Reset",
      title: {
        value: localize("reset", "Reset Language Status Interaction Counter"),
        original: "Reset Language Status Interaction Counter"
      },
      category: Categories.View,
      f1: true
    });
  }
  run(accessor) {
    accessor.get(IStorageService).remove("languageStatus.interactCount", 0);
  }
});
const NOTEBOOK_EDITOR_EDITABLE = new RawContextKey("notebookEditable", true);
const detectLanguageCommandId = "editor.detectLanguage";
let LanguageDetectionStatusContribution = (_z = class {
  constructor(_languageDetectionService, _statusBarService, _configurationService, _editorService, _languageService, _keybindingService) {
    this._languageDetectionService = _languageDetectionService;
    this._statusBarService = _statusBarService;
    this._configurationService = _configurationService;
    this._editorService = _editorService;
    this._languageService = _languageService;
    this._keybindingService = _keybindingService;
    this._disposables = new DisposableStore();
    this._delayer = new ThrottledDelayer(1e3);
    this._renderDisposables = new DisposableStore();
    _editorService.onDidActiveEditorChange(() => this._update(true), this, this._disposables);
    this._update(false);
  }
  dispose() {
    var _a2;
    this._disposables.dispose();
    this._delayer.dispose();
    (_a2 = this._combinedEntry) == null ? void 0 : _a2.dispose();
    this._renderDisposables.dispose();
  }
  _update(clear) {
    var _a2;
    if (clear) {
      (_a2 = this._combinedEntry) == null ? void 0 : _a2.dispose();
      this._combinedEntry = void 0;
    }
    this._delayer.trigger(() => this._doUpdate());
  }
  async _doUpdate() {
    var _a2, _b2;
    const editor = getCodeEditor(this._editorService.activeTextEditorControl);
    this._renderDisposables.clear();
    editor == null ? void 0 : editor.onDidChangeModelLanguage(() => this._update(true), this, this._renderDisposables);
    editor == null ? void 0 : editor.onDidChangeModelContent(() => this._update(false), this, this._renderDisposables);
    const editorModel = editor == null ? void 0 : editor.getModel();
    const editorUri = editorModel == null ? void 0 : editorModel.uri;
    const existingId = editorModel == null ? void 0 : editorModel.getLanguageId();
    const enablementConfig = this._configurationService.getValue("workbench.editor.languageDetectionHints");
    const enabled = typeof enablementConfig === "object" && (enablementConfig == null ? void 0 : enablementConfig.untitledEditors);
    const disableLightbulb = !enabled || (editorUri == null ? void 0 : editorUri.scheme) !== Schemas.untitled || !existingId;
    if (disableLightbulb || !editorUri) {
      (_a2 = this._combinedEntry) == null ? void 0 : _a2.dispose();
      this._combinedEntry = void 0;
    } else {
      const lang = await this._languageDetectionService.detectLanguage(editorUri);
      const skip = { "jsonc": "json" };
      const existing = editorModel.getLanguageId();
      if (lang && lang !== existing && skip[existing] !== lang) {
        const detectedName = this._languageService.getLanguageName(lang) || lang;
        let tooltip = localize("status.autoDetectLanguage", "Accept Detected Language: {0}", detectedName);
        const keybinding = this._keybindingService.lookupKeybinding(detectLanguageCommandId);
        const label = keybinding == null ? void 0 : keybinding.getLabel();
        if (label) {
          tooltip += ` (${label})`;
        }
        const props = {
          name: localize("langDetection.name", "Language Detection"),
          ariaLabel: localize("langDetection.aria", "Change to Detected Language: {0}", lang),
          tooltip,
          command: detectLanguageCommandId,
          text: "$(lightbulb-autofix)"
        };
        if (!this._combinedEntry) {
          this._combinedEntry = this._statusBarService.addEntry(props, _z._id, 1, { id: "status.editor.mode", alignment: 1, compact: true });
        } else {
          this._combinedEntry.update(props);
        }
      } else {
        (_b2 = this._combinedEntry) == null ? void 0 : _b2.dispose();
        this._combinedEntry = void 0;
      }
    }
  }
}, _z._id = "status.languageDetectionStatus", _z);
LanguageDetectionStatusContribution = __decorate([
  __param(0, ILanguageDetectionService),
  __param(1, IStatusbarService),
  __param(2, IConfigurationService),
  __param(3, IEditorService),
  __param(4, ILanguageService),
  __param(5, IKeybindingService)
], LanguageDetectionStatusContribution);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(LanguageDetectionStatusContribution, 3);
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: detectLanguageCommandId,
      title: { value: localize("detectlang", "Detect Language from Content"), original: "Detect Language from Content" },
      f1: true,
      precondition: ContextKeyExpr.and(NOTEBOOK_EDITOR_EDITABLE.toNegated(), EditorContextKeys.editorTextFocus),
      keybinding: { primary: 34 | 512 | 1024, weight: 200 }
    });
  }
  async run(accessor) {
    var _a2, _b2;
    const editorService = accessor.get(IEditorService);
    const languageDetectionService = accessor.get(ILanguageDetectionService);
    const editor = getCodeEditor(editorService.activeTextEditorControl);
    const notificationService = accessor.get(INotificationService);
    const editorUri = (_a2 = editor == null ? void 0 : editor.getModel()) == null ? void 0 : _a2.uri;
    if (editorUri) {
      const lang = await languageDetectionService.detectLanguage(editorUri);
      if (lang) {
        (_b2 = editor.getModel()) == null ? void 0 : _b2.setLanguage(lang, LanguageDetectionLanguageEventSource);
      } else {
        notificationService.warn(localize("noDetection", "Unable to detect editor language"));
      }
    }
  }
});
let TextFileEditorTracker = class TextFileEditorTracker2 extends Disposable {
  constructor(editorService, textFileService, lifecycleService, hostService, codeEditorService, filesConfigurationService, workingCopyEditorService) {
    super();
    this.editorService = editorService;
    this.textFileService = textFileService;
    this.lifecycleService = lifecycleService;
    this.hostService = hostService;
    this.codeEditorService = codeEditorService;
    this.filesConfigurationService = filesConfigurationService;
    this.workingCopyEditorService = workingCopyEditorService;
    this.ensureDirtyFilesAreOpenedWorker = this._register(new RunOnceWorker(
      (units) => this.ensureDirtyTextFilesAreOpened(units),
      this.getDirtyTextFileTrackerDelay()
    ));
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.textFileService.files.onDidChangeDirty((model) => this.ensureDirtyFilesAreOpenedWorker.work(model.resource)));
    this._register(this.textFileService.files.onDidSaveError((model) => this.ensureDirtyFilesAreOpenedWorker.work(model.resource)));
    this._register(this.textFileService.untitled.onDidChangeDirty((model) => this.ensureDirtyFilesAreOpenedWorker.work(model.resource)));
    this._register(this.hostService.onDidChangeFocus((hasFocus) => hasFocus ? this.reloadVisibleTextFileEditors() : void 0));
    this.lifecycleService.onDidShutdown(() => this.dispose());
  }
  getDirtyTextFileTrackerDelay() {
    return 800;
  }
  ensureDirtyTextFilesAreOpened(resources) {
    this.doEnsureDirtyTextFilesAreOpened(distinct(resources.filter((resource) => {
      if (!this.textFileService.isDirty(resource)) {
        return false;
      }
      const fileModel = this.textFileService.files.get(resource);
      if (fileModel == null ? void 0 : fileModel.hasState(2)) {
        return false;
      }
      if (resource.scheme !== Schemas.untitled && this.filesConfigurationService.getAutoSaveMode() === 1 && !(fileModel == null ? void 0 : fileModel.hasState(5))) {
        return false;
      }
      if (this.editorService.isOpened({ resource, typeId: resource.scheme === Schemas.untitled ? UntitledTextEditorInput.ID : FILE_EDITOR_INPUT_ID, editorId: DEFAULT_EDITOR_ASSOCIATION.id })) {
        return false;
      }
      const model = fileModel ?? this.textFileService.untitled.get(resource);
      if (model && this.workingCopyEditorService.findEditor(model)) {
        return false;
      }
      return true;
    }), (resource) => resource.toString()));
  }
  doEnsureDirtyTextFilesAreOpened(resources) {
    if (!resources.length) {
      return;
    }
    this.editorService.openEditors(resources.map((resource) => ({
      resource,
      options: { inactive: true, pinned: true, preserveFocus: true }
    })));
  }
  reloadVisibleTextFileEditors() {
    distinct(coalesce(this.codeEditorService.listCodeEditors().map((codeEditor) => {
      var _a2;
      const resource = (_a2 = codeEditor.getModel()) == null ? void 0 : _a2.uri;
      if (!resource) {
        return void 0;
      }
      const model = this.textFileService.files.get(resource);
      if (!model || model.isDirty() || !model.isResolved()) {
        return void 0;
      }
      return model;
    })), (model) => model.resource.toString()).forEach((model) => this.textFileService.files.resolve(model.resource, { reload: { async: true } }));
  }
};
TextFileEditorTracker = __decorate([
  __param(0, IEditorService),
  __param(1, ITextFileService),
  __param(2, ILifecycleService),
  __param(3, IHostService),
  __param(4, ICodeEditorService),
  __param(5, IFilesConfigurationService),
  __param(6, IWorkingCopyEditorService)
], TextFileEditorTracker);
let BinaryFileEditor = (_A = class extends BaseBinaryResourceEditor {
  constructor(telemetryService, themeService, editorResolverService, storageService, editorGroupService) {
    super(_A.ID, {
      openInternal: (input, options) => this.openInternal(input, options)
    }, telemetryService, themeService, storageService);
    this.editorResolverService = editorResolverService;
    this.editorGroupService = editorGroupService;
  }
  async openInternal(input, options) {
    var _a2;
    if (input instanceof FileEditorInput && ((_a2 = this.group) == null ? void 0 : _a2.activeEditor)) {
      const activeEditor = this.group.activeEditor;
      const untypedActiveEditor = activeEditor == null ? void 0 : activeEditor.toUntyped();
      if (!untypedActiveEditor) {
        return;
      }
      let resolvedEditor = await this.editorResolverService.resolveEditor({
        ...untypedActiveEditor,
        options: {
          ...options,
          override: EditorResolution.PICK
        }
      }, this.group);
      if (resolvedEditor === 2) {
        resolvedEditor = void 0;
      } else if (resolvedEditor === 1) {
        return;
      }
      if (isEditorInputWithOptions(resolvedEditor)) {
        for (const editor of resolvedEditor.editor instanceof DiffEditorInput ? [resolvedEditor.editor.original, resolvedEditor.editor.modified] : [resolvedEditor.editor]) {
          if (editor instanceof FileEditorInput) {
            editor.setForceOpenAsText();
            editor.setPreferredLanguageId(BINARY_TEXT_FILE_MODE);
          }
        }
      }
      await (this.group ?? this.editorGroupService.activeGroup).replaceEditors([{
        editor: activeEditor,
        replacement: (resolvedEditor == null ? void 0 : resolvedEditor.editor) ?? input,
        options: {
          ...(resolvedEditor == null ? void 0 : resolvedEditor.options) ?? options
        }
      }]);
    }
  }
  getTitle() {
    return this.input ? this.input.getName() : localize("binaryFileEditor", "Binary File Viewer");
  }
}, _A.ID = BINARY_FILE_EDITOR_ID, _A);
BinaryFileEditor = __decorate([
  __param(0, ITelemetryService),
  __param(1, IThemeService),
  __param(2, IEditorResolverService),
  __param(3, IStorageService),
  __param(4, IEditorGroupsService)
], BinaryFileEditor);
let WorkspaceWatcher = class WorkspaceWatcher2 extends Disposable {
  constructor(fileService, configurationService, contextService, notificationService, openerService, uriIdentityService, hostService) {
    super();
    this.fileService = fileService;
    this.configurationService = configurationService;
    this.contextService = contextService;
    this.notificationService = notificationService;
    this.openerService = openerService;
    this.uriIdentityService = uriIdentityService;
    this.hostService = hostService;
    this.watchedWorkspaces = new ResourceMap((resource) => this.uriIdentityService.extUri.getComparisonKey(resource));
    this.registerListeners();
    this.refresh();
  }
  registerListeners() {
    this._register(this.contextService.onDidChangeWorkspaceFolders((e) => this.onDidChangeWorkspaceFolders(e)));
    this._register(this.contextService.onDidChangeWorkbenchState(() => this.onDidChangeWorkbenchState()));
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.onDidChangeConfiguration(e)));
    this._register(this.fileService.onDidWatchError((error) => this.onDidWatchError(error)));
  }
  onDidChangeWorkspaceFolders(e) {
    for (const removed of e.removed) {
      this.unwatchWorkspace(removed);
    }
    for (const added of e.added) {
      this.watchWorkspace(added);
    }
  }
  onDidChangeWorkbenchState() {
    this.refresh();
  }
  onDidChangeConfiguration(e) {
    if (e.affectsConfiguration("files.watcherExclude") || e.affectsConfiguration("files.watcherInclude")) {
      this.refresh();
    }
  }
  onDidWatchError(error) {
    const msg = error.toString();
    if (msg.indexOf("ENOSPC") >= 0) {
      this.notificationService.prompt(Severity.Warning, localize(
        "enospcError",
        "Unable to watch for file changes in this large workspace folder. Please follow the instructions link to resolve this issue."
      ), [{
        label: localize("learnMore", "Instructions"),
        run: () => this.openerService.open(URI.parse("https://go.microsoft.com/fwlink/?linkid=867693"))
      }], {
        sticky: true,
        neverShowAgain: { id: "ignoreEnospcError", isSecondary: true, scope: NeverShowAgainScope.WORKSPACE }
      });
    } else if (msg.indexOf("EUNKNOWN") >= 0) {
      this.notificationService.prompt(Severity.Warning, localize(
        "eshutdownError",
        "File changes watcher stopped unexpectedly. A reload of the window may enable the watcher again unless the workspace cannot be watched for file changes."
      ), [{
        label: localize("reload", "Reload"),
        run: () => this.hostService.reload()
      }], {
        sticky: true,
        priority: NotificationPriority.SILENT
      });
    }
  }
  watchWorkspace(workspace) {
    var _a2, _b2;
    const excludes = [];
    const config = this.configurationService.getValue({ resource: workspace.uri });
    if ((_a2 = config.files) == null ? void 0 : _a2.watcherExclude) {
      for (const key in config.files.watcherExclude) {
        if (config.files.watcherExclude[key] === true) {
          excludes.push(key);
        }
      }
    }
    const pathsToWatch = new ResourceMap((uri) => this.uriIdentityService.extUri.getComparisonKey(uri));
    pathsToWatch.set(workspace.uri, workspace.uri);
    if ((_b2 = config.files) == null ? void 0 : _b2.watcherInclude) {
      for (const includePath of config.files.watcherInclude) {
        if (!includePath) {
          continue;
        }
        if (isAbsolute(includePath)) {
          const candidate = URI.file(includePath).with({ scheme: workspace.uri.scheme });
          if (this.uriIdentityService.extUri.isEqualOrParent(candidate, workspace.uri)) {
            pathsToWatch.set(candidate, candidate);
          }
        } else {
          const candidate = workspace.toResource(includePath);
          pathsToWatch.set(candidate, candidate);
        }
      }
    }
    const disposables = new DisposableStore();
    for (const [, pathToWatch] of pathsToWatch) {
      disposables.add(this.fileService.watch(pathToWatch, { recursive: true, excludes }));
    }
    this.watchedWorkspaces.set(workspace.uri, disposables);
  }
  unwatchWorkspace(workspace) {
    if (this.watchedWorkspaces.has(workspace.uri)) {
      dispose(this.watchedWorkspaces.get(workspace.uri));
      this.watchedWorkspaces.delete(workspace.uri);
    }
  }
  refresh() {
    this.unwatchWorkspaces();
    for (const folder of this.contextService.getWorkspace().folders) {
      this.watchWorkspace(folder);
    }
  }
  unwatchWorkspaces() {
    for (const [, disposable] of this.watchedWorkspaces) {
      disposable.dispose();
    }
    this.watchedWorkspaces.clear();
  }
  dispose() {
    super.dispose();
    this.unwatchWorkspaces();
  }
};
WorkspaceWatcher = __decorate([
  __param(0, IWorkbenchFileService),
  __param(1, IConfigurationService),
  __param(2, IWorkspaceContextService),
  __param(3, INotificationService),
  __param(4, IOpenerService),
  __param(5, IUriIdentityService),
  __param(6, IHostService)
], WorkspaceWatcher);
let DirtyFilesIndicator = class DirtyFilesIndicator2 extends Disposable {
  constructor(lifecycleService, activityService, workingCopyService, filesConfigurationService) {
    super();
    this.lifecycleService = lifecycleService;
    this.activityService = activityService;
    this.workingCopyService = workingCopyService;
    this.filesConfigurationService = filesConfigurationService;
    this.badgeHandle = this._register(new MutableDisposable());
    this.lastKnownDirtyCount = 0;
    this.updateActivityBadge();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.workingCopyService.onDidChangeDirty((workingCopy) => this.onWorkingCopyDidChangeDirty(workingCopy)));
    this.lifecycleService.onDidShutdown(() => this.dispose());
  }
  onWorkingCopyDidChangeDirty(workingCopy) {
    const gotDirty = workingCopy.isDirty();
    if (gotDirty && !(workingCopy.capabilities & 2) && this.filesConfigurationService.getAutoSaveMode() === 1) {
      return;
    }
    if (gotDirty || this.lastKnownDirtyCount > 0) {
      this.updateActivityBadge();
    }
  }
  updateActivityBadge() {
    const dirtyCount = this.lastKnownDirtyCount = this.workingCopyService.dirtyCount;
    if (dirtyCount > 0) {
      this.badgeHandle.value = this.activityService.showViewContainerActivity(VIEWLET_ID$1, {
        badge: new NumberBadge(dirtyCount, (num) => num === 1 ? localize("dirtyFile", "1 unsaved file") : localize("dirtyFiles", "{0} unsaved files", dirtyCount)),
        clazz: "explorer-viewlet-label"
      });
    } else {
      this.badgeHandle.clear();
    }
  }
};
DirtyFilesIndicator = __decorate([
  __param(0, ILifecycleService),
  __param(1, IActivityService),
  __param(2, IWorkingCopyService),
  __param(3, IFilesConfigurationService)
], DirtyFilesIndicator);
let FileEditorWorkingCopyEditorHandler = class FileEditorWorkingCopyEditorHandler2 extends Disposable {
  constructor(workingCopyEditorService, textEditorService, fileService) {
    super();
    this.textEditorService = textEditorService;
    this.fileService = fileService;
    this._register(workingCopyEditorService.registerHandler(this));
  }
  handles(workingCopy) {
    return workingCopy.typeId === NO_TYPE_ID && this.fileService.canHandleResource(workingCopy.resource);
  }
  handlesSync(workingCopy) {
    return workingCopy.typeId === NO_TYPE_ID && this.fileService.hasProvider(workingCopy.resource);
  }
  isOpen(workingCopy, editor) {
    if (!this.handlesSync(workingCopy)) {
      return false;
    }
    return isEqual(workingCopy.resource, editor.resource);
  }
  createEditor(workingCopy) {
    return this.textEditorService.createTextEditor({ resource: workingCopy.resource, forceFile: true });
  }
};
FileEditorWorkingCopyEditorHandler = __decorate([
  __param(0, IWorkingCopyEditorService),
  __param(1, ITextEditorService),
  __param(2, IFileService)
], FileEditorWorkingCopyEditorHandler);
let TextFileEditor = (_B = class extends AbstractTextCodeEditor {
  constructor(telemetryService, fileService, paneCompositeService, instantiationService, contextService, storageService, textResourceConfigurationService, editorService, themeService, editorGroupService, textFileService, explorerService, uriIdentityService, pathService, configurationService, preferencesService, hostService) {
    super(_B.ID, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorService, editorGroupService, fileService);
    this.paneCompositeService = paneCompositeService;
    this.contextService = contextService;
    this.textFileService = textFileService;
    this.explorerService = explorerService;
    this.uriIdentityService = uriIdentityService;
    this.pathService = pathService;
    this.configurationService = configurationService;
    this.preferencesService = preferencesService;
    this.hostService = hostService;
    this._register(this.fileService.onDidFilesChange((e) => this.onDidFilesChange(e)));
    this._register(this.fileService.onDidRunOperation((e) => this.onDidRunOperation(e)));
  }
  onDidFilesChange(e) {
    for (const resource of e.rawDeleted) {
      this.clearEditorViewState(resource);
    }
  }
  onDidRunOperation(e) {
    if (e.operation === 2 && e.target) {
      this.moveEditorViewState(e.resource, e.target.resource, this.uriIdentityService.extUri);
    }
  }
  getTitle() {
    if (this.input) {
      return this.input.getName();
    }
    return localize("textFileEditor", "Text File Editor");
  }
  get input() {
    return this._input;
  }
  async setInput(input, options, context, token) {
    mark("code/willSetInputToTextFileEditor");
    await super.setInput(input, options, context, token);
    try {
      const resolvedModel = await input.resolve(options);
      if (token.isCancellationRequested) {
        return;
      }
      if (resolvedModel instanceof BinaryEditorModel) {
        return this.openAsBinary(input, options);
      }
      const textFileModel = resolvedModel;
      const control = assertIsDefined(this.editorControl);
      control.setModel(textFileModel.textEditorModel);
      if (!isTextEditorViewState(options == null ? void 0 : options.viewState)) {
        const editorViewState = this.loadEditorViewState(input, context);
        if (editorViewState) {
          if (options == null ? void 0 : options.selection) {
            editorViewState.cursorState = [];
          }
          control.restoreViewState(editorViewState);
        }
      }
      if (options) {
        applyTextEditorOptions(options, control, 1);
      }
      control.updateOptions(this.getReadonlyConfiguration(textFileModel.isReadonly()));
      if (control.handleInitialized) {
        control.handleInitialized();
      }
    } catch (error) {
      await this.handleSetInputError(error, input, options);
    }
    mark("code/didSetInputToTextFileEditor");
  }
  async handleSetInputError(error, input, options) {
    if (error.textFileOperationResult === 0) {
      return this.openAsBinary(input, options);
    }
    if (error.fileOperationResult === 0) {
      const actions = [];
      actions.push(toAction({
        id: "workbench.files.action.openFolder",
        label: localize("openFolder", "Open Folder"),
        run: async () => {
          return this.hostService.openWindow([{ folderUri: input.resource }], { forceNewWindow: true });
        }
      }));
      if (this.contextService.isInsideWorkspace(input.preferredResource)) {
        actions.push(toAction({
          id: "workbench.files.action.reveal",
          label: localize("reveal", "Reveal Folder"),
          run: async () => {
            await this.paneCompositeService.openPaneComposite(VIEWLET_ID$1, 0, true);
            return this.explorerService.select(input.preferredResource, true);
          }
        }));
      }
      throw createEditorOpenError(localize("fileIsDirectory", "The file is not displayed in the text editor because it is a directory."), actions, { forceMessage: true });
    }
    if (error.fileOperationResult === 7 && this.group) {
      let message;
      if (error instanceof TooLargeFileOperationError) {
        message = localize(
          "fileTooLargeForHeapErrorWithSize",
          "The file is not displayed in the text editor because it is very large ({0}).",
          ByteSize.formatSize(error.size)
        );
      } else {
        message = localize(
          "fileTooLargeForHeapErrorWithoutSize",
          "The file is not displayed in the text editor because it is very large."
        );
      }
      throw createTooLargeFileError(this.group, input, options, message, this.preferencesService);
    }
    if (error.fileOperationResult === 1 && await this.pathService.hasValidBasename(input.preferredResource)) {
      const fileNotFoundError = createEditorOpenError(new FileOperationError(localize(
        "unavailableResourceErrorEditorText",
        "The editor could not be opened because the file was not found."
      ), 1), [
        toAction({
          id: "workbench.files.action.createMissingFile",
          label: localize("createFile", "Create File"),
          run: async () => {
            await this.textFileService.create([{ resource: input.preferredResource }]);
            return this.editorService.openEditor({
              resource: input.preferredResource,
              options: {
                pinned: true
              }
            });
          }
        })
      ], {
        allowDialog: true
      });
      throw fileNotFoundError;
    }
    throw error;
  }
  openAsBinary(input, options) {
    const defaultBinaryEditor = this.configurationService.getValue("workbench.editor.defaultBinaryEditor");
    const group = this.group ?? this.editorGroupService.activeGroup;
    const editorOptions = {
      ...options,
      activation: EditorActivation.PRESERVE
    };
    if (defaultBinaryEditor && defaultBinaryEditor !== "" && defaultBinaryEditor !== DEFAULT_EDITOR_ASSOCIATION.id) {
      this.doOpenAsBinaryInDifferentEditor(group, defaultBinaryEditor, input, editorOptions);
    } else {
      this.doOpenAsBinaryInSameEditor(group, defaultBinaryEditor, input, editorOptions);
    }
  }
  doOpenAsBinaryInDifferentEditor(group, editorId, editor, editorOptions) {
    this.editorService.replaceEditors([{
      editor,
      replacement: { resource: editor.resource, options: { ...editorOptions, override: editorId } }
    }], group);
  }
  doOpenAsBinaryInSameEditor(group, editorId, editor, editorOptions) {
    if (editorId === DEFAULT_EDITOR_ASSOCIATION.id) {
      editor.setForceOpenAsText();
      editor.setPreferredLanguageId(BINARY_TEXT_FILE_MODE);
      editorOptions = { ...editorOptions, forceReload: true };
    } else {
      editor.setForceOpenAsBinary();
    }
    group.openEditor(editor, editorOptions);
  }
  clearInput() {
    var _a2;
    super.clearInput();
    (_a2 = this.editorControl) == null ? void 0 : _a2.setModel(null);
  }
  createEditorControl(parent, initialOptions) {
    mark("code/willCreateTextFileEditorControl");
    super.createEditorControl(parent, initialOptions);
    mark("code/didCreateTextFileEditorControl");
  }
  tracksEditorViewState(input) {
    return input instanceof FileEditorInput;
  }
  tracksDisposedEditorViewState() {
    return true;
  }
}, _B.ID = TEXT_FILE_EDITOR_ID, _B);
TextFileEditor = __decorate([
  __param(0, ITelemetryService),
  __param(1, IFileService),
  __param(2, IPaneCompositePartService),
  __param(3, IInstantiationService),
  __param(4, IWorkspaceContextService),
  __param(5, IStorageService),
  __param(6, ITextResourceConfigurationService),
  __param(7, IEditorService),
  __param(8, IThemeService),
  __param(9, IEditorGroupsService),
  __param(10, ITextFileService),
  __param(11, IExplorerService),
  __param(12, IUriIdentityService),
  __param(13, IPathService),
  __param(14, IConfigurationService),
  __param(15, IPreferencesService),
  __param(16, IHostService)
], TextFileEditor);
let FileUriLabelContribution = class FileUriLabelContribution2 {
  constructor(labelService) {
    labelService.registerFormatter({
      scheme: Schemas.file,
      formatting: {
        label: "${authority}${path}",
        separator: sep,
        tildify: !isWindows,
        normalizeDriveLetter: isWindows,
        authorityPrefix: sep + sep,
        workspaceSuffix: ""
      }
    });
  }
};
FileUriLabelContribution = __decorate([
  __param(0, ILabelService)
], FileUriLabelContribution);
Registry.as(EditorExtensions.EditorPane).registerEditorPane(EditorPaneDescriptor.create(TextFileEditor, TextFileEditor.ID, localize("textFileEditor", "Text File Editor")), [
  new SyncDescriptor(FileEditorInput)
]);
Registry.as(EditorExtensions.EditorPane).registerEditorPane(EditorPaneDescriptor.create(BinaryFileEditor, BinaryFileEditor.ID, localize("binaryFileEditor", "Binary File Editor")), [
  new SyncDescriptor(FileEditorInput)
]);
Registry.as(EditorExtensions.EditorFactory).registerFileEditorFactory({
  typeId: FILE_EDITOR_INPUT_ID,
  createFileEditor: (resource, preferredResource, preferredName, preferredDescription, preferredEncoding, preferredLanguageId, preferredContents, instantiationService) => {
    return instantiationService.createInstance(FileEditorInput, resource, preferredResource, preferredName, preferredDescription, preferredEncoding, preferredLanguageId, preferredContents);
  },
  isFileEditor: (obj) => {
    return obj instanceof FileEditorInput;
  }
});
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(FileEditorWorkingCopyEditorHandler, 2);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(ExplorerViewletViewsContribution, 1);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(TextFileEditorTracker, 1);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(TextFileSaveErrorHandler, 1);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(FileUriLabelContribution, 1);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(WorkspaceWatcher, 3);
Registry.as(Extensions$3.Workbench).registerWorkbenchContribution(DirtyFilesIndicator, 1);
UndoCommand.addImplementation(110, "explorer", (accessor) => {
  const undoRedoService = accessor.get(IUndoRedoService);
  const explorerService = accessor.get(IExplorerService);
  const configurationService = accessor.get(IConfigurationService);
  const explorerCanUndo = configurationService.getValue().explorer.enableUndo;
  if (explorerService.hasViewFocus() && undoRedoService.canUndo(UNDO_REDO_SOURCE) && explorerCanUndo) {
    undoRedoService.undo(UNDO_REDO_SOURCE);
    return true;
  }
  return false;
});
RedoCommand.addImplementation(110, "explorer", (accessor) => {
  const undoRedoService = accessor.get(IUndoRedoService);
  const explorerService = accessor.get(IExplorerService);
  const configurationService = accessor.get(IConfigurationService);
  const explorerCanUndo = configurationService.getValue().explorer.enableUndo;
  if (explorerService.hasViewFocus() && undoRedoService.canRedo(UNDO_REDO_SOURCE) && explorerCanUndo) {
    undoRedoService.redo(UNDO_REDO_SOURCE);
    return true;
  }
  return false;
});
ModesRegistry.registerLanguage({
  id: BINARY_TEXT_FILE_MODE,
  aliases: ["Binary"],
  mimetypes: ["text/x-code-binary"]
});
let EditorResolverService = (_C = class extends Disposable {
  constructor(editorGroupService, instantiationService, configurationService, quickInputService, notificationService, telemetryService, storageService, extensionService, logService) {
    super();
    this.editorGroupService = editorGroupService;
    this.instantiationService = instantiationService;
    this.configurationService = configurationService;
    this.quickInputService = quickInputService;
    this.notificationService = notificationService;
    this.telemetryService = telemetryService;
    this.storageService = storageService;
    this.extensionService = extensionService;
    this.logService = logService;
    this._onDidChangeEditorRegistrations = this._register(new PauseableEmitter());
    this.onDidChangeEditorRegistrations = this._onDidChangeEditorRegistrations.event;
    this._editors = /* @__PURE__ */ new Map();
    this._flattenedEditors = /* @__PURE__ */ new Map();
    this._shouldReFlattenEditors = true;
    this.cache = new Set(
      JSON.parse(this.storageService.get(_C.cacheStorageID, 0, JSON.stringify([])))
    );
    this.storageService.remove(_C.cacheStorageID, 0);
    this._register(this.storageService.onWillSaveState(() => {
      this.cacheEditors();
    }));
    this.extensionService.onDidRegisterExtensions(() => {
      this.cache = void 0;
    });
  }
  resolveUntypedInputAndGroup(editor, preferredGroup) {
    const untypedEditor = editor;
    const [group, activation] = this.instantiationService.invokeFunction(findGroup, untypedEditor, preferredGroup);
    return [untypedEditor, group, activation];
  }
  async resolveEditor(editor, preferredGroup) {
    var _a2, _b2, _c2, _d2;
    this._flattenedEditors = this._flattenEditorsMap();
    if (isResourceSideBySideEditorInput(editor)) {
      return this.doResolveSideBySideEditor(editor, preferredGroup);
    }
    const resolvedUntypedAndGroup = this.resolveUntypedInputAndGroup(editor, preferredGroup);
    if (!resolvedUntypedAndGroup) {
      return 2;
    }
    const [untypedEditor, group, activation] = resolvedUntypedAndGroup;
    if (activation) {
      untypedEditor.options = { ...untypedEditor.options, activation };
    }
    let resource = EditorResourceAccessor.getCanonicalUri(untypedEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
    if (this.cache && resource && this.resourceMatchesCache(resource)) {
      await this.extensionService.whenInstalledExtensionsRegistered();
    }
    if (resource === void 0) {
      resource = URI.from({ scheme: Schemas.untitled });
    } else if (resource.scheme === void 0 || resource === null) {
      return 2;
    }
    if (((_a2 = untypedEditor.options) == null ? void 0 : _a2.override) === EditorResolution.PICK) {
      const picked = await this.doPickEditor(untypedEditor);
      if (!picked) {
        return 1;
      }
      untypedEditor.options = picked;
    }
    let { editor: selectedEditor, conflictingDefault } = this.getEditor(resource, (_b2 = untypedEditor.options) == null ? void 0 : _b2.override);
    if (!selectedEditor && (((_c2 = untypedEditor.options) == null ? void 0 : _c2.override) || isEditorInputWithOptions(editor))) {
      return 2;
    } else if (!selectedEditor) {
      const resolvedEditor = this.getEditor(resource, DEFAULT_EDITOR_ASSOCIATION.id);
      selectedEditor = resolvedEditor == null ? void 0 : resolvedEditor.editor;
      conflictingDefault = resolvedEditor == null ? void 0 : resolvedEditor.conflictingDefault;
      if (!selectedEditor) {
        return 2;
      }
    }
    if (isResourceDiffEditorInput(untypedEditor) && ((_d2 = untypedEditor.options) == null ? void 0 : _d2.override) === void 0) {
      let resource2 = EditorResourceAccessor.getCanonicalUri(untypedEditor, { supportSideBySide: SideBySideEditor.SECONDARY });
      if (!resource2) {
        resource2 = URI.from({ scheme: Schemas.untitled });
      }
      const { editor: selectedEditor2 } = this.getEditor(resource2, void 0);
      if (!selectedEditor2 || selectedEditor.editorInfo.id !== selectedEditor2.editorInfo.id) {
        const { editor: selectedDiff, conflictingDefault: conflictingDefaultDiff } = this.getEditor(resource, DEFAULT_EDITOR_ASSOCIATION.id);
        selectedEditor = selectedDiff;
        conflictingDefault = conflictingDefaultDiff;
      }
      if (!selectedEditor) {
        return 2;
      }
    }
    untypedEditor.options = { override: selectedEditor.editorInfo.id, ...untypedEditor.options };
    if (selectedEditor.editorFactoryObject.createDiffEditorInput === void 0 && isResourceDiffEditorInput(untypedEditor)) {
      return 2;
    }
    const input = await this.doResolveEditor(untypedEditor, group, selectedEditor);
    if (conflictingDefault && input) {
      await this.doHandleConflictingDefaults(resource, selectedEditor.editorInfo.label, untypedEditor, input.editor, group);
    }
    if (input) {
      this.sendEditorResolutionTelemetry(input.editor);
      if (input.editor.editorId !== selectedEditor.editorInfo.id) {
        this.logService.warn(`Editor ID Mismatch: ${input.editor.editorId} !== ${selectedEditor.editorInfo.id}. This will cause bugs. Please ensure editorInput.editorId matches the registered id`);
      }
      return { ...input, group };
    }
    return 1;
  }
  async doResolveSideBySideEditor(editor, preferredGroup) {
    const primaryResolvedEditor = await this.resolveEditor(editor.primary, preferredGroup);
    if (!isEditorInputWithOptionsAndGroup(primaryResolvedEditor)) {
      return 2;
    }
    const secondaryResolvedEditor = await this.resolveEditor(editor.secondary, primaryResolvedEditor.group ?? preferredGroup);
    if (!isEditorInputWithOptionsAndGroup(secondaryResolvedEditor)) {
      return 2;
    }
    return {
      group: primaryResolvedEditor.group ?? secondaryResolvedEditor.group,
      editor: this.instantiationService.createInstance(SideBySideEditorInput, editor.label, editor.description, secondaryResolvedEditor.editor, primaryResolvedEditor.editor),
      options: editor.options
    };
  }
  bufferChangeEvents(callback) {
    this._onDidChangeEditorRegistrations.pause();
    try {
      callback();
    } finally {
      this._onDidChangeEditorRegistrations.resume();
    }
  }
  registerEditor(globPattern, editorInfo, options, editorFactoryObject) {
    let registeredEditor = this._editors.get(globPattern);
    if (registeredEditor === void 0) {
      registeredEditor = /* @__PURE__ */ new Map();
      this._editors.set(globPattern, registeredEditor);
    }
    let editorsWithId = registeredEditor.get(editorInfo.id);
    if (editorsWithId === void 0) {
      editorsWithId = [];
    }
    const remove2 = insert(editorsWithId, {
      globPattern,
      editorInfo,
      options,
      editorFactoryObject
    });
    registeredEditor.set(editorInfo.id, editorsWithId);
    this._shouldReFlattenEditors = true;
    this._onDidChangeEditorRegistrations.fire();
    return toDisposable(() => {
      remove2();
      if (editorsWithId && editorsWithId.length === 0) {
        registeredEditor == null ? void 0 : registeredEditor.delete(editorInfo.id);
      }
      this._shouldReFlattenEditors = true;
      this._onDidChangeEditorRegistrations.fire();
    });
  }
  getAssociationsForResource(resource) {
    const associations = this.getAllUserAssociations();
    const matchingAssociations = associations.filter((association) => association.filenamePattern && globMatchesResource(association.filenamePattern, resource));
    const allEditors = this._registeredEditors;
    return matchingAssociations.filter((association) => allEditors.find((c) => c.editorInfo.id === association.viewType));
  }
  getAllUserAssociations() {
    const inspectedEditorAssociations = this.configurationService.inspect(editorsAssociationsSettingId) || {};
    const workspaceAssociations = inspectedEditorAssociations.workspaceValue ?? {};
    const userAssociations = inspectedEditorAssociations.userValue ?? {};
    const rawAssociations = { ...workspaceAssociations };
    for (const [key, value] of Object.entries(userAssociations)) {
      if (rawAssociations[key] === void 0) {
        rawAssociations[key] = value;
      }
    }
    const associations = [];
    for (const [key, value] of Object.entries(rawAssociations)) {
      const association = {
        filenamePattern: key,
        viewType: value
      };
      associations.push(association);
    }
    return associations;
  }
  _flattenEditorsMap() {
    if (!this._shouldReFlattenEditors) {
      return this._flattenedEditors;
    }
    this._shouldReFlattenEditors = false;
    const editors = /* @__PURE__ */ new Map();
    for (const [glob, value] of this._editors) {
      const registeredEditors = [];
      for (const editors2 of value.values()) {
        let registeredEditor = void 0;
        for (const editor of editors2) {
          if (!registeredEditor) {
            registeredEditor = {
              editorInfo: editor.editorInfo,
              globPattern: editor.globPattern,
              options: {},
              editorFactoryObject: {}
            };
          }
          registeredEditor.options = { ...registeredEditor.options, ...editor.options };
          registeredEditor.editorFactoryObject = { ...registeredEditor.editorFactoryObject, ...editor.editorFactoryObject };
        }
        if (registeredEditor) {
          registeredEditors.push(registeredEditor);
        }
      }
      editors.set(glob, registeredEditors);
    }
    return editors;
  }
  get _registeredEditors() {
    return flatten(Array.from(this._flattenedEditors.values()));
  }
  updateUserAssociations(globPattern, editorID) {
    const newAssociation = { viewType: editorID, filenamePattern: globPattern };
    const currentAssociations = this.getAllUserAssociations();
    const newSettingObject = /* @__PURE__ */ Object.create(null);
    for (const association of [...currentAssociations, newAssociation]) {
      if (association.filenamePattern) {
        newSettingObject[association.filenamePattern] = association.viewType;
      }
    }
    this.configurationService.updateValue(editorsAssociationsSettingId, newSettingObject);
  }
  findMatchingEditors(resource) {
    const userSettings = this.getAssociationsForResource(resource);
    const matchingEditors = [];
    for (const [key, editors] of this._flattenedEditors) {
      for (const editor of editors) {
        const foundInSettings = userSettings.find((setting) => setting.viewType === editor.editorInfo.id);
        if (foundInSettings && editor.editorInfo.priority !== RegisteredEditorPriority.exclusive || globMatchesResource(key, resource)) {
          matchingEditors.push(editor);
        }
      }
    }
    return matchingEditors.sort((a, b) => {
      if (priorityToRank(b.editorInfo.priority) === priorityToRank(a.editorInfo.priority) && typeof b.globPattern === "string" && typeof a.globPattern === "string") {
        return b.globPattern.length - a.globPattern.length;
      }
      return priorityToRank(b.editorInfo.priority) - priorityToRank(a.editorInfo.priority);
    });
  }
  getEditors(resource) {
    this._flattenedEditors = this._flattenEditorsMap();
    if (URI.isUri(resource)) {
      const editors = this.findMatchingEditors(resource);
      if (editors.find((e) => e.editorInfo.priority === RegisteredEditorPriority.exclusive)) {
        return [];
      }
      return editors.map((editor) => editor.editorInfo);
    }
    return distinct(this._registeredEditors.map((editor) => editor.editorInfo), (editor) => editor.id);
  }
  getEditor(resource, editorId) {
    var _a2;
    const findMatchingEditor = (editors2, viewType) => {
      return editors2.find((editor) => {
        if (editor.options && editor.options.canSupportResource !== void 0) {
          return editor.editorInfo.id === viewType && editor.options.canSupportResource(resource);
        }
        return editor.editorInfo.id === viewType;
      });
    };
    if (editorId && editorId !== EditorResolution.EXCLUSIVE_ONLY) {
      const registeredEditors = this._registeredEditors;
      return {
        editor: findMatchingEditor(registeredEditors, editorId),
        conflictingDefault: false
      };
    }
    const editors = this.findMatchingEditors(resource);
    const associationsFromSetting = this.getAssociationsForResource(resource);
    const minPriority = editorId === EditorResolution.EXCLUSIVE_ONLY ? RegisteredEditorPriority.exclusive : RegisteredEditorPriority.builtin;
    let possibleEditors = editors.filter((editor) => priorityToRank(editor.editorInfo.priority) >= priorityToRank(minPriority) && editor.editorInfo.id !== DEFAULT_EDITOR_ASSOCIATION.id);
    if (possibleEditors.length === 0) {
      return {
        editor: associationsFromSetting[0] && minPriority !== RegisteredEditorPriority.exclusive ? findMatchingEditor(editors, associationsFromSetting[0].viewType) : void 0,
        conflictingDefault: false
      };
    }
    const selectedViewType = possibleEditors[0].editorInfo.priority === RegisteredEditorPriority.exclusive ? possibleEditors[0].editorInfo.id : ((_a2 = associationsFromSetting[0]) == null ? void 0 : _a2.viewType) || possibleEditors[0].editorInfo.id;
    let conflictingDefault = false;
    possibleEditors = possibleEditors.filter((editor) => editor.editorInfo.priority !== RegisteredEditorPriority.exclusive);
    if (associationsFromSetting.length === 0 && possibleEditors.length > 1) {
      conflictingDefault = true;
    }
    return {
      editor: findMatchingEditor(editors, selectedViewType),
      conflictingDefault
    };
  }
  async doResolveEditor(editor, group, selectedEditor) {
    var _a2, _b2;
    let options = editor.options;
    const resource = EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });
    if (options && typeof options.activation === "undefined") {
      options = { ...options, activation: options.preserveFocus ? EditorActivation.RESTORE : void 0 };
    }
    if (isResourceMergeEditorInput(editor)) {
      if (!selectedEditor.editorFactoryObject.createMergeEditorInput) {
        return;
      }
      const inputWithOptions2 = await selectedEditor.editorFactoryObject.createMergeEditorInput(editor, group);
      return { editor: inputWithOptions2.editor, options: inputWithOptions2.options ?? options };
    }
    if (isResourceDiffEditorInput(editor)) {
      if (!selectedEditor.editorFactoryObject.createDiffEditorInput) {
        return;
      }
      const inputWithOptions2 = await selectedEditor.editorFactoryObject.createDiffEditorInput(editor, group);
      return { editor: inputWithOptions2.editor, options: inputWithOptions2.options ?? options };
    }
    if (isResourceSideBySideEditorInput(editor)) {
      throw new Error(`Untyped side by side editor input not supported here.`);
    }
    if (isUntitledResourceEditorInput(editor)) {
      if (!selectedEditor.editorFactoryObject.createUntitledEditorInput) {
        return;
      }
      const inputWithOptions2 = await selectedEditor.editorFactoryObject.createUntitledEditorInput(editor, group);
      return { editor: inputWithOptions2.editor, options: inputWithOptions2.options ?? options };
    }
    if (resource === void 0) {
      throw new Error(`Undefined resource on non untitled editor input.`);
    }
    const singleEditorPerResource = typeof ((_a2 = selectedEditor.options) == null ? void 0 : _a2.singlePerResource) === "function" ? selectedEditor.options.singlePerResource() : (_b2 = selectedEditor.options) == null ? void 0 : _b2.singlePerResource;
    if (singleEditorPerResource) {
      const foundInput = await this.moveExistingEditorForResource(resource, selectedEditor.editorInfo.id, group);
      if (foundInput) {
        return { editor: foundInput, options };
      }
    }
    if (!selectedEditor.editorFactoryObject.createEditorInput) {
      return;
    }
    const inputWithOptions = await selectedEditor.editorFactoryObject.createEditorInput(editor, group);
    options = inputWithOptions.options ?? options;
    const input = inputWithOptions.editor;
    return { editor: input, options };
  }
  async moveExistingEditorForResource(resource, viewType, targetGroup) {
    const editorInfoForResource = this.findExistingEditorsForResource(resource, viewType);
    if (!editorInfoForResource.length) {
      return;
    }
    const editorToUse = editorInfoForResource[0];
    for (const { editor, group } of editorInfoForResource) {
      if (editor !== editorToUse.editor) {
        const closed = await group.closeEditor(editor);
        if (!closed) {
          return;
        }
      }
    }
    if (targetGroup.id !== editorToUse.group.id) {
      editorToUse.group.moveEditor(editorToUse.editor, targetGroup);
      return editorToUse.editor;
    }
    return;
  }
  findExistingEditorsForResource(resource, editorId) {
    const out = [];
    const orderedGroups = distinct([
      ...this.editorGroupService.groups
    ]);
    for (const group of orderedGroups) {
      for (const editor of group.editors) {
        if (isEqual(editor.resource, resource) && editor.editorId === editorId) {
          out.push({ editor, group });
        }
      }
    }
    return out;
  }
  async doHandleConflictingDefaults(resource, editorName, untypedInput, currentEditor, group) {
    const editors = this.findMatchingEditors(resource);
    const storedChoices = JSON.parse(this.storageService.get(_C.conflictingDefaultsStorageID, 0, "{}"));
    const globForResource = `*${extname(resource)}`;
    const writeCurrentEditorsToStorage = () => {
      storedChoices[globForResource] = [];
      editors.forEach((editor) => storedChoices[globForResource].push(editor.editorInfo.id));
      this.storageService.store(_C.conflictingDefaultsStorageID, JSON.stringify(storedChoices), 0, 1);
    };
    if (storedChoices[globForResource] && storedChoices[globForResource].find((editorID) => editorID === currentEditor.editorId)) {
      return;
    }
    const handle = this.notificationService.prompt(Severity.Warning, localize(
      "editorResolver.conflictingDefaults",
      "There are multiple default editors available for the resource."
    ), [
      {
        label: localize("editorResolver.configureDefault", "Configure Default"),
        run: async () => {
          const picked = await this.doPickEditor(untypedInput, true);
          if (!picked) {
            return;
          }
          untypedInput.options = picked;
          const replacementEditor = await this.resolveEditor(untypedInput, group);
          if (replacementEditor === 1 || replacementEditor === 2) {
            return;
          }
          group.replaceEditors([
            {
              editor: currentEditor,
              replacement: replacementEditor.editor,
              options: replacementEditor.options ?? picked
            }
          ]);
        }
      },
      {
        label: localize("editorResolver.keepDefault", "Keep {0}", editorName),
        run: writeCurrentEditorsToStorage
      }
    ]);
    const onCloseListener = handle.onDidClose(() => {
      writeCurrentEditorsToStorage();
      onCloseListener.dispose();
    });
  }
  mapEditorsToQuickPickEntry(resource, showDefaultPicker) {
    var _a2, _b2, _c2;
    const currentEditor = firstOrDefault(this.editorGroupService.activeGroup.findEditors(resource));
    let registeredEditors = resource.scheme === Schemas.untitled ? this._registeredEditors.filter((e) => e.editorInfo.priority !== RegisteredEditorPriority.exclusive) : this.findMatchingEditors(resource);
    registeredEditors = distinct(registeredEditors, (c) => c.editorInfo.id);
    const defaultSetting = (_a2 = this.getAssociationsForResource(resource)[0]) == null ? void 0 : _a2.viewType;
    registeredEditors = registeredEditors.sort((a, b) => {
      if (a.editorInfo.id === DEFAULT_EDITOR_ASSOCIATION.id) {
        return -1;
      } else if (b.editorInfo.id === DEFAULT_EDITOR_ASSOCIATION.id) {
        return 1;
      } else {
        return priorityToRank(b.editorInfo.priority) - priorityToRank(a.editorInfo.priority);
      }
    });
    const quickPickEntries = [];
    const currentlyActiveLabel = localize("promptOpenWith.currentlyActive", "Active");
    const currentDefaultLabel = localize("promptOpenWith.currentDefault", "Default");
    const currentDefaultAndActiveLabel = localize("promptOpenWith.currentDefaultAndActive", "Active and Default");
    let defaultViewType = defaultSetting;
    if (!defaultViewType && registeredEditors.length > 2 && ((_b2 = registeredEditors[1]) == null ? void 0 : _b2.editorInfo.priority) !== RegisteredEditorPriority.option) {
      defaultViewType = (_c2 = registeredEditors[1]) == null ? void 0 : _c2.editorInfo.id;
    }
    if (!defaultViewType) {
      defaultViewType = DEFAULT_EDITOR_ASSOCIATION.id;
    }
    registeredEditors.forEach((editor) => {
      const currentViewType = (currentEditor == null ? void 0 : currentEditor.editorId) ?? DEFAULT_EDITOR_ASSOCIATION.id;
      const isActive = currentEditor ? editor.editorInfo.id === currentViewType : false;
      const isDefault = editor.editorInfo.id === defaultViewType;
      const quickPickEntry = {
        id: editor.editorInfo.id,
        label: editor.editorInfo.label,
        description: isActive && isDefault ? currentDefaultAndActiveLabel : isActive ? currentlyActiveLabel : isDefault ? currentDefaultLabel : void 0,
        detail: editor.editorInfo.detail ?? editor.editorInfo.priority
      };
      quickPickEntries.push(quickPickEntry);
    });
    if (!showDefaultPicker && extname(resource) !== "") {
      const separator = { type: "separator" };
      quickPickEntries.push(separator);
      const configureDefaultEntry = {
        id: _C.configureDefaultID,
        label: localize(
          "promptOpenWith.configureDefault",
          "Configure default editor for '{0}'...",
          `*${extname(resource)}`
        )
      };
      quickPickEntries.push(configureDefaultEntry);
    }
    return quickPickEntries;
  }
  async doPickEditor(editor, showDefaultPicker) {
    var _a2;
    let resource = EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY });
    if (resource === void 0) {
      resource = URI.from({ scheme: Schemas.untitled });
    }
    const editorPicks = this.mapEditorsToQuickPickEntry(resource, showDefaultPicker);
    const editorPicker = this.quickInputService.createQuickPick();
    const placeHolderMessage = showDefaultPicker ? localize(
      "promptOpenWith.updateDefaultPlaceHolder",
      "Select new default editor for '{0}'",
      `*${extname(resource)}`
    ) : localize(
      "promptOpenWith.placeHolder",
      "Select editor for '{0}'",
      basename(resource)
    );
    editorPicker.placeholder = placeHolderMessage;
    editorPicker.canAcceptInBackground = true;
    editorPicker.items = editorPicks;
    const firstItem = editorPicker.items.find((item) => item.type === "item");
    if (firstItem) {
      editorPicker.selectedItems = [firstItem];
    }
    const picked = await new Promise((resolve) => {
      editorPicker.onDidAccept((e) => {
        let result = void 0;
        if (editorPicker.selectedItems.length === 1) {
          result = {
            item: editorPicker.selectedItems[0],
            keyMods: editorPicker.keyMods,
            openInBackground: e.inBackground
          };
        }
        if (resource && showDefaultPicker && (result == null ? void 0 : result.item.id)) {
          this.updateUserAssociations(`*${extname(resource)}`, result.item.id);
        }
        resolve(result);
      });
      editorPicker.onDidHide(() => resolve(void 0));
      editorPicker.onDidTriggerItemButton((e) => {
        resolve({ item: e.item, openInBackground: false });
        if (resource && e.item && e.item.id) {
          this.updateUserAssociations(`*${extname(resource)}`, e.item.id);
        }
      });
      editorPicker.show();
    });
    editorPicker.dispose();
    if (picked) {
      if (picked.item.id === _C.configureDefaultID) {
        return this.doPickEditor(editor, true);
      }
      const targetOptions = {
        ...editor.options,
        override: picked.item.id,
        preserveFocus: picked.openInBackground || ((_a2 = editor.options) == null ? void 0 : _a2.preserveFocus)
      };
      return targetOptions;
    }
    return void 0;
  }
  sendEditorResolutionTelemetry(chosenInput) {
    if (chosenInput.editorId) {
      this.telemetryService.publicLog2("override.viewType", { viewType: chosenInput.editorId });
    }
  }
  cacheEditors() {
    const cacheStorage = /* @__PURE__ */ new Set();
    for (const [globPattern, contribPoint] of this._flattenedEditors) {
      const nonOptional = !!contribPoint.find((c) => c.editorInfo.priority !== RegisteredEditorPriority.option && c.editorInfo.id !== DEFAULT_EDITOR_ASSOCIATION.id);
      if (!nonOptional) {
        continue;
      }
      if (isRelativePattern(globPattern)) {
        cacheStorage.add(`${globPattern.pattern}`);
      } else {
        cacheStorage.add(globPattern);
      }
    }
    const userAssociations = this.getAllUserAssociations();
    for (const association of userAssociations) {
      if (association.filenamePattern) {
        cacheStorage.add(association.filenamePattern);
      }
    }
    this.storageService.store(_C.cacheStorageID, JSON.stringify(Array.from(cacheStorage)), 0, 1);
  }
  resourceMatchesCache(resource) {
    if (!this.cache) {
      return false;
    }
    for (const cacheEntry of this.cache) {
      if (globMatchesResource(cacheEntry, resource)) {
        return true;
      }
    }
    return false;
  }
}, _C.configureDefaultID = "promptOpenWith.configureDefault", _C.cacheStorageID = "editorOverrideService.cache", _C.conflictingDefaultsStorageID = "editorOverrideService.conflictingDefaults", _C);
EditorResolverService = __decorate([
  __param(0, IEditorGroupsService),
  __param(1, IInstantiationService),
  __param(2, IConfigurationService),
  __param(3, IQuickInputService),
  __param(4, INotificationService),
  __param(5, ITelemetryService),
  __param(6, IStorageService),
  __param(7, IExtensionService),
  __param(8, ILogService)
], EditorResolverService);
var css$2 = '.monaco-workbench .part.statusbar{box-sizing:border-box;cursor:default;display:flex;font-size:12px;height:22px;overflow:hidden;width:100%}.monaco-workbench:not(.reduce-motion) .part.statusbar{transition:background-color .15s ease-out}.monaco-workbench .part.statusbar.status-border-top:after{background-color:var(--status-border-top-color);content:"";height:1px;left:0;pointer-events:none;position:absolute;top:0;width:100%;z-index:5}.monaco-workbench .part.statusbar>.left-items,.monaco-workbench .part.statusbar>.right-items{display:flex}.monaco-workbench .part.statusbar>.right-items{flex-direction:row-reverse;flex-wrap:wrap}.monaco-workbench .part.statusbar>.left-items{flex-grow:1}.monaco-workbench .part.statusbar>.items-container>.statusbar-item{display:inline-block;font-variant-numeric:tabular-nums;height:100%;line-height:22px;max-width:40vw;vertical-align:top}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-beak{position:relative}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-beak>.status-bar-item-beak-container{height:5px;left:calc(50% - 5px);position:absolute;top:-5px;width:10px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-beak>.status-bar-item-beak-container:before{border-bottom-style:solid;border-bottom-width:5px;border-left:5px solid transparent;border-right:5px solid transparent;content:"";position:fixed}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>.statusbar-item-label{margin-left:3px;margin-right:3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-left>.statusbar-item-label{margin-left:0;margin-right:3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-right>.statusbar-item-label{margin-left:3px;margin-right:0}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.left.first-visible-item{padding-left:7px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.right.last-visible-item{margin-right:7px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-background-color.left.first-visible-item,.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-background-color.right.last-visible-item{padding-left:0;padding-right:0}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.has-background-color>.statusbar-item-label{margin-left:0;margin-right:0;padding-left:10px;padding-right:10px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-left.has-background-color>.statusbar-item-label{padding-left:3px;padding-right:10px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-right.has-background-color>.statusbar-item-label{padding-left:10px;padding-right:3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>.statusbar-item-label{align-items:center;cursor:pointer;display:flex;height:100%;outline-width:0;overflow:hidden;padding:0 5px;text-overflow:ellipsis;white-space:pre}.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-left>.statusbar-item-label,.monaco-workbench .part.statusbar>.items-container>.statusbar-item.compact-right>.statusbar-item-label{padding:0 3px}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>a:hover:not(.disabled){text-decoration:none}.monaco-workbench .part.statusbar>.items-container>.statusbar-item>a.disabled{cursor:default}.monaco-workbench .part.statusbar>.items-container>.statusbar-item span.codicon{color:inherit;font-size:14px;text-align:center}.monaco-workbench .part.statusbar>.items-container>.statusbar-item .status-bar-info{background-color:var(--vscode-statusBarItem-prominentBackground);color:var(--vscode-statusBarItem-prominentForeground)}.monaco-workbench .part.statusbar>.items-container>.statusbar-item a.status-bar-info:hover:not(.disabled){background-color:var(--vscode-statusBarItem-prominentHoverBackground)}.monaco-workbench .part.statusbar>.items-container>.statusbar-item a:active:not(.disabled){outline:1px solid var(--vscode-contrastActiveBorder)!important;outline-offset:-1px}.monaco-workbench:not(.hc-light):not(.hc-black) .part.statusbar>.items-container>.statusbar-item a:active:not(.disabled){background-color:var(--vscode-statusBarItem-activeBackground)!important}.monaco-workbench .part.statusbar>.items-container>.statusbar-item a:hover:not(.disabled){outline:1px dashed var(--vscode-contrastActiveBorder);outline-offset:-1px}.monaco-workbench:not(.hc-light):not(.hc-black) .part.statusbar>.items-container>.statusbar-item a:hover:not(.disabled){background-color:var(--vscode-statusBarItem-hoverBackground)}';
n(css$2, {});
class ToggleStatusbarEntryVisibilityAction extends Action {
  constructor(id, label, model) {
    super(id, label, void 0, true);
    this.model = model;
    this.checked = !model.isHidden(id);
  }
  async run() {
    if (this.model.isHidden(this.id)) {
      this.model.show(this.id);
    } else {
      this.model.hide(this.id);
    }
  }
}
class HideStatusbarEntryAction extends Action {
  constructor(id, name, model) {
    super(id, localize("hide", "Hide '{0}'", name), void 0, true);
    this.model = model;
  }
  async run() {
    this.model.hide(this.id);
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusPrevious",
  weight: 200,
  primary: 15,
  secondary: [16],
  when: StatusBarFocused,
  handler: (accessor) => {
    const statusBarService = accessor.get(IStatusbarService);
    statusBarService.focusPreviousEntry();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusNext",
  weight: 200,
  primary: 17,
  secondary: [18],
  when: StatusBarFocused,
  handler: (accessor) => {
    const statusBarService = accessor.get(IStatusbarService);
    statusBarService.focusNextEntry();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusFirst",
  weight: 200,
  primary: 14,
  when: StatusBarFocused,
  handler: (accessor) => {
    const statusBarService = accessor.get(IStatusbarService);
    statusBarService.focus(false);
    statusBarService.focusNextEntry();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.focusLast",
  weight: 200,
  primary: 13,
  when: StatusBarFocused,
  handler: (accessor) => {
    const statusBarService = accessor.get(IStatusbarService);
    statusBarService.focus(false);
    statusBarService.focusPreviousEntry();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "workbench.statusBar.clearFocus",
  weight: 200,
  primary: 9,
  when: StatusBarFocused,
  handler: (accessor) => {
    const statusBarService = accessor.get(IStatusbarService);
    const editorService = accessor.get(IEditorService);
    if (statusBarService.isEntryFocused()) {
      statusBarService.focus(false);
    } else if (editorService.activeEditorPane) {
      editorService.activeEditorPane.focus();
    }
  }
});
class FocusStatusBarAction extends Action2 {
  constructor() {
    super({
      id: "workbench.action.focusStatusBar",
      title: { value: localize("focusStatusBar", "Focus Status Bar"), original: "Focus Status Bar" },
      category: Categories.View,
      f1: true
    });
  }
  async run(accessor) {
    const layoutService = accessor.get(IWorkbenchLayoutService);
    layoutService.focusPart("workbench.parts.statusbar");
  }
}
registerAction2(FocusStatusBarAction);
const _StatusbarViewModel = class _StatusbarViewModel extends Disposable {
  get entries() {
    return this._entries.slice(0);
  }
  get lastFocusedEntry() {
    return this._lastFocusedEntry && !this.isHidden(this._lastFocusedEntry.id) ? this._lastFocusedEntry : void 0;
  }
  constructor(storageService) {
    super();
    this.storageService = storageService;
    this._onDidChangeEntryVisibility = this._register(new Emitter());
    this.onDidChangeEntryVisibility = this._onDidChangeEntryVisibility.event;
    this._entries = [];
    this.hidden = /* @__PURE__ */ new Set();
    this.restoreState();
    this.registerListeners();
  }
  restoreState() {
    const hiddenRaw = this.storageService.get(_StatusbarViewModel.HIDDEN_ENTRIES_KEY, 0);
    if (hiddenRaw) {
      try {
        const hiddenArray = JSON.parse(hiddenRaw);
        this.hidden = new Set(hiddenArray);
      } catch (error) {
      }
    }
  }
  registerListeners() {
    this._register(this.storageService.onDidChangeValue((e) => this.onDidStorageValueChange(e)));
  }
  onDidStorageValueChange(event) {
    if (event.key === _StatusbarViewModel.HIDDEN_ENTRIES_KEY && event.scope === 0) {
      const currentlyHidden = new Set(this.hidden);
      this.hidden.clear();
      this.restoreState();
      const changed = /* @__PURE__ */ new Set();
      for (const id of currentlyHidden) {
        if (!this.hidden.has(id)) {
          changed.add(id);
        }
      }
      for (const id of this.hidden) {
        if (!currentlyHidden.has(id)) {
          changed.add(id);
        }
      }
      if (changed.size > 0) {
        for (const entry of this._entries) {
          if (changed.has(entry.id)) {
            this.updateVisibility(entry.id, true);
            changed.delete(entry.id);
          }
        }
      }
    }
  }
  add(entry) {
    this._entries.push(entry);
    this.updateVisibility(entry, false);
    this.sort();
    this.markFirstLastVisibleEntry();
  }
  remove(entry) {
    const index = this._entries.indexOf(entry);
    if (index >= 0) {
      this._entries.splice(index, 1);
      if (this._entries.some(
        (otherEntry) => isStatusbarEntryLocation(otherEntry.priority.primary) && otherEntry.priority.primary.id === entry.id
      )) {
        this.sort();
      }
      this.markFirstLastVisibleEntry();
    }
  }
  isHidden(id) {
    return this.hidden.has(id);
  }
  hide(id) {
    if (!this.hidden.has(id)) {
      this.hidden.add(id);
      this.updateVisibility(id, true);
      this.saveState();
    }
  }
  show(id) {
    if (this.hidden.has(id)) {
      this.hidden.delete(id);
      this.updateVisibility(id, true);
      this.saveState();
    }
  }
  findEntry(container) {
    return this._entries.find((entry) => entry.container === container);
  }
  getEntries(alignment) {
    return this._entries.filter((entry) => entry.alignment === alignment);
  }
  focusNextEntry() {
    this.focusEntry(1, 0);
  }
  focusPreviousEntry() {
    this.focusEntry(-1, this.entries.length - 1);
  }
  isEntryFocused() {
    return !!this.getFocusedEntry();
  }
  getFocusedEntry() {
    return this._entries.find((entry) => isAncestor(document.activeElement, entry.container));
  }
  focusEntry(delta, restartPosition) {
    const getVisibleEntry = (start) => {
      let indexToFocus = start;
      let entry2 = indexToFocus >= 0 && indexToFocus < this._entries.length ? this._entries[indexToFocus] : void 0;
      while (entry2 && this.isHidden(entry2.id)) {
        indexToFocus += delta;
        entry2 = indexToFocus >= 0 && indexToFocus < this._entries.length ? this._entries[indexToFocus] : void 0;
      }
      return entry2;
    };
    const focused = this.getFocusedEntry();
    if (focused) {
      const entry2 = getVisibleEntry(this._entries.indexOf(focused) + delta);
      if (entry2) {
        this._lastFocusedEntry = entry2;
        entry2.labelContainer.focus();
        return;
      }
    }
    const entry = getVisibleEntry(restartPosition);
    if (entry) {
      this._lastFocusedEntry = entry;
      entry.labelContainer.focus();
    }
  }
  updateVisibility(arg1, trigger) {
    if (typeof arg1 === "string") {
      const id = arg1;
      for (const entry of this._entries) {
        if (entry.id === id) {
          this.updateVisibility(entry, trigger);
        }
      }
    } else {
      const entry = arg1;
      const isHidden = this.isHidden(entry.id);
      if (isHidden) {
        hide(entry.container);
      } else {
        show(entry.container);
      }
      if (trigger) {
        this._onDidChangeEntryVisibility.fire({ id: entry.id, visible: !isHidden });
      }
      this.markFirstLastVisibleEntry();
    }
  }
  saveState() {
    if (this.hidden.size > 0) {
      this.storageService.store(_StatusbarViewModel.HIDDEN_ENTRIES_KEY, JSON.stringify(Array.from(this.hidden.values())), 0, 0);
    } else {
      this.storageService.remove(_StatusbarViewModel.HIDDEN_ENTRIES_KEY, 0);
    }
  }
  sort() {
    const mapEntryWithNumberedPriorityToIndex = /* @__PURE__ */ new Map();
    const mapEntryWithRelativePriority = /* @__PURE__ */ new Map();
    for (let i = 0; i < this._entries.length; i++) {
      const entry = this._entries[i];
      if (typeof entry.priority.primary === "number") {
        mapEntryWithNumberedPriorityToIndex.set(entry, i);
      } else {
        let entries = mapEntryWithRelativePriority.get(entry.priority.primary.id);
        if (!entries) {
          entries = [];
          mapEntryWithRelativePriority.set(entry.priority.primary.id, entries);
        }
        entries.push(entry);
      }
    }
    const sortedEntriesWithNumberedPriority = Array.from(mapEntryWithNumberedPriorityToIndex.keys());
    sortedEntriesWithNumberedPriority.sort((entryA, entryB) => {
      if (entryA.alignment === entryB.alignment) {
        if (entryA.priority.primary !== entryB.priority.primary) {
          return Number(entryB.priority.primary) - Number(entryA.priority.primary);
        }
        if (entryA.priority.secondary !== entryB.priority.secondary) {
          return entryB.priority.secondary - entryA.priority.secondary;
        }
        return mapEntryWithNumberedPriorityToIndex.get(entryA) - mapEntryWithNumberedPriorityToIndex.get(entryB);
      }
      if (entryA.alignment === 0) {
        return -1;
      }
      if (entryB.alignment === 0) {
        return 1;
      }
      return 0;
    });
    let sortedEntries;
    if (mapEntryWithRelativePriority.size > 0) {
      sortedEntries = [];
      for (const entry of sortedEntriesWithNumberedPriority) {
        const relativeEntries = mapEntryWithRelativePriority.get(entry.id);
        if (relativeEntries) {
          sortedEntries.push(...relativeEntries.filter((entry2) => isStatusbarEntryLocation(entry2.priority.primary) && entry2.priority.primary.alignment === 0));
        }
        sortedEntries.push(entry);
        if (relativeEntries) {
          sortedEntries.push(...relativeEntries.filter((entry2) => isStatusbarEntryLocation(entry2.priority.primary) && entry2.priority.primary.alignment === 1));
        }
        mapEntryWithRelativePriority.delete(entry.id);
      }
      for (const [, entries] of mapEntryWithRelativePriority) {
        sortedEntries.push(...entries);
      }
    } else {
      sortedEntries = sortedEntriesWithNumberedPriority;
    }
    this._entries = sortedEntries;
  }
  markFirstLastVisibleEntry() {
    this.doMarkFirstLastVisibleStatusbarItem(this.getEntries(0));
    this.doMarkFirstLastVisibleStatusbarItem(this.getEntries(1));
  }
  doMarkFirstLastVisibleStatusbarItem(entries) {
    let firstVisibleItem;
    let lastVisibleItem;
    for (const entry of entries) {
      entry.container.classList.remove("first-visible-item", "last-visible-item");
      const isVisible = !this.isHidden(entry.id);
      if (isVisible) {
        if (!firstVisibleItem) {
          firstVisibleItem = entry;
        }
        lastVisibleItem = entry;
      }
    }
    firstVisibleItem == null ? void 0 : firstVisibleItem.container.classList.add("first-visible-item");
    lastVisibleItem == null ? void 0 : lastVisibleItem.container.classList.add("last-visible-item");
  }
};
_StatusbarViewModel.HIDDEN_ENTRIES_KEY = "workbench.statusbar.hidden";
let StatusbarViewModel = _StatusbarViewModel;
let StatusbarEntryItem = class StatusbarEntryItem2 extends Disposable {
  get name() {
    return assertIsDefined(this.entry).name;
  }
  get hasCommand() {
    var _a2;
    return typeof ((_a2 = this.entry) == null ? void 0 : _a2.command) !== "undefined";
  }
  constructor(container, entry, hoverDelegate, commandService, notificationService, telemetryService, themeService) {
    super();
    this.container = container;
    this.hoverDelegate = hoverDelegate;
    this.commandService = commandService;
    this.notificationService = notificationService;
    this.telemetryService = telemetryService;
    this.themeService = themeService;
    this.entry = void 0;
    this.foregroundListener = this._register(new MutableDisposable());
    this.backgroundListener = this._register(new MutableDisposable());
    this.commandMouseListener = this._register(new MutableDisposable());
    this.commandTouchListener = this._register(new MutableDisposable());
    this.commandKeyboardListener = this._register(new MutableDisposable());
    this.hover = void 0;
    this.labelContainer = document.createElement("a");
    this.labelContainer.tabIndex = -1;
    this.labelContainer.setAttribute("role", "button");
    this.labelContainer.className = "statusbar-item-label";
    this._register(Gesture.addTarget(this.labelContainer));
    this.label = new StatusBarCodiconLabel(this.labelContainer);
    this.container.appendChild(this.labelContainer);
    this.beakContainer = document.createElement("div");
    this.beakContainer.className = "status-bar-item-beak-container";
    this.container.appendChild(this.beakContainer);
    this.update(entry);
  }
  update(entry) {
    this.label.showProgress = entry.showProgress ?? false;
    if (!this.entry || entry.text !== this.entry.text) {
      this.label.text = entry.text;
      if (entry.text) {
        show(this.labelContainer);
      } else {
        hide(this.labelContainer);
      }
    }
    if (!this.entry || entry.ariaLabel !== this.entry.ariaLabel) {
      this.container.setAttribute("aria-label", entry.ariaLabel);
      this.labelContainer.setAttribute("aria-label", entry.ariaLabel);
    }
    if (!this.entry || entry.role !== this.entry.role) {
      this.labelContainer.setAttribute("role", entry.role || "button");
    }
    if (!this.entry || !this.isEqualTooltip(this.entry, entry)) {
      const hoverContents = isMarkdownString(entry.tooltip) ? { markdown: entry.tooltip, markdownNotSupportedFallback: void 0 } : entry.tooltip;
      if (this.hover) {
        this.hover.update(hoverContents);
      } else {
        this.hover = this._register(setupCustomHover(this.hoverDelegate, this.container, hoverContents));
      }
    }
    if (!this.entry || entry.command !== this.entry.command) {
      this.commandMouseListener.clear();
      this.commandTouchListener.clear();
      this.commandKeyboardListener.clear();
      const command = entry.command;
      if (command && (command !== ShowTooltipCommand || this.hover)) {
        this.commandMouseListener.value = addDisposableListener(this.labelContainer, EventType.CLICK, () => this.executeCommand(command));
        this.commandTouchListener.value = addDisposableListener(this.labelContainer, EventType$1.Tap, () => this.executeCommand(command));
        this.commandKeyboardListener.value = addDisposableListener(this.labelContainer, EventType.KEY_DOWN, (e) => {
          const event = new StandardKeyboardEvent(e);
          if (event.equals(10) || event.equals(3)) {
            EventHelper.stop(e);
            this.executeCommand(command);
          }
        });
        this.labelContainer.classList.remove("disabled");
      } else {
        this.labelContainer.classList.add("disabled");
      }
    }
    if (!this.entry || entry.showBeak !== this.entry.showBeak) {
      if (entry.showBeak) {
        this.container.classList.add("has-beak");
      } else {
        this.container.classList.remove("has-beak");
      }
    }
    if (!this.entry || entry.color !== this.entry.color) {
      this.applyColor(this.labelContainer, entry.color);
    }
    if (!this.entry || entry.backgroundColor !== this.entry.backgroundColor) {
      this.container.classList.toggle("has-background-color", !!entry.backgroundColor);
      this.applyColor(this.container, entry.backgroundColor, true);
    }
    this.entry = entry;
  }
  isEqualTooltip({ tooltip }, { tooltip: otherTooltip }) {
    if (tooltip === void 0) {
      return otherTooltip === void 0;
    }
    if (isMarkdownString(tooltip)) {
      return isMarkdownString(otherTooltip) && markdownStringEqual(tooltip, otherTooltip);
    }
    return tooltip === otherTooltip;
  }
  async executeCommand(command) {
    var _a2;
    if (command === ShowTooltipCommand) {
      (_a2 = this.hover) == null ? void 0 : _a2.show(true);
    } else {
      const id = typeof command === "string" ? command : command.id;
      const args = typeof command === "string" ? [] : command.arguments ?? [];
      this.telemetryService.publicLog2("workbenchActionExecuted", { id, from: "status bar" });
      try {
        await this.commandService.executeCommand(id, ...args);
      } catch (error) {
        this.notificationService.error(toErrorMessage(error));
      }
    }
  }
  applyColor(container, color, isBackground) {
    var _a2;
    let colorResult = void 0;
    if (isBackground) {
      this.backgroundListener.clear();
    } else {
      this.foregroundListener.clear();
    }
    if (color) {
      if (isThemeColor(color)) {
        colorResult = (_a2 = this.themeService.getColorTheme().getColor(color.id)) == null ? void 0 : _a2.toString();
        const listener = this.themeService.onDidColorThemeChange((theme) => {
          var _a3;
          const colorValue = (_a3 = theme.getColor(color.id)) == null ? void 0 : _a3.toString();
          if (isBackground) {
            container.style.backgroundColor = colorValue ?? "";
          } else {
            container.style.color = colorValue ?? "";
          }
        });
        if (isBackground) {
          this.backgroundListener.value = listener;
        } else {
          this.foregroundListener.value = listener;
        }
      } else {
        colorResult = color;
      }
    }
    if (isBackground) {
      container.style.backgroundColor = colorResult ?? "";
    } else {
      container.style.color = colorResult ?? "";
    }
  }
};
StatusbarEntryItem = __decorate([
  __param(3, ICommandService),
  __param(4, INotificationService),
  __param(5, ITelemetryService),
  __param(6, IThemeService)
], StatusbarEntryItem);
class StatusBarCodiconLabel extends SimpleIconLabel {
  constructor(container) {
    super(container);
    this.container = container;
    this.progressCodicon = renderIcon(syncing);
    this.currentText = "";
    this.currentShowProgress = false;
  }
  set showProgress(showProgress) {
    if (this.currentShowProgress !== showProgress) {
      this.currentShowProgress = showProgress;
      this.progressCodicon = renderIcon(showProgress === "loading" ? spinningLoading : syncing);
      this.text = this.currentText;
    }
  }
  set text(text) {
    if (this.currentShowProgress) {
      if (this.container.firstChild !== this.progressCodicon) {
        this.container.appendChild(this.progressCodicon);
      }
      for (const node of Array.from(this.container.childNodes)) {
        if (node !== this.progressCodicon) {
          node.remove();
        }
      }
      let textContent = text ?? "";
      if (textContent) {
        textContent = ` ${textContent}`;
      }
      append(this.container, ...renderLabelWithIcons(textContent));
    } else {
      super.text = text;
    }
  }
}
let StatusbarPart = class StatusbarPart2 extends Part {
  constructor(instantiationService, themeService, contextService, storageService, layoutService, contextMenuService, contextKeyService, hoverService, configurationService) {
    super("workbench.parts.statusbar", { hasTitle: false }, themeService, storageService, layoutService);
    this.instantiationService = instantiationService;
    this.contextService = contextService;
    this.storageService = storageService;
    this.contextMenuService = contextMenuService;
    this.contextKeyService = contextKeyService;
    this.hoverService = hoverService;
    this.configurationService = configurationService;
    this.minimumWidth = 0;
    this.maximumWidth = Number.POSITIVE_INFINITY;
    this.minimumHeight = 22;
    this.maximumHeight = 22;
    this.pendingEntries = [];
    this.viewModel = this._register(new StatusbarViewModel(this.storageService));
    this.onDidChangeEntryVisibility = this.viewModel.onDidChangeEntryVisibility;
    this.hoverDelegate = new class {
      get delay() {
        if (Date.now() - this.lastHoverHideTime < 200) {
          return 0;
        }
        return this.configurationService.getValue("workbench.hover.delay");
      }
      constructor(configurationService2, hoverService2) {
        this.configurationService = configurationService2;
        this.hoverService = hoverService2;
        this.lastHoverHideTime = 0;
        this.placement = "element";
      }
      showHover(options, focus) {
        return this.hoverService.showHover({
          ...options,
          hideOnKeyDown: true
        }, focus);
      }
      onDidHideHover() {
        this.lastHoverHideTime = Date.now();
      }
    }(this.configurationService, this.hoverService);
    this.compactEntriesDisposable = this._register(new MutableDisposable());
    this.styleOverrides = /* @__PURE__ */ new Set();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.onDidChangeEntryVisibility(() => this.updateCompactEntries()));
    this._register(this.contextService.onDidChangeWorkbenchState(() => this.updateStyles()));
  }
  addEntry(entry, id, alignment, priorityOrLocation = 0) {
    let priority;
    if (isStatusbarEntryPriority(priorityOrLocation)) {
      priority = priorityOrLocation;
    } else {
      priority = {
        primary: priorityOrLocation,
        secondary: hash(id)
      };
    }
    if (!this.element) {
      return this.doAddPendingEntry(entry, id, alignment, priority);
    }
    return this.doAddEntry(entry, id, alignment, priority);
  }
  doAddPendingEntry(entry, id, alignment, priority) {
    const pendingEntry = { entry, id, alignment, priority };
    this.pendingEntries.push(pendingEntry);
    const accessor = {
      update: (entry2) => {
        if (pendingEntry.accessor) {
          pendingEntry.accessor.update(entry2);
        } else {
          pendingEntry.entry = entry2;
        }
      },
      dispose: () => {
        if (pendingEntry.accessor) {
          pendingEntry.accessor.dispose();
        } else {
          this.pendingEntries = this.pendingEntries.filter((entry2) => entry2 !== pendingEntry);
        }
      }
    };
    return accessor;
  }
  doAddEntry(entry, id, alignment, priority) {
    const itemContainer = this.doCreateStatusItem(id, alignment, ...coalesce([entry.showBeak ? "has-beak" : void 0]));
    const item = this.instantiationService.createInstance(StatusbarEntryItem, itemContainer, entry, this.hoverDelegate);
    const viewModelEntry = new class {
      constructor() {
        this.id = id;
        this.alignment = alignment;
        this.priority = priority;
        this.container = itemContainer;
        this.labelContainer = item.labelContainer;
      }
      get name() {
        return item.name;
      }
      get hasCommand() {
        return item.hasCommand;
      }
    }();
    const { needsFullRefresh } = this.doAddOrRemoveModelEntry(viewModelEntry, true);
    if (needsFullRefresh) {
      this.appendStatusbarEntries();
    } else {
      this.appendStatusbarEntry(viewModelEntry);
    }
    return {
      update: (entry2) => {
        item.update(entry2);
      },
      dispose: () => {
        const { needsFullRefresh: needsFullRefresh2 } = this.doAddOrRemoveModelEntry(viewModelEntry, false);
        if (needsFullRefresh2) {
          this.appendStatusbarEntries();
        } else {
          itemContainer.remove();
        }
        dispose(item);
      }
    };
  }
  doCreateStatusItem(id, alignment, ...extraClasses) {
    const itemContainer = document.createElement("div");
    itemContainer.id = id;
    itemContainer.classList.add("statusbar-item");
    if (extraClasses) {
      itemContainer.classList.add(...extraClasses);
    }
    if (alignment === 1) {
      itemContainer.classList.add("right");
    } else {
      itemContainer.classList.add("left");
    }
    return itemContainer;
  }
  doAddOrRemoveModelEntry(entry, add) {
    const entriesBefore = this.viewModel.entries;
    if (add) {
      this.viewModel.add(entry);
    } else {
      this.viewModel.remove(entry);
    }
    const entriesAfter = this.viewModel.entries;
    if (add) {
      entriesBefore.splice(entriesAfter.indexOf(entry), 0, entry);
    } else {
      entriesBefore.splice(entriesBefore.indexOf(entry), 1);
    }
    const needsFullRefresh = !equals(entriesBefore, entriesAfter);
    return { needsFullRefresh };
  }
  isEntryVisible(id) {
    return !this.viewModel.isHidden(id);
  }
  updateEntryVisibility(id, visible) {
    if (visible) {
      this.viewModel.show(id);
    } else {
      this.viewModel.hide(id);
    }
  }
  focusNextEntry() {
    this.viewModel.focusNextEntry();
  }
  focusPreviousEntry() {
    this.viewModel.focusPreviousEntry();
  }
  isEntryFocused() {
    return this.viewModel.isEntryFocused();
  }
  focus(preserveEntryFocus = true) {
    var _a2;
    (_a2 = this.getContainer()) == null ? void 0 : _a2.focus();
    const lastFocusedEntry = this.viewModel.lastFocusedEntry;
    if (preserveEntryFocus && lastFocusedEntry) {
      setTimeout(() => lastFocusedEntry.labelContainer.focus(), 0);
    }
  }
  createContentArea(parent) {
    this.element = parent;
    const scopedContextKeyService = this.contextKeyService.createScoped(this.element);
    StatusBarFocused.bindTo(scopedContextKeyService).set(true);
    this.leftItemsContainer = document.createElement("div");
    this.leftItemsContainer.classList.add("left-items", "items-container");
    this.element.appendChild(this.leftItemsContainer);
    this.element.tabIndex = 0;
    this.rightItemsContainer = document.createElement("div");
    this.rightItemsContainer.classList.add("right-items", "items-container");
    this.element.appendChild(this.rightItemsContainer);
    this._register(addDisposableListener(parent, EventType.CONTEXT_MENU, (e) => this.showContextMenu(e)));
    this._register(Gesture.addTarget(parent));
    this._register(addDisposableListener(parent, EventType$1.Contextmenu, (e) => this.showContextMenu(e)));
    this.createInitialStatusbarEntries();
    return this.element;
  }
  createInitialStatusbarEntries() {
    this.appendStatusbarEntries();
    while (this.pendingEntries.length) {
      const pending = this.pendingEntries.shift();
      if (pending) {
        pending.accessor = this.addEntry(pending.entry, pending.id, pending.alignment, pending.priority.primary);
      }
    }
  }
  appendStatusbarEntries() {
    const leftItemsContainer = assertIsDefined(this.leftItemsContainer);
    const rightItemsContainer = assertIsDefined(this.rightItemsContainer);
    clearNode(leftItemsContainer);
    clearNode(rightItemsContainer);
    for (const entry of [
      ...this.viewModel.getEntries(0),
      ...this.viewModel.getEntries(1).reverse()
    ]) {
      const target = entry.alignment === 0 ? leftItemsContainer : rightItemsContainer;
      target.appendChild(entry.container);
    }
    this.updateCompactEntries();
  }
  appendStatusbarEntry(entry) {
    const entries = this.viewModel.getEntries(entry.alignment);
    if (entry.alignment === 1) {
      entries.reverse();
    }
    const target = assertIsDefined(entry.alignment === 0 ? this.leftItemsContainer : this.rightItemsContainer);
    const index = entries.indexOf(entry);
    if (index + 1 === entries.length) {
      target.appendChild(entry.container);
    } else {
      target.insertBefore(entry.container, entries[index + 1].container);
    }
    this.updateCompactEntries();
  }
  updateCompactEntries() {
    const entries = this.viewModel.entries;
    const mapIdToVisibleEntry = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      if (!this.viewModel.isHidden(entry.id)) {
        mapIdToVisibleEntry.set(entry.id, entry);
      }
      entry.container.classList.remove("compact-left", "compact-right");
    }
    const compactEntryGroups = /* @__PURE__ */ new Map();
    for (const entry of mapIdToVisibleEntry.values()) {
      if (isStatusbarEntryLocation(entry.priority.primary) && entry.priority.primary.compact) {
        const locationId = entry.priority.primary.id;
        const location = mapIdToVisibleEntry.get(locationId);
        if (!location) {
          continue;
        }
        let compactEntryGroup = compactEntryGroups.get(locationId);
        if (!compactEntryGroup) {
          compactEntryGroup = /* @__PURE__ */ new Set([entry, location]);
          compactEntryGroups.set(locationId, compactEntryGroup);
        } else {
          compactEntryGroup.add(entry);
        }
        if (entry.priority.primary.alignment === 0) {
          location.container.classList.add("compact-left");
          entry.container.classList.add("compact-right");
        } else {
          location.container.classList.add("compact-right");
          entry.container.classList.add("compact-left");
        }
      }
    }
    const statusBarItemHoverBackground = this.getColor(STATUS_BAR_ITEM_HOVER_BACKGROUND);
    const statusBarItemCompactHoverBackground = this.getColor(STATUS_BAR_ITEM_COMPACT_HOVER_BACKGROUND);
    this.compactEntriesDisposable.value = new DisposableStore();
    if (statusBarItemHoverBackground && statusBarItemCompactHoverBackground && !isHighContrast(this.theme.type)) {
      for (const [, compactEntryGroup] of compactEntryGroups) {
        for (const compactEntry of compactEntryGroup) {
          if (!compactEntry.hasCommand) {
            continue;
          }
          this.compactEntriesDisposable.value.add(addDisposableListener(compactEntry.labelContainer, EventType.MOUSE_OVER, () => {
            compactEntryGroup.forEach((compactEntry2) => compactEntry2.labelContainer.style.backgroundColor = statusBarItemHoverBackground);
            compactEntry.labelContainer.style.backgroundColor = statusBarItemCompactHoverBackground;
          }));
          this.compactEntriesDisposable.value.add(addDisposableListener(compactEntry.labelContainer, EventType.MOUSE_OUT, () => {
            compactEntryGroup.forEach((compactEntry2) => compactEntry2.labelContainer.style.backgroundColor = "");
          }));
        }
      }
    }
  }
  showContextMenu(e) {
    EventHelper.stop(e, true);
    const event = new StandardMouseEvent(e);
    let actions = void 0;
    this.contextMenuService.showContextMenu({
      getAnchor: () => event,
      getActions: () => {
        actions = this.getContextMenuActions(event);
        return actions;
      },
      onHide: () => {
        if (actions) {
          disposeIfDisposable(actions);
        }
      }
    });
  }
  getContextMenuActions(event) {
    const actions = [];
    actions.push(toAction({ id: ToggleStatusbarVisibilityAction.ID, label: localize("hideStatusBar", "Hide Status Bar"), run: () => this.instantiationService.invokeFunction((accessor) => new ToggleStatusbarVisibilityAction().run(accessor)) }));
    actions.push(new Separator());
    const handledEntries = /* @__PURE__ */ new Set();
    for (const entry of this.viewModel.entries) {
      if (!handledEntries.has(entry.id)) {
        actions.push(new ToggleStatusbarEntryVisibilityAction(entry.id, entry.name, this.viewModel));
        handledEntries.add(entry.id);
      }
    }
    let statusEntryUnderMouse = void 0;
    for (let element = event.target; element; element = element.parentElement) {
      const entry = this.viewModel.findEntry(element);
      if (entry) {
        statusEntryUnderMouse = entry;
        break;
      }
    }
    if (statusEntryUnderMouse) {
      actions.push(new Separator());
      actions.push(new HideStatusbarEntryAction(statusEntryUnderMouse.id, statusEntryUnderMouse.name, this.viewModel));
    }
    return actions;
  }
  updateStyles() {
    super.updateStyles();
    const container = assertIsDefined(this.getContainer());
    const styleOverride = [...this.styleOverrides].sort((a, b) => a.priority - b.priority)[0];
    const backgroundColor = this.getColor((styleOverride == null ? void 0 : styleOverride.background) ?? (this.contextService.getWorkbenchState() !== 1 ? STATUS_BAR_BACKGROUND : STATUS_BAR_NO_FOLDER_BACKGROUND)) || "";
    container.style.backgroundColor = backgroundColor;
    const foregroundColor = this.getColor((styleOverride == null ? void 0 : styleOverride.foreground) ?? (this.contextService.getWorkbenchState() !== 1 ? STATUS_BAR_FOREGROUND : STATUS_BAR_NO_FOLDER_FOREGROUND)) || "";
    container.style.color = foregroundColor;
    const itemBorderColor = this.getColor(STATUS_BAR_ITEM_FOCUS_BORDER);
    const borderColor = this.getColor((styleOverride == null ? void 0 : styleOverride.border) ?? (this.contextService.getWorkbenchState() !== 1 ? STATUS_BAR_BORDER : STATUS_BAR_NO_FOLDER_BORDER)) || this.getColor(contrastBorder);
    if (borderColor) {
      container.classList.add("status-border-top");
      container.style.setProperty("--status-border-top-color", borderColor);
    } else {
      container.classList.remove("status-border-top");
      container.style.removeProperty("--status-border-top-color");
    }
    const statusBarFocusColor = this.getColor(STATUS_BAR_FOCUS_BORDER);
    if (!this.styleElement) {
      this.styleElement = createStyleSheet(container);
    }
    this.styleElement.textContent = `

				/* Status bar focus outline */
				.monaco-workbench .part.statusbar:focus {
					outline-color: ${statusBarFocusColor};
				}

				/* Status bar item focus outline */
				.monaco-workbench .part.statusbar > .items-container > .statusbar-item a:focus-visible:not(.disabled) {
					outline: 1px solid ${this.getColor(activeContrastBorder) ?? itemBorderColor};
					outline-offset: ${borderColor ? "-2px" : "-1px"};
				}

				/* Notification Beak */
				.monaco-workbench .part.statusbar > .items-container > .statusbar-item.has-beak > .status-bar-item-beak-container:before {
					border-bottom-color: ${backgroundColor};
				}
			`;
  }
  layout(width, height, top, left) {
    super.layout(width, height, top, left);
    super.layoutContents(width, height);
  }
  overrideStyle(style) {
    this.styleOverrides.add(style);
    this.updateStyles();
    return toDisposable(() => {
      this.styleOverrides.delete(style);
      this.updateStyles();
    });
  }
  toJSON() {
    return {
      type: "workbench.parts.statusbar"
    };
  }
};
StatusbarPart = __decorate([
  __param(0, IInstantiationService),
  __param(1, IThemeService),
  __param(2, IWorkspaceContextService),
  __param(3, IStorageService),
  __param(4, IWorkbenchLayoutService),
  __param(5, IContextMenuService),
  __param(6, IContextKeyService),
  __param(7, IHoverService),
  __param(8, IConfigurationService)
], StatusbarPart);
let HistoryService = (_D = class extends Disposable {
  constructor(editorService, editorGroupService, contextService, storageService, configurationService, fileService, workspacesService, instantiationService, layoutService, contextKeyService) {
    super();
    this.editorService = editorService;
    this.editorGroupService = editorGroupService;
    this.contextService = contextService;
    this.storageService = storageService;
    this.configurationService = configurationService;
    this.fileService = fileService;
    this.workspacesService = workspacesService;
    this.instantiationService = instantiationService;
    this.layoutService = layoutService;
    this.contextKeyService = contextKeyService;
    this.activeEditorListeners = this._register(new DisposableStore());
    this.lastActiveEditor = void 0;
    this.editorHelper = this.instantiationService.createInstance(EditorHelper);
    this.canNavigateBackContextKey = new RawContextKey("canNavigateBack", false, localize(
      "canNavigateBack",
      "Whether it is possible to navigate back in editor history"
    )).bindTo(this.contextKeyService);
    this.canNavigateForwardContextKey = new RawContextKey("canNavigateForward", false, localize(
      "canNavigateForward",
      "Whether it is possible to navigate forward in editor history"
    )).bindTo(this.contextKeyService);
    this.canNavigateBackInNavigationsContextKey = new RawContextKey("canNavigateBackInNavigationLocations", false, localize(
      "canNavigateBackInNavigationLocations",
      "Whether it is possible to navigate back in editor navigation locations history"
    )).bindTo(this.contextKeyService);
    this.canNavigateForwardInNavigationsContextKey = new RawContextKey("canNavigateForwardInNavigationLocations", false, localize(
      "canNavigateForwardInNavigationLocations",
      "Whether it is possible to navigate forward in editor navigation locations history"
    )).bindTo(this.contextKeyService);
    this.canNavigateToLastNavigationLocationContextKey = new RawContextKey("canNavigateToLastNavigationLocation", false, localize(
      "canNavigateToLastNavigationLocation",
      "Whether it is possible to navigate to the last editor navigation location"
    )).bindTo(this.contextKeyService);
    this.canNavigateBackInEditsContextKey = new RawContextKey("canNavigateBackInEditLocations", false, localize(
      "canNavigateBackInEditLocations",
      "Whether it is possible to navigate back in editor edit locations history"
    )).bindTo(this.contextKeyService);
    this.canNavigateForwardInEditsContextKey = new RawContextKey("canNavigateForwardInEditLocations", false, localize(
      "canNavigateForwardInEditLocations",
      "Whether it is possible to navigate forward in editor edit locations history"
    )).bindTo(this.contextKeyService);
    this.canNavigateToLastEditLocationContextKey = new RawContextKey("canNavigateToLastEditLocation", false, localize(
      "canNavigateToLastEditLocation",
      "Whether it is possible to navigate to the last editor edit location"
    )).bindTo(this.contextKeyService);
    this.canReopenClosedEditorContextKey = new RawContextKey("canReopenClosedEditor", false, localize(
      "canReopenClosedEditor",
      "Whether it is possible to reopen the last closed editor"
    )).bindTo(this.contextKeyService);
    this._onDidChangeEditorNavigationStack = this._register(new Emitter());
    this.onDidChangeEditorNavigationStack = this._onDidChangeEditorNavigationStack.event;
    this.defaultScopedEditorNavigationStack = void 0;
    this.editorGroupScopedNavigationStacks = /* @__PURE__ */ new Map();
    this.editorScopedNavigationStacks = /* @__PURE__ */ new Map();
    this.editorNavigationScope = 0;
    this.recentlyUsedEditorsStack = void 0;
    this.recentlyUsedEditorsStackIndex = 0;
    this.recentlyUsedEditorsInGroupStack = void 0;
    this.recentlyUsedEditorsInGroupStackIndex = 0;
    this.navigatingInRecentlyUsedEditorsStack = false;
    this.navigatingInRecentlyUsedEditorsInGroupStack = false;
    this.recentlyClosedEditors = [];
    this.ignoreEditorCloseEvent = false;
    this.history = void 0;
    this.editorHistoryListeners = /* @__PURE__ */ new Map();
    this.resourceExcludeMatcher = this._register(new IdleValue(() => {
      const matcher = this._register(this.instantiationService.createInstance(ResourceGlobMatcher, (root) => getExcludes(root ? this.configurationService.getValue({ resource: root }) : this.configurationService.getValue()) || /* @__PURE__ */ Object.create(null), (event) => event.affectsConfiguration(FILES_EXCLUDE_CONFIG) || event.affectsConfiguration(SEARCH_EXCLUDE_CONFIG)));
      this._register(matcher.onExpressionChange(() => this.removeExcludedFromHistory()));
      return matcher;
    }));
    this.registerListeners();
    if (this.editorService.activeEditorPane) {
      this.onDidActiveEditorChange();
    }
  }
  registerListeners() {
    this.registerMouseNavigationListener();
    this._register(this.editorService.onDidActiveEditorChange(() => this.onDidActiveEditorChange()));
    this._register(this.editorService.onDidOpenEditorFail((event) => this.remove(event.editor)));
    this._register(this.editorService.onDidCloseEditor((event) => this.onDidCloseEditor(event)));
    this._register(this.editorService.onDidMostRecentlyActiveEditorsChange(() => this.handleEditorEventInRecentEditorsStack()));
    this._register(this.editorGroupService.onDidRemoveGroup((e) => this.onDidRemoveGroup(e)));
    this._register(this.fileService.onDidFilesChange((event) => this.onDidFilesChange(event)));
    this._register(this.fileService.onDidRunOperation((event) => this.onDidFilesChange(event)));
    this._register(this.storageService.onWillSaveState(() => this.saveState()));
    this.registerEditorNavigationScopeChangeListener();
    this._register(this.onDidChangeEditorNavigationStack(() => this.updateContextKeys()));
    this._register(this.editorGroupService.onDidChangeActiveGroup(() => this.updateContextKeys()));
  }
  onDidCloseEditor(e) {
    this.handleEditorCloseEventInHistory(e);
    this.handleEditorCloseEventInReopen(e);
  }
  registerMouseNavigationListener() {
    const mouseBackForwardSupportListener = this._register(new DisposableStore());
    const handleMouseBackForwardSupport = () => {
      mouseBackForwardSupportListener.clear();
      if (this.configurationService.getValue(_D.MOUSE_NAVIGATION_SETTING)) {
        mouseBackForwardSupportListener.add(addDisposableListener(this.layoutService.container, EventType.MOUSE_DOWN, (e) => this.onMouseDownOrUp(e, true)));
        mouseBackForwardSupportListener.add(addDisposableListener(this.layoutService.container, EventType.MOUSE_UP, (e) => this.onMouseDownOrUp(e, false)));
      }
    };
    this._register(this.configurationService.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration(_D.MOUSE_NAVIGATION_SETTING)) {
        handleMouseBackForwardSupport();
      }
    }));
    handleMouseBackForwardSupport();
  }
  onMouseDownOrUp(event, isMouseDown) {
    switch (event.button) {
      case 3:
        EventHelper.stop(event);
        if (isMouseDown) {
          this.goBack();
        }
        break;
      case 4:
        EventHelper.stop(event);
        if (isMouseDown) {
          this.goForward();
        }
        break;
    }
  }
  onDidRemoveGroup(group) {
    this.handleEditorGroupRemoveInNavigationStacks(group);
  }
  onDidActiveEditorChange() {
    const activeEditorGroup = this.editorGroupService.activeGroup;
    const activeEditorPane = activeEditorGroup.activeEditorPane;
    if (this.lastActiveEditor && this.editorHelper.matchesEditorIdentifier(this.lastActiveEditor, activeEditorPane)) {
      return;
    }
    this.lastActiveEditor = (activeEditorPane == null ? void 0 : activeEditorPane.input) && activeEditorPane.group ? { editor: activeEditorPane.input, groupId: activeEditorPane.group.id } : void 0;
    this.activeEditorListeners.clear();
    this.handleActiveEditorChange(activeEditorGroup, activeEditorPane);
    if (isEditorPaneWithSelection(activeEditorPane)) {
      this.activeEditorListeners.add(activeEditorPane.onDidChangeSelection((e) => this.handleActiveEditorSelectionChangeEvent(activeEditorGroup, activeEditorPane, e)));
    }
    this.updateContextKeys();
  }
  onDidFilesChange(event) {
    if (event instanceof FileChangesEvent) {
      if (event.gotDeleted()) {
        this.remove(event);
      }
    } else {
      if (event.isOperation(1)) {
        this.remove(event);
      } else if (event.isOperation(2) && event.target.isFile) {
        this.move(event);
      }
    }
  }
  handleActiveEditorChange(group, editorPane) {
    this.handleActiveEditorChangeInHistory(editorPane);
    this.handleActiveEditorChangeInNavigationStacks(group, editorPane);
  }
  handleActiveEditorSelectionChangeEvent(group, editorPane, event) {
    this.handleActiveEditorSelectionChangeInNavigationStacks(group, editorPane, event);
  }
  move(event) {
    this.moveInHistory(event);
    this.moveInEditorNavigationStacks(event);
  }
  remove(arg1) {
    this.removeFromHistory(arg1);
    this.removeFromEditorNavigationStacks(arg1);
    this.removeFromRecentlyClosedEditors(arg1);
    this.removeFromRecentlyOpened(arg1);
  }
  removeFromRecentlyOpened(arg1) {
    let resource = void 0;
    if (isEditorInput(arg1)) {
      resource = EditorResourceAccessor.getOriginalUri(arg1);
    } else if (arg1 instanceof FileChangesEvent)
      ;
    else {
      resource = arg1.resource;
    }
    if (resource) {
      this.workspacesService.removeRecentlyOpened([resource]);
    }
  }
  clear() {
    this.clearRecentlyOpened();
    this.clearEditorNavigationStacks();
    this.recentlyClosedEditors = [];
    this.updateContextKeys();
  }
  updateContextKeys() {
    this.contextKeyService.bufferChangeEvents(() => {
      const activeStack = this.getStack();
      this.canNavigateBackContextKey.set(activeStack.canGoBack(0));
      this.canNavigateForwardContextKey.set(activeStack.canGoForward(0));
      this.canNavigateBackInNavigationsContextKey.set(activeStack.canGoBack(2));
      this.canNavigateForwardInNavigationsContextKey.set(activeStack.canGoForward(2));
      this.canNavigateToLastNavigationLocationContextKey.set(activeStack.canGoLast(2));
      this.canNavigateBackInEditsContextKey.set(activeStack.canGoBack(1));
      this.canNavigateForwardInEditsContextKey.set(activeStack.canGoForward(1));
      this.canNavigateToLastEditLocationContextKey.set(activeStack.canGoLast(1));
      this.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);
    });
  }
  registerEditorNavigationScopeChangeListener() {
    const handleEditorNavigationScopeChange = () => {
      this.disposeEditorNavigationStacks();
      const configuredScope = this.configurationService.getValue(_D.NAVIGATION_SCOPE_SETTING);
      if (configuredScope === "editorGroup") {
        this.editorNavigationScope = 1;
      } else if (configuredScope === "editor") {
        this.editorNavigationScope = 2;
      } else {
        this.editorNavigationScope = 0;
      }
    };
    this._register(this.configurationService.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration(_D.NAVIGATION_SCOPE_SETTING)) {
        handleEditorNavigationScopeChange();
      }
    }));
    handleEditorNavigationScopeChange();
  }
  getStack(group = this.editorGroupService.activeGroup, editor = group.activeEditor) {
    var _a2, _b2;
    switch (this.editorNavigationScope) {
      case 2: {
        if (!editor) {
          return new NoOpEditorNavigationStacks();
        }
        let stacksForGroup = this.editorScopedNavigationStacks.get(group.id);
        if (!stacksForGroup) {
          stacksForGroup = /* @__PURE__ */ new Map();
          this.editorScopedNavigationStacks.set(group.id, stacksForGroup);
        }
        let stack = (_a2 = stacksForGroup.get(editor)) == null ? void 0 : _a2.stack;
        if (!stack) {
          const disposable = new DisposableStore();
          stack = disposable.add(this.instantiationService.createInstance(EditorNavigationStacks, 2));
          disposable.add(stack.onDidChange(() => this._onDidChangeEditorNavigationStack.fire()));
          stacksForGroup.set(editor, { stack, disposable });
        }
        return stack;
      }
      case 1: {
        let stack = (_b2 = this.editorGroupScopedNavigationStacks.get(group.id)) == null ? void 0 : _b2.stack;
        if (!stack) {
          const disposable = new DisposableStore();
          stack = disposable.add(this.instantiationService.createInstance(EditorNavigationStacks, 1));
          disposable.add(stack.onDidChange(() => this._onDidChangeEditorNavigationStack.fire()));
          this.editorGroupScopedNavigationStacks.set(group.id, { stack, disposable });
        }
        return stack;
      }
      case 0: {
        if (!this.defaultScopedEditorNavigationStack) {
          this.defaultScopedEditorNavigationStack = this._register(this.instantiationService.createInstance(EditorNavigationStacks, 0));
          this._register(this.defaultScopedEditorNavigationStack.onDidChange(() => this._onDidChangeEditorNavigationStack.fire()));
        }
        return this.defaultScopedEditorNavigationStack;
      }
    }
  }
  goForward(filter) {
    return this.getStack().goForward(filter);
  }
  goBack(filter) {
    return this.getStack().goBack(filter);
  }
  goPrevious(filter) {
    return this.getStack().goPrevious(filter);
  }
  goLast(filter) {
    return this.getStack().goLast(filter);
  }
  handleActiveEditorChangeInNavigationStacks(group, editorPane) {
    this.getStack(group, editorPane == null ? void 0 : editorPane.input).handleActiveEditorChange(editorPane);
  }
  handleActiveEditorSelectionChangeInNavigationStacks(group, editorPane, event) {
    this.getStack(group, editorPane.input).handleActiveEditorSelectionChange(editorPane, event);
  }
  handleEditorCloseEventInHistory(e) {
    const editors = this.editorScopedNavigationStacks.get(e.groupId);
    if (editors) {
      const editorStack = editors.get(e.editor);
      if (editorStack) {
        editorStack.disposable.dispose();
        editors.delete(e.editor);
      }
      if (editors.size === 0) {
        this.editorScopedNavigationStacks.delete(e.groupId);
      }
    }
  }
  handleEditorGroupRemoveInNavigationStacks(group) {
    var _a2;
    (_a2 = this.defaultScopedEditorNavigationStack) == null ? void 0 : _a2.remove(group.id);
    const editorGroupStack = this.editorGroupScopedNavigationStacks.get(group.id);
    if (editorGroupStack) {
      editorGroupStack.disposable.dispose();
      this.editorGroupScopedNavigationStacks.delete(group.id);
    }
  }
  clearEditorNavigationStacks() {
    this.withEachEditorNavigationStack((stack) => stack.clear());
  }
  removeFromEditorNavigationStacks(arg1) {
    this.withEachEditorNavigationStack((stack) => stack.remove(arg1));
  }
  moveInEditorNavigationStacks(event) {
    this.withEachEditorNavigationStack((stack) => stack.move(event));
  }
  withEachEditorNavigationStack(fn) {
    if (this.defaultScopedEditorNavigationStack) {
      fn(this.defaultScopedEditorNavigationStack);
    }
    for (const [, entry] of this.editorGroupScopedNavigationStacks) {
      fn(entry.stack);
    }
    for (const [, entries] of this.editorScopedNavigationStacks) {
      for (const [, entry] of entries) {
        fn(entry.stack);
      }
    }
  }
  disposeEditorNavigationStacks() {
    var _a2;
    (_a2 = this.defaultScopedEditorNavigationStack) == null ? void 0 : _a2.dispose();
    this.defaultScopedEditorNavigationStack = void 0;
    for (const [, stack] of this.editorGroupScopedNavigationStacks) {
      stack.disposable.dispose();
    }
    this.editorGroupScopedNavigationStacks.clear();
    for (const [, stacks] of this.editorScopedNavigationStacks) {
      for (const [, stack] of stacks) {
        stack.disposable.dispose();
      }
    }
    this.editorScopedNavigationStacks.clear();
  }
  openNextRecentlyUsedEditor(groupId) {
    const [stack, index] = this.ensureRecentlyUsedStack((index2) => index2 - 1, groupId);
    return this.doNavigateInRecentlyUsedEditorsStack(stack[index], groupId);
  }
  openPreviouslyUsedEditor(groupId) {
    const [stack, index] = this.ensureRecentlyUsedStack((index2) => index2 + 1, groupId);
    return this.doNavigateInRecentlyUsedEditorsStack(stack[index], groupId);
  }
  async doNavigateInRecentlyUsedEditorsStack(editorIdentifier, groupId) {
    if (editorIdentifier) {
      const acrossGroups = typeof groupId !== "number" || !this.editorGroupService.getGroup(groupId);
      if (acrossGroups) {
        this.navigatingInRecentlyUsedEditorsStack = true;
      } else {
        this.navigatingInRecentlyUsedEditorsInGroupStack = true;
      }
      const group = this.editorGroupService.getGroup(editorIdentifier.groupId) ?? this.editorGroupService.activeGroup;
      try {
        await group.openEditor(editorIdentifier.editor);
      } finally {
        if (acrossGroups) {
          this.navigatingInRecentlyUsedEditorsStack = false;
        } else {
          this.navigatingInRecentlyUsedEditorsInGroupStack = false;
        }
      }
    }
  }
  ensureRecentlyUsedStack(indexModifier, groupId) {
    let editors;
    let index;
    const group = typeof groupId === "number" ? this.editorGroupService.getGroup(groupId) : void 0;
    if (!group) {
      editors = this.recentlyUsedEditorsStack || this.editorService.getEditors(0);
      index = this.recentlyUsedEditorsStackIndex;
    } else {
      editors = this.recentlyUsedEditorsInGroupStack || group.getEditors(0).map((editor) => ({ groupId: group.id, editor }));
      index = this.recentlyUsedEditorsInGroupStackIndex;
    }
    let newIndex = indexModifier(index);
    if (newIndex < 0) {
      newIndex = 0;
    } else if (newIndex > editors.length - 1) {
      newIndex = editors.length - 1;
    }
    if (!group) {
      this.recentlyUsedEditorsStack = editors;
      this.recentlyUsedEditorsStackIndex = newIndex;
    } else {
      this.recentlyUsedEditorsInGroupStack = editors;
      this.recentlyUsedEditorsInGroupStackIndex = newIndex;
    }
    return [editors, newIndex];
  }
  handleEditorEventInRecentEditorsStack() {
    if (!this.navigatingInRecentlyUsedEditorsStack) {
      this.recentlyUsedEditorsStack = void 0;
      this.recentlyUsedEditorsStackIndex = 0;
    }
    if (!this.navigatingInRecentlyUsedEditorsInGroupStack) {
      this.recentlyUsedEditorsInGroupStack = void 0;
      this.recentlyUsedEditorsInGroupStackIndex = 0;
    }
  }
  handleEditorCloseEventInReopen(event) {
    if (this.ignoreEditorCloseEvent) {
      return;
    }
    const { editor, context } = event;
    if (context === EditorCloseContext.REPLACE || context === EditorCloseContext.MOVE) {
      return;
    }
    const untypedEditor = editor.toUntyped();
    if (!untypedEditor) {
      return;
    }
    const associatedResources = [];
    const editorResource = EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.BOTH });
    if (URI.isUri(editorResource)) {
      associatedResources.push(editorResource);
    } else if (editorResource) {
      associatedResources.push(...coalesce([editorResource.primary, editorResource.secondary]));
    }
    this.removeFromRecentlyClosedEditors(editor);
    this.recentlyClosedEditors.push({
      editorId: editor.editorId,
      editor: untypedEditor,
      resource: EditorResourceAccessor.getOriginalUri(editor),
      associatedResources,
      index: event.index,
      sticky: event.sticky
    });
    if (this.recentlyClosedEditors.length > _D.MAX_RECENTLY_CLOSED_EDITORS) {
      this.recentlyClosedEditors.shift();
    }
    this.canReopenClosedEditorContextKey.set(true);
  }
  async reopenLastClosedEditor() {
    const lastClosedEditor = this.recentlyClosedEditors.pop();
    let reopenClosedEditorPromise = void 0;
    if (lastClosedEditor) {
      reopenClosedEditorPromise = this.doReopenLastClosedEditor(lastClosedEditor);
    }
    this.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);
    return reopenClosedEditorPromise;
  }
  async doReopenLastClosedEditor(lastClosedEditor) {
    const options = { pinned: true, sticky: lastClosedEditor.sticky, index: lastClosedEditor.index, ignoreError: true };
    if (lastClosedEditor.sticky && !this.editorGroupService.activeGroup.isSticky(lastClosedEditor.index) || !lastClosedEditor.sticky && this.editorGroupService.activeGroup.isSticky(lastClosedEditor.index)) {
      options.index = void 0;
    }
    let editorPane = void 0;
    if (!this.editorGroupService.activeGroup.contains(lastClosedEditor.editor)) {
      this.ignoreEditorCloseEvent = true;
      try {
        editorPane = await this.editorService.openEditor({
          ...lastClosedEditor.editor,
          options: {
            ...lastClosedEditor.editor.options,
            ...options
          }
        });
      } finally {
        this.ignoreEditorCloseEvent = false;
      }
    }
    if (!editorPane) {
      remove(this.recentlyClosedEditors, lastClosedEditor);
      this.reopenLastClosedEditor();
    }
  }
  removeFromRecentlyClosedEditors(arg1) {
    this.recentlyClosedEditors = this.recentlyClosedEditors.filter((recentlyClosedEditor) => {
      if (isEditorInput(arg1) && recentlyClosedEditor.editorId !== arg1.editorId) {
        return true;
      }
      if (recentlyClosedEditor.resource && this.editorHelper.matchesFile(recentlyClosedEditor.resource, arg1)) {
        return false;
      }
      if (recentlyClosedEditor.associatedResources.some(
        (associatedResource) => this.editorHelper.matchesFile(associatedResource, arg1)
      )) {
        return false;
      }
      return true;
    });
    this.canReopenClosedEditorContextKey.set(this.recentlyClosedEditors.length > 0);
  }
  handleActiveEditorChangeInHistory(editorPane) {
    const editor = editorPane == null ? void 0 : editorPane.input;
    if (!editor || editor.isDisposed() || !this.includeInHistory(editor)) {
      return;
    }
    this.removeFromHistory(editor);
    this.addToHistory(editor);
  }
  addToHistory(editor, insertFirst = true) {
    this.ensureHistoryLoaded(this.history);
    const historyInput = this.editorHelper.preferResourceEditorInput(editor);
    if (!historyInput) {
      return;
    }
    if (insertFirst) {
      this.history.unshift(historyInput);
    } else {
      this.history.push(historyInput);
    }
    if (this.history.length > _D.MAX_HISTORY_ITEMS) {
      this.editorHelper.clearOnEditorDispose(this.history.pop(), this.editorHistoryListeners);
    }
    if (isEditorInput(historyInput)) {
      this.editorHelper.onEditorDispose(historyInput, () => this.updateHistoryOnEditorDispose(historyInput), this.editorHistoryListeners);
    }
  }
  updateHistoryOnEditorDispose(editor) {
    if (!isSideBySideEditorInput(editor)) {
      this.removeFromHistory(editor);
    } else {
      const resourceInputs = [];
      const sideInputs = editor.primary.matches(editor.secondary) ? [editor.primary] : [editor.primary, editor.secondary];
      for (const sideInput of sideInputs) {
        const candidateResourceInput = this.editorHelper.preferResourceEditorInput(sideInput);
        if (isResourceEditorInput(candidateResourceInput)) {
          resourceInputs.push(candidateResourceInput);
        }
      }
      this.replaceInHistory(editor, ...resourceInputs);
    }
  }
  includeInHistory(editor) {
    if (isEditorInput(editor)) {
      return true;
    }
    return !this.resourceExcludeMatcher.value.matches(editor.resource);
  }
  removeExcludedFromHistory() {
    this.ensureHistoryLoaded(this.history);
    this.history = this.history.filter((entry) => {
      const include = this.includeInHistory(entry);
      if (!include) {
        this.editorHelper.clearOnEditorDispose(entry, this.editorHistoryListeners);
      }
      return include;
    });
  }
  moveInHistory(event) {
    if (event.isOperation(2)) {
      const removed = this.removeFromHistory(event);
      if (removed) {
        this.addToHistory({ resource: event.target.resource });
      }
    }
  }
  removeFromHistory(arg1) {
    let removed = false;
    this.ensureHistoryLoaded(this.history);
    this.history = this.history.filter((entry) => {
      const matches = this.editorHelper.matchesEditor(arg1, entry);
      if (matches) {
        this.editorHelper.clearOnEditorDispose(arg1, this.editorHistoryListeners);
        removed = true;
      }
      return !matches;
    });
    return removed;
  }
  replaceInHistory(editor, ...replacements) {
    this.ensureHistoryLoaded(this.history);
    let replaced = false;
    const newHistory = [];
    for (const entry of this.history) {
      if (this.editorHelper.matchesEditor(editor, entry)) {
        this.editorHelper.clearOnEditorDispose(editor, this.editorHistoryListeners);
        if (!replaced) {
          newHistory.push(...replacements);
          replaced = true;
        }
      } else if (!replacements.some((replacement) => this.editorHelper.matchesEditor(replacement, entry))) {
        newHistory.push(entry);
      }
    }
    if (!replaced) {
      newHistory.push(...replacements);
    }
    this.history = newHistory;
  }
  clearRecentlyOpened() {
    this.history = [];
    for (const [, disposable] of this.editorHistoryListeners) {
      dispose(disposable);
    }
    this.editorHistoryListeners.clear();
  }
  getHistory() {
    this.ensureHistoryLoaded(this.history);
    return this.history;
  }
  ensureHistoryLoaded(history) {
    if (!this.history) {
      this.history = [];
      if (this.editorGroupService.isReady) {
        this.loadHistory();
      } else {
        (async () => {
          await this.editorGroupService.whenReady;
          this.loadHistory();
        })();
      }
    }
  }
  loadHistory() {
    var _a2;
    this.history = [];
    const storedEditorHistory = this.loadHistoryFromStorage();
    const openedEditorsLru = [...this.editorService.getEditors(0)].reverse();
    const handledEditors = /* @__PURE__ */ new Set();
    for (const { editor } of openedEditorsLru) {
      if (!this.includeInHistory(editor)) {
        continue;
      }
      this.addToHistory(editor);
      if (editor.resource) {
        handledEditors.add(`${editor.resource.toString()}/${editor.editorId}`);
      }
    }
    for (const editor of storedEditorHistory) {
      if (!handledEditors.has(`${editor.resource.toString()}/${(_a2 = editor.options) == null ? void 0 : _a2.override}`)) {
        this.addToHistory(editor, false);
      }
    }
  }
  loadHistoryFromStorage() {
    const entries = [];
    const entriesRaw = this.storageService.get(_D.HISTORY_STORAGE_KEY, 1);
    if (entriesRaw) {
      try {
        const entriesParsed = JSON.parse(entriesRaw);
        for (const entryParsed of entriesParsed) {
          if (!entryParsed.editor || !entryParsed.editor.resource) {
            continue;
          }
          try {
            entries.push({
              ...entryParsed.editor,
              resource: typeof entryParsed.editor.resource === "string" ? URI.parse(entryParsed.editor.resource) : URI.from(entryParsed.editor.resource)
            });
          } catch (error) {
            onUnexpectedError(error);
          }
        }
      } catch (error) {
        onUnexpectedError(error);
      }
    }
    return entries;
  }
  saveState() {
    if (!this.history) {
      return;
    }
    const entries = [];
    for (const editor of this.history) {
      if (isEditorInput(editor) || !isResourceEditorInput(editor)) {
        continue;
      }
      entries.push({
        editor: {
          ...editor,
          resource: editor.resource.toString()
        }
      });
    }
    this.storageService.store(_D.HISTORY_STORAGE_KEY, JSON.stringify(entries), 1, 1);
  }
  getLastActiveWorkspaceRoot(schemeFilter) {
    const folders = this.contextService.getWorkspace().folders;
    if (folders.length === 0) {
      return void 0;
    }
    if (folders.length === 1) {
      const resource = folders[0].uri;
      if (!schemeFilter || resource.scheme === schemeFilter) {
        return resource;
      }
      return void 0;
    }
    for (const input of this.getHistory()) {
      if (isEditorInput(input)) {
        continue;
      }
      if (schemeFilter && input.resource.scheme !== schemeFilter) {
        continue;
      }
      const resourceWorkspace = this.contextService.getWorkspaceFolder(input.resource);
      if (resourceWorkspace) {
        return resourceWorkspace.uri;
      }
    }
    for (const folder of folders) {
      const resource = folder.uri;
      if (!schemeFilter || resource.scheme === schemeFilter) {
        return resource;
      }
    }
    return void 0;
  }
  getLastActiveFile(filterByScheme) {
    for (const input of this.getHistory()) {
      let resource;
      if (isEditorInput(input)) {
        resource = EditorResourceAccessor.getOriginalUri(input, { filterByScheme });
      } else {
        resource = input.resource;
      }
      if ((resource == null ? void 0 : resource.scheme) === filterByScheme) {
        return resource;
      }
    }
    return void 0;
  }
}, _D.MOUSE_NAVIGATION_SETTING = "workbench.editor.mouseBackForwardToNavigate", _D.NAVIGATION_SCOPE_SETTING = "workbench.editor.navigationScope", _D.MAX_RECENTLY_CLOSED_EDITORS = 20, _D.MAX_HISTORY_ITEMS = 200, _D.HISTORY_STORAGE_KEY = "history.entries", _D);
HistoryService = __decorate([
  __param(0, IEditorService),
  __param(1, IEditorGroupsService),
  __param(2, IWorkspaceContextService),
  __param(3, IStorageService),
  __param(4, IConfigurationService),
  __param(5, IFileService),
  __param(6, IWorkspacesService),
  __param(7, IInstantiationService),
  __param(8, IWorkbenchLayoutService),
  __param(9, IContextKeyService)
], HistoryService);
class EditorSelectionState {
  constructor(editorIdentifier, selection, reason) {
    this.editorIdentifier = editorIdentifier;
    this.selection = selection;
    this.reason = reason;
  }
  justifiesNewNavigationEntry(other) {
    if (this.editorIdentifier.groupId !== other.editorIdentifier.groupId) {
      return true;
    }
    if (!this.editorIdentifier.editor.matches(other.editorIdentifier.editor)) {
      return true;
    }
    if (!this.selection || !other.selection) {
      return true;
    }
    const result = this.selection.compare(other.selection);
    if (result === 2 && (other.reason === 4 || other.reason === 5)) {
      return true;
    }
    return result === 3;
  }
}
let EditorNavigationStacks = class EditorNavigationStacks2 extends Disposable {
  constructor(scope, instantiationService) {
    super();
    this.scope = scope;
    this.instantiationService = instantiationService;
    this.selectionsStack = this._register(this.instantiationService.createInstance(EditorNavigationStack, 0, this.scope));
    this.editsStack = this._register(this.instantiationService.createInstance(EditorNavigationStack, 1, this.scope));
    this.navigationsStack = this._register(this.instantiationService.createInstance(EditorNavigationStack, 2, this.scope));
    this.stacks = [
      this.selectionsStack,
      this.editsStack,
      this.navigationsStack
    ];
    this.onDidChange = Event.any(this.selectionsStack.onDidChange, this.editsStack.onDidChange, this.navigationsStack.onDidChange);
  }
  canGoForward(filter) {
    return this.getStack(filter).canGoForward();
  }
  goForward(filter) {
    return this.getStack(filter).goForward();
  }
  canGoBack(filter) {
    return this.getStack(filter).canGoBack();
  }
  goBack(filter) {
    return this.getStack(filter).goBack();
  }
  goPrevious(filter) {
    return this.getStack(filter).goPrevious();
  }
  canGoLast(filter) {
    return this.getStack(filter).canGoLast();
  }
  goLast(filter) {
    return this.getStack(filter).goLast();
  }
  getStack(filter = 0) {
    switch (filter) {
      case 0:
        return this.selectionsStack;
      case 1:
        return this.editsStack;
      case 2:
        return this.navigationsStack;
    }
  }
  handleActiveEditorChange(editorPane) {
    this.selectionsStack.notifyNavigation(editorPane);
  }
  handleActiveEditorSelectionChange(editorPane, event) {
    const previous = this.selectionsStack.current;
    this.selectionsStack.notifyNavigation(editorPane, event);
    if (event.reason === 3) {
      this.editsStack.notifyNavigation(editorPane, event);
    } else if ((event.reason === 4 || event.reason === 5) && !this.selectionsStack.isNavigating()) {
      if (event.reason === 5 && !this.navigationsStack.isNavigating()) {
        if (previous) {
          this.navigationsStack.addOrReplace(previous.groupId, previous.editor, previous.selection);
        }
      }
      this.navigationsStack.notifyNavigation(editorPane, event);
    }
  }
  clear() {
    for (const stack of this.stacks) {
      stack.clear();
    }
  }
  remove(arg1) {
    for (const stack of this.stacks) {
      stack.remove(arg1);
    }
  }
  move(event) {
    for (const stack of this.stacks) {
      stack.move(event);
    }
  }
};
EditorNavigationStacks = __decorate([
  __param(1, IInstantiationService)
], EditorNavigationStacks);
class NoOpEditorNavigationStacks {
  constructor() {
    this.onDidChange = Event.None;
  }
  canGoForward() {
    return false;
  }
  async goForward() {
  }
  canGoBack() {
    return false;
  }
  async goBack() {
  }
  async goPrevious() {
  }
  canGoLast() {
    return false;
  }
  async goLast() {
  }
  handleActiveEditorChange() {
  }
  handleActiveEditorSelectionChange() {
  }
  clear() {
  }
  remove() {
  }
  move() {
  }
  dispose() {
  }
}
let EditorNavigationStack = (_E = class extends Disposable {
  get current() {
    return this.stack[this.index];
  }
  set current(entry) {
    if (entry) {
      this.stack[this.index] = entry;
    }
  }
  constructor(filter, scope, instantiationService, editorService, editorGroupService, logService) {
    super();
    this.filter = filter;
    this.scope = scope;
    this.instantiationService = instantiationService;
    this.editorService = editorService;
    this.editorGroupService = editorGroupService;
    this.logService = logService;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this.mapEditorToDisposable = /* @__PURE__ */ new Map();
    this.mapGroupToDisposable = /* @__PURE__ */ new Map();
    this.editorHelper = this.instantiationService.createInstance(EditorHelper);
    this.stack = [];
    this.index = -1;
    this.previousIndex = -1;
    this.navigating = false;
    this.currentSelectionState = void 0;
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.onDidChange(() => this.traceStack()));
    this._register(this.logService.onDidChangeLogLevel(() => this.traceStack()));
  }
  traceStack() {
    var _a2, _b2, _c2;
    if (this.logService.getLevel() !== LogLevel.Trace) {
      return;
    }
    const entryLabels = [];
    for (const entry of this.stack) {
      if (typeof ((_a2 = entry.selection) == null ? void 0 : _a2.log) === "function") {
        entryLabels.push(`- group: ${entry.groupId}, editor: ${(_b2 = entry.editor.resource) == null ? void 0 : _b2.toString()}, selection: ${entry.selection.log()}`);
      } else {
        entryLabels.push(`- group: ${entry.groupId}, editor: ${(_c2 = entry.editor.resource) == null ? void 0 : _c2.toString()}, selection: <none>`);
      }
    }
    if (entryLabels.length === 0) {
      this.trace(`index: ${this.index}, navigating: ${this.isNavigating()}: <empty>`);
    } else {
      this.trace(`index: ${this.index}, navigating: ${this.isNavigating()}
${entryLabels.join("\n")}
			`);
    }
  }
  trace(msg, editor = null, event) {
    var _a2;
    if (this.logService.getLevel() !== LogLevel.Trace) {
      return;
    }
    let filterLabel;
    switch (this.filter) {
      case 0:
        filterLabel = "global";
        break;
      case 1:
        filterLabel = "edits";
        break;
      case 2:
        filterLabel = "navigation";
        break;
    }
    let scopeLabel;
    switch (this.scope) {
      case 0:
        scopeLabel = "default";
        break;
      case 1:
        scopeLabel = "editorGroup";
        break;
      case 2:
        scopeLabel = "editor";
        break;
    }
    if (editor !== null) {
      this.logService.trace(`[History stack ${filterLabel}-${scopeLabel}]: ${msg} (editor: ${(_a2 = editor == null ? void 0 : editor.resource) == null ? void 0 : _a2.toString()}, event: ${this.traceEvent(event)})`);
    } else {
      this.logService.trace(`[History stack ${filterLabel}-${scopeLabel}]: ${msg}`);
    }
  }
  traceEvent(event) {
    if (!event) {
      return "<none>";
    }
    switch (event.reason) {
      case 3:
        return "edit";
      case 4:
        return "navigation";
      case 5:
        return "jump";
      case 1:
        return "programmatic";
      case 2:
        return "user";
    }
  }
  registerGroupListeners(groupId) {
    if (!this.mapGroupToDisposable.has(groupId)) {
      const group = this.editorGroupService.getGroup(groupId);
      if (group) {
        this.mapGroupToDisposable.set(groupId, group.onWillMoveEditor((e) => this.onWillMoveEditor(e)));
      }
    }
  }
  onWillMoveEditor(e) {
    this.trace("onWillMoveEditor()", e.editor);
    if (this.scope === 1) {
      return;
    }
    for (const entry of this.stack) {
      if (entry.groupId !== e.groupId) {
        continue;
      }
      if (!this.editorHelper.matchesEditor(e.editor, entry.editor)) {
        continue;
      }
      entry.groupId = e.target;
    }
  }
  notifyNavigation(editorPane, event) {
    this.trace("notifyNavigation()", editorPane == null ? void 0 : editorPane.input, event);
    const isSelectionAwareEditorPane = isEditorPaneWithSelection(editorPane);
    const hasValidEditor = (editorPane == null ? void 0 : editorPane.group) && editorPane.input && !editorPane.input.isDisposed();
    if (this.navigating) {
      this.trace(`notifyNavigation() ignoring (navigating)`, editorPane == null ? void 0 : editorPane.input, event);
      if (isSelectionAwareEditorPane && hasValidEditor) {
        this.trace("notifyNavigation() updating current selection state", editorPane == null ? void 0 : editorPane.input, event);
        this.currentSelectionState = new EditorSelectionState(
          { groupId: editorPane.group.id, editor: editorPane.input },
          editorPane.getSelection(),
          event == null ? void 0 : event.reason
        );
      } else {
        this.trace("notifyNavigation() dropping current selection state", editorPane == null ? void 0 : editorPane.input, event);
        this.currentSelectionState = void 0;
      }
    } else {
      this.trace(`notifyNavigation() not ignoring`, editorPane == null ? void 0 : editorPane.input, event);
      if (isSelectionAwareEditorPane && hasValidEditor) {
        this.onSelectionAwareEditorNavigation(editorPane.group.id, editorPane.input, editorPane.getSelection(), event);
      } else {
        this.currentSelectionState = void 0;
        if (hasValidEditor) {
          this.onNonSelectionAwareEditorNavigation(editorPane.group.id, editorPane.input);
        }
      }
    }
  }
  onSelectionAwareEditorNavigation(groupId, editor, selection, event) {
    var _a2;
    if (((_a2 = this.current) == null ? void 0 : _a2.groupId) === groupId && !selection && this.editorHelper.matchesEditor(this.current.editor, editor)) {
      return;
    }
    this.trace("onSelectionAwareEditorNavigation()", editor, event);
    const stateCandidate = new EditorSelectionState({ groupId, editor }, selection, event == null ? void 0 : event.reason);
    if (!this.currentSelectionState || this.currentSelectionState.justifiesNewNavigationEntry(stateCandidate)) {
      this.doAdd(groupId, editor, stateCandidate.selection);
    } else {
      this.doReplace(groupId, editor, stateCandidate.selection);
    }
    this.currentSelectionState = stateCandidate;
  }
  onNonSelectionAwareEditorNavigation(groupId, editor) {
    var _a2;
    if (((_a2 = this.current) == null ? void 0 : _a2.groupId) === groupId && this.editorHelper.matchesEditor(this.current.editor, editor)) {
      return;
    }
    this.trace("onNonSelectionAwareEditorNavigation()", editor);
    this.doAdd(groupId, editor);
  }
  doAdd(groupId, editor, selection) {
    if (!this.navigating) {
      this.addOrReplace(groupId, editor, selection);
    }
  }
  doReplace(groupId, editor, selection) {
    if (!this.navigating) {
      this.addOrReplace(groupId, editor, selection, true);
    }
  }
  addOrReplace(groupId, editorCandidate, selection, forceReplace) {
    this.registerGroupListeners(groupId);
    let replace = false;
    if (this.current) {
      if (forceReplace) {
        replace = true;
      } else if (this.shouldReplaceStackEntry(this.current, { groupId, editor: editorCandidate, selection })) {
        replace = true;
      }
    }
    const editor = this.editorHelper.preferResourceEditorInput(editorCandidate);
    if (!editor) {
      return;
    }
    if (replace) {
      this.trace("replace()", editor);
    } else {
      this.trace("add()", editor);
    }
    const newStackEntry = { groupId, editor, selection };
    const removedEntries = [];
    if (replace) {
      if (this.current) {
        removedEntries.push(this.current);
      }
      this.current = newStackEntry;
    } else {
      if (this.stack.length > this.index + 1) {
        for (let i = this.index + 1; i < this.stack.length; i++) {
          removedEntries.push(this.stack[i]);
        }
        this.stack = this.stack.slice(0, this.index + 1);
      }
      this.stack.splice(this.index + 1, 0, newStackEntry);
      if (this.stack.length > _E.MAX_STACK_SIZE) {
        removedEntries.push(this.stack.shift());
        if (this.previousIndex >= 0) {
          this.previousIndex--;
        }
      } else {
        this.setIndex(this.index + 1, true);
      }
    }
    for (const removedEntry of removedEntries) {
      this.editorHelper.clearOnEditorDispose(removedEntry.editor, this.mapEditorToDisposable);
    }
    if (isEditorInput(editor)) {
      this.editorHelper.onEditorDispose(editor, () => this.remove(editor), this.mapEditorToDisposable);
    }
    this._onDidChange.fire();
  }
  shouldReplaceStackEntry(entry, candidate) {
    if (entry.groupId !== candidate.groupId) {
      return false;
    }
    if (!this.editorHelper.matchesEditor(entry.editor, candidate.editor)) {
      return false;
    }
    if (!entry.selection) {
      return true;
    }
    if (!candidate.selection) {
      return false;
    }
    return entry.selection.compare(candidate.selection) === 1;
  }
  move(event) {
    if (event.isOperation(2)) {
      for (const entry of this.stack) {
        if (this.editorHelper.matchesEditor(event, entry.editor)) {
          entry.editor = { resource: event.target.resource };
        }
      }
    }
  }
  remove(arg1) {
    var _a2;
    this.stack = this.stack.filter((entry) => {
      const matches = typeof arg1 === "number" ? entry.groupId === arg1 : this.editorHelper.matchesEditor(arg1, entry.editor);
      if (matches) {
        this.editorHelper.clearOnEditorDispose(entry.editor, this.mapEditorToDisposable);
      }
      return !matches;
    });
    this.flatten();
    this.index = this.stack.length - 1;
    this.previousIndex = -1;
    if (typeof arg1 === "number") {
      (_a2 = this.mapGroupToDisposable.get(arg1)) == null ? void 0 : _a2.dispose();
      this.mapGroupToDisposable.delete(arg1);
    }
    this._onDidChange.fire();
  }
  flatten() {
    const flattenedStack = [];
    let previousEntry = void 0;
    for (const entry of this.stack) {
      if (previousEntry && this.shouldReplaceStackEntry(entry, previousEntry)) {
        continue;
      }
      previousEntry = entry;
      flattenedStack.push(entry);
    }
    this.stack = flattenedStack;
  }
  clear() {
    this.index = -1;
    this.previousIndex = -1;
    this.stack.splice(0);
    for (const [, disposable] of this.mapEditorToDisposable) {
      dispose(disposable);
    }
    this.mapEditorToDisposable.clear();
    for (const [, disposable] of this.mapGroupToDisposable) {
      dispose(disposable);
    }
    this.mapGroupToDisposable.clear();
  }
  dispose() {
    super.dispose();
    this.clear();
  }
  canGoForward() {
    return this.stack.length > this.index + 1;
  }
  async goForward() {
    const navigated = await this.maybeGoCurrent();
    if (navigated) {
      return;
    }
    if (!this.canGoForward()) {
      return;
    }
    this.setIndex(this.index + 1);
    return this.navigate();
  }
  canGoBack() {
    return this.index > 0;
  }
  async goBack() {
    const navigated = await this.maybeGoCurrent();
    if (navigated) {
      return;
    }
    if (!this.canGoBack()) {
      return;
    }
    this.setIndex(this.index - 1);
    return this.navigate();
  }
  async goPrevious() {
    const navigated = await this.maybeGoCurrent();
    if (navigated) {
      return;
    }
    if (this.previousIndex === -1) {
      return this.goBack();
    }
    this.setIndex(this.previousIndex);
    return this.navigate();
  }
  canGoLast() {
    return this.stack.length > 0;
  }
  async goLast() {
    if (!this.canGoLast()) {
      return;
    }
    this.setIndex(this.stack.length - 1);
    return this.navigate();
  }
  async maybeGoCurrent() {
    if (this.filter === 0) {
      return false;
    }
    if (this.isCurrentSelectionActive()) {
      return false;
    }
    await this.navigate();
    return true;
  }
  isCurrentSelectionActive() {
    var _a2, _b2;
    if (!((_a2 = this.current) == null ? void 0 : _a2.selection)) {
      return false;
    }
    const pane = this.editorService.activeEditorPane;
    if (!isEditorPaneWithSelection(pane)) {
      return false;
    }
    if (((_b2 = pane.group) == null ? void 0 : _b2.id) !== this.current.groupId) {
      return false;
    }
    if (!pane.input || !this.editorHelper.matchesEditor(pane.input, this.current.editor)) {
      return false;
    }
    const paneSelection = pane.getSelection();
    if (!paneSelection) {
      return false;
    }
    return paneSelection.compare(this.current.selection) === 1;
  }
  setIndex(newIndex, skipEvent) {
    this.previousIndex = this.index;
    this.index = newIndex;
    if (!skipEvent) {
      this._onDidChange.fire();
    }
  }
  async navigate() {
    this.navigating = true;
    try {
      if (this.current) {
        await this.doNavigate(this.current);
      }
    } finally {
      this.navigating = false;
    }
  }
  doNavigate(location) {
    let options = /* @__PURE__ */ Object.create(null);
    if (location.selection) {
      options = location.selection.restore(options);
    }
    if (isEditorInput(location.editor)) {
      return this.editorService.openEditor(location.editor, options, location.groupId);
    }
    return this.editorService.openEditor({
      ...location.editor,
      options: {
        ...location.editor.options,
        ...options
      }
    }, location.groupId);
  }
  isNavigating() {
    return this.navigating;
  }
}, _E.MAX_STACK_SIZE = 50, _E);
EditorNavigationStack = __decorate([
  __param(2, IInstantiationService),
  __param(3, IEditorService),
  __param(4, IEditorGroupsService),
  __param(5, ILogService)
], EditorNavigationStack);
let EditorHelper = class EditorHelper2 {
  constructor(uriIdentityService, lifecycleService, fileService, pathService) {
    this.uriIdentityService = uriIdentityService;
    this.lifecycleService = lifecycleService;
    this.fileService = fileService;
    this.pathService = pathService;
  }
  preferResourceEditorInput(editor) {
    const resource = EditorResourceAccessor.getOriginalUri(editor);
    const hasValidResourceEditorInputScheme = (resource == null ? void 0 : resource.scheme) === Schemas.file || (resource == null ? void 0 : resource.scheme) === Schemas.vscodeRemote || (resource == null ? void 0 : resource.scheme) === Schemas.vscodeUserData || (resource == null ? void 0 : resource.scheme) === this.pathService.defaultUriScheme;
    if (hasValidResourceEditorInputScheme) {
      if (isEditorInput(editor)) {
        const untypedInput = editor.toUntyped();
        if (isResourceEditorInput(untypedInput)) {
          return untypedInput;
        }
      }
      return editor;
    } else {
      return isEditorInput(editor) ? editor : void 0;
    }
  }
  matchesEditor(arg1, inputB) {
    if (arg1 instanceof FileChangesEvent || arg1 instanceof FileOperationEvent) {
      if (isEditorInput(inputB)) {
        return false;
      }
      if (arg1 instanceof FileChangesEvent) {
        return arg1.contains(inputB.resource, 2);
      }
      return this.matchesFile(inputB.resource, arg1);
    }
    if (isEditorInput(arg1)) {
      if (isEditorInput(inputB)) {
        return arg1.matches(inputB);
      }
      return this.matchesFile(inputB.resource, arg1);
    }
    if (isEditorInput(inputB)) {
      return this.matchesFile(arg1.resource, inputB);
    }
    return arg1 && inputB && this.uriIdentityService.extUri.isEqual(arg1.resource, inputB.resource);
  }
  matchesFile(resource, arg2) {
    if (arg2 instanceof FileChangesEvent) {
      return arg2.contains(resource, 2);
    }
    if (arg2 instanceof FileOperationEvent) {
      return this.uriIdentityService.extUri.isEqualOrParent(resource, arg2.resource);
    }
    if (isEditorInput(arg2)) {
      const inputResource = arg2.resource;
      if (!inputResource) {
        return false;
      }
      if (this.lifecycleService.phase >= 3 && !this.fileService.hasProvider(inputResource)) {
        return false;
      }
      return this.uriIdentityService.extUri.isEqual(inputResource, resource);
    }
    return this.uriIdentityService.extUri.isEqual(arg2 == null ? void 0 : arg2.resource, resource);
  }
  matchesEditorIdentifier(identifier, editorPane) {
    if (!(editorPane == null ? void 0 : editorPane.group)) {
      return false;
    }
    if (identifier.groupId !== editorPane.group.id) {
      return false;
    }
    return editorPane.input ? identifier.editor.matches(editorPane.input) : false;
  }
  onEditorDispose(editor, listener, mapEditorToDispose) {
    const toDispose = Event.once(editor.onWillDispose)(() => listener());
    let disposables = mapEditorToDispose.get(editor);
    if (!disposables) {
      disposables = new DisposableStore();
      mapEditorToDispose.set(editor, disposables);
    }
    disposables.add(toDispose);
  }
  clearOnEditorDispose(editor, mapEditorToDispose) {
    if (!isEditorInput(editor)) {
      return;
    }
    const disposables = mapEditorToDispose.get(editor);
    if (disposables) {
      dispose(disposables);
      mapEditorToDispose.delete(editor);
    }
  }
};
EditorHelper = __decorate([
  __param(0, IUriIdentityService),
  __param(1, ILifecycleService),
  __param(2, IFileService),
  __param(3, IPathService)
], EditorHelper);
class OutlineService {
  constructor() {
    this._factories = new LinkedList();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  canCreateOutline(pane) {
    for (const factory of this._factories) {
      if (factory.matches(pane)) {
        return true;
      }
    }
    return false;
  }
  async createOutline(pane, target, token) {
    for (const factory of this._factories) {
      if (factory.matches(pane)) {
        return await factory.createOutline(pane, target, token);
      }
    }
    return void 0;
  }
  registerOutlineCreator(creator) {
    const rm = this._factories.push(creator);
    this._onDidChange.fire();
    return toDisposable(() => {
      rm();
      this._onDidChange.fire();
    });
  }
}
var css$1 = ".webview.modified{box-shadow:-6px 0 5px -5px var(--vscode-scrollbar-shadow)}";
n(css$1, {});
class CustomEditorModelManager {
  constructor() {
    this._references = /* @__PURE__ */ new Map();
  }
  async getAllModels(resource) {
    const keyStart = `${resource.toString()}@@@`;
    const models = [];
    for (const [key, entry] of this._references) {
      if (key.startsWith(keyStart) && entry.model) {
        models.push(await entry.model);
      }
    }
    return models;
  }
  async get(resource, viewType) {
    const key = this.key(resource, viewType);
    const entry = this._references.get(key);
    return entry == null ? void 0 : entry.model;
  }
  tryRetain(resource, viewType) {
    const key = this.key(resource, viewType);
    const entry = this._references.get(key);
    if (!entry) {
      return void 0;
    }
    entry.counter++;
    return entry.model.then((model) => {
      return {
        object: model,
        dispose: once(() => {
          if (--entry.counter <= 0) {
            entry.model.then((x) => x.dispose());
            this._references.delete(key);
          }
        })
      };
    });
  }
  add(resource, viewType, model) {
    const key = this.key(resource, viewType);
    const existing = this._references.get(key);
    if (existing) {
      throw new Error("Model already exists");
    }
    this._references.set(key, { viewType, model, counter: 0 });
    return this.tryRetain(resource, viewType);
  }
  disposeAllModelsForView(viewType) {
    for (const [key, value] of this._references) {
      if (value.viewType === viewType) {
        value.model.then((x) => x.dispose());
        this._references.delete(key);
      }
    }
  }
  key(resource, viewType) {
    return `${resource.toString()}@@@${viewType}`;
  }
}
const Fields = Object.freeze({
  viewType: "viewType",
  displayName: "displayName",
  selector: "selector",
  priority: "priority"
});
const CustomEditorsContribution = {
  description: localize("contributes.customEditors", "Contributed custom editors."),
  type: "array",
  defaultSnippets: [{
    body: [{
      [Fields.viewType]: "$1",
      [Fields.displayName]: "$2",
      [Fields.selector]: [{
        filenamePattern: "$3"
      }]
    }]
  }],
  items: {
    type: "object",
    required: [
      Fields.viewType,
      Fields.displayName,
      Fields.selector
    ],
    properties: {
      [Fields.viewType]: {
        type: "string",
        markdownDescription: localize(
          "contributes.viewType",
          "Identifier for the custom editor. This must be unique across all custom editors, so we recommend including your extension id as part of `viewType`. The `viewType` is used when registering custom editors with `vscode.registerCustomEditorProvider` and in the `onCustomEditor:${id}` [activation event](https://code.visualstudio.com/api/references/activation-events)."
        )
      },
      [Fields.displayName]: {
        type: "string",
        description: localize(
          "contributes.displayName",
          "Human readable name of the custom editor. This is displayed to users when selecting which editor to use."
        )
      },
      [Fields.selector]: {
        type: "array",
        description: localize(
          "contributes.selector",
          "Set of globs that the custom editor is enabled for."
        ),
        items: {
          type: "object",
          defaultSnippets: [{
            body: {
              filenamePattern: "$1"
            }
          }],
          properties: {
            filenamePattern: {
              type: "string",
              description: localize(
                "contributes.selector.filenamePattern",
                "Glob that the custom editor is enabled for."
              )
            }
          }
        }
      },
      [Fields.priority]: {
        type: "string",
        markdownDeprecationMessage: localize(
          "contributes.priority",
          "Controls if the custom editor is enabled automatically when the user opens a file. This may be overridden by users using the `workbench.editorAssociations` setting."
        ),
        enum: [
          "default",
          "option"
        ],
        markdownEnumDescriptions: [
          localize(
            "contributes.priority.default",
            "The editor is automatically used when the user opens a resource, provided that no other default custom editors are registered for that resource."
          ),
          localize(
            "contributes.priority.option",
            "The editor is not automatically used when the user opens a resource, but a user can switch to the editor using the `Reopen With` command."
          )
        ],
        default: "default"
      }
    }
  }
};
const customEditorsExtensionPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "customEditors",
  deps: [languagesExtPoint],
  jsonSchema: CustomEditorsContribution,
  activationEventsGenerator: (contribs, result) => {
    for (const contrib of contribs) {
      const viewType = contrib[Fields.viewType];
      if (viewType) {
        result.push(`onCustomEditor:${viewType}`);
      }
    }
  }
});
const _ContributedCustomEditors = class _ContributedCustomEditors extends Disposable {
  constructor(storageService) {
    super();
    this._editors = /* @__PURE__ */ new Map();
    this._onChange = this._register(new Emitter());
    this.onChange = this._onChange.event;
    this._memento = new Memento(_ContributedCustomEditors.CUSTOM_EDITORS_STORAGE_ID, storageService);
    const mementoObject = this._memento.getMemento(0, 1);
    for (const info of mementoObject[_ContributedCustomEditors.CUSTOM_EDITORS_ENTRY_ID] || []) {
      this.add(new CustomEditorInfo(info));
    }
    customEditorsExtensionPoint.setHandler((extensions) => {
      this.update(extensions);
    });
  }
  update(extensions) {
    this._editors.clear();
    for (const extension of extensions) {
      for (const webviewEditorContribution of extension.value) {
        this.add(new CustomEditorInfo({
          id: webviewEditorContribution.viewType,
          displayName: webviewEditorContribution.displayName,
          providerDisplayName: extension.description.isBuiltin ? localize("builtinProviderDisplayName", "Built-in") : extension.description.displayName || extension.description.identifier.value,
          selector: webviewEditorContribution.selector || [],
          priority: getPriorityFromContribution(webviewEditorContribution, extension.description)
        }));
      }
    }
    const mementoObject = this._memento.getMemento(0, 1);
    mementoObject[_ContributedCustomEditors.CUSTOM_EDITORS_ENTRY_ID] = Array.from(this._editors.values());
    this._memento.saveMemento();
    this._onChange.fire();
  }
  [Symbol.iterator]() {
    return this._editors.values();
  }
  get(viewType) {
    return this._editors.get(viewType);
  }
  getContributedEditors(resource) {
    return Array.from(this._editors.values()).filter((customEditor) => customEditor.matches(resource));
  }
  add(info) {
    if (this._editors.has(info.id)) {
      console.error(`Custom editor with id '${info.id}' already registered`);
      return;
    }
    this._editors.set(info.id, info);
  }
};
_ContributedCustomEditors.CUSTOM_EDITORS_STORAGE_ID = "customEditors";
_ContributedCustomEditors.CUSTOM_EDITORS_ENTRY_ID = "editors";
let ContributedCustomEditors = _ContributedCustomEditors;
function getPriorityFromContribution(contribution, extension) {
  switch (contribution.priority) {
    case RegisteredEditorPriority.default:
    case RegisteredEditorPriority.option:
      return contribution.priority;
    case RegisteredEditorPriority.builtin:
      return extension.isBuiltin ? RegisteredEditorPriority.builtin : RegisteredEditorPriority.default;
    default:
      return RegisteredEditorPriority.default;
  }
}
let CustomEditorService = class CustomEditorService2 extends Disposable {
  constructor(contextKeyService, fileService, storageService, editorService, editorGroupService, instantiationService, uriIdentityService, editorResolverService) {
    super();
    this.editorService = editorService;
    this.editorGroupService = editorGroupService;
    this.instantiationService = instantiationService;
    this.uriIdentityService = uriIdentityService;
    this.editorResolverService = editorResolverService;
    this._untitledCounter = 0;
    this._editorResolverDisposables = this._register(new DisposableStore());
    this._editorCapabilities = /* @__PURE__ */ new Map();
    this._models = new CustomEditorModelManager();
    this._onDidChangeEditorTypes = this._register(new Emitter());
    this.onDidChangeEditorTypes = this._onDidChangeEditorTypes.event;
    this._fileEditorFactory = Registry.as(EditorExtensions.EditorFactory).getFileEditorFactory();
    this._activeCustomEditorId = CONTEXT_ACTIVE_CUSTOM_EDITOR_ID.bindTo(contextKeyService);
    this._focusedCustomEditorIsEditable = CONTEXT_FOCUSED_CUSTOM_EDITOR_IS_EDITABLE.bindTo(contextKeyService);
    this._contributedEditors = this._register(new ContributedCustomEditors(storageService));
    this.editorResolverService.bufferChangeEvents(this.registerContributionPoints.bind(this));
    this._register(this._contributedEditors.onChange(() => {
      this.editorResolverService.bufferChangeEvents(this.registerContributionPoints.bind(this));
      this.updateContexts();
      this._onDidChangeEditorTypes.fire();
    }));
    this._register(this.editorService.onDidActiveEditorChange(() => this.updateContexts()));
    this._register(fileService.onDidRunOperation((e) => {
      if (e.isOperation(2)) {
        this.handleMovedFileInOpenedFileEditors(e.resource, this.uriIdentityService.asCanonicalUri(e.target.resource));
      }
    }));
    const PRIORITY = 105;
    this._register(UndoCommand.addImplementation(PRIORITY, "custom-editor", () => {
      return this.withActiveCustomEditor((editor) => editor.undo());
    }));
    this._register(RedoCommand.addImplementation(PRIORITY, "custom-editor", () => {
      return this.withActiveCustomEditor((editor) => editor.redo());
    }));
    this.updateContexts();
  }
  getEditorTypes() {
    return [...this._contributedEditors];
  }
  withActiveCustomEditor(f) {
    const activeEditor = this.editorService.activeEditor;
    if (activeEditor instanceof CustomEditorInput) {
      const result = f(activeEditor);
      if (result) {
        return result;
      }
      return true;
    }
    return false;
  }
  registerContributionPoints() {
    this._editorResolverDisposables.clear();
    for (const contributedEditor of this._contributedEditors) {
      for (const globPattern of contributedEditor.selector) {
        if (!globPattern.filenamePattern) {
          continue;
        }
        this._editorResolverDisposables.add(this.editorResolverService.registerEditor(globPattern.filenamePattern, {
          id: contributedEditor.id,
          label: contributedEditor.displayName,
          detail: contributedEditor.providerDisplayName,
          priority: contributedEditor.priority
        }, {
          singlePerResource: () => {
            var _a2;
            return !((_a2 = this.getCustomEditorCapabilities(contributedEditor.id)) == null ? void 0 : _a2.supportsMultipleEditorsPerDocument);
          }
        }, {
          createEditorInput: ({ resource }, group) => {
            return { editor: CustomEditorInput.create(this.instantiationService, resource, contributedEditor.id, group.id) };
          },
          createUntitledEditorInput: ({ resource }, group) => {
            return { editor: CustomEditorInput.create(this.instantiationService, resource ?? URI.from(
              { scheme: Schemas.untitled, authority: `Untitled-${this._untitledCounter++}` }
            ), contributedEditor.id, group.id) };
          },
          createDiffEditorInput: (diffEditorInput, group) => {
            return { editor: this.createDiffEditorInput(diffEditorInput, contributedEditor.id, group) };
          }
        }));
      }
    }
  }
  createDiffEditorInput(editor, editorID, group) {
    const modifiedOverride = CustomEditorInput.create(this.instantiationService, assertIsDefined(editor.modified.resource), editorID, group.id, { customClasses: "modified" });
    const originalOverride = CustomEditorInput.create(this.instantiationService, assertIsDefined(editor.original.resource), editorID, group.id, { customClasses: "original" });
    return this.instantiationService.createInstance(DiffEditorInput, editor.label, editor.description, originalOverride, modifiedOverride, true);
  }
  get models() {
    return this._models;
  }
  getCustomEditor(viewType) {
    return this._contributedEditors.get(viewType);
  }
  getContributedCustomEditors(resource) {
    return new CustomEditorInfoCollection(this._contributedEditors.getContributedEditors(resource));
  }
  getUserConfiguredCustomEditors(resource) {
    const resourceAssocations = this.editorResolverService.getAssociationsForResource(resource);
    return new CustomEditorInfoCollection(coalesce(resourceAssocations.map((association) => this._contributedEditors.get(association.viewType))));
  }
  getAllCustomEditors(resource) {
    return new CustomEditorInfoCollection([
      ...this.getUserConfiguredCustomEditors(resource).allEditors,
      ...this.getContributedCustomEditors(resource).allEditors
    ]);
  }
  registerCustomEditorCapabilities(viewType, options) {
    if (this._editorCapabilities.has(viewType)) {
      throw new Error(`Capabilities for ${viewType} already set`);
    }
    this._editorCapabilities.set(viewType, options);
    return toDisposable(() => {
      this._editorCapabilities.delete(viewType);
    });
  }
  getCustomEditorCapabilities(viewType) {
    return this._editorCapabilities.get(viewType);
  }
  updateContexts() {
    var _a2;
    const activeEditorPane = this.editorService.activeEditorPane;
    const resource = (_a2 = activeEditorPane == null ? void 0 : activeEditorPane.input) == null ? void 0 : _a2.resource;
    if (!resource) {
      this._activeCustomEditorId.reset();
      this._focusedCustomEditorIsEditable.reset();
      return;
    }
    this._activeCustomEditorId.set((activeEditorPane == null ? void 0 : activeEditorPane.input) instanceof CustomEditorInput ? activeEditorPane.input.viewType : "");
    this._focusedCustomEditorIsEditable.set((activeEditorPane == null ? void 0 : activeEditorPane.input) instanceof CustomEditorInput);
  }
  async handleMovedFileInOpenedFileEditors(oldResource, newResource) {
    if (extname(oldResource).toLowerCase() === extname(newResource).toLowerCase()) {
      return;
    }
    const possibleEditors = this.getAllCustomEditors(newResource);
    if (!possibleEditors.allEditors.some((editor) => editor.priority !== RegisteredEditorPriority.option)) {
      return;
    }
    const editorsToReplace = /* @__PURE__ */ new Map();
    for (const group of this.editorGroupService.groups) {
      for (const editor of group.editors) {
        if (this._fileEditorFactory.isFileEditor(editor) && !(editor instanceof CustomEditorInput) && isEqual(editor.resource, newResource)) {
          let entry = editorsToReplace.get(group.id);
          if (!entry) {
            entry = [];
            editorsToReplace.set(group.id, entry);
          }
          entry.push(editor);
        }
      }
    }
    if (!editorsToReplace.size) {
      return;
    }
    for (const [group, entries] of editorsToReplace) {
      this.editorService.replaceEditors(entries.map((editor) => {
        let replacement;
        if (possibleEditors.defaultEditor) {
          const viewType = possibleEditors.defaultEditor.id;
          replacement = CustomEditorInput.create(this.instantiationService, newResource, viewType, group);
        } else {
          replacement = { resource: newResource, options: { override: DEFAULT_EDITOR_ASSOCIATION.id } };
        }
        return {
          editor,
          replacement,
          options: {
            preserveFocus: true
          }
        };
      }), group);
    }
  }
};
CustomEditorService = __decorate([
  __param(0, IContextKeyService),
  __param(1, IFileService),
  __param(2, IStorageService),
  __param(3, IEditorService),
  __param(4, IEditorGroupsService),
  __param(5, IInstantiationService),
  __param(6, IUriIdentityService),
  __param(7, IEditorResolverService)
], CustomEditorService);
let WebviewThemeDataProvider = class WebviewThemeDataProvider2 extends Disposable {
  constructor(_themeService, _configurationService) {
    super();
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._cachedWebViewThemeData = void 0;
    this._onThemeDataChanged = this._register(new Emitter());
    this.onThemeDataChanged = this._onThemeDataChanged.event;
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._reset();
    }));
    const webviewConfigurationKeys = ["editor.fontFamily", "editor.fontWeight", "editor.fontSize"];
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (webviewConfigurationKeys.some((key) => e.affectsConfiguration(key))) {
        this._reset();
      }
    }));
  }
  getTheme() {
    return this._themeService.getColorTheme();
  }
  getWebviewThemeData() {
    if (!this._cachedWebViewThemeData) {
      const configuration = this._configurationService.getValue("editor");
      const editorFontFamily = configuration.fontFamily || EDITOR_FONT_DEFAULTS.fontFamily;
      const editorFontWeight = configuration.fontWeight || EDITOR_FONT_DEFAULTS.fontWeight;
      const editorFontSize = configuration.fontSize || EDITOR_FONT_DEFAULTS.fontSize;
      const theme = this._themeService.getColorTheme();
      const exportedColors = getColorRegistry().getColors().reduce((colors, entry) => {
        const color = theme.getColor(entry.id);
        if (color) {
          colors["vscode-" + entry.id.replace(".", "-")] = color.toString();
        }
        return colors;
      }, {});
      const styles = {
        "vscode-font-family": DEFAULT_FONT_FAMILY,
        "vscode-font-weight": "normal",
        "vscode-font-size": "13px",
        "vscode-editor-font-family": editorFontFamily,
        "vscode-editor-font-weight": editorFontWeight,
        "vscode-editor-font-size": editorFontSize + "px",
        ...exportedColors
      };
      const activeTheme = ApiThemeClassName.fromTheme(theme);
      this._cachedWebViewThemeData = { styles, activeTheme, themeLabel: theme.label, themeId: theme.settingsId };
    }
    return this._cachedWebViewThemeData;
  }
  _reset() {
    this._cachedWebViewThemeData = void 0;
    this._onThemeDataChanged.fire();
  }
};
WebviewThemeDataProvider = __decorate([
  __param(0, IWorkbenchThemeService),
  __param(1, IConfigurationService)
], WebviewThemeDataProvider);
var ApiThemeClassName;
(function(ApiThemeClassName2) {
  ApiThemeClassName2["light"] = "vscode-light";
  ApiThemeClassName2["dark"] = "vscode-dark";
  ApiThemeClassName2["highContrast"] = "vscode-high-contrast";
  ApiThemeClassName2["highContrastLight"] = "vscode-high-contrast-light";
})(ApiThemeClassName || (ApiThemeClassName = {}));
(function(ApiThemeClassName2) {
  function fromTheme(theme) {
    switch (theme.type) {
      case ColorScheme.LIGHT:
        return ApiThemeClassName2.light;
      case ColorScheme.DARK:
        return ApiThemeClassName2.dark;
      case ColorScheme.HIGH_CONTRAST_DARK:
        return ApiThemeClassName2.highContrast;
      case ColorScheme.HIGH_CONTRAST_LIGHT:
        return ApiThemeClassName2.highContrastLight;
    }
  }
  ApiThemeClassName2.fromTheme = fromTheme;
})(ApiThemeClassName || (ApiThemeClassName = {}));
class WebviewPortMappingManager {
  constructor(_getExtensionLocation, _getMappings, tunnelService) {
    this._getExtensionLocation = _getExtensionLocation;
    this._getMappings = _getMappings;
    this.tunnelService = tunnelService;
    this._tunnels = /* @__PURE__ */ new Map();
  }
  async getRedirect(resolveAuthority, url) {
    const uri = URI.parse(url);
    const requestLocalHostInfo = extractLocalHostUriMetaDataForPortMapping(uri);
    if (!requestLocalHostInfo) {
      return void 0;
    }
    for (const mapping of this._getMappings()) {
      if (mapping.webviewPort === requestLocalHostInfo.port) {
        const extensionLocation = this._getExtensionLocation();
        if (extensionLocation && extensionLocation.scheme === Schemas.vscodeRemote) {
          const tunnel = resolveAuthority && await this.getOrCreateTunnel(resolveAuthority, mapping.extensionHostPort);
          if (tunnel) {
            if (tunnel.tunnelLocalPort === mapping.webviewPort) {
              return void 0;
            }
            return encodeURI(uri.with({
              authority: `127.0.0.1:${tunnel.tunnelLocalPort}`
            }).toString(true));
          }
        }
        if (mapping.webviewPort !== mapping.extensionHostPort) {
          return encodeURI(uri.with({
            authority: `${requestLocalHostInfo.address}:${mapping.extensionHostPort}`
          }).toString(true));
        }
      }
    }
    return void 0;
  }
  async dispose() {
    for (const tunnel of this._tunnels.values()) {
      await tunnel.dispose();
    }
    this._tunnels.clear();
  }
  async getOrCreateTunnel(remoteAuthority, remotePort) {
    const existing = this._tunnels.get(remotePort);
    if (existing) {
      return existing;
    }
    const tunnel = await this.tunnelService.openTunnel({ getAddress: async () => remoteAuthority }, void 0, remotePort);
    if (tunnel) {
      this._tunnels.set(remotePort, tunnel);
    }
    return tunnel;
  }
}
const webviewMimeTypes = /* @__PURE__ */ new Map([
  [".svg", "image/svg+xml"],
  [".txt", Mimes.text],
  [".css", "text/css"],
  [".js", "application/javascript"],
  [".cjs", "application/javascript"],
  [".mjs", "application/javascript"],
  [".json", "application/json"],
  [".html", "text/html"],
  [".htm", "text/html"],
  [".xhtml", "application/xhtml+xml"],
  [".oft", "font/otf"],
  [".xml", "application/xml"],
  [".wasm", "application/wasm"]
]);
function getWebviewContentMimeType(resource) {
  const ext = extname$1(resource.fsPath).toLowerCase();
  return webviewMimeTypes.get(ext) || getMediaMime(resource.fsPath) || Mimes.unknown;
}
var WebviewResourceResponse;
(function(WebviewResourceResponse2) {
  let Type2;
  (function(Type3) {
    Type3[Type3["Success"] = 0] = "Success";
    Type3[Type3["Failed"] = 1] = "Failed";
    Type3[Type3["AccessDenied"] = 2] = "AccessDenied";
    Type3[Type3["NotModified"] = 3] = "NotModified";
  })(Type2 = WebviewResourceResponse2.Type || (WebviewResourceResponse2.Type = {}));
  class StreamSuccess {
    constructor(stream, etag, mtime, mimeType) {
      this.stream = stream;
      this.etag = etag;
      this.mtime = mtime;
      this.mimeType = mimeType;
      this.type = Type2.Success;
    }
  }
  WebviewResourceResponse2.StreamSuccess = StreamSuccess;
  WebviewResourceResponse2.Failed = { type: Type2.Failed };
  WebviewResourceResponse2.AccessDenied = { type: Type2.AccessDenied };
  class NotModified {
    constructor(mimeType, mtime) {
      this.mimeType = mimeType;
      this.mtime = mtime;
      this.type = Type2.NotModified;
    }
  }
  WebviewResourceResponse2.NotModified = NotModified;
})(WebviewResourceResponse || (WebviewResourceResponse = {}));
async function loadLocalResource(requestUri, options, fileService, logService, token) {
  var _a2;
  logService.debug(`loadLocalResource - begin. requestUri=${requestUri}`);
  const resourceToLoad = getResourceToLoad(requestUri, options.roots);
  logService.debug(`loadLocalResource - found resource to load. requestUri=${requestUri}, resourceToLoad=${resourceToLoad}`);
  if (!resourceToLoad) {
    return WebviewResourceResponse.AccessDenied;
  }
  const mime = getWebviewContentMimeType(requestUri);
  try {
    const result = await fileService.readFileStream(resourceToLoad, { etag: options.ifNoneMatch }, token);
    return new WebviewResourceResponse.StreamSuccess(result.value, result.etag, result.mtime, mime);
  } catch (err) {
    if (err instanceof FileOperationError) {
      const result = err.fileOperationResult;
      if (result === 2) {
        return new WebviewResourceResponse.NotModified(mime, (_a2 = err.options) == null ? void 0 : _a2.mtime);
      }
    }
    logService.debug(`loadLocalResource - Error using fileReader. requestUri=${requestUri}`);
    console.log(err);
    return WebviewResourceResponse.Failed;
  }
}
function getResourceToLoad(requestUri, roots) {
  for (const root of roots) {
    if (containsResource(root, requestUri)) {
      return normalizeResourcePath(requestUri);
    }
  }
  return void 0;
}
function containsResource(root, resource) {
  if (root.scheme !== resource.scheme) {
    return false;
  }
  let resourceFsPath = normalize(resource.fsPath);
  let rootPath = normalize(root.fsPath + (root.fsPath.endsWith(sep) ? "" : sep));
  if (isUNC(root.fsPath) && isUNC(resource.fsPath)) {
    rootPath = rootPath.toLowerCase();
    resourceFsPath = resourceFsPath.toLowerCase();
  }
  return resourceFsPath.startsWith(rootPath);
}
function normalizeResourcePath(resource) {
  if (resource.scheme === Schemas.vscodeRemote) {
    return URI.from({
      scheme: Schemas.vscodeRemote,
      authority: resource.authority,
      path: "/vscode-resource",
      query: JSON.stringify({
        requestResourcePath: resource.path
      })
    });
  }
  return resource;
}
var css = ".monaco-workbench .simple-find-part-wrapper{max-width:calc(100% - 64px);overflow:hidden;padding:0 10px 10px;pointer-events:none;position:absolute;right:18px;top:0;z-index:10}.simple-find-part .monaco-inputbox>.ibwrapper>input{text-overflow:clip}.monaco-workbench .simple-find-part{align-items:center;background-color:var(--vscode-editorWidget-background)!important;border:1px solid var(--vscode-contrastBorder);border-bottom-left-radius:4px;border-bottom-right-radius:4px;box-shadow:0 0 8px 2px var(--vscode-widget-shadow);color:var(--vscode-editorWidget-foreground);display:flex;font-size:12px;padding:4px;pointer-events:all;position:relative;top:-45px;transition:top .2s linear;visibility:hidden;z-index:10}.monaco-workbench.reduce-motion .monaco-editor .find-widget{transition:top 0ms linear}.monaco-workbench .simple-find-part.visible{visibility:visible}.monaco-workbench .simple-find-part.suppress-transition{transition:none}.monaco-workbench .simple-find-part.visible-transition{top:0}.monaco-workbench .simple-find-part .monaco-findInput{flex:1}.monaco-workbench .simple-find-part .matchesCount{max-width:73px;min-width:73px;padding-left:5px;width:73px}.monaco-workbench .simple-find-part.reduced-find-widget .matchesCount{display:none}.monaco-workbench .simple-find-part .button{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:flex;flex:initial;height:20px;justify-content:center;line-height:20px;margin-left:3px;min-width:20px;width:20px}.monaco-workbench div.simple-find-part div.button.disabled{cursor:default;opacity:.3!important}div.simple-find-part-wrapper div.button{border-radius:5px}.no-results.matchesCount{color:var(--vscode-errorForeground)}div.simple-find-part-wrapper div.button:hover:not(.disabled){background-color:var(--vscode-toolbar-hoverBackground);outline:1px dashed var(--vscode-toolbar-hoverOutline);outline-offset:-1px}";
n(css, {});
const NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
const NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find (⇅ for history)");
const NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous Match");
const NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next Match");
const NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
const SIMPLE_FIND_WIDGET_INITIAL_WIDTH = 310;
const MATCHES_COUNT_WIDTH = 73;
class SimpleFindWidget extends Widget {
  constructor(options, contextViewService, contextKeyService, _keybindingService) {
    super();
    this._keybindingService = _keybindingService;
    this._isVisible = false;
    this._foundMatch = false;
    this._width = 0;
    this.state = new FindReplaceState();
    this._matchesLimit = options.matchesLimit ?? Number.MAX_SAFE_INTEGER;
    this._findInput = this._register(new ContextScopedFindInput(null, contextViewService, {
      label: NLS_FIND_INPUT_LABEL,
      placeholder: NLS_FIND_INPUT_PLACEHOLDER,
      validation: (value) => {
        if (value.length === 0 || !this._findInput.getRegex()) {
          return null;
        }
        try {
          return null;
        } catch (e) {
          this._foundMatch = false;
          this.updateButtons(this._foundMatch);
          return { content: e.message };
        }
      },
      showCommonFindToggles: options.showCommonFindToggles,
      appendCaseSensitiveLabel: options.appendCaseSensitiveActionId ? this._getKeybinding(options.appendCaseSensitiveActionId) : void 0,
      appendRegexLabel: options.appendRegexActionId ? this._getKeybinding(options.appendRegexActionId) : void 0,
      appendWholeWordsLabel: options.appendWholeWordsActionId ? this._getKeybinding(options.appendWholeWordsActionId) : void 0,
      showHistoryHint: () => showHistoryKeybindingHint(_keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, contextKeyService));
    this._updateHistoryDelayer = new Delayer(500);
    this._register(this._findInput.onInput(async (e) => {
      if (!options.checkImeCompletionState || !this._findInput.isImeSessionInProgress) {
        this._foundMatch = this._onInputChanged();
        if (options.showResultCount) {
          await this.updateResultCount();
        }
        this.updateButtons(this._foundMatch);
        this.focusFindBox();
        this._delayedUpdateHistory();
      }
    }));
    this._findInput.setRegex(!!this.state.isRegex);
    this._findInput.setCaseSensitive(!!this.state.matchCase);
    this._findInput.setWholeWords(!!this.state.wholeWord);
    this._register(this._findInput.onDidOptionChange(() => {
      this.state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, true);
    }));
    this._register(this.state.onFindReplaceStateChange(() => {
      this._findInput.setRegex(this.state.isRegex);
      this._findInput.setWholeWords(this.state.wholeWord);
      this._findInput.setCaseSensitive(this.state.matchCase);
      this.findFirst();
    }));
    this.prevBtn = this._register(new SimpleButton({
      label: NLS_PREVIOUS_MATCH_BTN_LABEL + (options.previousMatchActionId ? this._getKeybinding(options.previousMatchActionId) : ""),
      icon: findPreviousMatchIcon,
      onTrigger: () => {
        this.find(true);
      }
    }));
    this.nextBtn = this._register(new SimpleButton({
      label: NLS_NEXT_MATCH_BTN_LABEL + (options.nextMatchActionId ? this._getKeybinding(options.nextMatchActionId) : ""),
      icon: findNextMatchIcon,
      onTrigger: () => {
        this.find(false);
      }
    }));
    const closeBtn = this._register(new SimpleButton({
      label: NLS_CLOSE_BTN_LABEL + (options.closeWidgetActionId ? this._getKeybinding(options.closeWidgetActionId) : ""),
      icon: widgetClose,
      onTrigger: () => {
        this.hide();
      }
    }));
    this._innerDomNode = document.createElement("div");
    this._innerDomNode.classList.add("simple-find-part");
    this._innerDomNode.appendChild(this._findInput.domNode);
    this._innerDomNode.appendChild(this.prevBtn.domNode);
    this._innerDomNode.appendChild(this.nextBtn.domNode);
    this._innerDomNode.appendChild(closeBtn.domNode);
    this._domNode = document.createElement("div");
    this._domNode.classList.add("simple-find-part-wrapper");
    this._domNode.appendChild(this._innerDomNode);
    this.onkeyup(this._innerDomNode, (e) => {
      if (e.equals(9)) {
        this.hide();
        e.preventDefault();
        return;
      }
    });
    this._focusTracker = this._register(trackFocus(this._innerDomNode));
    this._register(this._focusTracker.onDidFocus(this._onFocusTrackerFocus.bind(this)));
    this._register(this._focusTracker.onDidBlur(this._onFocusTrackerBlur.bind(this)));
    this._findInputFocusTracker = this._register(trackFocus(this._findInput.domNode));
    this._register(this._findInputFocusTracker.onDidFocus(this._onFindInputFocusTrackerFocus.bind(this)));
    this._register(this._findInputFocusTracker.onDidBlur(this._onFindInputFocusTrackerBlur.bind(this)));
    this._register(addDisposableListener(this._innerDomNode, "click", (event) => {
      event.stopPropagation();
    }));
    if (options == null ? void 0 : options.showResultCount) {
      this._domNode.classList.add("result-count");
      this._matchesCount = document.createElement("div");
      this._matchesCount.className = "matchesCount";
      this._findInput.domNode.insertAdjacentElement("afterend", this._matchesCount);
      this._register(this._findInput.onDidChange(async () => {
        await this.updateResultCount();
      }));
      this._register(this._findInput.onDidOptionChange(async () => {
        this._foundMatch = this._onInputChanged();
        await this.updateResultCount();
        this.focusFindBox();
        this._delayedUpdateHistory();
      }));
    }
  }
  get inputValue() {
    return this._findInput.getValue();
  }
  get focusTracker() {
    return this._focusTracker;
  }
  _getKeybinding(actionId) {
    var _a2;
    const kb = (_a2 = this._keybindingService) == null ? void 0 : _a2.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  dispose() {
    super.dispose();
    if (this._domNode && this._domNode.parentElement) {
      this._domNode.parentElement.removeChild(this._domNode);
    }
  }
  isVisible() {
    return this._isVisible;
  }
  getDomNode() {
    return this._domNode;
  }
  reveal(initialInput, animated = true) {
    if (initialInput) {
      this._findInput.setValue(initialInput);
    }
    if (this._isVisible) {
      this._findInput.select();
      return;
    }
    this._isVisible = true;
    this.updateResultCount();
    this.layout();
    setTimeout(() => {
      this._innerDomNode.classList.toggle("suppress-transition", !animated);
      this._innerDomNode.classList.add("visible", "visible-transition");
      this._innerDomNode.setAttribute("aria-hidden", "false");
      this._findInput.select();
      if (!animated) {
        setTimeout(() => {
          this._innerDomNode.classList.remove("suppress-transition");
        }, 0);
      }
    }, 0);
  }
  show(initialInput) {
    if (initialInput && !this._isVisible) {
      this._findInput.setValue(initialInput);
    }
    this._isVisible = true;
    this.layout();
    setTimeout(() => {
      this._innerDomNode.classList.add("visible", "visible-transition");
      this._innerDomNode.setAttribute("aria-hidden", "false");
    }, 0);
  }
  hide(animated = true) {
    if (this._isVisible) {
      this._innerDomNode.classList.toggle("suppress-transition", !animated);
      this._innerDomNode.classList.remove("visible-transition");
      this._innerDomNode.setAttribute("aria-hidden", "true");
      setTimeout(() => {
        this._isVisible = false;
        this.updateButtons(this._foundMatch);
        this._innerDomNode.classList.remove("visible", "suppress-transition");
      }, animated ? 200 : 0);
    }
  }
  layout(width = this._width) {
    this._width = width;
    if (!this._isVisible) {
      return;
    }
    if (this._matchesCount) {
      let reducedFindWidget = false;
      if (SIMPLE_FIND_WIDGET_INITIAL_WIDTH + MATCHES_COUNT_WIDTH + 28 >= width) {
        reducedFindWidget = true;
      }
      this._innerDomNode.classList.toggle("reduced-find-widget", reducedFindWidget);
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this));
  }
  _updateHistory() {
    this._findInput.inputBox.addToHistory();
  }
  _getRegexValue() {
    return this._findInput.getRegex();
  }
  _getWholeWordValue() {
    return this._findInput.getWholeWords();
  }
  _getCaseSensitiveValue() {
    return this._findInput.getCaseSensitive();
  }
  updateButtons(foundMatch) {
    const hasInput = this.inputValue.length > 0;
    this.prevBtn.setEnabled(this._isVisible && hasInput && foundMatch);
    this.nextBtn.setEnabled(this._isVisible && hasInput && foundMatch);
  }
  focusFindBox() {
    this.nextBtn.focus();
    this._findInput.inputBox.focus();
  }
  async updateResultCount() {
    if (!this._matchesCount) {
      this.updateButtons(this._foundMatch);
      return;
    }
    const count = await this._getResultCount();
    this._matchesCount.innerText = "";
    const showRedOutline = this.inputValue.length > 0 && (count == null ? void 0 : count.resultCount) === 0;
    this._matchesCount.classList.toggle("no-results", showRedOutline);
    let label = "";
    if (count == null ? void 0 : count.resultCount) {
      let matchesCount = String(count.resultCount);
      if (count.resultCount >= this._matchesLimit) {
        matchesCount += "+";
      }
      let matchesPosition = String(count.resultIndex + 1);
      if (matchesPosition === "0") {
        matchesPosition = "?";
      }
      label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
    } else {
      label = NLS_NO_RESULTS;
    }
    status(this._announceSearchResults(label, this.inputValue));
    this._matchesCount.appendChild(document.createTextNode(label));
    this._foundMatch = !!count && count.resultCount > 0;
    this.updateButtons(this._foundMatch);
  }
  changeState(state) {
    this.state.change(state, false);
  }
  _announceSearchResults(label, searchString) {
    if (!searchString) {
      return localize("ariaSearchNoInput", "Enter search input");
    }
    if (label === NLS_NO_RESULTS) {
      return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
    }
    return localize(
      "ariaSearchNoResultWithLineNumNoCurrentMatch",
      "{0} found for '{1}'",
      label,
      searchString
    );
  }
}
let WebviewFindWidget = class WebviewFindWidget2 extends SimpleFindWidget {
  async _getResultCount(dataChanged) {
    return void 0;
  }
  constructor(_delegate, contextViewService, contextKeyService, keybindingService) {
    super({ showCommonFindToggles: false, checkImeCompletionState: _delegate.checkImeCompletionState }, contextViewService, contextKeyService, keybindingService);
    this._delegate = _delegate;
    this._findWidgetFocused = KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_FOCUSED.bindTo(contextKeyService);
    this._register(_delegate.hasFindResult((hasResult) => {
      this.updateButtons(hasResult);
      this.focusFindBox();
    }));
    this._register(_delegate.onDidStopFind(() => {
      this.updateButtons(false);
    }));
  }
  find(previous) {
    const val = this.inputValue;
    if (val) {
      this._delegate.find(val, previous);
    }
  }
  hide(animated = true) {
    super.hide(animated);
    this._delegate.stopFind(true);
    this._delegate.focus();
  }
  _onInputChanged() {
    const val = this.inputValue;
    if (val) {
      this._delegate.updateFind(val);
    } else {
      this._delegate.stopFind(false);
    }
    return false;
  }
  _onFocusTrackerFocus() {
    this._findWidgetFocused.set(true);
  }
  _onFocusTrackerBlur() {
    this._findWidgetFocused.reset();
  }
  _onFindInputFocusTrackerFocus() {
  }
  _onFindInputFocusTrackerBlur() {
  }
  findFirst() {
  }
};
WebviewFindWidget = __decorate([
  __param(1, IContextViewService),
  __param(2, IContextKeyService),
  __param(3, IKeybindingService)
], WebviewFindWidget);
var WebviewState;
(function(WebviewState2) {
  (function(Type2) {
    Type2[Type2["Initializing"] = 0] = "Initializing";
    Type2[Type2["Ready"] = 1] = "Ready";
  })(WebviewState2.Type || (WebviewState2.Type = {}));
  class Initializing {
    constructor(pendingMessages) {
      this.pendingMessages = pendingMessages;
      this.type = 0;
    }
  }
  WebviewState2.Initializing = Initializing;
  WebviewState2.Ready = { type: 1 };
})(WebviewState || (WebviewState = {}));
const webviewIdContext = "webviewId";
let WebviewElement = class WebviewElement2 extends Disposable {
  get platform() {
    return "browser";
  }
  get element() {
    return this._element;
  }
  get isFocused() {
    if (!this._focused) {
      return false;
    }
    if (document.activeElement && document.activeElement !== this.element) {
      return false;
    }
    return true;
  }
  constructor(initInfo, webviewThemeDataProvider, configurationService, contextMenuService, notificationService, _environmentService, _fileService, _logService, _remoteAuthorityResolverService, _telemetryService, _tunnelService, instantiationService, _accessibilityService) {
    super();
    this.webviewThemeDataProvider = webviewThemeDataProvider;
    this._environmentService = _environmentService;
    this._fileService = _fileService;
    this._logService = _logService;
    this._remoteAuthorityResolverService = _remoteAuthorityResolverService;
    this._telemetryService = _telemetryService;
    this._tunnelService = _tunnelService;
    this._accessibilityService = _accessibilityService;
    this.id = generateUuid();
    this._expectedServiceWorkerVersion = 4;
    this._state = new WebviewState.Initializing([]);
    this._resourceLoadingCts = this._register(new CancellationTokenSource());
    this._focusDelayer = this._register(new ThrottledDelayer(50));
    this._onDidHtmlChange = this._register(new Emitter());
    this.onDidHtmlChange = this._onDidHtmlChange.event;
    this._messageHandlers = /* @__PURE__ */ new Map();
    this.checkImeCompletionState = true;
    this._disposed = false;
    this._onMissingCsp = this._register(new Emitter());
    this.onMissingCsp = this._onMissingCsp.event;
    this._onDidClickLink = this._register(new Emitter());
    this.onDidClickLink = this._onDidClickLink.event;
    this._onDidReload = this._register(new Emitter());
    this.onDidReload = this._onDidReload.event;
    this._onMessage = this._register(new Emitter());
    this.onMessage = this._onMessage.event;
    this._onDidScroll = this._register(new Emitter());
    this.onDidScroll = this._onDidScroll.event;
    this._onDidWheel = this._register(new Emitter());
    this.onDidWheel = this._onDidWheel.event;
    this._onDidUpdateState = this._register(new Emitter());
    this.onDidUpdateState = this._onDidUpdateState.event;
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this._onFatalError = this._register(new Emitter());
    this.onFatalError = this._onFatalError.event;
    this._onDidDispose = this._register(new Emitter());
    this.onDidDispose = this._onDidDispose.event;
    this._hasAlertedAboutMissingCsp = false;
    this._hasFindResult = this._register(new Emitter());
    this.hasFindResult = this._hasFindResult.event;
    this._onDidStopFind = this._register(new Emitter());
    this.onDidStopFind = this._onDidStopFind.event;
    this.providedViewType = initInfo.providedViewType;
    this.origin = initInfo.origin ?? this.id;
    this._encodedWebviewOriginPromise = parentOriginHash(window.origin, this.origin).then((id) => this._encodedWebviewOrigin = id);
    this._options = initInfo.options;
    this.extension = initInfo.extension;
    this._content = {
      html: "",
      title: initInfo.title,
      options: initInfo.contentOptions,
      state: void 0
    };
    this._portMappingManager = this._register(new WebviewPortMappingManager(
      () => {
        var _a2;
        return (_a2 = this.extension) == null ? void 0 : _a2.location;
      },
      () => this._content.options.portMapping || [],
      this._tunnelService
    ));
    this._element = this._createElement(initInfo.options, initInfo.contentOptions);
    const subscription = this._register(addDisposableListener(window, "message", (e) => {
      var _a2, _b2;
      if (!this._encodedWebviewOrigin || ((_a2 = e == null ? void 0 : e.data) == null ? void 0 : _a2.target) !== this.id) {
        return;
      }
      if (e.data.channel === "webview-ready") {
        if (this._messagePort) {
          return;
        }
        this._logService.debug(`Webview(${this.id}): webview ready`);
        this._messagePort = e.ports[0];
        this._messagePort.onmessage = (e2) => {
          const handlers = this._messageHandlers.get(e2.data.channel);
          if (!handlers) {
            console.log(`No handlers found for '${e2.data.channel}'`);
            return;
          }
          handlers == null ? void 0 : handlers.forEach((handler) => handler(e2.data.data, e2));
        };
        (_b2 = this.element) == null ? void 0 : _b2.classList.add("ready");
        if (this._state.type === 0) {
          this._state.pendingMessages.forEach(({ channel, data }) => this.doPostMessage(channel, data));
        }
        this._state = WebviewState.Ready;
        subscription.dispose();
      }
    }));
    this._register(this.on("no-csp-found", () => {
      this.handleNoCspFound();
    }));
    this._register(this.on("did-click-link", ({ uri }) => {
      this._onDidClickLink.fire(uri);
    }));
    this._register(this.on("onmessage", ({ message, transfer }) => {
      this._onMessage.fire({ message, transfer });
    }));
    this._register(this.on("did-scroll", ({ scrollYPercentage }) => {
      this._onDidScroll.fire({ scrollYPercentage });
    }));
    this._register(this.on("do-reload", () => {
      this.reload();
    }));
    this._register(this.on("do-update-state", (state) => {
      this.state = state;
      this._onDidUpdateState.fire(state);
    }));
    this._register(this.on("did-focus", () => {
      this.handleFocusChange(true);
    }));
    this._register(this.on("did-blur", () => {
      this.handleFocusChange(false);
    }));
    this._register(this.on("did-scroll-wheel", (event) => {
      this._onDidWheel.fire(event);
    }));
    this._register(this.on("did-find", ({ didFind }) => {
      this._hasFindResult.fire(didFind);
    }));
    this._register(this.on("fatal-error", (e) => {
      notificationService.error(localize("fatalErrorMessage", "Error loading webview: {0}", e.message));
      this._onFatalError.fire({ message: e.message });
    }));
    this._register(this.on("did-keydown", (data) => {
      this.handleKeyEvent("keydown", data);
    }));
    this._register(this.on("did-keyup", (data) => {
      this.handleKeyEvent("keyup", data);
    }));
    this._register(this.on("did-context-menu", (data) => {
      if (!this.element) {
        return;
      }
      if (!this._contextKeyService) {
        return;
      }
      const elementBox = this.element.getBoundingClientRect();
      const contextKeyService = this._contextKeyService.createOverlay([
        ...Object.entries(data.context),
        [webviewIdContext, this.providedViewType]
      ]);
      contextMenuService.showContextMenu({
        menuId: MenuId.WebviewContext,
        menuActionOptions: { shouldForwardArgs: true },
        contextKeyService,
        getActionsContext: () => ({ ...data.context, webview: this.providedViewType }),
        getAnchor: () => ({
          x: elementBox.x + data.clientX,
          y: elementBox.y + data.clientY
        })
      });
    }));
    this._register(this.on("load-resource", async (entry) => {
      try {
        const authority = decodeAuthority(entry.authority);
        const uri = URI.from({
          scheme: entry.scheme,
          authority,
          path: decodeURIComponent(entry.path),
          query: entry.query ? decodeURIComponent(entry.query) : entry.query
        });
        this.loadResource(entry.id, uri, entry.ifNoneMatch);
      } catch (e) {
        this._send("did-load-resource", {
          id: entry.id,
          status: 404,
          path: entry.path
        });
      }
    }));
    this._register(this.on("load-localhost", (entry) => {
      this.localLocalhost(entry.id, entry.origin);
    }));
    this._register(Event.runAndSubscribe(webviewThemeDataProvider.onThemeDataChanged, () => this.style()));
    this._register(_accessibilityService.onDidChangeReducedMotion(() => this.style()));
    this._register(_accessibilityService.onDidChangeScreenReaderOptimized(() => this.style()));
    this._register(contextMenuService.onDidShowContextMenu(() => this._send("set-context-menu-visible", { visible: true })));
    this._register(contextMenuService.onDidHideContextMenu(() => this._send("set-context-menu-visible", { visible: false })));
    this._confirmBeforeClose = configurationService.getValue("window.confirmBeforeClose");
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("window.confirmBeforeClose")) {
        this._confirmBeforeClose = configurationService.getValue("window.confirmBeforeClose");
        this._send("set-confirm-before-close", this._confirmBeforeClose);
      }
    }));
    this._register(this.on("drag-start", () => {
      this._startBlockingIframeDragEvents();
    }));
    if (initInfo.options.enableFindWidget) {
      this._webviewFindWidget = this._register(instantiationService.createInstance(WebviewFindWidget, this));
    }
    this._encodedWebviewOriginPromise.then((encodedWebviewOrigin) => {
      if (!this._disposed) {
        this._initElement(encodedWebviewOrigin, this.extension, this._options);
      }
    });
  }
  dispose() {
    var _a2;
    this._disposed = true;
    (_a2 = this.element) == null ? void 0 : _a2.remove();
    this._element = void 0;
    this._messagePort = void 0;
    if (this._state.type === 0) {
      for (const message of this._state.pendingMessages) {
        message.resolve(false);
      }
      this._state.pendingMessages = [];
    }
    this._onDidDispose.fire();
    this._resourceLoadingCts.dispose(true);
    super.dispose();
  }
  setContextKeyService(contextKeyService) {
    this._contextKeyService = contextKeyService;
  }
  postMessage(message, transfer) {
    return this._send("message", { message, transfer });
  }
  async _send(channel, data, _createElement = []) {
    if (this._state.type === 0) {
      let resolve;
      const promise = new Promise((r) => resolve = r);
      this._state.pendingMessages.push({ channel, data, transferable: _createElement, resolve });
      return promise;
    } else {
      return this.doPostMessage(channel, data, _createElement);
    }
  }
  _createElement(options, _contentOptions) {
    const element = document.createElement("iframe");
    element.name = this.id;
    element.className = `webview ${options.customClasses || ""}`;
    element.sandbox.add("allow-scripts", "allow-same-origin", "allow-forms", "allow-pointer-lock", "allow-downloads");
    const allowRules = ["cross-origin-isolated", "autoplay"];
    if (!isFirefox) {
      allowRules.push("clipboard-read", "clipboard-write");
    }
    element.setAttribute("allow", allowRules.join("; "));
    element.style.border = "none";
    element.style.width = "100%";
    element.style.height = "100%";
    element.focus = () => {
      this._doFocus();
    };
    return element;
  }
  _initElement(encodedWebviewOrigin, extension, options) {
    const params = {
      id: this.id,
      origin: this.origin,
      swVersion: String(this._expectedServiceWorkerVersion),
      extensionId: (extension == null ? void 0 : extension.id.value) ?? "",
      platform: this.platform,
      "vscode-resource-base-authority": webviewRootResourceAuthority,
      parentOrigin: window.origin
    };
    if (this._options.disableServiceWorker) {
      params.disableServiceWorker = "true";
    }
    if (this._environmentService.remoteAuthority) {
      params.remoteAuthority = this._environmentService.remoteAuthority;
    }
    if (options.purpose) {
      params.purpose = options.purpose;
    }
    params.serviceWorkerUri = FileAccess.asBrowserUri("vs/workbench/contrib/webview/browser/pre/service-worker.js").toString(true);
    params.fakeHtmlUri = FileAccess.asBrowserUri("vs/workbench/contrib/webview/browser/pre/fake.html").toString(true);
    COI.addSearchParam(params, true, true);
    const queryString = new URLSearchParams(params).toString();
    const fileName = isFirefox ? "index-no-csp.html" : "index.html";
    const relativeIframeSrc = FileAccess.asBrowserUri(`vs/workbench/contrib/webview/browser/pre/${fileName}`);
    this.element.setAttribute("src", `${relativeIframeSrc.toString(true)}?${queryString}`);
  }
  mountTo(element) {
    if (!this.element) {
      return;
    }
    if (this._webviewFindWidget) {
      element.appendChild(this._webviewFindWidget.getDomNode());
    }
    for (const eventName of [EventType.MOUSE_DOWN, EventType.MOUSE_MOVE, EventType.DROP]) {
      this._register(addDisposableListener(element, eventName, () => {
        this._stopBlockingIframeDragEvents();
      }));
    }
    for (const node of [element, window]) {
      this._register(addDisposableListener(node, EventType.DRAG_END, () => {
        this._stopBlockingIframeDragEvents();
      }));
    }
    element.id = this.id;
    element.appendChild(this.element);
  }
  _startBlockingIframeDragEvents() {
    if (this.element) {
      this.element.style.pointerEvents = "none";
    }
  }
  _stopBlockingIframeDragEvents() {
    if (this.element) {
      this.element.style.pointerEvents = "auto";
    }
  }
  webviewContentEndpoint(encodedWebviewOrigin) {
    const webviewExternalEndpoint = this._environmentService.webviewExternalEndpoint;
    if (!webviewExternalEndpoint) {
      throw new Error(`'webviewExternalEndpoint' has not been configured. Webviews will not work!`);
    }
    const endpoint = webviewExternalEndpoint.replace("{{uuid}}", encodedWebviewOrigin);
    if (endpoint[endpoint.length - 1] === "/") {
      return endpoint.slice(0, endpoint.length - 1);
    }
    return endpoint;
  }
  doPostMessage(channel, data, transferable = []) {
    if (this.element && this._messagePort) {
      this._messagePort.postMessage({ channel, args: data }, transferable);
      return true;
    }
    return false;
  }
  on(channel, handler) {
    let handlers = this._messageHandlers.get(channel);
    if (!handlers) {
      handlers = /* @__PURE__ */ new Set();
      this._messageHandlers.set(channel, handlers);
    }
    handlers.add(handler);
    return toDisposable(() => {
      var _a2;
      (_a2 = this._messageHandlers.get(channel)) == null ? void 0 : _a2.delete(handler);
    });
  }
  handleNoCspFound() {
    var _a2;
    if (this._hasAlertedAboutMissingCsp) {
      return;
    }
    this._hasAlertedAboutMissingCsp = true;
    if ((_a2 = this.extension) == null ? void 0 : _a2.id) {
      if (this._environmentService.isExtensionDevelopment) {
        this._onMissingCsp.fire(this.extension.id);
      }
      const payload = {
        extension: this.extension.id.value
      };
      this._telemetryService.publicLog2("webviewMissingCsp", payload);
    }
  }
  reload() {
    this.doUpdateContent(this._content);
    const subscription = this._register(this.on("did-load", () => {
      this._onDidReload.fire();
      subscription.dispose();
    }));
  }
  setHtml(html) {
    this.doUpdateContent({ ...this._content, html });
    this._onDidHtmlChange.fire(html);
  }
  setTitle(title) {
    this._content = { ...this._content, title };
    this._send("set-title", title);
  }
  set contentOptions(options) {
    this._logService.debug(`Webview(${this.id}): will update content options`);
    if (areWebviewContentOptionsEqual(options, this._content.options)) {
      this._logService.debug(`Webview(${this.id}): skipping content options update`);
      return;
    }
    this.doUpdateContent({ ...this._content, options });
  }
  set localResourcesRoot(resources) {
    this._content = {
      ...this._content,
      options: { ...this._content.options, localResourceRoots: resources }
    };
  }
  set state(state) {
    this._content = { ...this._content, state };
  }
  set initialScrollProgress(value) {
    this._send("initial-scroll-position", value);
  }
  doUpdateContent(newContent) {
    this._logService.debug(`Webview(${this.id}): will update content`);
    this._content = newContent;
    const allowScripts = !!this._content.options.allowScripts;
    this._send("content", {
      contents: this._content.html,
      title: this._content.title,
      options: {
        allowMultipleAPIAcquire: !!this._content.options.allowMultipleAPIAcquire,
        allowScripts,
        allowForms: this._content.options.allowForms ?? allowScripts
      },
      state: this._content.state,
      cspSource: webviewGenericCspSource,
      confirmBeforeClose: this._confirmBeforeClose
    });
  }
  style() {
    let { styles, activeTheme, themeLabel, themeId } = this.webviewThemeDataProvider.getWebviewThemeData();
    if (this._options.transformCssVariables) {
      styles = this._options.transformCssVariables(styles);
    }
    const reduceMotion = this._accessibilityService.isMotionReduced();
    const screenReader = this._accessibilityService.isScreenReaderOptimized();
    this._send("styles", { styles, activeTheme, themeId, themeLabel, reduceMotion, screenReader });
  }
  handleFocusChange(isFocused) {
    this._focused = isFocused;
    if (isFocused) {
      this._onDidFocus.fire();
    } else {
      this._onDidBlur.fire();
    }
  }
  handleKeyEvent(type, event) {
    const emulatedKeyboardEvent = new KeyboardEvent(type, event);
    Object.defineProperty(emulatedKeyboardEvent, "target", {
      get: () => this.element
    });
    window.dispatchEvent(emulatedKeyboardEvent);
  }
  windowDidDragStart() {
    this._startBlockingIframeDragEvents();
  }
  windowDidDragEnd() {
    this._stopBlockingIframeDragEvents();
  }
  selectAll() {
    this.execCommand("selectAll");
  }
  copy() {
    this.execCommand("copy");
  }
  paste() {
    this.execCommand("paste");
  }
  cut() {
    this.execCommand("cut");
  }
  undo() {
    this.execCommand("undo");
  }
  redo() {
    this.execCommand("redo");
  }
  execCommand(command) {
    if (this.element) {
      this._send("execCommand", command);
    }
  }
  async loadResource(id, uri, ifNoneMatch) {
    try {
      const result = await loadLocalResource(uri, {
        ifNoneMatch,
        roots: this._content.options.localResourceRoots || []
      }, this._fileService, this._logService, this._resourceLoadingCts.token);
      switch (result.type) {
        case WebviewResourceResponse.Type.Success: {
          const buffer = await this.streamToBuffer(result.stream);
          return this._send("did-load-resource", {
            id,
            status: 200,
            path: uri.path,
            mime: result.mimeType,
            data: buffer,
            etag: result.etag,
            mtime: result.mtime
          }, [buffer]);
        }
        case WebviewResourceResponse.Type.NotModified: {
          return this._send("did-load-resource", {
            id,
            status: 304,
            path: uri.path,
            mime: result.mimeType,
            mtime: result.mtime
          });
        }
        case WebviewResourceResponse.Type.AccessDenied: {
          return this._send("did-load-resource", {
            id,
            status: 401,
            path: uri.path
          });
        }
      }
    } catch {
    }
    return this._send("did-load-resource", {
      id,
      status: 404,
      path: uri.path
    });
  }
  async streamToBuffer(stream) {
    const vsBuffer = await streamToBuffer(stream);
    return vsBuffer.buffer.buffer;
  }
  async localLocalhost(id, origin) {
    const authority = this._environmentService.remoteAuthority;
    const resolveAuthority = authority ? await this._remoteAuthorityResolverService.resolveAuthority(authority) : void 0;
    const redirect = resolveAuthority ? await this._portMappingManager.getRedirect(resolveAuthority.authority, origin) : void 0;
    return this._send("did-load-localhost", {
      id,
      origin,
      location: redirect
    });
  }
  focus() {
    this._doFocus();
    this.handleFocusChange(true);
  }
  _doFocus() {
    var _a2;
    if (!this.element) {
      return;
    }
    try {
      (_a2 = this.element.contentWindow) == null ? void 0 : _a2.focus();
    } catch {
    }
    this._focusDelayer.trigger(async () => {
      var _a3;
      if (!this.isFocused || !this.element) {
        return;
      }
      if (document.activeElement && document.activeElement !== this.element && ((_a3 = document.activeElement) == null ? void 0 : _a3.tagName) !== "BODY") {
        return;
      }
      this._send("focus", void 0);
    });
  }
  find(value, previous) {
    if (!this.element) {
      return;
    }
    this._send("find", { value, previous });
  }
  updateFind(value) {
    if (!value || !this.element) {
      return;
    }
    this._send("find", { value });
  }
  stopFind(keepSelection) {
    if (!this.element) {
      return;
    }
    this._send("find-stop", { clearSelection: !keepSelection });
    this._onDidStopFind.fire();
  }
  showFind(animated = true) {
    var _a2;
    (_a2 = this._webviewFindWidget) == null ? void 0 : _a2.reveal(void 0, animated);
  }
  hideFind(animated = true) {
    var _a2;
    (_a2 = this._webviewFindWidget) == null ? void 0 : _a2.hide(animated);
  }
  runFindAction(previous) {
    var _a2;
    (_a2 = this._webviewFindWidget) == null ? void 0 : _a2.find(previous);
  }
};
WebviewElement = __decorate([
  __param(2, IConfigurationService),
  __param(3, IContextMenuService),
  __param(4, INotificationService),
  __param(5, IWorkbenchEnvironmentService),
  __param(6, IFileService),
  __param(7, ILogService),
  __param(8, IRemoteAuthorityResolverService),
  __param(9, ITelemetryService),
  __param(10, ITunnelService),
  __param(11, IInstantiationService),
  __param(12, IAccessibilityService)
], WebviewElement);
let OverlayWebview = class OverlayWebview2 extends Disposable {
  constructor(initInfo, _layoutService, _webviewService, _baseContextKeyService) {
    super();
    this._layoutService = _layoutService;
    this._webviewService = _webviewService;
    this._baseContextKeyService = _baseContextKeyService;
    this._isFirstLoad = true;
    this._firstLoadPendingMessages = /* @__PURE__ */ new Set();
    this._webview = this._register(new MutableDisposable());
    this._webviewEvents = this._register(new DisposableStore());
    this._html = "";
    this._initialScrollProgress = 0;
    this._state = void 0;
    this._owner = void 0;
    this._scopedContextKeyService = this._register(new MutableDisposable());
    this._shouldShowFindWidgetOnRestore = false;
    this._isDisposed = false;
    this._onDidDispose = this._register(new Emitter());
    this.onDidDispose = this._onDidDispose.event;
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this._onDidClickLink = this._register(new Emitter());
    this.onDidClickLink = this._onDidClickLink.event;
    this._onDidReload = this._register(new Emitter());
    this.onDidReload = this._onDidReload.event;
    this._onDidScroll = this._register(new Emitter());
    this.onDidScroll = this._onDidScroll.event;
    this._onDidUpdateState = this._register(new Emitter());
    this.onDidUpdateState = this._onDidUpdateState.event;
    this._onMessage = this._register(new Emitter());
    this.onMessage = this._onMessage.event;
    this._onMissingCsp = this._register(new Emitter());
    this.onMissingCsp = this._onMissingCsp.event;
    this._onDidWheel = this._register(new Emitter());
    this.onDidWheel = this._onDidWheel.event;
    this._onFatalError = this._register(new Emitter());
    this.onFatalError = this._onFatalError.event;
    this.providedViewType = initInfo.providedViewType;
    this.origin = initInfo.origin ?? generateUuid();
    this._title = initInfo.title;
    this._extension = initInfo.extension;
    this._options = initInfo.options;
    this._contentOptions = initInfo.contentOptions;
  }
  get isFocused() {
    var _a2;
    return !!((_a2 = this._webview.value) == null ? void 0 : _a2.isFocused);
  }
  dispose() {
    var _a2;
    this._isDisposed = true;
    (_a2 = this._container) == null ? void 0 : _a2.domNode.remove();
    this._container = void 0;
    for (const msg of this._firstLoadPendingMessages) {
      msg.resolve(false);
    }
    this._firstLoadPendingMessages.clear();
    this._onDidDispose.fire();
    super.dispose();
  }
  get container() {
    if (this._isDisposed) {
      throw new Error(`OverlayWebview has been disposed`);
    }
    if (!this._container) {
      const node = document.createElement("div");
      node.style.position = "absolute";
      node.style.overflow = "hidden";
      this._container = new FastDomNode(node);
      this._container.setVisibility("hidden");
      this._layoutService.container.appendChild(node);
    }
    return this._container.domNode;
  }
  claim(owner, scopedContextKeyService) {
    var _a2, _b2, _c2, _d2;
    if (this._isDisposed) {
      return;
    }
    const oldOwner = this._owner;
    this._owner = owner;
    this._show();
    if (oldOwner !== owner) {
      const contextKeyService = scopedContextKeyService || this._baseContextKeyService;
      this._scopedContextKeyService.clear();
      this._scopedContextKeyService.value = contextKeyService.createScoped(this.container);
      const wasFindVisible = (_a2 = this._findWidgetVisible) == null ? void 0 : _a2.get();
      (_b2 = this._findWidgetVisible) == null ? void 0 : _b2.reset();
      this._findWidgetVisible = KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
      this._findWidgetVisible.set(!!wasFindVisible);
      (_c2 = this._findWidgetEnabled) == null ? void 0 : _c2.reset();
      this._findWidgetEnabled = KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_ENABLED.bindTo(contextKeyService);
      this._findWidgetEnabled.set(!!this.options.enableFindWidget);
      (_d2 = this._webview.value) == null ? void 0 : _d2.setContextKeyService(this._scopedContextKeyService.value);
    }
  }
  release(owner) {
    var _a2;
    if (this._owner !== owner) {
      return;
    }
    this._scopedContextKeyService.clear();
    this._owner = void 0;
    if (this._container) {
      this._container.setVisibility("hidden");
    }
    if (this._options.retainContextWhenHidden) {
      this._shouldShowFindWidgetOnRestore = !!((_a2 = this._findWidgetVisible) == null ? void 0 : _a2.get());
      this.hideFind(false);
    } else {
      this._webview.clear();
      this._webviewEvents.clear();
    }
  }
  layoutWebviewOverElement(element, dimension, clippingContainer) {
    if (!this._container || !this._container.domNode.parentElement) {
      return;
    }
    const frameRect = element.getBoundingClientRect();
    const containerRect = this._container.domNode.parentElement.getBoundingClientRect();
    const parentBorderTop = (containerRect.height - this._container.domNode.parentElement.clientHeight) / 2;
    const parentBorderLeft = (containerRect.width - this._container.domNode.parentElement.clientWidth) / 2;
    this._container.setTop(frameRect.top - containerRect.top - parentBorderTop);
    this._container.setLeft(frameRect.left - containerRect.left - parentBorderLeft);
    this._container.setWidth(dimension ? dimension.width : frameRect.width);
    this._container.setHeight(dimension ? dimension.height : frameRect.height);
    if (clippingContainer) {
      const { top, left, right, bottom } = computeClippingRect(frameRect, clippingContainer);
      this._container.domNode.style.clipPath = `polygon(${left}px ${top}px, ${right}px ${top}px, ${right}px ${bottom}px, ${left}px ${bottom}px)`;
    }
  }
  _show() {
    var _a2, _b2;
    if (this._isDisposed) {
      throw new Error("OverlayWebview is disposed");
    }
    if (!this._webview.value) {
      const webview = this._webviewService.createWebviewElement({
        providedViewType: this.providedViewType,
        origin: this.origin,
        title: this._title,
        options: this._options,
        contentOptions: this._contentOptions,
        extension: this.extension
      });
      this._webview.value = webview;
      webview.state = this._state;
      if (this._scopedContextKeyService.value) {
        this._webview.value.setContextKeyService(this._scopedContextKeyService.value);
      }
      if (this._html) {
        webview.setHtml(this._html);
      }
      if (this._options.tryRestoreScrollPosition) {
        webview.initialScrollProgress = this._initialScrollProgress;
      }
      (_a2 = this._findWidgetEnabled) == null ? void 0 : _a2.set(!!this.options.enableFindWidget);
      webview.mountTo(this.container);
      this._webviewEvents.clear();
      this._webviewEvents.add(webview.onDidFocus(() => {
        this._onDidFocus.fire();
      }));
      this._webviewEvents.add(webview.onDidBlur(() => {
        this._onDidBlur.fire();
      }));
      this._webviewEvents.add(webview.onDidClickLink((x) => {
        this._onDidClickLink.fire(x);
      }));
      this._webviewEvents.add(webview.onMessage((x) => {
        this._onMessage.fire(x);
      }));
      this._webviewEvents.add(webview.onMissingCsp((x) => {
        this._onMissingCsp.fire(x);
      }));
      this._webviewEvents.add(webview.onDidWheel((x) => {
        this._onDidWheel.fire(x);
      }));
      this._webviewEvents.add(webview.onDidReload(() => {
        this._onDidReload.fire();
      }));
      this._webviewEvents.add(webview.onFatalError((x) => {
        this._onFatalError.fire(x);
      }));
      this._webviewEvents.add(webview.onDidScroll((x) => {
        this._initialScrollProgress = x.scrollYPercentage;
        this._onDidScroll.fire(x);
      }));
      this._webviewEvents.add(webview.onDidUpdateState((state) => {
        this._state = state;
        this._onDidUpdateState.fire(state);
      }));
      if (this._isFirstLoad) {
        this._firstLoadPendingMessages.forEach(async (msg) => {
          msg.resolve(await webview.postMessage(msg.message, msg.transfer));
        });
      }
      this._isFirstLoad = false;
      this._firstLoadPendingMessages.clear();
    }
    if (this.options.retainContextWhenHidden && this._shouldShowFindWidgetOnRestore) {
      this.showFind(false);
      this._shouldShowFindWidgetOnRestore = false;
    }
    (_b2 = this._container) == null ? void 0 : _b2.setVisibility("visible");
  }
  setHtml(html) {
    this._html = html;
    this._withWebview((webview) => webview.setHtml(html));
  }
  setTitle(title) {
    this._title = title;
    this._withWebview((webview) => webview.setTitle(title));
  }
  get initialScrollProgress() {
    return this._initialScrollProgress;
  }
  set initialScrollProgress(value) {
    this._initialScrollProgress = value;
    this._withWebview((webview) => webview.initialScrollProgress = value);
  }
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
    this._withWebview((webview) => webview.state = value);
  }
  get extension() {
    return this._extension;
  }
  set extension(value) {
    this._extension = value;
    this._withWebview((webview) => webview.extension = value);
  }
  get options() {
    return this._options;
  }
  set options(value) {
    this._options = { customClasses: this._options.customClasses, ...value };
  }
  get contentOptions() {
    return this._contentOptions;
  }
  set contentOptions(value) {
    this._contentOptions = value;
    this._withWebview((webview) => webview.contentOptions = value);
  }
  set localResourcesRoot(resources) {
    this._withWebview((webview) => webview.localResourcesRoot = resources);
  }
  async postMessage(message, transfer) {
    if (this._webview.value) {
      return this._webview.value.postMessage(message, transfer);
    }
    if (this._isFirstLoad) {
      let resolve;
      const p = new Promise((r) => resolve = r);
      this._firstLoadPendingMessages.add({ message, transfer, resolve });
      return p;
    }
    return false;
  }
  focus() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.focus();
  }
  reload() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.reload();
  }
  selectAll() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.selectAll();
  }
  copy() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.copy();
  }
  paste() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.paste();
  }
  cut() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.cut();
  }
  undo() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.undo();
  }
  redo() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.redo();
  }
  showFind(animated = true) {
    var _a2;
    if (this._webview.value) {
      this._webview.value.showFind(animated);
      (_a2 = this._findWidgetVisible) == null ? void 0 : _a2.set(true);
    }
  }
  hideFind(animated = true) {
    var _a2, _b2;
    (_a2 = this._findWidgetVisible) == null ? void 0 : _a2.reset();
    (_b2 = this._webview.value) == null ? void 0 : _b2.hideFind(animated);
  }
  runFindAction(previous) {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.runFindAction(previous);
  }
  _withWebview(f) {
    if (this._webview.value) {
      f(this._webview.value);
    }
  }
  windowDidDragStart() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.windowDidDragStart();
  }
  windowDidDragEnd() {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.windowDidDragEnd();
  }
  setContextKeyService(contextKeyService) {
    var _a2;
    (_a2 = this._webview.value) == null ? void 0 : _a2.setContextKeyService(contextKeyService);
  }
};
OverlayWebview = __decorate([
  __param(1, ILayoutService),
  __param(2, IWebviewService),
  __param(3, IContextKeyService)
], OverlayWebview);
function computeClippingRect(frameRect, clipper) {
  const rootRect = clipper.getBoundingClientRect();
  const top = Math.max(rootRect.top - frameRect.top, 0);
  const right = Math.max(frameRect.width - (frameRect.right - rootRect.right), 0);
  const bottom = Math.max(frameRect.height - (frameRect.bottom - rootRect.bottom), 0);
  const left = Math.max(rootRect.left - frameRect.left, 0);
  return { top, right, bottom, left };
}
let WebviewService = class WebviewService2 extends Disposable {
  constructor(_instantiationService) {
    super();
    this._instantiationService = _instantiationService;
    this._webviews = /* @__PURE__ */ new Set();
    this._onDidChangeActiveWebview = this._register(new Emitter());
    this.onDidChangeActiveWebview = this._onDidChangeActiveWebview.event;
    this._webviewThemeDataProvider = this._instantiationService.createInstance(WebviewThemeDataProvider);
  }
  get activeWebview() {
    return this._activeWebview;
  }
  _updateActiveWebview(value) {
    if (value !== this._activeWebview) {
      this._activeWebview = value;
      this._onDidChangeActiveWebview.fire(value);
    }
  }
  get webviews() {
    return this._webviews.values();
  }
  createWebviewElement(initInfo) {
    const webview = this._instantiationService.createInstance(WebviewElement, initInfo, this._webviewThemeDataProvider);
    this.registerNewWebview(webview);
    return webview;
  }
  createWebviewOverlay(initInfo) {
    const webview = this._instantiationService.createInstance(OverlayWebview, initInfo);
    this.registerNewWebview(webview);
    return webview;
  }
  registerNewWebview(webview) {
    this._webviews.add(webview);
    webview.onDidFocus(() => {
      this._updateActiveWebview(webview);
    });
    const onBlur = () => {
      if (this._activeWebview === webview) {
        this._updateActiveWebview(void 0);
      }
    };
    webview.onDidBlur(onBlur);
    webview.onDidDispose(() => {
      onBlur();
      this._webviews.delete(webview);
    });
  }
};
WebviewService = __decorate([
  __param(0, IInstantiationService)
], WebviewService);
class Noop {
  constructor() {
    this.uris = [];
  }
  async perform() {
    return this;
  }
  toString() {
    return "(noop)";
  }
}
class RenameEdit {
  constructor(newUri, oldUri, options) {
    this.newUri = newUri;
    this.oldUri = oldUri;
    this.options = options;
    this.type = "rename";
  }
}
let RenameOperation = class RenameOperation2 {
  constructor(_edits, _undoRedoInfo, _workingCopyFileService, _fileService) {
    this._edits = _edits;
    this._undoRedoInfo = _undoRedoInfo;
    this._workingCopyFileService = _workingCopyFileService;
    this._fileService = _fileService;
  }
  get uris() {
    return this._edits.map((edit) => [edit.newUri, edit.oldUri]).flat();
  }
  async perform(token) {
    const moves = [];
    const undoes = [];
    for (const edit of this._edits) {
      const skip = edit.options.overwrite === void 0 && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri);
      if (!skip) {
        moves.push({
          file: { source: edit.oldUri, target: edit.newUri },
          overwrite: edit.options.overwrite
        });
        undoes.push(new RenameEdit(edit.oldUri, edit.newUri, edit.options));
      }
    }
    if (moves.length === 0) {
      return new Noop();
    }
    await this._workingCopyFileService.move(moves, token, this._undoRedoInfo);
    return new RenameOperation2(
      undoes,
      { isUndoing: true },
      this._workingCopyFileService,
      this._fileService
    );
  }
  toString() {
    return `(rename ${this._edits.map((edit) => `${edit.oldUri} to ${edit.newUri}`).join(", ")})`;
  }
};
RenameOperation = __decorate([
  __param(2, IWorkingCopyFileService),
  __param(3, IFileService)
], RenameOperation);
class CopyEdit {
  constructor(newUri, oldUri, options) {
    this.newUri = newUri;
    this.oldUri = oldUri;
    this.options = options;
    this.type = "copy";
  }
}
let CopyOperation = class CopyOperation2 {
  constructor(_edits, _undoRedoInfo, _workingCopyFileService, _fileService, _instaService) {
    this._edits = _edits;
    this._undoRedoInfo = _undoRedoInfo;
    this._workingCopyFileService = _workingCopyFileService;
    this._fileService = _fileService;
    this._instaService = _instaService;
  }
  get uris() {
    return this._edits.map((edit) => [edit.newUri, edit.oldUri]).flat();
  }
  async perform(token) {
    const copies = [];
    for (const edit of this._edits) {
      const skip = edit.options.overwrite === void 0 && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri);
      if (!skip) {
        copies.push({ file: { source: edit.oldUri, target: edit.newUri }, overwrite: edit.options.overwrite });
      }
    }
    if (copies.length === 0) {
      return new Noop();
    }
    const stats = await this._workingCopyFileService.copy(copies, token, this._undoRedoInfo);
    const undoes = [];
    for (let i = 0; i < stats.length; i++) {
      const stat = stats[i];
      const edit = this._edits[i];
      undoes.push(new DeleteEdit(
        stat.resource,
        { recursive: true, folder: this._edits[i].options.folder || stat.isDirectory, ...edit.options },
        false
      ));
    }
    return this._instaService.createInstance(DeleteOperation, undoes, { isUndoing: true });
  }
  toString() {
    return `(copy ${this._edits.map((edit) => `${edit.oldUri} to ${edit.newUri}`).join(", ")})`;
  }
};
CopyOperation = __decorate([
  __param(2, IWorkingCopyFileService),
  __param(3, IFileService),
  __param(4, IInstantiationService)
], CopyOperation);
class CreateEdit {
  constructor(newUri, options, contents) {
    this.newUri = newUri;
    this.options = options;
    this.contents = contents;
    this.type = "create";
  }
}
let CreateOperation = class CreateOperation2 {
  constructor(_edits, _undoRedoInfo, _fileService, _workingCopyFileService, _instaService, _textFileService) {
    this._edits = _edits;
    this._undoRedoInfo = _undoRedoInfo;
    this._fileService = _fileService;
    this._workingCopyFileService = _workingCopyFileService;
    this._instaService = _instaService;
    this._textFileService = _textFileService;
  }
  get uris() {
    return this._edits.map((edit) => edit.newUri);
  }
  async perform(token) {
    const folderCreates = [];
    const fileCreates = [];
    const undoes = [];
    for (const edit of this._edits) {
      if (edit.options.overwrite === void 0 && edit.options.ignoreIfExists && await this._fileService.exists(edit.newUri)) {
        continue;
      }
      if (edit.options.folder) {
        folderCreates.push({ resource: edit.newUri });
      } else {
        const encodedReadable = typeof edit.contents !== "undefined" ? edit.contents : await this._textFileService.getEncodedReadable(edit.newUri);
        fileCreates.push({ resource: edit.newUri, contents: encodedReadable, overwrite: edit.options.overwrite });
      }
      undoes.push(new DeleteEdit(edit.newUri, edit.options, !edit.options.folder && !edit.contents));
    }
    if (folderCreates.length === 0 && fileCreates.length === 0) {
      return new Noop();
    }
    await this._workingCopyFileService.createFolder(folderCreates, token, this._undoRedoInfo);
    await this._workingCopyFileService.create(fileCreates, token, this._undoRedoInfo);
    return this._instaService.createInstance(DeleteOperation, undoes, { isUndoing: true });
  }
  toString() {
    return `(create ${this._edits.map(
      (edit) => {
        var _a2;
        return edit.options.folder ? `folder ${edit.newUri}` : `file ${edit.newUri} with ${((_a2 = edit.contents) == null ? void 0 : _a2.byteLength) || 0} bytes`;
      }
    ).join(", ")})`;
  }
};
CreateOperation = __decorate([
  __param(2, IFileService),
  __param(3, IWorkingCopyFileService),
  __param(4, IInstantiationService),
  __param(5, ITextFileService)
], CreateOperation);
class DeleteEdit {
  constructor(oldUri, options, undoesCreate) {
    this.oldUri = oldUri;
    this.options = options;
    this.undoesCreate = undoesCreate;
    this.type = "delete";
  }
}
let DeleteOperation = class DeleteOperation2 {
  constructor(_edits, _undoRedoInfo, _workingCopyFileService, _fileService, _configurationService, _instaService, _logService) {
    this._edits = _edits;
    this._undoRedoInfo = _undoRedoInfo;
    this._workingCopyFileService = _workingCopyFileService;
    this._fileService = _fileService;
    this._configurationService = _configurationService;
    this._instaService = _instaService;
    this._logService = _logService;
  }
  get uris() {
    return this._edits.map((edit) => edit.oldUri);
  }
  async perform(token) {
    const deletes = [];
    const undoes = [];
    for (const edit of this._edits) {
      let fileStat;
      try {
        fileStat = await this._fileService.resolve(edit.oldUri, { resolveMetadata: true });
      } catch (err) {
        if (!edit.options.ignoreIfNotExists) {
          throw new Error(`${edit.oldUri} does not exist and can not be deleted`);
        }
        continue;
      }
      deletes.push({
        resource: edit.oldUri,
        recursive: edit.options.recursive,
        useTrash: !edit.options.skipTrashBin && this._fileService.hasCapability(edit.oldUri, 4096) && this._configurationService.getValue("files.enableTrash")
      });
      let fileContent;
      if (!edit.undoesCreate && !edit.options.folder && !(typeof edit.options.maxSize === "number" && fileStat.size > edit.options.maxSize)) {
        try {
          fileContent = await this._fileService.readFile(edit.oldUri);
        } catch (err) {
          this._logService.error(err);
        }
      }
      if (fileContent !== void 0) {
        undoes.push(new CreateEdit(edit.oldUri, edit.options, fileContent.value));
      }
    }
    if (deletes.length === 0) {
      return new Noop();
    }
    await this._workingCopyFileService.delete(deletes, token, this._undoRedoInfo);
    if (undoes.length === 0) {
      return new Noop();
    }
    return this._instaService.createInstance(CreateOperation, undoes, { isUndoing: true });
  }
  toString() {
    return `(delete ${this._edits.map((edit) => edit.oldUri).join(", ")})`;
  }
};
DeleteOperation = __decorate([
  __param(2, IWorkingCopyFileService),
  __param(3, IFileService),
  __param(4, IConfigurationService),
  __param(5, IInstantiationService),
  __param(6, ILogService)
], DeleteOperation);
class FileUndoRedoElement {
  constructor(label, code, operations, confirmBeforeUndo) {
    this.label = label;
    this.code = code;
    this.operations = operations;
    this.confirmBeforeUndo = confirmBeforeUndo;
    this.type = 1;
    this.resources = operations.map((op) => op.uris).flat();
  }
  async undo() {
    await this._reverse();
  }
  async redo() {
    await this._reverse();
  }
  async _reverse() {
    for (let i = 0; i < this.operations.length; i++) {
      const op = this.operations[i];
      const undo = await op.perform(CancellationToken.None);
      this.operations[i] = undo;
    }
  }
  toString() {
    return this.operations.map((op) => String(op)).join(", ");
  }
}
let BulkFileEdits = class BulkFileEdits2 {
  constructor(_label, _code, _undoRedoGroup, _undoRedoSource, _confirmBeforeUndo, _progress, _token, _edits, _instaService, _undoRedoService) {
    this._label = _label;
    this._code = _code;
    this._undoRedoGroup = _undoRedoGroup;
    this._undoRedoSource = _undoRedoSource;
    this._confirmBeforeUndo = _confirmBeforeUndo;
    this._progress = _progress;
    this._token = _token;
    this._edits = _edits;
    this._instaService = _instaService;
    this._undoRedoService = _undoRedoService;
  }
  async apply() {
    var _a2, _b2;
    const undoOperations = [];
    const undoRedoInfo = { undoRedoGroupId: this._undoRedoGroup.id };
    const edits = [];
    for (const edit of this._edits) {
      if (edit.newResource && edit.oldResource && !((_a2 = edit.options) == null ? void 0 : _a2.copy)) {
        edits.push(new RenameEdit(edit.newResource, edit.oldResource, edit.options ?? {}));
      } else if (edit.newResource && edit.oldResource && ((_b2 = edit.options) == null ? void 0 : _b2.copy)) {
        edits.push(new CopyEdit(edit.newResource, edit.oldResource, edit.options ?? {}));
      } else if (!edit.newResource && edit.oldResource) {
        edits.push(new DeleteEdit(edit.oldResource, edit.options ?? {}, false));
      } else if (edit.newResource && !edit.oldResource) {
        edits.push(new CreateEdit(edit.newResource, edit.options ?? {}, await edit.options.contents));
      }
    }
    if (edits.length === 0) {
      return [];
    }
    const groups = [];
    groups[0] = [edits[0]];
    for (let i = 1; i < edits.length; i++) {
      const edit = edits[i];
      const lastGroup = tail(groups);
      if (lastGroup[0].type === edit.type) {
        lastGroup.push(edit);
      } else {
        groups.push([edit]);
      }
    }
    for (const group of groups) {
      if (this._token.isCancellationRequested) {
        break;
      }
      let op;
      switch (group[0].type) {
        case "rename":
          op = this._instaService.createInstance(RenameOperation, group, undoRedoInfo);
          break;
        case "copy":
          op = this._instaService.createInstance(CopyOperation, group, undoRedoInfo);
          break;
        case "delete":
          op = this._instaService.createInstance(DeleteOperation, group, undoRedoInfo);
          break;
        case "create":
          op = this._instaService.createInstance(CreateOperation, group, undoRedoInfo);
          break;
      }
      if (op) {
        const undoOp = await op.perform(this._token);
        undoOperations.push(undoOp);
      }
      this._progress.report(void 0);
    }
    const undoRedoElement = new FileUndoRedoElement(this._label, this._code, undoOperations, this._confirmBeforeUndo);
    this._undoRedoService.pushElement(undoRedoElement, this._undoRedoGroup, this._undoRedoSource);
    return undoRedoElement.resources;
  }
};
BulkFileEdits = __decorate([
  __param(8, IInstantiationService),
  __param(9, IUndoRedoService)
], BulkFileEdits);
class ModelEditTask {
  constructor(_modelReference) {
    this._modelReference = _modelReference;
    this.model = this._modelReference.object.textEditorModel;
    this._edits = [];
  }
  dispose() {
    this._modelReference.dispose();
  }
  isNoOp() {
    if (this._edits.length > 0) {
      return false;
    }
    if (this._newEol !== void 0 && this._newEol !== this.model.getEndOfLineSequence()) {
      return false;
    }
    return true;
  }
  addEdit(resourceEdit) {
    this._expectedModelVersionId = resourceEdit.versionId;
    const { textEdit } = resourceEdit;
    if (typeof textEdit.eol === "number") {
      this._newEol = textEdit.eol;
    }
    if (!textEdit.range && !textEdit.text) {
      return;
    }
    if (Range.isEmpty(textEdit.range) && !textEdit.text) {
      return;
    }
    let range2;
    if (!textEdit.range) {
      range2 = this.model.getFullModelRange();
    } else {
      range2 = Range.lift(textEdit.range);
    }
    this._edits.push({ ...EditOperation.replaceMove(range2, textEdit.text), insertAsSnippet: textEdit.insertAsSnippet });
  }
  validate() {
    if (typeof this._expectedModelVersionId === "undefined" || this.model.getVersionId() === this._expectedModelVersionId) {
      return { canApply: true };
    }
    return { canApply: false, reason: this.model.uri };
  }
  getBeforeCursorState() {
    return null;
  }
  apply() {
    if (this._edits.length > 0) {
      this._edits = this._edits.map(this._transformSnippetStringToInsertText, this).sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
      this.model.pushEditOperations(null, this._edits, () => null);
    }
    if (this._newEol !== void 0) {
      this.model.pushEOL(this._newEol);
    }
  }
  _transformSnippetStringToInsertText(edit) {
    if (!edit.insertAsSnippet) {
      return edit;
    }
    if (!edit.text) {
      return edit;
    }
    const text = SnippetParser.asInsertText(edit.text);
    return { ...edit, insertAsSnippet: false, text };
  }
}
class EditorEditTask extends ModelEditTask {
  constructor(modelReference, editor) {
    super(modelReference);
    this._editor = editor;
  }
  getBeforeCursorState() {
    return this._canUseEditor() ? this._editor.getSelections() : null;
  }
  apply() {
    if (!this._canUseEditor()) {
      super.apply();
      return;
    }
    if (this._edits.length > 0) {
      const snippetCtrl = SnippetController2.get(this._editor);
      if (snippetCtrl && this._edits.some((edit) => edit.insertAsSnippet)) {
        const snippetEdits = [];
        for (const edit of this._edits) {
          if (edit.range && edit.text !== null) {
            snippetEdits.push({
              range: Range.lift(edit.range),
              template: edit.insertAsSnippet ? edit.text : SnippetParser.escape(edit.text)
            });
          }
        }
        snippetCtrl.apply(snippetEdits, { undoStopBefore: false, undoStopAfter: false });
      } else {
        this._edits = this._edits.map(this._transformSnippetStringToInsertText, this).sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
        this._editor.executeEdits("", this._edits);
      }
    }
    if (this._newEol !== void 0) {
      if (this._editor.hasModel()) {
        this._editor.getModel().pushEOL(this._newEol);
      }
    }
  }
  _canUseEditor() {
    var _a2, _b2;
    return ((_b2 = (_a2 = this._editor) == null ? void 0 : _a2.getModel()) == null ? void 0 : _b2.uri.toString()) === this.model.uri.toString();
  }
}
let BulkTextEdits = class BulkTextEdits2 {
  constructor(_label, _code, _editor, _undoRedoGroup, _undoRedoSource, _progress, _token, edits, _editorWorker, _modelService, _textModelResolverService, _undoRedoService) {
    this._label = _label;
    this._code = _code;
    this._editor = _editor;
    this._undoRedoGroup = _undoRedoGroup;
    this._undoRedoSource = _undoRedoSource;
    this._progress = _progress;
    this._token = _token;
    this._editorWorker = _editorWorker;
    this._modelService = _modelService;
    this._textModelResolverService = _textModelResolverService;
    this._undoRedoService = _undoRedoService;
    this._edits = new ResourceMap();
    for (const edit of edits) {
      let array = this._edits.get(edit.resource);
      if (!array) {
        array = [];
        this._edits.set(edit.resource, array);
      }
      array.push(edit);
    }
  }
  _validateBeforePrepare() {
    for (const array of this._edits.values()) {
      for (const edit of array) {
        if (typeof edit.versionId === "number") {
          const model = this._modelService.getModel(edit.resource);
          if (model && model.getVersionId() !== edit.versionId) {
            throw new Error(`${model.uri.toString()} has changed in the meantime`);
          }
        }
      }
    }
  }
  async _createEditsTasks() {
    const tasks = [];
    const promises = [];
    for (const [key, value] of this._edits) {
      const promise = this._textModelResolverService.createModelReference(key).then(async (ref) => {
        var _a2, _b2;
        let task;
        let makeMinimal = false;
        if (((_b2 = (_a2 = this._editor) == null ? void 0 : _a2.getModel()) == null ? void 0 : _b2.uri.toString()) === ref.object.textEditorModel.uri.toString()) {
          task = new EditorEditTask(ref, this._editor);
          makeMinimal = true;
        } else {
          task = new ModelEditTask(ref);
        }
        for (const edit of value) {
          if (makeMinimal && !edit.textEdit.insertAsSnippet) {
            const newEdits = await this._editorWorker.computeMoreMinimalEdits(edit.resource, [edit.textEdit]);
            if (!newEdits) {
              task.addEdit(edit);
            } else {
              for (const moreMinialEdit of newEdits) {
                task.addEdit(new ResourceTextEdit(edit.resource, moreMinialEdit, edit.versionId, edit.metadata));
              }
            }
          } else {
            task.addEdit(edit);
          }
        }
        tasks.push(task);
      });
      promises.push(promise);
    }
    await Promise.all(promises);
    return tasks;
  }
  _validateTasks(tasks) {
    for (const task of tasks) {
      const result = task.validate();
      if (!result.canApply) {
        return result;
      }
    }
    return { canApply: true };
  }
  async apply() {
    this._validateBeforePrepare();
    const tasks = await this._createEditsTasks();
    try {
      if (this._token.isCancellationRequested) {
        return [];
      }
      const resources = [];
      const validation = this._validateTasks(tasks);
      if (!validation.canApply) {
        throw new Error(`${validation.reason.toString()} has changed in the meantime`);
      }
      if (tasks.length === 1) {
        const task = tasks[0];
        if (!task.isNoOp()) {
          const singleModelEditStackElement = new SingleModelEditStackElement(this._label, this._code, task.model, task.getBeforeCursorState());
          this._undoRedoService.pushElement(singleModelEditStackElement, this._undoRedoGroup, this._undoRedoSource);
          task.apply();
          singleModelEditStackElement.close();
          resources.push(task.model.uri);
        }
        this._progress.report(void 0);
      } else {
        const multiModelEditStackElement = new MultiModelEditStackElement(this._label, this._code, tasks.map((t) => new SingleModelEditStackElement(this._label, this._code, t.model, t.getBeforeCursorState())));
        this._undoRedoService.pushElement(multiModelEditStackElement, this._undoRedoGroup, this._undoRedoSource);
        for (const task of tasks) {
          task.apply();
          this._progress.report(void 0);
          resources.push(task.model.uri);
        }
        multiModelEditStackElement.close();
      }
      return resources;
    } finally {
      dispose(tasks);
    }
  }
};
BulkTextEdits = __decorate([
  __param(8, IEditorWorkerService),
  __param(9, IModelService),
  __param(10, ITextModelService),
  __param(11, IUndoRedoService)
], BulkTextEdits);
function liftEdits(edits) {
  return edits.map((edit) => {
    if (ResourceTextEdit.is(edit)) {
      return ResourceTextEdit.lift(edit);
    }
    if (ResourceFileEdit.is(edit)) {
      return ResourceFileEdit.lift(edit);
    }
    if (ResourceNotebookCellEdit.is(edit)) {
      return ResourceNotebookCellEdit.lift(edit);
    }
    throw new Error("Unsupported edit");
  });
}
let BulkEdit = class BulkEdit2 {
  constructor(_label, _code, _editor, _progress, _token, _edits, _undoRedoGroup, _undoRedoSource, _confirmBeforeUndo, _instaService, _logService) {
    this._label = _label;
    this._code = _code;
    this._editor = _editor;
    this._progress = _progress;
    this._token = _token;
    this._edits = _edits;
    this._undoRedoGroup = _undoRedoGroup;
    this._undoRedoSource = _undoRedoSource;
    this._confirmBeforeUndo = _confirmBeforeUndo;
    this._instaService = _instaService;
    this._logService = _logService;
  }
  ariaMessage() {
    const otherResources = new ResourceMap();
    const textEditResources = new ResourceMap();
    let textEditCount = 0;
    for (const edit of this._edits) {
      if (edit instanceof ResourceTextEdit) {
        textEditCount += 1;
        textEditResources.set(edit.resource, true);
      } else if (edit instanceof ResourceFileEdit) {
        otherResources.set(edit.oldResource ?? edit.newResource, true);
      }
    }
    if (this._edits.length === 0) {
      return localize("summary.0", "Made no edits");
    } else if (otherResources.size === 0) {
      if (textEditCount > 1 && textEditResources.size > 1) {
        return localize(
          "summary.nm",
          "Made {0} text edits in {1} files",
          textEditCount,
          textEditResources.size
        );
      } else {
        return localize("summary.n0", "Made {0} text edits in one file", textEditCount);
      }
    } else {
      return localize(
        "summary.textFiles",
        "Made {0} text edits in {1} files, also created or deleted {2} files",
        textEditCount,
        textEditResources.size,
        otherResources.size
      );
    }
  }
  async perform() {
    if (this._edits.length === 0) {
      return [];
    }
    const ranges = [1];
    for (let i = 1; i < this._edits.length; i++) {
      if (Object.getPrototypeOf(this._edits[i - 1]) === Object.getPrototypeOf(this._edits[i])) {
        ranges[ranges.length - 1]++;
      } else {
        ranges.push(1);
      }
    }
    const increment = this._edits.length > 1 ? 0 : void 0;
    this._progress.report({ increment, total: 100 });
    const progress = { report: (_) => this._progress.report({ increment: 100 / this._edits.length }) };
    const resources = [];
    let index = 0;
    for (const range2 of ranges) {
      if (this._token.isCancellationRequested) {
        break;
      }
      const group = this._edits.slice(index, index + range2);
      if (group[0] instanceof ResourceFileEdit) {
        resources.push(await this._performFileEdits(group, this._undoRedoGroup, this._undoRedoSource, this._confirmBeforeUndo, progress));
      } else if (group[0] instanceof ResourceTextEdit) {
        resources.push(await this._performTextEdits(group, this._undoRedoGroup, this._undoRedoSource, progress));
      } else if (group[0] instanceof ResourceNotebookCellEdit) {
        resources.push(await this._performCellEdits(group, this._undoRedoGroup, this._undoRedoSource, progress));
      } else {
        console.log("UNKNOWN EDIT");
      }
      index = index + range2;
    }
    return resources.flat();
  }
  async _performFileEdits(edits, undoRedoGroup, undoRedoSource, confirmBeforeUndo, progress) {
    this._logService.debug("_performFileEdits", JSON.stringify(edits));
    const model = this._instaService.createInstance(BulkFileEdits, this._label || localize("workspaceEdit", "Workspace Edit"), this._code || "undoredo.workspaceEdit", undoRedoGroup, undoRedoSource, confirmBeforeUndo, progress, this._token, edits);
    return await model.apply();
  }
  async _performTextEdits(edits, undoRedoGroup, undoRedoSource, progress) {
    this._logService.debug("_performTextEdits", JSON.stringify(edits));
    const model = this._instaService.createInstance(BulkTextEdits, this._label || localize("workspaceEdit", "Workspace Edit"), this._code || "undoredo.workspaceEdit", this._editor, undoRedoGroup, undoRedoSource, progress, this._token, edits);
    return await model.apply();
  }
  async _performCellEdits(edits, undoRedoGroup, undoRedoSource, progress) {
    this._logService.debug("_performCellEdits", JSON.stringify(edits));
    const model = this._instaService.createInstance(BulkCellEdits, undoRedoGroup, undoRedoSource, progress, this._token, edits);
    return await model.apply();
  }
};
BulkEdit = __decorate([
  __param(9, IInstantiationService),
  __param(10, ILogService)
], BulkEdit);
let BulkEditService = class BulkEditService2 {
  constructor(_instaService, _logService, _editorService, _lifecycleService, _dialogService, _workingCopyService, _configService) {
    this._instaService = _instaService;
    this._logService = _logService;
    this._editorService = _editorService;
    this._lifecycleService = _lifecycleService;
    this._dialogService = _dialogService;
    this._workingCopyService = _workingCopyService;
    this._configService = _configService;
    this._activeUndoRedoGroups = new LinkedList();
  }
  setPreviewHandler(handler) {
    this._previewHandler = handler;
    return toDisposable(() => {
      if (this._previewHandler === handler) {
        this._previewHandler = void 0;
      }
    });
  }
  hasPreviewHandler() {
    return Boolean(this._previewHandler);
  }
  async apply(editsIn, options) {
    let edits = liftEdits(Array.isArray(editsIn) ? editsIn : editsIn.edits);
    if (edits.length === 0) {
      return { ariaSummary: localize("nothing", "Made no edits"), isApplied: false };
    }
    if (this._previewHandler && ((options == null ? void 0 : options.showPreview) || edits.some((value) => {
      var _a2;
      return (_a2 = value.metadata) == null ? void 0 : _a2.needsConfirmation;
    }))) {
      edits = await this._previewHandler(edits, options);
    }
    let codeEditor = options == null ? void 0 : options.editor;
    if (!codeEditor) {
      const candidate = this._editorService.activeTextEditorControl;
      if (isCodeEditor(candidate)) {
        codeEditor = candidate;
      }
    }
    if (codeEditor && codeEditor.getOption(89)) {
      codeEditor = void 0;
    }
    let undoRedoGroup;
    let undoRedoGroupRemove = () => {
    };
    if (typeof (options == null ? void 0 : options.undoRedoGroupId) === "number") {
      for (const candidate of this._activeUndoRedoGroups) {
        if (candidate.id === options.undoRedoGroupId) {
          undoRedoGroup = candidate;
          break;
        }
      }
    }
    if (!undoRedoGroup) {
      undoRedoGroup = new UndoRedoGroup();
      undoRedoGroupRemove = this._activeUndoRedoGroups.push(undoRedoGroup);
    }
    const label = (options == null ? void 0 : options.quotableLabel) || (options == null ? void 0 : options.label);
    const bulkEdit = this._instaService.createInstance(BulkEdit, label, options == null ? void 0 : options.code, codeEditor, (options == null ? void 0 : options.progress) ?? Progress.None, (options == null ? void 0 : options.token) ?? CancellationToken.None, edits, undoRedoGroup, options == null ? void 0 : options.undoRedoSource, !!(options == null ? void 0 : options.confirmBeforeUndo));
    let listener;
    try {
      listener = this._lifecycleService.onBeforeShutdown((e) => e.veto(this._shouldVeto(label, e.reason), "veto.blukEditService"));
      const resources = await bulkEdit.perform();
      if ((options == null ? void 0 : options.respectAutoSaveConfig) && this._configService.getValue(autoSaveSetting) === true && resources.length > 1) {
        await this._saveAll(resources);
      }
      return { ariaSummary: bulkEdit.ariaMessage(), isApplied: edits.length > 0 };
    } catch (err) {
      this._logService.error(err);
      throw err;
    } finally {
      listener == null ? void 0 : listener.dispose();
      undoRedoGroupRemove();
    }
  }
  async _saveAll(resources) {
    const set = new ResourceSet(resources);
    const saves = this._workingCopyService.dirtyWorkingCopies.map(async (copy) => {
      if (set.has(copy.resource)) {
        await copy.save();
      }
    });
    const result = await Promise.allSettled(saves);
    for (const item of result) {
      if (item.status === "rejected") {
        this._logService.warn(item.reason);
      }
    }
  }
  async _shouldVeto(label, reason) {
    let message;
    let primaryButton;
    switch (reason) {
      case 1:
        message = localize("closeTheWindow.message", "Are you sure you want to close the window?");
        primaryButton = localize(
          { key: "closeTheWindow", comment: ["&& denotes a mnemonic"] },
          "&&Close Window"
        );
        break;
      case 4:
        message = localize(
          "changeWorkspace.message",
          "Are you sure you want to change the workspace?"
        );
        primaryButton = localize(
          { key: "changeWorkspace", comment: ["&& denotes a mnemonic"] },
          "Change &&Workspace"
        );
        break;
      case 3:
        message = localize("reloadTheWindow.message", "Are you sure you want to reload the window?");
        primaryButton = localize(
          { key: "reloadTheWindow", comment: ["&& denotes a mnemonic"] },
          "&&Reload Window"
        );
        break;
      default:
        message = localize("quit.message", "Are you sure you want to quit?");
        primaryButton = localize({ key: "quit", comment: ["&& denotes a mnemonic"] }, "&&Quit");
        break;
    }
    const result = await this._dialogService.confirm({
      message,
      detail: localize(
        "areYouSureQuiteBulkEdit.detail",
        "'{0}' is in progress.",
        label || localize("fileOperation", "File operation")
      ),
      primaryButton
    });
    return !result.confirmed;
  }
};
BulkEditService = __decorate([
  __param(0, IInstantiationService),
  __param(1, ILogService),
  __param(2, IEditorService),
  __param(3, ILifecycleService),
  __param(4, IDialogService),
  __param(5, IWorkingCopyService),
  __param(6, IConfigurationService)
], BulkEditService);
const autoSaveSetting = "files.refactoring.autoSave";
Registry.as(Extensions$4.Configuration).registerConfiguration({
  id: "files",
  properties: {
    [autoSaveSetting]: {
      description: localize(
        "refactoring.autoSave",
        "Controls if files that were part of a refactoring are saved automatically"
      ),
      default: true,
      type: "boolean"
    }
  }
});
function getServiceOverride$1() {
  return {
    [IBulkEditService.toString()]: new SyncDescriptor(BulkEditService, [], true)
  };
}
function createPart(id, role, classes) {
  const part = document.createElement(role === "status" ? "footer" : "div");
  part.classList.add("part", ...classes);
  part.id = id;
  part.setAttribute("role", role);
  if (role === "status") {
    part.setAttribute("aria-live", "off");
  }
  return part;
}
function layoutPart(part) {
  var _a2;
  const parent = (_a2 = part.getContainer()) == null ? void 0 : _a2.parentNode;
  if (parent == null) {
    return;
  }
  part.layout(Math.max(part.minimumWidth, Math.min(part.maximumWidth, parent.offsetWidth)), Math.max(part.minimumHeight, Math.min(part.maximumHeight, parent.offsetHeight)), 0, 0);
}
function renderPart(partContainer, part) {
  partContainer.oncontextmenu = () => false;
  function layout() {
    layoutPart(part);
  }
  part.onDidVisibilityChange((visible) => {
    if (visible) {
      layout();
    }
  });
  layout();
}
function getPart(part) {
  return StandaloneServices.get(ILayoutService).getPart(part);
}
function _attachPart(part, container) {
  container.append(part.getContainer());
  const observer = new ResizeObserver(() => layoutPart(part));
  observer.observe(container);
  return {
    dispose() {
      return observer.disconnect();
    }
  };
}
function attachPart(part, container) {
  return _attachPart(getPart(part), container);
}
function onPartVisibilityChange(part, listener) {
  return getPart(part).onDidVisibilityChange(listener);
}
function isPartVisibile(part) {
  return StandaloneServices.get(IWorkbenchLayoutService).isVisible(part);
}
function setPartVisibility(part, visible) {
  StandaloneServices.get(IWorkbenchLayoutService).setPartHidden(!visible, part);
}
function renderActivitybarPar(container) {
  return attachPart("workbench.parts.activitybar", container);
}
function renderSidebarPart(container) {
  return attachPart("workbench.parts.sidebar", container);
}
function renderPanelPart(container) {
  return attachPart("workbench.parts.panel", container);
}
function renderAuxiliaryPart(container) {
  return attachPart("workbench.parts.auxiliarybar", container);
}
function renderEditorPart(container) {
  return attachPart("workbench.parts.editor", container);
}
function renderStatusBarPart(container) {
  return attachPart("workbench.parts.statusbar", container);
}
function registerEditorPane(options) {
  let CustomEditorPane = class CustomEditorPane extends EditorPane {
    constructor(telemetryService, themeService, storageService) {
      super(options.id, telemetryService, themeService, storageService);
    }
    createEditor(parent) {
      this.content = $$2(".editor-pane-content");
      this.content.style.display = "flex";
      this.content.style.alignItems = "stretch";
      append(parent, this.content);
      this._register(options.renderBody(this.content));
    }
    layout(dimension) {
      this.content.style.height = `${dimension.height}px`;
      this.content.style.width = `${dimension.width}px`;
    }
  };
  CustomEditorPane = __decorate([
    __param(0, ITelemetryService),
    __param(1, IThemeService),
    __param(2, IStorageService)
  ], CustomEditorPane);
  class CustomEditorInput2 extends EditorInput {
    constructor(closeHandler) {
      super();
      this.closeHandler = closeHandler;
      this.name = options.name;
      this.title = options.name;
      this.description = options.name;
      this.dirty = false;
    }
    get typeId() {
      return CustomEditorInput2.ID;
    }
    get resource() {
      return void 0;
    }
    setName(name) {
      this.name = name;
      this._onDidChangeLabel.fire();
    }
    setTitle(title) {
      this.title = title;
      this._onDidChangeLabel.fire();
    }
    setDescription(description) {
      this.description = description;
      this._onDidChangeLabel.fire();
    }
    getLabelValue(label, verbosity) {
      if (typeof label === "string") {
        return label;
      }
      switch (verbosity) {
        case 0:
          return label.short;
        case 2:
          return label.long;
        case 1:
        default:
          return label.medium;
      }
    }
    getName() {
      return this.name;
    }
    getTitle(verbosity) {
      return this.getLabelValue(this.title, verbosity);
    }
    getDescription(verbosity) {
      return this.getLabelValue(this.description, verbosity);
    }
    isDirty() {
      return this.dirty;
    }
    setDirty(dirty) {
      this.dirty = dirty;
      this._onDidChangeDirty.fire();
    }
  }
  CustomEditorInput2.ID = `workbench.editors.${options.id}Input`;
  const disposable = Registry.as(EditorExtensions.EditorPane).registerEditorPane(EditorPaneDescriptor.create(CustomEditorPane, options.id, options.name), [new SyncDescriptor(CustomEditorInput2)]);
  return {
    disposable,
    CustomEditorInput: CustomEditorInput2
  };
}
function registerCustomView(options) {
  const iconUrl = options.icon != null ? URI.parse(options.icon) : void 0;
  const VIEW_CONTAINER2 = Registry.as(Extensions$1.ViewContainersRegistry).registerViewContainer({
    id: options.id,
    title: options.name,
    order: options.order,
    ctorDescriptor: new SyncDescriptor(ViewPaneContainer, [options.id, { mergeViewWithContainerWhenSingleView: true }]),
    hideIfEmpty: true,
    icon: iconUrl
  }, options.location);
  const views = [{
    id: options.id,
    name: options.name,
    canToggleVisibility: false,
    ctorDescriptor: new SyncDescriptor(class extends ViewPane {
      renderBody(container) {
        super.renderBody(container);
        this.content = $$2(".view-pane-content");
        this.content.style.display = "flex";
        this.content.style.alignItems = "stretch";
        append(container, this.content);
        this._register(options.renderBody(this.content));
      }
      getActionViewItem(action, actionOptions) {
        const customAction = (options.actions ?? []).find((customAction2) => customAction2.id === action.id);
        if ((customAction == null ? void 0 : customAction.render) != null) {
          return new class extends BaseActionViewItem {
            constructor() {
              super(null, action);
              this.render = customAction.render;
            }
          }();
        }
        return super.getActionViewItem(action, actionOptions);
      }
      layoutBody(height, width) {
        this.content.style.height = `${height}px`;
        this.content.style.width = `${width}px`;
      }
    }),
    canMoveView: options.canMoveView ?? true,
    containerIcon: iconUrl
  }];
  Registry.as(Extensions$1.ViewsRegistry).registerViews(views, VIEW_CONTAINER2);
  if (options.default ?? false) {
    void StandaloneServices.get(ILifecycleService).when(4).then(() => {
      void StandaloneServices.get(IViewsService).openViewContainer(options.id);
    });
  }
  const disposableCollection = new DisposableStore();
  disposableCollection.add({
    dispose() {
      Registry.as(Extensions$1.ViewsRegistry).deregisterViews(views, VIEW_CONTAINER2);
      Registry.as(Extensions$1.ViewContainersRegistry).deregisterViewContainer(VIEW_CONTAINER2);
    }
  });
  for (const action of options.actions ?? []) {
    disposableCollection.add(registerAction2(class extends Action2 {
      constructor() {
        super({
          id: action.id,
          title: { value: action.title, original: action.title },
          category: Categories.View,
          menu: [{
            id: MenuId.ViewTitle,
            when: ContextKeyExpr.equals("view", options.id),
            group: "navigation",
            order: action.order
          }, {
            id: MenuId.CommandPalette
          }],
          tooltip: action.tooltip,
          icon: action.icon != null ? Codicon[action.icon] : void 0
        });
        this.run = action.run ?? (async () => {
        });
      }
    }));
  }
  return disposableCollection;
}
let EditorDropService = class EditorDropService2 {
  constructor(editorPart) {
    this.editorPart = editorPart;
  }
  createEditorDropTarget(container, delegate) {
    return this.editorPart.createEditorDropTarget(container, delegate);
  }
};
EditorDropService = __decorate([
  __param(0, IEditorGroupsService)
], EditorDropService);
function isElementVisible(el) {
  if (!el.isConnected) {
    return false;
  }
  if (el.checkVisibility != null) {
    return el.checkVisibility({
      checkOpacity: true,
      checkVisibilityCSS: true
    });
  }
  return el.offsetHeight > 0 && el.offsetWidth > 0;
}
function isEditorPartVisible() {
  const container = StandaloneServices.get(IEditorGroupsService).getContainer();
  return container != null && isElementVisible(container);
}
let MonacoEditorPart = class MonacoEditorPart2 extends MonacoDelegateEditorGroupsService {
  constructor(instantiationService) {
    super(instantiationService.createInstance(EditorPart), instantiationService);
    this.onDidChangeSizeConstraints = this.delegate.onDidChangeSizeConstraints;
    this.restoreGroup = (...args) => {
      return this.delegate.restoreGroup(...args);
    };
    this.isGroupMaximized = (...args) => {
      return this.delegate.isGroupMaximized(...args);
    };
    this.createEditorDropTarget = (...args) => {
      return this.delegate.createEditorDropTarget(...args);
    };
    this.updateStyles = (...args) => {
      return this.delegate.updateStyles(...args);
    };
    this.setBoundarySashes = (...args) => {
      return this.delegate.setBoundarySashes(...args);
    };
    this.layout = (...args) => {
      return this.delegate.layout(...args);
    };
    this.toJSON = (...args) => {
      return this.delegate.toJSON(...args);
    };
    this.onDidVisibilityChange = this.delegate.onDidVisibilityChange;
    this.create = (...args) => {
      return this.delegate.create(...args);
    };
    this.getContainer = (...args) => {
      return this.delegate.getContainer(...args);
    };
    this.setVisible = (...args) => {
      return this.delegate.setVisible(...args);
    };
    this.getId = (...args) => {
      return this.delegate.getId(...args);
    };
  }
  get minimumWidth() {
    return this.delegate.minimumWidth;
  }
  get maximumWidth() {
    return this.delegate.maximumWidth;
  }
  get minimumHeight() {
    return this.delegate.minimumHeight;
  }
  get maximumHeight() {
    return this.delegate.maximumHeight;
  }
  get snap() {
    return this.delegate.snap;
  }
  get onDidChange() {
    return this.delegate.onDidChange;
  }
  get priority() {
    return this.delegate.priority;
  }
  get dimension() {
    return this.delegate.dimension;
  }
  get element() {
    return this.delegate.element;
  }
};
MonacoEditorPart = __decorate([
  __param(0, IInstantiationService)
], MonacoEditorPart);
let webviewIframeAlternateDomains;
registerAssets({
  "vs/workbench/contrib/webview/browser/pre/service-worker.js": () => changeUrlDomain(new URL("/statetree-language/assets/service-worker-90548569.js", self.location).href, webviewIframeAlternateDomains),
  "vs/workbench/contrib/webview/browser/pre/index.html": () => changeUrlDomain(new URL("/statetree-language/assets/index-96e0339d.html", self.location).href, webviewIframeAlternateDomains),
  "vs/workbench/contrib/webview/browser/pre/index-no-csp.html": () => changeUrlDomain(new URL("/statetree-language/assets/index-no-csp-1bc96807.html", self.location).href, webviewIframeAlternateDomains),
  "vs/workbench/contrib/webview/browser/pre/fake.html": () => changeUrlDomain(new URL("/statetree-language/assets/fake-dfa91b18.html", self.location).href, webviewIframeAlternateDomains)
});
registerServiceInitializePostParticipant(async (accessor) => {
  var _a2, _b2, _c2;
  const paneCompositePartService = accessor.get(IPaneCompositePartService);
  const viewDescriptorService = accessor.get(IViewDescriptorService);
  accessor.get(IStatusbarService);
  paneCompositePartService.getPaneComposites(1);
  const layoutService = accessor.get(ILayoutService);
  const invisibleContainer = document.createElement("div");
  invisibleContainer.style.display = "none";
  document.body.append(invisibleContainer);
  for (const { id, role, classes, options } of [
    { id: "workbench.parts.activitybar", role: "none", classes: ["activitybar", "left"] },
    { id: "workbench.parts.sidebar", role: "none", classes: ["sidebar", "left"] },
    { id: "workbench.parts.editor", role: "main", classes: ["editor"], options: { restorePreviousState: false } },
    { id: "workbench.parts.panel", role: "none", classes: ["panel", "basepanel", positionToString(2)] },
    { id: "workbench.parts.auxiliarybar", role: "none", classes: ["auxiliarybar", "basepanel", "right"] },
    { id: "workbench.parts.statusbar", role: "status", classes: ["statusbar"] }
  ]) {
    const partContainer = createPart(id, role, classes);
    const part = layoutService.getPart(id);
    part.create(partContainer, options);
    renderPart(partContainer, part);
    invisibleContainer.append(partContainer);
  }
  await paneCompositePartService.openPaneComposite((_a2 = viewDescriptorService.getDefaultViewContainer(0)) == null ? void 0 : _a2.id, 0);
  await paneCompositePartService.openPaneComposite((_b2 = viewDescriptorService.getDefaultViewContainer(1)) == null ? void 0 : _b2.id, 1);
  await paneCompositePartService.openPaneComposite((_c2 = viewDescriptorService.getDefaultViewContainer(2)) == null ? void 0 : _c2.id, 2);
});
function getServiceOverride(openEditorFallback, _webviewIframeAlternateDomains) {
  if (_webviewIframeAlternateDomains != null) {
    webviewIframeAlternateDomains = _webviewIframeAlternateDomains;
  }
  return {
    ...getServiceOverride$2(),
    ...getServiceOverride$1(),
    ...getServiceOverride$3({
      isKeybindingConfigurationVisible: isEditorPartVisible,
      shouldUseGlobalPicker: isEditorPartVisible
    }),
    [IViewsService.toString()]: new SyncDescriptor(ViewsService, [], false),
    [IViewDescriptorService.toString()]: new SyncDescriptor(ViewDescriptorService, [], true),
    [IActivityService.toString()]: new SyncDescriptor(ActivityService, [], true),
    [IPaneCompositePartService.toString()]: new SyncDescriptor(PaneCompositeParts, [], true),
    [IHoverService.toString()]: new SyncDescriptor(HoverService, [], true),
    [IExplorerService.toString()]: new SyncDescriptor(ExplorerService, [], true),
    [ICodeEditorService.toString()]: new SyncDescriptor(CodeEditorService, [], true),
    [ITextEditorService.toString()]: new SyncDescriptor(TextEditorService, [], false),
    [IEditorGroupsService.toString()]: new SyncDescriptor(MonacoEditorPart, [], false),
    [IStatusbarService.toString()]: new SyncDescriptor(StatusbarPart, [], false),
    [IEditorDropService.toString()]: new SyncDescriptor(EditorDropService, [], true),
    [IEditorService.toString()]: new SyncDescriptor(MonacoEditorService, [openEditorFallback, isEditorPartVisible], false),
    [IEditorResolverService.toString()]: new SyncDescriptor(EditorResolverService, [], false),
    [IBreadcrumbsService.toString()]: new SyncDescriptor(BreadcrumbsService, [], true),
    [IContextViewService.toString()]: new SyncDescriptor(ContextViewService, [], true),
    [IUntitledTextEditorService.toString()]: new SyncDescriptor(UntitledTextEditorService, [], true),
    [ISemanticSimilarityService.toString()]: new SyncDescriptor(SemanticSimilarityService, [], true),
    [IHistoryService.toString()]: new SyncDescriptor(HistoryService, [], false),
    [IOutlineService.toString()]: new SyncDescriptor(OutlineService, [], true),
    [ICustomEditorService.toString()]: new SyncDescriptor(CustomEditorService, [], true),
    [IWebviewService.toString()]: new SyncDescriptor(WebviewService, [], true),
    [IWebviewViewService.toString()]: new SyncDescriptor(WebviewViewService, [], true),
    [IWebviewWorkbenchService.toString()]: new SyncDescriptor(WebviewEditorService, [], true)
  };
}
export {
  ActivityService,
  ActivitybarPart,
  rp as ConfirmResult,
  HoverService,
  PanelPart,
  ro as Parts,
  SidebarPart,
  StatusbarPart,
  rn as ViewContainerLocation,
  attachPart,
  getServiceOverride as default,
  isEditorPartVisible,
  isPartVisibile,
  onPartVisibilityChange,
  registerCustomView,
  registerEditorPane,
  renderActivitybarPar,
  renderAuxiliaryPart,
  renderEditorPart,
  renderPanelPart,
  renderPart,
  renderSidebarPart,
  renderStatusBarPart,
  setPartVisibility
};
