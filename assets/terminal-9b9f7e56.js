var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H;
import { aL as registerIcon, c as localize, aM as Codicon, xb as PickerQuickAccessProvider, zL as TerminalLocation, zM as getIconId, zN as getColorClass, zO as getUriClasses, xc as matchesFuzzy, aK as ThemeIcon, xv as TriggerAction, gu as __decorate, gv as __param, gx as IEditorService, zP as ITerminalEditorService, zQ as ITerminalGroupService, ak as ICommandService, aQ as IThemeService, b1 as IInstantiationService, a2 as URI, D as Disposable, ab as LRUCache, ay as IConfigurationService, aa as IStorageService, he as IFileService, iv as IRemoteAgentService, d2 as isWindows, zR as env, br as Schemas, im as win32, il as posix, pV as FileOperationError, cy as Action, c2 as IOpenerService, zS as TerminalContextKeys, bF as registerAction2, f6 as Action2, zT as ITerminalService, zU as ITerminalInstanceService, zV as ITerminalProfileService, zW as ITerminalProfileResolverService, e7 as isObject, l3 as IEditorGroupsService, kX as SIDE_GROUP, C as ContextKeyExpr, gh as CONTEXT_ACCESSIBILITY_MODE_ENABLED, v as IClipboardService, e9 as isString, u as ICodeEditorService, al as INotificationService, hR as IWorkbenchEnvironmentService, zX as TerminalExitReason, as as IQuickInputService, b0 as ILabelService, d7 as IWorkspaceContextService, l7 as ResourceContextKey, mb as CLOSE_EDITOR_COMMAND_ID, bz as IListService, K as KeyChord, hy as IPreferencesService, k9 as BrowserFeatures, dz as isLinux, dZ as Severity, zs as PICK_WORKSPACE_FOLDER_COMMAND_ID, a4 as IModelService, bb as ILanguageService, vV as IConfigurationResolverService, b5 as dirname, k0 as getIconClasses, k1 as FileKind, a7 as CancellationToken, pK as isAbsolute, wL as AbstractVariableResolverService, rh as IHistoryService, bP as withNullAsUndefined, bJ as Iterable, gM as n, a9 as createDecorator, zY as Throttler, M as MarkdownString, d as alert, zZ as toExtensionDescription, z_ as areSameExtensions, z$ as isLanguagePackExtension, A0 as INSTALL_ACTIONS_GROUP, A1 as THEME_ACTIONS_GROUP, ud as fromNow, pd as ExtensionIdentifier, bo as Event, g8 as language, A2 as getLocale, A3 as VIEWLET_ID, aD as Emitter, A4 as TargetPlatformToString, A5 as getWorkspaceSupportTypeMessage, A6 as escapeMarkdownSyntaxTokens, A7 as isVirtualWorkspace, w as isWeb, A8 as toExtension, a0 as CommandsRegistry, jA as IPaneCompositePartService, f as registerColor, gz as buttonBackground, gB as buttonForeground, A9 as buttonHoverBackground, Aa as buttonSeparator, cL as registerThemingParticipant, cg as editorErrorForeground, ci as editorWarningForeground, ck as editorInfoForeground, fv as isCancellationError, Ab as ExtensionManagementErrorCode, hF as getErrorMessage, Ac as SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID, go as isIOS, jI as IProductService, iK as IDialogService, fM as ILogService, Ad as IExtensionManagementServerService, rS as IExtensionGalleryService, Ae as IExtensionManifestPropertiesService, yS as IExtensionsWorkbenchService, h5 as IExtensionService, cu as ITelemetryService, oV as ActionViewItem, aP as getDomNodePagePosition, qk as disposeIfDisposable, cE as Separator, ct as IContextMenuService, c9 as IMenuService, Af as isApplicationScopedExtension, i as MenuId, jC as SubmenuAction, Ag as TOGGLE_IGNORE_EXTENSION_ACTION_ID, Ah as getExtensionId, yc as IWorkbenchExtensionEnablementService, dr as Delayer, ht as parse, Ai as parseTree, Aj as findNodeAtLocation, h4 as ITextFileService, i1 as IJSONEditingService, a_ as ITextModelService, Ak as TERMINAL_CONFIG_SECTION, Al as DEFAULT_FONT_WEIGHT, Am as DEFAULT_BOLD_FONT_WEIGHT, am as EDITOR_FONT_DEFAULTS, An as MINIMUM_LETTER_SPACING, Ao as DEFAULT_LETTER_SPACING, Ap as DEFAULT_LINE_HEIGHT, gL as basename, c8 as Severity$1, pI as NeverShowAgainScope, Aq as MINIMUM_FONT_WEIGHT, Ar as MAXIMUM_FONT_WEIGHT, yb as IExtensionManagementService, uX as getIconRegistry, As as getColorStyleElement, bE as coalesce, aX as dispose, At as TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR, fn as timeout, Au as debounce, cH as OS, aq as toDisposable, bC as combinedDisposable, aI as addDisposableListener, aJ as EventType, jG as IHoverService, f4 as AudioCue, Av as TERMINAL_COMMAND_DECORATION_ERROR_BACKGROUND_COLOR, Aw as TERMINAL_COMMAND_DECORATION_SUCCESS_BACKGROUND_COLOR, hS as ILifecycleService, f0 as IAudioCueService, Ax as TERMINAL_COMMAND_DECORATION_DEFAULT_BACKGROUND_COLOR, b8 as FuzzyScore, Ay as FuzzyScoreOptions, Az as fuzzyScore, AA as fuzzyScoreGracefulAggressive, AB as quickSelect, a6 as DisposableStore, aG as append, ah as $$3, b2 as IconLabel, b6 as createMatches, bq as show, cZ as MutableDisposable, aA as TimeoutTimer, bV as ResizableHTMLElement, aS as Dimension, ox as List, AC as SuggestWidgetStatus, rR as runAtThisOrScheduleAtNextAnimationFrame, bh as hide, bW as getClientArea, w7 as clamp, lT as findParentWithClass, za as getListStyles, AD as editorSuggestWidgetSelectedBackground, fA as activeContrastBorder, m0 as isSafari, AE as TERMINAL_BACKGROUND_COLOR, kx as PANEL_BACKGROUND, AF as TERMINAL_FIND_MATCH_BACKGROUND_COLOR, AG as TERMINAL_FIND_MATCH_BORDER_COLOR, AH as TERMINAL_FIND_MATCH_HIGHLIGHT_BACKGROUND_COLOR, AI as TERMINAL_FIND_MATCH_HIGHLIGHT_BORDER_COLOR, AJ as TERMINAL_OVERVIEW_RULER_FIND_MATCH_FOREGROUND_COLOR, AK as TERMINAL_FOREGROUND_COLOR, AL as TERMINAL_CURSOR_FOREGROUND_COLOR, AM as TERMINAL_CURSOR_BACKGROUND_COLOR, AN as TERMINAL_SELECTION_BACKGROUND_COLOR, AO as TERMINAL_INACTIVE_SELECTION_BACKGROUND_COLOR, AP as TERMINAL_SELECTION_FOREGROUND_COLOR, xG as ansiColorIdentifiers, qB as LogLevel, AQ as ITerminalLogService, I as IContextKeyService, Z as Registry, xi as join, v0 as getRemoteAuthority, d3 as generateUuid, AR as serializeEnvironmentVariableCollections, ac as runWhenIdle, iu as IPathService, AS as IEnvironmentVariableService, aT as isMacintosh, dB as Toggle, dj as asCssVariable, dn as inputActiveOptionBorder, dp as inputActiveOptionForeground, dq as inputActiveOptionBackground, qg as spinningLoading, oj as listWarningForeground, oi as listErrorForeground, AT as TitleEventSource, hg as ServiceCollection, AU as AutoOpenBarrier, ap as onUnexpectedError, i4 as Promises, hA as ErrorNoTelemetry, cc as editorBackground, AV as TERMINAL_VIEW_ID, jh as SIDE_BAR_BACKGROUND, bT as StandardKeyboardEvent, AW as TERMINAL_CREATION_COMMANDS, g5 as TabFocus, lt as DragAndDropObserver, q as isFirefox, AX as deserializeEnvironmentVariableCollections, AY as DEFAULT_COMMANDS_TO_SKIP_SHELL, bS as DomScrollableElement, AZ as getAllCodicons, A_ as getStandardColors, mx as containsDragType, cX as CodeDataTransfers, cT as DataTransfers, A$ as resolve, B0 as template, B1 as TerminalEditorInput, a$ as IKeybindingService, mT as IViewsService, cN as IAccessibilityService, u5 as IWorkspaceTrustRequestService, jl as IViewDescriptorService, jk as IWorkbenchLayoutService, eL as DeferredPromise, B2 as TerminalExtensions, i6 as mark, B3 as columnToEditorGroup, B4 as VirtualWorkspaceContext, B5 as ITimerService, l6 as Themable, oO as ColorScheme, kd as asCSSUrl, B6 as asCSSPropertyValue, e3 as iconForeground, B7 as getColorStyleContent, l2 as ACTIVE_GROUP, m3 as EditorActivation, bi as SplitView, bp as Sizing, B8 as PlatformToString, _ as Extensions, B9 as throttle, cD as equals, Ba as ITerminalContributionService, ha as deepClone, Bb as parse$1, Bc as deserializeEnvironmentVariableCollection, Bd as deserializeEnvironmentDescriptionMap, Be as serializeEnvironmentVariableCollection, Bf as serializeEnvironmentDescriptionMap, jm as ILoggerService, gr as ExtensionsRegistry, ig as isProposedApiEnabled, c1 as asArray, ur as WorkbenchList, kV as ResourceLabels, kW as DEFAULT_LABELS_CONTAINER, Bg as IDecorationsService, cA as ActionBar, cB as MenuItemAction, cF as MenuEntryActionViewItem, u7 as InputBox, dx as defaultInputBoxStyles, bn as addStandardDisposableListener, dW as IContextViewService, Bh as NativeDragAndDropData, xV as ElementsDragAndDropData, an as disposableTimeout, ad as once, fU as StandardMouseEvent, k7 as createAndFillInContextMenuActions, h as MenuRegistry, Bi as TaskExecutionSupportedContext, oo as ViewPane, gS as SelectActionViewItem, gT as defaultSelectBoxStyles, wY as selectBorder, ai as reset, ag as renderLabelWithIcons, bu as KeybindingsRegistry, Bj as SUGGESTIONS_FONT_WEIGHT, Bk as TerminalCursorStyle, Bl as DEFAULT_LOCAL_ECHO_EXCLUDE, lg as EditorPane, Bm as terminalEditorId, q5 as RegisteredEditorPriority, lo as IEditorResolverService, Bn as IEmbedderTerminalService, r_ as Extensions$1, j$ as getQuickNavigateHandler, h1 as Extensions$2, m7 as EditorExtensions, pn as EditorPaneDescriptor, hh as SyncDescriptor, mw as Extensions$3, jp as Extensions$4, jv as ViewPaneContainer, Bo as registerColors, ds as format, yh as EditorExtensionsRegistry, G as CodeActionController, wU as getSimpleEditorOptions, wS as CodeEditorWidget, bY as trackFocus, rK as terminalTabFocusModeContextKey, gE as AccessibilityHelpAction, gF as IAccessibleViewService, iS as unsupported, Bp as TerminalContributionService, Bq as ITerminalLinkProviderService, Br as ITerminalQuickFixService } from "./theme-defaults-1df7f429.js";
import { I as IWorkbenchThemeService } from "./index-ca8d23e0.js";
import { m as manageExtensionIcon, p as preReleaseIcon, s as syncIgnoredIcon, a as syncEnabledIcon, w as warningIcon, i as infoIcon, t as trustIcon, e as errorIcon, b as showWithPinnedItems } from "./quickPickPin-cb6cd653.js";
import { s as showWindowLogActionId } from "./logConstants-8dfc303d.js";
import { q as __vitePreload } from "./index-3bddf13b.js";
import { g as getPartByLocation } from "./viewsService-d4b94cea.js";
import { D as DropdownWithPrimaryActionViewItem } from "./dropdownWithPrimaryActionViewItem-f7a63dfc.js";
function formatMessageForTerminal(message, options = {}) {
  let result = "";
  if (!options.excludeLeadingNewLine) {
    result += "\r\n";
  }
  result += "\x1B[0m\x1B[7m * ";
  if (options.loudFormatting) {
    result += "\x1B[0;104m";
  } else {
    result += "\x1B[0m";
  }
  result += ` ${message} \x1B[0m
\r`;
  return result;
}
const terminalViewIcon = registerIcon("terminal-view-icon", Codicon.terminal, localize("terminalViewIcon", "View icon of the terminal view."));
const renameTerminalIcon = registerIcon("terminal-rename", Codicon.gear, localize("renameTerminalIcon", "Icon for rename in the terminal quick menu."));
const killTerminalIcon = registerIcon("terminal-kill", Codicon.trash, localize("killTerminalIcon", "Icon for killing a terminal instance."));
const newTerminalIcon = registerIcon("terminal-new", Codicon.add, localize("newTerminalIcon", "Icon for creating a new terminal instance."));
const configureTerminalProfileIcon = registerIcon("terminal-configure-profile", Codicon.gear, localize(
  "configureTerminalProfileIcon",
  "Icon for creating a new terminal profile."
));
const terminalDecorationMark = registerIcon("terminal-decoration-mark", Codicon.circleSmallFilled, localize("terminalDecorationMark", "Icon for a terminal decoration mark."));
const terminalDecorationIncomplete = registerIcon("terminal-decoration-incomplete", Codicon.circle, localize(
  "terminalDecorationIncomplete",
  "Icon for a terminal decoration of a command that was incomplete."
));
const terminalDecorationError = registerIcon("terminal-decoration-error", Codicon.errorSmall, localize(
  "terminalDecorationError",
  "Icon for a terminal decoration of a command that errored."
));
const terminalDecorationSuccess = registerIcon("terminal-decoration-success", Codicon.circleFilled, localize(
  "terminalDecorationSuccess",
  "Icon for a terminal decoration of a command that was successful."
));
const commandHistoryRemoveIcon = registerIcon("terminal-command-history-remove", Codicon.close, localize(
  "terminalCommandHistoryRemove",
  "Icon for removing a terminal command from command history."
));
const commandHistoryOutputIcon = registerIcon("terminal-command-history-output", Codicon.output, localize(
  "terminalCommandHistoryOutput",
  "Icon for viewing output of a terminal command."
));
const commandHistoryFuzzySearchIcon = registerIcon("terminal-command-history-fuzzy-search", Codicon.searchFuzzy, localize(
  "terminalCommandHistoryFuzzySearch",
  "Icon for toggling fuzzy search of command history."
));
const terminalStrings = {
  terminal: localize("terminal", "Terminal"),
  new: localize("terminal.new", "New Terminal"),
  doNotShowAgain: localize("doNotShowAgain", "Do Not Show Again"),
  currentSessionCategory: localize("currentSessionCategory", "current session"),
  previousSessionCategory: localize("previousSessionCategory", "previous session"),
  actionCategory: {
    value: localize("terminalCategory", "Terminal"),
    original: "Terminal"
  },
  focus: {
    value: localize("workbench.action.terminal.focus", "Focus Terminal"),
    original: "Focus Terminal"
  },
  kill: {
    value: localize("killTerminal", "Kill Terminal"),
    original: "Kill Terminal",
    short: localize("killTerminal.short", "Kill")
  },
  moveToEditor: {
    value: localize("moveToEditor", "Move Terminal into Editor Area"),
    original: "Move Terminal into Editor Area"
  },
  moveToTerminalPanel: {
    value: localize(
      "workbench.action.terminal.moveToTerminalPanel",
      "Move Terminal into Panel"
    ),
    original: "Move Terminal into Panel"
  },
  changeIcon: {
    value: localize("workbench.action.terminal.changeIcon", "Change Icon..."),
    original: "Change Icon..."
  },
  changeColor: {
    value: localize("workbench.action.terminal.changeColor", "Change Color..."),
    original: "Change Color..."
  },
  split: {
    value: localize("splitTerminal", "Split Terminal"),
    original: "Split Terminal",
    short: localize("splitTerminal.short", "Split")
  },
  unsplit: {
    value: localize("unsplitTerminal", "Unsplit Terminal"),
    original: "Unsplit Terminal"
  },
  rename: {
    value: localize("workbench.action.terminal.rename", "Rename..."),
    original: "Rename..."
  },
  toggleSizeToContentWidth: {
    value: localize(
      "workbench.action.terminal.sizeToContentWidthInstance",
      "Toggle Size to Content Width"
    ),
    original: "Toggle Size to Content Width"
  },
  focusHover: {
    value: localize("workbench.action.terminal.focusHover", "Focus Hover"),
    original: "Focus Hover"
  },
  sendSequence: {
    value: localize(
      "workbench.action.terminal.sendSequence",
      "Send Custom Sequence To Terminal"
    ),
    original: "Send Custom Sequence To Terminal"
  },
  newWithCwd: {
    value: localize(
      "workbench.action.terminal.newWithCwd",
      "Create New Terminal Starting in a Custom Working Directory"
    ),
    original: "Create New Terminal Starting in a Custom Working Directory"
  },
  renameWithArgs: {
    value: localize(
      "workbench.action.terminal.renameWithArg",
      "Rename the Currently Active Terminal"
    ),
    original: "Rename the Currently Active Terminal"
  }
};
let terminalPicks = [];
let TerminalQuickAccessProvider = (_a = class extends PickerQuickAccessProvider {
  constructor(_editorService, _terminalService, _terminalEditorService, _terminalGroupService, _commandService, _themeService, _instantiationService) {
    super(_a.PREFIX, { canAcceptInBackground: true });
    this._editorService = _editorService;
    this._terminalService = _terminalService;
    this._terminalEditorService = _terminalEditorService;
    this._terminalGroupService = _terminalGroupService;
    this._commandService = _commandService;
    this._themeService = _themeService;
    this._instantiationService = _instantiationService;
  }
  _getPicks(filter) {
    terminalPicks = [];
    terminalPicks.push({ type: "separator", label: "panel" });
    const terminalGroups = this._terminalGroupService.groups;
    for (let groupIndex = 0; groupIndex < terminalGroups.length; groupIndex++) {
      const terminalGroup = terminalGroups[groupIndex];
      for (let terminalIndex = 0; terminalIndex < terminalGroup.terminalInstances.length; terminalIndex++) {
        const terminal = terminalGroup.terminalInstances[terminalIndex];
        const pick = this._createPick(terminal, terminalIndex, filter, { groupIndex, groupSize: terminalGroup.terminalInstances.length });
        if (pick) {
          terminalPicks.push(pick);
        }
      }
    }
    if (terminalPicks.length > 0) {
      terminalPicks.push({ type: "separator", label: "editor" });
    }
    const terminalEditors = this._terminalEditorService.instances;
    for (let editorIndex = 0; editorIndex < terminalEditors.length; editorIndex++) {
      const term = terminalEditors[editorIndex];
      term.target = TerminalLocation.Editor;
      const pick = this._createPick(term, editorIndex, filter);
      if (pick) {
        terminalPicks.push(pick);
      }
    }
    if (terminalPicks.length > 0) {
      terminalPicks.push({ type: "separator" });
    }
    const createTerminalLabel = localize("workbench.action.terminal.newplus", "Create New Terminal");
    terminalPicks.push({
      label: `$(plus) ${createTerminalLabel}`,
      ariaLabel: createTerminalLabel,
      accept: () => this._commandService.executeCommand("workbench.action.terminal.new")
    });
    const createWithProfileLabel = localize(
      "workbench.action.terminal.newWithProfilePlus",
      "Create New Terminal With Profile"
    );
    terminalPicks.push({
      label: `$(plus) ${createWithProfileLabel}`,
      ariaLabel: createWithProfileLabel,
      accept: () => this._commandService.executeCommand("workbench.action.terminal.newWithProfile")
    });
    return terminalPicks;
  }
  _createPick(terminal, terminalIndex, filter, groupInfo) {
    const iconId = this._instantiationService.invokeFunction(getIconId, terminal);
    const index = groupInfo ? groupInfo.groupSize > 1 ? `${groupInfo.groupIndex + 1}.${terminalIndex + 1}` : `${groupInfo.groupIndex + 1}` : `${terminalIndex + 1}`;
    const label = `$(${iconId}) ${index}: ${terminal.title}`;
    const iconClasses = [];
    const colorClass = getColorClass(terminal);
    if (colorClass) {
      iconClasses.push(colorClass);
    }
    const uriClasses = getUriClasses(terminal, this._themeService.getColorTheme().type);
    if (uriClasses) {
      iconClasses.push(...uriClasses);
    }
    const highlights = matchesFuzzy(filter, label, true);
    if (highlights) {
      return {
        label,
        description: terminal.description,
        highlights: { label: highlights },
        buttons: [
          {
            iconClass: ThemeIcon.asClassName(renameTerminalIcon),
            tooltip: localize("renameTerminal", "Rename Terminal")
          },
          {
            iconClass: ThemeIcon.asClassName(killTerminalIcon),
            tooltip: terminalStrings.kill.value
          }
        ],
        iconClasses,
        trigger: (buttonIndex) => {
          switch (buttonIndex) {
            case 0:
              this._commandService.executeCommand("workbench.action.terminal.rename", terminal);
              return TriggerAction.NO_ACTION;
            case 1:
              this._terminalService.safeDisposeTerminal(terminal);
              return TriggerAction.REMOVE_ITEM;
          }
          return TriggerAction.NO_ACTION;
        },
        accept: (keyMod, event) => {
          if (terminal.target === TerminalLocation.Editor) {
            const existingEditors = this._editorService.findEditors(terminal.resource);
            this._terminalEditorService.openEditor(terminal, { viewColumn: existingEditors == null ? void 0 : existingEditors[0].groupId });
            this._terminalEditorService.setActiveInstance(terminal);
          } else {
            this._terminalGroupService.showPanel(!event.inBackground);
            this._terminalGroupService.setActiveInstance(terminal);
          }
        }
      };
    }
    return void 0;
  }
}, _a.PREFIX = "term ", _a);
TerminalQuickAccessProvider = __decorate([
  __param(0, IEditorService),
  __param(1, ITerminalEditorService),
  __param(2, ITerminalEditorService),
  __param(3, ITerminalGroupService),
  __param(4, ICommandService),
  __param(5, IThemeService),
  __param(6, IInstantiationService)
], TerminalQuickAccessProvider);
function createProfileSchemaEnums(detectedProfiles, extensionProfiles) {
  const result = [{
    name: null,
    description: localize("terminalAutomaticProfile", "Automatically detect the default")
  }];
  result.push(...detectedProfiles.map((e) => {
    return {
      name: e.profileName,
      description: createProfileDescription(e)
    };
  }));
  if (extensionProfiles) {
    result.push(...extensionProfiles.map((extensionProfile) => {
      return {
        name: extensionProfile.title,
        description: createExtensionProfileDescription(extensionProfile)
      };
    }));
  }
  return {
    values: result.map((e) => e.name),
    markdownDescriptions: result.map((e) => e.description)
  };
}
function createProfileDescription(profile) {
  let description = `$(${ThemeIcon.isThemeIcon(profile.icon) ? profile.icon.id : profile.icon ? profile.icon : Codicon.terminal.id}) ${profile.profileName}
- path: ${profile.path}`;
  if (profile.args) {
    if (typeof profile.args === "string") {
      description += `
- args: "${profile.args}"`;
    } else {
      description += `
- args: [${profile.args.length === 0 ? "" : `'${profile.args.join(`','`)}'`}]`;
    }
  }
  if (profile.overrideName !== void 0) {
    description += `
- overrideName: ${profile.overrideName}`;
  }
  if (profile.color) {
    description += `
- color: ${profile.color}`;
  }
  if (profile.env) {
    description += `
- env: ${JSON.stringify(profile.env)}`;
  }
  return description;
}
function createExtensionProfileDescription(profile) {
  const description = `$(${ThemeIcon.isThemeIcon(profile.icon) ? profile.icon.id : profile.icon ? profile.icon : Codicon.terminal.id}) ${profile.title}
- extensionIdentifier: ${profile.extensionIdentifier}`;
  return description;
}
function terminalProfileArgsMatch(args1, args2) {
  if (!args1 && !args2) {
    return true;
  } else if (typeof args1 === "string" && typeof args2 === "string") {
    return args1 === args2;
  } else if (Array.isArray(args1) && Array.isArray(args2)) {
    if (args1.length !== args2.length) {
      return false;
    }
    for (let i = 0; i < args1.length; i++) {
      if (args1[i] !== args2[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function terminalIconsEqual(a, b) {
  if (!a && !b) {
    return true;
  } else if (!a || !b) {
    return false;
  }
  if (ThemeIcon.isThemeIcon(a) && ThemeIcon.isThemeIcon(b)) {
    return a.id === b.id && a.color === b.color;
  }
  if (typeof a === "object" && "light" in a && "dark" in a && typeof b === "object" && "light" in b && "dark" in b) {
    const castedA = a;
    const castedB = b;
    if ((URI.isUri(castedA.light) || isUriComponents(castedA.light)) && (URI.isUri(castedA.dark) || isUriComponents(castedA.dark)) && (URI.isUri(castedB.light) || isUriComponents(castedB.light)) && (URI.isUri(castedB.dark) || isUriComponents(castedB.dark))) {
      return castedA.light.path === castedB.light.path && castedA.dark.path === castedB.dark.path;
    }
  }
  if (URI.isUri(a) && URI.isUri(b) || (isUriComponents(a) || isUriComponents(b))) {
    const castedA = a;
    const castedB = b;
    return castedA.path === castedB.path && castedA.scheme === castedB.scheme;
  }
  return false;
}
function isUriComponents(thing) {
  if (!thing) {
    return false;
  }
  return typeof thing.path === "string" && typeof thing.scheme === "string";
}
let commandHistory = void 0;
function getCommandHistory(accessor) {
  if (!commandHistory) {
    commandHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, "commands");
  }
  return commandHistory;
}
let directoryHistory = void 0;
function getDirectoryHistory(accessor) {
  if (!directoryHistory) {
    directoryHistory = accessor.get(IInstantiationService).createInstance(TerminalPersistedHistory, "dirs");
  }
  return directoryHistory;
}
const shellFileHistory = /* @__PURE__ */ new Map();
async function getShellFileHistory(accessor, shellType) {
  const cached = shellFileHistory.get(shellType);
  if (cached === null) {
    return [];
  }
  if (cached !== void 0) {
    return cached;
  }
  let result;
  switch (shellType) {
    case "bash":
      result = await fetchBashHistory(accessor);
      break;
    case "pwsh":
      result = await fetchPwshHistory(accessor);
      break;
    case "zsh":
      result = await fetchZshHistory(accessor);
      break;
    case "fish":
      result = await fetchFishHistory(accessor);
      break;
    default:
      return [];
  }
  if (result === void 0) {
    shellFileHistory.set(shellType, null);
    return [];
  }
  const array = Array.from(result);
  shellFileHistory.set(shellType, array);
  return array;
}
function clearShellFileHistory() {
  shellFileHistory.clear();
}
let TerminalPersistedHistory = class TerminalPersistedHistory2 extends Disposable {
  get entries() {
    this._ensureUpToDate();
    return this._entries.entries();
  }
  constructor(_storageDataKey, _configurationService, _storageService) {
    super();
    this._storageDataKey = _storageDataKey;
    this._configurationService = _configurationService;
    this._storageService = _storageService;
    this._timestamp = 0;
    this._isReady = false;
    this._isStale = true;
    this._entries = new LRUCache(this._getHistoryLimit());
    this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("terminal.integrated.shellIntegration.history")) {
        this._entries.limit = this._getHistoryLimit();
      }
    });
    this._storageService.onDidChangeValue((e) => {
      if (e.key === this._getTimestampStorageKey() && !this._isStale) {
        this._isStale = this._storageService.getNumber(this._getTimestampStorageKey(), -1, 0) !== this._timestamp;
      }
    });
  }
  add(key, value) {
    this._ensureUpToDate();
    this._entries.set(key, value);
    this._saveState();
  }
  remove(key) {
    this._ensureUpToDate();
    this._entries.delete(key);
    this._saveState();
  }
  clear() {
    this._ensureUpToDate();
    this._entries.clear();
    this._saveState();
  }
  _ensureUpToDate() {
    if (!this._isReady) {
      this._loadState();
      this._isReady = true;
    }
    if (this._isStale) {
      this._entries.clear();
      this._loadState();
      this._isStale = false;
    }
  }
  _loadState() {
    this._timestamp = this._storageService.getNumber(this._getTimestampStorageKey(), -1, 0);
    const serialized = this._loadPersistedState();
    if (serialized) {
      for (const entry of serialized.entries) {
        this._entries.set(entry.key, entry.value);
      }
    }
  }
  _loadPersistedState() {
    const raw = this._storageService.get(this._getEntriesStorageKey(), -1);
    if (raw === void 0 || raw.length === 0) {
      return void 0;
    }
    let serialized = void 0;
    try {
      serialized = JSON.parse(raw);
    } catch {
      return void 0;
    }
    return serialized;
  }
  _saveState() {
    const serialized = { entries: [] };
    this._entries.forEach((value, key) => serialized.entries.push({ key, value }));
    this._storageService.store(this._getEntriesStorageKey(), JSON.stringify(serialized), -1, 1);
    this._timestamp = Date.now();
    this._storageService.store(this._getTimestampStorageKey(), this._timestamp, -1, 1);
  }
  _getHistoryLimit() {
    const historyLimit = this._configurationService.getValue("terminal.integrated.shellIntegration.history");
    return typeof historyLimit === "number" ? historyLimit : 100;
  }
  _getTimestampStorageKey() {
    return `${"terminal.history.timestamp"}.${this._storageDataKey}`;
  }
  _getEntriesStorageKey() {
    return `${"terminal.history.entries"}.${this._storageDataKey}`;
  }
};
TerminalPersistedHistory = __decorate([
  __param(1, IConfigurationService),
  __param(2, IStorageService)
], TerminalPersistedHistory);
async function fetchBashHistory(accessor) {
  const fileService = accessor.get(IFileService);
  const remoteAgentService = accessor.get(IRemoteAgentService);
  const remoteEnvironment = await remoteAgentService.getEnvironment();
  if ((remoteEnvironment == null ? void 0 : remoteEnvironment.os) === 1 || !remoteEnvironment && isWindows) {
    return void 0;
  }
  const content = await fetchFileContents(env["HOME"], ".bash_history", false, fileService, remoteAgentService);
  if (content === void 0) {
    return void 0;
  }
  const fileLines = content.split("\n");
  const result = /* @__PURE__ */ new Set();
  let currentLine;
  let currentCommand = void 0;
  let wrapChar = void 0;
  for (let i = 0; i < fileLines.length; i++) {
    currentLine = fileLines[i];
    if (currentCommand === void 0) {
      currentCommand = currentLine;
    } else {
      currentCommand += `
${currentLine}`;
    }
    for (let c = 0; c < currentLine.length; c++) {
      if (wrapChar) {
        if (currentLine[c] === wrapChar) {
          wrapChar = void 0;
        }
      } else {
        if (currentLine[c].match(/['"]/)) {
          wrapChar = currentLine[c];
        }
      }
    }
    if (wrapChar === void 0) {
      if (currentCommand.length > 0) {
        result.add(currentCommand.trim());
      }
      currentCommand = void 0;
    }
  }
  return result.values();
}
async function fetchZshHistory(accessor) {
  const fileService = accessor.get(IFileService);
  const remoteAgentService = accessor.get(IRemoteAgentService);
  const remoteEnvironment = await remoteAgentService.getEnvironment();
  if ((remoteEnvironment == null ? void 0 : remoteEnvironment.os) === 1 || !remoteEnvironment && isWindows) {
    return void 0;
  }
  const content = await fetchFileContents(env["HOME"], ".zsh_history", false, fileService, remoteAgentService);
  if (content === void 0) {
    return void 0;
  }
  const fileLines = content.split(/\:\s\d+\:\d+;/);
  const result = /* @__PURE__ */ new Set();
  for (let i = 0; i < fileLines.length; i++) {
    const sanitized = fileLines[i].replace(/\\\n/g, "\n").trim();
    if (sanitized.length > 0) {
      result.add(sanitized);
    }
  }
  return result.values();
}
async function fetchPwshHistory(accessor) {
  const fileService = accessor.get(IFileService);
  const remoteAgentService = accessor.get(IRemoteAgentService);
  let folderPrefix;
  let filePath;
  const remoteEnvironment = await remoteAgentService.getEnvironment();
  const isFileWindows = (remoteEnvironment == null ? void 0 : remoteEnvironment.os) === 1 || !remoteEnvironment && isWindows;
  if (isFileWindows) {
    folderPrefix = env["APPDATA"];
    filePath = "\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt";
  } else {
    folderPrefix = env["HOME"];
    filePath = ".local/share/powershell/PSReadline/ConsoleHost_history.txt";
  }
  const content = await fetchFileContents(folderPrefix, filePath, isFileWindows, fileService, remoteAgentService);
  if (content === void 0) {
    return void 0;
  }
  const fileLines = content.split("\n");
  const result = /* @__PURE__ */ new Set();
  let currentLine;
  let currentCommand = void 0;
  let wrapChar = void 0;
  for (let i = 0; i < fileLines.length; i++) {
    currentLine = fileLines[i];
    if (currentCommand === void 0) {
      currentCommand = currentLine;
    } else {
      currentCommand += `
${currentLine}`;
    }
    if (!currentLine.endsWith("`")) {
      const sanitized = currentCommand.trim();
      if (sanitized.length > 0) {
        result.add(sanitized);
      }
      currentCommand = void 0;
      continue;
    }
    for (let c = 0; c < currentLine.length; c++) {
      if (wrapChar) {
        if (currentLine[c] === wrapChar) {
          wrapChar = void 0;
        }
      } else {
        if (currentLine[c].match(/`/)) {
          wrapChar = currentLine[c];
        }
      }
    }
    if (!wrapChar) {
      const sanitized = currentCommand.trim();
      if (sanitized.length > 0) {
        result.add(sanitized);
      }
      currentCommand = void 0;
    } else {
      currentCommand = currentCommand.replace(/`$/, "");
      wrapChar = void 0;
    }
  }
  return result.values();
}
async function fetchFishHistory(accessor) {
  const fileService = accessor.get(IFileService);
  const remoteAgentService = accessor.get(IRemoteAgentService);
  const remoteEnvironment = await remoteAgentService.getEnvironment();
  if ((remoteEnvironment == null ? void 0 : remoteEnvironment.os) === 1 || !remoteEnvironment && isWindows) {
    return void 0;
  }
  const overridenDataHome = env["XDG_DATA_HOME"];
  const content = await (overridenDataHome ? fetchFileContents(env["XDG_DATA_HOME"], "fish/fish_history", false, fileService, remoteAgentService) : fetchFileContents(env["HOME"], ".local/share/fish/fish_history", false, fileService, remoteAgentService));
  if (content === void 0) {
    return void 0;
  }
  const result = /* @__PURE__ */ new Set();
  const cmds = content.split("\n").filter((x) => x.startsWith("- cmd:")).map((x) => x.substring(6).trimStart());
  for (let i = 0; i < cmds.length; i++) {
    const sanitized = sanitizeFishHistoryCmd(cmds[i]).trim();
    if (sanitized.length > 0) {
      result.add(sanitized);
    }
  }
  return result.values();
}
function sanitizeFishHistoryCmd(cmd) {
  return repeatedReplace(/(^|[^\\])((?:\\\\)*)(\\n)/g, cmd, "$1$2\n");
}
function repeatedReplace(pattern, value, replaceValue) {
  let last;
  let current = value;
  while (true) {
    last = current;
    current = current.replace(pattern, replaceValue);
    if (current === last) {
      return current;
    }
  }
}
async function fetchFileContents(folderPrefix, filePath, isFileWindows, fileService, remoteAgentService) {
  var _a2;
  if (!folderPrefix) {
    return void 0;
  }
  const isRemote = !!((_a2 = remoteAgentService.getConnection()) == null ? void 0 : _a2.remoteAuthority);
  const historyFileUri = URI.from({
    scheme: isRemote ? Schemas.vscodeRemote : Schemas.file,
    path: (isFileWindows ? win32.join : posix.join)(folderPrefix, filePath)
  });
  let content;
  try {
    content = await fileService.readFile(historyFileUri);
  } catch (e) {
    if (e instanceof FileOperationError && e.fileOperationResult === 1) {
      return void 0;
    }
    throw e;
  }
  if (content === void 0) {
    return void 0;
  }
  return content.value.toString();
}
const switchTerminalActionViewItemSeparator = "─────────";
const switchTerminalShowTabsTitle = localize("showTerminalTabs", "Show Tabs");
const category = terminalStrings.actionCategory;
async function getCwdForSplit(configHelper, instance, folders, commandService) {
  switch (configHelper.config.splitCwd) {
    case "workspaceRoot":
      if (folders !== void 0 && commandService !== void 0) {
        if (folders.length === 1) {
          return folders[0].uri;
        } else if (folders.length > 1) {
          const options = {
            placeHolder: localize(
              "workbench.action.terminal.newWorkspacePlaceholder",
              "Select current working directory for new terminal"
            )
          };
          const workspace = await commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID, [options]);
          if (!workspace) {
            return void 0;
          }
          return Promise.resolve(workspace.uri);
        }
      }
      return "";
    case "initial":
      return instance.getInitialCwd();
    case "inherited":
      return instance.getCwd();
  }
}
const terminalSendSequenceCommand = async (accessor, args) => {
  const instance = accessor.get(ITerminalService).activeInstance;
  if (instance) {
    const text = isObject(args) && "text" in args ? toOptionalString(args.text) : void 0;
    if (!text) {
      return;
    }
    const configurationResolverService = accessor.get(IConfigurationResolverService);
    const workspaceContextService = accessor.get(IWorkspaceContextService);
    const historyService = accessor.get(IHistoryService);
    const activeWorkspaceRootUri = historyService.getLastActiveWorkspaceRoot(instance.isRemote ? Schemas.vscodeRemote : Schemas.file);
    const lastActiveWorkspaceRoot = activeWorkspaceRootUri ? withNullAsUndefined(workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri)) : void 0;
    const resolvedText = await configurationResolverService.resolveAsync(lastActiveWorkspaceRoot, text);
    instance.sendText(resolvedText, false);
  }
};
let TerminalLaunchHelpAction = class TerminalLaunchHelpAction2 extends Action {
  constructor(_openerService) {
    super("workbench.action.terminal.launchHelp", localize("terminalLaunchHelp", "Open Help"));
    this._openerService = _openerService;
  }
  async run() {
    this._openerService.open("https://aka.ms/vscode-troubleshoot-terminal-launch");
  }
};
TerminalLaunchHelpAction = __decorate([
  __param(0, IOpenerService)
], TerminalLaunchHelpAction);
function registerTerminalAction(options) {
  options.f1 = options.f1 ?? true;
  options.category = options.category ?? category;
  options.precondition = options.precondition ?? TerminalContextKeys.processSupported;
  const runFunc = options.run;
  const strictOptions = options;
  delete strictOptions["run"];
  return registerAction2(class extends Action2 {
    constructor() {
      super(strictOptions);
    }
    run(accessor, args) {
      return runFunc(getTerminalServices(accessor), accessor, args);
    }
  });
}
function registerActiveInstanceAction(options) {
  const originalRun = options.run;
  return registerTerminalAction({
    ...options,
    run: (c, accessor, args) => {
      const activeInstance = c.service.activeInstance;
      if (activeInstance) {
        return originalRun(activeInstance, c, accessor, args);
      }
    }
  });
}
function registerActiveXtermAction(options) {
  const originalRun = options.run;
  return registerTerminalAction({
    ...options,
    run: (c, accessor, args) => {
      const activeDetached = Iterable.find(c.service.detachedXterms, (d) => d.isFocused);
      if (activeDetached) {
        return originalRun(activeDetached, accessor, void 0, args);
      }
      const activeInstance = c.service.activeInstance;
      if (activeInstance == null ? void 0 : activeInstance.xterm) {
        return originalRun(activeInstance.xterm, accessor, activeInstance, args);
      }
    }
  });
}
function getTerminalServices(accessor) {
  return {
    service: accessor.get(ITerminalService),
    groupService: accessor.get(ITerminalGroupService),
    instanceService: accessor.get(ITerminalInstanceService),
    editorService: accessor.get(ITerminalEditorService),
    profileService: accessor.get(ITerminalProfileService),
    profileResolverService: accessor.get(ITerminalProfileResolverService)
  };
}
function registerTerminalActions() {
  registerTerminalAction({
    id: "workbench.action.terminal.newInActiveWorkspace",
    title: { value: localize(
      "workbench.action.terminal.newInActiveWorkspace",
      "Create New Terminal (In Active Workspace)"
    ), original: "Create New Terminal (In Active Workspace)" },
    run: async (c) => {
      if (c.service.isProcessSupportRegistered) {
        const instance = await c.service.createTerminal({ location: c.service.defaultLocation });
        if (!instance) {
          return;
        }
        c.service.setActiveInstance(instance);
      }
      await c.groupService.showPanel(true);
    }
  });
  refreshTerminalActions([]);
  registerTerminalAction({
    id: "workbench.action.createTerminalEditor",
    title: { value: localize(
      "workbench.action.terminal.createTerminalEditor",
      "Create New Terminal in Editor Area"
    ), original: "Create New Terminal in Editor Area" },
    run: async (c, _, args) => {
      const options = isObject(args) && "location" in args ? args : { location: TerminalLocation.Editor };
      const instance = await c.service.createTerminal(options);
      instance.focusWhenReady();
    }
  });
  registerTerminalAction({
    id: "workbench.action.createTerminalEditorSameGroup",
    title: { value: localize(
      "workbench.action.terminal.createTerminalEditor",
      "Create New Terminal in Editor Area"
    ), original: "Create New Terminal in Editor Area" },
    f1: false,
    run: async (c, accessor, args) => {
      const editorGroupsService = accessor.get(IEditorGroupsService);
      const instance = await c.service.createTerminal({
        location: { viewColumn: editorGroupsService.activeGroup.index }
      });
      instance.focusWhenReady();
    }
  });
  registerTerminalAction({
    id: "workbench.action.createTerminalEditorSide",
    title: { value: localize(
      "workbench.action.terminal.createTerminalEditorSide",
      "Create New Terminal in Editor Area to the Side"
    ), original: "Create New Terminal in Editor Area to the Side" },
    run: async (c) => {
      const instance = await c.service.createTerminal({
        location: { viewColumn: SIDE_GROUP }
      });
      instance.focusWhenReady();
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.moveToEditor",
    title: terminalStrings.moveToEditor,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.terminalEditorActive.toNegated(), TerminalContextKeys.viewShowing),
    run: (activeInstance, c) => c.service.moveToEditor(activeInstance)
  });
  registerTerminalAction({
    id: "workbench.action.terminal.moveToEditorInstance",
    title: terminalStrings.moveToEditor,
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.isOpen),
    run: async (c, accessor) => {
      const selectedInstances = getSelectedInstances(accessor);
      if (!selectedInstances || selectedInstances.length === 0) {
        return;
      }
      for (const instance of selectedInstances) {
        c.service.moveToEditor(instance);
      }
      selectedInstances[selectedInstances.length - 1].focus();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.moveToTerminalPanel",
    title: terminalStrings.moveToTerminalPanel,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.terminalEditorActive),
    run: (c, _, args) => {
      const source = toOptionalUri(args) ?? c.editorService.activeInstance;
      if (source) {
        c.service.moveToTerminalView(source);
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.showTabs",
    title: { value: localize("workbench.action.terminal.showTabs", "Show Tabs"), original: "Show Tabs" },
    f1: false,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => c.groupService.showTabs()
  });
  registerTerminalAction({
    id: "workbench.action.terminal.focusPreviousPane",
    title: { value: localize(
      "workbench.action.terminal.focusPreviousPane",
      "Focus Previous Terminal in Terminal Group"
    ), original: "Focus Previous Terminal in Terminal Group" },
    keybinding: {
      primary: 512 | 15,
      secondary: [512 | 16],
      mac: {
        primary: 512 | 2048 | 15,
        secondary: [512 | 2048 | 16]
      },
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (c) => {
      var _a2;
      (_a2 = c.groupService.activeGroup) == null ? void 0 : _a2.focusPreviousPane();
      await c.groupService.showPanel(true);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.focusNextPane",
    title: { value: localize(
      "workbench.action.terminal.focusNextPane",
      "Focus Next Terminal in Terminal Group"
    ), original: "Focus Next Terminal in Terminal Group" },
    keybinding: {
      primary: 512 | 17,
      secondary: [512 | 18],
      mac: {
        primary: 512 | 2048 | 17,
        secondary: [512 | 2048 | 18]
      },
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (c) => {
      var _a2;
      (_a2 = c.groupService.activeGroup) == null ? void 0 : _a2.focusNextPane();
      await c.groupService.showPanel(true);
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.runRecentCommand",
    title: { value: localize("workbench.action.terminal.runRecentCommand", "Run Recent Command..."), original: "Run Recent Command..." },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    keybinding: [
      {
        primary: 2048 | 48,
        mac: { primary: 256 | 48 },
        when: ContextKeyExpr.and(TerminalContextKeys.focus, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
        weight: 200
      },
      {
        primary: 2048 | 512 | 48,
        mac: { primary: 256 | 512 | 48 },
        when: ContextKeyExpr.and(TerminalContextKeys.focus, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
        weight: 200
      }
    ],
    run: async (activeInstance, c) => {
      await activeInstance.runRecent("command");
      if ((activeInstance == null ? void 0 : activeInstance.target) === TerminalLocation.Editor) {
        await c.editorService.revealActiveEditor();
      } else {
        await c.groupService.showPanel(false);
      }
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.copyLastCommandOutput",
    title: { value: localize("workbench.action.terminal.copyLastCommand", "Copy Last Command Output"), original: "Copy Last Command Output" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (instance, c, accessor) => {
      var _a2;
      const clipboardService = accessor.get(IClipboardService);
      const commands = (_a2 = instance.capabilities.get(2)) == null ? void 0 : _a2.commands;
      if (!commands || commands.length === 0) {
        return;
      }
      const command = commands[commands.length - 1];
      if (!(command == null ? void 0 : command.hasOutput())) {
        return;
      }
      const output = command.getOutput();
      if (isString(output)) {
        await clipboardService.writeText(output);
      }
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.goToRecentDirectory",
    title: { value: localize(
      "workbench.action.terminal.goToRecentDirectory",
      "Go to Recent Directory..."
    ), original: "Go to Recent Directory..." },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2048 | 37,
      when: TerminalContextKeys.focus,
      weight: 200
    },
    run: async (activeInstance, c) => {
      await activeInstance.runRecent("cwd");
      if ((activeInstance == null ? void 0 : activeInstance.target) === TerminalLocation.Editor) {
        await c.editorService.revealActiveEditor();
      } else {
        await c.groupService.showPanel(false);
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.resizePaneLeft",
    title: { value: localize("workbench.action.terminal.resizePaneLeft", "Resize Terminal Left"), original: "Resize Terminal Left" },
    keybinding: {
      linux: { primary: 2048 | 1024 | 15 },
      mac: { primary: 2048 | 256 | 15 },
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => {
      var _a2;
      return (_a2 = c.groupService.activeGroup) == null ? void 0 : _a2.resizePane(0);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.resizePaneRight",
    title: { value: localize("workbench.action.terminal.resizePaneRight", "Resize Terminal Right"), original: "Resize Terminal Right" },
    keybinding: {
      linux: { primary: 2048 | 1024 | 17 },
      mac: { primary: 2048 | 256 | 17 },
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => {
      var _a2;
      return (_a2 = c.groupService.activeGroup) == null ? void 0 : _a2.resizePane(1);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.resizePaneUp",
    title: { value: localize("workbench.action.terminal.resizePaneUp", "Resize Terminal Up"), original: "Resize Terminal Up" },
    keybinding: {
      mac: { primary: 2048 | 256 | 16 },
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => {
      var _a2;
      return (_a2 = c.groupService.activeGroup) == null ? void 0 : _a2.resizePane(2);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.resizePaneDown",
    title: { value: localize("workbench.action.terminal.resizePaneDown", "Resize Terminal Down"), original: "Resize Terminal Down" },
    keybinding: {
      mac: { primary: 2048 | 256 | 18 },
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => {
      var _a2;
      return (_a2 = c.groupService.activeGroup) == null ? void 0 : _a2.resizePane(3);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.focus",
    title: terminalStrings.focus,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (c) => {
      const instance = c.service.activeInstance || await c.service.createTerminal({ location: TerminalLocation.Panel });
      if (!instance) {
        return;
      }
      c.service.setActiveInstance(instance);
      return c.groupService.showPanel(true);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.focusTabs",
    title: { value: localize("workbench.action.terminal.focus.tabsView", "Focus Terminal Tabs View"), original: "Focus Terminal Tabs View" },
    keybinding: {
      primary: 2048 | 1024 | 93,
      weight: 200,
      when: ContextKeyExpr.or(TerminalContextKeys.tabsFocus, TerminalContextKeys.focus)
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => c.groupService.focusTabs()
  });
  registerTerminalAction({
    id: "workbench.action.terminal.focusNext",
    title: { value: localize("workbench.action.terminal.focusNext", "Focus Next Terminal Group"), original: "Focus Next Terminal Group" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2048 | 12,
      mac: {
        primary: 2048 | 1024 | 94
      },
      when: ContextKeyExpr.and(TerminalContextKeys.focus, TerminalContextKeys.editorFocus.negate()),
      weight: 200
    },
    run: async (c) => {
      c.groupService.setActiveGroupToNext();
      await c.groupService.showPanel(true);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.focusPrevious",
    title: { value: localize("workbench.action.terminal.focusPrevious", "Focus Previous Terminal Group"), original: "Focus Previous Terminal Group" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2048 | 11,
      mac: {
        primary: 2048 | 1024 | 92
      },
      when: ContextKeyExpr.and(TerminalContextKeys.focus, TerminalContextKeys.editorFocus.negate()),
      weight: 200
    },
    run: async (c) => {
      c.groupService.setActiveGroupToPrevious();
      await c.groupService.showPanel(true);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.runSelectedText",
    title: { value: localize(
      "workbench.action.terminal.runSelectedText",
      "Run Selected Text In Active Terminal"
    ), original: "Run Selected Text In Active Terminal" },
    run: async (c, accessor) => {
      const codeEditorService = accessor.get(ICodeEditorService);
      const editor = codeEditorService.getActiveCodeEditor();
      if (!editor || !editor.hasModel()) {
        return;
      }
      const instance = await c.service.getActiveOrCreateInstance({ acceptsInput: true });
      const selection = editor.getSelection();
      let text;
      if (selection.isEmpty()) {
        text = editor.getModel().getLineContent(selection.selectionStartLineNumber).trim();
      } else {
        const endOfLinePreference = isWindows ? 1 : 2;
        text = editor.getModel().getValueInRange(selection, endOfLinePreference);
      }
      instance.sendText(text, true, true);
      await c.service.revealActiveTerminal();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.runActiveFile",
    title: { value: localize(
      "workbench.action.terminal.runActiveFile",
      "Run Active File In Active Terminal"
    ), original: "Run Active File In Active Terminal" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (c, accessor) => {
      const codeEditorService = accessor.get(ICodeEditorService);
      const notificationService = accessor.get(INotificationService);
      const workbenchEnvironmentService = accessor.get(IWorkbenchEnvironmentService);
      const editor = codeEditorService.getActiveCodeEditor();
      if (!editor || !editor.hasModel()) {
        return;
      }
      const instance = await c.service.getActiveOrCreateInstance({ acceptsInput: true });
      const isRemote = instance ? instance.isRemote : workbenchEnvironmentService.remoteAuthority ? true : false;
      const uri = editor.getModel().uri;
      if (!isRemote && uri.scheme !== Schemas.file && uri.scheme !== Schemas.vscodeUserData || isRemote && uri.scheme !== Schemas.vscodeRemote) {
        notificationService.warn(localize(
          "workbench.action.terminal.runActiveFile.noFile",
          "Only files on disk can be run in the terminal"
        ));
        return;
      }
      await instance.sendPath(uri, true);
      return c.groupService.showPanel();
    }
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.scrollDown",
    title: { value: localize("workbench.action.terminal.scrollDown", "Scroll Down (Line)"), original: "Scroll Down (Line)" },
    keybinding: {
      primary: 2048 | 512 | 12,
      linux: { primary: 2048 | 1024 | 18 },
      when: ContextKeyExpr.and(TerminalContextKeys.focusInAny, TerminalContextKeys.altBufferActive.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (xterm2) => xterm2.scrollDownLine()
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.scrollDownPage",
    title: { value: localize("workbench.action.terminal.scrollDownPage", "Scroll Down (Page)"), original: "Scroll Down (Page)" },
    keybinding: {
      primary: 1024 | 12,
      mac: { primary: 12 },
      when: ContextKeyExpr.and(TerminalContextKeys.focusInAny, TerminalContextKeys.altBufferActive.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (xterm2) => xterm2.scrollDownPage()
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.scrollToBottom",
    title: { value: localize("workbench.action.terminal.scrollToBottom", "Scroll to Bottom"), original: "Scroll to Bottom" },
    keybinding: {
      primary: 2048 | 13,
      linux: { primary: 1024 | 13 },
      when: ContextKeyExpr.and(TerminalContextKeys.focusInAny, TerminalContextKeys.altBufferActive.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (xterm2) => xterm2.scrollToBottom()
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.scrollUp",
    title: { value: localize("workbench.action.terminal.scrollUp", "Scroll Up (Line)"), original: "Scroll Up (Line)" },
    keybinding: {
      primary: 2048 | 512 | 11,
      linux: { primary: 2048 | 1024 | 16 },
      when: ContextKeyExpr.and(TerminalContextKeys.focusInAny, TerminalContextKeys.altBufferActive.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (xterm2) => xterm2.scrollUpLine()
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.scrollUpPage",
    title: { value: localize("workbench.action.terminal.scrollUpPage", "Scroll Up (Page)"), original: "Scroll Up (Page)" },
    f1: true,
    category,
    keybinding: {
      primary: 1024 | 11,
      mac: { primary: 11 },
      when: ContextKeyExpr.and(TerminalContextKeys.focusInAny, TerminalContextKeys.altBufferActive.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (xterm2) => xterm2.scrollUpPage()
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.scrollToTop",
    title: { value: localize("workbench.action.terminal.scrollToTop", "Scroll to Top"), original: "Scroll to Top" },
    keybinding: {
      primary: 2048 | 14,
      linux: { primary: 1024 | 14 },
      when: ContextKeyExpr.and(TerminalContextKeys.focusInAny, TerminalContextKeys.altBufferActive.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (xterm2) => xterm2.scrollToTop()
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.clearSelection",
    title: { value: localize("workbench.action.terminal.clearSelection", "Clear Selection"), original: "Clear Selection" },
    keybinding: {
      primary: 9,
      when: ContextKeyExpr.and(
        TerminalContextKeys.focusInAny,
        TerminalContextKeys.textSelected,
        TerminalContextKeys.notFindVisible
      ),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (xterm2) => {
      if (xterm2.hasSelection()) {
        xterm2.clearSelection();
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.changeIcon",
    title: terminalStrings.changeIcon,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c, _, args) => {
      var _a2;
      return (_a2 = getResourceOrActiveInstance(c, args)) == null ? void 0 : _a2.changeIcon();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.changeIconPanel",
    title: terminalStrings.changeIcon,
    f1: false,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => {
      var _a2;
      return (_a2 = c.groupService.activeInstance) == null ? void 0 : _a2.changeIcon();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.changeIconInstance",
    title: terminalStrings.changeIcon,
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.tabsSingularSelection),
    run: (c, accessor) => {
      var _a2;
      return (_a2 = getSelectedInstances(accessor)) == null ? void 0 : _a2[0].changeIcon();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.changeColor",
    title: terminalStrings.changeColor,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c, _, args) => {
      var _a2;
      return (_a2 = getResourceOrActiveInstance(c, args)) == null ? void 0 : _a2.changeColor();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.changeColorPanel",
    title: terminalStrings.changeColor,
    f1: false,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c) => {
      var _a2;
      return (_a2 = c.groupService.activeInstance) == null ? void 0 : _a2.changeColor();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.changeColorInstance",
    title: terminalStrings.changeColor,
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.tabsSingularSelection),
    run: (c, accessor) => {
      var _a2;
      return (_a2 = getSelectedInstances(accessor)) == null ? void 0 : _a2[0].changeColor();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.rename",
    title: terminalStrings.rename,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c, accessor, args) => renameWithQuickPick(c, accessor, args)
  });
  registerTerminalAction({
    id: "workbench.action.terminal.renamePanel",
    title: terminalStrings.rename,
    f1: false,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c, accessor) => renameWithQuickPick(c, accessor)
  });
  registerTerminalAction({
    id: "workbench.action.terminal.renameInstance",
    title: terminalStrings.rename,
    f1: false,
    keybinding: {
      primary: 60,
      mac: {
        primary: 3
      },
      when: ContextKeyExpr.and(TerminalContextKeys.tabsFocus),
      weight: 200
    },
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.tabsSingularSelection),
    run: async (c, accessor) => {
      var _a2;
      const notificationService = accessor.get(INotificationService);
      const instance = (_a2 = getSelectedInstances(accessor)) == null ? void 0 : _a2[0];
      if (!instance) {
        return;
      }
      c.service.setEditingTerminal(instance);
      c.service.setEditable(instance, {
        validationMessage: (value) => validateTerminalName(value),
        onFinish: async (value, success) => {
          c.service.setEditable(instance, null);
          c.service.setEditingTerminal(void 0);
          if (success) {
            try {
              await instance.rename(value);
            } catch (e) {
              notificationService.error(e);
            }
          }
        }
      });
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.detachSession",
    title: { value: localize("workbench.action.terminal.detachSession", "Detach Session"), original: "Detach Session" },
    run: (activeInstance) => activeInstance.detachProcessAndDispose(TerminalExitReason.User)
  });
  registerTerminalAction({
    id: "workbench.action.terminal.attachToSession",
    title: { value: localize("workbench.action.terminal.attachToSession", "Attach to Session"), original: "Attach to Session" },
    run: async (c, accessor) => {
      var _a2;
      const quickInputService = accessor.get(IQuickInputService);
      const labelService = accessor.get(ILabelService);
      const remoteAgentService = accessor.get(IRemoteAgentService);
      const notificationService = accessor.get(INotificationService);
      const remoteAuthority = ((_a2 = remoteAgentService.getConnection()) == null ? void 0 : _a2.remoteAuthority) ?? void 0;
      const backend = await accessor.get(ITerminalInstanceService).getBackend(remoteAuthority);
      if (!backend) {
        throw new Error(`No backend registered for remote authority '${remoteAuthority}'`);
      }
      const terms = await backend.listProcesses();
      backend.reduceConnectionGraceTime();
      const unattachedTerms = terms.filter((term) => !c.service.isAttachedToTerminal(term));
      const items = unattachedTerms.map((term) => {
        const cwdLabel = labelService.getUriLabel(URI.file(term.cwd));
        return {
          label: term.title,
          detail: term.workspaceName ? `${term.workspaceName} ⸱ ${cwdLabel}` : cwdLabel,
          description: term.pid ? String(term.pid) : "",
          term
        };
      });
      if (items.length === 0) {
        notificationService.info(localize("noUnattachedTerminals", "There are no unattached terminals to attach to"));
        return;
      }
      const selected = await quickInputService.pick(items, { canPickMany: false });
      if (selected) {
        const instance = await c.service.createTerminal({
          config: { attachPersistentProcess: selected.term }
        });
        c.service.setActiveInstance(instance);
        await focusActiveTerminal(instance, c);
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.quickOpenTerm",
    title: { value: localize("quickAccessTerminal", "Switch Active Terminal"), original: "Switch Active Terminal" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c, accessor) => accessor.get(IQuickInputService).quickAccess.show(TerminalQuickAccessProvider.PREFIX)
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.scrollToPreviousCommand",
    title: { value: localize(
      "workbench.action.terminal.scrollToPreviousCommand",
      "Scroll To Previous Command"
    ), original: "Scroll To Previous Command" },
    keybinding: {
      primary: 2048 | 16,
      when: ContextKeyExpr.and(TerminalContextKeys.focus, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (activeInstance) => {
      var _a2;
      return (_a2 = activeInstance.xterm) == null ? void 0 : _a2.markTracker.scrollToPreviousMark(void 0, void 0, activeInstance.capabilities.has(2));
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.scrollToNextCommand",
    title: { value: localize("workbench.action.terminal.scrollToNextCommand", "Scroll To Next Command"), original: "Scroll To Next Command" },
    keybinding: {
      primary: 2048 | 18,
      when: ContextKeyExpr.and(TerminalContextKeys.focus, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (activeInstance) => {
      var _a2;
      (_a2 = activeInstance.xterm) == null ? void 0 : _a2.markTracker.scrollToNextMark();
      activeInstance.focus();
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.selectToPreviousCommand",
    title: { value: localize(
      "workbench.action.terminal.selectToPreviousCommand",
      "Select To Previous Command"
    ), original: "Select To Previous Command" },
    keybinding: {
      primary: 2048 | 1024 | 16,
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (activeInstance) => {
      var _a2;
      (_a2 = activeInstance.xterm) == null ? void 0 : _a2.markTracker.selectToPreviousMark();
      activeInstance.focus();
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.selectToNextCommand",
    title: { value: localize("workbench.action.terminal.selectToNextCommand", "Select To Next Command"), original: "Select To Next Command" },
    keybinding: {
      primary: 2048 | 1024 | 18,
      when: TerminalContextKeys.focus,
      weight: 200
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (activeInstance) => {
      var _a2;
      (_a2 = activeInstance.xterm) == null ? void 0 : _a2.markTracker.selectToNextMark();
      activeInstance.focus();
    }
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.selectToPreviousLine",
    title: { value: localize(
      "workbench.action.terminal.selectToPreviousLine",
      "Select To Previous Line"
    ), original: "Select To Previous Line" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (xterm2, _, instance) => {
      xterm2.markTracker.selectToPreviousLine();
      (instance || xterm2).focus();
    }
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.selectToNextLine",
    title: { value: localize("workbench.action.terminal.selectToNextLine", "Select To Next Line"), original: "Select To Next Line" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (xterm2, _, instance) => {
      xterm2.markTracker.selectToNextLine();
      (instance || xterm2).focus();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.sendSequence",
    title: terminalStrings.sendSequence,
    f1: false,
    description: {
      description: terminalStrings.sendSequence.value,
      args: [{
        name: "args",
        schema: {
          type: "object",
          required: ["text"],
          properties: {
            text: {
              description: localize("sendSequence", "The sequence of text to send to the terminal"),
              type: "string"
            }
          }
        }
      }]
    },
    run: (c, accessor, args) => terminalSendSequenceCommand(accessor, args)
  });
  registerTerminalAction({
    id: "workbench.action.terminal.newWithCwd",
    title: terminalStrings.newWithCwd,
    description: {
      description: terminalStrings.newWithCwd.value,
      args: [{
        name: "args",
        schema: {
          type: "object",
          required: ["cwd"],
          properties: {
            cwd: {
              description: localize(
                "workbench.action.terminal.newWithCwd.cwd",
                "The directory to start the terminal at"
              ),
              type: "string"
            }
          }
        }
      }]
    },
    run: async (c, _, args) => {
      const cwd = isObject(args) && "cwd" in args ? toOptionalString(args.cwd) : void 0;
      const instance = await c.service.createTerminal({ cwd });
      if (!instance) {
        return;
      }
      c.service.setActiveInstance(instance);
      await focusActiveTerminal(instance, c);
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.renameWithArg",
    title: terminalStrings.renameWithArgs,
    description: {
      description: terminalStrings.renameWithArgs.value,
      args: [{
        name: "args",
        schema: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              description: localize(
                "workbench.action.terminal.renameWithArg.name",
                "The new name for the terminal"
              ),
              type: "string",
              minLength: 1
            }
          }
        }
      }]
    },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (activeInstance, c, accessor, args) => {
      const notificationService = accessor.get(INotificationService);
      const name = isObject(args) && "name" in args ? toOptionalString(args.name) : void 0;
      if (!name) {
        notificationService.warn(localize(
          "workbench.action.terminal.renameWithArg.noName",
          "No name argument provided"
        ));
        return;
      }
      activeInstance.rename(name);
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.relaunch",
    title: { value: localize("workbench.action.terminal.relaunch", "Relaunch Active Terminal"), original: "Relaunch Active Terminal" },
    run: (activeInstance) => activeInstance.relaunch()
  });
  registerTerminalAction({
    id: "workbench.action.terminal.split",
    title: terminalStrings.split,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.webExtensionContributedProfile
    ),
    keybinding: {
      primary: 2048 | 1024 | 26,
      weight: 200,
      mac: {
        primary: 2048 | 93,
        secondary: [256 | 1024 | 26]
      },
      when: TerminalContextKeys.focus
    },
    icon: Codicon.splitHorizontal,
    run: async (c, accessor, args) => {
      const optionsOrProfile = isObject(args) ? args : void 0;
      const commandService = accessor.get(ICommandService);
      const workspaceContextService = accessor.get(IWorkspaceContextService);
      const options = convertOptionsOrProfileToOptions(optionsOrProfile);
      const activeInstance = (await c.service.getInstanceHost(options == null ? void 0 : options.location)).activeInstance;
      if (!activeInstance) {
        return;
      }
      const cwd = await getCwdForSplit(c.service.configHelper, activeInstance, workspaceContextService.getWorkspace().folders, commandService);
      if (cwd === void 0) {
        return;
      }
      const instance = await c.service.createTerminal({ location: { parentTerminal: activeInstance }, config: options == null ? void 0 : options.config, cwd });
      await focusActiveTerminal(instance, c);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.splitInstance",
    title: terminalStrings.split,
    f1: false,
    keybinding: {
      primary: 2048 | 1024 | 26,
      mac: {
        primary: 2048 | 93,
        secondary: [256 | 1024 | 26]
      },
      weight: 200,
      when: TerminalContextKeys.tabsFocus
    },
    run: async (c, accessor) => {
      const instances = getSelectedInstances(accessor);
      if (instances) {
        const promises = [];
        for (const t of instances) {
          promises.push((async () => {
            await c.service.createTerminal({ location: { parentTerminal: t } });
            await c.groupService.showPanel(true);
          })());
        }
        await Promise.all(promises);
      }
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.unsplit",
    title: terminalStrings.unsplit,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (activeInstance, c) => c.groupService.unsplitInstance(activeInstance)
  });
  registerTerminalAction({
    id: "workbench.action.terminal.unsplitInstance",
    title: terminalStrings.unsplit,
    f1: false,
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (c, accessor) => {
      const instances = getSelectedInstances(accessor);
      if ((instances == null ? void 0 : instances.length) === 1) {
        const group = c.groupService.getGroupForInstance(instances[0]);
        if (group && (group == null ? void 0 : group.terminalInstances.length) > 1) {
          c.groupService.unsplitInstance(instances[0]);
        }
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.joinInstance",
    title: { value: localize("workbench.action.terminal.joinInstance", "Join Terminals"), original: "Join Terminals" },
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.tabsSingularSelection.toNegated()),
    run: async (c, accessor) => {
      const instances = getSelectedInstances(accessor);
      if (instances && instances.length > 1) {
        c.groupService.joinInstances(instances);
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.join",
    title: { value: localize("workbench.action.terminal.join", "Join Terminals"), original: "Join Terminals" },
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    )),
    run: async (c, accessor) => {
      const themeService = accessor.get(IThemeService);
      const notificationService = accessor.get(INotificationService);
      const quickInputService = accessor.get(IQuickInputService);
      const picks = [];
      if (c.groupService.instances.length <= 1) {
        notificationService.warn(localize(
          "workbench.action.terminal.join.insufficientTerminals",
          "Insufficient terminals for the join action"
        ));
        return;
      }
      const otherInstances = c.groupService.instances.filter((i) => {
        var _a2;
        return i.instanceId !== ((_a2 = c.groupService.activeInstance) == null ? void 0 : _a2.instanceId);
      });
      for (const terminal of otherInstances) {
        const group = c.groupService.getGroupForInstance(terminal);
        if ((group == null ? void 0 : group.terminalInstances.length) === 1) {
          const iconId = getIconId(accessor, terminal);
          const label = `$(${iconId}): ${terminal.title}`;
          const iconClasses = [];
          const colorClass = getColorClass(terminal);
          if (colorClass) {
            iconClasses.push(colorClass);
          }
          const uriClasses = getUriClasses(terminal, themeService.getColorTheme().type);
          if (uriClasses) {
            iconClasses.push(...uriClasses);
          }
          picks.push({
            terminal,
            label,
            iconClasses
          });
        }
      }
      if (picks.length === 0) {
        notificationService.warn(localize(
          "workbench.action.terminal.join.onlySplits",
          "All terminals are joined already"
        ));
        return;
      }
      const result = await quickInputService.pick(picks, {});
      if (result) {
        c.groupService.joinInstances([result.terminal, c.groupService.activeInstance]);
      }
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.splitInActiveWorkspace",
    title: { value: localize(
      "workbench.action.terminal.splitInActiveWorkspace",
      "Split Terminal (In Active Workspace)"
    ), original: "Split Terminal (In Active Workspace)" },
    run: async (instance, c) => {
      const newInstance = await c.service.createTerminal({ location: { parentTerminal: instance } });
      if ((newInstance == null ? void 0 : newInstance.target) !== TerminalLocation.Editor) {
        await c.groupService.showPanel(true);
      }
    }
  });
  registerActiveXtermAction({
    id: "workbench.action.terminal.selectAll",
    title: { value: localize("workbench.action.terminal.selectAll", "Select All"), original: "Select All" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    keybinding: [{
      primary: 0,
      mac: { primary: 2048 | 31 },
      weight: 200,
      when: TerminalContextKeys.focusInAny
    }],
    run: (xterm2) => xterm2.selectAll()
  });
  registerTerminalAction({
    id: "workbench.action.terminal.new",
    title: { value: localize("workbench.action.terminal.new", "Create New Terminal"), original: "Create New Terminal" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.webExtensionContributedProfile
    ),
    icon: newTerminalIcon,
    keybinding: {
      primary: 2048 | 1024 | 91,
      mac: { primary: 256 | 1024 | 91 },
      weight: 200
    },
    run: async (c, accessor, args) => {
      var _a2;
      let eventOrOptions = isObject(args) ? args : void 0;
      const workspaceContextService = accessor.get(IWorkspaceContextService);
      const commandService = accessor.get(ICommandService);
      const folders = workspaceContextService.getWorkspace().folders;
      if (eventOrOptions && eventOrOptions instanceof MouseEvent && (eventOrOptions.altKey || eventOrOptions.ctrlKey)) {
        await c.service.createTerminal({ location: { splitActiveTerminal: true } });
        return;
      }
      if (c.service.isProcessSupportRegistered) {
        eventOrOptions = !eventOrOptions || eventOrOptions instanceof MouseEvent ? {} : eventOrOptions;
        let instance;
        if (folders.length <= 1) {
          instance = await c.service.createTerminal(eventOrOptions);
        } else {
          const cwd = (_a2 = await pickTerminalCwd(accessor)) == null ? void 0 : _a2.cwd;
          if (!cwd) {
            return;
          }
          eventOrOptions.cwd = cwd;
          instance = await c.service.createTerminal(eventOrOptions);
        }
        c.service.setActiveInstance(instance);
        await focusActiveTerminal(instance, c);
      } else {
        if (c.profileService.contributedProfiles.length > 0) {
          commandService.executeCommand("workbench.action.terminal.newWithProfile");
        } else {
          commandService.executeCommand("workbench.action.terminal.toggleTerminal");
        }
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.kill",
    title: { value: localize("workbench.action.terminal.kill", "Kill the Active Terminal Instance"), original: "Kill the Active Terminal Instance" },
    precondition: ContextKeyExpr.or(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.isOpen),
    icon: killTerminalIcon,
    run: async (c) => {
      const instance = c.groupService.activeInstance;
      if (!instance) {
        return;
      }
      await c.service.safeDisposeTerminal(instance);
      if (c.groupService.instances.length > 0) {
        await c.groupService.showPanel(true);
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.killAll",
    title: { value: localize("workbench.action.terminal.killAll", "Kill All Terminals"), original: "Kill All Terminals" },
    precondition: ContextKeyExpr.or(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.isOpen),
    icon: Codicon.trash,
    run: async (c) => {
      const disposePromises = [];
      for (const instance of c.service.instances) {
        disposePromises.push(c.service.safeDisposeTerminal(instance));
      }
      await Promise.all(disposePromises);
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.killEditor",
    title: { value: localize(
      "workbench.action.terminal.killEditor",
      "Kill the Active Terminal in Editor Area"
    ), original: "Kill the Active Terminal in Editor Area" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    keybinding: {
      primary: 2048 | 53,
      win: { primary: 2048 | 62, secondary: [2048 | 53] },
      weight: 200,
      when: ContextKeyExpr.and(TerminalContextKeys.focus, ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal), TerminalContextKeys.editorFocus)
    },
    run: (c, accessor) => accessor.get(ICommandService).executeCommand(CLOSE_EDITOR_COMMAND_ID)
  });
  registerTerminalAction({
    id: "workbench.action.terminal.killInstance",
    title: terminalStrings.kill,
    f1: false,
    precondition: ContextKeyExpr.or(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.isOpen),
    keybinding: {
      primary: 20,
      mac: {
        primary: 2048 | 1,
        secondary: [20]
      },
      weight: 200,
      when: TerminalContextKeys.tabsFocus
    },
    run: async (c, accessor) => {
      var _a2;
      const selectedInstances = getSelectedInstances(accessor);
      if (!selectedInstances) {
        return;
      }
      const listService = accessor.get(IListService);
      const disposePromises = [];
      for (const instance of selectedInstances) {
        disposePromises.push(c.service.safeDisposeTerminal(instance));
      }
      await Promise.all(disposePromises);
      if (c.service.instances.length > 0) {
        c.groupService.focusTabs();
        (_a2 = listService.lastFocusedList) == null ? void 0 : _a2.focusNext();
      }
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.focusHover",
    title: terminalStrings.focusHover,
    precondition: ContextKeyExpr.or(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.isOpen),
    keybinding: {
      primary: KeyChord(2048 | 41, 2048 | 39),
      weight: 200,
      when: ContextKeyExpr.or(TerminalContextKeys.tabsFocus, TerminalContextKeys.focus)
    },
    run: (c) => c.groupService.focusHover()
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.clear",
    title: { value: localize("workbench.action.terminal.clear", "Clear"), original: "Clear" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    keybinding: [{
      primary: 0,
      mac: { primary: 2048 | 41 },
      weight: 200 + 1,
      when: ContextKeyExpr.and(TerminalContextKeys.focus, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate())
    }],
    run: (activeInstance) => activeInstance.clearBuffer()
  });
  registerTerminalAction({
    id: "workbench.action.terminal.selectDefaultShell",
    title: { value: localize("workbench.action.terminal.selectDefaultShell", "Select Default Profile"), original: "Select Default Profile" },
    run: (c) => c.service.showProfileQuickPick("setDefault")
  });
  registerTerminalAction({
    id: "workbench.action.terminal.openSettings",
    title: { value: localize("workbench.action.terminal.openSettings", "Configure Terminal Settings"), original: "Configure Terminal Settings" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: (c, accessor) => accessor.get(IPreferencesService).openSettings({ jsonEditor: false, query: "@feature:terminal" })
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.setDimensions",
    title: { value: localize("workbench.action.terminal.setFixedDimensions", "Set Fixed Dimensions"), original: "Set Fixed Dimensions" },
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.isOpen),
    run: (activeInstance) => activeInstance.setFixedDimensions()
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.sizeToContentWidth",
    title: { value: localize(
      "workbench.action.terminal.sizeToContentWidth",
      "Toggle Size to Content Width"
    ), original: "Toggle Size to Content Width" },
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.isOpen),
    keybinding: {
      primary: 512 | 56,
      weight: 200,
      when: TerminalContextKeys.focus
    },
    run: (instancactiveInstance) => instancactiveInstance.toggleSizeToContentWidth()
  });
  registerTerminalAction({
    id: "workbench.action.terminal.sizeToContentWidthInstance",
    title: terminalStrings.toggleSizeToContentWidth,
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.focus),
    run: (c, accessor) => {
      var _a2;
      return (_a2 = getSelectedInstances(accessor)) == null ? void 0 : _a2[0].toggleSizeToContentWidth();
    }
  });
  registerTerminalAction({
    id: "workbench.action.terminal.clearPreviousSessionHistory",
    title: { value: localize(
      "workbench.action.terminal.clearPreviousSessionHistory",
      "Clear Previous Session History"
    ), original: "Clear Previous Session History" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (c, accessor) => {
      getCommandHistory(accessor).clear();
      clearShellFileHistory();
    }
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.selectPrevSuggestion",
    title: { value: localize(
      "workbench.action.terminal.selectPrevSuggestion",
      "Select the Previous Suggestion"
    ), original: "Select the Previous Suggestion" },
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible),
    keybinding: {
      primary: 16,
      weight: 200 + 1
    },
    run: (activeInstance) => activeInstance.selectPreviousSuggestion()
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.selectPrevPageSuggestion",
    title: { value: localize(
      "workbench.action.terminal.selectPrevPageSuggestion",
      "Select the Previous Page Suggestion"
    ), original: "Select the Previous Page Suggestion" },
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible),
    keybinding: {
      primary: 11,
      weight: 200 + 1
    },
    run: (activeInstance) => activeInstance.selectPreviousPageSuggestion()
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.selectNextSuggestion",
    title: { value: localize(
      "workbench.action.terminal.selectNextSuggestion",
      "Select the Next Suggestion"
    ), original: "Select the Next Suggestion" },
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible),
    keybinding: {
      primary: 18,
      weight: 200 + 1
    },
    run: (insactiveInstanceance) => insactiveInstanceance.selectNextSuggestion()
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.selectNextPageSuggestion",
    title: { value: localize(
      "workbench.action.terminal.selectNextPageSuggestion",
      "Select the Next Page Suggestion"
    ), original: "Select the Next Page Suggestion" },
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible),
    keybinding: {
      primary: 12,
      weight: 200 + 1
    },
    run: (activeInstance) => activeInstance.selectNextPageSuggestion()
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.acceptSelectedSuggestion",
    title: { value: localize(
      "workbench.action.terminal.acceptSelectedSuggestion",
      "Accept Selected Suggestion"
    ), original: "Accept Selected Suggestion" },
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible),
    keybinding: {
      primary: 3,
      secondary: [2],
      weight: 200 + 1
    },
    run: (activeInstance) => activeInstance.acceptSelectedSuggestion()
  });
  registerActiveInstanceAction({
    id: "workbench.action.terminal.hideSuggestWidget",
    title: { value: localize("workbench.action.terminal.hideSuggestWidget", "Hide Suggest Widget"), original: "Hide Suggest Widget" },
    f1: false,
    precondition: ContextKeyExpr.and(ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ), TerminalContextKeys.focus, TerminalContextKeys.isOpen, TerminalContextKeys.suggestWidgetVisible),
    keybinding: {
      primary: 9,
      weight: 200 + 1
    },
    run: (activeInstance) => activeInstance.hideSuggestWidget()
  });
  if (BrowserFeatures.clipboard.writeText) {
    registerActiveXtermAction({
      id: "workbench.action.terminal.copySelection",
      title: { value: localize("workbench.action.terminal.copySelection", "Copy Selection"), original: "Copy Selection" },
      precondition: ContextKeyExpr.or(TerminalContextKeys.textSelectedInFocused, ContextKeyExpr.and(ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
      ), TerminalContextKeys.textSelected)),
      keybinding: [{
        primary: 2048 | 1024 | 33,
        mac: { primary: 2048 | 33 },
        weight: 200,
        when: ContextKeyExpr.or(ContextKeyExpr.and(TerminalContextKeys.textSelected, TerminalContextKeys.focus), TerminalContextKeys.textSelectedInFocused)
      }],
      run: (activeInstance) => activeInstance.copySelection()
    });
    registerActiveXtermAction({
      id: "workbench.action.terminal.copyAndClearSelection",
      title: { value: localize(
        "workbench.action.terminal.copyAndClearSelection",
        "Copy and Clear Selection"
      ), original: "Copy and Clear Selection" },
      precondition: ContextKeyExpr.or(TerminalContextKeys.textSelectedInFocused, ContextKeyExpr.and(ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
      ), TerminalContextKeys.textSelected)),
      keybinding: [{
        win: { primary: 2048 | 33 },
        weight: 200,
        when: ContextKeyExpr.or(ContextKeyExpr.and(TerminalContextKeys.textSelected, TerminalContextKeys.focus), TerminalContextKeys.textSelectedInFocused)
      }],
      run: async (xterm2) => {
        await xterm2.copySelection();
        xterm2.clearSelection();
      }
    });
    registerActiveXtermAction({
      id: "workbench.action.terminal.copySelectionAsHtml",
      title: { value: localize("workbench.action.terminal.copySelectionAsHtml", "Copy Selection as HTML"), original: "Copy Selection as HTML" },
      f1: true,
      category,
      precondition: ContextKeyExpr.or(TerminalContextKeys.textSelectedInFocused, ContextKeyExpr.and(ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
      ), TerminalContextKeys.textSelected)),
      run: (xterm2) => xterm2.copySelection(true)
    });
  }
  if (BrowserFeatures.clipboard.readText) {
    registerActiveInstanceAction({
      id: "workbench.action.terminal.paste",
      title: { value: localize("workbench.action.terminal.paste", "Paste into Active Terminal"), original: "Paste into Active Terminal" },
      precondition: ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
      ),
      keybinding: [{
        primary: 2048 | 52,
        win: { primary: 2048 | 52, secondary: [2048 | 1024 | 52] },
        linux: { primary: 2048 | 1024 | 52 },
        weight: 200,
        when: TerminalContextKeys.focus
      }],
      run: (activeInstance) => activeInstance.paste()
    });
  }
  if (BrowserFeatures.clipboard.readText && isLinux) {
    registerActiveInstanceAction({
      id: "workbench.action.terminal.pasteSelection",
      title: { value: localize(
        "workbench.action.terminal.pasteSelection",
        "Paste Selection into Active Terminal"
      ), original: "Paste Selection into Active Terminal" },
      precondition: ContextKeyExpr.or(
        TerminalContextKeys.processSupported,
        TerminalContextKeys.terminalHasBeenCreated
      ),
      keybinding: [{
        linux: { primary: 1024 | 19 },
        weight: 200,
        when: TerminalContextKeys.focus
      }],
      run: (activeInstance) => activeInstance.pasteSelection()
    });
  }
  registerTerminalAction({
    id: "workbench.action.terminal.switchTerminal",
    title: { value: localize("workbench.action.terminal.switchTerminal", "Switch Terminal"), original: "Switch Terminal" },
    precondition: ContextKeyExpr.or(
      TerminalContextKeys.processSupported,
      TerminalContextKeys.terminalHasBeenCreated
    ),
    run: async (c, accessor, args) => {
      const item = toOptionalString(args);
      if (!item) {
        return;
      }
      if (item === switchTerminalActionViewItemSeparator) {
        c.service.refreshActiveGroup();
        return;
      }
      if (item === switchTerminalShowTabsTitle) {
        accessor.get(IConfigurationService).updateValue("terminal.integrated.tabs.enabled", true);
        return;
      }
      const terminalIndexRe = /^([0-9]+): /;
      const indexMatches = terminalIndexRe.exec(item);
      if (indexMatches) {
        c.groupService.setActiveGroupByIndex(Number(indexMatches[1]) - 1);
        return c.groupService.showPanel(true);
      }
      const quickSelectProfiles = c.profileService.availableProfiles;
      const profileSelection = item.substring(4);
      if (quickSelectProfiles) {
        const profile = quickSelectProfiles.find((profile2) => profile2.profileName === profileSelection);
        if (profile) {
          const instance = await c.service.createTerminal({
            config: profile
          });
          c.service.setActiveInstance(instance);
        } else {
          console.warn(`No profile with name "${profileSelection}"`);
        }
      } else {
        console.warn(`Unmatched terminal item: "${item}"`);
      }
    }
  });
}
function getSelectedInstances(accessor) {
  var _a2;
  const listService = accessor.get(IListService);
  const terminalService = accessor.get(ITerminalService);
  if (!((_a2 = listService.lastFocusedList) == null ? void 0 : _a2.getSelection())) {
    return void 0;
  }
  const selections = listService.lastFocusedList.getSelection();
  const focused = listService.lastFocusedList.getFocus();
  const instances = [];
  if (focused.length === 1 && !selections.includes(focused[0])) {
    instances.push(terminalService.getInstanceFromIndex(focused[0]));
    return instances;
  }
  for (const selection of selections) {
    instances.push(terminalService.getInstanceFromIndex(selection));
  }
  return instances;
}
function validateTerminalName(name) {
  if (!name || name.trim().length === 0) {
    return {
      content: localize(
        "emptyTerminalNameInfo",
        "Providing no name will reset it to the default value"
      ),
      severity: Severity.Info
    };
  }
  return null;
}
function convertOptionsOrProfileToOptions(optionsOrProfile) {
  if (isObject(optionsOrProfile) && "profileName" in optionsOrProfile) {
    return { config: optionsOrProfile, location: optionsOrProfile.location };
  }
  return optionsOrProfile;
}
let newWithProfileAction;
function refreshTerminalActions(detectedProfiles) {
  const profileEnum = createProfileSchemaEnums(detectedProfiles);
  newWithProfileAction == null ? void 0 : newWithProfileAction.dispose();
  newWithProfileAction = registerAction2(class extends Action2 {
    constructor() {
      super({
        id: "workbench.action.terminal.newWithProfile",
        title: { value: localize(
          "workbench.action.terminal.newWithProfile",
          "Create New Terminal (With Profile)"
        ), original: "Create New Terminal (With Profile)" },
        f1: true,
        category,
        precondition: ContextKeyExpr.or(
          TerminalContextKeys.processSupported,
          TerminalContextKeys.webExtensionContributedProfile
        ),
        description: {
          description: "workbench.action.terminal.newWithProfile",
          args: [{
            name: "args",
            schema: {
              type: "object",
              required: ["profileName"],
              properties: {
                profileName: {
                  description: localize(
                    "workbench.action.terminal.newWithProfile.profileName",
                    "The name of the profile to create"
                  ),
                  type: "string",
                  enum: profileEnum.values,
                  markdownEnumDescriptions: profileEnum.markdownDescriptions
                }
              }
            }
          }]
        }
      });
    }
    async run(accessor, eventOrOptionsOrProfile, profile) {
      const c = getTerminalServices(accessor);
      const workspaceContextService = accessor.get(IWorkspaceContextService);
      const commandService = accessor.get(ICommandService);
      let event;
      let options;
      let instance;
      let cwd;
      if (isObject(eventOrOptionsOrProfile) && eventOrOptionsOrProfile && "profileName" in eventOrOptionsOrProfile) {
        const config = c.profileService.availableProfiles.find((profile2) => profile2.profileName === eventOrOptionsOrProfile.profileName);
        if (!config) {
          throw new Error(`Could not find terminal profile "${eventOrOptionsOrProfile.profileName}"`);
        }
        options = { config };
      } else if (eventOrOptionsOrProfile instanceof MouseEvent || eventOrOptionsOrProfile instanceof PointerEvent || eventOrOptionsOrProfile instanceof KeyboardEvent) {
        event = eventOrOptionsOrProfile;
        options = profile ? { config: profile } : void 0;
      } else {
        options = convertOptionsOrProfileToOptions(eventOrOptionsOrProfile);
      }
      if (event && (event.altKey || event.ctrlKey)) {
        const parentTerminal = c.service.activeInstance;
        if (parentTerminal) {
          await c.service.createTerminal({ location: { parentTerminal }, config: options == null ? void 0 : options.config });
          return;
        }
      }
      const folders = workspaceContextService.getWorkspace().folders;
      if (folders.length > 1) {
        const options2 = {
          placeHolder: localize(
            "workbench.action.terminal.newWorkspacePlaceholder",
            "Select current working directory for new terminal"
          )
        };
        const workspace = await commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID, [options2]);
        if (!workspace) {
          return;
        }
        cwd = workspace.uri;
      }
      if (options) {
        options.cwd = cwd;
        instance = await c.service.createTerminal(options);
      } else {
        instance = await c.service.showProfileQuickPick("createInstance", cwd);
      }
      if (instance) {
        c.service.setActiveInstance(instance);
        await focusActiveTerminal(instance, c);
      }
    }
  });
}
function getResourceOrActiveInstance(c, resource) {
  return c.service.getInstanceFromResource(toOptionalUri(resource)) || c.service.activeInstance;
}
async function pickTerminalCwd(accessor, cancel) {
  const quickInputService = accessor.get(IQuickInputService);
  const labelService = accessor.get(ILabelService);
  const contextService = accessor.get(IWorkspaceContextService);
  const modelService = accessor.get(IModelService);
  const languageService = accessor.get(ILanguageService);
  const configurationService = accessor.get(IConfigurationService);
  const configurationResolverService = accessor.get(IConfigurationResolverService);
  const folders = contextService.getWorkspace().folders;
  if (!folders.length) {
    return;
  }
  const folderCwdPairs = await Promise.all(folders.map(
    (x) => resolveWorkspaceFolderCwd(x, configurationService, configurationResolverService)
  ));
  const shrinkedPairs = shrinkWorkspaceFolderCwdPairs(folderCwdPairs);
  if (shrinkedPairs.length === 1) {
    return shrinkedPairs[0];
  }
  const folderPicks = shrinkedPairs.map((pair) => {
    const label = pair.folder.name;
    const description = pair.isOverridden ? localize(
      "workbench.action.terminal.overriddenCwdDescription",
      "(Overriden) {0}",
      labelService.getUriLabel(pair.cwd, { relative: !pair.isAbsolute })
    ) : labelService.getUriLabel(dirname(pair.cwd), { relative: true });
    return {
      label,
      description: description !== label ? description : void 0,
      pair,
      iconClasses: getIconClasses(modelService, languageService, pair.cwd, FileKind.ROOT_FOLDER)
    };
  });
  const options = {
    placeHolder: localize(
      "workbench.action.terminal.newWorkspacePlaceholder",
      "Select current working directory for new terminal"
    ),
    matchOnDescription: true,
    canPickMany: false
  };
  const token = cancel || CancellationToken.None;
  const pick = await quickInputService.pick(folderPicks, options, token);
  return pick == null ? void 0 : pick.pair;
}
async function resolveWorkspaceFolderCwd(folder, configurationService, configurationResolverService) {
  const cwdConfig = configurationService.getValue("terminal.integrated.cwd", { resource: folder.uri });
  if (!isString(cwdConfig) || cwdConfig.length === 0) {
    return { folder, cwd: folder.uri, isAbsolute: false, isOverridden: false };
  }
  const resolvedCwdConfig = await configurationResolverService.resolveAsync(folder, cwdConfig);
  return isAbsolute(resolvedCwdConfig) || resolvedCwdConfig.startsWith(AbstractVariableResolverService.VARIABLE_LHS) ? { folder, isAbsolute: true, isOverridden: true, cwd: URI.from({ scheme: folder.uri.scheme, path: resolvedCwdConfig }) } : { folder, isAbsolute: false, isOverridden: true, cwd: URI.joinPath(folder.uri, resolvedCwdConfig) };
}
function shrinkWorkspaceFolderCwdPairs(pairs) {
  const map = /* @__PURE__ */ new Map();
  for (const pair of pairs) {
    const key = pair.cwd.toString();
    const value = map.get(key);
    if (!value || key === pair.folder.uri.toString()) {
      map.set(key, pair);
    }
  }
  const selectedPairs = new Set(map.values());
  const selectedPairsInOrder = pairs.filter((x) => selectedPairs.has(x));
  return selectedPairsInOrder;
}
async function focusActiveTerminal(instance, c) {
  if (instance.target === TerminalLocation.Editor) {
    await c.editorService.revealActiveEditor();
    await instance.focusWhenReady(true);
  } else {
    await c.groupService.showPanel(true);
  }
}
async function renameWithQuickPick(c, accessor, resource) {
  const instance = getResourceOrActiveInstance(c, resource);
  if (instance) {
    const title = await accessor.get(IQuickInputService).input({
      value: instance.title,
      prompt: localize("workbench.action.terminal.rename.prompt", "Enter terminal name")
    });
    instance.rename(title);
  }
}
function toOptionalUri(obj) {
  return URI.isUri(obj) ? obj : void 0;
}
function toOptionalString(obj) {
  return isString(obj) ? obj : void 0;
}
var css$5 = '.monaco-action-bar .action-item .action-label.extension-action{line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-action-bar .action-dropdown-item>.action-label.extension-action.label,.monaco-action-bar .action-item>.action-label.extension-action.label{padding:0 5px}.monaco-action-bar .action-dropdown-item>.monaco-dropdown .action-label{padding:0}.monaco-action-bar .action-item .action-label.extension-action.label{outline-offset:1px}.monaco-action-bar .action-dropdown-item .action-label.extension-action.label,.monaco-action-bar .action-item .action-label.extension-action.label,.monaco-action-bar .action-item .action-label.extension-action.text{height:auto;line-height:14px;width:auto}.monaco-action-bar .action-item .action-label.extension-action.built-in-status{border-color:var(--vscode-foreground)}.monaco-action-bar .action-item .action-label.extension-action.label,.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator{background-color:var(--vscode-extensionButton-background)!important}.monaco-action-bar .action-item .action-label.extension-action.label{color:var(--vscode-extensionButton-foreground)!important}.monaco-action-bar .action-item .action-label.extension-action.label:hover{background-color:var(--vscode-extensionButton-hoverBackground)!important}.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator>div{background-color:var(--vscode-extensionButton-separator)}.monaco-action-bar .action-item .action-label.extension-action.label.prominent,.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator.prominent{background-color:var(--vscode-extensionButton-prominentBackground)}.monaco-action-bar .action-item .action-label.extension-action.label.prominent{color:var(--vscode-extensionButton-prominentForeground)!important}.monaco-action-bar .action-item .action-label.extension-action.label.prominent:hover{background-color:var(--vscode-extensionButton-prominentHoverBackground)}.monaco-action-bar .action-item .action-label.extension-action:not(.disabled){border:1px solid var(--vscode-contrastBorder)}.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator{border-bottom:1px solid var(--vscode-contrastBorder);border-top:1px solid var(--vscode-contrastBorder)}.monaco-action-bar .action-item .action-label.extension-action.extension-status-error{color:var(--vscode-editorError-foreground)}.monaco-action-bar .action-item .action-label.extension-action.extension-status-warning{color:var(--vscode-editorWarning-foreground)}.monaco-action-bar .action-item .action-label.extension-action.extension-status-info{color:var(--vscode-editorInfo-foreground)}.monaco-action-bar .action-dropdown-item .action-label.extension-action.label,.monaco-action-bar .action-item .action-label.extension-action.icon,.monaco-action-bar .action-item:not(.disabled) .action-label.extension-action.label,.monaco-action-bar .action-item:not(.disabled) .action-label.extension-action.text{margin-top:2px}.monaco-action-bar .action-item .action-label.extension-action.manage.hide,.monaco-action-bar .action-item.action-dropdown-item .action-label.extension-action.hide,.monaco-action-bar .action-item.action-dropdown-item.disabled,.monaco-action-bar .action-item.disabled .action-label.disable-status.hide,.monaco-action-bar .action-item.disabled .action-label.extension-action.extension-sync,.monaco-action-bar .action-item.disabled .action-label.extension-action.hide,.monaco-action-bar .action-item.disabled .action-label.extension-action.hide-when-disabled,.monaco-action-bar .action-item.disabled .action-label.extension-action.ignore,.monaco-action-bar .action-item.disabled .action-label.extension-action.install:not(.installing),.monaco-action-bar .action-item.disabled .action-label.extension-action.language,.monaco-action-bar .action-item.disabled .action-label.extension-action.migrate,.monaco-action-bar .action-item.disabled .action-label.extension-action.reload,.monaco-action-bar .action-item.disabled .action-label.extension-action.theme,.monaco-action-bar .action-item.disabled .action-label.extension-action.undo-ignore,.monaco-action-bar .action-item.disabled .action-label.extension-action.uninstall:not(.uninstalling),.monaco-action-bar .action-item.disabled .action-label.extension-action.update,.monaco-action-bar .action-item.disabled .action-label.extension-status-label.hide,.monaco-action-bar .action-item.disabled .action-label.extension-status.hide{display:none}.monaco-action-bar .extension-action.label{display:inherit}.monaco-action-bar .action-item.disabled .action-label.extension-status:before{opacity:1}.monaco-action-bar .action-item.disabled .action-label.extension-status-label:before{content:"\\2713";padding-right:4px}.monaco-action-bar .action-item.disabled .action-label.extension-action{opacity:1}.monaco-action-bar .action-item.disabled .action-label.extension-action.text{font-style:italic;opacity:.9}';
n(css$5, {});
const ExtensionsConfigurationInitialContent = [
  "{",
  "	// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.",
  "	// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp",
  "",
  "	// List of extensions which should be recommended for users of this workspace.",
  '	"recommendations": [',
  "		",
  "	],",
  "	// List of extensions recommended by VS Code that should not be recommended for users of this workspace.",
  '	"unwantedRecommendations": [',
  "		",
  "	]",
  "}"
].join("\n");
const IExtensionRecommendationsService = createDecorator("extensionRecommendationsService");
const IExtensionIgnoredRecommendationsService = createDecorator("IExtensionIgnoredRecommendationsService");
const EXTENSIONS_CONFIG = ".vscode/extensions.json";
let PromptExtensionInstallFailureAction = class PromptExtensionInstallFailureAction2 extends Action {
  constructor(extension, version, installOperation, error, productService, openerService, notificationService, dialogService, commandService, logService, extensionManagementServerService, instantiationService, galleryService, extensionManifestPropertiesService) {
    super("extension.promptExtensionInstallFailure");
    this.extension = extension;
    this.version = version;
    this.installOperation = installOperation;
    this.error = error;
    this.productService = productService;
    this.openerService = openerService;
    this.notificationService = notificationService;
    this.dialogService = dialogService;
    this.commandService = commandService;
    this.logService = logService;
    this.extensionManagementServerService = extensionManagementServerService;
    this.instantiationService = instantiationService;
    this.galleryService = galleryService;
    this.extensionManifestPropertiesService = extensionManifestPropertiesService;
  }
  async run() {
    if (isCancellationError(this.error)) {
      return;
    }
    this.logService.error(this.error);
    if (this.error.name === ExtensionManagementErrorCode.Unsupported) {
      const productName = isWeb ? localize("VS Code for Web", "{0} for the Web", this.productService.nameLong) : this.productService.nameLong;
      const message2 = localize(
        "cannot be installed",
        "The '{0}' extension is not available in {1}. Click 'More Information' to learn more.",
        this.extension.displayName || this.extension.identifier.id,
        productName
      );
      const { confirmed } = await this.dialogService.confirm({
        type: Severity.Info,
        message: message2,
        primaryButton: localize(
          { key: "more information", comment: ["&& denotes a mnemonic"] },
          "&&More Information"
        ),
        cancelButton: localize("close", "Close")
      });
      if (confirmed) {
        this.openerService.open(isWeb ? URI.parse("https://aka.ms/vscode-web-extensions-guide") : URI.parse("https://aka.ms/vscode-remote"));
      }
      return;
    }
    if ([ExtensionManagementErrorCode.Incompatible, ExtensionManagementErrorCode.IncompatibleTargetPlatform, ExtensionManagementErrorCode.Malicious, ExtensionManagementErrorCode.ReleaseVersionNotFound, ExtensionManagementErrorCode.Deprecated].includes(this.error.name)) {
      await this.dialogService.info(getErrorMessage(this.error));
      return;
    }
    if (ExtensionManagementErrorCode.Signature === this.error.name) {
      await this.dialogService.prompt({
        type: "error",
        message: localize(
          "signature verification failed",
          "{0} cannot verify the '{1}' extension. Are you sure you want to install it?",
          this.productService.nameLong,
          this.extension.displayName || this.extension.identifier.id
        ),
        buttons: [{
          label: localize("install anyway", "Install Anyway"),
          run: () => {
            const installAction = this.instantiationService.createInstance(InstallAction, { donotVerifySignature: true });
            installAction.extension = this.extension;
            return installAction.run();
          }
        }],
        cancelButton: localize("cancel", "Cancel")
      });
      return;
    }
    const operationMessage = this.installOperation === 3 ? localize(
      "update operation",
      "Error while updating '{0}' extension.",
      this.extension.displayName || this.extension.identifier.id
    ) : localize(
      "install operation",
      "Error while installing '{0}' extension.",
      this.extension.displayName || this.extension.identifier.id
    );
    let additionalMessage;
    const promptChoices = [];
    const downloadUrl = await this.getDownloadUrl();
    if (downloadUrl) {
      additionalMessage = localize(
        "check logs",
        "Please check the [log]({0}) for more details.",
        `command:${showWindowLogActionId}`
      );
      promptChoices.push({
        label: localize("download", "Try Downloading Manually..."),
        run: () => this.openerService.open(downloadUrl).then(() => {
          this.notificationService.prompt(Severity.Info, localize(
            "install vsix",
            "Once downloaded, please manually install the downloaded VSIX of '{0}'.",
            this.extension.identifier.id
          ), [{
            label: localize("installVSIX", "Install from VSIX..."),
            run: () => this.commandService.executeCommand(SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID)
          }]);
        })
      });
    }
    const message = `${operationMessage}${additionalMessage ? ` ${additionalMessage}` : ""}`;
    this.notificationService.prompt(Severity.Error, message, promptChoices);
  }
  async getDownloadUrl() {
    if (isIOS) {
      return void 0;
    }
    if (!this.extension.gallery) {
      return void 0;
    }
    if (!this.productService.extensionsGallery) {
      return void 0;
    }
    if (!this.extensionManagementServerService.localExtensionManagementServer && !this.extensionManagementServerService.remoteExtensionManagementServer) {
      return void 0;
    }
    let targetPlatform = this.extension.gallery.properties.targetPlatform;
    if (targetPlatform !== "universal" && targetPlatform !== "undefined" && this.extensionManagementServerService.remoteExtensionManagementServer) {
      try {
        const manifest = await this.galleryService.getManifest(this.extension.gallery, CancellationToken.None);
        if (manifest && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(manifest)) {
          targetPlatform = await this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform();
        }
      } catch (error) {
        this.logService.error(error);
        return void 0;
      }
    }
    if (targetPlatform === "unknown") {
      return void 0;
    }
    return URI.parse(
      `${this.productService.extensionsGallery.serviceUrl}/publishers/${this.extension.publisher}/vsextensions/${this.extension.name}/${this.version}/vspackage${targetPlatform !== "undefined" ? `?targetPlatform=${targetPlatform}` : ""}`
    );
  }
};
PromptExtensionInstallFailureAction = __decorate([
  __param(4, IProductService),
  __param(5, IOpenerService),
  __param(6, INotificationService),
  __param(7, IDialogService),
  __param(8, ICommandService),
  __param(9, ILogService),
  __param(10, IExtensionManagementServerService),
  __param(11, IInstantiationService),
  __param(12, IExtensionGalleryService),
  __param(13, IExtensionManifestPropertiesService)
], PromptExtensionInstallFailureAction);
const _ExtensionAction = class _ExtensionAction extends Action {
  constructor() {
    super(...arguments);
    this._extension = null;
  }
  get extension() {
    return this._extension;
  }
  set extension(extension) {
    this._extension = extension;
    this.update();
  }
};
_ExtensionAction.EXTENSION_ACTION_CLASS = "extension-action";
_ExtensionAction.TEXT_ACTION_CLASS = `${_ExtensionAction.EXTENSION_ACTION_CLASS} text`;
_ExtensionAction.LABEL_ACTION_CLASS = `${_ExtensionAction.EXTENSION_ACTION_CLASS} label`;
_ExtensionAction.ICON_ACTION_CLASS = `${_ExtensionAction.EXTENSION_ACTION_CLASS} icon`;
let ExtensionAction = _ExtensionAction;
let InstallAction = (_b = class extends ExtensionAction {
  set manifest(manifest) {
    this._manifest = manifest;
    this.updateLabel();
  }
  constructor(options, extensionsWorkbenchService, instantiationService, runtimeExtensionService, workbenchThemeService, labelService, dialogService, preferencesService, telemetryService) {
    super("extensions.install", localize("install", "Install"), _b.Class, false);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.instantiationService = instantiationService;
    this.runtimeExtensionService = runtimeExtensionService;
    this.workbenchThemeService = workbenchThemeService;
    this.labelService = labelService;
    this.dialogService = dialogService;
    this.preferencesService = preferencesService;
    this.telemetryService = telemetryService;
    this._manifest = null;
    this.updateThrottler = new Throttler();
    this.options = { ...options, isMachineScoped: false };
    this.update();
    this._register(this.labelService.onDidChangeFormatters(() => this.updateLabel(), this));
  }
  update() {
    this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
  }
  async computeAndUpdateEnablement() {
    this.enabled = false;
    if (!this.extension) {
      return;
    }
    if (this.extension.isBuiltin) {
      return;
    }
    if (this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
      return;
    }
    if (this.extension.state === 3 && await this.extensionsWorkbenchService.canInstall(this.extension)) {
      this.enabled = this.options.installPreReleaseVersion ? this.extension.hasPreReleaseVersion : this.extension.hasReleaseVersion;
      this.updateLabel();
    }
  }
  async run() {
    if (!this.extension) {
      return;
    }
    if (this.extension.deprecationInfo) {
      let detail = localize(
        "deprecated message",
        "This extension is deprecated as it is no longer being maintained."
      );
      let DeprecationChoice;
      (function(DeprecationChoice2) {
        DeprecationChoice2[DeprecationChoice2["InstallAnyway"] = 0] = "InstallAnyway";
        DeprecationChoice2[DeprecationChoice2["ShowAlternateExtension"] = 1] = "ShowAlternateExtension";
        DeprecationChoice2[DeprecationChoice2["ConfigureSettings"] = 2] = "ConfigureSettings";
        DeprecationChoice2[DeprecationChoice2["Cancel"] = 3] = "Cancel";
      })(DeprecationChoice || (DeprecationChoice = {}));
      const buttons = [
        {
          label: localize("install anyway", "Install Anyway"),
          run: () => DeprecationChoice.InstallAnyway
        }
      ];
      if (this.extension.deprecationInfo.extension) {
        detail = localize(
          "deprecated with alternate extension message",
          "This extension is deprecated. Use the {0} extension instead.",
          this.extension.deprecationInfo.extension.displayName
        );
        const alternateExtension = this.extension.deprecationInfo.extension;
        buttons.push({
          label: localize(
            { key: "Show alternate extension", comment: ["&& denotes a mnemonic"] },
            "&&Open {0}",
            this.extension.deprecationInfo.extension.displayName
          ),
          run: async () => {
            const [extension2] = await this.extensionsWorkbenchService.getExtensions([{ id: alternateExtension.id, preRelease: alternateExtension.preRelease }], CancellationToken.None);
            await this.extensionsWorkbenchService.open(extension2);
            return DeprecationChoice.ShowAlternateExtension;
          }
        });
      } else if (this.extension.deprecationInfo.settings) {
        detail = localize(
          "deprecated with alternate settings message",
          "This extension is deprecated as this functionality is now built-in to VS Code."
        );
        const settings = this.extension.deprecationInfo.settings;
        buttons.push({
          label: localize(
            { key: "configure in settings", comment: ["&& denotes a mnemonic"] },
            "&&Configure Settings"
          ),
          run: async () => {
            await this.preferencesService.openSettings({ query: settings.map((setting) => `@id:${setting}`).join(" ") });
            return DeprecationChoice.ConfigureSettings;
          }
        });
      } else if (this.extension.deprecationInfo.additionalInfo) {
        detail = new MarkdownString(`${detail} ${this.extension.deprecationInfo.additionalInfo}`);
      }
      const { result } = await this.dialogService.prompt({
        type: Severity.Warning,
        message: localize(
          "install confirmation",
          "Are you sure you want to install '{0}'?",
          this.extension.displayName
        ),
        detail: isString(detail) ? detail : void 0,
        custom: isString(detail) ? void 0 : {
          markdownDetails: [{
            markdown: detail
          }]
        },
        buttons,
        cancelButton: {
          run: () => DeprecationChoice.Cancel
        }
      });
      if (result !== DeprecationChoice.InstallAnyway) {
        return;
      }
    }
    this.extensionsWorkbenchService.open(this.extension, { showPreReleaseVersion: this.options.installPreReleaseVersion });
    alert(localize(
      "installExtensionStart",
      "Installing extension {0} started. An editor is now open with more details on this extension",
      this.extension.displayName
    ));
    this.telemetryService.publicLog("extensions:action:install", { ...this.extension.telemetryData, actionId: this.id });
    const extension = await this.install(this.extension);
    if (extension == null ? void 0 : extension.local) {
      alert(localize(
        "installExtensionComplete",
        "Installing extension {0} is completed.",
        this.extension.displayName
      ));
      const runningExtension = await this.getRunningExtension(extension.local);
      if (runningExtension && !(runningExtension.activationEvents && runningExtension.activationEvents.some((activationEent) => activationEent.startsWith("onLanguage")))) {
        const action = await this.getThemeAction(extension);
        if (action) {
          action.extension = extension;
          try {
            return action.run({ showCurrentTheme: true, ignoreFocusLost: true });
          } finally {
            action.dispose();
          }
        }
      }
    }
  }
  async getThemeAction(extension) {
    const colorThemes = await this.workbenchThemeService.getColorThemes();
    if (colorThemes.some((theme) => isThemeFromExtension(theme, extension))) {
      return this.instantiationService.createInstance(SetColorThemeAction);
    }
    const fileIconThemes = await this.workbenchThemeService.getFileIconThemes();
    if (fileIconThemes.some((theme) => isThemeFromExtension(theme, extension))) {
      return this.instantiationService.createInstance(SetFileIconThemeAction);
    }
    const productIconThemes = await this.workbenchThemeService.getProductIconThemes();
    if (productIconThemes.some((theme) => isThemeFromExtension(theme, extension))) {
      return this.instantiationService.createInstance(SetProductIconThemeAction);
    }
    return void 0;
  }
  async install(extension) {
    try {
      return await this.extensionsWorkbenchService.install(extension, this.options);
    } catch (error) {
      await this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, extension.latestVersion, 2, error).run();
      return void 0;
    }
  }
  async getRunningExtension(extension) {
    const runningExtension = await this.runtimeExtensionService.getExtension(extension.identifier.id);
    if (runningExtension) {
      return runningExtension;
    }
    if (this.runtimeExtensionService.canAddExtension(toExtensionDescription(extension))) {
      return new Promise((c, e) => {
        const disposable = this.runtimeExtensionService.onDidChangeExtensions(async () => {
          const runningExtension2 = await this.runtimeExtensionService.getExtension(extension.identifier.id);
          if (runningExtension2) {
            disposable.dispose();
            c(runningExtension2);
          }
        });
      });
    }
    return null;
  }
  updateLabel() {
    this.label = this.getLabel();
  }
  getLabel(primary) {
    var _a2, _b2;
    if (this.options.installPreReleaseVersion && ((_a2 = this.extension) == null ? void 0 : _a2.hasPreReleaseVersion)) {
      return primary ? localize("install pre-release", "Install Pre-Release") : localize("install pre-release version", "Install Pre-Release Version");
    }
    if ((_b2 = this.extension) == null ? void 0 : _b2.hasPreReleaseVersion) {
      return primary ? localize("install", "Install") : localize("install release version", "Install Release Version");
    }
    return localize("install", "Install");
  }
}, _b.Class = `${ExtensionAction.LABEL_ACTION_CLASS} prominent install`, _b);
InstallAction = __decorate([
  __param(1, IExtensionsWorkbenchService),
  __param(2, IInstantiationService),
  __param(3, IExtensionService),
  __param(4, IWorkbenchThemeService),
  __param(5, ILabelService),
  __param(6, IDialogService),
  __param(7, IPreferencesService),
  __param(8, ITelemetryService)
], InstallAction);
const _InstallingLabelAction = class _InstallingLabelAction extends ExtensionAction {
  constructor() {
    super("extension.installing", _InstallingLabelAction.LABEL, _InstallingLabelAction.CLASS, false);
  }
  update() {
    this.class = `${_InstallingLabelAction.CLASS}${this.extension && this.extension.state === 0 ? "" : " hide"}`;
  }
};
_InstallingLabelAction.LABEL = localize("installing", "Installing");
_InstallingLabelAction.CLASS = `${ExtensionAction.LABEL_ACTION_CLASS} install installing`;
let InstallingLabelAction = _InstallingLabelAction;
_c = class extends ExtensionAction {
  constructor(id, server, canInstallAnyWhere, extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService) {
    super(id, _c.INSTALL_LABEL, _c.Class, false);
    this.server = server;
    this.canInstallAnyWhere = canInstallAnyWhere;
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionManagementServerService = extensionManagementServerService;
    this.extensionManifestPropertiesService = extensionManifestPropertiesService;
    this.updateWhenCounterExtensionChanges = true;
    this.update();
  }
  update() {
    this.enabled = false;
    this.class = _c.Class;
    if (this.canInstall()) {
      const extensionInOtherServer = this.extensionsWorkbenchService.installed.filter((e) => areSameExtensions(e.identifier, this.extension.identifier) && e.server === this.server)[0];
      if (extensionInOtherServer) {
        if (extensionInOtherServer.state === 0 && !extensionInOtherServer.local) {
          this.enabled = true;
          this.label = _c.INSTALLING_LABEL;
          this.class = _c.InstallingClass;
        }
      } else {
        this.enabled = true;
        this.label = this.getInstallLabel();
      }
    }
  }
  canInstall() {
    if (!this.extension || !this.server || !this.extension.local || this.extension.state !== 1 || this.extension.type !== 1 || this.extension.enablementState === 2 || this.extension.enablementState === 0 || this.extension.enablementState === 4) {
      return false;
    }
    if (isLanguagePackExtension(this.extension.local.manifest)) {
      return true;
    }
    if (this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
      return true;
    }
    if (this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
      return true;
    }
    if (this.server === this.extensionManagementServerService.webExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWeb(this.extension.local.manifest)) {
      return true;
    }
    if (this.canInstallAnyWhere) {
      if (this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnUI(this.extension.local.manifest)) {
        return true;
      }
      if (this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnWorkspace(this.extension.local.manifest)) {
        return true;
      }
    }
    return false;
  }
  async run() {
    var _a2, _b2;
    if (!((_a2 = this.extension) == null ? void 0 : _a2.local)) {
      return;
    }
    if (!((_b2 = this.extension) == null ? void 0 : _b2.server)) {
      return;
    }
    if (!this.server) {
      return;
    }
    this.extensionsWorkbenchService.open(this.extension);
    alert(localize(
      "installExtensionStart",
      "Installing extension {0} started. An editor is now open with more details on this extension",
      this.extension.displayName
    ));
    return this.extensionsWorkbenchService.installInServer(this.extension, this.server);
  }
}, _c.INSTALL_LABEL = localize("install", "Install"), _c.INSTALLING_LABEL = localize("installing", "Installing"), _c.Class = `${ExtensionAction.LABEL_ACTION_CLASS} prominent install`, _c.InstallingClass = `${ExtensionAction.LABEL_ACTION_CLASS} install installing`, _c;
let UninstallAction = (_d = class extends ExtensionAction {
  constructor(extensionsWorkbenchService) {
    super("extensions.uninstall", _d.UninstallLabel, _d.UninstallClass, false);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.update();
  }
  update() {
    if (!this.extension) {
      this.enabled = false;
      return;
    }
    const state = this.extension.state;
    if (state === 2) {
      this.label = _d.UninstallingLabel;
      this.class = _d.UnInstallingClass;
      this.enabled = false;
      return;
    }
    this.label = _d.UninstallLabel;
    this.class = _d.UninstallClass;
    this.tooltip = _d.UninstallLabel;
    if (state !== 1) {
      this.enabled = false;
      return;
    }
    if (this.extension.isBuiltin) {
      this.enabled = false;
      return;
    }
    this.enabled = true;
  }
  async run() {
    if (!this.extension) {
      return;
    }
    alert(localize(
      "uninstallExtensionStart",
      "Uninstalling extension {0} started.",
      this.extension.displayName
    ));
    return this.extensionsWorkbenchService.uninstall(this.extension).then(() => {
      alert(localize(
        "uninstallExtensionComplete",
        "Please reload Visual Studio Code to complete the uninstallation of the extension {0}.",
        this.extension.displayName
      ));
    });
  }
}, _d.UninstallLabel = localize("uninstallAction", "Uninstall"), _d.UninstallingLabel = localize("Uninstalling", "Uninstalling"), _d.UninstallClass = `${ExtensionAction.LABEL_ACTION_CLASS} uninstall`, _d.UnInstallingClass = `${ExtensionAction.LABEL_ACTION_CLASS} uninstall uninstalling`, _d);
UninstallAction = __decorate([
  __param(0, IExtensionsWorkbenchService)
], UninstallAction);
const _AbstractUpdateAction = class _AbstractUpdateAction extends ExtensionAction {
  constructor(id, label, extensionsWorkbenchService) {
    super(id, label, _AbstractUpdateAction.DisabledClass, false);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.updateThrottler = new Throttler();
    this.update();
  }
  update() {
    this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
  }
  async computeAndUpdateEnablement() {
    this.enabled = false;
    this.class = UpdateAction.DisabledClass;
    if (!this.extension) {
      return;
    }
    if (this.extension.deprecationInfo) {
      return;
    }
    const canInstall = await this.extensionsWorkbenchService.canInstall(this.extension);
    const isInstalled = this.extension.state === 1;
    this.enabled = canInstall && isInstalled && this.extension.outdated;
    this.class = this.enabled ? _AbstractUpdateAction.EnabledClass : _AbstractUpdateAction.DisabledClass;
  }
};
_AbstractUpdateAction.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} prominent update`;
_AbstractUpdateAction.DisabledClass = `${_AbstractUpdateAction.EnabledClass} disabled`;
let AbstractUpdateAction = _AbstractUpdateAction;
let UpdateAction = class UpdateAction2 extends AbstractUpdateAction {
  constructor(verbose, extensionsWorkbenchService, instantiationService) {
    super(`extensions.update`, localize("update", "Update"), extensionsWorkbenchService);
    this.verbose = verbose;
    this.instantiationService = instantiationService;
  }
  update() {
    super.update();
    if (this.extension) {
      this.label = this.verbose ? localize("update to", "Update to v{0}", this.extension.latestVersion) : localize("update", "Update");
    }
  }
  async run() {
    if (!this.extension) {
      return;
    }
    alert(localize(
      "updateExtensionStart",
      "Updating extension {0} to version {1} started.",
      this.extension.displayName,
      this.extension.latestVersion
    ));
    return this.install(this.extension);
  }
  async install(extension) {
    var _a2;
    try {
      await this.extensionsWorkbenchService.install(extension, ((_a2 = extension.local) == null ? void 0 : _a2.preRelease) ? { installPreReleaseVersion: true } : void 0);
      alert(localize(
        "updateExtensionComplete",
        "Updating extension {0} to version {1} completed.",
        extension.displayName,
        extension.latestVersion
      ));
    } catch (err) {
      this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, extension.latestVersion, 3, err).run();
    }
  }
};
UpdateAction = __decorate([
  __param(1, IExtensionsWorkbenchService),
  __param(2, IInstantiationService)
], UpdateAction);
_e = class extends ExtensionAction {
  constructor(small, extensionsWorkbenchService) {
    super("extensionsAction.migrateDeprecatedExtension", localize("migrateExtension", "Migrate"), _e.DisabledClass, false);
    this.small = small;
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.update();
  }
  update() {
    var _a2, _b2;
    this.enabled = false;
    this.class = _e.DisabledClass;
    if (!((_a2 = this.extension) == null ? void 0 : _a2.local)) {
      return;
    }
    if (this.extension.state !== 1) {
      return;
    }
    if (!((_b2 = this.extension.deprecationInfo) == null ? void 0 : _b2.extension)) {
      return;
    }
    const id = this.extension.deprecationInfo.extension.id;
    if (this.extensionsWorkbenchService.local.some((e) => areSameExtensions(e.identifier, { id }))) {
      return;
    }
    this.enabled = true;
    this.class = _e.EnabledClass;
    this.tooltip = localize(
      "migrate to",
      "Migrate to {0}",
      this.extension.deprecationInfo.extension.displayName
    );
    this.label = this.small ? localize("migrate", "Migrate") : this.tooltip;
  }
  async run() {
    var _a2, _b2, _c2, _d2;
    if (!((_b2 = (_a2 = this.extension) == null ? void 0 : _a2.deprecationInfo) == null ? void 0 : _b2.extension)) {
      return;
    }
    const local = this.extension.local;
    await this.extensionsWorkbenchService.uninstall(this.extension);
    const [extension] = await this.extensionsWorkbenchService.getExtensions([{ id: this.extension.deprecationInfo.extension.id, preRelease: (_d2 = (_c2 = this.extension.deprecationInfo) == null ? void 0 : _c2.extension) == null ? void 0 : _d2.preRelease }], CancellationToken.None);
    await this.extensionsWorkbenchService.install(extension, { isMachineScoped: local == null ? void 0 : local.isMachineScoped });
  }
}, _e.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} migrate`, _e.DisabledClass = `${_e.EnabledClass} disabled`, _e;
let ExtensionDropDownAction = class ExtensionDropDownAction2 extends ExtensionAction {
  constructor(id, label, cssClass, enabled, instantiationService) {
    super(id, label, cssClass, enabled);
    this.instantiationService = instantiationService;
    this._actionViewItem = null;
  }
  createActionViewItem() {
    this._actionViewItem = this.instantiationService.createInstance(DropDownMenuActionViewItem, this);
    return this._actionViewItem;
  }
  run({ actionGroups, disposeActionsOnHide }) {
    var _a2;
    (_a2 = this._actionViewItem) == null ? void 0 : _a2.showMenu(actionGroups, disposeActionsOnHide);
    return Promise.resolve();
  }
};
ExtensionDropDownAction = __decorate([
  __param(4, IInstantiationService)
], ExtensionDropDownAction);
let DropDownMenuActionViewItem = class DropDownMenuActionViewItem2 extends ActionViewItem {
  constructor(action, contextMenuService) {
    super(null, action, { icon: true, label: true });
    this.contextMenuService = contextMenuService;
  }
  showMenu(menuActionGroups, disposeActionsOnHide) {
    if (this.element) {
      const actions = this.getActions(menuActionGroups);
      const elementPosition = getDomNodePagePosition(this.element);
      const anchor = { x: elementPosition.left, y: elementPosition.top + elementPosition.height + 10 };
      this.contextMenuService.showContextMenu({
        getAnchor: () => anchor,
        getActions: () => actions,
        actionRunner: this.actionRunner,
        onHide: () => {
          if (disposeActionsOnHide) {
            disposeIfDisposable(actions);
          }
        }
      });
    }
  }
  getActions(menuActionGroups) {
    let actions = [];
    for (const menuActions of menuActionGroups) {
      actions = [...actions, ...menuActions, new Separator()];
    }
    return actions.length ? actions.slice(0, actions.length - 1) : actions;
  }
};
DropDownMenuActionViewItem = __decorate([
  __param(1, IContextMenuService)
], DropDownMenuActionViewItem);
async function getContextMenuActionsGroups(extension, contextKeyService, instantiationService) {
  return instantiationService.invokeFunction(async (accessor) => {
    var _a2, _b2, _c2, _d2, _e2;
    const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
    const menuService = accessor.get(IMenuService);
    const extensionRecommendationsService = accessor.get(IExtensionRecommendationsService);
    const extensionIgnoredRecommendationsService = accessor.get(IExtensionIgnoredRecommendationsService);
    const workbenchThemeService = accessor.get(IWorkbenchThemeService);
    const cksOverlay = [];
    if (extension) {
      cksOverlay.push(["extension", extension.identifier.id]);
      cksOverlay.push(["isBuiltinExtension", extension.isBuiltin]);
      cksOverlay.push(["isDefaultApplicationScopedExtension", extension.local && isApplicationScopedExtension(extension.local.manifest)]);
      cksOverlay.push(["isApplicationScopedExtension", extension.local && extension.local.isApplicationScoped]);
      cksOverlay.push(["extensionHasConfiguration", extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes.configuration]);
      cksOverlay.push(["extensionHasKeybindings", extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes.keybindings]);
      cksOverlay.push(["extensionHasCommands", extension.local && !!extension.local.manifest.contributes && !!((_a2 = extension.local.manifest.contributes) == null ? void 0 : _a2.commands)]);
      cksOverlay.push(["isExtensionRecommended", !!extensionRecommendationsService.getAllRecommendationsWithReason()[extension.identifier.id.toLowerCase()]]);
      cksOverlay.push(["isExtensionWorkspaceRecommended", ((_b2 = extensionRecommendationsService.getAllRecommendationsWithReason()[extension.identifier.id.toLowerCase()]) == null ? void 0 : _b2.reasonId) === 0]);
      cksOverlay.push(["isUserIgnoredRecommendation", extensionIgnoredRecommendationsService.globalIgnoredRecommendations.some((e) => e === extension.identifier.id.toLowerCase())]);
      if (extension.state === 1) {
        cksOverlay.push(["extensionStatus", "installed"]);
      }
      cksOverlay.push(["installedExtensionIsPreReleaseVersion", !!((_c2 = extension.local) == null ? void 0 : _c2.isPreReleaseVersion)]);
      cksOverlay.push(["installedExtensionIsOptedTpPreRelease", !!((_d2 = extension.local) == null ? void 0 : _d2.preRelease)]);
      cksOverlay.push(["galleryExtensionIsPreReleaseVersion", !!((_e2 = extension.gallery) == null ? void 0 : _e2.properties.isPreReleaseVersion)]);
      cksOverlay.push(["extensionHasPreReleaseVersion", extension.hasPreReleaseVersion]);
      cksOverlay.push(["extensionHasReleaseVersion", extension.hasReleaseVersion]);
      const [colorThemes, fileIconThemes, productIconThemes] = await Promise.all([workbenchThemeService.getColorThemes(), workbenchThemeService.getFileIconThemes(), workbenchThemeService.getProductIconThemes()]);
      cksOverlay.push(["extensionHasColorThemes", colorThemes.some((theme) => isThemeFromExtension(theme, extension))]);
      cksOverlay.push(["extensionHasFileIconThemes", fileIconThemes.some((theme) => isThemeFromExtension(theme, extension))]);
      cksOverlay.push(["extensionHasProductIconThemes", productIconThemes.some((theme) => isThemeFromExtension(theme, extension))]);
      cksOverlay.push(["canSetLanguage", extensionsWorkbenchService.canSetLanguage(extension)]);
      cksOverlay.push(["isActiveLanguagePackExtension", extension.gallery && language === getLocale(extension.gallery)]);
    }
    const menu = menuService.createMenu(MenuId.ExtensionContext, contextKeyService.createOverlay(cksOverlay));
    const actionsGroups = menu.getActions({ shouldForwardArgs: true });
    menu.dispose();
    return actionsGroups;
  });
}
function toActions(actionsGroups, instantiationService) {
  const result = [];
  for (const [, actions] of actionsGroups) {
    result.push(actions.map((action) => {
      if (action instanceof SubmenuAction) {
        return action;
      }
      return instantiationService.createInstance(MenuItemExtensionAction, action);
    }));
  }
  return result;
}
_f = class extends ExtensionDropDownAction {
  constructor(instantiationService, extensionService, contextKeyService) {
    super(_f.ID, "", "", true, instantiationService);
    this.extensionService = extensionService;
    this.contextKeyService = contextKeyService;
    this.tooltip = localize("manage", "Manage");
    this.update();
  }
  async getActionGroups() {
    const groups = [];
    const contextMenuActionsGroups = await getContextMenuActionsGroups(this.extension, this.contextKeyService, this.instantiationService);
    const themeActions = [], installActions = [], otherActionGroups = [];
    for (const [group, actions] of contextMenuActionsGroups) {
      if (group === INSTALL_ACTIONS_GROUP) {
        installActions.push(...toActions([[group, actions]], this.instantiationService)[0]);
      } else if (group === THEME_ACTIONS_GROUP) {
        themeActions.push(...toActions([[group, actions]], this.instantiationService)[0]);
      } else {
        otherActionGroups.push(...toActions([[group, actions]], this.instantiationService));
      }
    }
    if (themeActions.length) {
      groups.push(themeActions);
    }
    groups.push([
      this.instantiationService.createInstance(EnableGloballyAction),
      this.instantiationService.createInstance(EnableForWorkspaceAction)
    ]);
    groups.push([
      this.instantiationService.createInstance(DisableGloballyAction),
      this.instantiationService.createInstance(DisableForWorkspaceAction)
    ]);
    groups.push([
      ...installActions.length ? installActions : [],
      this.instantiationService.createInstance(InstallAnotherVersionAction),
      this.instantiationService.createInstance(UninstallAction)
    ]);
    otherActionGroups.forEach((actions) => groups.push(actions));
    groups.forEach((group) => group.forEach((extensionAction) => {
      if (extensionAction instanceof ExtensionAction) {
        extensionAction.extension = this.extension;
      }
    }));
    return groups;
  }
  async run() {
    await this.extensionService.whenInstalledExtensionsRegistered();
    return super.run({ actionGroups: await this.getActionGroups(), disposeActionsOnHide: true });
  }
  update() {
    this.class = _f.HideManageExtensionClass;
    this.enabled = false;
    if (this.extension) {
      const state = this.extension.state;
      this.enabled = state === 1;
      this.class = this.enabled || state === 2 ? _f.Class : _f.HideManageExtensionClass;
      this.tooltip = state === 2 ? localize("ManageExtensionAction.uninstallingTooltip", "Uninstalling") : "";
    }
  }
}, _f.ID = "extensions.manage", _f.Class = `${ExtensionAction.ICON_ACTION_CLASS} manage ` + ThemeIcon.asClassName(manageExtensionIcon), _f.HideManageExtensionClass = `${_f.Class} hide`, _f;
let MenuItemExtensionAction = class MenuItemExtensionAction2 extends ExtensionAction {
  constructor(action, extensionsWorkbenchService) {
    super(action.id, action.label);
    this.action = action;
    this.extensionsWorkbenchService = extensionsWorkbenchService;
  }
  update() {
    if (!this.extension) {
      return;
    }
    if (this.action.id === TOGGLE_IGNORE_EXTENSION_ACTION_ID) {
      this.checked = !this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension);
    } else {
      this.checked = this.action.checked;
    }
  }
  async run() {
    if (this.extension) {
      await this.action.run(this.extension.local ? getExtensionId(this.extension.local.manifest.publisher, this.extension.local.manifest.name) : this.extension.gallery ? getExtensionId(this.extension.gallery.publisher, this.extension.gallery.name) : this.extension.identifier.id);
    }
  }
};
MenuItemExtensionAction = __decorate([
  __param(1, IExtensionsWorkbenchService)
], MenuItemExtensionAction);
_g = class extends ExtensionAction {
  constructor(icon, commandService) {
    super(_g.ID, icon ? "" : _g.TITLE.value, `${icon ? ExtensionAction.ICON_ACTION_CLASS + " " + ThemeIcon.asClassName(preReleaseIcon) : ExtensionAction.LABEL_ACTION_CLASS} hide-when-disabled switch-to-prerelease`, true);
    this.commandService = commandService;
    this.tooltip = localize(
      "switch to pre-release version tooltip",
      "Switch to Pre-Release version of this extension"
    );
    this.update();
  }
  update() {
    var _a2, _b2;
    this.enabled = !!this.extension && !this.extension.isBuiltin && !((_a2 = this.extension.local) == null ? void 0 : _a2.isPreReleaseVersion) && !((_b2 = this.extension.local) == null ? void 0 : _b2.preRelease) && this.extension.hasPreReleaseVersion && this.extension.state === 1;
  }
  async run() {
    var _a2;
    if (!this.enabled) {
      return;
    }
    return this.commandService.executeCommand(_g.ID, (_a2 = this.extension) == null ? void 0 : _a2.identifier.id);
  }
}, _g.ID = "workbench.extensions.action.switchToPreReleaseVersion", _g.TITLE = { value: localize("switch to pre-release version", "Switch to Pre-Release Version"), original: "Switch to  Pre-Release Version" }, _g;
_h = class extends ExtensionAction {
  constructor(icon, commandService) {
    super(_h.ID, icon ? "" : _h.TITLE.value, `${icon ? ExtensionAction.ICON_ACTION_CLASS + " " + ThemeIcon.asClassName(preReleaseIcon) : ExtensionAction.LABEL_ACTION_CLASS} hide-when-disabled switch-to-released`);
    this.commandService = commandService;
    this.tooltip = localize(
      "switch to release version tooltip",
      "Switch to Release version of this extension"
    );
    this.update();
  }
  update() {
    var _a2;
    this.enabled = !!this.extension && !this.extension.isBuiltin && this.extension.state === 1 && !!((_a2 = this.extension.local) == null ? void 0 : _a2.isPreReleaseVersion) && !!this.extension.hasReleaseVersion;
  }
  async run() {
    var _a2;
    if (!this.enabled) {
      return;
    }
    return this.commandService.executeCommand(_h.ID, (_a2 = this.extension) == null ? void 0 : _a2.identifier.id);
  }
}, _h.ID = "workbench.extensions.action.switchToReleaseVersion", _h.TITLE = { value: localize("switch to release version", "Switch to Release Version"), original: "Switch to Release Version" }, _h;
let InstallAnotherVersionAction = (_i = class extends ExtensionAction {
  constructor(extensionsWorkbenchService, extensionGalleryService, quickInputService, instantiationService, dialogService) {
    super(_i.ID, _i.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionGalleryService = extensionGalleryService;
    this.quickInputService = quickInputService;
    this.instantiationService = instantiationService;
    this.dialogService = dialogService;
    this.update();
  }
  update() {
    this.enabled = !!this.extension && !this.extension.isBuiltin && !!this.extension.gallery && !!this.extension.local && !!this.extension.server && this.extension.state === 1 && !this.extension.deprecationInfo;
  }
  async run() {
    if (!this.enabled) {
      return;
    }
    const targetPlatform = await this.extension.server.extensionManagementService.getTargetPlatform();
    const allVersions = await this.extensionGalleryService.getAllCompatibleVersions(this.extension.gallery, this.extension.local.preRelease, targetPlatform);
    if (!allVersions.length) {
      await this.dialogService.info(localize("no versions", "This extension has no other versions."));
      return;
    }
    const picks = allVersions.map((v, i) => {
      return {
        id: v.version,
        label: v.version,
        description: `${fromNow(new Date(Date.parse(v.date)), true)}${v.isPreReleaseVersion ? ` (${localize("pre-release", "pre-release")})` : ""}${v.version === this.extension.version ? ` (${localize("current", "current")})` : ""}`,
        latest: i === 0,
        ariaLabel: `${v.isPreReleaseVersion ? "Pre-Release version" : "Release version"} ${v.version}`,
        isPreReleaseVersion: v.isPreReleaseVersion
      };
    });
    const pick = await this.quickInputService.pick(picks, {
      placeHolder: localize("selectVersion", "Select Version to Install"),
      matchOnDetail: true
    });
    if (pick) {
      if (this.extension.version === pick.id) {
        return;
      }
      try {
        if (pick.latest) {
          await this.extensionsWorkbenchService.install(this.extension, { installPreReleaseVersion: pick.isPreReleaseVersion });
        } else {
          await this.extensionsWorkbenchService.installVersion(this.extension, pick.id, { installPreReleaseVersion: pick.isPreReleaseVersion });
        }
      } catch (error) {
        this.instantiationService.createInstance(PromptExtensionInstallFailureAction, this.extension, pick.latest ? this.extension.latestVersion : pick.id, 2, error).run();
      }
    }
    return null;
  }
}, _i.ID = "workbench.extensions.action.install.anotherVersion", _i.LABEL = localize("install another version", "Install Another Version..."), _i);
InstallAnotherVersionAction = __decorate([
  __param(0, IExtensionsWorkbenchService),
  __param(1, IExtensionGalleryService),
  __param(2, IQuickInputService),
  __param(3, IInstantiationService),
  __param(4, IDialogService)
], InstallAnotherVersionAction);
let EnableForWorkspaceAction = (_j = class extends ExtensionAction {
  constructor(extensionsWorkbenchService, extensionEnablementService) {
    super(_j.ID, _j.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionEnablementService = extensionEnablementService;
    this.tooltip = localize(
      "enableForWorkspaceActionToolTip",
      "Enable this extension only in this workspace"
    );
    this.update();
  }
  update() {
    this.enabled = false;
    if (this.extension && this.extension.local) {
      this.enabled = this.extension.state === 1 && !this.extensionEnablementService.isEnabled(this.extension.local) && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local);
    }
  }
  async run() {
    if (!this.extension) {
      return;
    }
    return this.extensionsWorkbenchService.setEnablement(this.extension, 9);
  }
}, _j.ID = "extensions.enableForWorkspace", _j.LABEL = localize("enableForWorkspaceAction", "Enable (Workspace)"), _j);
EnableForWorkspaceAction = __decorate([
  __param(0, IExtensionsWorkbenchService),
  __param(1, IWorkbenchExtensionEnablementService)
], EnableForWorkspaceAction);
let EnableGloballyAction = (_k = class extends ExtensionAction {
  constructor(extensionsWorkbenchService, extensionEnablementService) {
    super(_k.ID, _k.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionEnablementService = extensionEnablementService;
    this.tooltip = localize("enableGloballyActionToolTip", "Enable this extension");
    this.update();
  }
  update() {
    this.enabled = false;
    if (this.extension && this.extension.local) {
      this.enabled = this.extension.state === 1 && this.extensionEnablementService.isDisabledGlobally(this.extension.local) && this.extensionEnablementService.canChangeEnablement(this.extension.local);
    }
  }
  async run() {
    if (!this.extension) {
      return;
    }
    return this.extensionsWorkbenchService.setEnablement(this.extension, 8);
  }
}, _k.ID = "extensions.enableGlobally", _k.LABEL = localize("enableGloballyAction", "Enable"), _k);
EnableGloballyAction = __decorate([
  __param(0, IExtensionsWorkbenchService),
  __param(1, IWorkbenchExtensionEnablementService)
], EnableGloballyAction);
let DisableForWorkspaceAction = (_l = class extends ExtensionAction {
  constructor(workspaceContextService, extensionsWorkbenchService, extensionEnablementService, extensionService) {
    super(_l.ID, _l.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
    this.workspaceContextService = workspaceContextService;
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionEnablementService = extensionEnablementService;
    this.extensionService = extensionService;
    this.tooltip = localize(
      "disableForWorkspaceActionToolTip",
      "Disable this extension only in this workspace"
    );
    this.update();
    this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
  }
  update() {
    this.enabled = false;
    if (this.extension && this.extension.local && this.extensionService.extensions.some(
      (e) => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier) && this.workspaceContextService.getWorkbenchState() !== 1
    )) {
      this.enabled = this.extension.state === 1 && (this.extension.enablementState === 8 || this.extension.enablementState === 9) && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local);
    }
  }
  async run() {
    if (!this.extension) {
      return;
    }
    return this.extensionsWorkbenchService.setEnablement(this.extension, 7);
  }
}, _l.ID = "extensions.disableForWorkspace", _l.LABEL = localize("disableForWorkspaceAction", "Disable (Workspace)"), _l);
DisableForWorkspaceAction = __decorate([
  __param(0, IWorkspaceContextService),
  __param(1, IExtensionsWorkbenchService),
  __param(2, IWorkbenchExtensionEnablementService),
  __param(3, IExtensionService)
], DisableForWorkspaceAction);
let DisableGloballyAction = (_m = class extends ExtensionAction {
  constructor(extensionsWorkbenchService, extensionEnablementService, extensionService) {
    super(_m.ID, _m.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionEnablementService = extensionEnablementService;
    this.extensionService = extensionService;
    this.tooltip = localize("disableGloballyActionToolTip", "Disable this extension");
    this.update();
    this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
  }
  update() {
    this.enabled = false;
    if (this.extension && this.extension.local && this.extensionService.extensions.some(
      (e) => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier)
    )) {
      this.enabled = this.extension.state === 1 && (this.extension.enablementState === 8 || this.extension.enablementState === 9) && this.extensionEnablementService.canChangeEnablement(this.extension.local);
    }
  }
  async run() {
    if (!this.extension) {
      return;
    }
    return this.extensionsWorkbenchService.setEnablement(this.extension, 6);
  }
}, _m.ID = "extensions.disableGlobally", _m.LABEL = localize("disableGloballyAction", "Disable"), _m);
DisableGloballyAction = __decorate([
  __param(0, IExtensionsWorkbenchService),
  __param(1, IWorkbenchExtensionEnablementService),
  __param(2, IExtensionService)
], DisableGloballyAction);
_n = class extends ExtensionAction {
  constructor(hostService, extensionService) {
    super("extensions.reload", localize("reloadAction", "Reload"), _n.DisabledClass, false);
    this.hostService = hostService;
    this.extensionService = extensionService;
    this.updateWhenCounterExtensionChanges = true;
    this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
    this.update();
  }
  update() {
    this.enabled = false;
    this.tooltip = "";
    if (!this.extension) {
      return;
    }
    const state = this.extension.state;
    if (state === 0 || state === 2) {
      return;
    }
    if (this.extension.local && this.extension.local.manifest && this.extension.local.manifest.contributes && this.extension.local.manifest.contributes.localizations && this.extension.local.manifest.contributes.localizations.length > 0) {
      return;
    }
    const reloadTooltip = this.extension.reloadRequiredStatus;
    this.enabled = reloadTooltip !== void 0;
    this.label = reloadTooltip !== void 0 ? localize("reload required", "Reload Required") : "";
    this.tooltip = reloadTooltip !== void 0 ? reloadTooltip : "";
    this.class = this.enabled ? _n.EnabledClass : _n.DisabledClass;
  }
  run() {
    return Promise.resolve(this.hostService.reload());
  }
}, _n.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} reload`, _n.DisabledClass = `${_n.EnabledClass} disabled`, _n;
function isThemeFromExtension(theme, extension) {
  return !!(extension && theme.extensionData && ExtensionIdentifier.equals(theme.extensionData.extensionId, extension.identifier.id));
}
function getQuickPickEntries(themes, currentTheme, extension, showCurrentTheme) {
  const picks = [];
  for (const theme of themes) {
    if (isThemeFromExtension(theme, extension) && !(showCurrentTheme && theme === currentTheme)) {
      picks.push({ label: theme.label, id: theme.id });
    }
  }
  if (showCurrentTheme) {
    picks.push({ type: "separator", label: localize("current", "current") });
    picks.push({ label: currentTheme.label, id: currentTheme.id });
  }
  return picks;
}
let SetColorThemeAction = (_o = class extends ExtensionAction {
  constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
    super(_o.ID, _o.TITLE.value, _o.DisabledClass, false);
    this.workbenchThemeService = workbenchThemeService;
    this.quickInputService = quickInputService;
    this.extensionEnablementService = extensionEnablementService;
    this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidColorThemeChange)(() => this.update(), this));
    this.update();
  }
  update() {
    this.workbenchThemeService.getColorThemes().then((colorThemes) => {
      this.enabled = this.computeEnablement(colorThemes);
      this.class = this.enabled ? _o.EnabledClass : _o.DisabledClass;
    });
  }
  computeEnablement(colorThemes) {
    return !!this.extension && this.extension.state === 1 && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && colorThemes.some((th) => isThemeFromExtension(th, this.extension));
  }
  async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
    const colorThemes = await this.workbenchThemeService.getColorThemes();
    if (!this.computeEnablement(colorThemes)) {
      return;
    }
    const currentTheme = this.workbenchThemeService.getColorTheme();
    const delayer = new Delayer(100);
    const picks = getQuickPickEntries(colorThemes, currentTheme, this.extension, showCurrentTheme);
    const pickedTheme = await this.quickInputService.pick(picks, {
      placeHolder: localize("select color theme", "Select Color Theme"),
      onDidFocus: (item) => delayer.trigger(() => this.workbenchThemeService.setColorTheme(item.id, void 0)),
      ignoreFocusLost
    });
    return this.workbenchThemeService.setColorTheme(pickedTheme ? pickedTheme.id : currentTheme.id, "auto");
  }
}, _o.ID = "workbench.extensions.action.setColorTheme", _o.TITLE = { value: localize("workbench.extensions.action.setColorTheme", "Set Color Theme"), original: "Set Color Theme" }, _o.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`, _o.DisabledClass = `${_o.EnabledClass} disabled`, _o);
SetColorThemeAction = __decorate([
  __param(0, IExtensionService),
  __param(1, IWorkbenchThemeService),
  __param(2, IQuickInputService),
  __param(3, IWorkbenchExtensionEnablementService)
], SetColorThemeAction);
let SetFileIconThemeAction = (_p = class extends ExtensionAction {
  constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
    super(_p.ID, _p.TITLE.value, _p.DisabledClass, false);
    this.workbenchThemeService = workbenchThemeService;
    this.quickInputService = quickInputService;
    this.extensionEnablementService = extensionEnablementService;
    this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidFileIconThemeChange)(() => this.update(), this));
    this.update();
  }
  update() {
    this.workbenchThemeService.getFileIconThemes().then((fileIconThemes) => {
      this.enabled = this.computeEnablement(fileIconThemes);
      this.class = this.enabled ? _p.EnabledClass : _p.DisabledClass;
    });
  }
  computeEnablement(colorThemfileIconThemess) {
    return !!this.extension && this.extension.state === 1 && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && colorThemfileIconThemess.some((th) => isThemeFromExtension(th, this.extension));
  }
  async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
    const fileIconThemes = await this.workbenchThemeService.getFileIconThemes();
    if (!this.computeEnablement(fileIconThemes)) {
      return;
    }
    const currentTheme = this.workbenchThemeService.getFileIconTheme();
    const delayer = new Delayer(100);
    const picks = getQuickPickEntries(fileIconThemes, currentTheme, this.extension, showCurrentTheme);
    const pickedTheme = await this.quickInputService.pick(picks, {
      placeHolder: localize("select file icon theme", "Select File Icon Theme"),
      onDidFocus: (item) => delayer.trigger(() => this.workbenchThemeService.setFileIconTheme(item.id, void 0)),
      ignoreFocusLost
    });
    return this.workbenchThemeService.setFileIconTheme(pickedTheme ? pickedTheme.id : currentTheme.id, "auto");
  }
}, _p.ID = "workbench.extensions.action.setFileIconTheme", _p.TITLE = { value: localize("workbench.extensions.action.setFileIconTheme", "Set File Icon Theme"), original: "Set File Icon Theme" }, _p.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`, _p.DisabledClass = `${_p.EnabledClass} disabled`, _p);
SetFileIconThemeAction = __decorate([
  __param(0, IExtensionService),
  __param(1, IWorkbenchThemeService),
  __param(2, IQuickInputService),
  __param(3, IWorkbenchExtensionEnablementService)
], SetFileIconThemeAction);
let SetProductIconThemeAction = (_q = class extends ExtensionAction {
  constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
    super(_q.ID, _q.TITLE.value, _q.DisabledClass, false);
    this.workbenchThemeService = workbenchThemeService;
    this.quickInputService = quickInputService;
    this.extensionEnablementService = extensionEnablementService;
    this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidProductIconThemeChange)(() => this.update(), this));
    this.update();
  }
  update() {
    this.workbenchThemeService.getProductIconThemes().then((productIconThemes) => {
      this.enabled = this.computeEnablement(productIconThemes);
      this.class = this.enabled ? _q.EnabledClass : _q.DisabledClass;
    });
  }
  computeEnablement(productIconThemes) {
    return !!this.extension && this.extension.state === 1 && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && productIconThemes.some((th) => isThemeFromExtension(th, this.extension));
  }
  async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
    const productIconThemes = await this.workbenchThemeService.getProductIconThemes();
    if (!this.computeEnablement(productIconThemes)) {
      return;
    }
    const currentTheme = this.workbenchThemeService.getProductIconTheme();
    const delayer = new Delayer(100);
    const picks = getQuickPickEntries(productIconThemes, currentTheme, this.extension, showCurrentTheme);
    const pickedTheme = await this.quickInputService.pick(picks, {
      placeHolder: localize("select product icon theme", "Select Product Icon Theme"),
      onDidFocus: (item) => delayer.trigger(() => this.workbenchThemeService.setProductIconTheme(item.id, void 0)),
      ignoreFocusLost
    });
    return this.workbenchThemeService.setProductIconTheme(pickedTheme ? pickedTheme.id : currentTheme.id, "auto");
  }
}, _q.ID = "workbench.extensions.action.setProductIconTheme", _q.TITLE = { value: localize(
  "workbench.extensions.action.setProductIconTheme",
  "Set Product Icon Theme"
), original: "Set Product Icon Theme" }, _q.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`, _q.DisabledClass = `${_q.EnabledClass} disabled`, _q);
SetProductIconThemeAction = __decorate([
  __param(0, IExtensionService),
  __param(1, IWorkbenchThemeService),
  __param(2, IQuickInputService),
  __param(3, IWorkbenchExtensionEnablementService)
], SetProductIconThemeAction);
_r = class extends ExtensionAction {
  constructor(extensionsWorkbenchService) {
    super(_r.ID, _r.TITLE.value, _r.DisabledClass, false);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.update();
  }
  update() {
    this.enabled = false;
    this.class = _r.DisabledClass;
    if (!this.extension) {
      return;
    }
    if (!this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
      return;
    }
    if (this.extension.gallery && language === getLocale(this.extension.gallery)) {
      return;
    }
    this.enabled = true;
    this.class = _r.EnabledClass;
  }
  async run() {
    return this.extension && this.extensionsWorkbenchService.setLanguage(this.extension);
  }
}, _r.ID = "workbench.extensions.action.setDisplayLanguage", _r.TITLE = { value: localize("workbench.extensions.action.setDisplayLanguage", "Set Display Language"), original: "Set Display Language" }, _r.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} language`, _r.DisabledClass = `${_r.EnabledClass} disabled`, _r;
_s = class extends ExtensionAction {
  constructor(extensionsWorkbenchService, localeService) {
    super(_s.ID, _s.TITLE.value, _s.DisabledClass, false);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.localeService = localeService;
    this.update();
  }
  update() {
    this.enabled = false;
    this.class = _s.DisabledClass;
    if (!this.extension) {
      return;
    }
    if (!this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
      return;
    }
    if (this.extension.gallery && language !== getLocale(this.extension.gallery)) {
      return;
    }
    this.enabled = true;
    this.class = _s.EnabledClass;
  }
  async run() {
    return this.extension && this.localeService.clearLocalePreference();
  }
}, _s.ID = "workbench.extensions.action.clearLanguage", _s.TITLE = { value: localize("workbench.extensions.action.clearLanguage", "Clear Display Language"), original: "Clear Display Language" }, _s.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} language`, _s.DisabledClass = `${_s.EnabledClass} disabled`, _s;
_t = class extends Action {
  constructor(extensionId, paneCompositeService, extensionWorkbenchService) {
    super(_t.ID, _t.LABEL, void 0, false);
    this.paneCompositeService = paneCompositeService;
    this.extensionWorkbenchService = extensionWorkbenchService;
    this.extensionId = extensionId;
  }
  async run() {
    const paneComposite = await this.paneCompositeService.openPaneComposite(VIEWLET_ID, 0, true);
    const paneContainer = paneComposite == null ? void 0 : paneComposite.getViewPaneContainer();
    paneContainer.search(`@id:${this.extensionId}`);
    paneContainer.focus();
    const [extension] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: "install-recommendation" }, CancellationToken.None);
    if (extension) {
      return this.extensionWorkbenchService.open(extension);
    }
    return null;
  }
}, _t.ID = "workbench.extensions.action.showRecommendedExtension", _t.LABEL = localize("showRecommendedExtension", "Show Recommended Extension"), _t;
let InstallRecommendedExtensionAction = (_u = class extends Action {
  constructor(extensionId, paneCompositeService, instantiationService, extensionWorkbenchService) {
    super(_u.ID, _u.LABEL, void 0, false);
    this.paneCompositeService = paneCompositeService;
    this.instantiationService = instantiationService;
    this.extensionWorkbenchService = extensionWorkbenchService;
    this.extensionId = extensionId;
  }
  async run() {
    const viewlet = await this.paneCompositeService.openPaneComposite(VIEWLET_ID, 0, true);
    const viewPaneContainer = viewlet == null ? void 0 : viewlet.getViewPaneContainer();
    viewPaneContainer.search(`@id:${this.extensionId}`);
    viewPaneContainer.focus();
    const [extension] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: "install-recommendation" }, CancellationToken.None);
    if (extension) {
      await this.extensionWorkbenchService.open(extension);
      try {
        await this.extensionWorkbenchService.install(extension);
      } catch (err) {
        this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, extension.latestVersion, 2, err).run();
      }
    }
  }
}, _u.ID = "workbench.extensions.action.installRecommendedExtension", _u.LABEL = localize("installRecommendedExtension", "Install Recommended Extension"), _u);
InstallRecommendedExtensionAction = __decorate([
  __param(1, IPaneCompositePartService),
  __param(2, IInstantiationService),
  __param(3, IExtensionsWorkbenchService)
], InstallRecommendedExtensionAction);
_v = class extends Action {
  constructor(extension, extensionRecommendationsManagementService) {
    super(_v.ID, "Ignore Recommendation");
    this.extension = extension;
    this.extensionRecommendationsManagementService = extensionRecommendationsManagementService;
    this.class = _v.Class;
    this.tooltip = localize("ignoreExtensionRecommendation", "Do not recommend this extension again");
    this.enabled = true;
  }
  run() {
    this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, true);
    return Promise.resolve();
  }
}, _v.ID = "extensions.ignore", _v.Class = `${ExtensionAction.LABEL_ACTION_CLASS} ignore`, _v;
_w = class extends Action {
  constructor(extension, extensionRecommendationsManagementService) {
    super(_w.ID, "Undo");
    this.extension = extension;
    this.extensionRecommendationsManagementService = extensionRecommendationsManagementService;
    this.class = _w.Class;
    this.tooltip = localize("undo", "Undo");
    this.enabled = true;
  }
  run() {
    this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, false);
    return Promise.resolve();
  }
}, _w.ID = "extensions.ignore", _w.Class = `${ExtensionAction.LABEL_ACTION_CLASS} undo-ignore`, _w;
let SearchExtensionsAction = class SearchExtensionsAction2 extends Action {
  constructor(searchValue, paneCompositeService) {
    super("extensions.searchExtensions", localize("search recommendations", "Search Extensions"), void 0, true);
    this.searchValue = searchValue;
    this.paneCompositeService = paneCompositeService;
  }
  async run() {
    var _a2;
    const viewPaneContainer = (_a2 = await this.paneCompositeService.openPaneComposite(VIEWLET_ID, 0, true)) == null ? void 0 : _a2.getViewPaneContainer();
    viewPaneContainer.search(this.searchValue);
    viewPaneContainer.focus();
  }
};
SearchExtensionsAction = __decorate([
  __param(1, IPaneCompositePartService)
], SearchExtensionsAction);
let AbstractConfigureRecommendedExtensionsAction = class AbstractConfigureRecommendedExtensionsAction2 extends Action {
  constructor(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService) {
    super(id, label);
    this.contextService = contextService;
    this.fileService = fileService;
    this.textFileService = textFileService;
    this.editorService = editorService;
    this.jsonEditingService = jsonEditingService;
    this.textModelResolverService = textModelResolverService;
  }
  openExtensionsFile(extensionsFileResource) {
    return this.getOrCreateExtensionsFile(extensionsFileResource).then(({ created, content }) => this.getSelectionPosition(content, extensionsFileResource, ["recommendations"]).then((selection) => this.editorService.openEditor({
      resource: extensionsFileResource,
      options: {
        pinned: created,
        selection
      }
    })), (error) => Promise.reject(new Error(localize(
      "OpenExtensionsFile.failed",
      "Unable to create 'extensions.json' file inside the '.vscode' folder ({0}).",
      error
    ))));
  }
  openWorkspaceConfigurationFile(workspaceConfigurationFile) {
    return this.getOrUpdateWorkspaceConfigurationFile(workspaceConfigurationFile).then((content) => this.getSelectionPosition(content.value.toString(), content.resource, ["extensions", "recommendations"])).then((selection) => this.editorService.openEditor({
      resource: workspaceConfigurationFile,
      options: {
        selection,
        forceReload: true
      }
    }));
  }
  getOrUpdateWorkspaceConfigurationFile(workspaceConfigurationFile) {
    return Promise.resolve(this.fileService.readFile(workspaceConfigurationFile)).then((content) => {
      const workspaceRecommendations = parse(content.value.toString())["extensions"];
      if (!workspaceRecommendations || !workspaceRecommendations.recommendations) {
        return this.jsonEditingService.write(workspaceConfigurationFile, [{ path: ["extensions"], value: { recommendations: [] } }], true).then(() => this.fileService.readFile(workspaceConfigurationFile));
      }
      return content;
    });
  }
  getSelectionPosition(content, resource, path) {
    const tree = parseTree(content);
    const node = findNodeAtLocation(tree, path);
    if (node && node.parent && node.parent.children) {
      const recommendationsValueNode = node.parent.children[1];
      const lastExtensionNode = recommendationsValueNode.children && recommendationsValueNode.children.length ? recommendationsValueNode.children[recommendationsValueNode.children.length - 1] : null;
      const offset = lastExtensionNode ? lastExtensionNode.offset + lastExtensionNode.length : recommendationsValueNode.offset + 1;
      return Promise.resolve(this.textModelResolverService.createModelReference(resource)).then((reference) => {
        const position = reference.object.textEditorModel.getPositionAt(offset);
        reference.dispose();
        return {
          startLineNumber: position.lineNumber,
          startColumn: position.column,
          endLineNumber: position.lineNumber,
          endColumn: position.column
        };
      });
    }
    return Promise.resolve(void 0);
  }
  getOrCreateExtensionsFile(extensionsFileResource) {
    return Promise.resolve(this.fileService.readFile(extensionsFileResource)).then((content) => {
      return { created: false, extensionsFileResource, content: content.value.toString() };
    }, (err) => {
      return this.textFileService.write(extensionsFileResource, ExtensionsConfigurationInitialContent).then(() => {
        return { created: true, extensionsFileResource, content: ExtensionsConfigurationInitialContent };
      });
    });
  }
};
AbstractConfigureRecommendedExtensionsAction = __decorate([
  __param(2, IWorkspaceContextService),
  __param(3, IFileService),
  __param(4, ITextFileService),
  __param(5, IEditorService),
  __param(6, IJSONEditingService),
  __param(7, ITextModelService)
], AbstractConfigureRecommendedExtensionsAction);
_x = class extends AbstractConfigureRecommendedExtensionsAction {
  constructor(id, label, fileService, textFileService, contextService, editorService, jsonEditingService, textModelResolverService) {
    super(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService);
    this._register(this.contextService.onDidChangeWorkbenchState(() => this.update(), this));
    this.update();
  }
  update() {
    this.enabled = this.contextService.getWorkbenchState() !== 1;
  }
  run() {
    switch (this.contextService.getWorkbenchState()) {
      case 2:
        return this.openExtensionsFile(this.contextService.getWorkspace().folders[0].toResource(EXTENSIONS_CONFIG));
      case 3:
        return this.openWorkspaceConfigurationFile(this.contextService.getWorkspace().configuration);
    }
    return Promise.resolve();
  }
}, _x.ID = "workbench.extensions.action.configureWorkspaceRecommendedExtensions", _x.LABEL = localize(
  "configureWorkspaceRecommendedExtensions",
  "Configure Recommended Extensions (Workspace)"
), _x;
_y = class extends AbstractConfigureRecommendedExtensionsAction {
  constructor(id, label, fileService, textFileService, contextService, editorService, jsonEditingService, textModelResolverService, commandService) {
    super(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService);
    this.commandService = commandService;
  }
  run() {
    const folderCount = this.contextService.getWorkspace().folders.length;
    const pickFolderPromise = folderCount === 1 ? Promise.resolve(this.contextService.getWorkspace().folders[0]) : this.commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID);
    return Promise.resolve(pickFolderPromise).then((workspaceFolder) => {
      if (workspaceFolder) {
        return this.openExtensionsFile(workspaceFolder.toResource(EXTENSIONS_CONFIG));
      }
      return null;
    });
  }
}, _y.ID = "workbench.extensions.action.configureWorkspaceFolderRecommendedExtensions", _y.LABEL = localize(
  "configureWorkspaceFolderRecommendedExtensions",
  "Configure Recommended Extensions (Workspace Folder)"
), _y;
_z = class extends Action {
  get extension() {
    return this._extension;
  }
  set extension(extension) {
    if (!(this._extension && extension && areSameExtensions(this._extension.identifier, extension.identifier))) {
      this.initialStatus = null;
      this.status = null;
      this.enablementState = null;
    }
    this._extension = extension;
    this.update();
  }
  constructor(extensionService, extensionManagementServerService, extensionEnablementService) {
    super("extensions.action.statusLabel", "", _z.DISABLED_CLASS, false);
    this.extensionService = extensionService;
    this.extensionManagementServerService = extensionManagementServerService;
    this.extensionEnablementService = extensionEnablementService;
    this.initialStatus = null;
    this.status = null;
    this.version = null;
    this.enablementState = null;
    this._extension = null;
  }
  update() {
    const label = this.computeLabel();
    this.label = label || "";
    this.class = label ? _z.ENABLED_CLASS : _z.DISABLED_CLASS;
  }
  computeLabel() {
    if (!this.extension) {
      return null;
    }
    const currentStatus = this.status;
    const currentVersion = this.version;
    const currentEnablementState = this.enablementState;
    this.status = this.extension.state;
    this.version = this.extension.version;
    if (this.initialStatus === null) {
      this.initialStatus = this.status;
    }
    this.enablementState = this.extension.enablementState;
    const canAddExtension = () => {
      const runningExtension = this.extensionService.extensions.filter((e) => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier))[0];
      if (this.extension.local) {
        if (runningExtension && this.extension.version === runningExtension.version) {
          return true;
        }
        return this.extensionService.canAddExtension(toExtensionDescription(this.extension.local));
      }
      return false;
    };
    const canRemoveExtension = () => {
      if (this.extension.local) {
        if (this.extensionService.extensions.every((e) => !(areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier) && this.extension.server === this.extensionManagementServerService.getExtensionManagementServer(toExtension(e))))) {
          return true;
        }
        return this.extensionService.canRemoveExtension(toExtensionDescription(this.extension.local));
      }
      return false;
    };
    if (currentStatus !== null) {
      if (currentStatus === 0 && this.status === 1) {
        return canAddExtension() ? this.initialStatus === 1 && this.version !== currentVersion ? localize("updated", "Updated") : localize("installed", "Installed") : null;
      }
      if (currentStatus === 2 && this.status === 3) {
        this.initialStatus = this.status;
        return canRemoveExtension() ? localize("uninstalled", "Uninstalled") : null;
      }
    }
    if (currentEnablementState !== null) {
      const currentlyEnabled = this.extensionEnablementService.isEnabledEnablementState(currentEnablementState);
      const enabled = this.extensionEnablementService.isEnabledEnablementState(this.enablementState);
      if (!currentlyEnabled && enabled) {
        return canAddExtension() ? localize("enabled", "Enabled") : null;
      }
      if (currentlyEnabled && !enabled) {
        return canRemoveExtension() ? localize("disabled", "Disabled") : null;
      }
    }
    return null;
  }
  run() {
    return Promise.resolve();
  }
}, _z.ENABLED_CLASS = `${ExtensionAction.TEXT_ACTION_CLASS} extension-status-label`, _z.DISABLED_CLASS = `${_z.ENABLED_CLASS} hide`, _z;
_A = class extends ExtensionDropDownAction {
  constructor(configurationService, extensionsWorkbenchService, userDataSyncEnablementService, instantiationService) {
    super("extensions.sync", "", _A.SYNC_CLASS, false, instantiationService);
    this.configurationService = configurationService;
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.userDataSyncEnablementService = userDataSyncEnablementService;
    this._register(Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration("settingsSync.ignoredExtensions"))(() => this.update()));
    this._register(userDataSyncEnablementService.onDidChangeEnablement(() => this.update()));
    this.update();
  }
  update() {
    this.enabled = !!this.extension && this.userDataSyncEnablementService.isEnabled() && this.extension.state === 1;
    if (this.extension) {
      const isIgnored = this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension);
      this.class = isIgnored ? _A.IGNORED_SYNC_CLASS : _A.SYNC_CLASS;
      this.tooltip = isIgnored ? localize("ignored", "This extension is ignored during sync") : localize("synced", "This extension is synced");
    }
  }
  async run() {
    return super.run({
      actionGroups: [
        [
          new Action(
            "extensions.syncignore",
            this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension) ? localize("sync", "Sync this extension") : localize("do not sync", "Do not sync this extension"),
            void 0,
            true,
            () => this.extensionsWorkbenchService.toggleExtensionIgnoredToSync(this.extension)
          )
        ]
      ],
      disposeActionsOnHide: true
    });
  }
}, _A.IGNORED_SYNC_CLASS = `${ExtensionAction.ICON_ACTION_CLASS} extension-sync ${ThemeIcon.asClassName(syncIgnoredIcon)}`, _A.SYNC_CLASS = `${_A.ICON_ACTION_CLASS} extension-sync ${ThemeIcon.asClassName(syncEnabledIcon)}`, _A;
_B = class extends ExtensionAction {
  get status() {
    return this._status;
  }
  constructor(extensionManagementServerService, labelService, commandService, workspaceTrustEnablementService, workspaceTrustService, extensionsWorkbenchService, extensionService, extensionManifestPropertiesService, contextService, productService, workbenchExtensionEnablementService) {
    super("extensions.status", "", `${_B.CLASS} hide`, false);
    this.extensionManagementServerService = extensionManagementServerService;
    this.labelService = labelService;
    this.commandService = commandService;
    this.workspaceTrustEnablementService = workspaceTrustEnablementService;
    this.workspaceTrustService = workspaceTrustService;
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionService = extensionService;
    this.extensionManifestPropertiesService = extensionManifestPropertiesService;
    this.contextService = contextService;
    this.productService = productService;
    this.workbenchExtensionEnablementService = workbenchExtensionEnablementService;
    this.updateWhenCounterExtensionChanges = true;
    this._onDidChangeStatus = this._register(new Emitter());
    this.onDidChangeStatus = this._onDidChangeStatus.event;
    this.updateThrottler = new Throttler();
    this._register(this.labelService.onDidChangeFormatters(() => this.update(), this));
    this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
    this.update();
  }
  update() {
    this.updateThrottler.queue(() => this.computeAndUpdateStatus());
  }
  async computeAndUpdateStatus() {
    var _a2, _b2, _c2, _d2;
    this.updateStatus(void 0, true);
    this.enabled = false;
    if (!this.extension) {
      return;
    }
    if (this.extension.isMalicious) {
      this.updateStatus({ icon: warningIcon, message: new MarkdownString(
        localize("malicious tooltip", "This extension was reported to be problematic.")
      ) }, true);
      return;
    }
    if (this.extension.deprecationInfo) {
      if (this.extension.deprecationInfo.extension) {
        const link = `[${this.extension.deprecationInfo.extension.displayName}](${URI.parse(
          `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.deprecationInfo.extension.id]))}`
        )})`;
        this.updateStatus({ icon: warningIcon, message: new MarkdownString(localize(
          "deprecated with alternate extension tooltip",
          "This extension is deprecated. Use the {0} extension instead.",
          link
        )) }, true);
      } else if (this.extension.deprecationInfo.settings) {
        const link = `[${localize("settings", "settings")}](${URI.parse(
          `command:workbench.action.openSettings?${encodeURIComponent(JSON.stringify([this.extension.deprecationInfo.settings.map((setting) => `@id:${setting}`).join(" ")]))}`
        )})`;
        this.updateStatus({ icon: warningIcon, message: new MarkdownString(localize(
          "deprecated with alternate settings tooltip",
          "This extension is deprecated as this functionality is now built-in to VS Code. Configure these {0} to use this functionality.",
          link
        )) }, true);
      } else {
        const message = new MarkdownString(localize(
          "deprecated tooltip",
          "This extension is deprecated as it is no longer being maintained."
        ));
        if (this.extension.deprecationInfo.additionalInfo) {
          message.appendMarkdown(` ${this.extension.deprecationInfo.additionalInfo}`);
        }
        this.updateStatus({ icon: warningIcon, message }, true);
      }
      return;
    }
    if (this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
      return;
    }
    if (this.extension.gallery && this.extension.state === 3 && !await this.extensionsWorkbenchService.canInstall(this.extension)) {
      if (this.extensionManagementServerService.localExtensionManagementServer || this.extensionManagementServerService.remoteExtensionManagementServer) {
        const targetPlatform = await (this.extensionManagementServerService.localExtensionManagementServer ? this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.getTargetPlatform() : this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform());
        const message = new MarkdownString(`${localize(
          "incompatible platform",
          "The '{0}' extension is not available in {1} for {2}.",
          this.extension.displayName || this.extension.identifier.id,
          this.productService.nameLong,
          TargetPlatformToString(targetPlatform)
        )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-platform-specific-extensions)`);
        this.updateStatus({ icon: warningIcon, message }, true);
        return;
      }
      if (this.extensionManagementServerService.webExtensionManagementServer) {
        const productName = localize("VS Code for Web", "{0} for the Web", this.productService.nameLong);
        const message = new MarkdownString(`${localize(
          "not web tooltip",
          "The '{0}' extension is not available in {1}.",
          this.extension.displayName || this.extension.identifier.id,
          productName
        )} [${localize("learn why", "Learn Why")}](https://aka.ms/vscode-web-extensions-guide)`);
        this.updateStatus({ icon: warningIcon, message }, true);
        return;
      }
    }
    if (!this.extension.local || !this.extension.server || this.extension.state !== 1) {
      return;
    }
    if (this.extension.enablementState === 2) {
      this.updateStatus({ message: new MarkdownString(localize(
        "disabled by environment",
        "This extension is disabled by the environment."
      )) }, true);
      return;
    }
    if (this.extension.enablementState === 3) {
      this.updateStatus({ message: new MarkdownString(localize(
        "enabled by environment",
        "This extension is enabled because it is required in the current environment."
      )) }, true);
      return;
    }
    if (this.extension.enablementState === 4) {
      const details = getWorkspaceSupportTypeMessage((_a2 = this.extension.local.manifest.capabilities) == null ? void 0 : _a2.virtualWorkspaces);
      this.updateStatus({ icon: infoIcon, message: new MarkdownString(details ? escapeMarkdownSyntaxTokens(details) : localize(
        "disabled because of virtual workspace",
        "This extension has been disabled because it does not support virtual workspaces."
      )) }, true);
      return;
    }
    if (isVirtualWorkspace(this.contextService.getWorkspace())) {
      const virtualSupportType = this.extensionManifestPropertiesService.getExtensionVirtualWorkspaceSupportType(this.extension.local.manifest);
      const details = getWorkspaceSupportTypeMessage((_b2 = this.extension.local.manifest.capabilities) == null ? void 0 : _b2.virtualWorkspaces);
      if (virtualSupportType === "limited" || details) {
        this.updateStatus({ icon: warningIcon, message: new MarkdownString(details ? escapeMarkdownSyntaxTokens(details) : localize(
          "extension limited because of virtual workspace",
          "This extension has limited features because the current workspace is virtual."
        )) }, true);
        return;
      }
    }
    if (this.extension.enablementState === 0 || this.extension.enablementState === 5 && this.workbenchExtensionEnablementService.getDependenciesEnablementStates(this.extension.local).every(([, enablementState]) => this.workbenchExtensionEnablementService.isEnabledEnablementState(enablementState) || enablementState === 0)) {
      this.enabled = true;
      const untrustedDetails = getWorkspaceSupportTypeMessage((_c2 = this.extension.local.manifest.capabilities) == null ? void 0 : _c2.untrustedWorkspaces);
      this.updateStatus({ icon: trustIcon, message: new MarkdownString(
        untrustedDetails ? escapeMarkdownSyntaxTokens(untrustedDetails) : localize(
          "extension disabled because of trust requirement",
          "This extension has been disabled because the current workspace is not trusted."
        )
      ) }, true);
      return;
    }
    if (this.workspaceTrustEnablementService.isWorkspaceTrustEnabled() && !this.workspaceTrustService.isWorkspaceTrusted()) {
      const untrustedSupportType = this.extensionManifestPropertiesService.getExtensionUntrustedWorkspaceSupportType(this.extension.local.manifest);
      const untrustedDetails = getWorkspaceSupportTypeMessage((_d2 = this.extension.local.manifest.capabilities) == null ? void 0 : _d2.untrustedWorkspaces);
      if (untrustedSupportType === "limited" || untrustedDetails) {
        this.enabled = true;
        this.updateStatus({ icon: trustIcon, message: new MarkdownString(
          untrustedDetails ? escapeMarkdownSyntaxTokens(untrustedDetails) : localize(
            "extension limited because of trust requirement",
            "This extension has limited features because the current workspace is not trusted."
          )
        ) }, true);
        return;
      }
    }
    if (this.extension.enablementState === 1) {
      if (!this.extensionsWorkbenchService.installed.some(
        (e) => areSameExtensions(e.identifier, this.extension.identifier) && e.server !== this.extension.server
      )) {
        let message;
        if (this.extensionManagementServerService.localExtensionManagementServer === this.extension.server) {
          if (this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
            if (this.extensionManagementServerService.remoteExtensionManagementServer) {
              message = new MarkdownString(`${localize(
                "Install in remote server to enable",
                "This extension is disabled in this workspace because it is defined to run in the Remote Extension Host. Please install the extension in '{0}' to enable.",
                this.extensionManagementServerService.remoteExtensionManagementServer.label
              )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`);
            }
          }
        } else if (this.extensionManagementServerService.remoteExtensionManagementServer === this.extension.server) {
          if (this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
            if (this.extensionManagementServerService.localExtensionManagementServer) {
              message = new MarkdownString(`${localize(
                "Install in local server to enable",
                "This extension is disabled in this workspace because it is defined to run in the Local Extension Host. Please install the extension locally to enable.",
                this.extensionManagementServerService.remoteExtensionManagementServer.label
              )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`);
            } else if (isWeb) {
              message = new MarkdownString(`${localize(
                "Defined to run in desktop",
                "This extension is disabled because it is defined to run only in {0} for the Desktop.",
                this.productService.nameLong
              )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`);
            }
          }
        } else if (this.extensionManagementServerService.webExtensionManagementServer === this.extension.server) {
          message = new MarkdownString(`${localize(
            "Cannot be enabled",
            "This extension is disabled because it is not supported in {0} for the Web.",
            this.productService.nameLong
          )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`);
        }
        if (message) {
          this.updateStatus({ icon: warningIcon, message }, true);
        }
        return;
      }
    }
    if (this.extensionManagementServerService.remoteExtensionManagementServer) {
      if (isLanguagePackExtension(this.extension.local.manifest)) {
        if (!this.extensionsWorkbenchService.installed.some(
          (e) => areSameExtensions(e.identifier, this.extension.identifier) && e.server !== this.extension.server
        )) {
          const message = this.extension.server === this.extensionManagementServerService.localExtensionManagementServer ? new MarkdownString(localize(
            "Install language pack also in remote server",
            "Install the language pack extension on '{0}' to enable it there also.",
            this.extensionManagementServerService.remoteExtensionManagementServer.label
          )) : new MarkdownString(localize(
            "Install language pack also locally",
            "Install the language pack extension locally to enable it there also."
          ));
          this.updateStatus({ icon: infoIcon, message }, true);
        }
        return;
      }
      const runningExtension = this.extensionService.extensions.filter((e) => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier))[0];
      const runningExtensionServer = runningExtension ? this.extensionManagementServerService.getExtensionManagementServer(toExtension(runningExtension)) : null;
      if (this.extension.server === this.extensionManagementServerService.localExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.remoteExtensionManagementServer) {
        if (this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
          this.updateStatus({ icon: infoIcon, message: new MarkdownString(`${localize(
            "enabled remotely",
            "This extension is enabled in the Remote Extension Host because it prefers to run there."
          )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`) }, true);
        }
        return;
      }
      if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.localExtensionManagementServer) {
        if (this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
          this.updateStatus({ icon: infoIcon, message: new MarkdownString(`${localize(
            "enabled locally",
            "This extension is enabled in the Local Extension Host because it prefers to run there."
          )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`) }, true);
        }
        return;
      }
      if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.webExtensionManagementServer) {
        if (this.extensionManifestPropertiesService.canExecuteOnWeb(this.extension.local.manifest)) {
          this.updateStatus({ icon: infoIcon, message: new MarkdownString(`${localize(
            "enabled in web worker",
            "This extension is enabled in the Web Worker Extension Host because it prefers to run there."
          )} [${localize("learn more", "Learn More")}](https://aka.ms/vscode-remote/developing-extensions/architecture)`) }, true);
        }
        return;
      }
    }
    if (this.extension.enablementState === 5) {
      this.updateStatus({ icon: warningIcon, message: new MarkdownString(localize(
        "extension disabled because of dependency",
        "This extension has been disabled because it depends on an extension that is disabled."
      )) }, true);
      return;
    }
    const isEnabled = this.workbenchExtensionEnablementService.isEnabled(this.extension.local);
    const isRunning = this.extensionService.extensions.some(
      (e) => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier)
    );
    if (isEnabled && isRunning) {
      if (this.extensionManagementServerService.localExtensionManagementServer && this.extensionManagementServerService.remoteExtensionManagementServer) {
        if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer) {
          this.updateStatus({ message: new MarkdownString(localize(
            "extension enabled on remote",
            "Extension is enabled on '{0}'",
            this.extension.server.label
          )) }, true);
          return;
        }
      }
      if (this.extension.enablementState === 8) {
        this.updateStatus({ message: new MarkdownString(
          localize("globally enabled", "This extension is enabled globally.")
        ) }, true);
        return;
      }
      if (this.extension.enablementState === 9) {
        this.updateStatus({ message: new MarkdownString(localize(
          "workspace enabled",
          "This extension is enabled for this workspace by the user."
        )) }, true);
        return;
      }
    }
    if (!isEnabled && !isRunning) {
      if (this.extension.enablementState === 6) {
        this.updateStatus({ message: new MarkdownString(
          localize("globally disabled", "This extension is disabled globally by the user.")
        ) }, true);
        return;
      }
      if (this.extension.enablementState === 7) {
        this.updateStatus({ message: new MarkdownString(localize(
          "workspace disabled",
          "This extension is disabled for this workspace by the user."
        )) }, true);
        return;
      }
    }
    if (isEnabled && !isRunning && !this.extension.local.isValid) {
      const errors = this.extension.local.validations.filter(([severity]) => severity === Severity.Error).map(([, message]) => message);
      this.updateStatus({ icon: errorIcon, message: new MarkdownString(errors.join(" ").trim()) }, true);
    }
  }
  updateStatus(status, updateClass) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    if (this._status === status) {
      return;
    }
    if (this._status && status && this._status.message === status.message && ((_a2 = this._status.icon) == null ? void 0 : _a2.id) === ((_b2 = status.icon) == null ? void 0 : _b2.id)) {
      return;
    }
    this._status = status;
    if (updateClass) {
      if (((_c2 = this._status) == null ? void 0 : _c2.icon) === errorIcon) {
        this.class = `${_B.CLASS} extension-status-error ${ThemeIcon.asClassName(errorIcon)}`;
      } else if (((_d2 = this._status) == null ? void 0 : _d2.icon) === warningIcon) {
        this.class = `${_B.CLASS} extension-status-warning ${ThemeIcon.asClassName(warningIcon)}`;
      } else if (((_e2 = this._status) == null ? void 0 : _e2.icon) === infoIcon) {
        this.class = `${_B.CLASS} extension-status-info ${ThemeIcon.asClassName(infoIcon)}`;
      } else if (((_f2 = this._status) == null ? void 0 : _f2.icon) === trustIcon) {
        this.class = `${_B.CLASS} ${ThemeIcon.asClassName(trustIcon)}`;
      } else {
        this.class = `${_B.CLASS} hide`;
      }
    }
    this._onDidChangeStatus.fire();
  }
  async run() {
    var _a2;
    if (((_a2 = this._status) == null ? void 0 : _a2.icon) === trustIcon) {
      return this.commandService.executeCommand("workbench.trust.manage");
    }
  }
}, _B.CLASS = `${ExtensionAction.ICON_ACTION_CLASS} extension-status`, _B;
_C = class extends Action {
  constructor(id = _C.ID, label = _C.LABEL, extensionsWorkbenchService, extensionManagementServerService, quickInputService, notificationService, hostService, instantiationService, extensionService) {
    super(id, label);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.extensionManagementServerService = extensionManagementServerService;
    this.quickInputService = quickInputService;
    this.notificationService = notificationService;
    this.hostService = hostService;
    this.instantiationService = instantiationService;
    this.extensionService = extensionService;
  }
  get enabled() {
    return this.extensionsWorkbenchService.local.filter((l) => !l.isBuiltin && l.local).length > 0;
  }
  run() {
    return this.quickInputService.pick(this.getEntries(), { placeHolder: localize("selectExtensionToReinstall", "Select Extension to Reinstall") }).then((pick) => pick && this.reinstallExtension(pick.extension));
  }
  getEntries() {
    return this.extensionsWorkbenchService.queryLocal().then((local) => {
      const entries = local.filter((extension) => !extension.isBuiltin && extension.server !== this.extensionManagementServerService.webExtensionManagementServer).map((extension) => {
        return {
          id: extension.identifier.id,
          label: extension.displayName,
          description: extension.identifier.id,
          extension
        };
      });
      return entries;
    });
  }
  reinstallExtension(extension) {
    return this.instantiationService.createInstance(SearchExtensionsAction, "@installed ").run().then(() => {
      return this.extensionsWorkbenchService.reinstall(extension).then((extension2) => {
        const requireReload = !(extension2.local && this.extensionService.canAddExtension(toExtensionDescription(extension2.local)));
        const message = requireReload ? localize(
          "ReinstallAction.successReload",
          "Please reload Visual Studio Code to complete reinstalling the extension {0}.",
          extension2.identifier.id
        ) : localize(
          "ReinstallAction.success",
          "Reinstalling the extension {0} is completed.",
          extension2.identifier.id
        );
        const actions = requireReload ? [{
          label: localize("InstallVSIXAction.reloadNow", "Reload Now"),
          run: () => this.hostService.reload()
        }] : [];
        this.notificationService.prompt(Severity.Info, message, actions, { sticky: true });
      }, (error) => this.notificationService.error(error));
    });
  }
}, _C.ID = "workbench.extensions.action.reinstall", _C.LABEL = localize("reinstall", "Reinstall Extension..."), _C;
_D = class extends Action {
  constructor(id = _D.ID, label = _D.LABEL, extensionsWorkbenchService, quickInputService, instantiationService, extensionEnablementService) {
    super(id, label);
    this.extensionsWorkbenchService = extensionsWorkbenchService;
    this.quickInputService = quickInputService;
    this.instantiationService = instantiationService;
    this.extensionEnablementService = extensionEnablementService;
  }
  get enabled() {
    return this.extensionsWorkbenchService.local.some((l) => this.isEnabled(l));
  }
  async run() {
    const extensionPick = await this.quickInputService.pick(this.getExtensionEntries(), { placeHolder: localize("selectExtension", "Select Extension"), matchOnDetail: true });
    if (extensionPick && extensionPick.extension) {
      const action = this.instantiationService.createInstance(InstallAnotherVersionAction);
      action.extension = extensionPick.extension;
      await action.run();
      await this.instantiationService.createInstance(SearchExtensionsAction, extensionPick.extension.identifier.id).run();
    }
  }
  isEnabled(extension) {
    const action = this.instantiationService.createInstance(InstallAnotherVersionAction);
    action.extension = extension;
    return action.enabled && !!extension.local && this.extensionEnablementService.isEnabled(extension.local);
  }
  async getExtensionEntries() {
    const installed = await this.extensionsWorkbenchService.queryLocal();
    const entries = [];
    for (const extension of installed) {
      if (this.isEnabled(extension)) {
        entries.push({
          id: extension.identifier.id,
          label: extension.displayName || extension.identifier.id,
          description: extension.identifier.id,
          extension
        });
      }
    }
    return entries.sort((e1, e2) => e1.extension.displayName.localeCompare(e2.extension.displayName));
  }
}, _D.ID = "workbench.extensions.action.install.specificVersion", _D.LABEL = localize("install previous version", "Install Specific Version of Extension..."), _D;
CommandsRegistry.registerCommand("workbench.extensions.action.showExtensionsForLanguage", function(accessor, fileExtension) {
  const paneCompositeService = accessor.get(IPaneCompositePartService);
  return paneCompositeService.openPaneComposite(VIEWLET_ID, 0, true).then((viewlet) => viewlet == null ? void 0 : viewlet.getViewPaneContainer()).then((viewlet) => {
    viewlet.search(`ext:${fileExtension.replace(/^\./, "")}`);
    viewlet.focus();
  });
});
CommandsRegistry.registerCommand("workbench.extensions.action.showExtensionsWithIds", function(accessor, extensionIds) {
  const paneCompositeService = accessor.get(IPaneCompositePartService);
  return paneCompositeService.openPaneComposite(VIEWLET_ID, 0, true).then((viewlet) => viewlet == null ? void 0 : viewlet.getViewPaneContainer()).then((viewlet) => {
    const query = extensionIds.map((id) => `@id:${id}`).join(" ");
    viewlet.search(query);
    viewlet.focus();
  });
});
registerColor("extensionButton.background", {
  dark: buttonBackground,
  light: buttonBackground,
  hcDark: null,
  hcLight: null
}, localize(
  "extensionButtonBackground",
  "Button background color for extension actions."
));
registerColor("extensionButton.foreground", {
  dark: buttonForeground,
  light: buttonForeground,
  hcDark: null,
  hcLight: null
}, localize(
  "extensionButtonForeground",
  "Button foreground color for extension actions."
));
registerColor("extensionButton.hoverBackground", {
  dark: buttonHoverBackground,
  light: buttonHoverBackground,
  hcDark: null,
  hcLight: null
}, localize(
  "extensionButtonHoverBackground",
  "Button background hover color for extension actions."
));
registerColor("extensionButton.separator", {
  dark: buttonSeparator,
  light: buttonSeparator,
  hcDark: buttonSeparator,
  hcLight: buttonSeparator
}, localize("extensionButtonSeparator", "Button separator color for extension actions"));
registerColor("extensionButton.prominentBackground", {
  dark: buttonBackground,
  light: buttonBackground,
  hcDark: null,
  hcLight: null
}, localize(
  "extensionButtonProminentBackground",
  "Button background color for extension actions that stand out (e.g. install button)."
));
registerColor("extensionButton.prominentForeground", {
  dark: buttonForeground,
  light: buttonForeground,
  hcDark: null,
  hcLight: null
}, localize(
  "extensionButtonProminentForeground",
  "Button foreground color for extension actions that stand out (e.g. install button)."
));
registerColor("extensionButton.prominentHoverBackground", {
  dark: buttonHoverBackground,
  light: buttonHoverBackground,
  hcDark: null,
  hcLight: null
}, localize(
  "extensionButtonProminentHoverBackground",
  "Button background hover color for extension actions that stand out (e.g. install button)."
));
registerThemingParticipant((theme, collector) => {
  const errorColor = theme.getColor(editorErrorForeground);
  if (errorColor) {
    collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
    collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
    collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
  }
  const warningColor = theme.getColor(editorWarningForeground);
  if (warningColor) {
    collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
    collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
    collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
  }
  const infoColor = theme.getColor(editorInfoForeground);
  if (infoColor) {
    collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
    collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
    collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
  }
});
let TerminalConfigHelper = class TerminalConfigHelper2 {
  get onConfigChanged() {
    return this._onConfigChanged.event;
  }
  constructor(_configurationService, _extensionManagementService, _notificationService, _instantiationService, _productService) {
    this._configurationService = _configurationService;
    this._extensionManagementService = _extensionManagementService;
    this._notificationService = _notificationService;
    this._instantiationService = _instantiationService;
    this._productService = _productService;
    this._linuxDistro = 1;
    this._onConfigChanged = new Emitter();
    this._recommendationsShown = false;
    this._updateConfig();
    this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(TERMINAL_CONFIG_SECTION)) {
        this._updateConfig();
      }
    });
    if (isLinux) {
      if (navigator.userAgent.includes("Ubuntu")) {
        this._linuxDistro = 3;
      } else if (navigator.userAgent.includes("Fedora")) {
        this._linuxDistro = 2;
      }
    }
  }
  _updateConfig() {
    const configValues = this._configurationService.getValue(TERMINAL_CONFIG_SECTION);
    configValues.fontWeight = this._normalizeFontWeight(configValues.fontWeight, DEFAULT_FONT_WEIGHT);
    configValues.fontWeightBold = this._normalizeFontWeight(configValues.fontWeightBold, DEFAULT_BOLD_FONT_WEIGHT);
    this.config = configValues;
    this._onConfigChanged.fire();
  }
  configFontIsMonospace() {
    const fontSize = 15;
    const fontFamily = this.config.fontFamily || this._configurationService.getValue("editor").fontFamily || EDITOR_FONT_DEFAULTS.fontFamily;
    const iRect = this._getBoundingRectFor("i", fontFamily, fontSize);
    const wRect = this._getBoundingRectFor("w", fontFamily, fontSize);
    if (!iRect || !wRect || !iRect.width || !wRect.width) {
      return true;
    }
    return iRect.width === wRect.width;
  }
  _createCharMeasureElementIfNecessary() {
    if (!this.panelContainer) {
      throw new Error("Cannot measure element when terminal is not attached");
    }
    if (!this._charMeasureElement || !this._charMeasureElement.parentElement) {
      this._charMeasureElement = document.createElement("div");
      this.panelContainer.appendChild(this._charMeasureElement);
    }
    return this._charMeasureElement;
  }
  _getBoundingRectFor(char, fontFamily, fontSize) {
    let charMeasureElement;
    try {
      charMeasureElement = this._createCharMeasureElementIfNecessary();
    } catch {
      return void 0;
    }
    const style = charMeasureElement.style;
    style.display = "inline-block";
    style.fontFamily = fontFamily;
    style.fontSize = fontSize + "px";
    style.lineHeight = "normal";
    charMeasureElement.innerText = char;
    const rect = charMeasureElement.getBoundingClientRect();
    style.display = "none";
    return rect;
  }
  _measureFont(fontFamily, fontSize, letterSpacing, lineHeight) {
    const rect = this._getBoundingRectFor("X", fontFamily, fontSize);
    if (this._lastFontMeasurement && (!rect || !rect.width || !rect.height)) {
      return this._lastFontMeasurement;
    }
    this._lastFontMeasurement = {
      fontFamily,
      fontSize,
      letterSpacing,
      lineHeight,
      charWidth: 0,
      charHeight: 0
    };
    if (rect && rect.width && rect.height) {
      this._lastFontMeasurement.charHeight = Math.ceil(rect.height);
      if (this.config.gpuAcceleration === "off") {
        this._lastFontMeasurement.charWidth = rect.width;
      } else {
        const deviceCharWidth = Math.floor(rect.width * window.devicePixelRatio);
        const deviceCellWidth = deviceCharWidth + Math.round(letterSpacing);
        const cssCellWidth = deviceCellWidth / window.devicePixelRatio;
        this._lastFontMeasurement.charWidth = cssCellWidth - Math.round(letterSpacing) / window.devicePixelRatio;
      }
    }
    return this._lastFontMeasurement;
  }
  getFont(xtermCore, excludeDimensions) {
    var _a2, _b2;
    const editorConfig = this._configurationService.getValue("editor");
    let fontFamily = this.config.fontFamily || editorConfig.fontFamily || EDITOR_FONT_DEFAULTS.fontFamily;
    let fontSize = this._clampInt(this.config.fontSize, 6, 100, EDITOR_FONT_DEFAULTS.fontSize);
    if (!this.config.fontFamily) {
      if (this._linuxDistro === 2) {
        fontFamily = "'DejaVu Sans Mono'";
      }
      if (this._linuxDistro === 3) {
        fontFamily = "'Ubuntu Mono'";
        fontSize = this._clampInt(fontSize + 2, 6, 100, EDITOR_FONT_DEFAULTS.fontSize);
      }
    }
    fontFamily += ", monospace";
    const letterSpacing = this.config.letterSpacing ? Math.max(Math.floor(this.config.letterSpacing), MINIMUM_LETTER_SPACING) : DEFAULT_LETTER_SPACING;
    const lineHeight = this.config.lineHeight ? Math.max(this.config.lineHeight, 1) : DEFAULT_LINE_HEIGHT;
    if (excludeDimensions) {
      return {
        fontFamily,
        fontSize,
        letterSpacing,
        lineHeight
      };
    }
    if (xtermCore) {
      if (xtermCore._renderService && ((_a2 = xtermCore._renderService.dimensions) == null ? void 0 : _a2.css.cell.width) && ((_b2 = xtermCore._renderService.dimensions) == null ? void 0 : _b2.css.cell.height)) {
        return {
          fontFamily,
          fontSize,
          letterSpacing,
          lineHeight,
          charHeight: xtermCore._renderService.dimensions.css.cell.height / lineHeight,
          charWidth: xtermCore._renderService.dimensions.css.cell.width - Math.round(letterSpacing) / window.devicePixelRatio
        };
      }
    }
    return this._measureFont(fontFamily, fontSize, letterSpacing, lineHeight);
  }
  _clampInt(source, minimum, maximum, fallback) {
    let r = parseInt(source, 10);
    if (isNaN(r)) {
      return fallback;
    }
    if (typeof minimum === "number") {
      r = Math.max(minimum, r);
    }
    if (typeof maximum === "number") {
      r = Math.min(maximum, r);
    }
    return r;
  }
  async showRecommendations(shellLaunchConfig) {
    if (this._recommendationsShown) {
      return;
    }
    this._recommendationsShown = true;
    if (isWindows && shellLaunchConfig.executable && basename(shellLaunchConfig.executable).toLowerCase() === "wsl.exe") {
      const exeBasedExtensionTips = this._productService.exeBasedExtensionTips;
      if (!exeBasedExtensionTips || !exeBasedExtensionTips.wsl) {
        return;
      }
      const extId = Object.keys(exeBasedExtensionTips.wsl.recommendations).find((extId2) => exeBasedExtensionTips.wsl.recommendations[extId2].important);
      if (extId && !await this._isExtensionInstalled(extId)) {
        this._notificationService.prompt(Severity$1.Info, localize(
          "useWslExtension.title",
          "The '{0}' extension is recommended for opening a terminal in WSL.",
          exeBasedExtensionTips.wsl.friendlyName
        ), [
          {
            label: localize("install", "Install"),
            run: () => {
              this._instantiationService.createInstance(InstallRecommendedExtensionAction, extId).run();
            }
          }
        ], {
          sticky: true,
          neverShowAgain: { id: "terminalConfigHelper/launchRecommendationsIgnore", scope: NeverShowAgainScope.APPLICATION },
          onCancel: () => {
          }
        });
      }
    }
  }
  async _isExtensionInstalled(id) {
    const extensions = await this._extensionManagementService.getInstalled();
    return extensions.some((e) => e.identifier.id === id);
  }
  _normalizeFontWeight(input, defaultWeight) {
    if (input === "normal" || input === "bold") {
      return input;
    }
    return this._clampInt(input, MINIMUM_FONT_WEIGHT, MAXIMUM_FONT_WEIGHT, defaultWeight);
  }
};
TerminalConfigHelper = __decorate([
  __param(0, IConfigurationService),
  __param(1, IExtensionManagementService),
  __param(2, INotificationService),
  __param(3, IInstantiationService),
  __param(4, IProductService)
], TerminalConfigHelper);
let TerminalProfileQuickpick = class TerminalProfileQuickpick2 {
  constructor(_terminalProfileService, _terminalProfileResolverService, _configurationService, _quickInputService, _themeService, _notificationService) {
    this._terminalProfileService = _terminalProfileService;
    this._terminalProfileResolverService = _terminalProfileResolverService;
    this._configurationService = _configurationService;
    this._quickInputService = _quickInputService;
    this._themeService = _themeService;
    this._notificationService = _notificationService;
  }
  async showAndGetResult(type) {
    const platformKey = await this._terminalProfileService.getPlatformKey();
    const profilesKey = "terminal.integrated.profiles." + platformKey;
    const result = await this._createAndShow(type);
    const defaultProfileKey = `${"terminal.integrated.defaultProfile."}${platformKey}`;
    if (!result) {
      return;
    }
    if (type === "setDefault") {
      if ("command" in result.profile) {
        return;
      } else if ("id" in result.profile) {
        await this._configurationService.updateValue(defaultProfileKey, result.profile.title, 2);
        return {
          config: {
            extensionIdentifier: result.profile.extensionIdentifier,
            id: result.profile.id,
            title: result.profile.title,
            options: {
              color: result.profile.color,
              icon: result.profile.icon
            }
          },
          keyMods: result.keyMods
        };
      }
      if ("isAutoDetected" in result.profile) {
        const profilesConfig = await this._configurationService.getValue(profilesKey);
        if (typeof profilesConfig === "object") {
          const newProfile = {
            path: result.profile.path
          };
          if (result.profile.args) {
            newProfile.args = result.profile.args;
          }
          profilesConfig[result.profile.profileName] = newProfile;
        }
        await this._configurationService.updateValue(profilesKey, profilesConfig, 2);
      }
      await this._configurationService.updateValue(defaultProfileKey, result.profileName, 2);
    } else if (type === "createInstance") {
      if ("id" in result.profile) {
        return {
          config: {
            extensionIdentifier: result.profile.extensionIdentifier,
            id: result.profile.id,
            title: result.profile.title,
            options: {
              icon: result.profile.icon,
              color: result.profile.color
            }
          },
          keyMods: result.keyMods
        };
      } else {
        return { config: result.profile, keyMods: result.keyMods };
      }
    }
    return "profileName" in result.profile ? result.profile.profileName : result.profile.title;
  }
  async _createAndShow(type) {
    const platformKey = await this._terminalProfileService.getPlatformKey();
    const profiles = this._terminalProfileService.availableProfiles;
    const profilesKey = "terminal.integrated.profiles." + platformKey;
    const defaultProfileName = this._terminalProfileService.getDefaultProfileName();
    let keyMods;
    const options = {
      placeHolder: type === "createInstance" ? localize(
        "terminal.integrated.selectProfileToCreate",
        "Select the terminal profile to create"
      ) : localize(
        "terminal.integrated.chooseDefaultProfile",
        "Select your default terminal profile"
      ),
      onDidTriggerItemButton: async (context) => {
        if (!await this._isProfileSafe(context.item.profile)) {
          return;
        }
        if ("command" in context.item.profile) {
          return;
        }
        if ("id" in context.item.profile) {
          return;
        }
        const configProfiles2 = this._configurationService.getValue("terminal.integrated.profiles." + platformKey);
        const existingProfiles = !!configProfiles2 ? Object.keys(configProfiles2) : [];
        const name = await this._quickInputService.input({
          prompt: localize("enterTerminalProfileName", "Enter terminal profile name"),
          value: context.item.profile.profileName,
          validateInput: async (input) => {
            if (existingProfiles.includes(input)) {
              return localize(
                "terminalProfileAlreadyExists",
                "A terminal profile already exists with that name"
              );
            }
            return void 0;
          }
        });
        if (!name) {
          return;
        }
        const newConfigValue = { ...configProfiles2 };
        newConfigValue[name] = {
          path: context.item.profile.path,
          args: context.item.profile.args
        };
        await this._configurationService.updateValue(profilesKey, newConfigValue, 2);
      },
      onKeyMods: (mods) => keyMods = mods
    };
    const quickPickItems = [];
    const configProfiles = profiles.filter((e) => !e.isAutoDetected);
    const autoDetectedProfiles = profiles.filter((e) => e.isAutoDetected);
    if (configProfiles.length > 0) {
      quickPickItems.push({ type: "separator", label: localize("terminalProfiles", "profiles") });
      quickPickItems.push(...this._sortProfileQuickPickItems(configProfiles.map((e) => this._createProfileQuickPickItem(e)), defaultProfileName));
    }
    quickPickItems.push({ type: "separator", label: localize("ICreateContributedTerminalProfileOptions", "contributed") });
    const contributedProfiles = [];
    for (const contributed of this._terminalProfileService.contributedProfiles) {
      let icon;
      if (typeof contributed.icon === "string") {
        if (contributed.icon.startsWith("$(")) {
          icon = ThemeIcon.fromString(contributed.icon);
        } else {
          icon = ThemeIcon.fromId(contributed.icon);
        }
      }
      if (!icon || !getIconRegistry().getIcon(icon.id)) {
        icon = this._terminalProfileResolverService.getDefaultIcon();
      }
      const uriClasses = getUriClasses(contributed, this._themeService.getColorTheme().type, true);
      const colorClass = getColorClass(contributed);
      const iconClasses = [];
      if (uriClasses) {
        iconClasses.push(...uriClasses);
      }
      if (colorClass) {
        iconClasses.push(colorClass);
      }
      contributedProfiles.push({
        label: `$(${icon.id}) ${contributed.title}`,
        profile: {
          extensionIdentifier: contributed.extensionIdentifier,
          title: contributed.title,
          icon: contributed.icon,
          id: contributed.id,
          color: contributed.color
        },
        profileName: contributed.title,
        iconClasses
      });
    }
    if (contributedProfiles.length > 0) {
      quickPickItems.push(...this._sortProfileQuickPickItems(contributedProfiles, defaultProfileName));
    }
    if (autoDetectedProfiles.length > 0) {
      quickPickItems.push({ type: "separator", label: localize("terminalProfiles.detected", "detected") });
      quickPickItems.push(...this._sortProfileQuickPickItems(autoDetectedProfiles.map((e) => this._createProfileQuickPickItem(e)), defaultProfileName));
    }
    const styleElement = getColorStyleElement(this._themeService.getColorTheme());
    document.body.appendChild(styleElement);
    const result = await this._quickInputService.pick(quickPickItems, options);
    document.body.removeChild(styleElement);
    if (!result) {
      return void 0;
    }
    if (!await this._isProfileSafe(result.profile)) {
      return void 0;
    }
    if (keyMods) {
      result.keyMods = keyMods;
    }
    return result;
  }
  async _isProfileSafe(profile) {
    const isUnsafePath = "isUnsafePath" in profile && profile.isUnsafePath;
    const requiresUnsafePath = "requiresUnsafePath" in profile && profile.requiresUnsafePath;
    if (!isUnsafePath && !requiresUnsafePath) {
      return true;
    }
    return await new Promise((r) => {
      const unsafePaths = [];
      if (isUnsafePath) {
        unsafePaths.push(profile.path);
      }
      if (requiresUnsafePath) {
        unsafePaths.push(requiresUnsafePath);
      }
      const handle = this._notificationService.prompt(Severity.Warning, localize(
        "unsafePathWarning",
        "This terminal profile uses a potentially unsafe path that can be modified by another user: {0}. Are you sure you want to use it?",
        `"${unsafePaths.join(",")}"`
      ), [{
        label: localize("yes", "Yes"),
        run: () => r(true)
      }, {
        label: localize("cancel", "Cancel"),
        run: () => r(false)
      }]);
      handle.onDidClose(() => r(false));
    });
  }
  _createProfileQuickPickItem(profile) {
    const buttons = [{
      iconClass: ThemeIcon.asClassName(configureTerminalProfileIcon),
      tooltip: localize("createQuickLaunchProfile", "Configure Terminal Profile")
    }];
    const icon = profile.icon && ThemeIcon.isThemeIcon(profile.icon) ? profile.icon : Codicon.terminal;
    const label = `$(${icon.id}) ${profile.profileName}`;
    const friendlyPath = profile.isFromPath ? basename(profile.path) : profile.path;
    const colorClass = getColorClass(profile);
    const iconClasses = [];
    if (colorClass) {
      iconClasses.push(colorClass);
    }
    if (profile.args) {
      if (typeof profile.args === "string") {
        return { label, description: `${profile.path} ${profile.args}`, profile, profileName: profile.profileName, buttons, iconClasses };
      }
      const argsString = profile.args.map((e) => {
        if (e.includes(" ")) {
          return `"${e.replace(/"/g, '\\"')}"`;
        }
        return e;
      }).join(" ");
      return { label, description: `${friendlyPath} ${argsString}`, profile, profileName: profile.profileName, buttons, iconClasses };
    }
    return { label, description: friendlyPath, profile, profileName: profile.profileName, buttons, iconClasses };
  }
  _sortProfileQuickPickItems(items, defaultProfileName) {
    return items.sort((a, b) => {
      if (b.profileName === defaultProfileName) {
        return 1;
      }
      if (a.profileName === defaultProfileName) {
        return -1;
      }
      return a.profileName.localeCompare(b.profileName);
    });
  }
};
TerminalProfileQuickpick = __decorate([
  __param(0, ITerminalProfileService),
  __param(1, ITerminalProfileResolverService),
  __param(2, IConfigurationService),
  __param(3, IQuickInputService),
  __param(4, IThemeService),
  __param(5, INotificationService)
], TerminalProfileQuickpick);
function parseTerminalUri(resource) {
  const [, workspaceId, instanceId] = resource.path.split("/");
  if (!workspaceId || !Number.parseInt(instanceId)) {
    throw new Error(`Could not parse terminal uri for resource ${resource}`);
  }
  return { workspaceId, instanceId: Number.parseInt(instanceId) };
}
function getTerminalUri(workspaceId, instanceId, title) {
  return URI.from({
    scheme: Schemas.vscodeTerminal,
    path: `/${workspaceId}/${instanceId}`,
    fragment: title || void 0
  });
}
function getTerminalResourcesFromDragEvent(event) {
  var _a2;
  const resources = (_a2 = event.dataTransfer) == null ? void 0 : _a2.getData("Terminals");
  if (resources) {
    const json = JSON.parse(resources);
    const result = [];
    for (const entry of json) {
      result.push(URI.parse(entry));
    }
    return result.length === 0 ? void 0 : result;
  }
  return void 0;
}
function getInstanceFromResource(instances, resource) {
  if (resource) {
    for (const instance of instances) {
      if (instance.resource.path === resource.path) {
        return instance;
      }
    }
  }
  return void 0;
}
var Boundary;
(function(Boundary2) {
  Boundary2[Boundary2["Top"] = 0] = "Top";
  Boundary2[Boundary2["Bottom"] = 1] = "Bottom";
})(Boundary || (Boundary = {}));
let MarkNavigationAddon = class MarkNavigationAddon2 extends Disposable {
  activate(terminal) {
    this._terminal = terminal;
    this._register(this._terminal.onData(() => {
      this._currentMarker = Boundary.Bottom;
    }));
  }
  constructor(_capabilities, _themeService) {
    super();
    this._capabilities = _capabilities;
    this._themeService = _themeService;
    this._currentMarker = Boundary.Bottom;
    this._selectionStart = null;
    this._isDisposable = false;
  }
  _getMarkers(skipEmptyCommands) {
    var _a2, _b2;
    const commandCapability = this._capabilities.get(2);
    const partialCommandCapability = this._capabilities.get(3);
    const markCapability = this._capabilities.get(4);
    let markers = [];
    if (commandCapability) {
      markers = coalesce(commandCapability.commands.map((e) => e.marker));
    } else if (partialCommandCapability) {
      markers.push(...partialCommandCapability.commands);
    }
    if (markCapability && !skipEmptyCommands) {
      let next = (_a2 = markCapability.markers().next()) == null ? void 0 : _a2.value;
      const arr = [];
      while (next) {
        arr.push(next);
        next = (_b2 = markCapability.markers().next()) == null ? void 0 : _b2.value;
      }
      markers = arr;
    }
    return markers;
  }
  clearMarker() {
    this._currentMarker = Boundary.Bottom;
    this._resetNavigationDecorations();
    this._selectionStart = null;
  }
  _resetNavigationDecorations() {
    if (this._navigationDecorations) {
      dispose(this._navigationDecorations);
    }
    this._navigationDecorations = [];
  }
  _isEmptyCommand(marker) {
    if (marker === Boundary.Bottom) {
      return true;
    }
    if (marker === Boundary.Top) {
      return !this._getMarkers(true).map((e) => e.line).includes(0);
    }
    return !this._getMarkers(true).includes(marker);
  }
  scrollToPreviousMark(scrollPosition = 1, retainSelection = false, skipEmptyCommands = false) {
    if (!this._terminal) {
      return;
    }
    if (!retainSelection) {
      this._selectionStart = null;
    }
    let markerIndex;
    const currentLineY = typeof this._currentMarker === "object" ? this._getTargetScrollLine(this._terminal, this._currentMarker, scrollPosition) : Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);
    const viewportY = this._terminal.buffer.active.viewportY;
    if (typeof this._currentMarker === "object" ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {
      const markersBelowViewport = this._getMarkers(skipEmptyCommands).filter((e) => e.line >= viewportY).length;
      markerIndex = this._getMarkers(skipEmptyCommands).length - markersBelowViewport - 1;
    } else if (this._currentMarker === Boundary.Bottom) {
      markerIndex = this._getMarkers(skipEmptyCommands).length - 1;
    } else if (this._currentMarker === Boundary.Top) {
      markerIndex = -1;
    } else if (this._isDisposable) {
      markerIndex = this._findPreviousMarker(this._terminal, skipEmptyCommands);
      this._currentMarker.dispose();
      this._isDisposable = false;
    } else {
      if (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {
        markerIndex = this._findPreviousMarker(this._terminal, true);
      } else {
        markerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) - 1;
      }
    }
    if (markerIndex < 0) {
      this._currentMarker = Boundary.Top;
      this._terminal.scrollToTop();
      this._resetNavigationDecorations();
      return;
    }
    this._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];
    this._scrollToMarker(this._currentMarker, scrollPosition);
  }
  scrollToNextMark(scrollPosition = 1, retainSelection = false, skipEmptyCommands = true) {
    if (!this._terminal) {
      return;
    }
    if (!retainSelection) {
      this._selectionStart = null;
    }
    let markerIndex;
    const currentLineY = typeof this._currentMarker === "object" ? this._getTargetScrollLine(this._terminal, this._currentMarker, scrollPosition) : Math.min(getLine(this._terminal, this._currentMarker), this._terminal.buffer.active.baseY);
    const viewportY = this._terminal.buffer.active.viewportY;
    if (typeof this._currentMarker === "object" ? !this._isMarkerInViewport(this._terminal, this._currentMarker) : currentLineY !== viewportY) {
      const markersAboveViewport = this._getMarkers(skipEmptyCommands).filter((e) => e.line <= viewportY).length;
      markerIndex = markersAboveViewport;
    } else if (this._currentMarker === Boundary.Bottom) {
      markerIndex = this._getMarkers(skipEmptyCommands).length;
    } else if (this._currentMarker === Boundary.Top) {
      markerIndex = 0;
    } else if (this._isDisposable) {
      markerIndex = this._findNextMarker(this._terminal, skipEmptyCommands);
      this._currentMarker.dispose();
      this._isDisposable = false;
    } else {
      if (skipEmptyCommands && this._isEmptyCommand(this._currentMarker)) {
        markerIndex = this._findNextMarker(this._terminal, true);
      } else {
        markerIndex = this._getMarkers(skipEmptyCommands).indexOf(this._currentMarker) + 1;
      }
    }
    if (markerIndex >= this._getMarkers(skipEmptyCommands).length) {
      this._currentMarker = Boundary.Bottom;
      this._terminal.scrollToBottom();
      this._resetNavigationDecorations();
      return;
    }
    this._currentMarker = this._getMarkers(skipEmptyCommands)[markerIndex];
    this._scrollToMarker(this._currentMarker, scrollPosition);
  }
  _scrollToMarker(marker, position, endMarker, hideDecoration) {
    if (!this._terminal) {
      return;
    }
    if (!this._isMarkerInViewport(this._terminal, marker)) {
      const line = this._getTargetScrollLine(this._terminal, marker, position);
      this._terminal.scrollToLine(line);
    }
    if (!hideDecoration) {
      this._registerTemporaryDecoration(marker, endMarker);
    }
  }
  _createMarkerForOffset(marker, offset) {
    var _a2;
    if (offset === 0) {
      return marker;
    } else {
      const offsetMarker = (_a2 = this._terminal) == null ? void 0 : _a2.registerMarker(-this._terminal.buffer.active.cursorY + marker.line - this._terminal.buffer.active.baseY + offset);
      if (offsetMarker) {
        return offsetMarker;
      } else {
        throw new Error(`Could not register marker with offset ${marker.line}, ${offset}`);
      }
    }
  }
  _registerTemporaryDecoration(marker, endMarker) {
    var _a2;
    if (!this._terminal) {
      return;
    }
    this._resetNavigationDecorations();
    const color = this._themeService.getColorTheme().getColor(TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR);
    const startLine = marker.line;
    const decorationCount = endMarker ? endMarker.line - startLine + 1 : 1;
    for (let i = 0; i < decorationCount; i++) {
      const decoration = this._terminal.registerDecoration({
        marker: this._createMarkerForOffset(marker, i),
        width: this._terminal.cols,
        overviewRulerOptions: {
          color: (color == null ? void 0 : color.toString()) || "#a0a0a0cc"
        }
      });
      if (decoration) {
        (_a2 = this._navigationDecorations) == null ? void 0 : _a2.push(decoration);
        let renderedElement;
        decoration.onRender((element) => {
          var _a3;
          if (!renderedElement) {
            renderedElement = element;
            if (decorationCount > 1) {
              element.classList.add("terminal-scroll-highlight");
            } else {
              element.classList.add("terminal-scroll-highlight", "terminal-scroll-highlight-outline");
            }
            if ((_a3 = this._terminal) == null ? void 0 : _a3.element) {
              element.style.marginLeft = `-${getComputedStyle(this._terminal.element).paddingLeft}`;
            }
          }
        });
        decoration.onDispose(() => {
          var _a3;
          this._navigationDecorations = (_a3 = this._navigationDecorations) == null ? void 0 : _a3.filter((d) => d !== decoration);
        });
        timeout(350).then(() => {
          if (renderedElement) {
            renderedElement.classList.remove("terminal-scroll-highlight-outline");
          }
        });
      }
    }
  }
  _getTargetScrollLine(terminal, marker, position) {
    if (position === 1) {
      return Math.max(marker.line - Math.floor(terminal.rows / 4), 0);
    }
    return marker.line;
  }
  _isMarkerInViewport(terminal, marker) {
    const viewportY = terminal.buffer.active.viewportY;
    return marker.line >= viewportY && marker.line < viewportY + terminal.rows;
  }
  scrollToClosestMarker(startMarkerId, endMarkerId, highlight) {
    const detectionCapability = this._capabilities.get(4);
    if (!detectionCapability) {
      return;
    }
    const startMarker = detectionCapability.getMark(startMarkerId);
    if (!startMarker) {
      return;
    }
    const endMarker = endMarkerId ? detectionCapability.getMark(endMarkerId) : startMarker;
    this._scrollToMarker(startMarker, 0, endMarker, !highlight);
  }
  selectToPreviousMark() {
    if (!this._terminal) {
      return;
    }
    if (this._selectionStart === null) {
      this._selectionStart = this._currentMarker;
    }
    if (this._capabilities.has(2)) {
      this.scrollToPreviousMark(1, true, true);
    } else {
      this.scrollToPreviousMark(1, true, false);
    }
    selectLines(this._terminal, this._currentMarker, this._selectionStart);
  }
  selectToNextMark() {
    if (!this._terminal) {
      return;
    }
    if (this._selectionStart === null) {
      this._selectionStart = this._currentMarker;
    }
    if (this._capabilities.has(2)) {
      this.scrollToNextMark(1, true, true);
    } else {
      this.scrollToNextMark(1, true, false);
    }
    selectLines(this._terminal, this._currentMarker, this._selectionStart);
  }
  selectToPreviousLine() {
    if (!this._terminal) {
      return;
    }
    if (this._selectionStart === null) {
      this._selectionStart = this._currentMarker;
    }
    this.scrollToPreviousLine(this._terminal, 1, true);
    selectLines(this._terminal, this._currentMarker, this._selectionStart);
  }
  selectToNextLine() {
    if (!this._terminal) {
      return;
    }
    if (this._selectionStart === null) {
      this._selectionStart = this._currentMarker;
    }
    this.scrollToNextLine(this._terminal, 1, true);
    selectLines(this._terminal, this._currentMarker, this._selectionStart);
  }
  scrollToPreviousLine(xterm2, scrollPosition = 1, retainSelection = false) {
    if (!retainSelection) {
      this._selectionStart = null;
    }
    if (this._currentMarker === Boundary.Top) {
      xterm2.scrollToTop();
      return;
    }
    if (this._currentMarker === Boundary.Bottom) {
      this._currentMarker = this._registerMarkerOrThrow(xterm2, this._getOffset(xterm2) - 1);
    } else {
      const offset = this._getOffset(xterm2);
      if (this._isDisposable) {
        this._currentMarker.dispose();
      }
      this._currentMarker = this._registerMarkerOrThrow(xterm2, offset - 1);
    }
    this._isDisposable = true;
    this._scrollToMarker(this._currentMarker, scrollPosition);
  }
  scrollToNextLine(xterm2, scrollPosition = 1, retainSelection = false) {
    if (!retainSelection) {
      this._selectionStart = null;
    }
    if (this._currentMarker === Boundary.Bottom) {
      xterm2.scrollToBottom();
      return;
    }
    if (this._currentMarker === Boundary.Top) {
      this._currentMarker = this._registerMarkerOrThrow(xterm2, this._getOffset(xterm2) + 1);
    } else {
      const offset = this._getOffset(xterm2);
      if (this._isDisposable) {
        this._currentMarker.dispose();
      }
      this._currentMarker = this._registerMarkerOrThrow(xterm2, offset + 1);
    }
    this._isDisposable = true;
    this._scrollToMarker(this._currentMarker, scrollPosition);
  }
  _registerMarkerOrThrow(xterm2, cursorYOffset) {
    const marker = xterm2.registerMarker(cursorYOffset);
    if (!marker) {
      throw new Error(`Could not create marker for ${cursorYOffset}`);
    }
    return marker;
  }
  _getOffset(xterm2) {
    if (this._currentMarker === Boundary.Bottom) {
      return 0;
    } else if (this._currentMarker === Boundary.Top) {
      return 0 - (xterm2.buffer.active.baseY + xterm2.buffer.active.cursorY);
    } else {
      let offset = getLine(xterm2, this._currentMarker);
      offset -= xterm2.buffer.active.baseY + xterm2.buffer.active.cursorY;
      return offset;
    }
  }
  _findPreviousMarker(xterm2, skipEmptyCommands = false) {
    if (this._currentMarker === Boundary.Top) {
      return 0;
    } else if (this._currentMarker === Boundary.Bottom) {
      return this._getMarkers(skipEmptyCommands).length - 1;
    }
    let i;
    for (i = this._getMarkers(skipEmptyCommands).length - 1; i >= 0; i--) {
      if (this._getMarkers(skipEmptyCommands)[i].line < this._currentMarker.line) {
        return i;
      }
    }
    return -1;
  }
  _findNextMarker(xterm2, skipEmptyCommands = false) {
    if (this._currentMarker === Boundary.Top) {
      return 0;
    } else if (this._currentMarker === Boundary.Bottom) {
      return this._getMarkers(skipEmptyCommands).length - 1;
    }
    let i;
    for (i = 0; i < this._getMarkers(skipEmptyCommands).length; i++) {
      if (this._getMarkers(skipEmptyCommands)[i].line > this._currentMarker.line) {
        return i;
      }
    }
    return this._getMarkers(skipEmptyCommands).length;
  }
};
MarkNavigationAddon = __decorate([
  __param(1, IThemeService)
], MarkNavigationAddon);
function getLine(xterm2, marker) {
  if (marker === Boundary.Bottom) {
    return xterm2.buffer.active.baseY + xterm2.rows - 1;
  }
  if (marker === Boundary.Top) {
    return 0;
  }
  return marker.line;
}
function selectLines(xterm2, start, end) {
  if (end === null) {
    end = Boundary.Bottom;
  }
  let startLine = getLine(xterm2, start);
  let endLine = getLine(xterm2, end);
  if (startLine > endLine) {
    const temp = startLine;
    startLine = endLine;
    endLine = temp;
  }
  endLine -= 1;
  xterm2.selectLines(startLine, endLine);
}
class TerminalCapabilityStore extends Disposable {
  constructor() {
    super(...arguments);
    this._map = /* @__PURE__ */ new Map();
    this._onDidRemoveCapability = this._register(new Emitter());
    this.onDidRemoveCapability = this._onDidRemoveCapability.event;
    this._onDidAddCapability = this._register(new Emitter());
    this.onDidAddCapability = this._onDidAddCapability.event;
  }
  get items() {
    return this._map.keys();
  }
  add(capability, impl) {
    this._map.set(capability, impl);
    this._onDidAddCapability.fire(capability);
  }
  get(capability) {
    return this._map.get(capability);
  }
  remove(capability) {
    if (!this._map.has(capability)) {
      return;
    }
    this._map.delete(capability);
    this._onDidRemoveCapability.fire(capability);
  }
  has(capability) {
    return this._map.has(capability);
  }
}
class TerminalCapabilityStoreMultiplexer extends Disposable {
  constructor() {
    super(...arguments);
    this._stores = [];
    this._onDidRemoveCapability = this._register(new Emitter());
    this.onDidRemoveCapability = this._onDidRemoveCapability.event;
    this._onDidAddCapability = this._register(new Emitter());
    this.onDidAddCapability = this._onDidAddCapability.event;
  }
  get items() {
    return this._items();
  }
  *_items() {
    for (const store of this._stores) {
      for (const c of store.items) {
        yield c;
      }
    }
  }
  has(capability) {
    for (const store of this._stores) {
      for (const c of store.items) {
        if (c === capability) {
          return true;
        }
      }
    }
    return false;
  }
  get(capability) {
    for (const store of this._stores) {
      const c = store.get(capability);
      if (c) {
        return c;
      }
    }
    return void 0;
  }
  add(store) {
    this._stores.push(store);
    for (const capability of store.items) {
      this._onDidAddCapability.fire(capability);
    }
    store.onDidAddCapability((e) => this._onDidAddCapability.fire(e));
    store.onDidRemoveCapability((e) => this._onDidRemoveCapability.fire(e));
  }
}
class CommandDetectionCapability {
  get commands() {
    return this._commands;
  }
  get executingCommand() {
    return this._currentCommand.command;
  }
  get executingCommandObject() {
    if (this._currentCommand.commandStartMarker) {
      return { marker: this._currentCommand.commandStartMarker };
    }
    return void 0;
  }
  get cwd() {
    return this._cwd;
  }
  get _isInputting() {
    return !!(this._currentCommand.commandStartMarker && !this._currentCommand.commandExecutedMarker);
  }
  get hasInput() {
    var _a2, _b2, _c2;
    if (!this._isInputting || !((_a2 = this._currentCommand) == null ? void 0 : _a2.commandStartMarker)) {
      return void 0;
    }
    if (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY === ((_b2 = this._currentCommand.commandStartMarker) == null ? void 0 : _b2.line)) {
      const line = (_c2 = this._terminal.buffer.active.getLine(this._terminal.buffer.active.cursorY)) == null ? void 0 : _c2.translateToString(true, this._currentCommand.commandStartX);
      if (line === void 0) {
        return void 0;
      }
      return line.length > 0;
    }
    return true;
  }
  constructor(_terminal, _logService) {
    this._terminal = _terminal;
    this._logService = _logService;
    this.type = 2;
    this._commands = [];
    this._currentCommand = {};
    this._isWindowsPty = false;
    this._commandMarkers = [];
    this.__isCommandStorageDisabled = false;
    this._onCommandStarted = new Emitter();
    this.onCommandStarted = this._onCommandStarted.event;
    this._onBeforeCommandFinished = new Emitter();
    this.onBeforeCommandFinished = this._onBeforeCommandFinished.event;
    this._onCommandFinished = new Emitter();
    this.onCommandFinished = this._onCommandFinished.event;
    this._onCommandExecuted = new Emitter();
    this.onCommandExecuted = this._onCommandExecuted.event;
    this._onCommandInvalidated = new Emitter();
    this.onCommandInvalidated = this._onCommandInvalidated.event;
    this._onCurrentCommandInvalidated = new Emitter();
    this.onCurrentCommandInvalidated = this._onCurrentCommandInvalidated.event;
    this._dimensions = {
      cols: this._terminal.cols,
      rows: this._terminal.rows
    };
    this._terminal.onResize((e) => this._handleResize(e));
    this._terminal.onCursorMove(() => this._handleCursorMove());
    this._setupClearListeners();
  }
  _handleResize(e) {
    if (this._isWindowsPty) {
      this._preHandleResizeWindows(e);
    }
    this._dimensions.cols = e.cols;
    this._dimensions.rows = e.rows;
  }
  _handleCursorMove() {
    if (this._terminal.buffer.active === this._terminal.buffer.normal && this._currentCommand.commandStartMarker) {
      if (this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY < this._currentCommand.commandStartMarker.line) {
        this._clearCommandsInViewport();
        this._currentCommand.isInvalid = true;
        this._onCurrentCommandInvalidated.fire({ reason: "windows" });
      }
    }
  }
  _setupClearListeners() {
    this.onBeforeCommandFinished((command) => {
      if (this._isWindowsPty) {
        if (command.command.trim().toLowerCase() === "clear" || command.command.trim().toLowerCase() === "cls") {
          this._clearCommandsInViewport();
          this._currentCommand.isInvalid = true;
          this._onCurrentCommandInvalidated.fire({ reason: "windows" });
        }
      }
    });
    this._terminal.parser.registerCsiHandler({ final: "J" }, (params) => {
      if (!this._isWindowsPty) {
        if (params.length >= 1 && (params[0] === 2 || params[0] === 3)) {
          this._clearCommandsInViewport();
        }
      }
      return false;
    });
  }
  _preHandleResizeWindows(e) {
    const baseY = this._terminal.buffer.active.baseY;
    const rowsDifference = e.rows - this._dimensions.rows;
    if (rowsDifference > 0) {
      this._waitForCursorMove().then(() => {
        const potentialShiftedLineCount = Math.min(rowsDifference, baseY);
        for (let i = this.commands.length - 1; i >= 0; i--) {
          const command = this.commands[i];
          if (!command.marker || command.marker.line < baseY || command.commandStartLineContent === void 0) {
            break;
          }
          const line = this._terminal.buffer.active.getLine(command.marker.line);
          if (!line || line.translateToString(true) === command.commandStartLineContent) {
            continue;
          }
          const shiftedY = command.marker.line - potentialShiftedLineCount;
          const shiftedLine = this._terminal.buffer.active.getLine(shiftedY);
          if ((shiftedLine == null ? void 0 : shiftedLine.translateToString(true)) !== command.commandStartLineContent) {
            continue;
          }
          this._terminal._core._bufferService.buffer.lines.onDeleteEmitter.fire({
            index: this._terminal.buffer.active.baseY,
            amount: potentialShiftedLineCount
          });
        }
      });
    }
  }
  _clearCommandsInViewport() {
    var _a2;
    let count = 0;
    for (let i = this._commands.length - 1; i >= 0; i--) {
      const line = (_a2 = this._commands[i].marker) == null ? void 0 : _a2.line;
      if (line && line < this._terminal.buffer.active.baseY) {
        break;
      }
      count++;
    }
    if (count > 0) {
      this._onCommandInvalidated.fire(this._commands.splice(this._commands.length - count, count));
    }
  }
  _waitForCursorMove() {
    const cursorX = this._terminal.buffer.active.cursorX;
    const cursorY = this._terminal.buffer.active.cursorY;
    let totalDelay = 0;
    return new Promise((resolve2, reject) => {
      const interval = setInterval(() => {
        if (cursorX !== this._terminal.buffer.active.cursorX || cursorY !== this._terminal.buffer.active.cursorY) {
          resolve2();
          clearInterval(interval);
          return;
        }
        totalDelay += 10;
        if (totalDelay > 1e3) {
          clearInterval(interval);
          resolve2();
        }
      }, 10);
    });
  }
  setCwd(value) {
    this._cwd = value;
  }
  setIsWindowsPty(value) {
    this._isWindowsPty = value;
  }
  setIsCommandStorageDisabled() {
    this.__isCommandStorageDisabled = true;
  }
  getCwdForLine(line) {
    var _a2, _b2;
    if (this._currentCommand.promptStartMarker && line >= ((_a2 = this._currentCommand.promptStartMarker) == null ? void 0 : _a2.line)) {
      return this._cwd;
    }
    const reversed = [...this._commands].reverse();
    return (_b2 = reversed.find((c) => c.marker.line <= line - 1)) == null ? void 0 : _b2.cwd;
  }
  handlePromptStart(options) {
    var _a2;
    this._currentCommand.promptStartMarker = (options == null ? void 0 : options.marker) || this._terminal.registerMarker(0);
    this._logService.debug("CommandDetectionCapability#handlePromptStart", this._terminal.buffer.active.cursorX, (_a2 = this._currentCommand.promptStartMarker) == null ? void 0 : _a2.line);
  }
  handleContinuationStart() {
    this._currentCommand.currentContinuationMarker = this._terminal.registerMarker(0);
    this._logService.debug("CommandDetectionCapability#handleContinuationStart", this._currentCommand.currentContinuationMarker);
  }
  handleContinuationEnd() {
    if (!this._currentCommand.currentContinuationMarker) {
      this._logService.warn("CommandDetectionCapability#handleContinuationEnd Received continuation end without start");
      return;
    }
    if (!this._currentCommand.continuations) {
      this._currentCommand.continuations = [];
    }
    this._currentCommand.continuations.push({
      marker: this._currentCommand.currentContinuationMarker,
      end: this._terminal.buffer.active.cursorX
    });
    this._currentCommand.currentContinuationMarker = void 0;
    this._logService.debug("CommandDetectionCapability#handleContinuationEnd", this._currentCommand.continuations[this._currentCommand.continuations.length - 1]);
  }
  handleRightPromptStart() {
    this._currentCommand.commandRightPromptStartX = this._terminal.buffer.active.cursorX;
    this._logService.debug("CommandDetectionCapability#handleRightPromptStart", this._currentCommand.commandRightPromptStartX);
  }
  handleRightPromptEnd() {
    this._currentCommand.commandRightPromptEndX = this._terminal.buffer.active.cursorX;
    this._logService.debug("CommandDetectionCapability#handleRightPromptEnd", this._currentCommand.commandRightPromptEndX);
  }
  handleCommandStart(options) {
    var _a2, _b2, _c2, _d2;
    this._handleCommandStartOptions = options;
    this._currentCommand.commandStartMarker = (options == null ? void 0 : options.marker) || this._currentCommand.commandStartMarker;
    if (((_a2 = this._currentCommand.commandStartMarker) == null ? void 0 : _a2.line) === this._terminal.buffer.active.cursorY) {
      this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;
      this._logService.debug("CommandDetectionCapability#handleCommandStart", this._currentCommand.commandStartX, (_b2 = this._currentCommand.commandStartMarker) == null ? void 0 : _b2.line);
      return;
    }
    if (this._isWindowsPty) {
      this._handleCommandStartWindows();
      return;
    }
    this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;
    this._currentCommand.commandStartMarker = (options == null ? void 0 : options.marker) || this._terminal.registerMarker(0);
    (_c2 = this._currentCommand.commandExecutedMarker) == null ? void 0 : _c2.dispose();
    this._currentCommand.commandExecutedMarker = void 0;
    this._currentCommand.commandExecutedX = void 0;
    for (const m of this._commandMarkers) {
      m.dispose();
    }
    this._commandMarkers.length = 0;
    this._onCommandStarted.fire({ marker: (options == null ? void 0 : options.marker) || this._currentCommand.commandStartMarker, markProperties: options == null ? void 0 : options.markProperties });
    this._logService.debug("CommandDetectionCapability#handleCommandStart", this._currentCommand.commandStartX, (_d2 = this._currentCommand.commandStartMarker) == null ? void 0 : _d2.line);
  }
  _handleCommandStartWindows() {
    this._currentCommand.commandStartX = this._terminal.buffer.active.cursorX;
    this._commandMarkers.length = 0;
    timeout(0).then(() => {
      var _a2;
      if (!this._currentCommand.commandExecutedMarker) {
        this._onCursorMoveListener = this._terminal.onCursorMove(() => {
          if (this._commandMarkers.length === 0 || this._commandMarkers[this._commandMarkers.length - 1].line !== this._terminal.buffer.active.cursorY) {
            const marker = this._terminal.registerMarker(0);
            if (marker) {
              this._commandMarkers.push(marker);
            }
          }
        });
      }
      this._currentCommand.commandStartMarker = this._terminal.registerMarker(0);
      if (this._currentCommand.commandStartMarker) {
        const line = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line);
        if (line) {
          this._currentCommand.commandStartLineContent = line.translateToString(true);
        }
      }
      this._onCommandStarted.fire({ marker: this._currentCommand.commandStartMarker });
      this._logService.debug("CommandDetectionCapability#_handleCommandStartWindows", this._currentCommand.commandStartX, (_a2 = this._currentCommand.commandStartMarker) == null ? void 0 : _a2.line);
    });
  }
  handleGenericCommand(options) {
    var _a2;
    if ((_a2 = options == null ? void 0 : options.markProperties) == null ? void 0 : _a2.disableCommandStorage) {
      this.setIsCommandStorageDisabled();
    }
    this.handlePromptStart(options);
    this.handleCommandStart(options);
    this.handleCommandExecuted(options);
    this.handleCommandFinished(void 0, options);
  }
  handleCommandExecuted(options) {
    var _a2, _b2, _c2, _d2;
    if (this._isWindowsPty) {
      this._handleCommandExecutedWindows();
      return;
    }
    this._currentCommand.commandExecutedMarker = (options == null ? void 0 : options.marker) || this._terminal.registerMarker(0);
    this._currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;
    this._logService.debug("CommandDetectionCapability#handleCommandExecuted", this._currentCommand.commandExecutedX, (_a2 = this._currentCommand.commandExecutedMarker) == null ? void 0 : _a2.line);
    if (!this._currentCommand.commandStartMarker || !this._currentCommand.commandExecutedMarker || this._currentCommand.commandStartX === void 0) {
      return;
    }
    this._currentCommand.command = this.__isCommandStorageDisabled ? "" : (_b2 = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line)) == null ? void 0 : _b2.translateToString(true, this._currentCommand.commandStartX, this._currentCommand.commandRightPromptStartX).trim();
    let y = this._currentCommand.commandStartMarker.line + 1;
    const commandExecutedLine = this._currentCommand.commandExecutedMarker.line;
    for (; y < commandExecutedLine; y++) {
      const line = this._terminal.buffer.active.getLine(y);
      if (line) {
        const continuation = (_c2 = this._currentCommand.continuations) == null ? void 0 : _c2.find((e) => e.marker.line === y);
        if (continuation) {
          this._currentCommand.command += "\n";
        }
        const startColumn = (continuation == null ? void 0 : continuation.end) ?? 0;
        this._currentCommand.command += line.translateToString(true, startColumn);
      }
    }
    if (y === commandExecutedLine) {
      this._currentCommand.command += ((_d2 = this._terminal.buffer.active.getLine(commandExecutedLine)) == null ? void 0 : _d2.translateToString(true, void 0, this._currentCommand.commandExecutedX)) || "";
    }
    this._onCommandExecuted.fire();
  }
  _handleCommandExecutedWindows() {
    var _a2, _b2;
    (_a2 = this._onCursorMoveListener) == null ? void 0 : _a2.dispose();
    this._onCursorMoveListener = void 0;
    this._evaluateCommandMarkersWindows();
    this._currentCommand.commandExecutedX = this._terminal.buffer.active.cursorX;
    this._onCommandExecuted.fire();
    this._logService.debug("CommandDetectionCapability#handleCommandExecuted", this._currentCommand.commandExecutedX, (_b2 = this._currentCommand.commandExecutedMarker) == null ? void 0 : _b2.line);
  }
  invalidateCurrentCommand(request) {
    this._currentCommand.isInvalid = true;
    this._onCurrentCommandInvalidated.fire(request);
  }
  handleCommandFinished(exitCode, options) {
    var _a2, _b2, _c2;
    if (this._isWindowsPty) {
      this._preHandleCommandFinishedWindows();
    }
    this._currentCommand.commandFinishedMarker = (options == null ? void 0 : options.marker) || this._terminal.registerMarker(0);
    let command = this._currentCommand.command;
    this._logService.debug("CommandDetectionCapability#handleCommandFinished", this._terminal.buffer.active.cursorX, (_a2 = this._currentCommand.commandFinishedMarker) == null ? void 0 : _a2.line, this._currentCommand.command, this._currentCommand);
    this._exitCode = exitCode;
    if (this._exitCode === void 0) {
      const lastCommand = this.commands.length > 0 ? this.commands[this.commands.length - 1] : void 0;
      if (command && command.length > 0 && (lastCommand == null ? void 0 : lastCommand.command) === command) {
        this._exitCode = lastCommand.exitCode;
      }
    }
    if (this._currentCommand.commandStartMarker === void 0 || !this._terminal.buffer.active) {
      return;
    }
    if (this._exitCode === void 0 && command === void 0) {
      command = "";
    }
    if (command !== void 0 && !command.startsWith("\\") || ((_b2 = this._handleCommandStartOptions) == null ? void 0 : _b2.ignoreCommandLine)) {
      const buffer = this._terminal.buffer.active;
      const timestamp = Date.now();
      const executedMarker = this._currentCommand.commandExecutedMarker;
      const endMarker = this._currentCommand.commandFinishedMarker;
      const newCommand = {
        command: ((_c2 = this._handleCommandStartOptions) == null ? void 0 : _c2.ignoreCommandLine) ? "" : command || "",
        isTrusted: !!this._currentCommand.isTrusted,
        marker: this._currentCommand.commandStartMarker,
        endMarker,
        executedMarker,
        timestamp,
        cwd: this._cwd,
        exitCode: this._exitCode,
        commandStartLineContent: this._currentCommand.commandStartLineContent,
        hasOutput: () => !(executedMarker == null ? void 0 : executedMarker.isDisposed) && !(endMarker == null ? void 0 : endMarker.isDisposed) && !!(executedMarker && endMarker && (executedMarker == null ? void 0 : executedMarker.line) < endMarker.line),
        getOutput: () => getOutputForCommand(executedMarker, endMarker, buffer),
        getOutputMatch: (outputMatcher) => getOutputMatchForCommand(this._isWindowsPty && (executedMarker == null ? void 0 : executedMarker.line) === (endMarker == null ? void 0 : endMarker.line) ? this._currentCommand.commandStartMarker : executedMarker, endMarker, buffer, this._terminal.cols, outputMatcher),
        markProperties: options == null ? void 0 : options.markProperties
      };
      this._commands.push(newCommand);
      this._logService.debug("CommandDetectionCapability#onCommandFinished", newCommand);
      this._onBeforeCommandFinished.fire(newCommand);
      if (!this._currentCommand.isInvalid) {
        this._onCommandFinished.fire(newCommand);
      }
    }
    this._currentCommand.previousCommandMarker = this._currentCommand.commandStartMarker;
    this._currentCommand = {};
    this._handleCommandStartOptions = void 0;
  }
  _preHandleCommandFinishedWindows() {
    if (this._currentCommand.commandExecutedMarker) {
      return;
    }
    if (this._commandMarkers.length === 0) {
      if (!this._currentCommand.commandStartMarker) {
        this._currentCommand.commandStartMarker = this._terminal.registerMarker(0);
      }
      if (this._currentCommand.commandStartMarker) {
        this._commandMarkers.push(this._currentCommand.commandStartMarker);
      }
    }
    this._evaluateCommandMarkersWindows();
  }
  _evaluateCommandMarkersWindows() {
    if (this._commandMarkers.length === 0) {
      return;
    }
    this._commandMarkers = this._commandMarkers.sort((a, b) => a.line - b.line);
    this._currentCommand.commandStartMarker = this._commandMarkers[0];
    if (this._currentCommand.commandStartMarker) {
      const line = this._terminal.buffer.active.getLine(this._currentCommand.commandStartMarker.line);
      if (line) {
        this._currentCommand.commandStartLineContent = line.translateToString(true);
      }
    }
    this._currentCommand.commandExecutedMarker = this._commandMarkers[this._commandMarkers.length - 1];
  }
  setCommandLine(commandLine, isTrusted) {
    this._logService.debug("CommandDetectionCapability#setCommandLine", commandLine, isTrusted);
    this._currentCommand.command = commandLine;
    this._currentCommand.isTrusted = isTrusted;
  }
  serialize() {
    const commands = this.commands.map((e) => {
      var _a2, _b2, _c2;
      return {
        startLine: (_a2 = e.marker) == null ? void 0 : _a2.line,
        startX: void 0,
        endLine: (_b2 = e.endMarker) == null ? void 0 : _b2.line,
        executedLine: (_c2 = e.executedMarker) == null ? void 0 : _c2.line,
        command: this.__isCommandStorageDisabled ? "" : e.command,
        isTrusted: e.isTrusted,
        cwd: e.cwd,
        exitCode: e.exitCode,
        commandStartLineContent: e.commandStartLineContent,
        timestamp: e.timestamp,
        markProperties: e.markProperties,
        aliases: e.aliases
      };
    });
    if (this._currentCommand.commandStartMarker) {
      commands.push({
        startLine: this._currentCommand.commandStartMarker.line,
        startX: this._currentCommand.commandStartX,
        endLine: void 0,
        executedLine: void 0,
        command: "",
        isTrusted: true,
        cwd: this._cwd,
        exitCode: void 0,
        commandStartLineContent: void 0,
        timestamp: 0,
        markProperties: void 0
      });
    }
    return {
      isWindowsPty: this._isWindowsPty,
      commands
    };
  }
  deserialize(serialized) {
    if (serialized.isWindowsPty) {
      this.setIsWindowsPty(serialized.isWindowsPty);
    }
    const buffer = this._terminal.buffer.normal;
    for (const e of serialized.commands) {
      const marker = e.startLine !== void 0 ? this._terminal.registerMarker(e.startLine - (buffer.baseY + buffer.cursorY)) : void 0;
      if (!marker) {
        continue;
      }
      if (!e.endLine) {
        this._currentCommand.commandStartMarker = marker;
        this._currentCommand.commandStartX = e.startX;
        this._cwd = e.cwd;
        this._onCommandStarted.fire({ marker });
        continue;
      }
      const endMarker = e.endLine !== void 0 ? this._terminal.registerMarker(e.endLine - (buffer.baseY + buffer.cursorY)) : void 0;
      const executedMarker = e.executedLine !== void 0 ? this._terminal.registerMarker(e.executedLine - (buffer.baseY + buffer.cursorY)) : void 0;
      const newCommand = {
        command: this.__isCommandStorageDisabled ? "" : e.command,
        isTrusted: e.isTrusted,
        marker,
        endMarker,
        executedMarker,
        timestamp: e.timestamp,
        cwd: e.cwd,
        commandStartLineContent: e.commandStartLineContent,
        exitCode: e.exitCode,
        hasOutput: () => !(executedMarker == null ? void 0 : executedMarker.isDisposed) && !(endMarker == null ? void 0 : endMarker.isDisposed) && !!(executedMarker && endMarker && executedMarker.line < endMarker.line),
        getOutput: () => getOutputForCommand(executedMarker, endMarker, buffer),
        getOutputMatch: (outputMatcher) => getOutputMatchForCommand(this._isWindowsPty && (executedMarker == null ? void 0 : executedMarker.line) === (endMarker == null ? void 0 : endMarker.line) ? marker : executedMarker, endMarker, buffer, this._terminal.cols, outputMatcher),
        markProperties: e.markProperties,
        wasReplayed: true
      };
      this._commands.push(newCommand);
      this._logService.debug("CommandDetectionCapability#onCommandFinished", newCommand);
      this._onCommandFinished.fire(newCommand);
    }
  }
}
CommandDetectionCapability.__decorator = __decorate([
  debounce(500)
], CommandDetectionCapability.prototype, "_handleCursorMove", null);
function getOutputForCommand(executedMarker, endMarker, buffer) {
  if (!executedMarker || !endMarker) {
    return void 0;
  }
  const startLine = executedMarker.line;
  const endLine = endMarker.line;
  if (startLine === endLine) {
    return void 0;
  }
  let output = "";
  let line;
  for (let i = startLine; i < endLine; i++) {
    line = buffer.getLine(i);
    if (!line) {
      continue;
    }
    output += line.translateToString(!line.isWrapped) + (line.isWrapped ? "" : "\n");
  }
  return output === "" ? void 0 : output;
}
function getOutputMatchForCommand(executedMarker, endMarker, buffer, cols, outputMatcher) {
  var _a2, _b2;
  if (!executedMarker || !endMarker) {
    return void 0;
  }
  const endLine = endMarker.line;
  if (endLine === -1) {
    return void 0;
  }
  const startLine = Math.max(executedMarker.line, 0);
  const matcher = outputMatcher.lineMatcher;
  const linesToCheck = typeof matcher === "string" ? 1 : outputMatcher.length || countNewLines(matcher);
  const lines = [];
  let match;
  if (outputMatcher.anchor === "bottom") {
    for (let i = endLine - (outputMatcher.offset || 0); i >= startLine; i--) {
      let wrappedLineStart = i;
      const wrappedLineEnd = i;
      while (wrappedLineStart >= startLine && ((_a2 = buffer.getLine(wrappedLineStart)) == null ? void 0 : _a2.isWrapped)) {
        wrappedLineStart--;
      }
      i = wrappedLineStart;
      lines.unshift(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));
      if (!match) {
        match = lines[0].match(matcher);
      }
      if (lines.length >= linesToCheck) {
        break;
      }
    }
  } else {
    for (let i = startLine + (outputMatcher.offset || 0); i < endLine; i++) {
      const wrappedLineStart = i;
      let wrappedLineEnd = i;
      while (wrappedLineEnd + 1 < endLine && ((_b2 = buffer.getLine(wrappedLineEnd + 1)) == null ? void 0 : _b2.isWrapped)) {
        wrappedLineEnd++;
      }
      i = wrappedLineEnd;
      lines.push(getXtermLineContent(buffer, wrappedLineStart, wrappedLineEnd, cols));
      if (!match) {
        match = lines[lines.length - 1].match(matcher);
      }
      if (lines.length >= linesToCheck) {
        break;
      }
    }
  }
  return match ? { regexMatch: match, outputLines: lines } : void 0;
}
function getXtermLineContent(buffer, lineStart, lineEnd, cols) {
  const maxLineLength = Math.max(2048 / cols * 2);
  lineEnd = Math.min(lineEnd, lineStart + maxLineLength);
  let content = "";
  for (let i = lineStart; i <= lineEnd; i++) {
    const line = buffer.getLine(i);
    if (line) {
      content += line.translateToString(true, 0, cols);
    }
  }
  return content;
}
function countNewLines(regex) {
  if (!regex.multiline) {
    return 1;
  }
  const source = regex.source;
  let count = 1;
  let i = source.indexOf("\\n");
  while (i !== -1) {
    count++;
    i = source.indexOf("\\n", i + 1);
  }
  return count;
}
class CwdDetectionCapability {
  constructor() {
    this.type = 0;
    this._cwd = "";
    this._cwds = /* @__PURE__ */ new Map();
    this._onDidChangeCwd = new Emitter();
    this.onDidChangeCwd = this._onDidChangeCwd.event;
  }
  get cwds() {
    return Array.from(this._cwds.keys());
  }
  getCwd() {
    return this._cwd;
  }
  updateCwd(cwd) {
    const didChange = this._cwd !== cwd;
    this._cwd = cwd;
    const count = this._cwds.get(this._cwd) || 0;
    this._cwds.delete(this._cwd);
    this._cwds.set(this._cwd, count + 1);
    if (didChange) {
      this._onDidChangeCwd.fire(cwd);
    }
  }
}
class PartialCommandDetectionCapability {
  get commands() {
    return this._commands;
  }
  constructor(_terminal) {
    this._terminal = _terminal;
    this.type = 3;
    this._commands = [];
    this._onCommandFinished = new Emitter();
    this.onCommandFinished = this._onCommandFinished.event;
    this._terminal.onData((e) => this._onData(e));
    this._terminal.parser.registerCsiHandler({ final: "J" }, (params) => {
      if (params.length >= 1 && (params[0] === 2 || params[0] === 3)) {
        this._clearCommandsInViewport();
      }
      return false;
    });
  }
  _onData(data) {
    if (data === "\r") {
      this._onEnter();
    }
  }
  _onEnter() {
    if (!this._terminal) {
      return;
    }
    if (this._terminal.buffer.active.cursorX >= 2) {
      const marker = this._terminal.registerMarker(0);
      if (marker) {
        this._commands.push(marker);
        this._onCommandFinished.fire(marker);
      }
    }
  }
  _clearCommandsInViewport() {
    let count = 0;
    for (let i = this._commands.length - 1; i >= 0; i--) {
      if (this._commands[i].line < this._terminal.buffer.active.baseY) {
        break;
      }
      count++;
    }
    this._commands.splice(this._commands.length - count, count);
  }
}
class BufferMarkCapability {
  constructor(_terminal) {
    this._terminal = _terminal;
    this.type = 4;
    this._idToMarkerMap = /* @__PURE__ */ new Map();
    this._anonymousMarkers = /* @__PURE__ */ new Map();
    this._onMarkAdded = new Emitter();
    this.onMarkAdded = this._onMarkAdded.event;
  }
  *markers() {
    for (const m of this._idToMarkerMap.values()) {
      yield m;
    }
    for (const m of this._anonymousMarkers.values()) {
      yield m;
    }
  }
  addMark(properties) {
    const marker = (properties == null ? void 0 : properties.marker) || this._terminal.registerMarker();
    const id = properties == null ? void 0 : properties.id;
    if (!marker) {
      return;
    }
    if (id) {
      this._idToMarkerMap.set(id, marker);
      marker.onDispose(() => this._idToMarkerMap.delete(id));
    } else {
      this._anonymousMarkers.set(marker.id, marker);
      marker.onDispose(() => this._anonymousMarkers.delete(marker.id));
    }
    this._onMarkAdded.fire({ marker, id, hidden: properties == null ? void 0 : properties.hidden, hoverMessage: properties == null ? void 0 : properties.hoverMessage });
  }
  getMark(id) {
    return this._idToMarkerMap.get(id);
  }
}
function escapeNonWindowsPath(path) {
  let newPath = path;
  if (newPath.includes("\\")) {
    newPath = newPath.replace(/\\/g, "\\\\");
  }
  const bannedChars = /[\`\$\|\&\>\~\#\!\^\*\;\<\"\']/g;
  newPath = newPath.replace(bannedChars, "");
  return `'${newPath}'`;
}
function collapseTildePath(path, userHome, separator) {
  if (!path) {
    return "";
  }
  if (!userHome) {
    return path;
  }
  if (userHome.match(/[\/\\]$/)) {
    userHome = userHome.slice(0, userHome.length - 1);
  }
  const normalizedPath = path.replace(/\\/g, "/").toLowerCase();
  const normalizedUserHome = userHome.replace(/\\/g, "/").toLowerCase();
  if (!normalizedPath.includes(normalizedUserHome)) {
    return path;
  }
  return `~${separator}${path.slice(userHome.length + 1)}`;
}
function sanitizeCwd(cwd) {
  if (cwd.match(/^['"].*['"]$/)) {
    cwd = cwd.substring(1, cwd.length - 1);
  }
  if (OS === 1 && cwd && cwd[1] === ":") {
    return cwd[0].toUpperCase() + cwd.substring(1);
  }
  return cwd;
}
class ShellIntegrationAddon extends Disposable {
  get status() {
    return this._status;
  }
  constructor(_nonce, _disableTelemetry, _telemetryService, _logService) {
    super();
    this._nonce = _nonce;
    this._disableTelemetry = _disableTelemetry;
    this._telemetryService = _telemetryService;
    this._logService = _logService;
    this.capabilities = new TerminalCapabilityStore();
    this._hasUpdatedTelemetry = false;
    this._commonProtocolDisposables = [];
    this._status = 0;
    this._onDidChangeStatus = new Emitter();
    this.onDidChangeStatus = this._onDidChangeStatus.event;
    this._register(toDisposable(() => {
      this._clearActivationTimeout();
      this._disposeCommonProtocol();
    }));
  }
  _disposeCommonProtocol() {
    dispose(this._commonProtocolDisposables);
    this._commonProtocolDisposables.length = 0;
  }
  activate(xterm2) {
    this._terminal = xterm2;
    this.capabilities.add(3, new PartialCommandDetectionCapability(this._terminal));
    this._register(xterm2.parser.registerOscHandler(633, (data) => this._handleVSCodeSequence(data)));
    this._register(xterm2.parser.registerOscHandler(1337, (data) => this._doHandleITermSequence(data)));
    this._commonProtocolDisposables.push(xterm2.parser.registerOscHandler(133, (data) => this._handleFinalTermSequence(data)));
    this._register(xterm2.parser.registerOscHandler(7, (data) => this._doHandleSetCwd(data)));
    this._register(xterm2.parser.registerOscHandler(9, (data) => this._doHandleSetWindowsFriendlyCwd(data)));
    this._ensureCapabilitiesOrAddFailureTelemetry();
  }
  _handleFinalTermSequence(data) {
    const didHandle = this._doHandleFinalTermSequence(data);
    if (this._status === 0) {
      this._status = 1;
      this._onDidChangeStatus.fire(this._status);
    }
    return didHandle;
  }
  _doHandleFinalTermSequence(data) {
    if (!this._terminal) {
      return false;
    }
    const [command, ...args] = data.split(";");
    switch (command) {
      case "A":
        this._createOrGetCommandDetection(this._terminal).handlePromptStart();
        return true;
      case "B":
        this._createOrGetCommandDetection(this._terminal).handleCommandStart({ ignoreCommandLine: true });
        return true;
      case "C":
        this._createOrGetCommandDetection(this._terminal).handleCommandExecuted();
        return true;
      case "D": {
        const exitCode = args.length === 1 ? parseInt(args[0]) : void 0;
        this._createOrGetCommandDetection(this._terminal).handleCommandFinished(exitCode);
        return true;
      }
    }
    return false;
  }
  _handleVSCodeSequence(data) {
    var _a2;
    const didHandle = this._doHandleVSCodeSequence(data);
    if (!this._hasUpdatedTelemetry && didHandle) {
      (_a2 = this._telemetryService) == null ? void 0 : _a2.publicLog2("terminal/shellIntegrationActivationSucceeded");
      this._hasUpdatedTelemetry = true;
      this._clearActivationTimeout();
    }
    if (this._status !== 2) {
      this._status = 2;
      this._onDidChangeStatus.fire(this._status);
    }
    return didHandle;
  }
  async _ensureCapabilitiesOrAddFailureTelemetry() {
    if (!this._telemetryService || this._disableTelemetry) {
      return;
    }
    this._activationTimeout = setTimeout(() => {
      var _a2;
      if (!this.capabilities.get(2) && !this.capabilities.get(0)) {
        (_a2 = this._telemetryService) == null ? void 0 : _a2.publicLog2("terminal/shellIntegrationActivationTimeout");
        this._logService.warn("Shell integration failed to add capabilities within 10 seconds");
      }
      this._hasUpdatedTelemetry = true;
    }, 1e4);
  }
  _clearActivationTimeout() {
    if (this._activationTimeout !== void 0) {
      clearTimeout(this._activationTimeout);
      this._activationTimeout = void 0;
    }
  }
  _doHandleVSCodeSequence(data) {
    var _a2;
    if (!this._terminal) {
      return false;
    }
    const argsIndex = data.indexOf(";");
    const sequenceCommand = argsIndex === -1 ? data : data.substring(0, argsIndex);
    const args = argsIndex === -1 ? [] : data.substring(argsIndex + 1).split(";");
    switch (sequenceCommand) {
      case "A":
        this._createOrGetCommandDetection(this._terminal).handlePromptStart();
        return true;
      case "B":
        this._createOrGetCommandDetection(this._terminal).handleCommandStart();
        return true;
      case "C":
        this._createOrGetCommandDetection(this._terminal).handleCommandExecuted();
        return true;
      case "D": {
        const arg0 = args[0];
        const exitCode = arg0 !== void 0 ? parseInt(arg0) : void 0;
        this._createOrGetCommandDetection(this._terminal).handleCommandFinished(exitCode);
        return true;
      }
      case "E": {
        const arg0 = args[0];
        const arg1 = args[1];
        let commandLine;
        if (arg0 !== void 0) {
          commandLine = deserializeMessage(arg0);
        } else {
          commandLine = "";
        }
        this._createOrGetCommandDetection(this._terminal).setCommandLine(commandLine, arg1 === this._nonce);
        return true;
      }
      case "F": {
        this._createOrGetCommandDetection(this._terminal).handleContinuationStart();
        return true;
      }
      case "G": {
        this._createOrGetCommandDetection(this._terminal).handleContinuationEnd();
        return true;
      }
      case "H": {
        this._createOrGetCommandDetection(this._terminal).handleRightPromptStart();
        return true;
      }
      case "I": {
        this._createOrGetCommandDetection(this._terminal).handleRightPromptEnd();
        return true;
      }
      case "P": {
        const arg0 = args[0];
        const deserialized = arg0 !== void 0 ? deserializeMessage(arg0) : "";
        const { key, value } = parseKeyValueAssignment(deserialized);
        if (value === void 0) {
          return true;
        }
        switch (key) {
          case "Cwd": {
            this._updateCwd(value);
            return true;
          }
          case "IsWindows": {
            this._createOrGetCommandDetection(this._terminal).setIsWindowsPty(value === "True" ? true : false);
            return true;
          }
          case "Task": {
            this._createOrGetBufferMarkDetection(this._terminal);
            (_a2 = this.capabilities.get(2)) == null ? void 0 : _a2.setIsCommandStorageDisabled();
            return true;
          }
        }
      }
      case "SetMark": {
        this._createOrGetBufferMarkDetection(this._terminal).addMark(parseMarkSequence(args));
        return true;
      }
    }
    return false;
  }
  _updateCwd(value) {
    value = sanitizeCwd(value);
    this._createOrGetCwdDetection().updateCwd(value);
    const commandDetection = this.capabilities.get(2);
    commandDetection == null ? void 0 : commandDetection.setCwd(value);
  }
  _doHandleITermSequence(data) {
    if (!this._terminal) {
      return false;
    }
    const [command] = data.split(";");
    switch (command) {
      case "SetMark": {
        this._createOrGetBufferMarkDetection(this._terminal).addMark();
      }
      default: {
        const { key, value } = parseKeyValueAssignment(command);
        if (value === void 0) {
          return true;
        }
        switch (key) {
          case "CurrentDir":
            this._updateCwd(value);
            return true;
        }
      }
    }
    return false;
  }
  _doHandleSetWindowsFriendlyCwd(data) {
    if (!this._terminal) {
      return false;
    }
    const [command, ...args] = data.split(";");
    switch (command) {
      case "9":
        if (args.length) {
          this._updateCwd(args[0]);
        }
        return true;
    }
    return false;
  }
  _doHandleSetCwd(data) {
    if (!this._terminal) {
      return false;
    }
    const [command] = data.split(";");
    if (command.match(/^file:\/\/.*\//)) {
      const uri = URI.parse(command);
      if (uri.path && uri.path.length > 0) {
        this._updateCwd(uri.path);
        return true;
      }
    }
    return false;
  }
  serialize() {
    if (!this._terminal || !this.capabilities.has(2)) {
      return {
        isWindowsPty: false,
        commands: []
      };
    }
    const result = this._createOrGetCommandDetection(this._terminal).serialize();
    return result;
  }
  deserialize(serialized) {
    if (!this._terminal) {
      throw new Error("Cannot restore commands before addon is activated");
    }
    this._createOrGetCommandDetection(this._terminal).deserialize(serialized);
  }
  _createOrGetCwdDetection() {
    let cwdDetection = this.capabilities.get(0);
    if (!cwdDetection) {
      cwdDetection = new CwdDetectionCapability();
      this.capabilities.add(0, cwdDetection);
    }
    return cwdDetection;
  }
  _createOrGetCommandDetection(terminal) {
    let commandDetection = this.capabilities.get(2);
    if (!commandDetection) {
      commandDetection = new CommandDetectionCapability(terminal, this._logService);
      this.capabilities.add(2, commandDetection);
    }
    return commandDetection;
  }
  _createOrGetBufferMarkDetection(terminal) {
    let bufferMarkDetection = this.capabilities.get(4);
    if (!bufferMarkDetection) {
      bufferMarkDetection = new BufferMarkCapability(terminal);
      this.capabilities.add(4, bufferMarkDetection);
    }
    return bufferMarkDetection;
  }
}
function deserializeMessage(message) {
  return message.replaceAll(
    /\\(\\|x([0-9a-f]{2}))/gi,
    (_match, op, hex) => hex ? String.fromCharCode(parseInt(hex, 16)) : op
  );
}
function parseKeyValueAssignment(message) {
  const separatorIndex = message.indexOf("=");
  if (separatorIndex === -1) {
    return { key: message, value: void 0 };
  }
  return {
    key: message.substring(0, separatorIndex),
    value: message.substring(1 + separatorIndex)
  };
}
function parseMarkSequence(sequence) {
  let id = void 0;
  let hidden = false;
  for (const property of sequence) {
    if (property === void 0) {
      continue;
    }
    if (property === "Hidden") {
      hidden = true;
    }
    if (property.startsWith("Id=")) {
      id = property.substring(3);
    }
  }
  return { id, hidden };
}
let TerminalDecorationHoverManager = class TerminalDecorationHoverManager2 extends Disposable {
  constructor(_hoverService, configurationService, contextMenuService) {
    super();
    this._hoverService = _hoverService;
    this._contextMenuVisible = false;
    this._register(contextMenuService.onDidShowContextMenu(() => this._contextMenuVisible = true));
    this._register(contextMenuService.onDidHideContextMenu(() => this._contextMenuVisible = false));
    this._hoverDelayer = this._register(new Delayer(configurationService.getValue("workbench.hover.delay")));
  }
  hideHover() {
    this._hoverDelayer.cancel();
    this._hoverService.hideHover();
  }
  createHover(element, command, hoverMessage) {
    return combinedDisposable(addDisposableListener(element, EventType.MOUSE_ENTER, () => {
      if (this._contextMenuVisible) {
        return;
      }
      this._hoverDelayer.trigger(() => {
        var _a2, _b2;
        let hoverContent = `${localize("terminalPromptContextMenu", "Show Command Actions")}`;
        hoverContent += "\n\n---\n\n";
        if (!command) {
          if (hoverMessage) {
            hoverContent = hoverMessage;
          } else {
            return;
          }
        } else if (command.markProperties || hoverMessage) {
          if (((_a2 = command.markProperties) == null ? void 0 : _a2.hoverMessage) || hoverMessage) {
            hoverContent = ((_b2 = command.markProperties) == null ? void 0 : _b2.hoverMessage) || hoverMessage || "";
          } else {
            return;
          }
        } else if (command.exitCode) {
          if (command.exitCode === -1) {
            hoverContent += localize(
              "terminalPromptCommandFailed",
              "Command executed {0} and failed",
              fromNow(command.timestamp, true)
            );
          } else {
            hoverContent += localize(
              "terminalPromptCommandFailedWithExitCode",
              "Command executed {0} and failed (Exit Code {1})",
              fromNow(command.timestamp, true),
              command.exitCode
            );
          }
        } else {
          hoverContent += localize(
            "terminalPromptCommandSuccess",
            "Command executed {0}",
            fromNow(command.timestamp, true)
          );
        }
        this._hoverService.showHover({ content: new MarkdownString(hoverContent), target: element });
      });
    }), addDisposableListener(element, EventType.MOUSE_LEAVE, () => this.hideHover()), addDisposableListener(element, EventType.MOUSE_OUT, () => this.hideHover()));
  }
};
TerminalDecorationHoverManager = __decorate([
  __param(0, IHoverService),
  __param(1, IConfigurationService),
  __param(2, IContextMenuService)
], TerminalDecorationHoverManager);
function updateLayout(configurationService, element) {
  if (!element) {
    return;
  }
  const fontSize = configurationService.inspect("terminal.integrated.fontSize").value;
  const defaultFontSize = configurationService.inspect("terminal.integrated.fontSize").defaultValue;
  const lineHeight = configurationService.inspect("terminal.integrated.lineHeight").value;
  if (typeof fontSize === "number" && typeof defaultFontSize === "number" && typeof lineHeight === "number") {
    const scalar = fontSize / defaultFontSize <= 1 ? fontSize / defaultFontSize : 1;
    element.style.width = `${scalar * 16}px`;
    element.style.height = `${scalar * 16 * lineHeight}px`;
    element.style.fontSize = `${scalar * 16}px`;
    element.style.marginLeft = `${scalar * -17}px`;
  }
}
let DecorationAddon = class DecorationAddon2 extends Disposable {
  constructor(_capabilities, _clipboardService, _contextMenuService, _configurationService, _themeService, _openerService, _quickInputService, lifecycleService, _commandService, instantiationService, _audioCueService, _notificationService) {
    super();
    this._capabilities = _capabilities;
    this._clipboardService = _clipboardService;
    this._contextMenuService = _contextMenuService;
    this._configurationService = _configurationService;
    this._themeService = _themeService;
    this._openerService = _openerService;
    this._quickInputService = _quickInputService;
    this._commandService = _commandService;
    this._audioCueService = _audioCueService;
    this._notificationService = _notificationService;
    this._capabilityDisposables = /* @__PURE__ */ new Map();
    this._decorations = /* @__PURE__ */ new Map();
    this._onDidRequestRunCommand = this._register(new Emitter());
    this.onDidRequestRunCommand = this._onDidRequestRunCommand.event;
    this._register(toDisposable(() => this._dispose()));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("terminal.integrated.fontSize") || e.affectsConfiguration("terminal.integrated.lineHeight")) {
        this.refreshLayouts();
      } else if (e.affectsConfiguration("workbench.colorCustomizations")) {
        this._refreshStyles(true);
      } else if (e.affectsConfiguration("terminal.integrated.shellIntegration.decorationsEnabled")) {
        this._removeCapabilityDisposables(2);
        this._updateDecorationVisibility();
      }
    }));
    this._register(this._themeService.onDidColorThemeChange(() => this._refreshStyles(true)));
    this._updateDecorationVisibility();
    this._register(this._capabilities.onDidAddCapability((c) => this._createCapabilityDisposables(c)));
    this._register(this._capabilities.onDidRemoveCapability((c) => this._removeCapabilityDisposables(c)));
    this._register(lifecycleService.onWillShutdown(() => this._disposeAllDecorations()));
    this._terminalDecorationHoverService = instantiationService.createInstance(TerminalDecorationHoverManager);
  }
  _removeCapabilityDisposables(c) {
    const disposables = this._capabilityDisposables.get(c);
    if (disposables) {
      dispose(disposables);
    }
    this._capabilityDisposables.delete(c);
  }
  _createCapabilityDisposables(c) {
    let disposables = [];
    const capability = this._capabilities.get(c);
    if (!capability || this._capabilityDisposables.has(c)) {
      return;
    }
    switch (capability.type) {
      case 4:
        disposables = [capability.onMarkAdded((mark2) => this.registerMarkDecoration(mark2))];
        break;
      case 2:
        disposables = this._getCommandDetectionListeners(capability);
        break;
    }
    this._capabilityDisposables.set(c, disposables);
  }
  registerMarkDecoration(mark2) {
    if (!this._terminal || !this._showGutterDecorations && !this._showOverviewRulerDecorations) {
      return void 0;
    }
    if (mark2.hidden) {
      return void 0;
    }
    return this.registerCommandDecoration(void 0, void 0, mark2);
  }
  _updateDecorationVisibility() {
    var _a2;
    const showDecorations = this._configurationService.getValue("terminal.integrated.shellIntegration.decorationsEnabled");
    this._showGutterDecorations = showDecorations === "both" || showDecorations === "gutter";
    this._showOverviewRulerDecorations = showDecorations === "both" || showDecorations === "overviewRuler";
    this._disposeAllDecorations();
    if (this._showGutterDecorations || this._showOverviewRulerDecorations) {
      this._attachToCommandCapability();
      this._updateGutterDecorationVisibility();
    }
    const currentCommand = (_a2 = this._capabilities.get(2)) == null ? void 0 : _a2.executingCommandObject;
    if (currentCommand) {
      this.registerCommandDecoration(currentCommand, true);
    }
  }
  _disposeAllDecorations() {
    var _a2;
    (_a2 = this._placeholderDecoration) == null ? void 0 : _a2.dispose();
    for (const value of this._decorations.values()) {
      value.decoration.dispose();
      dispose(value.disposables);
    }
  }
  _updateGutterDecorationVisibility() {
    const commandDecorationElements = document.querySelectorAll("terminal-command-decoration");
    for (const commandDecorationElement of commandDecorationElements) {
      this._updateCommandDecorationVisibility(commandDecorationElement);
    }
  }
  _updateCommandDecorationVisibility(commandDecorationElement) {
    if (this._showGutterDecorations) {
      commandDecorationElement.classList.remove("hide");
    } else {
      commandDecorationElement.classList.add("hide");
    }
  }
  refreshLayouts() {
    var _a2;
    updateLayout(this._configurationService, (_a2 = this._placeholderDecoration) == null ? void 0 : _a2.element);
    for (const decoration of this._decorations) {
      updateLayout(this._configurationService, decoration[1].decoration.element);
    }
  }
  _refreshStyles(refreshOverviewRulerColors) {
    var _a2, _b2, _c2;
    if (refreshOverviewRulerColors) {
      for (const decoration of this._decorations.values()) {
        const color = ((_a2 = this._getDecorationCssColor(decoration)) == null ? void 0 : _a2.toString()) ?? "";
        if ((_b2 = decoration.decoration.options) == null ? void 0 : _b2.overviewRulerOptions) {
          decoration.decoration.options.overviewRulerOptions.color = color;
        } else if (decoration.decoration.options) {
          decoration.decoration.options.overviewRulerOptions = { color };
        }
      }
    }
    this._updateClasses((_c2 = this._placeholderDecoration) == null ? void 0 : _c2.element);
    for (const decoration of this._decorations.values()) {
      this._updateClasses(decoration.decoration.element, decoration.exitCode, decoration.markProperties);
    }
  }
  _dispose() {
    this._terminalDecorationHoverService.dispose();
    for (const disposable of this._capabilityDisposables.values()) {
      dispose(disposable);
    }
    this.clearDecorations();
  }
  _clearPlaceholder() {
    var _a2;
    (_a2 = this._placeholderDecoration) == null ? void 0 : _a2.dispose();
    this._placeholderDecoration = void 0;
  }
  clearDecorations() {
    var _a2;
    (_a2 = this._placeholderDecoration) == null ? void 0 : _a2.marker.dispose();
    this._clearPlaceholder();
    this._disposeAllDecorations();
    this._decorations.clear();
  }
  _attachToCommandCapability() {
    if (this._capabilities.has(2)) {
      this._getCommandDetectionListeners(this._capabilities.get(2));
    }
  }
  _getCommandDetectionListeners(capability) {
    var _a2;
    if (this._capabilityDisposables.has(2)) {
      const disposables = this._capabilityDisposables.get(2);
      dispose(disposables);
      this._capabilityDisposables.delete(capability.type);
    }
    const commandDetectionListeners = [];
    if ((_a2 = capability.executingCommandObject) == null ? void 0 : _a2.marker) {
      this.registerCommandDecoration(capability.executingCommandObject, true);
    }
    commandDetectionListeners.push(capability.onCommandStarted((command) => this.registerCommandDecoration(command, true)));
    for (const command of capability.commands) {
      this.registerCommandDecoration(command);
    }
    commandDetectionListeners.push(capability.onCommandFinished((command) => {
      this.registerCommandDecoration(command);
      if (command.exitCode) {
        this._audioCueService.playAudioCue(AudioCue.terminalCommandFailed);
      }
    }));
    commandDetectionListeners.push(capability.onCommandInvalidated((commands) => {
      var _a3;
      for (const command of commands) {
        const id = (_a3 = command.marker) == null ? void 0 : _a3.id;
        if (id) {
          const match = this._decorations.get(id);
          if (match) {
            match.decoration.dispose();
            dispose(match.disposables);
          }
        }
      }
    }));
    commandDetectionListeners.push(capability.onCurrentCommandInvalidated((request) => {
      if (request.reason === "noProblemsReported") {
        const lastDecoration = Array.from(this._decorations.entries())[this._decorations.size - 1];
        lastDecoration == null ? void 0 : lastDecoration[1].decoration.dispose();
      } else if (request.reason === "windows") {
        this._clearPlaceholder();
      }
    }));
    return commandDetectionListeners;
  }
  activate(terminal) {
    this._terminal = terminal;
    this._attachToCommandCapability();
  }
  registerCommandDecoration(command, beforeCommandExecution, markProperties) {
    var _a2;
    if (!this._terminal || beforeCommandExecution && !command || !this._showGutterDecorations && !this._showOverviewRulerDecorations) {
      return void 0;
    }
    const marker = (command == null ? void 0 : command.marker) || (markProperties == null ? void 0 : markProperties.marker);
    if (!marker) {
      throw new Error(`cannot add a decoration for a command ${JSON.stringify(command)} with no marker`);
    }
    this._clearPlaceholder();
    const color = ((_a2 = this._getDecorationCssColor(command)) == null ? void 0 : _a2.toString()) ?? "";
    const decoration = this._terminal.registerDecoration({
      marker,
      overviewRulerOptions: this._showOverviewRulerDecorations ? beforeCommandExecution ? { color, position: "left" } : { color, position: (command == null ? void 0 : command.exitCode) ? "right" : "left" } : void 0
    });
    if (!decoration) {
      return void 0;
    }
    if (beforeCommandExecution) {
      this._placeholderDecoration = decoration;
    }
    decoration.onRender((element) => {
      var _a3;
      if (element.classList.contains(".xterm-decoration-overview-ruler")) {
        return;
      }
      if (!this._decorations.get(decoration.marker.id)) {
        decoration.onDispose(() => this._decorations.delete(decoration.marker.id));
        this._decorations.set(decoration.marker.id, {
          decoration,
          disposables: this._createDisposables(element, command, markProperties),
          exitCode: command == null ? void 0 : command.exitCode,
          markProperties: command == null ? void 0 : command.markProperties
        });
      }
      if (!element.classList.contains("codicon") || ((_a3 = command == null ? void 0 : command.marker) == null ? void 0 : _a3.line) === 0) {
        updateLayout(this._configurationService, element);
        this._updateClasses(element, command == null ? void 0 : command.exitCode, (command == null ? void 0 : command.markProperties) || markProperties);
      }
    });
    return decoration;
  }
  _createDisposables(element, command, markProperties) {
    if ((command == null ? void 0 : command.exitCode) === void 0 && !(command == null ? void 0 : command.markProperties)) {
      return [];
    } else if ((command == null ? void 0 : command.markProperties) || markProperties) {
      return [this._terminalDecorationHoverService.createHover(element, command || markProperties, markProperties == null ? void 0 : markProperties.hoverMessage)];
    }
    return [this._createContextMenu(element, command), this._terminalDecorationHoverService.createHover(element, command)];
  }
  _updateClasses(element, exitCode, markProperties) {
    if (!element) {
      return;
    }
    for (const classes of element.classList) {
      element.classList.remove(classes);
    }
    element.classList.add("terminal-command-decoration", "codicon", "xterm-decoration");
    if (markProperties) {
      element.classList.add("default-color", ...ThemeIcon.asClassNameArray(terminalDecorationMark));
      if (!markProperties.hoverMessage) {
        element.classList.add("default");
      }
    } else {
      this._updateCommandDecorationVisibility(element);
      if (exitCode === void 0) {
        element.classList.add("default-color", "default");
        element.classList.add(...ThemeIcon.asClassNameArray(terminalDecorationIncomplete));
      } else if (exitCode) {
        element.classList.add("error");
        element.classList.add(...ThemeIcon.asClassNameArray(terminalDecorationError));
      } else {
        element.classList.add(...ThemeIcon.asClassNameArray(terminalDecorationSuccess));
      }
    }
  }
  _createContextMenu(element, command) {
    return addDisposableListener(element, EventType.CLICK, async () => {
      this._terminalDecorationHoverService.hideHover();
      const actions = await this._getCommandActions(command);
      this._contextMenuService.showContextMenu({ getAnchor: () => element, getActions: () => actions });
    });
  }
  async _getCommandActions(command) {
    const actions = [];
    if (command.command !== "") {
      const labelRun = localize("terminal.rerunCommand", "Rerun Command");
      actions.push({
        class: void 0,
        tooltip: labelRun,
        id: "terminal.rerunCommand",
        label: labelRun,
        enabled: true,
        run: async () => {
          if (command.command === "") {
            return;
          }
          if (!command.isTrusted) {
            const shouldRun = await new Promise((r) => {
              this._notificationService.prompt(Severity.Info, localize("rerun", "Do you want to run the command: {0}", command.command), [{
                label: localize("yes", "Yes"),
                run: () => r(true)
              }, {
                label: localize("no", "No"),
                run: () => r(false)
              }]);
            });
            if (!shouldRun) {
              return;
            }
          }
          this._onDidRequestRunCommand.fire({ command });
        }
      });
      const labelCopy = localize("terminal.copyCommand", "Copy Command");
      actions.push({
        class: void 0,
        tooltip: labelCopy,
        id: "terminal.copyCommand",
        label: labelCopy,
        enabled: true,
        run: () => this._clipboardService.writeText(command.command)
      });
    }
    if (command.hasOutput()) {
      if (actions.length > 0) {
        actions.push(new Separator());
      }
      const labelText = localize("terminal.copyOutput", "Copy Output");
      actions.push({
        class: void 0,
        tooltip: labelText,
        id: "terminal.copyOutput",
        label: labelText,
        enabled: true,
        run: () => {
          const text = command.getOutput();
          if (typeof text === "string") {
            this._clipboardService.writeText(text);
          }
        }
      });
      const labelHtml = localize("terminal.copyOutputAsHtml", "Copy Output as HTML");
      actions.push({
        class: void 0,
        tooltip: labelHtml,
        id: "terminal.copyOutputAsHtml",
        label: labelHtml,
        enabled: true,
        run: () => this._onDidRequestRunCommand.fire({ command, copyAsHtml: true })
      });
    }
    if (actions.length > 0) {
      actions.push(new Separator());
    }
    const labelRunRecent = localize("workbench.action.terminal.runRecentCommand", "Run Recent Command");
    actions.push({
      class: void 0,
      tooltip: labelRunRecent,
      id: "workbench.action.terminal.runRecentCommand",
      label: labelRunRecent,
      enabled: true,
      run: () => this._commandService.executeCommand("workbench.action.terminal.runRecentCommand")
    });
    const labelGoToRecent = localize("workbench.action.terminal.goToRecentDirectory", "Go To Recent Directory");
    actions.push({
      class: void 0,
      tooltip: labelRunRecent,
      id: "workbench.action.terminal.goToRecentDirectory",
      label: labelGoToRecent,
      enabled: true,
      run: () => this._commandService.executeCommand("workbench.action.terminal.goToRecentDirectory")
    });
    actions.push(new Separator());
    const labelConfigure = localize("terminal.configureCommandDecorations", "Configure Command Decorations");
    actions.push({
      class: void 0,
      tooltip: labelConfigure,
      id: "terminal.configureCommandDecorations",
      label: labelConfigure,
      enabled: true,
      run: () => this._showConfigureCommandDecorationsQuickPick()
    });
    const labelAbout = localize("terminal.learnShellIntegration", "Learn About Shell Integration");
    actions.push({
      class: void 0,
      tooltip: labelAbout,
      id: "terminal.learnShellIntegration",
      label: labelAbout,
      enabled: true,
      run: () => this._openerService.open("https://code.visualstudio.com/docs/terminal/shell-integration")
    });
    return actions;
  }
  async _showConfigureCommandDecorationsQuickPick() {
    const quickPick = this._quickInputService.createQuickPick();
    quickPick.items = [
      { id: "a", label: localize("toggleVisibility", "Toggle visibility") }
    ];
    quickPick.canSelectMany = false;
    quickPick.onDidAccept(async (e) => {
      quickPick.hide();
      const result = quickPick.activeItems[0];
      switch (result.id) {
        case "a":
          this._showToggleVisibilityQuickPick();
          break;
      }
    });
    quickPick.show();
  }
  _showToggleVisibilityQuickPick() {
    const quickPick = this._quickInputService.createQuickPick();
    quickPick.hideInput = true;
    quickPick.hideCheckAll = true;
    quickPick.canSelectMany = true;
    quickPick.title = localize("toggleVisibility", "Toggle visibility");
    const configValue = this._configurationService.getValue("terminal.integrated.shellIntegration.decorationsEnabled");
    const gutterIcon = {
      label: localize("gutter", "Gutter command decorations"),
      picked: configValue !== "never" && configValue !== "overviewRuler"
    };
    const overviewRulerIcon = {
      label: localize("overviewRuler", "Overview ruler command decorations"),
      picked: configValue !== "never" && configValue !== "gutter"
    };
    quickPick.items = [gutterIcon, overviewRulerIcon];
    const selectedItems = [];
    if (configValue !== "never") {
      if (configValue !== "gutter") {
        selectedItems.push(gutterIcon);
      }
      if (configValue !== "overviewRuler") {
        selectedItems.push(overviewRulerIcon);
      }
    }
    quickPick.selectedItems = selectedItems;
    quickPick.onDidChangeSelection(async (e) => {
      let newValue = "never";
      if (e.includes(gutterIcon)) {
        if (e.includes(overviewRulerIcon)) {
          newValue = "both";
        } else {
          newValue = "gutter";
        }
      } else if (e.includes(overviewRulerIcon)) {
        newValue = "overviewRuler";
      }
      await this._configurationService.updateValue("terminal.integrated.shellIntegration.decorationsEnabled", newValue);
    });
    quickPick.ok = false;
    quickPick.show();
  }
  _getDecorationCssColor(decorationOrCommand) {
    var _a2;
    let colorId;
    if ((decorationOrCommand == null ? void 0 : decorationOrCommand.exitCode) === void 0) {
      colorId = TERMINAL_COMMAND_DECORATION_DEFAULT_BACKGROUND_COLOR;
    } else {
      colorId = decorationOrCommand.exitCode ? TERMINAL_COMMAND_DECORATION_ERROR_BACKGROUND_COLOR : TERMINAL_COMMAND_DECORATION_SUCCESS_BACKGROUND_COLOR;
    }
    return (_a2 = this._themeService.getColorTheme().getColor(colorId)) == null ? void 0 : _a2.toString();
  }
};
DecorationAddon = __decorate([
  __param(1, IClipboardService),
  __param(2, IContextMenuService),
  __param(3, IConfigurationService),
  __param(4, IThemeService),
  __param(5, IOpenerService),
  __param(6, IQuickInputService),
  __param(7, ILifecycleService),
  __param(8, ICommandService),
  __param(9, IInstantiationService),
  __param(10, IAudioCueService),
  __param(11, INotificationService)
], DecorationAddon);
class SimpleCompletionItem {
  constructor(completion) {
    this.completion = completion;
    this.score = FuzzyScore.Default;
    this.distance = 0;
    this.labelLow = this.completion.label.toLowerCase();
  }
}
class LineContext {
  constructor(leadingLineContent, characterCountDelta) {
    this.leadingLineContent = leadingLineContent;
    this.characterCountDelta = characterCountDelta;
  }
}
class SimpleCompletionModel {
  constructor(_items, _lineContext, replacementIndex, replacementLength) {
    this._items = _items;
    this._lineContext = _lineContext;
    this.replacementIndex = replacementIndex;
    this.replacementLength = replacementLength;
    this._refilterKind = 1;
    this._fuzzyScoreOptions = FuzzyScoreOptions.default;
    this._options = {};
  }
  get items() {
    this._ensureCachedState();
    return this._filteredItems;
  }
  get stats() {
    this._ensureCachedState();
    return this._stats;
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(value) {
    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {
      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 : 1;
      this._lineContext = value;
    }
  }
  _ensureCachedState() {
    if (this._refilterKind !== 0) {
      this._createCachedState();
    }
  }
  _createCachedState() {
    const labelLengths = [];
    const { leadingLineContent, characterCountDelta } = this._lineContext;
    let word = "";
    let wordLow = "";
    const source = this._refilterKind === 1 ? this._items : this._filteredItems;
    const target = [];
    const scoreFn = !this._options.filterGraceful || source.length > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
    for (let i = 0; i < source.length; i++) {
      const item = source[i];
      const overwriteBefore = this.replacementLength;
      const wordLen = overwriteBefore + characterCountDelta;
      if (word.length !== wordLen) {
        word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
        wordLow = word.toLowerCase();
      }
      item.word = word;
      if (wordLen === 0) {
        item.score = FuzzyScore.Default;
      } else {
        let wordPos = 0;
        while (wordPos < overwriteBefore) {
          const ch = word.charCodeAt(wordPos);
          if (ch === 32 || ch === 9) {
            wordPos += 1;
          } else {
            break;
          }
        }
        if (wordPos >= wordLen) {
          item.score = FuzzyScore.Default;
        } else {
          const match = scoreFn(word, wordLow, wordPos, item.completion.label, item.labelLow, 0, this._fuzzyScoreOptions);
          if (!match) {
            continue;
          }
          item.score = match;
        }
      }
      item.idx = i;
      item.distance = 1;
      target.push(item);
      labelLengths.push(item.completion.label.length);
    }
    this._filteredItems = target;
    this._refilterKind = 0;
    this._stats = {
      pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - 0.85, labelLengths, (a, b) => a - b) : 0
    };
  }
}
var css$4 = '.workbench-suggest-widget{display:flex;flex-direction:column;left:0;position:absolute;top:0;width:430px;z-index:40}.workbench-suggest-widget.message{align-items:center;flex-direction:row}.monaco-workbench .workbench-suggest-details,.workbench-suggest-widget{background-color:var(--vscode-editorSuggestWidget-background);border-color:var(--vscode-editorSuggestWidget-border);border-style:solid;border-width:1px;flex:0 1 auto;width:100%}.monaco-workbench.hc-black .workbench-suggest-details,.monaco-workbench.hc-black .workbench-suggest-widget,.monaco-workbench.hc-light .workbench-suggest-details,.monaco-workbench.hc-light .workbench-suggest-widget{border-width:2px}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar{display:flex}.monaco-workbench .workbench-suggest-widget .suggest-status-bar .left{padding-right:8px}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar .action-label{color:var(--vscode-editorSuggestWidgetStatus-foreground)}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label{margin-right:0}.monaco-workbench .workbench-suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label:after{content:", ";margin-right:.3em}.monaco-workbench .workbench-suggest-widget.with-status-bar .monaco-list .monaco-list-row.focused.string-label>.contents>.main>.right>.readMore,.monaco-workbench .workbench-suggest-widget.with-status-bar .monaco-list .monaco-list-row>.contents>.main>.right>.readMore{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row{background-position:2px 2px;background-repeat:no-repeat;-mox-box-sizing:border-box;box-sizing:border-box;cursor:pointer;display:flex;padding-right:10px;touch-action:none;white-space:nowrap}.workbench-suggest-widget .monaco-list .monaco-list-row.focused{color:var(--vscode-editorSuggestWidget-selectedForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row.focused .codicon{color:var(--vscode-editorSuggestWidget-selectedIconForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents{flex:1;height:100%;overflow:hidden;padding-left:2px}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main{display:flex;justify-content:space-between;overflow:hidden;text-overflow:ellipsis;white-space:pre}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left,.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right{display:flex}.workbench-suggest-widget .monaco-list .monaco-list-row:not(.focused)>.contents>.main .monaco-icon-label{color:var(--vscode-editorSuggestWidget-foreground)}.workbench-suggest-widget:not(.frozen) .monaco-highlighted-label .highlight{font-weight:700}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main .monaco-highlighted-label .highlight{color:var(--vscode-editorSuggestWidget-highlightForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row.focused>.contents>.main .monaco-highlighted-label .highlight{color:var(--vscode-editorSuggestWidget-focusHighlightForeground)}.workbench-suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated{opacity:.66;text-decoration:unset}.workbench-suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated>.monaco-icon-label-container>.monaco-icon-name-container{text-decoration:line-through}.workbench-suggest-widget .monaco-list .monaco-list-row .monaco-icon-label:before{height:100%}.workbench-suggest-widget .monaco-list .monaco-list-row .icon{background-position:50%;background-repeat:no-repeat;background-size:80%;display:block;height:16px;margin-left:2px;width:16px}.workbench-suggest-widget .monaco-list .monaco-list-row .icon.hide{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row .suggest-icon{align-items:center;display:flex;margin-right:4px}.workbench-suggest-widget.no-icons .monaco-list .monaco-list-row .icon,.workbench-suggest-widget.no-icons .monaco-list .monaco-list-row .suggest-icon:before{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row .icon.customcolor .colorspan{border:.1em solid #000;display:inline-block;height:.7em;margin:0 0 0 .3em;width:.7em}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{opacity:.7}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.signature-label{opacity:.6;overflow:hidden;text-overflow:ellipsis}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.qualifier-label{align-self:center;font-size:85%;line-height:normal;margin-left:12px;opacity:.4;overflow:hidden;text-overflow:ellipsis}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{font-size:85%;margin-left:1.1em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label>.monaco-tokenized-source{display:inline}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{display:none}.workbench-suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.right>.details-label,.workbench-suggest-widget.docs-side .monaco-list .monaco-list-row.focused:not(.string-label)>.contents>.main>.right>.details-label,.workbench-suggest-widget:not(.shows-details) .monaco-list .monaco-list-row.focused>.contents>.main>.right>.details-label{display:inline}.workbench-suggest-widget:not(.docs-side) .monaco-list .monaco-list-row.focused:hover>.contents>.main>.right.can-expand-details>.details-label{width:calc(100% - 26px)}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left{flex-grow:1;flex-shrink:1;overflow:hidden}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.monaco-icon-label{flex-shrink:0}.workbench-suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.left>.monaco-icon-label{max-width:100%}.workbench-suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.left>.monaco-icon-label{flex-shrink:1}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right{flex-shrink:4;max-width:70%;overflow:hidden}.workbench-suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore{display:inline-block;height:18px;position:absolute;right:10px;visibility:hidden;width:18px}';
n(css$4, {});
function getAriaId(index) {
  return `simple-suggest-aria-id:${index}`;
}
class SimpleSuggestWidgetItemRenderer {
  constructor() {
    this._onDidToggleDetails = new Emitter();
    this.onDidToggleDetails = this._onDidToggleDetails.event;
    this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(container) {
    const disposables = new DisposableStore();
    const root = container;
    root.classList.add("show-file-icons");
    const icon = append(container, $$3(".icon"));
    const colorspan = append(icon, $$3("span.colorspan"));
    const text = append(container, $$3(".contents"));
    const main = append(text, $$3(".main"));
    const iconContainer = append(main, $$3(".icon-label.codicon"));
    const left = append(main, $$3("span.left"));
    const right = append(main, $$3("span.right"));
    const iconLabel = new IconLabel(left, { supportHighlights: true, supportIcons: true });
    disposables.add(iconLabel);
    const parametersLabel = append(left, $$3("span.signature-label"));
    const qualifierLabel = append(left, $$3("span.qualifier-label"));
    const detailsLabel = append(right, $$3("span.details-label"));
    const configureFont = () => {
      const fontFamily = "Hack";
      const fontFeatureSettings = "";
      const fontSize = "12";
      const lineHeight = "20";
      const fontWeight = "normal";
      const letterSpacing = "0";
      const fontSizePx = `${fontSize}px`;
      const lineHeightPx = `${lineHeight}px`;
      const letterSpacingPx = `${letterSpacing}px`;
      root.style.fontSize = fontSizePx;
      root.style.fontWeight = fontWeight;
      root.style.letterSpacing = letterSpacingPx;
      main.style.fontFamily = fontFamily;
      main.style.fontFeatureSettings = fontFeatureSettings;
      main.style.lineHeight = lineHeightPx;
      icon.style.height = lineHeightPx;
      icon.style.width = lineHeightPx;
    };
    configureFont();
    return { root, left, right, icon, colorspan, iconLabel, iconContainer, parametersLabel, qualifierLabel, detailsLabel, disposables };
  }
  renderElement(element, index, data) {
    const { completion } = element;
    data.root.id = getAriaId(index);
    data.colorspan.style.backgroundColor = "";
    const labelOptions = {
      labelEscapeNewLines: true,
      matches: createMatches(element.score)
    };
    data.icon.className = "icon hide";
    data.iconContainer.className = "";
    data.iconContainer.classList.add("suggest-icon", ...ThemeIcon.asClassNameArray(completion.icon || Codicon.symbolText));
    data.iconLabel.setLabel(completion.label, void 0, labelOptions);
    data.parametersLabel.textContent = "";
    data.detailsLabel.textContent = stripNewLines(completion.detail || "");
    data.root.classList.add("string-label");
    show(data.detailsLabel);
    data.right.classList.remove("can-expand-details");
  }
  disposeTemplate(templateData) {
    templateData.disposables.dispose();
  }
}
function stripNewLines(str) {
  return str.replace(/\r\n|\r|\n/g, "");
}
const $$2 = $$3;
let SimpleSuggestWidget = class SimpleSuggestWidget2 {
  get list() {
    return this._list;
  }
  constructor(_container, _persistedSize, options, instantiationService) {
    this._container = _container;
    this._persistedSize = _persistedSize;
    this._state = 0;
    this._forceRenderingAbove = false;
    this._pendingLayout = new MutableDisposable();
    this._showTimeout = new TimeoutTimer();
    this._disposables = new DisposableStore();
    this._onDidSelect = new Emitter();
    this.onDidSelect = this._onDidSelect.event;
    this._onDidHide = new Emitter();
    this.onDidHide = this._onDidHide.event;
    this._onDidShow = new Emitter();
    this.onDidShow = this._onDidShow.event;
    this.element = new ResizableHTMLElement();
    this.element.domNode.classList.add("workbench-suggest-widget");
    this._container.appendChild(this.element.domNode);
    class ResizeState {
      constructor(persistedSize, currentSize, persistHeight = false, persistWidth = false) {
        this.persistedSize = persistedSize;
        this.currentSize = currentSize;
        this.persistHeight = persistHeight;
        this.persistWidth = persistWidth;
      }
    }
    let state;
    this._disposables.add(this.element.onDidWillResize(() => {
      state = new ResizeState(this._persistedSize.restore(), this.element.size);
    }));
    this._disposables.add(this.element.onDidResize((e) => {
      var _a2, _b2;
      this._resize(e.dimension.width, e.dimension.height);
      if (state) {
        state.persistHeight = state.persistHeight || !!e.north || !!e.south;
        state.persistWidth = state.persistWidth || !!e.east || !!e.west;
      }
      if (!e.done) {
        return;
      }
      if (state) {
        const { itemHeight, defaultSize } = this._getLayoutInfo();
        const threshold = Math.round(itemHeight / 2);
        let { width, height } = this.element.size;
        if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) {
          height = ((_a2 = state.persistedSize) == null ? void 0 : _a2.height) ?? defaultSize.height;
        }
        if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) {
          width = ((_b2 = state.persistedSize) == null ? void 0 : _b2.width) ?? defaultSize.width;
        }
        this._persistedSize.store(new Dimension(width, height));
      }
      state = void 0;
    }));
    const renderer = new SimpleSuggestWidgetItemRenderer();
    this._disposables.add(renderer);
    this._listElement = append(this.element.domNode, $$2(".tree"));
    this._list = new List("SuggestWidget", this._listElement, {
      getHeight: (_element) => this._getLayoutInfo().itemHeight,
      getTemplateId: (_element) => "suggestion"
    }, [renderer], {
      alwaysConsumeMouseWheel: true,
      useShadows: false,
      mouseSupport: false,
      multipleSelectionSupport: false,
      accessibilityProvider: {
        getRole: () => "option",
        getWidgetAriaLabel: () => localize("suggest", "Suggest"),
        getWidgetRole: () => "listbox",
        getAriaLabel: (item) => {
          let label = item.completion.label;
          if (typeof item.completion.label !== "string") {
            const { detail: detail2, description } = item.completion.label;
            if (detail2 && description) {
              label = localize("label.full", "{0}{1}, {2}", label, detail2, description);
            } else if (detail2) {
              label = localize("label.detail", "{0}{1}", label, detail2);
            } else if (description) {
              label = localize("label.desc", "{0}, {1}", label, description);
            }
          }
          const { detail } = item.completion;
          return localize("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", label, detail);
        }
      }
    });
    if (options.statusBarMenuId) {
      this._status = instantiationService.createInstance(SuggestWidgetStatus, this.element.domNode, options.statusBarMenuId);
      this.element.domNode.classList.toggle("with-status-bar", true);
    }
    this._disposables.add(this._list.onMouseDown((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onTap((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onDidChangeSelection((e) => this._onListSelection(e)));
  }
  dispose() {
    var _a2;
    this._disposables.dispose();
    (_a2 = this._status) == null ? void 0 : _a2.dispose();
    this.element.dispose();
  }
  showSuggestions(completionModel, selectionIndex, isFrozen, isAuto, cursorPosition) {
    this._cursorPosition = cursorPosition;
    if (this._completionModel !== completionModel) {
      this._completionModel = completionModel;
    }
    if (isFrozen && this._state !== 2 && this._state !== 0) {
      this._setState(4);
      return;
    }
    const visibleCount = this._completionModel.items.length;
    const isEmpty = visibleCount === 0;
    if (isEmpty) {
      this._setState(isAuto ? 0 : 2);
      this._completionModel = void 0;
      return;
    }
    try {
      this._list.splice(0, this._list.length, this._completionModel.items);
      this._setState(isFrozen ? 4 : 3);
      this._list.reveal(selectionIndex, 0);
      this._list.setFocus([selectionIndex]);
    } finally {
    }
    this._pendingLayout.value = runAtThisOrScheduleAtNextAnimationFrame(() => {
      this._pendingLayout.clear();
      this._layout(this.element.size);
    });
  }
  setLineContext(lineContext) {
    if (this._completionModel) {
      this._completionModel.lineContext = lineContext;
    }
  }
  _setState(state) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    if (this._state === state) {
      return;
    }
    this._state = state;
    this.element.domNode.classList.toggle("frozen", state === 4);
    this.element.domNode.classList.remove("message");
    switch (state) {
      case 0:
        hide(this._listElement);
        if (this._status) {
          hide((_a2 = this._status) == null ? void 0 : _a2.element);
        }
        (_b2 = this._status) == null ? void 0 : _b2.hide();
        this._showTimeout.cancel();
        this.element.domNode.classList.remove("visible");
        this._list.splice(0, this._list.length);
        this._cappedHeight = void 0;
        break;
      case 1:
        this.element.domNode.classList.add("message");
        hide(this._listElement);
        if (this._status) {
          hide((_c2 = this._status) == null ? void 0 : _c2.element);
        }
        this._show();
        break;
      case 2:
        this.element.domNode.classList.add("message");
        hide(this._listElement);
        if (this._status) {
          hide((_d2 = this._status) == null ? void 0 : _d2.element);
        }
        this._show();
        break;
      case 3:
        show(this._listElement);
        if (this._status) {
          show((_e2 = this._status) == null ? void 0 : _e2.element);
        }
        this._show();
        break;
      case 4:
        show(this._listElement);
        if (this._status) {
          show((_f2 = this._status) == null ? void 0 : _f2.element);
        }
        this._show();
        break;
      case 5:
        show(this._listElement);
        if (this._status) {
          show((_g2 = this._status) == null ? void 0 : _g2.element);
        }
        this._show();
        break;
    }
  }
  _show() {
    var _a2;
    (_a2 = this._status) == null ? void 0 : _a2.show();
    show(this.element.domNode);
    this._layout(this._persistedSize.restore());
    this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible");
      this._onDidShow.fire(this);
    }, 100);
  }
  hide() {
    this._pendingLayout.clear();
    this._setState(0);
    this._onDidHide.fire(this);
    hide(this.element.domNode);
    this.element.clearSashHoverState();
    const dim = this._persistedSize.restore();
    const minPersistedHeight = Math.ceil(this._getLayoutInfo().itemHeight * 4.3);
    if (dim && dim.height < minPersistedHeight) {
      this._persistedSize.store(dim.with(void 0, minPersistedHeight));
    }
  }
  _layout(size) {
    var _a2, _b2;
    if (!this._cursorPosition) {
      return;
    }
    const bodyBox = getClientArea(document.body);
    const info = this._getLayoutInfo();
    if (!size) {
      size = info.defaultSize;
    }
    let height = size.height;
    let width = size.width;
    if (this._status) {
      this._status.element.style.lineHeight = `${info.itemHeight}px`;
    }
    const maxWidth = bodyBox.width - info.borderHeight - 2 * info.horizontalPadding;
    if (width > maxWidth) {
      width = maxWidth;
    }
    const preferredWidth = this._completionModel ? this._completionModel.stats.pLabelLen * info.typicalHalfwidthCharacterWidth : width;
    const fullHeight = info.statusBarHeight + this._list.contentHeight + info.borderHeight;
    const minHeight = info.itemHeight + info.statusBarHeight;
    const editorBox = getDomNodePagePosition(this._container);
    const cursorBox = this._cursorPosition;
    const cursorBottom = editorBox.top + cursorBox.top + cursorBox.height;
    const maxHeightBelow = Math.min(bodyBox.height - cursorBottom - info.verticalPadding, fullHeight);
    const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;
    const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);
    let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);
    if (height === ((_a2 = this._cappedHeight) == null ? void 0 : _a2.capped)) {
      height = this._cappedHeight.wanted;
    }
    if (height < minHeight) {
      height = minHeight;
    }
    if (height > maxHeight) {
      height = maxHeight;
    }
    const forceRenderingAboveRequiredSpace = 150;
    if (height > maxHeightBelow || this._forceRenderingAbove && availableSpaceAbove > forceRenderingAboveRequiredSpace) {
      this._preference = 0;
      this.element.enableSashes(true, true, false, false);
      maxHeight = maxHeightAbove;
    } else {
      this._preference = 1;
      this.element.enableSashes(false, true, true, false);
      maxHeight = maxHeightBelow;
    }
    this.element.preferredSize = new Dimension(preferredWidth, info.defaultSize.height);
    this.element.maxSize = new Dimension(maxWidth, maxHeight);
    this.element.minSize = new Dimension(220, minHeight);
    this._cappedHeight = height === fullHeight ? { wanted: ((_b2 = this._cappedHeight) == null ? void 0 : _b2.wanted) ?? size.height, capped: height } : void 0;
    this.element.domNode.style.left = `${this._cursorPosition.left}px`;
    if (this._preference === 0) {
      this.element.domNode.style.top = `${this._cursorPosition.top - height - info.borderHeight}px`;
    } else {
      this.element.domNode.style.top = `${this._cursorPosition.top + this._cursorPosition.height}px`;
    }
    this._resize(width, height);
  }
  _resize(width, height) {
    const { width: maxWidth, height: maxHeight } = this.element.maxSize;
    width = Math.min(maxWidth, width);
    if (maxHeight) {
      height = Math.min(maxHeight, height);
    }
    const { statusBarHeight } = this._getLayoutInfo();
    this._list.layout(height - statusBarHeight, width);
    this._listElement.style.height = `${height - statusBarHeight}px`;
    this._listElement.style.width = `${width}px`;
    this._listElement.style.height = `${height}px`;
    this.element.layout(height, width);
  }
  _getLayoutInfo() {
    const fontInfo = {
      lineHeight: 20,
      typicalHalfwidthCharacterWidth: 10
    };
    const itemHeight = clamp(fontInfo.lineHeight, 8, 1e3);
    const statusBarHeight = 0;
    const borderWidth = 1;
    const borderHeight = 2 * borderWidth;
    return {
      itemHeight,
      statusBarHeight,
      borderWidth,
      borderHeight,
      typicalHalfwidthCharacterWidth: fontInfo.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new Dimension(430, statusBarHeight + 12 * itemHeight + borderHeight)
    };
  }
  _onListMouseDownOrTap(e) {
    if (typeof e.element === "undefined" || typeof e.index === "undefined") {
      return;
    }
    e.browserEvent.preventDefault();
    e.browserEvent.stopPropagation();
    this._select(e.element, e.index);
  }
  _onListSelection(e) {
    if (e.elements.length) {
      this._select(e.elements[0], e.indexes[0]);
    }
  }
  _select(item, index) {
    const completionModel = this._completionModel;
    if (completionModel) {
      this._onDidSelect.fire({ item, index, model: completionModel });
    }
  }
  selectNext() {
    this._list.focusNext(1, true);
    const focus = this._list.getFocus();
    if (focus.length > 0) {
      this._list.reveal(focus[0]);
    }
    return true;
  }
  selectNextPage() {
    this._list.focusNextPage();
    const focus = this._list.getFocus();
    if (focus.length > 0) {
      this._list.reveal(focus[0]);
    }
    return true;
  }
  selectPrevious() {
    this._list.focusPrevious(1, true);
    const focus = this._list.getFocus();
    if (focus.length > 0) {
      this._list.reveal(focus[0]);
    }
    return true;
  }
  selectPreviousPage() {
    this._list.focusPreviousPage();
    const focus = this._list.getFocus();
    if (focus.length > 0) {
      this._list.reveal(focus[0]);
    }
    return true;
  }
  getFocusedItem() {
    if (this._completionModel) {
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
    }
    return void 0;
  }
  forceRenderingAbove() {
    if (!this._forceRenderingAbove) {
      this._forceRenderingAbove = true;
      this._layout(this._persistedSize.restore());
    }
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = false;
  }
};
SimpleSuggestWidget = __decorate([
  __param(3, IInstantiationService)
], SimpleSuggestWidget);
const pwshTypeToIconMap = {
  0: Codicon.symbolText,
  1: Codicon.history,
  2: Codicon.symbolMethod,
  3: Codicon.symbolFile,
  4: Codicon.folder,
  5: Codicon.symbolProperty,
  6: Codicon.symbolMethod,
  7: Codicon.symbolVariable,
  8: Codicon.symbolValue,
  9: Codicon.symbolVariable,
  10: Codicon.symbolNamespace,
  11: Codicon.symbolInterface,
  12: Codicon.symbolKeyword,
  13: Codicon.symbolKeyword
};
let SuggestAddon = class SuggestAddon2 extends Disposable {
  constructor(_terminalSuggestWidgetVisibleContextKey, _instantiationService) {
    super();
    this._terminalSuggestWidgetVisibleContextKey = _terminalSuggestWidgetVisibleContextKey;
    this._instantiationService = _instantiationService;
    this._enableWidget = true;
    this._cursorIndexStart = 0;
    this._cursorIndexDelta = 0;
    this._onBell = new Emitter();
    this.onBell = this._onBell.event;
    this._onAcceptedCompletion = new Emitter();
    this.onAcceptedCompletion = this._onAcceptedCompletion.event;
    this._cachedBashAliases = /* @__PURE__ */ new Set();
    this._cachedBashBuiltins = /* @__PURE__ */ new Set();
    this._cachedBashCommands = /* @__PURE__ */ new Set();
    this._cachedBashKeywords = /* @__PURE__ */ new Set();
  }
  activate(xterm2) {
    this._terminal = xterm2;
    this._register(xterm2.parser.registerOscHandler(633, (data) => {
      return this._handleVSCodeSequence(data);
    }));
    this._register(xterm2.onData((e) => {
      this._handleTerminalInput(e);
    }));
  }
  setContainer(container) {
    this._container = container;
  }
  _handleVSCodeSequence(data) {
    if (!this._terminal) {
      return false;
    }
    const [command, ...args] = data.split(";");
    switch (command) {
      case "Completions":
        this._handleCompletionsSequence(this._terminal, data, command, args);
        return true;
      case "CompletionsBash":
        this._handleCompletionsBashSequence(this._terminal, data, command, args);
        return true;
      case "CompletionsBashFirstWord":
        return this._handleCompletionsBashFirstWordSequence(this._terminal, data, command, args);
    }
    return false;
  }
  _handleCompletionsSequence(terminal, data, command, args) {
    if (!terminal.element || !this._enableWidget) {
      return;
    }
    const replacementIndex = parseInt(args[0]);
    const replacementLength = parseInt(args[1]);
    this._cursorIndexStart = parseInt(args[2]);
    if (!args[3]) {
      this._onBell.fire();
      return;
    }
    let completionList = JSON.parse(data.slice(command.length + args[0].length + args[1].length + args[2].length + 4));
    if (!Array.isArray(completionList)) {
      completionList = [completionList];
    }
    const completions = completionList.map((e) => {
      return new SimpleCompletionItem({
        label: e.CompletionText,
        icon: pwshTypeToIconMap[e.ResultType],
        detail: e.ToolTip
      });
    });
    this._leadingLineContent = completions[0].completion.label.slice(0, replacementLength);
    this._cursorIndexDelta = 0;
    const model = new SimpleCompletionModel(completions, new LineContext(this._leadingLineContent, replacementIndex), replacementIndex, replacementLength);
    if (completions.length === 1) {
      const insertText = completions[0].completion.label.substring(replacementLength);
      if (insertText.length === 0) {
        this._onBell.fire();
        return;
      }
    }
    this._handleCompletionModel(model);
  }
  _handleCompletionsBashFirstWordSequence(terminal, data, command, args) {
    const type = args[0];
    const completionList = data.slice(command.length + type.length + 2).split(";");
    let set;
    switch (type) {
      case "alias":
        set = this._cachedBashAliases;
        break;
      case "builtin":
        set = this._cachedBashBuiltins;
        break;
      case "command":
        set = this._cachedBashCommands;
        break;
      case "keyword":
        set = this._cachedBashKeywords;
        break;
      default:
        return false;
    }
    set.clear();
    const distinctLabels = /* @__PURE__ */ new Set();
    for (const label of completionList) {
      distinctLabels.add(label);
    }
    for (const label of distinctLabels) {
      set.add(new SimpleCompletionItem({
        label,
        icon: Codicon.symbolString,
        detail: type
      }));
    }
    this._cachedFirstWord = void 0;
    return true;
  }
  _handleCompletionsBashSequence(terminal, data, command, args) {
    if (!terminal.element) {
      return;
    }
    let replacementIndex = parseInt(args[0]);
    const replacementLength = parseInt(args[1]);
    if (!args[2]) {
      this._onBell.fire();
      return;
    }
    const completionList = data.slice(command.length + args[0].length + args[1].length + args[2].length + 4).split(";");
    let completions;
    if (replacementIndex !== 100 && completionList.length > 0) {
      completions = completionList.map((label) => {
        return new SimpleCompletionItem({
          label,
          icon: Codicon.symbolProperty
        });
      });
    } else {
      replacementIndex = 0;
      if (!this._cachedFirstWord) {
        this._cachedFirstWord = [
          ...this._cachedBashAliases,
          ...this._cachedBashBuiltins,
          ...this._cachedBashCommands,
          ...this._cachedBashKeywords
        ];
        this._cachedFirstWord.sort((a, b) => {
          const aCode = a.completion.label.charCodeAt(0);
          const bCode = b.completion.label.charCodeAt(0);
          const isANonAlpha = aCode < 65 || aCode > 90 && aCode < 97 || aCode > 122 ? 1 : 0;
          const isBNonAlpha = bCode < 65 || bCode > 90 && bCode < 97 || bCode > 122 ? 1 : 0;
          if (isANonAlpha !== isBNonAlpha) {
            return isANonAlpha - isBNonAlpha;
          }
          return a.completion.label.localeCompare(b.completion.label);
        });
      }
      completions = this._cachedFirstWord;
    }
    if (completions.length === 0) {
      return;
    }
    this._leadingLineContent = completions[0].completion.label.slice(0, replacementLength);
    const model = new SimpleCompletionModel(completions, new LineContext(this._leadingLineContent, replacementIndex), replacementIndex, replacementLength);
    if (completions.length === 1) {
      const insertText = completions[0].completion.label.substring(replacementLength);
      if (insertText.length === 0) {
        this._onBell.fire();
        return;
      }
    }
    this._handleCompletionModel(model);
  }
  _handleCompletionModel(model) {
    var _a2;
    if (model.items.length === 0 || !((_a2 = this._terminal) == null ? void 0 : _a2.element)) {
      return;
    }
    if (model.items.length === 1) {
      this.acceptSelectedSuggestion({
        item: model.items[0],
        model
      });
      return;
    }
    const suggestWidget = this._ensureSuggestWidget(this._terminal);
    this._additionalInput = void 0;
    const dimensions = {
      width: this._terminal._core._renderService.dimensions.device.cell.width,
      height: this._terminal._core._renderService.dimensions.device.cell.height
    };
    if (!dimensions.width || !dimensions.height) {
      return;
    }
    const xtermBox = this._terminal.element.getBoundingClientRect();
    const panelElement = findParentWithClass(this._container, "panel").offsetParent;
    const panelBox = panelElement.getBoundingClientRect();
    suggestWidget.showSuggestions(model, 0, false, false, {
      left: xtermBox.left - panelBox.left + this._terminal.buffer.active.cursorX * dimensions.width,
      top: xtermBox.top - panelBox.top + this._terminal.buffer.active.cursorY * dimensions.height,
      height: dimensions.height
    });
    if (this._inputQueue) {
      const inputQueue = this._inputQueue;
      this._inputQueue = void 0;
      for (const data of inputQueue) {
        this._handleTerminalInput(data);
      }
    }
  }
  _ensureSuggestWidget(terminal) {
    this._terminalSuggestWidgetVisibleContextKey.set(true);
    if (!this._suggestWidget) {
      this._suggestWidget = this._register(this._instantiationService.createInstance(SimpleSuggestWidget, findParentWithClass(this._container, "panel"), this._instantiationService.createInstance(PersistedWidgetSize), {}));
      this._suggestWidget.list.style(getListStyles({
        listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
        listInactiveFocusOutline: activeContrastBorder
      }));
      this._suggestWidget.onDidSelect(async (e) => this.acceptSelectedSuggestion(e));
      this._suggestWidget.onDidHide(() => this._terminalSuggestWidgetVisibleContextKey.set(false));
      this._suggestWidget.onDidShow(() => this._terminalSuggestWidgetVisibleContextKey.set(true));
    }
    return this._suggestWidget;
  }
  selectPreviousSuggestion() {
    var _a2;
    (_a2 = this._suggestWidget) == null ? void 0 : _a2.selectPrevious();
  }
  selectPreviousPageSuggestion() {
    var _a2;
    (_a2 = this._suggestWidget) == null ? void 0 : _a2.selectPreviousPage();
  }
  selectNextSuggestion() {
    var _a2;
    (_a2 = this._suggestWidget) == null ? void 0 : _a2.selectNext();
  }
  selectNextPageSuggestion() {
    var _a2;
    (_a2 = this._suggestWidget) == null ? void 0 : _a2.selectNextPage();
  }
  acceptSelectedSuggestion(suggestion) {
    var _a2, _b2, _c2;
    if (!suggestion) {
      suggestion = (_a2 = this._suggestWidget) == null ? void 0 : _a2.getFocusedItem();
    }
    if (suggestion && this._leadingLineContent) {
      (_b2 = this._suggestWidget) == null ? void 0 : _b2.hide();
      this._onAcceptedCompletion.fire([
        "\x1B[D".repeat(Math.max(suggestion.model.replacementLength - this._cursorIndexStart + this._cursorIndexDelta, 0)),
        "\x1B[3~".repeat(((_c2 = this._additionalInput) == null ? void 0 : _c2.length) ?? 0),
        "".repeat(suggestion.model.replacementLength),
        suggestion.item.completion.label
      ].join(""));
      this._enableWidget = false;
      timeout(100).then((e) => this._enableWidget = true);
    }
  }
  hideSuggestWidget() {
    var _a2;
    (_a2 = this._suggestWidget) == null ? void 0 : _a2.hide();
  }
  handleNonXtermData(data) {
    this._handleTerminalInput(data);
  }
  _handleTerminalInput(data) {
    var _a2, _b2, _c2, _d2, _e2;
    if (!this._terminal || !this._enableWidget || !this._terminalSuggestWidgetVisibleContextKey.get()) {
      if (data === "-") {
        this._inputQueue = [];
      } else {
        (_a2 = this._inputQueue) == null ? void 0 : _a2.push(data);
      }
      return;
    }
    let handled = false;
    if (data === "") {
      if (this._additionalInput && this._additionalInput.length > 0 && this._cursorIndexDelta > 0) {
        handled = true;
        this._additionalInput = this._additionalInput.substring(0, this._cursorIndexDelta-- - 1) + this._additionalInput.substring(this._cursorIndexDelta);
      }
    }
    if (data === "\x1B[3~") {
      if (this._additionalInput && this._additionalInput.length > 0 && this._cursorIndexDelta < this._additionalInput.length - 1) {
        handled = true;
        this._additionalInput = this._additionalInput.substring(0, this._cursorIndexDelta) + this._additionalInput.substring(this._cursorIndexDelta + 1);
      }
    }
    if (data === "\x1B[D") {
      if (this._cursorIndexDelta > 0) {
        handled = true;
        this._cursorIndexDelta--;
      }
    }
    if (data === "\x1B[C") {
      handled = true;
      this._cursorIndexDelta += 1;
    }
    if (data.match(/^[a-z0-9]$/i)) {
      handled = true;
      if (this._additionalInput === void 0) {
        this._additionalInput = "";
      }
      this._additionalInput += data;
      this._cursorIndexDelta++;
    }
    if (handled) {
      if (this._terminalSuggestWidgetVisibleContextKey.get()) {
        (_c2 = this._suggestWidget) == null ? void 0 : _c2.setLineContext(new LineContext(
          this._leadingLineContent + (this._additionalInput ?? ""),
          ((_b2 = this._additionalInput) == null ? void 0 : _b2.length) ?? 0
        ));
      }
      if (((_d2 = this._suggestWidget._completionModel) == null ? void 0 : _d2.items.length) === 0) {
        this._additionalInput = void 0;
        this.hideSuggestWidget();
        return;
      }
      const dimensions = {
        width: this._terminal._core._renderService.dimensions.device.cell.width,
        height: this._terminal._core._renderService.dimensions.device.cell.height
      };
      if (!dimensions.width || !dimensions.height) {
        return;
      }
      const xtermBox = this._terminal.element.getBoundingClientRect();
      const panelElement = findParentWithClass(this._container, "panel").offsetParent;
      const panelBox = panelElement.getBoundingClientRect();
      (_e2 = this._suggestWidget) == null ? void 0 : _e2.showSuggestions(this._suggestWidget._completionModel, 0, false, false, {
        left: xtermBox.left - panelBox.left + this._terminal.buffer.active.cursorX * dimensions.width,
        top: xtermBox.top - panelBox.top + this._terminal.buffer.active.cursorY * dimensions.height,
        height: dimensions.height
      });
    } else {
      this._additionalInput = void 0;
      this.hideSuggestWidget();
    }
  }
};
SuggestAddon = __decorate([
  __param(1, IInstantiationService)
], SuggestAddon);
let PersistedWidgetSize = class PersistedWidgetSize2 {
  constructor(_storageService) {
    this._storageService = _storageService;
    this._key = "terminal.integrated.suggestSize";
  }
  restore() {
    const raw = this._storageService.get(this._key, 0) ?? "";
    try {
      const obj = JSON.parse(raw);
      if (Dimension.is(obj)) {
        return Dimension.lift(obj);
      }
    } catch {
    }
    return void 0;
  }
  store(size) {
    this._storageService.store(this._key, JSON.stringify(size), 0, 1);
  }
  reset() {
    this._storageService.remove(this._key, 0);
  }
};
PersistedWidgetSize = __decorate([
  __param(0, IStorageService)
], PersistedWidgetSize);
let CanvasAddon;
let ImageAddon;
let SearchAddon;
let SerializeAddon;
let Unicode11Addon;
let WebglAddon;
function getFullBufferLineAsString(lineIndex, buffer) {
  let line = buffer.getLine(lineIndex);
  if (!line) {
    return { lineData: void 0, lineIndex };
  }
  let lineData = line.translateToString(true);
  while (lineIndex > 0 && line.isWrapped) {
    line = buffer.getLine(--lineIndex);
    if (!line) {
      break;
    }
    lineData = line.translateToString(false) + lineData;
  }
  return { lineData, lineIndex };
}
let XtermTerminal = (_E = class extends DisposableStore {
  get findResult() {
    return this._lastFindResult;
  }
  get isStdinDisabled() {
    return !!this.raw.options.disableStdin;
  }
  get markTracker() {
    return this._markNavigationAddon;
  }
  get shellIntegration() {
    return this._shellIntegrationAddon;
  }
  get suggestController() {
    return this._suggestAddon;
  }
  get textureAtlas() {
    var _a2, _b2;
    const canvas = ((_a2 = this._webglAddon) == null ? void 0 : _a2.textureAtlas) || ((_b2 = this._canvasAddon) == null ? void 0 : _b2.textureAtlas);
    if (!canvas) {
      return void 0;
    }
    return createImageBitmap(canvas);
  }
  get isFocused() {
    var _a2;
    return !!((_a2 = this.raw.element) == null ? void 0 : _a2.contains(document.activeElement));
  }
  constructor(xtermCtor, _configHelper, cols, rows, _backgroundColorProvider, _capabilities, shellIntegrationNonce, _terminalSuggestWidgetVisibleContextKey, disableShellIntegrationReporting, _configurationService, _instantiationService, _logService, _notificationService, _storageService, _themeService, _telemetryService, _clipboardService, contextKeyService) {
    super();
    this._configHelper = _configHelper;
    this._backgroundColorProvider = _backgroundColorProvider;
    this._capabilities = _capabilities;
    this._terminalSuggestWidgetVisibleContextKey = _terminalSuggestWidgetVisibleContextKey;
    this._configurationService = _configurationService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._notificationService = _notificationService;
    this._storageService = _storageService;
    this._themeService = _themeService;
    this._telemetryService = _telemetryService;
    this._clipboardService = _clipboardService;
    this._attachedDisposables = this.add(new DisposableStore());
    this._onDidRequestRunCommand = new Emitter();
    this.onDidRequestRunCommand = this._onDidRequestRunCommand.event;
    this._onDidRequestFocus = new Emitter();
    this.onDidRequestFocus = this._onDidRequestFocus.event;
    this._onDidRequestSendText = new Emitter();
    this.onDidRequestSendText = this._onDidRequestSendText.event;
    this._onDidRequestFreePort = new Emitter();
    this.onDidRequestFreePort = this._onDidRequestFreePort.event;
    this._onDidChangeFindResults = new Emitter();
    this.onDidChangeFindResults = this._onDidChangeFindResults.event;
    this._onDidChangeSelection = new Emitter();
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this._onDidChangeFocus = new Emitter();
    this.onDidChangeFocus = this._onDidChangeFocus.event;
    this._onDidDispose = new Emitter();
    this.onDidDispose = this._onDidDispose.event;
    const font = this._configHelper.getFont(void 0, true);
    const config = this._configHelper.config;
    const editorOptions = this._configurationService.getValue("editor");
    this.raw = this.add(new xtermCtor({
      allowProposedApi: true,
      cols,
      rows,
      altClickMovesCursor: config.altClickMovesCursor && editorOptions.multiCursorModifier === "alt",
      scrollback: config.scrollback,
      theme: this._getXtermTheme(),
      drawBoldTextInBrightColors: config.drawBoldTextInBrightColors,
      fontFamily: font.fontFamily,
      fontWeight: config.fontWeight,
      fontWeightBold: config.fontWeightBold,
      fontSize: font.fontSize,
      letterSpacing: font.letterSpacing,
      lineHeight: font.lineHeight,
      logLevel: vscodeToXtermLogLevel(this._logService.getLevel()),
      logger: this._logService,
      minimumContrastRatio: config.minimumContrastRatio,
      tabStopWidth: config.tabStopWidth,
      cursorBlink: config.cursorBlinking,
      cursorStyle: config.cursorStyle === "line" ? "bar" : config.cursorStyle,
      cursorWidth: config.cursorWidth,
      macOptionIsMeta: config.macOptionIsMeta,
      macOptionClickForcesSelection: config.macOptionClickForcesSelection,
      rightClickSelectsWord: config.rightClickBehavior === "selectWord",
      fastScrollModifier: "alt",
      fastScrollSensitivity: config.fastScrollSensitivity,
      scrollSensitivity: config.mouseWheelScrollSensitivity,
      wordSeparator: config.wordSeparators,
      overviewRulerWidth: 10,
      smoothScrollDuration: config.smoothScrolling ? 125 : 0
    }));
    this._core = this.raw._core;
    this.add(this._configurationService.onDidChangeConfiguration(async (e) => {
      if (e.affectsConfiguration("terminal.integrated.gpuAcceleration")) {
        _E._suggestedRendererType = void 0;
      }
      if (e.affectsConfiguration("terminal.integrated") || e.affectsConfiguration("editor.fastScrollSensitivity") || e.affectsConfiguration("editor.mouseWheelScrollSensitivity") || e.affectsConfiguration("editor.multiCursorModifier")) {
        this.updateConfig();
      }
      if (e.affectsConfiguration("terminal.integrated.unicodeVersion")) {
        this._updateUnicodeVersion();
      }
    }));
    this.add(this._themeService.onDidColorThemeChange((theme) => this._updateTheme(theme)));
    this.add(this._logService.onDidChangeLogLevel((e) => this.raw.options.logLevel = vscodeToXtermLogLevel(e)));
    this.add(this.raw.onSelectionChange(() => {
      this._onDidChangeSelection.fire();
      if (this.isFocused) {
        this._anyFocusedTerminalHasSelection.set(this.raw.hasSelection());
      }
    }));
    this._updateUnicodeVersion();
    this._markNavigationAddon = this._instantiationService.createInstance(MarkNavigationAddon, _capabilities);
    this.raw.loadAddon(this._markNavigationAddon);
    this._decorationAddon = this._instantiationService.createInstance(DecorationAddon, this._capabilities);
    this._decorationAddon.onDidRequestRunCommand((e) => this._onDidRequestRunCommand.fire(e));
    this.raw.loadAddon(this._decorationAddon);
    this._shellIntegrationAddon = new ShellIntegrationAddon(
      shellIntegrationNonce,
      disableShellIntegrationReporting,
      this._telemetryService,
      this._logService
    );
    this.raw.loadAddon(this._shellIntegrationAddon);
    this._anyTerminalFocusContextKey = TerminalContextKeys.focusInAny.bindTo(contextKeyService);
    this._anyFocusedTerminalHasSelection = TerminalContextKeys.textSelectedInFocused.bindTo(contextKeyService);
    if (this._terminalSuggestWidgetVisibleContextKey) {
      this._suggestAddon = this._instantiationService.createInstance(SuggestAddon, this._terminalSuggestWidgetVisibleContextKey);
      this.raw.loadAddon(this._suggestAddon);
      this._suggestAddon.onAcceptedCompletion(async (text) => {
        this._onDidRequestFocus.fire();
        this._onDidRequestSendText.fire(text);
      });
    }
  }
  *getBufferReverseIterator() {
    for (let i = this.raw.buffer.active.length; i >= 0; i--) {
      const { lineData, lineIndex } = getFullBufferLineAsString(i, this.raw.buffer.active);
      if (lineData) {
        i = lineIndex;
        yield lineData;
      }
    }
  }
  async getContentsAsHtml() {
    if (!this._serializeAddon) {
      const Addon = await this._getSerializeAddonConstructor();
      this._serializeAddon = new Addon();
      this.raw.loadAddon(this._serializeAddon);
    }
    return this._serializeAddon.serializeAsHTML();
  }
  async getSelectionAsHtml(command) {
    var _a2, _b2;
    if (!this._serializeAddon) {
      const Addon = await this._getSerializeAddonConstructor();
      this._serializeAddon = new Addon();
      this.raw.loadAddon(this._serializeAddon);
    }
    if (command) {
      const length = (_a2 = command.getOutput()) == null ? void 0 : _a2.length;
      const row = (_b2 = command.marker) == null ? void 0 : _b2.line;
      if (!length || !row) {
        throw new Error(`No row ${row} or output length ${length} for command ${command}`);
      }
      this.raw.select(0, row + 1, length - Math.floor(length / this.raw.cols));
    }
    const result = this._serializeAddon.serializeAsHTML({ onlySelection: true });
    if (command) {
      this.raw.clearSelection();
    }
    return result;
  }
  attachToElement(container, partialOptions) {
    var _a2, _b2;
    const options = { enableGpu: true, ...partialOptions };
    if (!this._attached) {
      this.raw.open(container);
    }
    if (options.enableGpu) {
      if (this._shouldLoadWebgl()) {
        this._enableWebglRenderer();
      } else if (this._shouldLoadCanvas()) {
        this._enableCanvasRenderer();
      }
    }
    if (!this.raw.element || !this.raw.textarea) {
      throw new Error("xterm elements not set after open");
    }
    const ad = this._attachedDisposables;
    ad.clear();
    ad.add(addDisposableListener(this.raw.textarea, "focus", () => this._setFocused(true)));
    ad.add(addDisposableListener(this.raw.textarea, "blur", () => this._setFocused(false)));
    ad.add(addDisposableListener(this.raw.textarea, "focusout", () => this._setFocused(false)));
    (_a2 = this._suggestAddon) == null ? void 0 : _a2.setContainer(container);
    this._attached = { container, options };
    return (_b2 = this._attached) == null ? void 0 : _b2.container.querySelector(".xterm-screen");
  }
  _setFocused(isFocused) {
    this._onDidChangeFocus.fire(isFocused);
    this._anyTerminalFocusContextKey.set(isFocused);
    this._anyFocusedTerminalHasSelection.set(isFocused && this.raw.hasSelection());
  }
  write(data) {
    this.raw.write(data);
  }
  resize(columns, rows) {
    this.raw.resize(columns, rows);
  }
  updateConfig() {
    var _a2;
    const config = this._configHelper.config;
    this.raw.options.altClickMovesCursor = config.altClickMovesCursor;
    this._setCursorBlink(config.cursorBlinking);
    this._setCursorStyle(config.cursorStyle);
    this._setCursorWidth(config.cursorWidth);
    this.raw.options.scrollback = config.scrollback;
    this.raw.options.drawBoldTextInBrightColors = config.drawBoldTextInBrightColors;
    this.raw.options.minimumContrastRatio = config.minimumContrastRatio;
    this.raw.options.tabStopWidth = config.tabStopWidth;
    this.raw.options.fastScrollSensitivity = config.fastScrollSensitivity;
    this.raw.options.scrollSensitivity = config.mouseWheelScrollSensitivity;
    this.raw.options.macOptionIsMeta = config.macOptionIsMeta;
    const editorOptions = this._configurationService.getValue("editor");
    this.raw.options.altClickMovesCursor = config.altClickMovesCursor && editorOptions.multiCursorModifier === "alt";
    this.raw.options.macOptionClickForcesSelection = config.macOptionClickForcesSelection;
    this.raw.options.rightClickSelectsWord = config.rightClickBehavior === "selectWord";
    this.raw.options.wordSeparator = config.wordSeparators;
    this.raw.options.customGlyphs = config.customGlyphs;
    this.raw.options.smoothScrollDuration = config.smoothScrolling ? 125 : 0;
    if ((_a2 = this._attached) == null ? void 0 : _a2.options.enableGpu) {
      if (this._shouldLoadWebgl()) {
        this._enableWebglRenderer();
      } else {
        this._disposeOfWebglRenderer();
        if (this._shouldLoadCanvas()) {
          this._enableCanvasRenderer();
        } else {
          this._disposeOfCanvasRenderer();
        }
      }
    }
  }
  _shouldLoadWebgl() {
    return !isSafari && (this._configHelper.config.gpuAcceleration === "auto" && _E._suggestedRendererType === void 0) || this._configHelper.config.gpuAcceleration === "on";
  }
  _shouldLoadCanvas() {
    return this._configHelper.config.gpuAcceleration === "auto" && (_E._suggestedRendererType === void 0 || _E._suggestedRendererType === "canvas") || this._configHelper.config.gpuAcceleration === "canvas";
  }
  forceRedraw() {
    this.raw.clearTextureAtlas();
  }
  clearDecorations() {
    var _a2;
    (_a2 = this._decorationAddon) == null ? void 0 : _a2.clearDecorations();
  }
  forceRefresh() {
    var _a2;
    (_a2 = this._core.viewport) == null ? void 0 : _a2._innerRefresh();
  }
  forceUnpause() {
    var _a2;
    if (!!this._canvasAddon) {
      (_a2 = this._core._renderService) == null ? void 0 : _a2._handleIntersectionChange({ intersectionRatio: 1 });
      this.raw.refresh(0, this.raw.rows - 1);
    }
  }
  async findNext(term, searchOptions) {
    this._updateFindColors(searchOptions);
    return (await this._getSearchAddon()).findNext(term, searchOptions);
  }
  async findPrevious(term, searchOptions) {
    this._updateFindColors(searchOptions);
    return (await this._getSearchAddon()).findPrevious(term, searchOptions);
  }
  _updateFindColors(searchOptions) {
    const theme = this._themeService.getColorTheme();
    const terminalBackground = theme.getColor(TERMINAL_BACKGROUND_COLOR) || theme.getColor(PANEL_BACKGROUND);
    const findMatchBackground = theme.getColor(TERMINAL_FIND_MATCH_BACKGROUND_COLOR);
    const findMatchBorder = theme.getColor(TERMINAL_FIND_MATCH_BORDER_COLOR);
    const findMatchOverviewRuler = theme.getColor(TERMINAL_OVERVIEW_RULER_CURSOR_FOREGROUND_COLOR);
    const findMatchHighlightBackground = theme.getColor(TERMINAL_FIND_MATCH_HIGHLIGHT_BACKGROUND_COLOR);
    const findMatchHighlightBorder = theme.getColor(TERMINAL_FIND_MATCH_HIGHLIGHT_BORDER_COLOR);
    const findMatchHighlightOverviewRuler = theme.getColor(TERMINAL_OVERVIEW_RULER_FIND_MATCH_FOREGROUND_COLOR);
    searchOptions.decorations = {
      activeMatchBackground: findMatchBackground == null ? void 0 : findMatchBackground.toString(),
      activeMatchBorder: (findMatchBorder == null ? void 0 : findMatchBorder.toString()) || "transparent",
      activeMatchColorOverviewRuler: (findMatchOverviewRuler == null ? void 0 : findMatchOverviewRuler.toString()) || "transparent",
      matchBackground: terminalBackground ? findMatchHighlightBackground == null ? void 0 : findMatchHighlightBackground.blend(terminalBackground).toString() : void 0,
      matchBorder: (findMatchHighlightBorder == null ? void 0 : findMatchHighlightBorder.toString()) || "transparent",
      matchOverviewRuler: (findMatchHighlightOverviewRuler == null ? void 0 : findMatchHighlightOverviewRuler.toString()) || "transparent"
    };
  }
  _getSearchAddon() {
    if (!this._searchAddonPromise) {
      this._searchAddonPromise = this._getSearchAddonConstructor().then((AddonCtor) => {
        this._searchAddon = new AddonCtor({ highlightLimit: 1e3 });
        this.raw.loadAddon(this._searchAddon);
        this._searchAddon.onDidChangeResults((results) => {
          this._lastFindResult = results;
          this._onDidChangeFindResults.fire(results);
        });
        return this._searchAddon;
      });
    }
    return this._searchAddonPromise;
  }
  clearSearchDecorations() {
    var _a2;
    (_a2 = this._searchAddon) == null ? void 0 : _a2.clearDecorations();
  }
  clearActiveSearchDecoration() {
    var _a2;
    (_a2 = this._searchAddon) == null ? void 0 : _a2.clearActiveDecoration();
  }
  getFont() {
    return this._configHelper.getFont(this._core);
  }
  getLongestViewportWrappedLineLength() {
    let maxLineLength = 0;
    for (let i = this.raw.buffer.active.length - 1; i >= this.raw.buffer.active.viewportY; i--) {
      const lineInfo = this._getWrappedLineCount(i, this.raw.buffer.active);
      maxLineLength = Math.max(maxLineLength, lineInfo.lineCount * this.raw.cols - lineInfo.endSpaces || 0);
      i = lineInfo.currentIndex;
    }
    return maxLineLength;
  }
  _getWrappedLineCount(index, buffer) {
    var _a2;
    let line = buffer.getLine(index);
    if (!line) {
      throw new Error("Could not get line");
    }
    let currentIndex = index;
    let endSpaces = 0;
    for (let i = Math.min(line.length, this.raw.cols) - 1; i >= 0; i--) {
      if (!((_a2 = line == null ? void 0 : line.getCell(i)) == null ? void 0 : _a2.getChars())) {
        endSpaces++;
      } else {
        break;
      }
    }
    while ((line == null ? void 0 : line.isWrapped) && currentIndex > 0) {
      currentIndex--;
      line = buffer.getLine(currentIndex);
    }
    return { lineCount: index - currentIndex + 1, currentIndex, endSpaces };
  }
  scrollDownLine() {
    this.raw.scrollLines(1);
  }
  scrollDownPage() {
    this.raw.scrollPages(1);
  }
  scrollToBottom() {
    this.raw.scrollToBottom();
  }
  scrollUpLine() {
    this.raw.scrollLines(-1);
  }
  scrollUpPage() {
    this.raw.scrollPages(-1);
  }
  scrollToTop() {
    this.raw.scrollToTop();
  }
  clearBuffer() {
    var _a2, _b2;
    this.raw.clear();
    (_a2 = this._capabilities.get(2)) == null ? void 0 : _a2.handlePromptStart();
    (_b2 = this._capabilities.get(2)) == null ? void 0 : _b2.handleCommandStart();
  }
  hasSelection() {
    return this.raw.hasSelection();
  }
  clearSelection() {
    this.raw.clearSelection();
  }
  selectAll() {
    this.raw.focus();
    this.raw.selectAll();
  }
  focus() {
    this.raw.focus();
  }
  async copySelection(asHtml, command) {
    if (this.hasSelection() || asHtml && command) {
      if (asHtml) {
        let listener = function(e) {
          if (!e.clipboardData.types.includes("text/plain")) {
            e.clipboardData.setData("text/plain", (command == null ? void 0 : command.getOutput()) ?? "");
          }
          e.clipboardData.setData("text/html", textAsHtml);
          e.preventDefault();
        };
        const textAsHtml = await this.getSelectionAsHtml(command);
        document.addEventListener("copy", listener);
        document.execCommand("copy");
        document.removeEventListener("copy", listener);
      } else {
        await this._clipboardService.writeText(this.raw.getSelection());
      }
    } else {
      this._notificationService.warn(localize(
        "terminal.integrated.copySelection.noSelection",
        "The terminal has no selection to copy"
      ));
    }
  }
  _setCursorBlink(blink) {
    if (this.raw.options.cursorBlink !== blink) {
      this.raw.options.cursorBlink = blink;
      this.raw.refresh(0, this.raw.rows - 1);
    }
  }
  _setCursorStyle(style) {
    if (this.raw.options.cursorStyle !== style) {
      this.raw.options.cursorStyle = style === "line" ? "bar" : style;
    }
  }
  _setCursorWidth(width) {
    if (this.raw.options.cursorWidth !== width) {
      this.raw.options.cursorWidth = width;
    }
  }
  async _enableWebglRenderer() {
    if (!this.raw.element || this._webglAddon) {
      return;
    }
    const Addon = await this._getWebglAddonConstructor();
    this._webglAddon = new Addon();
    this._disposeOfCanvasRenderer();
    try {
      this.raw.loadAddon(this._webglAddon);
      this._logService.trace("Webgl was loaded");
      this._webglAddon.onContextLoss(() => {
        this._logService.info(`Webgl lost context, disposing of webgl renderer`);
        this._disposeOfWebglRenderer();
      });
      this._refreshImageAddon();
    } catch (e) {
      this._logService.warn(`Webgl could not be loaded. Falling back to the canvas renderer type.`, e);
      const neverMeasureRenderTime = this._storageService.getBoolean("terminal.integrated.neverMeasureRenderTime", -1, false);
      if (!neverMeasureRenderTime && this._configHelper.config.gpuAcceleration !== "off") {
        this._measureRenderTime();
      }
      _E._suggestedRendererType = "canvas";
      this._disposeOfWebglRenderer();
      this._enableCanvasRenderer();
    }
  }
  async _enableCanvasRenderer() {
    if (!this.raw.element || this._canvasAddon) {
      return;
    }
    const Addon = await this._getCanvasAddonConstructor();
    this._canvasAddon = new Addon();
    this._disposeOfWebglRenderer();
    try {
      this.raw.loadAddon(this._canvasAddon);
      this._logService.trace("Canvas renderer was loaded");
    } catch (e) {
      this._logService.warn(`Canvas renderer could not be loaded, falling back to dom renderer`, e);
      const neverMeasureRenderTime = this._storageService.getBoolean("terminal.integrated.neverMeasureRenderTime", -1, false);
      if (!neverMeasureRenderTime && this._configHelper.config.gpuAcceleration !== "off") {
        this._measureRenderTime();
      }
      _E._suggestedRendererType = "dom";
      this._disposeOfCanvasRenderer();
    }
    this._refreshImageAddon();
  }
  async _getCanvasAddonConstructor() {
    if (!CanvasAddon) {
      CanvasAddon = (await __vitePreload(() => import("./xterm-addon-canvas-cc1824a2.js").then((n2) => n2.x), true ? ["assets/xterm-addon-canvas-cc1824a2.js","assets/index-3bddf13b.js","assets/index-734057e1.css"] : void 0).then((module) => module.default ?? module)).CanvasAddon;
    }
    return CanvasAddon;
  }
  async _refreshImageAddon() {
    var _a2;
    if (this._configHelper.config.enableImages && (this._canvasAddon || this._webglAddon)) {
      if (!this._imageAddon) {
        const AddonCtor = await this._getImageAddonConstructor();
        this._imageAddon = new AddonCtor();
        this.raw.loadAddon(this._imageAddon);
      }
    } else {
      try {
        (_a2 = this._imageAddon) == null ? void 0 : _a2.dispose();
      } catch {
      }
      this._imageAddon = void 0;
    }
  }
  async _getImageAddonConstructor() {
    if (!ImageAddon) {
      ImageAddon = (await __vitePreload(() => import("./xterm-addon-image-a01d8b9d.js").then((n2) => n2.x), true ? ["assets/xterm-addon-image-a01d8b9d.js","assets/index-3bddf13b.js","assets/index-734057e1.css"] : void 0).then((module) => module.default ?? module)).ImageAddon;
    }
    return ImageAddon;
  }
  async _getSearchAddonConstructor() {
    if (!SearchAddon) {
      SearchAddon = (await __vitePreload(() => import("./xterm-addon-search-67010b19.js").then((n2) => n2.x), true ? ["assets/xterm-addon-search-67010b19.js","assets/index-3bddf13b.js","assets/index-734057e1.css"] : void 0).then((module) => module.default ?? module)).SearchAddon;
    }
    return SearchAddon;
  }
  async _getUnicode11Constructor() {
    if (!Unicode11Addon) {
      Unicode11Addon = (await __vitePreload(() => import("./xterm-addon-unicode11-7c01775e.js").then((n2) => n2.x), true ? ["assets/xterm-addon-unicode11-7c01775e.js","assets/index-3bddf13b.js","assets/index-734057e1.css"] : void 0).then((module) => module.default ?? module)).Unicode11Addon;
    }
    return Unicode11Addon;
  }
  async _getWebglAddonConstructor() {
    if (!WebglAddon) {
      WebglAddon = (await __vitePreload(() => import("./xterm-addon-webgl-d2b3915f.js").then((n2) => n2.x), true ? ["assets/xterm-addon-webgl-d2b3915f.js","assets/index-3bddf13b.js","assets/index-734057e1.css"] : void 0).then((module) => module.default ?? module)).WebglAddon;
    }
    return WebglAddon;
  }
  async _getSerializeAddonConstructor() {
    if (!SerializeAddon) {
      SerializeAddon = (await __vitePreload(() => import("./xterm-addon-serialize-8f905667.js").then((n2) => n2.x), true ? ["assets/xterm-addon-serialize-8f905667.js","assets/index-3bddf13b.js","assets/index-734057e1.css"] : void 0).then((module) => module.default ?? module)).SerializeAddon;
    }
    return SerializeAddon;
  }
  _disposeOfCanvasRenderer() {
    var _a2;
    try {
      (_a2 = this._canvasAddon) == null ? void 0 : _a2.dispose();
    } catch {
    }
    this._canvasAddon = void 0;
    this._refreshImageAddon();
  }
  _disposeOfWebglRenderer() {
    var _a2;
    try {
      (_a2 = this._webglAddon) == null ? void 0 : _a2.dispose();
    } catch {
    }
    this._webglAddon = void 0;
    this._refreshImageAddon();
  }
  async _measureRenderTime() {
    var _a2;
    const frameTimes = [];
    if (!((_a2 = this._core._renderService) == null ? void 0 : _a2._renderer._renderLayers)) {
      return;
    }
    const textRenderLayer = this._core._renderService._renderer._renderLayers[0];
    const originalOnGridChanged = textRenderLayer == null ? void 0 : textRenderLayer.onGridChanged;
    const evaluateCanvasRenderer = () => {
      frameTimes.shift();
      const medianTime = frameTimes.sort((a, b) => a - b)[Math.floor(frameTimes.length / 2)];
      if (medianTime > 50) {
        if (this._configHelper.config.gpuAcceleration === "auto") {
          _E._suggestedRendererType = "dom";
          this.updateConfig();
        } else {
          const promptChoices = [
            {
              label: localize("yes", "Yes"),
              run: () => this._configurationService.updateValue("terminal.integrated.gpuAcceleration", "off", 2)
            },
            {
              label: localize("no", "No"),
              run: () => {
              }
            },
            {
              label: localize("dontShowAgain", "Don't Show Again"),
              isSecondary: true,
              run: () => this._storageService.store("terminal.integrated.neverMeasureRenderTime", true, -1, 1)
            }
          ];
          this._notificationService.prompt(Severity.Warning, localize(
            "terminal.slowRendering",
            "Terminal GPU acceleration appears to be slow on your computer. Would you like to switch to disable it which may improve performance? [Read more about terminal settings](https://code.visualstudio.com/docs/editor/integrated-terminal#_changing-how-the-terminal-is-rendered)."
          ), promptChoices);
        }
      }
    };
    textRenderLayer.onGridChanged = (terminal, firstRow, lastRow) => {
      const startTime = performance.now();
      originalOnGridChanged.call(textRenderLayer, terminal, firstRow, lastRow);
      frameTimes.push(performance.now() - startTime);
      if (frameTimes.length === 20) {
        evaluateCanvasRenderer();
        textRenderLayer.onGridChanged = originalOnGridChanged;
      }
    };
  }
  _getXtermTheme(theme) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2;
    if (!theme) {
      theme = this._themeService.getColorTheme();
    }
    const foregroundColor = theme.getColor(TERMINAL_FOREGROUND_COLOR);
    const backgroundColor = this._backgroundColorProvider.getBackgroundColor(theme);
    const cursorColor = theme.getColor(TERMINAL_CURSOR_FOREGROUND_COLOR) || foregroundColor;
    const cursorAccentColor = theme.getColor(TERMINAL_CURSOR_BACKGROUND_COLOR) || backgroundColor;
    const selectionBackgroundColor = theme.getColor(TERMINAL_SELECTION_BACKGROUND_COLOR);
    const selectionInactiveBackgroundColor = theme.getColor(TERMINAL_INACTIVE_SELECTION_BACKGROUND_COLOR);
    const selectionForegroundColor = theme.getColor(TERMINAL_SELECTION_FOREGROUND_COLOR) || void 0;
    return {
      background: backgroundColor == null ? void 0 : backgroundColor.toString(),
      foreground: foregroundColor == null ? void 0 : foregroundColor.toString(),
      cursor: cursorColor == null ? void 0 : cursorColor.toString(),
      cursorAccent: cursorAccentColor == null ? void 0 : cursorAccentColor.toString(),
      selectionBackground: selectionBackgroundColor == null ? void 0 : selectionBackgroundColor.toString(),
      selectionInactiveBackground: selectionInactiveBackgroundColor == null ? void 0 : selectionInactiveBackgroundColor.toString(),
      selectionForeground: selectionForegroundColor == null ? void 0 : selectionForegroundColor.toString(),
      black: (_a2 = theme.getColor(ansiColorIdentifiers[0])) == null ? void 0 : _a2.toString(),
      red: (_b2 = theme.getColor(ansiColorIdentifiers[1])) == null ? void 0 : _b2.toString(),
      green: (_c2 = theme.getColor(ansiColorIdentifiers[2])) == null ? void 0 : _c2.toString(),
      yellow: (_d2 = theme.getColor(ansiColorIdentifiers[3])) == null ? void 0 : _d2.toString(),
      blue: (_e2 = theme.getColor(ansiColorIdentifiers[4])) == null ? void 0 : _e2.toString(),
      magenta: (_f2 = theme.getColor(ansiColorIdentifiers[5])) == null ? void 0 : _f2.toString(),
      cyan: (_g2 = theme.getColor(ansiColorIdentifiers[6])) == null ? void 0 : _g2.toString(),
      white: (_h2 = theme.getColor(ansiColorIdentifiers[7])) == null ? void 0 : _h2.toString(),
      brightBlack: (_i2 = theme.getColor(ansiColorIdentifiers[8])) == null ? void 0 : _i2.toString(),
      brightRed: (_j2 = theme.getColor(ansiColorIdentifiers[9])) == null ? void 0 : _j2.toString(),
      brightGreen: (_k2 = theme.getColor(ansiColorIdentifiers[10])) == null ? void 0 : _k2.toString(),
      brightYellow: (_l2 = theme.getColor(ansiColorIdentifiers[11])) == null ? void 0 : _l2.toString(),
      brightBlue: (_m2 = theme.getColor(ansiColorIdentifiers[12])) == null ? void 0 : _m2.toString(),
      brightMagenta: (_n2 = theme.getColor(ansiColorIdentifiers[13])) == null ? void 0 : _n2.toString(),
      brightCyan: (_o2 = theme.getColor(ansiColorIdentifiers[14])) == null ? void 0 : _o2.toString(),
      brightWhite: (_p2 = theme.getColor(ansiColorIdentifiers[15])) == null ? void 0 : _p2.toString()
    };
  }
  _updateTheme(theme) {
    this.raw.options.theme = this._getXtermTheme(theme);
  }
  refresh() {
    this._updateTheme();
    this._decorationAddon.refreshLayouts();
  }
  async _updateUnicodeVersion() {
    if (!this._unicode11Addon && this._configHelper.config.unicodeVersion === "11") {
      const Addon = await this._getUnicode11Constructor();
      this._unicode11Addon = new Addon();
      this.raw.loadAddon(this._unicode11Addon);
    }
    if (this.raw.unicode.activeVersion !== this._configHelper.config.unicodeVersion) {
      this.raw.unicode.activeVersion = this._configHelper.config.unicodeVersion;
    }
  }
  _writeText(data) {
    this.raw.write(data);
  }
  dispose() {
    this._anyTerminalFocusContextKey.reset();
    this._anyFocusedTerminalHasSelection.reset();
    this._onDidDispose.fire();
    super.dispose();
  }
}, _E._suggestedRendererType = void 0, _E);
XtermTerminal.__decorator = __decorate([
  debounce(100)
], XtermTerminal.prototype, "_refreshImageAddon", null);
XtermTerminal = __decorate([
  __param(9, IConfigurationService),
  __param(10, IInstantiationService),
  __param(11, ITerminalLogService),
  __param(12, INotificationService),
  __param(13, IStorageService),
  __param(14, IThemeService),
  __param(15, ITelemetryService),
  __param(16, IClipboardService),
  __param(17, IContextKeyService)
], XtermTerminal);
function getXtermScaledDimensions(font, width, height) {
  if (!font.charWidth || !font.charHeight) {
    return null;
  }
  const scaledWidthAvailable = width * window.devicePixelRatio;
  const scaledCharWidth = font.charWidth * window.devicePixelRatio + font.letterSpacing;
  const cols = Math.max(Math.floor(scaledWidthAvailable / scaledCharWidth), 1);
  const scaledHeightAvailable = height * window.devicePixelRatio;
  const scaledCharHeight = Math.ceil(font.charHeight * window.devicePixelRatio);
  const scaledLineHeight = Math.floor(scaledCharHeight * font.lineHeight);
  const rows = Math.max(Math.floor(scaledHeightAvailable / scaledLineHeight), 1);
  return { rows, cols };
}
function vscodeToXtermLogLevel(logLevel) {
  switch (logLevel) {
    case LogLevel.Trace:
    case LogLevel.Debug:
      return "debug";
    case LogLevel.Info:
      return "info";
    case LogLevel.Warning:
      return "warn";
    case LogLevel.Error:
      return "error";
    default:
      return "off";
  }
}
function registerTerminalContribution(id, ctor) {
  TerminalContributionRegistry.INSTANCE.registerTerminalContribution(id, ctor);
}
var TerminalExtensionsRegistry;
(function(TerminalExtensionsRegistry2) {
  function getTerminalContributions() {
    return TerminalContributionRegistry.INSTANCE.getTerminalContributions();
  }
  TerminalExtensionsRegistry2.getTerminalContributions = getTerminalContributions;
})(TerminalExtensionsRegistry || (TerminalExtensionsRegistry = {}));
const _TerminalContributionRegistry = class _TerminalContributionRegistry {
  constructor() {
    this._terminalContributions = [];
  }
  registerTerminalContribution(id, ctor) {
    this._terminalContributions.push({ id, ctor });
  }
  getTerminalContributions() {
    return this._terminalContributions.slice(0);
  }
};
_TerminalContributionRegistry.INSTANCE = new _TerminalContributionRegistry();
let TerminalContributionRegistry = _TerminalContributionRegistry;
Registry.add("terminal.contributions", TerminalContributionRegistry.INSTANCE);
class NaiveCwdDetectionCapability {
  constructor(_process) {
    this._process = _process;
    this.type = 1;
    this._cwd = "";
    this._onDidChangeCwd = new Emitter();
    this.onDidChangeCwd = this._onDidChangeCwd.event;
  }
  async getCwd() {
    if (!this._process) {
      return Promise.resolve("");
    }
    const newCwd = await this._process.getCwd();
    if (newCwd !== this._cwd) {
      this._onDidChangeCwd.fire(newCwd);
    }
    this._cwd = newCwd;
    return this._cwd;
  }
}
class TerminalRecorder {
  constructor(cols, rows) {
    this._totalDataLength = 0;
    this._entries = [{ cols, rows, data: [] }];
  }
  handleResize(cols, rows) {
    if (this._entries.length > 0) {
      const lastEntry = this._entries[this._entries.length - 1];
      if (lastEntry.data.length === 0) {
        this._entries.pop();
      }
    }
    if (this._entries.length > 0) {
      const lastEntry = this._entries[this._entries.length - 1];
      if (lastEntry.cols === cols && lastEntry.rows === rows) {
        return;
      }
      if (lastEntry.cols === 0 && lastEntry.rows === 0) {
        lastEntry.cols = cols;
        lastEntry.rows = rows;
        return;
      }
    }
    this._entries.push({ cols, rows, data: [] });
  }
  handleData(data) {
    const lastEntry = this._entries[this._entries.length - 1];
    lastEntry.data.push(data);
    this._totalDataLength += data.length;
    while (this._totalDataLength > 1048576) {
      const firstEntry = this._entries[0];
      const remainingToDelete = this._totalDataLength - 1048576;
      if (remainingToDelete >= firstEntry.data[0].length) {
        this._totalDataLength -= firstEntry.data[0].length;
        firstEntry.data.shift();
        if (firstEntry.data.length === 0) {
          this._entries.shift();
        }
      } else {
        firstEntry.data[0] = firstEntry.data[0].substr(remainingToDelete);
        this._totalDataLength -= remainingToDelete;
      }
    }
  }
  generateReplayEventSync() {
    this._entries.forEach((entry) => {
      if (entry.data.length > 0) {
        entry.data = [entry.data.join("")];
      }
    });
    return {
      events: this._entries.map(
        (entry) => ({ cols: entry.cols, rows: entry.rows, data: entry.data[0] ?? "" })
      ),
      commands: {
        isWindowsPty: false,
        commands: []
      }
    };
  }
  async generateReplayEvent() {
    return this.generateReplayEventSync();
  }
}
let EnvironmentVariableInfoStale = class EnvironmentVariableInfoStale2 {
  constructor(_diff, _terminalId, _collection, _terminalService, _extensionService) {
    this._diff = _diff;
    this._terminalId = _terminalId;
    this._collection = _collection;
    this._terminalService = _terminalService;
    this._extensionService = _extensionService;
    this.requiresAction = true;
  }
  _getInfo(scope) {
    const extSet = /* @__PURE__ */ new Set();
    addExtensionIdentifiers(extSet, this._diff.added.values());
    addExtensionIdentifiers(extSet, this._diff.removed.values());
    addExtensionIdentifiers(extSet, this._diff.changed.values());
    let message = localize(
      "extensionEnvironmentContributionInfoStale",
      "The following extensions want to relaunch the terminal to contribute to its environment:"
    );
    message += getMergedDescription(this._collection, scope, this._extensionService, extSet);
    return message;
  }
  _getActions() {
    return [{
      label: localize("relaunchTerminalLabel", "Relaunch terminal"),
      run: () => {
        var _a2;
        return (_a2 = this._terminalService.getInstanceFromId(this._terminalId)) == null ? void 0 : _a2.relaunch();
      },
      commandId: "workbench.action.terminal.relaunch"
    }];
  }
  getStatus(scope) {
    return {
      id: "relaunch-needed",
      severity: Severity$1.Warning,
      icon: Codicon.warning,
      tooltip: this._getInfo(scope),
      hoverActions: this._getActions()
    };
  }
};
EnvironmentVariableInfoStale = __decorate([
  __param(3, ITerminalService),
  __param(4, IExtensionService)
], EnvironmentVariableInfoStale);
let EnvironmentVariableInfoChangesActive = class EnvironmentVariableInfoChangesActive2 {
  constructor(_collection, _commandService, _extensionService) {
    this._collection = _collection;
    this._commandService = _commandService;
    this._extensionService = _extensionService;
    this.requiresAction = false;
  }
  _getInfo(scope) {
    const extSet = /* @__PURE__ */ new Set();
    addExtensionIdentifiers(extSet, this._collection.getVariableMap(scope).values());
    let message = localize(
      "extensionEnvironmentContributionInfoActive",
      "The following extensions have contributed to this terminal's environment:"
    );
    message += getMergedDescription(this._collection, scope, this._extensionService, extSet);
    return message;
  }
  _getActions(scope) {
    return [{
      label: localize("showEnvironmentContributions", "Show environment contributions"),
      run: () => this._commandService.executeCommand("workbench.action.terminal.showEnvironmentContributions", scope),
      commandId: "workbench.action.terminal.showEnvironmentContributions"
    }];
  }
  getStatus(scope) {
    return {
      id: "env-var-info-changes-active",
      severity: Severity$1.Info,
      tooltip: this._getInfo(scope),
      hoverActions: this._getActions(scope)
    };
  }
};
EnvironmentVariableInfoChangesActive = __decorate([
  __param(1, ICommandService),
  __param(2, IExtensionService)
], EnvironmentVariableInfoChangesActive);
function getMergedDescription(collection, scope, extensionService, extSet) {
  const message = ["\n"];
  const globalDescriptions = collection.getDescriptionMap(void 0);
  const workspaceDescriptions = collection.getDescriptionMap(scope);
  for (const ext of extSet) {
    const globalDescription = globalDescriptions.get(ext);
    if (globalDescription) {
      message.push(`
- \`${getExtensionName(ext, extensionService)}\``);
      message.push(`: ${globalDescription}`);
    }
    const workspaceDescription = workspaceDescriptions.get(ext);
    if (workspaceDescription) {
      const workspaceSuffix = globalDescription ? ` (${localize("ScopedEnvironmentContributionInfo", "workspace")})` : "";
      message.push(`
- \`${getExtensionName(ext, extensionService)}${workspaceSuffix}\``);
      message.push(`: ${workspaceDescription}`);
    }
    if (!globalDescription && !workspaceDescription) {
      message.push(`
- \`${getExtensionName(ext, extensionService)}\``);
    }
  }
  return message.join("");
}
function addExtensionIdentifiers(extSet, diff) {
  for (const mutators of diff) {
    for (const mutator of mutators) {
      extSet.add(mutator.extensionIdentifier);
    }
  }
}
function getExtensionName(id, extensionService) {
  var _a2;
  return ((_a2 = extensionService.extensions.find((e) => e.id === id)) == null ? void 0 : _a2.displayName) || id;
}
var EnvironmentVariableMutatorType;
(function(EnvironmentVariableMutatorType2) {
  EnvironmentVariableMutatorType2[EnvironmentVariableMutatorType2["Replace"] = 1] = "Replace";
  EnvironmentVariableMutatorType2[EnvironmentVariableMutatorType2["Append"] = 2] = "Append";
  EnvironmentVariableMutatorType2[EnvironmentVariableMutatorType2["Prepend"] = 3] = "Prepend";
})(EnvironmentVariableMutatorType || (EnvironmentVariableMutatorType = {}));
const mutatorTypeToLabelMap = /* @__PURE__ */ new Map([
  [EnvironmentVariableMutatorType.Append, "APPEND"],
  [EnvironmentVariableMutatorType.Prepend, "PREPEND"],
  [EnvironmentVariableMutatorType.Replace, "REPLACE"]
]);
class MergedEnvironmentVariableCollection {
  constructor(collections) {
    this.collections = collections;
    this.map = /* @__PURE__ */ new Map();
    this.descriptionMap = /* @__PURE__ */ new Map();
    collections.forEach((collection, extensionIdentifier) => {
      this.populateDescriptionMap(collection, extensionIdentifier);
      const it = collection.map.entries();
      let next = it.next();
      while (!next.done) {
        const mutator = next.value[1];
        const key = next.value[0];
        let entry = this.map.get(key);
        if (!entry) {
          entry = [];
          this.map.set(key, entry);
        }
        if (entry.length > 0 && entry[0].type === EnvironmentVariableMutatorType.Replace) {
          next = it.next();
          continue;
        }
        const extensionMutator = {
          extensionIdentifier,
          value: mutator.value,
          type: mutator.type,
          scope: mutator.scope,
          variable: mutator.variable,
          options: mutator.options
        };
        if (!extensionMutator.scope) {
          delete extensionMutator.scope;
        }
        entry.unshift(extensionMutator);
        next = it.next();
      }
    });
  }
  async applyToProcessEnvironment(env2, scope, variableResolver) {
    var _a2, _b2;
    let lowerToActualVariableNames;
    if (isWindows) {
      lowerToActualVariableNames = {};
      Object.keys(env2).forEach((e) => lowerToActualVariableNames[e.toLowerCase()] = e);
    }
    for (const [variable, mutators] of this.getVariableMap(scope)) {
      const actualVariable = isWindows ? lowerToActualVariableNames[variable.toLowerCase()] || variable : variable;
      for (const mutator of mutators) {
        const value = variableResolver ? await variableResolver(mutator.value) : mutator.value;
        if (((_a2 = mutator.options) == null ? void 0 : _a2.applyAtProcessCreation) ?? true) {
          switch (mutator.type) {
            case EnvironmentVariableMutatorType.Append:
              env2[actualVariable] = (env2[actualVariable] || "") + value;
              break;
            case EnvironmentVariableMutatorType.Prepend:
              env2[actualVariable] = value + (env2[actualVariable] || "");
              break;
            case EnvironmentVariableMutatorType.Replace:
              env2[actualVariable] = value;
              break;
          }
        }
        if (((_b2 = mutator.options) == null ? void 0 : _b2.applyAtShellIntegration) ?? false) {
          const key = `VSCODE_ENV_${mutatorTypeToLabelMap.get(mutator.type)}`;
          env2[key] = (env2[key] ? env2[key] + ":" : "") + variable + "=" + this._encodeColons(value);
        }
      }
    }
  }
  _encodeColons(value) {
    return value.replaceAll(":", "\\x3a");
  }
  diff(other, scope) {
    const added = /* @__PURE__ */ new Map();
    const changed = /* @__PURE__ */ new Map();
    const removed = /* @__PURE__ */ new Map();
    other.getVariableMap(scope).forEach((otherMutators, variable) => {
      const currentMutators = this.getVariableMap(scope).get(variable);
      const result = getMissingMutatorsFromArray(otherMutators, currentMutators);
      if (result) {
        added.set(variable, result);
      }
    });
    this.getVariableMap(scope).forEach((currentMutators, variable) => {
      const otherMutators = other.getVariableMap(scope).get(variable);
      const result = getMissingMutatorsFromArray(currentMutators, otherMutators);
      if (result) {
        removed.set(variable, result);
      }
    });
    this.getVariableMap(scope).forEach((currentMutators, variable) => {
      const otherMutators = other.getVariableMap(scope).get(variable);
      const result = getChangedMutatorsFromArray(currentMutators, otherMutators);
      if (result) {
        changed.set(variable, result);
      }
    });
    if (added.size === 0 && changed.size === 0 && removed.size === 0) {
      return void 0;
    }
    return { added, changed, removed };
  }
  getVariableMap(scope) {
    const result = /* @__PURE__ */ new Map();
    for (const mutators of this.map.values()) {
      const filteredMutators = mutators.filter((m) => filterScope(m, scope));
      if (filteredMutators.length > 0) {
        result.set(filteredMutators[0].variable, filteredMutators);
      }
    }
    return result;
  }
  getDescriptionMap(scope) {
    const result = /* @__PURE__ */ new Map();
    for (const mutators of this.descriptionMap.values()) {
      const filteredMutators = mutators.filter((m) => filterScope(m, scope, true));
      for (const mutator of filteredMutators) {
        result.set(mutator.extensionIdentifier, mutator.description);
      }
    }
    return result;
  }
  populateDescriptionMap(collection, extensionIdentifier) {
    if (!collection.descriptionMap) {
      return;
    }
    const it = collection.descriptionMap.entries();
    let next = it.next();
    while (!next.done) {
      const mutator = next.value[1];
      const key = next.value[0];
      let entry = this.descriptionMap.get(key);
      if (!entry) {
        entry = [];
        this.descriptionMap.set(key, entry);
      }
      const extensionMutator = {
        extensionIdentifier,
        scope: mutator.scope,
        description: mutator.description
      };
      if (!extensionMutator.scope) {
        delete extensionMutator.scope;
      }
      entry.push(extensionMutator);
      next = it.next();
    }
  }
}
function filterScope(mutator, scope, strictFilter = false) {
  if (!mutator.scope) {
    if (strictFilter) {
      return scope === mutator.scope;
    }
    return true;
  }
  if (mutator.scope.workspaceFolder && (scope == null ? void 0 : scope.workspaceFolder) && mutator.scope.workspaceFolder.index === scope.workspaceFolder.index) {
    return true;
  }
  return false;
}
function getMissingMutatorsFromArray(current, other) {
  if (!other) {
    return current;
  }
  const otherMutatorExtensions = /* @__PURE__ */ new Set();
  other.forEach((m) => otherMutatorExtensions.add(m.extensionIdentifier));
  const result = [];
  current.forEach((mutator) => {
    if (!otherMutatorExtensions.has(mutator.extensionIdentifier)) {
      result.push(mutator);
    }
  });
  return result.length === 0 ? void 0 : result;
}
function getChangedMutatorsFromArray(current, other) {
  if (!other) {
    return void 0;
  }
  const otherMutatorExtensions = /* @__PURE__ */ new Map();
  other.forEach((m) => otherMutatorExtensions.set(m.extensionIdentifier, m));
  const result = [];
  current.forEach((mutator) => {
    var _a2, _b2, _c2, _d2;
    const otherMutator = otherMutatorExtensions.get(mutator.extensionIdentifier);
    if (otherMutator && (mutator.type !== otherMutator.type || mutator.value !== otherMutator.value || ((_b2 = (_a2 = mutator.scope) == null ? void 0 : _a2.workspaceFolder) == null ? void 0 : _b2.index) !== ((_d2 = (_c2 = otherMutator.scope) == null ? void 0 : _c2.workspaceFolder) == null ? void 0 : _d2.index))) {
      result.push(otherMutator);
    }
  });
  return result.length === 0 ? void 0 : result;
}
function sanitizeProcessEnvironment(env2, ...preserve) {
  const set = preserve.reduce((set2, key) => {
    set2[key] = true;
    return set2;
  }, {});
  const keysToRemove = [
    /^ELECTRON_.+$/,
    /^VSCODE_(?!(PORTABLE|SHELL_LOGIN|ENV_REPLACE|ENV_APPEND|ENV_PREPEND)).+$/,
    /^SNAP(|_.*)$/,
    /^GDK_PIXBUF_.+$/
  ];
  const envKeys = Object.keys(env2);
  envKeys.filter((key) => !set[key]).forEach((envKey) => {
    for (let i = 0; i < keysToRemove.length; i++) {
      if (envKey.search(keysToRemove[i]) !== -1) {
        delete env2[envKey];
        break;
      }
    }
  });
}
function mergeEnvironments(parent, other) {
  if (!other) {
    return;
  }
  if (isWindows) {
    for (const configKey in other) {
      let actualKey = configKey;
      for (const envKey in parent) {
        if (configKey.toLowerCase() === envKey.toLowerCase()) {
          actualKey = envKey;
          break;
        }
      }
      const value = other[configKey];
      if (value !== void 0) {
        _mergeEnvironmentValue(parent, actualKey, value);
      }
    }
  } else {
    Object.keys(other).forEach((key) => {
      const value = other[key];
      if (value !== void 0) {
        _mergeEnvironmentValue(parent, key, value);
      }
    });
  }
}
function _mergeEnvironmentValue(env2, key, value) {
  if (typeof value === "string") {
    env2[key] = value;
  } else {
    delete env2[key];
  }
}
function addTerminalEnvironmentKeys(env2, version, locale, detectLocale) {
  env2["TERM_PROGRAM"] = "vscode";
  if (version) {
    env2["TERM_PROGRAM_VERSION"] = version;
  }
  if (shouldSetLangEnvVariable(env2, detectLocale)) {
    env2["LANG"] = getLangEnvVariable(locale);
  }
  env2["COLORTERM"] = "truecolor";
}
function mergeNonNullKeys(env2, other) {
  if (!other) {
    return;
  }
  for (const key of Object.keys(other)) {
    const value = other[key];
    if (value !== void 0 && value !== null) {
      env2[key] = value;
    }
  }
}
async function resolveConfigurationVariables(variableResolver, env2) {
  await Promise.all(Object.entries(env2).map(async ([key, value]) => {
    if (typeof value === "string") {
      try {
        env2[key] = await variableResolver(value);
      } catch (e) {
        env2[key] = value;
      }
    }
  }));
  return env2;
}
function shouldSetLangEnvVariable(env2, detectLocale) {
  if (detectLocale === "on") {
    return true;
  }
  if (detectLocale === "auto") {
    const lang = env2["LANG"];
    return !lang || lang.search(/\.UTF\-8$/) === -1 && lang.search(/\.utf8$/) === -1 && lang.search(/\.euc.+/) === -1;
  }
  return false;
}
function getLangEnvVariable(locale) {
  const parts = locale ? locale.split("-") : [];
  const n2 = parts.length;
  if (n2 === 0) {
    return "en_US.UTF-8";
  }
  if (n2 === 1) {
    const languageVariants = {
      af: "ZA",
      am: "ET",
      be: "BY",
      bg: "BG",
      ca: "ES",
      cs: "CZ",
      da: "DK",
      de: "DE",
      el: "GR",
      en: "US",
      es: "ES",
      et: "EE",
      eu: "ES",
      fi: "FI",
      fr: "FR",
      he: "IL",
      hr: "HR",
      hu: "HU",
      hy: "AM",
      is: "IS",
      it: "IT",
      ja: "JP",
      kk: "KZ",
      ko: "KR",
      lt: "LT",
      nl: "NL",
      no: "NO",
      pl: "PL",
      pt: "BR",
      ro: "RO",
      ru: "RU",
      sk: "SK",
      sl: "SI",
      sr: "YU",
      sv: "SE",
      tr: "TR",
      uk: "UA",
      zh: "CN"
    };
    if (parts[0] in languageVariants) {
      parts.push(languageVariants[parts[0]]);
    }
  } else {
    parts[1] = parts[1].toUpperCase();
  }
  return parts.join("_") + ".UTF-8";
}
async function getCwd(shell, userHome, variableResolver, root, customCwd, logService) {
  if (shell.cwd) {
    const unresolved = typeof shell.cwd === "object" ? shell.cwd.fsPath : shell.cwd;
    const resolved = await _resolveCwd(unresolved, variableResolver);
    return sanitizeCwd(resolved || unresolved);
  }
  let cwd;
  if (!shell.ignoreConfigurationCwd && customCwd) {
    if (variableResolver) {
      customCwd = await _resolveCwd(customCwd, variableResolver, logService);
    }
    if (customCwd) {
      if (isAbsolute(customCwd)) {
        cwd = customCwd;
      } else if (root) {
        cwd = join(root.fsPath, customCwd);
      }
    }
  }
  if (!cwd) {
    cwd = root ? root.fsPath : userHome || "";
  }
  return sanitizeCwd(cwd);
}
async function _resolveCwd(cwd, variableResolver, logService) {
  if (variableResolver) {
    try {
      return await variableResolver(cwd);
    } catch (e) {
      logService == null ? void 0 : logService.error("Could not resolve terminal cwd", e);
      return void 0;
    }
  }
  return cwd;
}
function createVariableResolver(lastActiveWorkspace, env2, configurationResolverService) {
  if (!configurationResolverService) {
    return void 0;
  }
  return (str) => configurationResolverService.resolveWithEnvironment(env2, lastActiveWorkspace, str);
}
async function createTerminalEnvironment(shellLaunchConfig, envFromConfig, variableResolver, version, detectLocale, baseEnv) {
  const env2 = {};
  if (shellLaunchConfig.strictEnv) {
    mergeNonNullKeys(env2, shellLaunchConfig.env);
  } else {
    mergeNonNullKeys(env2, baseEnv);
    const allowedEnvFromConfig = { ...envFromConfig };
    if (variableResolver) {
      if (allowedEnvFromConfig) {
        await resolveConfigurationVariables(variableResolver, allowedEnvFromConfig);
      }
      if (shellLaunchConfig.env) {
        await resolveConfigurationVariables(variableResolver, shellLaunchConfig.env);
      }
    }
    sanitizeProcessEnvironment(env2, "VSCODE_IPC_HOOK_CLI");
    mergeEnvironments(env2, allowedEnvFromConfig);
    mergeEnvironments(env2, shellLaunchConfig.env);
    addTerminalEnvironmentKeys(env2, version, language, detectLocale);
  }
  return env2;
}
async function preparePathForShell(resource, executable, title, shellType, backend, os, isWindowsFrontend = isWindows) {
  let originalPath;
  if (isString(resource)) {
    originalPath = resource;
  } else {
    originalPath = resource.fsPath;
    if (isWindowsFrontend && os !== 1) {
      originalPath = originalPath.replace(/\\/g, "/");
    } else if (!isWindowsFrontend && os === 1) {
      originalPath = originalPath.replace(/\//g, "\\");
    }
  }
  if (!executable) {
    return originalPath;
  }
  const hasSpace = originalPath.includes(" ");
  const hasParens = originalPath.includes("(") || originalPath.includes(")");
  const pathBasename = basename(executable, ".exe");
  const isPowerShell = pathBasename === "pwsh" || title === "pwsh" || pathBasename === "powershell" || title === "powershell";
  if (isPowerShell && (hasSpace || originalPath.includes("'"))) {
    return `& '${originalPath.replace(/'/g, "''")}'`;
  }
  if (hasParens && isPowerShell) {
    return `& '${originalPath}'`;
  }
  if (os === 1) {
    if (shellType !== void 0) {
      if (shellType === "gitbash") {
        return escapeNonWindowsPath(originalPath.replace(/\\/g, "/"));
      } else if (shellType === "wsl") {
        return (backend == null ? void 0 : backend.getWslPath(originalPath, "win-to-unix")) || originalPath;
      } else if (hasSpace) {
        return `"${originalPath}"`;
      }
      return originalPath;
    }
    const lowerExecutable = executable.toLowerCase();
    if (lowerExecutable.includes("wsl") || lowerExecutable.includes("bash.exe") && !lowerExecutable.toLowerCase().includes("git")) {
      return (backend == null ? void 0 : backend.getWslPath(originalPath, "win-to-unix")) || originalPath;
    } else if (hasSpace) {
      return `"${originalPath}"`;
    }
    return originalPath;
  }
  return escapeNonWindowsPath(originalPath);
}
function getWorkspaceForTerminal(cwd, workspaceContextService, historyService) {
  const cwdUri = typeof cwd === "string" ? URI.parse(cwd) : cwd;
  let workspaceFolder = cwdUri ? withNullAsUndefined(workspaceContextService.getWorkspaceFolder(cwdUri)) : void 0;
  if (!workspaceFolder) {
    const activeWorkspaceRootUri = historyService.getLastActiveWorkspaceRoot();
    workspaceFolder = activeWorkspaceRootUri ? withNullAsUndefined(workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri)) : void 0;
  }
  return workspaceFolder;
}
let TerminalProcessManager = class TerminalProcessManager2 extends Disposable {
  get persistentProcessId() {
    var _a2;
    return (_a2 = this._process) == null ? void 0 : _a2.id;
  }
  get shouldPersist() {
    return !!this.reconnectionProperties || (this._process ? this._process.shouldPersist : false);
  }
  get hasWrittenData() {
    return this._hasWrittenData;
  }
  get hasChildProcesses() {
    return this._hasChildProcesses;
  }
  get reconnectionProperties() {
    var _a2, _b2, _c2;
    return ((_b2 = (_a2 = this._shellLaunchConfig) == null ? void 0 : _a2.attachPersistentProcess) == null ? void 0 : _b2.reconnectionProperties) || ((_c2 = this._shellLaunchConfig) == null ? void 0 : _c2.reconnectionProperties) || void 0;
  }
  get extEnvironmentVariableCollection() {
    return this._extEnvironmentVariableCollection;
  }
  constructor(_instanceId, _configHelper, cwd, environmentVariableCollections, shellIntegrationNonce, _historyService, _instantiationService, _logService, _workspaceContextService, _configurationResolverService, _workbenchEnvironmentService, _productService, _remoteAgentService, _pathService, _environmentVariableService, _terminalProfileResolverService, _configurationService, _terminalInstanceService, _telemetryService, _notificationService) {
    super();
    this._instanceId = _instanceId;
    this._configHelper = _configHelper;
    this._historyService = _historyService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._workspaceContextService = _workspaceContextService;
    this._configurationResolverService = _configurationResolverService;
    this._workbenchEnvironmentService = _workbenchEnvironmentService;
    this._productService = _productService;
    this._remoteAgentService = _remoteAgentService;
    this._pathService = _pathService;
    this._environmentVariableService = _environmentVariableService;
    this._terminalProfileResolverService = _terminalProfileResolverService;
    this._configurationService = _configurationService;
    this._terminalInstanceService = _terminalInstanceService;
    this._telemetryService = _telemetryService;
    this._notificationService = _notificationService;
    this.processState = 1;
    this.capabilities = new TerminalCapabilityStore();
    this._isDisposed = false;
    this._process = null;
    this._processType = 0;
    this._preLaunchInputQueue = [];
    this._hasWrittenData = false;
    this._hasChildProcesses = false;
    this._ptyListenersAttached = false;
    this._isDisconnected = false;
    this._dimensions = { cols: 0, rows: 0 };
    this._onPtyDisconnect = this._register(new Emitter());
    this.onPtyDisconnect = this._onPtyDisconnect.event;
    this._onPtyReconnect = this._register(new Emitter());
    this.onPtyReconnect = this._onPtyReconnect.event;
    this._onProcessReady = this._register(new Emitter());
    this.onProcessReady = this._onProcessReady.event;
    this._onProcessStateChange = this._register(new Emitter());
    this.onProcessStateChange = this._onProcessStateChange.event;
    this._onBeforeProcessData = this._register(new Emitter());
    this.onBeforeProcessData = this._onBeforeProcessData.event;
    this._onProcessData = this._register(new Emitter());
    this.onProcessData = this._onProcessData.event;
    this._onProcessReplayComplete = this._register(new Emitter());
    this.onProcessReplayComplete = this._onProcessReplayComplete.event;
    this._onDidChangeProperty = this._register(new Emitter());
    this.onDidChangeProperty = this._onDidChangeProperty.event;
    this._onEnvironmentVariableInfoChange = this._register(new Emitter());
    this.onEnvironmentVariableInfoChanged = this._onEnvironmentVariableInfoChange.event;
    this._onProcessExit = this._register(new Emitter());
    this.onProcessExit = this._onProcessExit.event;
    this._onRestoreCommands = this._register(new Emitter());
    this.onRestoreCommands = this._onRestoreCommands.event;
    this._cwdWorkspaceFolder = getWorkspaceForTerminal(cwd, this._workspaceContextService, this._historyService);
    this.ptyProcessReady = this._createPtyProcessReadyPromise();
    this._ackDataBufferer = new AckDataBufferer((e) => {
      var _a2;
      return (_a2 = this._process) == null ? void 0 : _a2.acknowledgeDataEvent(e);
    });
    this._dataFilter = this._instantiationService.createInstance(SeamlessRelaunchDataFilter);
    this._dataFilter.onProcessData((ev) => {
      const data = typeof ev === "string" ? ev : ev.data;
      const beforeProcessDataEvent = { data };
      this._onBeforeProcessData.fire(beforeProcessDataEvent);
      if (beforeProcessDataEvent.data && beforeProcessDataEvent.data.length > 0) {
        if (typeof ev !== "string") {
          ev.data = beforeProcessDataEvent.data;
        }
        this._onProcessData.fire(typeof ev !== "string" ? ev : { data: beforeProcessDataEvent.data, trackCommit: false });
      }
    });
    if (cwd && typeof cwd === "object") {
      this.remoteAuthority = getRemoteAuthority(cwd);
    } else {
      this.remoteAuthority = this._workbenchEnvironmentService.remoteAuthority;
    }
    if (environmentVariableCollections) {
      this._extEnvironmentVariableCollection = new MergedEnvironmentVariableCollection(environmentVariableCollections);
      this._register(this._environmentVariableService.onDidChangeCollections((newCollection) => this._onEnvironmentVariableCollectionChange(newCollection)));
      this.environmentVariableInfo = this._instantiationService.createInstance(EnvironmentVariableInfoChangesActive, this._extEnvironmentVariableCollection);
      this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo);
    }
    this.shellIntegrationNonce = shellIntegrationNonce ?? generateUuid();
  }
  async freePortKillProcess(port) {
    var _a2, _b2;
    try {
      if ((_a2 = this._process) == null ? void 0 : _a2.freePortKillProcess) {
        await ((_b2 = this._process) == null ? void 0 : _b2.freePortKillProcess(port));
      }
    } catch (e) {
      this._notificationService.notify({ message: localize(
        "killportfailure",
        "Could not kill process listening on port {0}, command exited with error {1}",
        port,
        e
      ), severity: Severity$1.Warning });
    }
  }
  dispose(immediate = false) {
    this._isDisposed = true;
    if (this._process) {
      this._setProcessState(5);
      this._process.shutdown(immediate);
      this._process = null;
    }
    super.dispose();
  }
  _createPtyProcessReadyPromise() {
    return new Promise((c) => {
      const listener = this.onProcessReady(() => {
        this._logService.debug(`Terminal process ready (shellProcessId: ${this.shellProcessId})`);
        listener.dispose();
        c(void 0);
      });
    });
  }
  async detachFromProcess(forcePersist) {
    var _a2, _b2;
    await ((_b2 = (_a2 = this._process) == null ? void 0 : _a2.detach) == null ? void 0 : _b2.call(_a2, forcePersist));
    this._process = null;
  }
  async createProcess(shellLaunchConfig, cols, rows, reset2 = true) {
    var _a2, _b2;
    this._shellLaunchConfig = shellLaunchConfig;
    this._dimensions.cols = cols;
    this._dimensions.rows = rows;
    let newProcess;
    if (shellLaunchConfig.customPtyImplementation) {
      this._processType = 1;
      newProcess = shellLaunchConfig.customPtyImplementation(this._instanceId, cols, rows);
    } else {
      const backend = await this._terminalInstanceService.getBackend(this.remoteAuthority);
      if (!backend) {
        throw new Error(`No terminal backend registered for remote authority '${this.remoteAuthority}'`);
      }
      this.backend = backend;
      const variableResolver = createVariableResolver(this._cwdWorkspaceFolder, await this._terminalProfileResolverService.getEnvironment(this.remoteAuthority), this._configurationResolverService);
      this.userHome = (_a2 = this._pathService.resolvedUserHome) == null ? void 0 : _a2.fsPath;
      this.os = OS;
      if (!!this.remoteAuthority) {
        const userHomeUri = await this._pathService.userHome();
        this.userHome = userHomeUri.path;
        const remoteEnv = await this._remoteAgentService.getEnvironment();
        if (!remoteEnv) {
          throw new Error(`Failed to get remote environment for remote authority "${this.remoteAuthority}"`);
        }
        this.userHome = remoteEnv.userHome.path;
        this.os = remoteEnv.os;
        const env2 = await this._resolveEnvironment(backend, variableResolver, shellLaunchConfig);
        const shouldPersist = (this._configurationService.getValue("task.reconnection") && shellLaunchConfig.reconnectionProperties || !shellLaunchConfig.isFeatureTerminal) && this._configHelper.config.enablePersistentSessions && !shellLaunchConfig.isTransient;
        if (shellLaunchConfig.attachPersistentProcess) {
          const result2 = await backend.attachToProcess(shellLaunchConfig.attachPersistentProcess.id);
          if (result2) {
            newProcess = result2;
          } else {
            this._logService.warn(`Attach to process failed for terminal`, shellLaunchConfig.attachPersistentProcess);
            shellLaunchConfig.attachPersistentProcess = void 0;
          }
        }
        if (!newProcess) {
          await this._terminalProfileResolverService.resolveShellLaunchConfig(shellLaunchConfig, {
            remoteAuthority: this.remoteAuthority,
            os: this.os
          });
          const options = {
            shellIntegration: {
              enabled: this._configurationService.getValue("terminal.integrated.shellIntegration.enabled"),
              suggestEnabled: this._configurationService.getValue("terminal.integrated.shellIntegration.suggestEnabled"),
              nonce: this.shellIntegrationNonce
            },
            windowsEnableConpty: this._configHelper.config.windowsEnableConpty,
            environmentVariableCollections: ((_b2 = this._extEnvironmentVariableCollection) == null ? void 0 : _b2.collections) ? serializeEnvironmentVariableCollections(this._extEnvironmentVariableCollection.collections) : void 0,
            workspaceFolder: this._cwdWorkspaceFolder
          };
          try {
            newProcess = await backend.createProcess(
              shellLaunchConfig,
              "",
              cols,
              rows,
              this._configHelper.config.unicodeVersion,
              env2,
              options,
              shouldPersist
            );
          } catch (e) {
            if ((e == null ? void 0 : e.message) === "Could not fetch remote environment") {
              this._logService.trace(`Could not fetch remote environment, silently failing`);
              return void 0;
            }
            throw e;
          }
        }
        if (!this._isDisposed) {
          this._setupPtyHostListeners(backend);
        }
      } else {
        if (shellLaunchConfig.attachPersistentProcess) {
          const result2 = shellLaunchConfig.attachPersistentProcess.findRevivedId ? await backend.attachToRevivedProcess(shellLaunchConfig.attachPersistentProcess.id) : await backend.attachToProcess(shellLaunchConfig.attachPersistentProcess.id);
          if (result2) {
            newProcess = result2;
          } else {
            this._logService.warn(`Attach to process failed for terminal`, shellLaunchConfig.attachPersistentProcess);
            shellLaunchConfig.attachPersistentProcess = void 0;
          }
        }
        if (!newProcess) {
          newProcess = await this._launchLocalProcess(backend, shellLaunchConfig, cols, rows, this.userHome, variableResolver);
        }
        if (!this._isDisposed) {
          this._setupPtyHostListeners(backend);
        }
      }
    }
    if (this._isDisposed) {
      newProcess.shutdown(false);
      return void 0;
    }
    this._process = newProcess;
    this._setProcessState(2);
    if (this.os === 3 || this.os === 2) {
      this.capabilities.add(1, new NaiveCwdDetectionCapability(this._process));
    }
    this._dataFilter.newProcess(this._process, reset2);
    if (this._processListeners) {
      dispose(this._processListeners);
    }
    this._processListeners = [
      newProcess.onProcessReady((e) => {
        this.shellProcessId = e.pid;
        this._initialCwd = e.cwd;
        this._onDidChangeProperty.fire({ type: "initialCwd", value: this._initialCwd });
        this._onProcessReady.fire(e);
        if (this._preLaunchInputQueue.length > 0 && this._process) {
          newProcess.input(this._preLaunchInputQueue.join(""));
          this._preLaunchInputQueue.length = 0;
        }
      }),
      newProcess.onProcessExit((exitCode) => this._onExit(exitCode)),
      newProcess.onDidChangeProperty(({ type, value }) => {
        var _a3;
        switch (type) {
          case "hasChildProcesses":
            this._hasChildProcesses = value;
            break;
          case "failedShellIntegrationActivation":
            (_a3 = this._telemetryService) == null ? void 0 : _a3.publicLog2("terminal/shellIntegrationActivationFailureCustomArgs");
            break;
        }
        this._onDidChangeProperty.fire({ type, value });
      })
    ];
    if (newProcess.onProcessReplayComplete) {
      this._processListeners.push(newProcess.onProcessReplayComplete(() => this._onProcessReplayComplete.fire()));
    }
    if (newProcess.onRestoreCommands) {
      this._processListeners.push(newProcess.onRestoreCommands((e) => this._onRestoreCommands.fire(e)));
    }
    setTimeout(() => {
      if (this.processState === 2) {
        this._setProcessState(3);
      }
    }, 500);
    const result = await newProcess.start();
    if (result) {
      return result;
    }
    runWhenIdle(() => {
      var _a3;
      (_a3 = this.backend) == null ? void 0 : _a3.getLatency().then((measurements) => {
        this._logService.info(`Latency measurements for ${this.remoteAuthority ?? "local"} backend
${measurements.map((e) => `${e.label}: ${e.latency.toFixed(2)}ms`).join("\n")}`);
      });
    });
    return void 0;
  }
  async relaunch(shellLaunchConfig, cols, rows, reset2) {
    this.ptyProcessReady = this._createPtyProcessReadyPromise();
    this._logService.trace(`Relaunching terminal instance ${this._instanceId}`);
    if (this._isDisconnected) {
      this._isDisconnected = false;
      this._onPtyReconnect.fire();
    }
    this._hasWrittenData = false;
    return this.createProcess(shellLaunchConfig, cols, rows, reset2);
  }
  async _resolveEnvironment(backend, variableResolver, shellLaunchConfig) {
    const workspaceFolder = getWorkspaceForTerminal(shellLaunchConfig.cwd, this._workspaceContextService, this._historyService);
    const platformKey = isWindows ? "windows" : isMacintosh ? "osx" : "linux";
    const envFromConfigValue = this._configurationService.getValue(`terminal.integrated.env.${platformKey}`);
    this._configHelper.showRecommendations(shellLaunchConfig);
    let baseEnv;
    if (shellLaunchConfig.useShellEnvironment) {
      baseEnv = await backend.getShellEnvironment();
    } else {
      baseEnv = await this._terminalProfileResolverService.getEnvironment(this.remoteAuthority);
    }
    const env2 = await createTerminalEnvironment(shellLaunchConfig, envFromConfigValue, variableResolver, this._productService.version, this._configHelper.config.detectLocale, baseEnv);
    if (!this._isDisposed && !shellLaunchConfig.strictEnv && !shellLaunchConfig.hideFromUser) {
      this._extEnvironmentVariableCollection = this._environmentVariableService.mergedCollection;
      this._register(this._environmentVariableService.onDidChangeCollections((newCollection) => this._onEnvironmentVariableCollectionChange(newCollection)));
      await this._extEnvironmentVariableCollection.applyToProcessEnvironment(env2, { workspaceFolder }, variableResolver);
      if (this._extEnvironmentVariableCollection.getVariableMap({ workspaceFolder }).size) {
        this.environmentVariableInfo = this._instantiationService.createInstance(EnvironmentVariableInfoChangesActive, this._extEnvironmentVariableCollection);
        this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo);
      }
    }
    return env2;
  }
  async _launchLocalProcess(backend, shellLaunchConfig, cols, rows, userHome, variableResolver) {
    await this._terminalProfileResolverService.resolveShellLaunchConfig(shellLaunchConfig, {
      remoteAuthority: void 0,
      os: OS
    });
    const activeWorkspaceRootUri = this._historyService.getLastActiveWorkspaceRoot(Schemas.file);
    const initialCwd = await getCwd(shellLaunchConfig, userHome, variableResolver, activeWorkspaceRootUri, this._configHelper.config.cwd, this._logService);
    const env2 = await this._resolveEnvironment(backend, variableResolver, shellLaunchConfig);
    const options = {
      shellIntegration: {
        enabled: this._configurationService.getValue("terminal.integrated.shellIntegration.enabled"),
        suggestEnabled: this._configurationService.getValue("terminal.integrated.shellIntegration.suggestEnabled"),
        nonce: this.shellIntegrationNonce
      },
      windowsEnableConpty: this._configHelper.config.windowsEnableConpty,
      environmentVariableCollections: this._extEnvironmentVariableCollection ? serializeEnvironmentVariableCollections(this._extEnvironmentVariableCollection.collections) : void 0,
      workspaceFolder: this._cwdWorkspaceFolder
    };
    const shouldPersist = (this._configurationService.getValue("task.reconnection") && shellLaunchConfig.reconnectionProperties || !shellLaunchConfig.isFeatureTerminal) && this._configHelper.config.enablePersistentSessions && !shellLaunchConfig.isTransient;
    return await backend.createProcess(shellLaunchConfig, initialCwd, cols, rows, this._configHelper.config.unicodeVersion, env2, options, shouldPersist);
  }
  _setupPtyHostListeners(backend) {
    if (this._ptyListenersAttached) {
      return;
    }
    this._ptyListenersAttached = true;
    this._register(backend.onPtyHostUnresponsive(() => {
      this._isDisconnected = true;
      this._onPtyDisconnect.fire();
    }));
    this._ptyResponsiveListener = backend.onPtyHostResponsive(() => {
      this._isDisconnected = false;
      this._onPtyReconnect.fire();
    });
    this._register(toDisposable(() => {
      var _a2;
      return (_a2 = this._ptyResponsiveListener) == null ? void 0 : _a2.dispose();
    }));
    this._register(backend.onPtyHostRestart(async () => {
      var _a2;
      if (!this._isDisconnected) {
        this._isDisconnected = true;
        this._onPtyDisconnect.fire();
      }
      (_a2 = this._ptyResponsiveListener) == null ? void 0 : _a2.dispose();
      this._ptyResponsiveListener = void 0;
      if (this._shellLaunchConfig) {
        if (this._shellLaunchConfig.isFeatureTerminal && !this.reconnectionProperties) {
          this._onExit(-1);
        } else {
          const message = localize(
            "ptyHostRelaunch",
            "Restarting the terminal because the connection to the shell process was lost..."
          );
          this._onProcessData.fire({ data: formatMessageForTerminal(message, { loudFormatting: true }), trackCommit: false });
          await this.relaunch(this._shellLaunchConfig, this._dimensions.cols, this._dimensions.rows, false);
        }
      }
    }));
  }
  async getBackendOS() {
    let os = OS;
    if (!!this.remoteAuthority) {
      const remoteEnv = await this._remoteAgentService.getEnvironment();
      if (!remoteEnv) {
        throw new Error(`Failed to get remote environment for remote authority "${this.remoteAuthority}"`);
      }
      os = remoteEnv.os;
    }
    return os;
  }
  setDimensions(cols, rows, sync) {
    if (sync) {
      this._resize(cols, rows);
      return;
    }
    return this.ptyProcessReady.then(() => this._resize(cols, rows));
  }
  async setUnicodeVersion(version) {
    var _a2;
    return (_a2 = this._process) == null ? void 0 : _a2.setUnicodeVersion(version);
  }
  _resize(cols, rows) {
    if (!this._process) {
      return;
    }
    try {
      this._process.resize(cols, rows);
    } catch (error) {
      if (error.code !== "EPIPE" && error.code !== "ERR_IPC_CHANNEL_CLOSED") {
        throw error;
      }
    }
    this._dimensions.cols = cols;
    this._dimensions.rows = rows;
  }
  async write(data) {
    await this.ptyProcessReady;
    this._dataFilter.disableSeamlessRelaunch();
    this._hasWrittenData = true;
    if (this.shellProcessId || this._processType === 1) {
      if (this._process) {
        this._process.input(data);
      }
    } else {
      this._preLaunchInputQueue.push(data);
    }
  }
  async processBinary(data) {
    var _a2;
    await this.ptyProcessReady;
    this._dataFilter.disableSeamlessRelaunch();
    this._hasWrittenData = true;
    (_a2 = this._process) == null ? void 0 : _a2.processBinary(data);
  }
  get initialCwd() {
    return this._initialCwd ?? "";
  }
  async refreshProperty(type) {
    if (!this._process) {
      throw new Error("Cannot refresh property when process is not set");
    }
    return this._process.refreshProperty(type);
  }
  async updateProperty(type, value) {
    var _a2;
    return (_a2 = this._process) == null ? void 0 : _a2.updateProperty(type, value);
  }
  acknowledgeDataEvent(charCount) {
    this._ackDataBufferer.ack(charCount);
  }
  _onExit(exitCode) {
    this._process = null;
    if (this.processState === 2) {
      this._setProcessState(4);
    }
    if (this.processState === 3) {
      this._setProcessState(6);
    }
    this._onProcessExit.fire(exitCode);
  }
  _setProcessState(state) {
    this.processState = state;
    this._onProcessStateChange.fire();
  }
  _onEnvironmentVariableCollectionChange(newCollection) {
    const diff = this._extEnvironmentVariableCollection.diff(newCollection, { workspaceFolder: this._cwdWorkspaceFolder });
    if (diff === void 0) {
      if (this.environmentVariableInfo instanceof EnvironmentVariableInfoStale) {
        this.environmentVariableInfo = this._instantiationService.createInstance(EnvironmentVariableInfoChangesActive, this._extEnvironmentVariableCollection);
        this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo);
      }
      return;
    }
    this.environmentVariableInfo = this._instantiationService.createInstance(EnvironmentVariableInfoStale, diff, this._instanceId, newCollection);
    this._onEnvironmentVariableInfoChange.fire(this.environmentVariableInfo);
  }
  async clearBuffer() {
    var _a2, _b2;
    (_b2 = (_a2 = this._process) == null ? void 0 : _a2.clearBuffer) == null ? void 0 : _b2.call(_a2);
  }
};
TerminalProcessManager = __decorate([
  __param(5, IHistoryService),
  __param(6, IInstantiationService),
  __param(7, ITerminalLogService),
  __param(8, IWorkspaceContextService),
  __param(9, IConfigurationResolverService),
  __param(10, IWorkbenchEnvironmentService),
  __param(11, IProductService),
  __param(12, IRemoteAgentService),
  __param(13, IPathService),
  __param(14, IEnvironmentVariableService),
  __param(15, ITerminalProfileResolverService),
  __param(16, IConfigurationService),
  __param(17, ITerminalInstanceService),
  __param(18, ITelemetryService),
  __param(19, INotificationService)
], TerminalProcessManager);
class AckDataBufferer {
  constructor(_callback) {
    this._callback = _callback;
    this._unsentCharCount = 0;
  }
  ack(charCount) {
    this._unsentCharCount += charCount;
    while (this._unsentCharCount > 5e3) {
      this._unsentCharCount -= 5e3;
      this._callback(5e3);
    }
  }
}
let SeamlessRelaunchDataFilter = class SeamlessRelaunchDataFilter2 extends Disposable {
  get onProcessData() {
    return this._onProcessData.event;
  }
  constructor(_logService) {
    super();
    this._logService = _logService;
    this._disableSeamlessRelaunch = false;
    this._onProcessData = this._register(new Emitter());
  }
  newProcess(process, reset2) {
    var _a2, _b2, _c2, _d2, _e2;
    (_a2 = this._dataListener) == null ? void 0 : _a2.dispose();
    (_b2 = this._activeProcess) == null ? void 0 : _b2.shutdown(false);
    this._activeProcess = process;
    if (!this._firstRecorder || !reset2 || this._disableSeamlessRelaunch) {
      (_c2 = this._firstDisposable) == null ? void 0 : _c2.dispose();
      [this._firstRecorder, this._firstDisposable] = this._createRecorder(process);
      if (this._disableSeamlessRelaunch && reset2) {
        this._onProcessData.fire("\x1Bc");
      }
      this._dataListener = process.onProcessData((e) => this._onProcessData.fire(e));
      this._disableSeamlessRelaunch = false;
      return;
    }
    if (this._secondRecorder) {
      this.triggerSwap();
    }
    this._swapTimeout = window.setTimeout(() => this.triggerSwap(), 3e3);
    (_d2 = this._dataListener) == null ? void 0 : _d2.dispose();
    (_e2 = this._firstDisposable) == null ? void 0 : _e2.dispose();
    const recorder = this._createRecorder(process);
    [this._secondRecorder, this._secondDisposable] = recorder;
  }
  disableSeamlessRelaunch() {
    this._disableSeamlessRelaunch = true;
    this._stopRecording();
    this.triggerSwap();
  }
  triggerSwap() {
    var _a2, _b2, _c2;
    if (this._swapTimeout) {
      window.clearTimeout(this._swapTimeout);
      this._swapTimeout = void 0;
    }
    if (!this._firstRecorder) {
      return;
    }
    if (!this._secondRecorder) {
      this._firstRecorder = void 0;
      (_a2 = this._firstDisposable) == null ? void 0 : _a2.dispose();
      return;
    }
    const firstData = this._getDataFromRecorder(this._firstRecorder);
    const secondData = this._getDataFromRecorder(this._secondRecorder);
    if (firstData === secondData) {
      this._logService.trace(`Seamless terminal relaunch - identical content`);
    } else {
      this._logService.trace(`Seamless terminal relaunch - resetting content`);
      this._onProcessData.fire({ data: `\x1Bc${secondData}`, trackCommit: false });
    }
    (_b2 = this._dataListener) == null ? void 0 : _b2.dispose();
    this._dataListener = this._activeProcess.onProcessData((e) => this._onProcessData.fire(e));
    this._firstRecorder = this._secondRecorder;
    (_c2 = this._firstDisposable) == null ? void 0 : _c2.dispose();
    this._firstDisposable = this._secondDisposable;
    this._secondRecorder = void 0;
  }
  _stopRecording() {
    var _a2, _b2;
    if (this._swapTimeout) {
      return;
    }
    this._firstRecorder = void 0;
    (_a2 = this._firstDisposable) == null ? void 0 : _a2.dispose();
    this._secondRecorder = void 0;
    (_b2 = this._secondDisposable) == null ? void 0 : _b2.dispose();
  }
  _createRecorder(process) {
    const recorder = new TerminalRecorder(0, 0);
    const disposable = process.onProcessData((e) => recorder.handleData(typeof e === "string" ? e : e.data));
    return [recorder, disposable];
  }
  _getDataFromRecorder(recorder) {
    return recorder.generateReplayEventSync().events.filter((e) => !!e.data).map((e) => e.data).join("");
  }
};
SeamlessRelaunchDataFilter = __decorate([
  __param(0, ITerminalLogService)
], SeamlessRelaunchDataFilter);
async function showRunRecentQuickPick(accessor, instance, terminalInRunCommandPicker, type, filterMode, value) {
  var _a2;
  if (!instance.xterm) {
    return;
  }
  const editorService = accessor.get(IEditorService);
  const instantiationService = accessor.get(IInstantiationService);
  const quickInputService = accessor.get(IQuickInputService);
  const storageService = accessor.get(IStorageService);
  const runRecentStorageKey = `${"terminal.pinnedRecentCommands"}.${instance.shellType}`;
  let placeholder;
  let items = [];
  const commandMap = /* @__PURE__ */ new Set();
  const removeFromCommandHistoryButton = {
    iconClass: ThemeIcon.asClassName(commandHistoryRemoveIcon),
    tooltip: localize("removeCommand", "Remove from Command History")
  };
  const commandOutputButton = {
    iconClass: ThemeIcon.asClassName(commandHistoryOutputIcon),
    tooltip: localize("viewCommandOutput", "View Command Output"),
    alwaysVisible: false
  };
  if (type === "command") {
    let formatLabel = function(label) {
      return label.replace(/\r?\n/g, "⏎").replace(/\s\s\s+/g, "⋯");
    };
    placeholder = isMacintosh ? localize(
      "selectRecentCommandMac",
      "Select a command to run (hold Option-key to edit the command)"
    ) : localize(
      "selectRecentCommand",
      "Select a command to run (hold Alt-key to edit the command)"
    );
    const cmdDetection = instance.capabilities.get(2);
    const commands = cmdDetection == null ? void 0 : cmdDetection.commands;
    const executingCommand = cmdDetection == null ? void 0 : cmdDetection.executingCommand;
    if (executingCommand) {
      commandMap.add(executingCommand);
    }
    if (commands && commands.length > 0) {
      for (const entry of commands) {
        const label = entry.command.trim();
        if (label.length === 0 || commandMap.has(label)) {
          continue;
        }
        let description = collapseTildePath(entry.cwd, instance.userHome, instance.os === 1 ? "\\" : "/");
        if (entry.exitCode) {
          if (entry.exitCode === -1) {
            description += " failed";
          } else {
            description += ` exitCode: ${entry.exitCode}`;
          }
        }
        description = description.trim();
        const buttons = [commandOutputButton];
        const lastItem = items.length > 0 ? items[items.length - 1] : void 0;
        if ((lastItem == null ? void 0 : lastItem.type) !== "separator" && (lastItem == null ? void 0 : lastItem.label) === label) {
          lastItem.id = entry.timestamp.toString();
          lastItem.description = description;
          continue;
        }
        items.push({
          label: formatLabel(label),
          rawLabel: label,
          description,
          id: entry.timestamp.toString(),
          command: entry,
          buttons: entry.hasOutput() ? buttons : void 0
        });
        commandMap.add(label);
      }
      items = items.reverse();
    }
    if (executingCommand) {
      items.unshift({
        label: formatLabel(executingCommand),
        rawLabel: executingCommand,
        description: cmdDetection.cwd
      });
    }
    if (items.length > 0) {
      items.unshift({ type: "separator", label: terminalStrings.currentSessionCategory });
    }
    const history = instantiationService.invokeFunction(getCommandHistory);
    const previousSessionItems = [];
    for (const [label, info] of history.entries) {
      if (!commandMap.has(label) && info.shellType === instance.shellType) {
        previousSessionItems.unshift({
          label: formatLabel(label),
          rawLabel: label,
          buttons: [removeFromCommandHistoryButton]
        });
        commandMap.add(label);
      }
    }
    if (previousSessionItems.length > 0) {
      items.push({ type: "separator", label: terminalStrings.previousSessionCategory }, ...previousSessionItems);
    }
    const shellFileHistory2 = await instantiationService.invokeFunction(getShellFileHistory, instance.shellType);
    const dedupedShellFileItems = [];
    for (const label of shellFileHistory2) {
      if (!commandMap.has(label)) {
        dedupedShellFileItems.unshift({
          label: formatLabel(label),
          rawLabel: label
        });
      }
    }
    if (dedupedShellFileItems.length > 0) {
      items.push({ type: "separator", label: localize("shellFileHistoryCategory", "{0} history", instance.shellType) }, ...dedupedShellFileItems);
    }
  } else {
    placeholder = isMacintosh ? localize(
      "selectRecentDirectoryMac",
      "Select a directory to go to (hold Option-key to edit the command)"
    ) : localize(
      "selectRecentDirectory",
      "Select a directory to go to (hold Alt-key to edit the command)"
    );
    const cwds = ((_a2 = instance.capabilities.get(0)) == null ? void 0 : _a2.cwds) || [];
    if (cwds && cwds.length > 0) {
      for (const label of cwds) {
        items.push({ label, rawLabel: label });
      }
      items = items.reverse();
      items.unshift({ type: "separator", label: terminalStrings.currentSessionCategory });
    }
    const history = instantiationService.invokeFunction(getDirectoryHistory);
    const previousSessionItems = [];
    for (const [label, info] of history.entries) {
      if ((info === null || info.remoteAuthority === instance.remoteAuthority) && !cwds.includes(label)) {
        previousSessionItems.unshift({
          label,
          rawLabel: label,
          buttons: [removeFromCommandHistoryButton]
        });
      }
    }
    if (previousSessionItems.length > 0) {
      items.push({ type: "separator", label: terminalStrings.previousSessionCategory }, ...previousSessionItems);
    }
  }
  if (items.length === 0) {
    return;
  }
  const fuzzySearchToggle = new Toggle({
    title: "Fuzzy search",
    icon: commandHistoryFuzzySearchIcon,
    isChecked: filterMode === "fuzzy",
    inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
    inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
    inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
  });
  fuzzySearchToggle.onChange(() => {
    instantiationService.invokeFunction(showRunRecentQuickPick, instance, terminalInRunCommandPicker, type, fuzzySearchToggle.checked ? "fuzzy" : "contiguous", quickPick.value);
  });
  const outputProvider = instantiationService.createInstance(TerminalOutputProvider);
  const quickPick = quickInputService.createQuickPick();
  const originalItems = items;
  quickPick.items = [...originalItems];
  quickPick.sortByLabel = false;
  quickPick.placeholder = placeholder;
  quickPick.matchOnLabelMode = filterMode || "contiguous";
  quickPick.toggles = [fuzzySearchToggle];
  quickPick.onDidTriggerItemButton(async (e) => {
    var _a3, _b2;
    if (e.button === removeFromCommandHistoryButton) {
      if (type === "command") {
        (_a3 = instantiationService.invokeFunction(getCommandHistory)) == null ? void 0 : _a3.remove(e.item.label);
      } else {
        (_b2 = instantiationService.invokeFunction(getDirectoryHistory)) == null ? void 0 : _b2.remove(e.item.label);
      }
    } else if (e.button === commandOutputButton) {
      const selectedCommand = e.item.command;
      const output = selectedCommand == null ? void 0 : selectedCommand.getOutput();
      if (output && (selectedCommand == null ? void 0 : selectedCommand.command)) {
        const textContent = await outputProvider.provideTextContent(URI.from({
          scheme: TerminalOutputProvider.scheme,
          path: `${selectedCommand.command}... ${fromNow(selectedCommand.timestamp, true)}`,
          fragment: output,
          query: `terminal-output-${selectedCommand.timestamp}-${instance.instanceId}`
        }));
        if (textContent) {
          await editorService.openEditor({
            resource: textContent.uri
          });
        }
      }
    }
    await instantiationService.invokeFunction(showRunRecentQuickPick, instance, terminalInRunCommandPicker, type, filterMode, value);
  });
  quickPick.onDidChangeValue(async (value2) => {
    if (!value2) {
      await instantiationService.invokeFunction(showRunRecentQuickPick, instance, terminalInRunCommandPicker, type, filterMode, value2);
    }
  });
  quickPick.onDidAccept(async () => {
    const result = quickPick.activeItems[0];
    let text;
    if (type === "cwd") {
      text = `cd ${await instance.preparePathForShell(result.rawLabel)}`;
    } else {
      text = result.rawLabel;
    }
    quickPick.hide();
    instance.runCommand(text, !quickPick.keyMods.alt);
    if (quickPick.keyMods.alt) {
      instance.focus();
    }
  });
  if (value) {
    quickPick.value = value;
  }
  return new Promise((r) => {
    terminalInRunCommandPicker.set(true);
    showWithPinnedItems(storageService, runRecentStorageKey, quickPick, true);
    quickPick.onDidHide(() => {
      terminalInRunCommandPicker.set(false);
      r();
    });
  });
}
let TerminalOutputProvider = (_F = class {
  constructor(textModelResolverService, _modelService) {
    this._modelService = _modelService;
    textModelResolverService.registerTextModelContentProvider(_F.scheme, this);
  }
  async provideTextContent(resource) {
    const existing = this._modelService.getModel(resource);
    if (existing && !existing.isDisposed()) {
      return existing;
    }
    return this._modelService.createModel(resource.fragment, null, resource, false);
  }
}, _F.scheme = "TERMINAL_OUTPUT", _F);
TerminalOutputProvider = __decorate([
  __param(0, ITextModelService),
  __param(1, IModelService)
], TerminalOutputProvider);
let TerminalStatusList = class TerminalStatusList2 extends Disposable {
  get onDidAddStatus() {
    return this._onDidAddStatus.event;
  }
  get onDidRemoveStatus() {
    return this._onDidRemoveStatus.event;
  }
  get onDidChangePrimaryStatus() {
    return this._onDidChangePrimaryStatus.event;
  }
  constructor(_configurationService) {
    super();
    this._configurationService = _configurationService;
    this._statuses = /* @__PURE__ */ new Map();
    this._statusTimeouts = /* @__PURE__ */ new Map();
    this._onDidAddStatus = this._register(new Emitter());
    this._onDidRemoveStatus = this._register(new Emitter());
    this._onDidChangePrimaryStatus = this._register(new Emitter());
  }
  get primary() {
    let result;
    for (const s of this._statuses.values()) {
      if (!result || s.severity >= result.severity) {
        result = s;
      }
    }
    return result;
  }
  get statuses() {
    return Array.from(this._statuses.values());
  }
  add(status, duration) {
    status = this._applyAnimationSetting(status);
    const outTimeout = this._statusTimeouts.get(status.id);
    if (outTimeout) {
      window.clearTimeout(outTimeout);
      this._statusTimeouts.delete(status.id);
    }
    if (duration && duration > 0) {
      const timeout2 = window.setTimeout(() => this.remove(status), duration);
      this._statusTimeouts.set(status.id, timeout2);
    }
    const existingStatus = this._statuses.get(status.id);
    if (existingStatus && existingStatus !== status) {
      this._onDidRemoveStatus.fire(existingStatus);
      this._statuses.delete(existingStatus.id);
    }
    if (!this._statuses.has(status.id)) {
      const oldPrimary = this.primary;
      this._statuses.set(status.id, status);
      this._onDidAddStatus.fire(status);
      const newPrimary = this.primary;
      if (oldPrimary !== newPrimary) {
        this._onDidChangePrimaryStatus.fire(newPrimary);
      }
    }
  }
  remove(statusOrId) {
    var _a2;
    const status = typeof statusOrId === "string" ? this._statuses.get(statusOrId) : statusOrId;
    if (status && this._statuses.get(status.id)) {
      const wasPrimary = ((_a2 = this.primary) == null ? void 0 : _a2.id) === status.id;
      this._statuses.delete(status.id);
      this._onDidRemoveStatus.fire(status);
      if (wasPrimary) {
        this._onDidChangePrimaryStatus.fire(this.primary);
      }
    }
  }
  toggle(status, value) {
    if (value) {
      this.add(status);
    } else {
      this.remove(status);
    }
  }
  _applyAnimationSetting(status) {
    if (!status.icon || ThemeIcon.getModifier(status.icon) !== "spin" || this._configurationService.getValue("terminal.integrated.tabs.enableAnimation")) {
      return status;
    }
    let icon;
    if (status.icon.id === spinningLoading.id) {
      icon = Codicon.play;
    } else {
      icon = ThemeIcon.modify(status.icon, void 0);
    }
    return {
      ...status,
      icon
    };
  }
};
TerminalStatusList = __decorate([
  __param(0, IConfigurationService)
], TerminalStatusList);
function getColorForSeverity(severity) {
  switch (severity) {
    case Severity$1.Error:
      return listErrorForeground;
    case Severity$1.Warning:
      return listWarningForeground;
    default:
      return "";
  }
}
class TerminalWidgetManager {
  constructor() {
    this._attached = /* @__PURE__ */ new Map();
  }
  attachToElement(terminalWrapper) {
    if (!this._container) {
      this._container = document.createElement("div");
      this._container.classList.add("terminal-widget-container");
      terminalWrapper.appendChild(this._container);
    }
  }
  dispose() {
    if (this._container && this._container.parentElement) {
      this._container.parentElement.removeChild(this._container);
      this._container = void 0;
    }
  }
  attachWidget(widget) {
    var _a2;
    if (!this._container) {
      return;
    }
    (_a2 = this._attached.get(widget.id)) == null ? void 0 : _a2.dispose();
    widget.attach(this._container);
    this._attached.set(widget.id, widget);
    return {
      dispose: () => {
        const current = this._attached.get(widget.id);
        if (current === widget) {
          this._attached.delete(widget.id);
          widget.dispose();
        }
      }
    };
  }
}
class LineDataEventAddon extends Disposable {
  constructor(_initializationPromise) {
    super();
    this._initializationPromise = _initializationPromise;
    this._isOsSet = false;
    this._onLineData = this._register(new Emitter());
    this.onLineData = this._onLineData.event;
  }
  async activate(xterm2) {
    this._xterm = xterm2;
    await this._initializationPromise;
    this._register(xterm2.onLineFeed(() => {
      const buffer = xterm2.buffer;
      const newLine = buffer.active.getLine(buffer.active.baseY + buffer.active.cursorY);
      if (newLine && !newLine.isWrapped) {
        this._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY - 1);
      }
    }));
    this._register(toDisposable(() => {
      const buffer = xterm2.buffer;
      this._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY);
    }));
  }
  setOperatingSystem(os) {
    if (this._isOsSet || !this._xterm) {
      return;
    }
    this._isOsSet = true;
    if (os === 1) {
      const xterm2 = this._xterm;
      this._register(xterm2.parser.registerCsiHandler({ final: "H" }, () => {
        const buffer = xterm2.buffer;
        this._sendLineData(buffer.active, buffer.active.baseY + buffer.active.cursorY);
        return false;
      }));
    }
  }
  _sendLineData(buffer, lineIndex) {
    let line = buffer.getLine(lineIndex);
    if (!line) {
      return;
    }
    let lineData = line.translateToString(true);
    while (lineIndex > 0 && line.isWrapped) {
      line = buffer.getLine(--lineIndex);
      if (!line) {
        break;
      }
      lineData = line.translateToString(false) + lineData;
    }
    this._onLineData.fire(lineData);
  }
}
var xterm = { exports: {} };
var hasRequiredXterm;
function requireXterm() {
  if (hasRequiredXterm)
    return xterm.exports;
  hasRequiredXterm = 1;
  (function(module, exports) {
    !function(e, t) {
      module.exports = t();
    }(self, () => (() => {
      var e = { 4567: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AccessibilityManager = void 0;
        const n2 = i2(9042), o = i2(6114), a = i2(9924), h = i2(844), c = i2(5596), l = i2(4725), d = i2(3656);
        let _ = class extends h.Disposable {
          constructor(e3, t3) {
            super(), this._terminal = e3, this._renderService = t3, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
            for (let e4 = 0; e4 < this._terminal.rows; e4++)
              this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
            if (this._topBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 0), this._bottomBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new a.TimeBasedDebouncer(this._announceCharacters.bind(this))), !this._terminal.element)
              throw new Error("Cannot enable accessibility before Terminal.open");
            this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._liveRegionDebouncer), this.register(this._terminal.onResize((e4) => this._handleResize(e4.rows))), this.register(this._terminal.onRender((e4) => this._refreshRows(e4.start, e4.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((e4) => this._handleChar(e4))), this.register(this._terminal.onLineFeed(() => this._handleChar("\n"))), this.register(this._terminal.onA11yTab((e4) => this._handleTab(e4))), this.register(this._terminal.onKey((e4) => this._handleKey(e4.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new c.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, d.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, h.toDisposable)(() => {
              this._accessibilityContainer.remove(), this._rowElements.length = 0;
            }));
          }
          _handleTab(e3) {
            for (let t3 = 0; t3 < e3; t3++)
              this._handleChar(" ");
          }
          _handleChar(e3) {
            this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e3 && (this._charsToAnnounce += e3) : this._charsToAnnounce += e3, "\n" === e3 && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n2.tooMuchOutput)), o.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
              this._accessibilityContainer.appendChild(this._liveRegion);
            }, 0));
          }
          _clearLiveRegion() {
            this._liveRegion.textContent = "", this._liveRegionLineCount = 0, o.isMac && this._liveRegion.remove();
          }
          _handleKey(e3) {
            this._clearLiveRegion(), /\p{Control}/u.test(e3) || this._charsToConsume.push(e3);
          }
          _refreshRows(e3, t3) {
            this._liveRegionDebouncer.refresh(e3, t3, this._terminal.rows);
          }
          _announceCharacters() {
            0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
          }
          _handleBoundaryFocus(e3, t3) {
            const i3 = e3.target, s3 = this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2];
            if (i3.getAttribute("aria-posinset") === (0 === t3 ? "1" : `${this._terminal.buffer.lines.length}`))
              return;
            if (e3.relatedTarget !== s3)
              return;
            let r2, n3;
            if (0 === t3 ? (r2 = i3, n3 = this._rowElements.pop(), this._rowContainer.removeChild(n3)) : (r2 = this._rowElements.shift(), n3 = i3, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n3.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t3) {
              const e4 = this._createAccessibilityTreeNode();
              this._rowElements.unshift(e4), this._rowContainer.insertAdjacentElement("afterbegin", e4);
            } else {
              const e4 = this._createAccessibilityTreeNode();
              this._rowElements.push(e4), this._rowContainer.appendChild(e4);
            }
            this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t3 ? -1 : 1), this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2].focus(), e3.preventDefault(), e3.stopImmediatePropagation();
          }
          _handleResize(e3) {
            this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
            for (let e4 = this._rowContainer.children.length; e4 < this._terminal.rows; e4++)
              this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
            for (; this._rowElements.length > e3; )
              this._rowContainer.removeChild(this._rowElements.pop());
            this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
          }
          _createAccessibilityTreeNode() {
            const e3 = document.createElement("div");
            return e3.setAttribute("role", "listitem"), e3.tabIndex = -1, this._refreshRowDimensions(e3), e3;
          }
          _refreshRowsDimensions() {
            if (this._renderService.dimensions.css.cell.height) {
              this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
              for (let e3 = 0; e3 < this._terminal.rows; e3++)
                this._refreshRowDimensions(this._rowElements[e3]);
            }
          }
          _refreshRowDimensions(e3) {
            e3.style.height = `${this._renderService.dimensions.css.cell.height}px`;
          }
        };
        _ = s2([r(1, l.IRenderService)], _), t2.AccessibilityManager = _;
      }, 3614: (e2, t2) => {
        function i2(e3) {
          return e3.replace(/\r?\n/g, "\r");
        }
        function s2(e3, t3) {
          return t3 ? "\x1B[200~" + e3 + "\x1B[201~" : e3;
        }
        function r(e3, t3, r2) {
          e3 = s2(e3 = i2(e3), r2.decPrivateModes.bracketedPasteMode), r2.triggerDataEvent(e3, true), t3.value = "";
        }
        function n2(e3, t3, i3) {
          const s3 = i3.getBoundingClientRect(), r2 = e3.clientX - s3.left - 10, n3 = e3.clientY - s3.top - 10;
          t3.style.width = "20px", t3.style.height = "20px", t3.style.left = `${r2}px`, t3.style.top = `${n3}px`, t3.style.zIndex = "1000", t3.focus();
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.rightClickHandler = t2.moveTextAreaUnderMouseCursor = t2.paste = t2.handlePasteEvent = t2.copyHandler = t2.bracketTextForPaste = t2.prepareTextForTerminal = void 0, t2.prepareTextForTerminal = i2, t2.bracketTextForPaste = s2, t2.copyHandler = function(e3, t3) {
          e3.clipboardData && e3.clipboardData.setData("text/plain", t3.selectionText), e3.preventDefault();
        }, t2.handlePasteEvent = function(e3, t3, i3) {
          e3.stopPropagation(), e3.clipboardData && r(e3.clipboardData.getData("text/plain"), t3, i3);
        }, t2.paste = r, t2.moveTextAreaUnderMouseCursor = n2, t2.rightClickHandler = function(e3, t3, i3, s3, r2) {
          n2(e3, t3, i3), r2 && s3.rightClickSelect(e3), t3.value = s3.selectionText, t3.select();
        };
      }, 7239: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorContrastCache = void 0;
        const s2 = i2(1505);
        t2.ColorContrastCache = class {
          constructor() {
            this._color = new s2.TwoKeyMap(), this._css = new s2.TwoKeyMap();
          }
          setCss(e3, t3, i3) {
            this._css.set(e3, t3, i3);
          }
          getCss(e3, t3) {
            return this._css.get(e3, t3);
          }
          setColor(e3, t3, i3) {
            this._color.set(e3, t3, i3);
          }
          getColor(e3, t3) {
            return this._color.get(e3, t3);
          }
          clear() {
            this._color.clear(), this._css.clear();
          }
        };
      }, 3656: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.addDisposableDomListener = void 0, t2.addDisposableDomListener = function(e3, t3, i2, s2) {
          e3.addEventListener(t3, i2, s2);
          let r = false;
          return { dispose: () => {
            r || (r = true, e3.removeEventListener(t3, i2, s2));
          } };
        };
      }, 6465: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Linkifier2 = void 0;
        const n2 = i2(2585), o = i2(8460), a = i2(844), h = i2(3656);
        let c = class extends a.Disposable {
          constructor(e3) {
            super(), this._bufferService = e3, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)(() => {
              this._lastMouseEvent = void 0;
            })), this.register(this._bufferService.onResize(() => {
              this._clearCurrentLink(), this._wasResized = true;
            }));
          }
          get currentLink() {
            return this._currentLink;
          }
          registerLinkProvider(e3) {
            return this._linkProviders.push(e3), { dispose: () => {
              const t3 = this._linkProviders.indexOf(e3);
              -1 !== t3 && this._linkProviders.splice(t3, 1);
            } };
          }
          attachToDom(e3, t3, i3) {
            this._element = e3, this._mouseService = t3, this._renderService = i3, this.register((0, h.addDisposableDomListener)(this._element, "mouseleave", () => {
              this._isMouseOut = true, this._clearCurrentLink();
            })), this.register((0, h.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
          }
          _handleMouseMove(e3) {
            if (this._lastMouseEvent = e3, !this._element || !this._mouseService)
              return;
            const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
            if (!t3)
              return;
            this._isMouseOut = false;
            const i3 = e3.composedPath();
            for (let e4 = 0; e4 < i3.length; e4++) {
              const t4 = i3[e4];
              if (t4.classList.contains("xterm"))
                break;
              if (t4.classList.contains("xterm-hover"))
                return;
            }
            this._lastBufferCell && t3.x === this._lastBufferCell.x && t3.y === this._lastBufferCell.y || (this._handleHover(t3), this._lastBufferCell = t3);
          }
          _handleHover(e3) {
            if (this._activeLine !== e3.y || this._wasResized)
              return this._clearCurrentLink(), this._askForLink(e3, false), void (this._wasResized = false);
            this._currentLink && this._linkAtPosition(this._currentLink.link, e3) || (this._clearCurrentLink(), this._askForLink(e3, true));
          }
          _askForLink(e3, t3) {
            var i3, s3;
            this._activeProviderReplies && t3 || (null === (i3 = this._activeProviderReplies) || void 0 === i3 || i3.forEach((e4) => {
              null == e4 || e4.forEach((e5) => {
                e5.link.dispose && e5.link.dispose();
              });
            }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e3.y);
            let r2 = false;
            for (const [i4, n3] of this._linkProviders.entries())
              t3 ? (null === (s3 = this._activeProviderReplies) || void 0 === s3 ? void 0 : s3.get(i4)) && (r2 = this._checkLinkProviderResult(i4, e3, r2)) : n3.provideLinks(e3.y, (t4) => {
                var s4, n4;
                if (this._isMouseOut)
                  return;
                const o2 = null == t4 ? void 0 : t4.map((e4) => ({ link: e4 }));
                null === (s4 = this._activeProviderReplies) || void 0 === s4 || s4.set(i4, o2), r2 = this._checkLinkProviderResult(i4, e3, r2), (null === (n4 = this._activeProviderReplies) || void 0 === n4 ? void 0 : n4.size) === this._linkProviders.length && this._removeIntersectingLinks(e3.y, this._activeProviderReplies);
              });
          }
          _removeIntersectingLinks(e3, t3) {
            const i3 = /* @__PURE__ */ new Set();
            for (let s3 = 0; s3 < t3.size; s3++) {
              const r2 = t3.get(s3);
              if (r2)
                for (let t4 = 0; t4 < r2.length; t4++) {
                  const s4 = r2[t4], n3 = s4.link.range.start.y < e3 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e3 ? this._bufferService.cols : s4.link.range.end.x;
                  for (let e4 = n3; e4 <= o2; e4++) {
                    if (i3.has(e4)) {
                      r2.splice(t4--, 1);
                      break;
                    }
                    i3.add(e4);
                  }
                }
            }
          }
          _checkLinkProviderResult(e3, t3, i3) {
            var s3;
            if (!this._activeProviderReplies)
              return i3;
            const r2 = this._activeProviderReplies.get(e3);
            let n3 = false;
            for (let t4 = 0; t4 < e3; t4++)
              this._activeProviderReplies.has(t4) && !this._activeProviderReplies.get(t4) || (n3 = true);
            if (!n3 && r2) {
              const e4 = r2.find((e5) => this._linkAtPosition(e5.link, t3));
              e4 && (i3 = true, this._handleNewLink(e4));
            }
            if (this._activeProviderReplies.size === this._linkProviders.length && !i3)
              for (let e4 = 0; e4 < this._activeProviderReplies.size; e4++) {
                const r3 = null === (s3 = this._activeProviderReplies.get(e4)) || void 0 === s3 ? void 0 : s3.find((e5) => this._linkAtPosition(e5.link, t3));
                if (r3) {
                  i3 = true, this._handleNewLink(r3);
                  break;
                }
              }
            return i3;
          }
          _handleMouseDown() {
            this._mouseDownLink = this._currentLink;
          }
          _handleMouseUp(e3) {
            if (!this._element || !this._mouseService || !this._currentLink)
              return;
            const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
            t3 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t3) && this._currentLink.link.activate(e3, this._currentLink.link.text);
          }
          _clearCurrentLink(e3, t3) {
            this._element && this._currentLink && this._lastMouseEvent && (!e3 || !t3 || this._currentLink.link.range.start.y >= e3 && this._currentLink.link.range.end.y <= t3) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
          }
          _handleNewLink(e3) {
            if (!this._element || !this._lastMouseEvent || !this._mouseService)
              return;
            const t3 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
            t3 && this._linkAtPosition(e3.link, t3) && (this._currentLink = e3, this._currentLink.state = { decorations: { underline: void 0 === e3.link.decorations || e3.link.decorations.underline, pointerCursor: void 0 === e3.link.decorations || e3.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e3.link, this._lastMouseEvent), e3.link.decorations = {}, Object.defineProperties(e3.link.decorations, { pointerCursor: { get: () => {
              var e4, t4;
              return null === (t4 = null === (e4 = this._currentLink) || void 0 === e4 ? void 0 : e4.state) || void 0 === t4 ? void 0 : t4.decorations.pointerCursor;
            }, set: (e4) => {
              var t4, i3;
              (null === (t4 = this._currentLink) || void 0 === t4 ? void 0 : t4.state) && this._currentLink.state.decorations.pointerCursor !== e4 && (this._currentLink.state.decorations.pointerCursor = e4, this._currentLink.state.isHovered && (null === (i3 = this._element) || void 0 === i3 || i3.classList.toggle("xterm-cursor-pointer", e4)));
            } }, underline: { get: () => {
              var e4, t4;
              return null === (t4 = null === (e4 = this._currentLink) || void 0 === e4 ? void 0 : e4.state) || void 0 === t4 ? void 0 : t4.decorations.underline;
            }, set: (t4) => {
              var i3, s3, r2;
              (null === (i3 = this._currentLink) || void 0 === i3 ? void 0 : i3.state) && (null === (r2 = null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) || void 0 === r2 ? void 0 : r2.decorations.underline) !== t4 && (this._currentLink.state.decorations.underline = t4, this._currentLink.state.isHovered && this._fireUnderlineEvent(e3.link, t4));
            } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((e4) => {
              if (!this._currentLink)
                return;
              const t4 = 0 === e4.start ? 0 : e4.start + 1 + this._bufferService.buffer.ydisp, i3 = this._bufferService.buffer.ydisp + 1 + e4.end;
              if (this._currentLink.link.range.start.y >= t4 && this._currentLink.link.range.end.y <= i3 && (this._clearCurrentLink(t4, i3), this._lastMouseEvent && this._element)) {
                const e5 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                e5 && this._askForLink(e5, false);
              }
            })));
          }
          _linkHover(e3, t3, i3) {
            var s3;
            (null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, true), this._currentLink.state.decorations.pointerCursor && e3.classList.add("xterm-cursor-pointer")), t3.hover && t3.hover(i3, t3.text);
          }
          _fireUnderlineEvent(e3, t3) {
            const i3 = e3.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i3.start.x - 1, i3.start.y - s3 - 1, i3.end.x, i3.end.y - s3 - 1, void 0);
            (t3 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
          }
          _linkLeave(e3, t3, i3) {
            var s3;
            (null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, false), this._currentLink.state.decorations.pointerCursor && e3.classList.remove("xterm-cursor-pointer")), t3.leave && t3.leave(i3, t3.text);
          }
          _linkAtPosition(e3, t3) {
            const i3 = e3.range.start.y * this._bufferService.cols + e3.range.start.x, s3 = e3.range.end.y * this._bufferService.cols + e3.range.end.x, r2 = t3.y * this._bufferService.cols + t3.x;
            return i3 <= r2 && r2 <= s3;
          }
          _positionFromMouseEvent(e3, t3, i3) {
            const s3 = i3.getCoords(e3, t3, this._bufferService.cols, this._bufferService.rows);
            if (s3)
              return { x: s3[0], y: s3[1] + this._bufferService.buffer.ydisp };
          }
          _createLinkUnderlineEvent(e3, t3, i3, s3, r2) {
            return { x1: e3, y1: t3, x2: i3, y2: s3, cols: this._bufferService.cols, fg: r2 };
          }
        };
        c = s2([r(0, n2.IBufferService)], c), t2.Linkifier2 = c;
      }, 9042: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.tooMuchOutput = t2.promptLabel = void 0, t2.promptLabel = "Terminal input", t2.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
      }, 3730: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkProvider = void 0;
        const n2 = i2(511), o = i2(2585);
        let a = class {
          constructor(e3, t3, i3) {
            this._bufferService = e3, this._optionsService = t3, this._oscLinkService = i3;
          }
          provideLinks(e3, t3) {
            var i3;
            const s3 = this._bufferService.buffer.lines.get(e3 - 1);
            if (!s3)
              return void t3(void 0);
            const r2 = [], o2 = this._optionsService.rawOptions.linkHandler, a2 = new n2.CellData(), c = s3.getTrimmedLength();
            let l = -1, d = -1, _ = false;
            for (let t4 = 0; t4 < c; t4++)
              if (-1 !== d || s3.hasContent(t4)) {
                if (s3.loadCell(t4, a2), a2.hasExtendedAttrs() && a2.extended.urlId) {
                  if (-1 === d) {
                    d = t4, l = a2.extended.urlId;
                    continue;
                  }
                  _ = a2.extended.urlId !== l;
                } else
                  -1 !== d && (_ = true);
                if (_ || -1 !== d && t4 === c - 1) {
                  const s4 = null === (i3 = this._oscLinkService.getLinkData(l)) || void 0 === i3 ? void 0 : i3.uri;
                  if (s4) {
                    const i4 = { start: { x: d + 1, y: e3 }, end: { x: t4 + (_ || t4 !== c - 1 ? 0 : 1), y: e3 } };
                    let n3 = false;
                    if (!(null == o2 ? void 0 : o2.allowNonHttpProtocols))
                      try {
                        const e4 = new URL(s4);
                        ["http:", "https:"].includes(e4.protocol) || (n3 = true);
                      } catch (e4) {
                        n3 = true;
                      }
                    n3 || r2.push({ text: s4, range: i4, activate: (e4, t5) => o2 ? o2.activate(e4, t5, i4) : h(0, t5), hover: (e4, t5) => {
                      var s5;
                      return null === (s5 = null == o2 ? void 0 : o2.hover) || void 0 === s5 ? void 0 : s5.call(o2, e4, t5, i4);
                    }, leave: (e4, t5) => {
                      var s5;
                      return null === (s5 = null == o2 ? void 0 : o2.leave) || void 0 === s5 ? void 0 : s5.call(o2, e4, t5, i4);
                    } });
                  }
                  _ = false, a2.hasExtendedAttrs() && a2.extended.urlId ? (d = t4, l = a2.extended.urlId) : (d = -1, l = -1);
                }
              }
            t3(r2);
          }
        };
        function h(e3, t3) {
          if (confirm(`Do you want to navigate to ${t3}?

WARNING: This link could potentially be dangerous`)) {
            const e4 = window.open();
            if (e4) {
              try {
                e4.opener = null;
              } catch (e5) {
              }
              e4.location.href = t3;
            } else
              console.warn("Opening link blocked as opener could not be cleared");
          }
        }
        a = s2([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a), t2.OscLinkProvider = a;
      }, 6193: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderDebouncer = void 0, t2.RenderDebouncer = class {
          constructor(e3, t3) {
            this._parentWindow = e3, this._renderCallback = t3, this._refreshCallbacks = [];
          }
          dispose() {
            this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
          }
          addRefreshCallback(e3) {
            return this._refreshCallbacks.push(e3), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
          }
          refresh(e3, t3, i2) {
            this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount)
              return void this._runRefreshCallbacks();
            const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3), this._runRefreshCallbacks();
          }
          _runRefreshCallbacks() {
            for (const e3 of this._refreshCallbacks)
              e3(0);
            this._refreshCallbacks = [];
          }
        };
      }, 5596: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ScreenDprMonitor = void 0;
        const s2 = i2(844);
        class r extends s2.Disposable {
          constructor(e3) {
            super(), this._parentWindow = e3, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, s2.toDisposable)(() => {
              this.clearListener();
            }));
          }
          setListener(e3) {
            this._listener && this.clearListener(), this._listener = e3, this._outerListener = () => {
              this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
            }, this._updateDpr();
          }
          _updateDpr() {
            var e3;
            this._outerListener && (null === (e3 = this._resolutionMediaMatchList) || void 0 === e3 || e3.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
          }
          clearListener() {
            this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
          }
        }
        t2.ScreenDprMonitor = r;
      }, 3236: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Terminal = void 0;
        const s2 = i2(2950), r = i2(1680), n2 = i2(3614), o = i2(2584), a = i2(5435), h = i2(9312), c = i2(6114), l = i2(3656), d = i2(9042), _ = i2(4567), u = i2(1296), f = i2(7399), v = i2(8460), g = i2(8437), p = i2(3230), S = i2(4725), m = i2(428), C = i2(8934), b = i2(6465), y = i2(5114), w = i2(8969), E = i2(8055), L = i2(4269), k = i2(5941), R = i2(3107), D = i2(5744), A = i2(9074), x = i2(2585), B = i2(3730), T = i2(844), M = i2(6731), O = "undefined" != typeof window ? window.document : null;
        class I extends w.CoreTerminal {
          constructor(e3 = {}) {
            super(e3), this.browser = c, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._onCursorMove = this.register(new v.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new v.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new v.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new v.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new v.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new v.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new v.EventEmitter()), this._onBlur = this.register(new v.EventEmitter()), this._onA11yCharEmitter = this.register(new v.EventEmitter()), this._onA11yTabEmitter = this.register(new v.EventEmitter()), this._onWillOpen = this.register(new v.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(b.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(B.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(x.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e4, t3) => this.refresh(e4, t3))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((e4) => this._reportWindowsOptions(e4))), this.register(this._inputHandler.onColor((e4) => this._handleColorEvent(e4))), this.register((0, v.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, v.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, v.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, v.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((e4) => this._afterResize(e4.cols, e4.rows))), this.register((0, T.toDisposable)(() => {
              var e4, t3;
              this._customKeyEventHandler = void 0, null === (t3 = null === (e4 = this.element) || void 0 === e4 ? void 0 : e4.parentNode) || void 0 === t3 || t3.removeChild(this.element);
            }));
          }
          get onFocus() {
            return this._onFocus.event;
          }
          get onBlur() {
            return this._onBlur.event;
          }
          get onA11yChar() {
            return this._onA11yCharEmitter.event;
          }
          get onA11yTab() {
            return this._onA11yTabEmitter.event;
          }
          get onWillOpen() {
            return this._onWillOpen.event;
          }
          _handleColorEvent(e3) {
            if (this._themeService)
              for (const t3 of e3) {
                let e4, i3 = "";
                switch (t3.index) {
                  case 256:
                    e4 = "foreground", i3 = "10";
                    break;
                  case 257:
                    e4 = "background", i3 = "11";
                    break;
                  case 258:
                    e4 = "cursor", i3 = "12";
                    break;
                  default:
                    e4 = "ansi", i3 = "4;" + t3.index;
                }
                switch (t3.type) {
                  case 0:
                    const s3 = E.color.toColorRGB("ansi" === e4 ? this._themeService.colors.ansi[t3.index] : this._themeService.colors[e4]);
                    this.coreService.triggerDataEvent(`${o.C0.ESC}]${i3};${(0, k.toRgbString)(s3)}${o.C1_ESCAPED.ST}`);
                    break;
                  case 1:
                    if ("ansi" === e4)
                      this._themeService.modifyColors((e5) => e5.ansi[t3.index] = E.rgba.toColor(...t3.color));
                    else {
                      const i4 = e4;
                      this._themeService.modifyColors((e5) => e5[i4] = E.rgba.toColor(...t3.color));
                    }
                    break;
                  case 2:
                    this._themeService.restoreColor(t3.index);
                }
              }
          }
          _setup() {
            super._setup(), this._customKeyEventHandler = void 0;
          }
          get buffer() {
            return this.buffers.active;
          }
          focus() {
            this.textarea && this.textarea.focus({ preventScroll: true });
          }
          _handleScreenReaderModeOptionChange(e3) {
            var t3;
            e3 ? !this._accessibilityManager && this._renderService && (this._accessibilityManager = this._instantiationService.createInstance(_.AccessibilityManager, this)) : (null === (t3 = this._accessibilityManager) || void 0 === t3 || t3.dispose(), this._accessibilityManager = void 0);
          }
          _handleTextAreaFocus(e3) {
            this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(o.C0.ESC + "[I"), this.updateCursorStyle(e3), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
          }
          blur() {
            var e3;
            return null === (e3 = this.textarea) || void 0 === e3 ? void 0 : e3.blur();
          }
          _handleTextAreaBlur() {
            this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(o.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
          }
          _syncTextArea() {
            if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService)
              return;
            const e3 = this.buffer.ybase + this.buffer.y, t3 = this.buffer.lines.get(e3);
            if (!t3)
              return;
            const i3 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t3.getWidth(i3), n3 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i3 * this._renderService.dimensions.css.cell.width;
            this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n3 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
          }
          _initGlobal() {
            this._bindKeys(), this.register((0, l.addDisposableDomListener)(this.element, "copy", (e4) => {
              this.hasSelection() && (0, n2.copyHandler)(e4, this._selectionService);
            }));
            const e3 = (e4) => (0, n2.handlePasteEvent)(e4, this.textarea, this.coreService);
            this.register((0, l.addDisposableDomListener)(this.textarea, "paste", e3)), this.register((0, l.addDisposableDomListener)(this.element, "paste", e3)), c.isFirefox ? this.register((0, l.addDisposableDomListener)(this.element, "mousedown", (e4) => {
              2 === e4.button && (0, n2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })) : this.register((0, l.addDisposableDomListener)(this.element, "contextmenu", (e4) => {
              (0, n2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            })), c.isLinux && this.register((0, l.addDisposableDomListener)(this.element, "auxclick", (e4) => {
              1 === e4.button && (0, n2.moveTextAreaUnderMouseCursor)(e4, this.textarea, this.screenElement);
            }));
          }
          _bindKeys() {
            this.register((0, l.addDisposableDomListener)(this.textarea, "keyup", (e3) => this._keyUp(e3), true)), this.register((0, l.addDisposableDomListener)(this.textarea, "keydown", (e3) => this._keyDown(e3), true)), this.register((0, l.addDisposableDomListener)(this.textarea, "keypress", (e3) => this._keyPress(e3), true)), this.register((0, l.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, l.addDisposableDomListener)(this.textarea, "compositionupdate", (e3) => this._compositionHelper.compositionupdate(e3))), this.register((0, l.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, l.addDisposableDomListener)(this.textarea, "input", (e3) => this._inputEvent(e3), true)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
          }
          open(e3) {
            var t3;
            if (!e3)
              throw new Error("Terminal requires a parent element.");
            e3.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = e3.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e3.appendChild(this.element);
            const i3 = O.createDocumentFragment();
            this._viewportElement = O.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), i3.appendChild(this._viewportElement), this._viewportScrollArea = O.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = O.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = O.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), i3.appendChild(this.screenElement), this.textarea = O.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", d.promptLabel), c.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(y.CoreBrowserService, this.textarea, null !== (t3 = this._document.defaultView) && void 0 !== t3 ? t3 : window), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, l.addDisposableDomListener)(this.textarea, "focus", (e4) => this._handleTextAreaFocus(e4))), this.register((0, l.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(m.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(M.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(L.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(p.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((e4) => this._onRender.fire(e4))), this.onResize((e4) => this._renderService.resize(e4.cols, e4.rows)), this._compositionView = O.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(s2.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(i3);
            try {
              this._onWillOpen.fire(this.element);
            } catch (e4) {
            }
            this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(C.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(r.Viewport, (e4) => this.scrollLines(e4, true, 1), this._viewportElement, this._viewportScrollArea), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
              this._renderService.handleCursorMove(), this._syncTextArea();
            })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(h.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((e4) => this._renderService.handleSelectionChanged(e4.start, e4.end, e4.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((e4) => {
              this.textarea.value = e4, this.textarea.focus(), this.textarea.select();
            })), this.register(this._onScroll.event((e4) => {
              this.viewport.syncScrollArea(), this._selectionService.refresh();
            })), this.register((0, l.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(R.BufferDecorationRenderer, this.screenElement)), this.register((0, l.addDisposableDomListener)(this.element, "mousedown", (e4) => this._selectionService.handleMouseDown(e4))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager = this._instantiationService.createInstance(_.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (e4) => this._handleScreenReaderModeOptionChange(e4))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(D.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (e4) => {
              !this._overviewRulerRenderer && e4 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(D.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
            }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
          }
          _createRenderer() {
            return this._instantiationService.createInstance(u.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
          }
          bindMouse() {
            const e3 = this, t3 = this.element;
            function i3(t4) {
              const i4 = e3._mouseService.getMouseReportCoords(t4, e3.screenElement);
              if (!i4)
                return false;
              let s4, r3;
              switch (t4.overrideType || t4.type) {
                case "mousemove":
                  r3 = 32, void 0 === t4.buttons ? (s4 = 3, void 0 !== t4.button && (s4 = t4.button < 3 ? t4.button : 3)) : s4 = 1 & t4.buttons ? 0 : 4 & t4.buttons ? 1 : 2 & t4.buttons ? 2 : 3;
                  break;
                case "mouseup":
                  r3 = 0, s4 = t4.button < 3 ? t4.button : 3;
                  break;
                case "mousedown":
                  r3 = 1, s4 = t4.button < 3 ? t4.button : 3;
                  break;
                case "wheel":
                  if (0 === e3.viewport.getLinesScrolled(t4))
                    return false;
                  r3 = t4.deltaY < 0 ? 0 : 1, s4 = 4;
                  break;
                default:
                  return false;
              }
              return !(void 0 === r3 || void 0 === s4 || s4 > 4) && e3.coreMouseService.triggerMouseEvent({ col: i4.col, row: i4.row, x: i4.x, y: i4.y, button: s4, action: r3, ctrl: t4.ctrlKey, alt: t4.altKey, shift: t4.shiftKey });
            }
            const s3 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, r2 = { mouseup: (e4) => (i3(e4), e4.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e4)), wheel: (e4) => (i3(e4), this.cancel(e4, true)), mousedrag: (e4) => {
              e4.buttons && i3(e4);
            }, mousemove: (e4) => {
              e4.buttons || i3(e4);
            } };
            this.register(this.coreMouseService.onProtocolChange((e4) => {
              e4 ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e4)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e4 ? s3.mousemove || (t3.addEventListener("mousemove", r2.mousemove), s3.mousemove = r2.mousemove) : (t3.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e4 ? s3.wheel || (t3.addEventListener("wheel", r2.wheel, { passive: false }), s3.wheel = r2.wheel) : (t3.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e4 ? s3.mouseup || (s3.mouseup = r2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e4 ? s3.mousedrag || (s3.mousedrag = r2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
            })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, l.addDisposableDomListener)(t3, "mousedown", (e4) => {
              if (e4.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e4))
                return i3(e4), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e4);
            })), this.register((0, l.addDisposableDomListener)(t3, "wheel", (e4) => {
              if (!s3.wheel) {
                if (!this.buffer.hasScrollback) {
                  const t4 = this.viewport.getLinesScrolled(e4);
                  if (0 === t4)
                    return;
                  const i4 = o.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e4.deltaY < 0 ? "A" : "B");
                  let s4 = "";
                  for (let e5 = 0; e5 < Math.abs(t4); e5++)
                    s4 += i4;
                  return this.coreService.triggerDataEvent(s4, true), this.cancel(e4, true);
                }
                return this.viewport.handleWheel(e4) ? this.cancel(e4) : void 0;
              }
            }, { passive: false })), this.register((0, l.addDisposableDomListener)(t3, "touchstart", (e4) => {
              if (!this.coreMouseService.areMouseEventsActive)
                return this.viewport.handleTouchStart(e4), this.cancel(e4);
            }, { passive: true })), this.register((0, l.addDisposableDomListener)(t3, "touchmove", (e4) => {
              if (!this.coreMouseService.areMouseEventsActive)
                return this.viewport.handleTouchMove(e4) ? void 0 : this.cancel(e4);
            }, { passive: false }));
          }
          refresh(e3, t3) {
            var i3;
            null === (i3 = this._renderService) || void 0 === i3 || i3.refreshRows(e3, t3);
          }
          updateCursorStyle(e3) {
            var t3;
            (null === (t3 = this._selectionService) || void 0 === t3 ? void 0 : t3.shouldColumnSelect(e3)) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
          }
          _showCursor() {
            this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
          }
          scrollLines(e3, t3, i3 = 0) {
            super.scrollLines(e3, t3, i3), this.refresh(0, this.rows - 1);
          }
          paste(e3) {
            (0, n2.paste)(e3, this.textarea, this.coreService);
          }
          attachCustomKeyEventHandler(e3) {
            this._customKeyEventHandler = e3;
          }
          registerLinkProvider(e3) {
            return this.linkifier2.registerLinkProvider(e3);
          }
          registerCharacterJoiner(e3) {
            if (!this._characterJoinerService)
              throw new Error("Terminal must be opened first");
            const t3 = this._characterJoinerService.register(e3);
            return this.refresh(0, this.rows - 1), t3;
          }
          deregisterCharacterJoiner(e3) {
            if (!this._characterJoinerService)
              throw new Error("Terminal must be opened first");
            this._characterJoinerService.deregister(e3) && this.refresh(0, this.rows - 1);
          }
          get markers() {
            return this.buffer.markers;
          }
          addMarker(e3) {
            return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e3);
          }
          registerDecoration(e3) {
            return this._decorationService.registerDecoration(e3);
          }
          hasSelection() {
            return !!this._selectionService && this._selectionService.hasSelection;
          }
          select(e3, t3, i3) {
            this._selectionService.setSelection(e3, t3, i3);
          }
          getSelection() {
            return this._selectionService ? this._selectionService.selectionText : "";
          }
          getSelectionPosition() {
            if (this._selectionService && this._selectionService.hasSelection)
              return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
          }
          clearSelection() {
            var e3;
            null === (e3 = this._selectionService) || void 0 === e3 || e3.clearSelection();
          }
          selectAll() {
            var e3;
            null === (e3 = this._selectionService) || void 0 === e3 || e3.selectAll();
          }
          selectLines(e3, t3) {
            var i3;
            null === (i3 = this._selectionService) || void 0 === i3 || i3.selectLines(e3, t3);
          }
          _keyDown(e3) {
            if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && false === this._customKeyEventHandler(e3))
              return false;
            const t3 = this.browser.isMac && this.options.macOptionIsMeta && e3.altKey;
            if (!t3 && !this._compositionHelper.keydown(e3))
              return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this._bufferService.scrollToBottom(), false;
            t3 || "Dead" !== e3.key && "AltGraph" !== e3.key || (this._unprocessedDeadKey = true);
            const i3 = (0, f.evaluateKeyboardEvent)(e3, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
            if (this.updateCursorStyle(e3), 3 === i3.type || 2 === i3.type) {
              const t4 = this.rows - 1;
              return this.scrollLines(2 === i3.type ? -t4 : t4), this.cancel(e3, true);
            }
            return 1 === i3.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e3) || (i3.cancel && this.cancel(e3, true), !i3.key || !!(e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && 1 === e3.key.length && e3.key.charCodeAt(0) >= 65 && e3.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i3.key !== o.C0.ETX && i3.key !== o.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: i3.key, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(i3.key, true), !this.optionsService.rawOptions.screenReaderMode || e3.altKey || e3.ctrlKey ? this.cancel(e3, true) : void (this._keyDownHandled = true))));
          }
          _isThirdLevelShift(e3, t3) {
            const i3 = e3.isMac && !this.options.macOptionIsMeta && t3.altKey && !t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.altKey && t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.getModifierState("AltGraph");
            return "keypress" === t3.type ? i3 : i3 && (!t3.keyCode || t3.keyCode > 47);
          }
          _keyUp(e3) {
            this._keyDownSeen = false, this._customKeyEventHandler && false === this._customKeyEventHandler(e3) || (function(e4) {
              return 16 === e4.keyCode || 17 === e4.keyCode || 18 === e4.keyCode;
            }(e3) || this.focus(), this.updateCursorStyle(e3), this._keyPressHandled = false);
          }
          _keyPress(e3) {
            let t3;
            if (this._keyPressHandled = false, this._keyDownHandled)
              return false;
            if (this._customKeyEventHandler && false === this._customKeyEventHandler(e3))
              return false;
            if (this.cancel(e3), e3.charCode)
              t3 = e3.charCode;
            else if (null === e3.which || void 0 === e3.which)
              t3 = e3.keyCode;
            else {
              if (0 === e3.which || 0 === e3.charCode)
                return false;
              t3 = e3.which;
            }
            return !(!t3 || (e3.altKey || e3.ctrlKey || e3.metaKey) && !this._isThirdLevelShift(this.browser, e3) || (t3 = String.fromCharCode(t3), this._onKey.fire({ key: t3, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(t3, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
          }
          _inputEvent(e3) {
            if (e3.data && "insertText" === e3.inputType && (!e3.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
              if (this._keyPressHandled)
                return false;
              this._unprocessedDeadKey = false;
              const t3 = e3.data;
              return this.coreService.triggerDataEvent(t3, true), this.cancel(e3), true;
            }
            return false;
          }
          resize(e3, t3) {
            e3 !== this.cols || t3 !== this.rows ? super.resize(e3, t3) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
          }
          _afterResize(e3, t3) {
            var i3, s3;
            null === (i3 = this._charSizeService) || void 0 === i3 || i3.measure(), null === (s3 = this.viewport) || void 0 === s3 || s3.syncScrollArea(true);
          }
          clear() {
            if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
              this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
              for (let e3 = 1; e3 < this.rows; e3++)
                this.buffer.lines.push(this.buffer.getBlankLine(g.DEFAULT_ATTR_DATA));
              this.refresh(0, this.rows - 1), this._onScroll.fire({ position: this.buffer.ydisp, source: 0 });
            }
          }
          reset() {
            var e3, t3;
            this.options.rows = this.rows, this.options.cols = this.cols;
            const i3 = this._customKeyEventHandler;
            this._setup(), super.reset(), null === (e3 = this._selectionService) || void 0 === e3 || e3.reset(), this._decorationService.reset(), this._customKeyEventHandler = i3, this.refresh(0, this.rows - 1), null === (t3 = this.viewport) || void 0 === t3 || t3.syncScrollArea();
          }
          clearTextureAtlas() {
            var e3;
            null === (e3 = this._renderService) || void 0 === e3 || e3.clearTextureAtlas();
          }
          _reportFocus() {
            var e3;
            (null === (e3 = this.element) || void 0 === e3 ? void 0 : e3.classList.contains("focus")) ? this.coreService.triggerDataEvent(o.C0.ESC + "[I") : this.coreService.triggerDataEvent(o.C0.ESC + "[O");
          }
          _reportWindowsOptions(e3) {
            if (this._renderService)
              switch (e3) {
                case a.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                  const e4 = this._renderService.dimensions.css.canvas.width.toFixed(0), t3 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                  this.coreService.triggerDataEvent(`${o.C0.ESC}[4;${t3};${e4}t`);
                  break;
                case a.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                  const i3 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
                  this.coreService.triggerDataEvent(`${o.C0.ESC}[6;${s3};${i3}t`);
              }
          }
          cancel(e3, t3) {
            if (this.options.cancelEvents || t3)
              return e3.preventDefault(), e3.stopPropagation(), false;
          }
        }
        t2.Terminal = I;
      }, 9924: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TimeBasedDebouncer = void 0, t2.TimeBasedDebouncer = class {
          constructor(e3, t3 = 1e3) {
            this._renderCallback = e3, this._debounceThresholdMS = t3, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
          }
          dispose() {
            this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
          }
          refresh(e3, t3, i2) {
            this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3;
            const s2 = Date.now();
            if (s2 - this._lastRefreshMs >= this._debounceThresholdMS)
              this._lastRefreshMs = s2, this._innerRefresh();
            else if (!this._additionalRefreshRequested) {
              const e4 = s2 - this._lastRefreshMs, t4 = this._debounceThresholdMS - e4;
              this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout(() => {
                this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
              }, t4);
            }
          }
          _innerRefresh() {
            if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount)
              return;
            const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3);
          }
        };
      }, 1680: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Viewport = void 0;
        const n2 = i2(844), o = i2(3656), a = i2(4725), h = i2(2585);
        let c = class extends n2.Disposable {
          constructor(e3, t3, i3, s3, r2, n3, a2, h2, c2) {
            super(), this._scrollLines = e3, this._viewportElement = t3, this._scrollArea = i3, this._bufferService = s3, this._optionsService = r2, this._charSizeService = n3, this._renderService = a2, this._coreBrowserService = h2, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, o.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((e4) => this._renderDimensions = e4)), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors((e4) => this._handleThemeChange(e4))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea(), 0);
          }
          _handleThemeChange(e3) {
            this._viewportElement.style.backgroundColor = e3.background.css;
          }
          _refresh(e3) {
            if (e3)
              return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
            null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
          }
          _innerRefresh() {
            if (this._charSizeService.height > 0) {
              this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
              const e4 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
              this._lastRecordedBufferHeight !== e4 && (this._lastRecordedBufferHeight = e4, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
            }
            const e3 = this._bufferService.buffer.ydisp * this._currentRowHeight;
            this._viewportElement.scrollTop !== e3 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e3), this._refreshAnimationFrame = null;
          }
          syncScrollArea(e3 = false) {
            if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length)
              return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e3);
            this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e3);
          }
          _handleScroll(e3) {
            if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent)
              return;
            if (this._ignoreNextScrollEvent)
              return this._ignoreNextScrollEvent = false, void this._scrollLines(0);
            const t3 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
            this._scrollLines(t3);
          }
          _smoothScroll() {
            if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target)
              return;
            const e3 = this._smoothScrollPercent();
            this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e3 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e3 < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
          }
          _smoothScrollPercent() {
            return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
          }
          _clearSmoothScrollState() {
            this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
          }
          _bubbleScroll(e3, t3) {
            const i3 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
            return !(t3 < 0 && 0 !== this._viewportElement.scrollTop || t3 > 0 && i3 < this._lastRecordedBufferHeight) || (e3.cancelable && e3.preventDefault(), false);
          }
          handleWheel(e3) {
            const t3 = this._getPixelsScrolled(e3);
            return 0 !== t3 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t3 : this._smoothScrollState.target += t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
          }
          _getPixelsScrolled(e3) {
            if (0 === e3.deltaY || e3.shiftKey)
              return 0;
            let t3 = this._applyScrollModifier(e3.deltaY, e3);
            return e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? t3 *= this._currentRowHeight : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._currentRowHeight * this._bufferService.rows), t3;
          }
          getBufferElements(e3, t3) {
            var i3;
            let s3, r2 = "";
            const n3 = [], o2 = null != t3 ? t3 : this._bufferService.buffer.lines.length, a2 = this._bufferService.buffer.lines;
            for (let t4 = e3; t4 < o2; t4++) {
              const e4 = a2.get(t4);
              if (!e4)
                continue;
              const o3 = null === (i3 = a2.get(t4 + 1)) || void 0 === i3 ? void 0 : i3.isWrapped;
              if (r2 += e4.translateToString(!o3), !o3 || t4 === a2.length - 1) {
                const e5 = document.createElement("div");
                e5.textContent = r2, n3.push(e5), r2.length > 0 && (s3 = e5), r2 = "";
              }
            }
            return { bufferElements: n3, cursorElement: s3 };
          }
          getLinesScrolled(e3) {
            if (0 === e3.deltaY || e3.shiftKey)
              return 0;
            let t3 = this._applyScrollModifier(e3.deltaY, e3);
            return e3.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t3 /= this._currentRowHeight + 0, this._wheelPartialScroll += t3, t3 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._bufferService.rows), t3;
          }
          _applyScrollModifier(e3, t3) {
            const i3 = this._optionsService.rawOptions.fastScrollModifier;
            return "alt" === i3 && t3.altKey || "ctrl" === i3 && t3.ctrlKey || "shift" === i3 && t3.shiftKey ? e3 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e3 * this._optionsService.rawOptions.scrollSensitivity;
          }
          handleTouchStart(e3) {
            this._lastTouchY = e3.touches[0].pageY;
          }
          handleTouchMove(e3) {
            const t3 = this._lastTouchY - e3.touches[0].pageY;
            return this._lastTouchY = e3.touches[0].pageY, 0 !== t3 && (this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
          }
        };
        c = s2([r(3, h.IBufferService), r(4, h.IOptionsService), r(5, a.ICharSizeService), r(6, a.IRenderService), r(7, a.ICoreBrowserService), r(8, a.IThemeService)], c), t2.Viewport = c;
      }, 3107: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferDecorationRenderer = void 0;
        const n2 = i2(3656), o = i2(4725), a = i2(844), h = i2(2585);
        let c = class extends a.Disposable {
          constructor(e3, t3, i3, s3) {
            super(), this._screenElement = e3, this._bufferService = t3, this._decorationService = i3, this._renderService = s3, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
              this._dimensionsChanged = true, this._queueRefresh();
            })), this.register((0, n2.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
            })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((e4) => this._removeDecoration(e4))), this.register((0, a.toDisposable)(() => {
              this._container.remove(), this._decorationElements.clear();
            }));
          }
          _queueRefresh() {
            void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback(() => {
              this._doRefreshDecorations(), this._animationFrame = void 0;
            }));
          }
          _doRefreshDecorations() {
            for (const e3 of this._decorationService.decorations)
              this._renderDecoration(e3);
            this._dimensionsChanged = false;
          }
          _renderDecoration(e3) {
            this._refreshStyle(e3), this._dimensionsChanged && this._refreshXPosition(e3);
          }
          _createElement(e3) {
            var t3, i3;
            const s3 = document.createElement("div");
            s3.classList.add("xterm-decoration"), s3.classList.toggle("xterm-decoration-top-layer", "top" === (null === (t3 = null == e3 ? void 0 : e3.options) || void 0 === t3 ? void 0 : t3.layer)), s3.style.width = `${Math.round((e3.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, s3.style.height = (e3.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", s3.style.top = (e3.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", s3.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
            const r2 = null !== (i3 = e3.options.x) && void 0 !== i3 ? i3 : 0;
            return r2 && r2 > this._bufferService.cols && (s3.style.display = "none"), this._refreshXPosition(e3, s3), s3;
          }
          _refreshStyle(e3) {
            const t3 = e3.marker.line - this._bufferService.buffers.active.ydisp;
            if (t3 < 0 || t3 >= this._bufferService.rows)
              e3.element && (e3.element.style.display = "none", e3.onRenderEmitter.fire(e3.element));
            else {
              let i3 = this._decorationElements.get(e3);
              i3 || (i3 = this._createElement(e3), e3.element = i3, this._decorationElements.set(e3, i3), this._container.appendChild(i3)), i3.style.top = t3 * this._renderService.dimensions.css.cell.height + "px", i3.style.display = this._altBufferIsActive ? "none" : "block", e3.onRenderEmitter.fire(i3);
            }
          }
          _refreshXPosition(e3, t3 = e3.element) {
            var i3;
            if (!t3)
              return;
            const s3 = null !== (i3 = e3.options.x) && void 0 !== i3 ? i3 : 0;
            "right" === (e3.options.anchor || "left") ? t3.style.right = s3 ? s3 * this._renderService.dimensions.css.cell.width + "px" : "" : t3.style.left = s3 ? s3 * this._renderService.dimensions.css.cell.width + "px" : "";
          }
          _removeDecoration(e3) {
            var t3;
            null === (t3 = this._decorationElements.get(e3)) || void 0 === t3 || t3.remove(), this._decorationElements.delete(e3), e3.dispose();
          }
        };
        c = s2([r(1, h.IBufferService), r(2, h.IDecorationService), r(3, o.IRenderService)], c), t2.BufferDecorationRenderer = c;
      }, 5871: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorZoneStore = void 0, t2.ColorZoneStore = class {
          constructor() {
            this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
          }
          get zones() {
            return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
          }
          clear() {
            this._zones.length = 0, this._zonePoolIndex = 0;
          }
          addDecoration(e3) {
            if (e3.options.overviewRulerOptions) {
              for (const t3 of this._zones)
                if (t3.color === e3.options.overviewRulerOptions.color && t3.position === e3.options.overviewRulerOptions.position) {
                  if (this._lineIntersectsZone(t3, e3.marker.line))
                    return;
                  if (this._lineAdjacentToZone(t3, e3.marker.line, e3.options.overviewRulerOptions.position))
                    return void this._addLineToZone(t3, e3.marker.line);
                }
              if (this._zonePoolIndex < this._zonePool.length)
                return this._zonePool[this._zonePoolIndex].color = e3.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e3.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e3.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e3.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
              this._zones.push({ color: e3.options.overviewRulerOptions.color, position: e3.options.overviewRulerOptions.position, startBufferLine: e3.marker.line, endBufferLine: e3.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
            }
          }
          setPadding(e3) {
            this._linePadding = e3;
          }
          _lineIntersectsZone(e3, t3) {
            return t3 >= e3.startBufferLine && t3 <= e3.endBufferLine;
          }
          _lineAdjacentToZone(e3, t3, i2) {
            return t3 >= e3.startBufferLine - this._linePadding[i2 || "full"] && t3 <= e3.endBufferLine + this._linePadding[i2 || "full"];
          }
          _addLineToZone(e3, t3) {
            e3.startBufferLine = Math.min(e3.startBufferLine, t3), e3.endBufferLine = Math.max(e3.endBufferLine, t3);
          }
        };
      }, 5744: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OverviewRulerRenderer = void 0;
        const n2 = i2(5871), o = i2(3656), a = i2(4725), h = i2(844), c = i2(2585), l = { full: 0, left: 0, center: 0, right: 0 }, d = { full: 0, left: 0, center: 0, right: 0 }, _ = { full: 0, left: 0, center: 0, right: 0 };
        let u = class extends h.Disposable {
          constructor(e3, t3, i3, s3, r2, o2, a2) {
            var c2;
            super(), this._viewportElement = e3, this._screenElement = t3, this._bufferService = i3, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowseService = a2, this._colorZoneStore = new n2.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), null === (c2 = this._viewportElement.parentElement) || void 0 === c2 || c2.insertBefore(this._canvas, this._viewportElement);
            const l2 = this._canvas.getContext("2d");
            if (!l2)
              throw new Error("Ctx cannot be null");
            this._ctx = l2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, h.toDisposable)(() => {
              var e4;
              null === (e4 = this._canvas) || void 0 === e4 || e4.remove();
            }));
          }
          get _width() {
            return this._optionsService.options.overviewRulerWidth || 0;
          }
          _registerDecorationListeners() {
            this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, true))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, true)));
          }
          _registerBufferChangeListeners() {
            this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
              this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
            })), this.register(this._bufferService.onScroll(() => {
              this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
            }));
          }
          _registerDimensionChangeListeners() {
            this.register(this._renderService.onRender(() => {
              this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
            })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(true))), this.register((0, o.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(true))), this._queueRefresh(true);
          }
          _refreshDrawConstants() {
            const e3 = Math.floor(this._canvas.width / 3), t3 = Math.ceil(this._canvas.width / 3);
            d.full = this._canvas.width, d.left = e3, d.center = t3, d.right = e3, this._refreshDrawHeightConstants(), _.full = 0, _.left = 0, _.center = d.left, _.right = d.left + d.center;
          }
          _refreshDrawHeightConstants() {
            l.full = Math.round(2 * this._coreBrowseService.dpr);
            const e3 = this._canvas.height / this._bufferService.buffer.lines.length, t3 = Math.round(Math.max(Math.min(e3, 12), 6) * this._coreBrowseService.dpr);
            l.left = t3, l.center = t3, l.right = t3;
          }
          _refreshColorZonePadding() {
            this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
          }
          _refreshCanvasDimensions() {
            this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
          }
          _refreshDecorations() {
            this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
            for (const e4 of this._decorationService.decorations)
              this._colorZoneStore.addDecoration(e4);
            this._ctx.lineWidth = 1;
            const e3 = this._colorZoneStore.zones;
            for (const t3 of e3)
              "full" !== t3.position && this._renderColorZone(t3);
            for (const t3 of e3)
              "full" === t3.position && this._renderColorZone(t3);
            this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
          }
          _renderColorZone(e3) {
            this._ctx.fillStyle = e3.color, this._ctx.fillRect(_[e3.position || "full"], Math.round((this._canvas.height - 1) * (e3.startBufferLine / this._bufferService.buffers.active.lines.length) - l[e3.position || "full"] / 2), d[e3.position || "full"], Math.round((this._canvas.height - 1) * ((e3.endBufferLine - e3.startBufferLine) / this._bufferService.buffers.active.lines.length) + l[e3.position || "full"]));
          }
          _queueRefresh(e3, t3) {
            this._shouldUpdateDimensions = e3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t3 || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
              this._refreshDecorations(), this._animationFrame = void 0;
            }));
          }
        };
        u = s2([r(2, c.IBufferService), r(3, c.IDecorationService), r(4, a.IRenderService), r(5, c.IOptionsService), r(6, a.ICoreBrowserService)], u), t2.OverviewRulerRenderer = u;
      }, 2950: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CompositionHelper = void 0;
        const n2 = i2(4725), o = i2(2585), a = i2(2584);
        let h = class {
          constructor(e3, t3, i3, s3, r2, n3) {
            this._textarea = e3, this._compositionView = t3, this._bufferService = i3, this._optionsService = s3, this._coreService = r2, this._renderService = n3, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
          }
          get isComposing() {
            return this._isComposing;
          }
          compositionstart() {
            this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
          }
          compositionupdate(e3) {
            this._compositionView.textContent = e3.data, this.updateCompositionElements(), setTimeout(() => {
              this._compositionPosition.end = this._textarea.value.length;
            }, 0);
          }
          compositionend() {
            this._finalizeComposition(true);
          }
          keydown(e3) {
            if (this._isComposing || this._isSendingComposition) {
              if (229 === e3.keyCode)
                return false;
              if (16 === e3.keyCode || 17 === e3.keyCode || 18 === e3.keyCode)
                return false;
              this._finalizeComposition(false);
            }
            return 229 !== e3.keyCode || (this._handleAnyTextareaChanges(), false);
          }
          _finalizeComposition(e3) {
            if (this._compositionView.classList.remove("active"), this._isComposing = false, e3) {
              const e4 = { start: this._compositionPosition.start, end: this._compositionPosition.end };
              this._isSendingComposition = true, setTimeout(() => {
                if (this._isSendingComposition) {
                  let t3;
                  this._isSendingComposition = false, e4.start += this._dataAlreadySent.length, t3 = this._isComposing ? this._textarea.value.substring(e4.start, e4.end) : this._textarea.value.substring(e4.start), t3.length > 0 && this._coreService.triggerDataEvent(t3, true);
                }
              }, 0);
            } else {
              this._isSendingComposition = false;
              const e4 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
              this._coreService.triggerDataEvent(e4, true);
            }
          }
          _handleAnyTextareaChanges() {
            const e3 = this._textarea.value;
            setTimeout(() => {
              if (!this._isComposing) {
                const t3 = this._textarea.value, i3 = t3.replace(e3, "");
                this._dataAlreadySent = i3, t3.length > e3.length ? this._coreService.triggerDataEvent(i3, true) : t3.length < e3.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t3.length === e3.length && t3 !== e3 && this._coreService.triggerDataEvent(t3, true);
              }
            }, 0);
          }
          updateCompositionElements(e3) {
            if (this._isComposing) {
              if (this._bufferService.buffer.isCursorInViewport) {
                const e4 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t3 = this._renderService.dimensions.css.cell.height, i3 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e4 * this._renderService.dimensions.css.cell.width;
                this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i3 + "px", this._compositionView.style.height = t3 + "px", this._compositionView.style.lineHeight = t3 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                const r2 = this._compositionView.getBoundingClientRect();
                this._textarea.style.left = s3 + "px", this._textarea.style.top = i3 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
              }
              e3 || setTimeout(() => this.updateCompositionElements(true), 0);
            }
          }
        };
        h = s2([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n2.IRenderService)], h), t2.CompositionHelper = h;
      }, 9806: (e2, t2) => {
        function i2(e3, t3, i3) {
          const s2 = i3.getBoundingClientRect(), r = e3.getComputedStyle(i3), n2 = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
          return [t3.clientX - s2.left - n2, t3.clientY - s2.top - o];
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getCoords = t2.getCoordsRelativeToElement = void 0, t2.getCoordsRelativeToElement = i2, t2.getCoords = function(e3, t3, s2, r, n2, o, a, h, c) {
          if (!o)
            return;
          const l = i2(e3, t3, s2);
          return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n2), l) : void 0;
        };
      }, 9504: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.moveToCellSequence = void 0;
        const s2 = i2(2584);
        function r(e3, t3, i3, s3) {
          const r2 = e3 - n2(e3, i3), a2 = t3 - n2(t3, i3), l = Math.abs(r2 - a2) - function(e4, t4, i4) {
            let s4 = 0;
            const r3 = e4 - n2(e4, i4), a3 = t4 - n2(t4, i4);
            for (let n3 = 0; n3 < Math.abs(r3 - a3); n3++) {
              const a4 = "A" === o(e4, t4) ? -1 : 1, h2 = i4.buffer.lines.get(r3 + a4 * n3);
              (null == h2 ? void 0 : h2.isWrapped) && s4++;
            }
            return s4;
          }(e3, t3, i3);
          return c(l, h(o(e3, t3), s3));
        }
        function n2(e3, t3) {
          let i3 = 0, s3 = t3.buffer.lines.get(e3), r2 = null == s3 ? void 0 : s3.isWrapped;
          for (; r2 && e3 >= 0 && e3 < t3.rows; )
            i3++, s3 = t3.buffer.lines.get(--e3), r2 = null == s3 ? void 0 : s3.isWrapped;
          return i3;
        }
        function o(e3, t3) {
          return e3 > t3 ? "A" : "B";
        }
        function a(e3, t3, i3, s3, r2, n3) {
          let o2 = e3, a2 = t3, h2 = "";
          for (; o2 !== i3 || a2 !== s3; )
            o2 += r2 ? 1 : -1, r2 && o2 > n3.cols - 1 ? (h2 += n3.buffer.translateBufferLineToString(a2, false, e3, o2), o2 = 0, e3 = 0, a2++) : !r2 && o2 < 0 && (h2 += n3.buffer.translateBufferLineToString(a2, false, 0, e3 + 1), o2 = n3.cols - 1, e3 = o2, a2--);
          return h2 + n3.buffer.translateBufferLineToString(a2, false, e3, o2);
        }
        function h(e3, t3) {
          const i3 = t3 ? "O" : "[";
          return s2.C0.ESC + i3 + e3;
        }
        function c(e3, t3) {
          e3 = Math.floor(e3);
          let i3 = "";
          for (let s3 = 0; s3 < e3; s3++)
            i3 += t3;
          return i3;
        }
        t2.moveToCellSequence = function(e3, t3, i3, s3) {
          const o2 = i3.buffer.x, l = i3.buffer.y;
          if (!i3.buffer.hasScrollback)
            return function(e4, t4, i4, s4, o3, l2) {
              return 0 === r(t4, s4, o3, l2).length ? "" : c(a(e4, t4, e4, t4 - n2(t4, o3), false, o3).length, h("D", l2));
            }(o2, l, 0, t3, i3, s3) + r(l, t3, i3, s3) + function(e4, t4, i4, s4, o3, l2) {
              let d2;
              d2 = r(t4, s4, o3, l2).length > 0 ? s4 - n2(s4, o3) : t4;
              const _2 = s4, u = function(e5, t5, i5, s5, o4, a2) {
                let h2;
                return h2 = r(i5, s5, o4, a2).length > 0 ? s5 - n2(s5, o4) : t5, e5 < i5 && h2 <= s5 || e5 >= i5 && h2 < s5 ? "C" : "D";
              }(e4, t4, i4, s4, o3, l2);
              return c(a(e4, d2, i4, _2, "C" === u, o3).length, h(u, l2));
            }(o2, l, e3, t3, i3, s3);
          let d;
          if (l === t3)
            return d = o2 > e3 ? "D" : "C", c(Math.abs(o2 - e3), h(d, s3));
          d = l > t3 ? "D" : "C";
          const _ = Math.abs(l - t3);
          return c(function(e4, t4) {
            return t4.cols - e4;
          }(l > t3 ? e3 : o2, i3) + (_ - 1) * i3.cols + 1 + ((l > t3 ? o2 : e3) - 1), h(d, s3));
        };
      }, 1296: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRenderer = void 0;
        const n2 = i2(3787), o = i2(2223), a = i2(6171), h = i2(4725), c = i2(8055), l = i2(8460), d = i2(844), _ = i2(2585), u = "xterm-dom-renderer-owner-", f = "xterm-focus";
        let v = 1, g = class extends d.Disposable {
          constructor(e3, t3, i3, s3, r2, o2, h2, c2, _2, f2) {
            super(), this._element = e3, this._screenElement = t3, this._viewportElement = i3, this._linkifier2 = s3, this._charSizeService = o2, this._optionsService = h2, this._bufferService = c2, this._coreBrowserService = _2, this._themeService = f2, this._terminalClass = v++, this._rowElements = [], this._cellToRowElements = [], this.onRequestRedraw = this.register(new l.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add("xterm-rows"), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add("xterm-selection"), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, a.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((e4) => this._injectCss(e4))), this._injectCss(this._themeService.colors), this._rowFactory = r2.createInstance(n2.DomRendererRowFactory, document), this._element.classList.add(u + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((e4) => this._handleLinkHover(e4))), this.register(this._linkifier2.onHideLinkUnderline((e4) => this._handleLinkLeave(e4))), this.register((0, d.toDisposable)(() => {
              this._element.classList.remove(u + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
            }));
          }
          _updateDimensions() {
            const e3 = this._coreBrowserService.dpr;
            this.dimensions.device.char.width = this._charSizeService.width * e3, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e3), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e3), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e3), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
            for (const e4 of this._rowElements)
              e4.style.width = `${this.dimensions.css.canvas.width}px`, e4.style.height = `${this.dimensions.css.cell.height}px`, e4.style.lineHeight = `${this.dimensions.css.cell.height}px`, e4.style.overflow = "hidden";
            this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
            const t3 = `${this._terminalSelector} .xterm-rows span { display: inline-block; height: 100%; vertical-align: top; width: ${this.dimensions.css.cell.width}px}`;
            this._dimensionsStyleElement.textContent = t3, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
          }
          _injectCss(e3) {
            this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
            let t3 = `${this._terminalSelector} .xterm-rows { color: ${e3.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px;}`;
            t3 += `${this._terminalSelector} .xterm-rows .xterm-dim { color: ${c.color.multiplyOpacity(e3.foreground, 0.5).css};}`, t3 += `${this._terminalSelector} span:not(.${n2.BOLD_CLASS}) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.${n2.BOLD_CLASS} { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.${n2.ITALIC_CLASS} { font-style: italic;}`, t3 += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  box-shadow: none; }}", t3 += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${e3.cursor.css};  color: ${e3.cursorAccent.css}; } 50% {  background-color: ${e3.cursorAccent.css};  color: ${e3.cursor.css}; }}`, t3 += `${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${n2.CURSOR_CLASS}.${n2.CURSOR_STYLE_BLOCK_CLASS} ,${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${n2.CURSOR_CLASS}.${n2.CURSOR_STYLE_BAR_CLASS} ,${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${n2.CURSOR_CLASS}.${n2.CURSOR_STYLE_UNDERLINE_CLASS} { outline: 1px solid ${e3.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .xterm-rows.xterm-focus .${n2.CURSOR_CLASS}.${n2.CURSOR_BLINK_CLASS}:not(.${n2.CURSOR_STYLE_BLOCK_CLASS}) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .xterm-rows.xterm-focus .${n2.CURSOR_CLASS}.${n2.CURSOR_BLINK_CLASS}.${n2.CURSOR_STYLE_BLOCK_CLASS} { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .xterm-rows.xterm-focus .${n2.CURSOR_CLASS}.${n2.CURSOR_STYLE_BLOCK_CLASS} { background-color: ${e3.cursor.css}; color: ${e3.cursorAccent.css};}${this._terminalSelector} .xterm-rows .${n2.CURSOR_CLASS}.${n2.CURSOR_STYLE_BAR_CLASS} { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e3.cursor.css} inset;}${this._terminalSelector} .xterm-rows .${n2.CURSOR_CLASS}.${n2.CURSOR_STYLE_UNDERLINE_CLASS} { box-shadow: 0 -1px 0 ${e3.cursor.css} inset;}`, t3 += `${this._terminalSelector} .xterm-selection { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .xterm-selection div { position: absolute; background-color: ${e3.selectionBackgroundOpaque.css};}${this._terminalSelector} .xterm-selection div { position: absolute; background-color: ${e3.selectionInactiveBackgroundOpaque.css};}`;
            for (const [i3, s3] of e3.ansi.entries())
              t3 += `${this._terminalSelector} .xterm-fg-${i3} { color: ${s3.css}; }${this._terminalSelector} .xterm-fg-${i3}.${n2.DIM_CLASS} { color: ${c.color.multiplyOpacity(s3, 0.5).css}; }${this._terminalSelector} .xterm-bg-${i3} { background-color: ${s3.css}; }`;
            t3 += `${this._terminalSelector} .xterm-fg-${o.INVERTED_DEFAULT_COLOR} { color: ${c.color.opaque(e3.background).css}; }${this._terminalSelector} .xterm-fg-${o.INVERTED_DEFAULT_COLOR}.${n2.DIM_CLASS} { color: ${c.color.multiplyOpacity(c.color.opaque(e3.background), 0.5).css}; }${this._terminalSelector} .xterm-bg-${o.INVERTED_DEFAULT_COLOR} { background-color: ${e3.foreground.css}; }`, this._themeStyleElement.textContent = t3;
          }
          handleDevicePixelRatioChange() {
            this._updateDimensions();
          }
          _refreshRowElements(e3, t3) {
            for (let e4 = this._rowElements.length; e4 <= t3; e4++) {
              const e5 = document.createElement("div");
              this._rowContainer.appendChild(e5), this._rowElements.push(e5);
            }
            for (; this._rowElements.length > t3; )
              this._rowContainer.removeChild(this._rowElements.pop());
          }
          handleResize(e3, t3) {
            this._refreshRowElements(e3, t3), this._updateDimensions();
          }
          handleCharSizeChanged() {
            this._updateDimensions();
          }
          handleBlur() {
            this._rowContainer.classList.remove(f);
          }
          handleFocus() {
            this._rowContainer.classList.add(f);
          }
          handleSelectionChanged(e3, t3, i3) {
            for (; this._selectionContainer.children.length; )
              this._selectionContainer.removeChild(this._selectionContainer.children[0]);
            if (this._rowFactory.handleSelectionChanged(e3, t3, i3), this.renderRows(0, this._bufferService.rows - 1), !e3 || !t3)
              return;
            const s3 = e3[1] - this._bufferService.buffer.ydisp, r2 = t3[1] - this._bufferService.buffer.ydisp, n3 = Math.max(s3, 0), o2 = Math.min(r2, this._bufferService.rows - 1);
            if (n3 >= this._bufferService.rows || o2 < 0)
              return;
            const a2 = document.createDocumentFragment();
            if (i3) {
              const i4 = e3[0] > t3[0];
              a2.appendChild(this._createSelectionElement(n3, i4 ? t3[0] : e3[0], i4 ? e3[0] : t3[0], o2 - n3 + 1));
            } else {
              const i4 = s3 === n3 ? e3[0] : 0, h2 = n3 === r2 ? t3[0] : this._bufferService.cols;
              a2.appendChild(this._createSelectionElement(n3, i4, h2));
              const c2 = o2 - n3 - 1;
              if (a2.appendChild(this._createSelectionElement(n3 + 1, 0, this._bufferService.cols, c2)), n3 !== o2) {
                const e4 = r2 === o2 ? t3[0] : this._bufferService.cols;
                a2.appendChild(this._createSelectionElement(o2, 0, e4));
              }
            }
            this._selectionContainer.appendChild(a2);
          }
          _createSelectionElement(e3, t3, i3, s3 = 1) {
            const r2 = document.createElement("div");
            return r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e3 * this.dimensions.css.cell.height + "px", r2.style.left = t3 * this.dimensions.css.cell.width + "px", r2.style.width = this.dimensions.css.cell.width * (i3 - t3) + "px", r2;
          }
          handleCursorMove() {
          }
          _handleOptionsChanged() {
            this._updateDimensions(), this._injectCss(this._themeService.colors);
          }
          clear() {
            for (const e3 of this._rowElements)
              e3.replaceChildren();
          }
          renderRows(e3, t3) {
            const i3 = this._bufferService.buffer.ybase + this._bufferService.buffer.y, s3 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), r2 = this._optionsService.rawOptions.cursorBlink;
            for (let n3 = e3; n3 <= t3; n3++) {
              const e4 = this._rowElements[n3], t4 = n3 + this._bufferService.buffer.ydisp, o2 = this._bufferService.buffer.lines.get(t4), a2 = this._optionsService.rawOptions.cursorStyle;
              this._cellToRowElements[n3] && this._cellToRowElements[n3].length === this._bufferService.cols || (this._cellToRowElements[n3] = new Int16Array(this._bufferService.cols)), e4.replaceChildren(this._rowFactory.createRow(o2, t4, t4 === i3, a2, s3, r2, this.dimensions.css.cell.width, this._bufferService.cols, this._cellToRowElements[n3]));
            }
          }
          get _terminalSelector() {
            return `.${u}${this._terminalClass}`;
          }
          _handleLinkHover(e3) {
            this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, true);
          }
          _handleLinkLeave(e3) {
            this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, false);
          }
          _setCellUnderline(e3, t3, i3, s3, r2, n3) {
            i3 < 0 && (e3 = 0), s3 < 0 && (t3 = 0);
            const o2 = this._cellToRowElements.length - 1;
            i3 = Math.max(Math.min(i3, o2), 0), s3 = Math.max(Math.min(s3, o2), 0);
            const a2 = this._cellToRowElements[i3], h2 = this._cellToRowElements[s3];
            if (!(e3 >= a2.length || t3 >= h2.length) && (e3 = a2[e3], t3 = h2[t3], -1 !== e3 && -1 !== t3))
              for (; e3 !== t3 || i3 !== s3; ) {
                const t4 = this._rowElements[i3];
                if (!t4)
                  return;
                const s4 = t4.children[e3];
                s4 && (s4.style.textDecoration = n3 ? "underline" : "none"), ++e3 >= r2 && (e3 = 0, i3++);
              }
          }
        };
        g = s2([r(4, _.IInstantiationService), r(5, h.ICharSizeService), r(6, _.IOptionsService), r(7, _.IBufferService), r(8, h.ICoreBrowserService), r(9, h.IThemeService)], g), t2.DomRenderer = g;
      }, 3787: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRendererRowFactory = t2.CURSOR_STYLE_UNDERLINE_CLASS = t2.CURSOR_STYLE_BAR_CLASS = t2.CURSOR_STYLE_BLOCK_CLASS = t2.CURSOR_BLINK_CLASS = t2.CURSOR_CLASS = t2.STRIKETHROUGH_CLASS = t2.OVERLINE_CLASS = t2.UNDERLINE_CLASS = t2.ITALIC_CLASS = t2.DIM_CLASS = t2.BOLD_CLASS = void 0;
        const n2 = i2(2223), o = i2(643), a = i2(511), h = i2(2585), c = i2(8055), l = i2(4725), d = i2(4269), _ = i2(6171), u = i2(3734);
        t2.BOLD_CLASS = "xterm-bold", t2.DIM_CLASS = "xterm-dim", t2.ITALIC_CLASS = "xterm-italic", t2.UNDERLINE_CLASS = "xterm-underline", t2.OVERLINE_CLASS = "xterm-overline", t2.STRIKETHROUGH_CLASS = "xterm-strikethrough", t2.CURSOR_CLASS = "xterm-cursor", t2.CURSOR_BLINK_CLASS = "xterm-cursor-blink", t2.CURSOR_STYLE_BLOCK_CLASS = "xterm-cursor-block", t2.CURSOR_STYLE_BAR_CLASS = "xterm-cursor-bar", t2.CURSOR_STYLE_UNDERLINE_CLASS = "xterm-cursor-underline";
        let f = class {
          constructor(e3, t3, i3, s3, r2, n3, o2) {
            this._document = e3, this._characterJoinerService = t3, this._optionsService = i3, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n3, this._themeService = o2, this._workCell = new a.CellData(), this._columnSelectMode = false;
          }
          handleSelectionChanged(e3, t3, i3) {
            this._selectionStart = e3, this._selectionEnd = t3, this._columnSelectMode = i3;
          }
          createRow(e3, i3, s3, r2, a2, h2, l2, _2, f2) {
            const g = this._document.createDocumentFragment(), p = this._characterJoinerService.getJoinedCharacters(i3);
            let S = 0;
            for (let t3 = Math.min(e3.length, _2) - 1; t3 >= 0; t3--)
              if (e3.loadCell(t3, this._workCell).getCode() !== o.NULL_CELL_CODE || s3 && t3 === a2) {
                S = t3 + 1;
                break;
              }
            const m = this._themeService.colors;
            let C = -1, b = 0;
            for (; b < S; b++) {
              e3.loadCell(b, this._workCell);
              let _3 = this._workCell.getWidth();
              if (0 === _3) {
                f2[b] = C;
                continue;
              }
              let S2 = false, y = b, w = this._workCell;
              if (p.length > 0 && b === p[0][0]) {
                S2 = true;
                const t3 = p.shift();
                w = new d.JoinedCellData(this._workCell, e3.translateToString(true, t3[0], t3[1]), t3[1] - t3[0]), y = t3[1] - 1, _3 = w.getWidth();
              }
              const E = this._document.createElement("span");
              if (_3 > 1 && (E.style.width = l2 * _3 + "px"), S2 && (E.style.display = "inline", a2 >= b && a2 <= y && (a2 = b)), !this._coreService.isCursorHidden && s3 && b === a2)
                switch (E.classList.add(t2.CURSOR_CLASS), h2 && E.classList.add(t2.CURSOR_BLINK_CLASS), r2) {
                  case "bar":
                    E.classList.add(t2.CURSOR_STYLE_BAR_CLASS);
                    break;
                  case "underline":
                    E.classList.add(t2.CURSOR_STYLE_UNDERLINE_CLASS);
                    break;
                  default:
                    E.classList.add(t2.CURSOR_STYLE_BLOCK_CLASS);
                }
              if (w.isBold() && E.classList.add(t2.BOLD_CLASS), w.isItalic() && E.classList.add(t2.ITALIC_CLASS), w.isDim() && E.classList.add(t2.DIM_CLASS), w.isInvisible() ? E.textContent = o.WHITESPACE_CELL_CHAR : E.textContent = w.getChars() || o.WHITESPACE_CELL_CHAR, w.isUnderline() && (E.classList.add(`${t2.UNDERLINE_CLASS}-${w.extended.underlineStyle}`), " " === E.textContent && (E.textContent = " "), !w.isUnderlineColorDefault()))
                if (w.isUnderlineColorRGB())
                  E.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(w.getUnderlineColor()).join(",")})`;
                else {
                  let e4 = w.getUnderlineColor();
                  this._optionsService.rawOptions.drawBoldTextInBrightColors && w.isBold() && e4 < 8 && (e4 += 8), E.style.textDecorationColor = m.ansi[e4].css;
                }
              w.isOverline() && (E.classList.add(t2.OVERLINE_CLASS), " " === E.textContent && (E.textContent = " ")), w.isStrikethrough() && E.classList.add(t2.STRIKETHROUGH_CLASS);
              let L = w.getFgColor(), k = w.getFgColorMode(), R = w.getBgColor(), D = w.getBgColorMode();
              const A = !!w.isInverse();
              if (A) {
                const e4 = L;
                L = R, R = e4;
                const t3 = k;
                k = D, D = t3;
              }
              let x, B, T = false;
              this._decorationService.forEachDecorationAtCell(b, i3, void 0, (e4) => {
                "top" !== e4.options.layer && T || (e4.backgroundColorRGB && (D = 50331648, R = e4.backgroundColorRGB.rgba >> 8 & 16777215, x = e4.backgroundColorRGB), e4.foregroundColorRGB && (k = 50331648, L = e4.foregroundColorRGB.rgba >> 8 & 16777215, B = e4.foregroundColorRGB), T = "top" === e4.options.layer);
              });
              const M = this._isCellInSelection(b, i3);
              let O;
              switch (T || m.selectionForeground && M && (k = 50331648, L = m.selectionForeground.rgba >> 8 & 16777215, B = m.selectionForeground), M && (x = this._coreBrowserService.isFocused ? m.selectionBackgroundOpaque : m.selectionInactiveBackgroundOpaque, T = true), T && E.classList.add("xterm-decoration-top"), D) {
                case 16777216:
                case 33554432:
                  O = m.ansi[R], E.classList.add(`xterm-bg-${R}`);
                  break;
                case 50331648:
                  O = c.rgba.toColor(R >> 16, R >> 8 & 255, 255 & R), this._addStyle(E, `background-color:#${v((R >>> 0).toString(16), "0", 6)}`);
                  break;
                default:
                  A ? (O = m.foreground, E.classList.add(`xterm-bg-${n2.INVERTED_DEFAULT_COLOR}`)) : O = m.background;
              }
              switch (x || w.isDim() && (x = c.color.multiplyOpacity(O, 0.5)), k) {
                case 16777216:
                case 33554432:
                  w.isBold() && L < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (L += 8), this._applyMinimumContrast(E, O, m.ansi[L], w, x, void 0) || E.classList.add(`xterm-fg-${L}`);
                  break;
                case 50331648:
                  const e4 = c.rgba.toColor(L >> 16 & 255, L >> 8 & 255, 255 & L);
                  this._applyMinimumContrast(E, O, e4, w, x, B) || this._addStyle(E, `color:#${v(L.toString(16), "0", 6)}`);
                  break;
                default:
                  this._applyMinimumContrast(E, O, m.foreground, w, x, void 0) || A && E.classList.add(`xterm-fg-${n2.INVERTED_DEFAULT_COLOR}`);
              }
              g.appendChild(E), f2[b] = ++C, b = y;
            }
            return b < _2 - 1 && f2.subarray(b).fill(++C), g;
          }
          _applyMinimumContrast(e3, t3, i3, s3, r2, n3) {
            if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.excludeFromContrastRatioDemands)(s3.getCode()))
              return false;
            let o2;
            return r2 || n3 || (o2 = this._themeService.colors.contrastCache.getColor(t3.rgba, i3.rgba)), void 0 === o2 && (o2 = c.color.ensureContrastRatio(r2 || t3, n3 || i3, this._optionsService.rawOptions.minimumContrastRatio), this._themeService.colors.contrastCache.setColor((r2 || t3).rgba, (n3 || i3).rgba, null != o2 ? o2 : null)), !!o2 && (this._addStyle(e3, `color:${o2.css}`), true);
          }
          _addStyle(e3, t3) {
            e3.setAttribute("style", `${e3.getAttribute("style") || ""}${t3};`);
          }
          _isCellInSelection(e3, t3) {
            const i3 = this._selectionStart, s3 = this._selectionEnd;
            return !(!i3 || !s3) && (this._columnSelectMode ? i3[0] <= s3[0] ? e3 >= i3[0] && t3 >= i3[1] && e3 < s3[0] && t3 <= s3[1] : e3 < i3[0] && t3 >= i3[1] && e3 >= s3[0] && t3 <= s3[1] : t3 > i3[1] && t3 < s3[1] || i3[1] === s3[1] && t3 === i3[1] && e3 >= i3[0] && e3 < s3[0] || i3[1] < s3[1] && t3 === s3[1] && e3 < s3[0] || i3[1] < s3[1] && t3 === i3[1] && e3 >= i3[0]);
          }
        };
        function v(e3, t3, i3) {
          for (; e3.length < i3; )
            e3 = t3 + e3;
          return e3;
        }
        f = s2([r(1, l.ICharacterJoinerService), r(2, h.IOptionsService), r(3, l.ICoreBrowserService), r(4, h.ICoreService), r(5, h.IDecorationService), r(6, l.IThemeService)], f), t2.DomRendererRowFactory = f;
      }, 2223: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TEXT_BASELINE = t2.DIM_OPACITY = t2.INVERTED_DEFAULT_COLOR = void 0;
        const s2 = i2(6114);
        t2.INVERTED_DEFAULT_COLOR = 257, t2.DIM_OPACITY = 0.5, t2.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
      }, 6171: (e2, t2) => {
        function i2(e3) {
          return 57508 <= e3 && e3 <= 57558;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createRenderDimensions = t2.excludeFromContrastRatioDemands = t2.isRestrictedPowerlineGlyph = t2.isPowerlineGlyph = t2.throwIfFalsy = void 0, t2.throwIfFalsy = function(e3) {
          if (!e3)
            throw new Error("value must not be falsy");
          return e3;
        }, t2.isPowerlineGlyph = i2, t2.isRestrictedPowerlineGlyph = function(e3) {
          return 57520 <= e3 && e3 <= 57527;
        }, t2.excludeFromContrastRatioDemands = function(e3) {
          return i2(e3) || function(e4) {
            return 9472 <= e4 && e4 <= 9631;
          }(e3);
        }, t2.createRenderDimensions = function() {
          return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
        };
      }, 456: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionModel = void 0, t2.SelectionModel = class {
          constructor(e3) {
            this._bufferService = e3, this.isSelectAllActive = false, this.selectionStartLength = 0;
          }
          clearSelection() {
            this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
          }
          get finalSelectionStart() {
            return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
          }
          get finalSelectionEnd() {
            if (this.isSelectAllActive)
              return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
            if (this.selectionStart) {
              if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                const e3 = this.selectionStart[0] + this.selectionStartLength;
                return e3 > this._bufferService.cols ? e3 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols) - 1] : [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [e3, this.selectionStart[1]];
              }
              if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                const e3 = this.selectionStart[0] + this.selectionStartLength;
                return e3 > this._bufferService.cols ? [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [Math.max(e3, this.selectionEnd[0]), this.selectionEnd[1]];
              }
              return this.selectionEnd;
            }
          }
          areSelectionValuesReversed() {
            const e3 = this.selectionStart, t3 = this.selectionEnd;
            return !(!e3 || !t3) && (e3[1] > t3[1] || e3[1] === t3[1] && e3[0] > t3[0]);
          }
          handleTrim(e3) {
            return this.selectionStart && (this.selectionStart[1] -= e3), this.selectionEnd && (this.selectionEnd[1] -= e3), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
          }
        };
      }, 428: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CharSizeService = void 0;
        const n2 = i2(2585), o = i2(8460), a = i2(844);
        let h = class extends a.Disposable {
          constructor(e3, t3, i3) {
            super(), this._optionsService = i3, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new c(e3, t3, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
          }
          get hasValidSize() {
            return this.width > 0 && this.height > 0;
          }
          measure() {
            const e3 = this._measureStrategy.measure();
            e3.width === this.width && e3.height === this.height || (this.width = e3.width, this.height = e3.height, this._onCharSizeChange.fire());
          }
        };
        h = s2([r(2, n2.IOptionsService)], h), t2.CharSizeService = h;
        class c {
          constructor(e3, t3, i3) {
            this._document = e3, this._parentElement = t3, this._optionsService = i3, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W", this._measureElement.setAttribute("aria-hidden", "true"), this._parentElement.appendChild(this._measureElement);
          }
          measure() {
            this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
            const e3 = this._measureElement.getBoundingClientRect();
            return 0 !== e3.width && 0 !== e3.height && (this._result.width = e3.width, this._result.height = Math.ceil(e3.height)), this._result;
          }
        }
      }, 4269: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CharacterJoinerService = t2.JoinedCellData = void 0;
        const n2 = i2(3734), o = i2(643), a = i2(511), h = i2(2585);
        class c extends n2.AttributeData {
          constructor(e3, t3, i3) {
            super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t3, this._width = i3;
          }
          isCombined() {
            return 2097152;
          }
          getWidth() {
            return this._width;
          }
          getChars() {
            return this.combinedData;
          }
          getCode() {
            return 2097151;
          }
          setFromCharData(e3) {
            throw new Error("not implemented");
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        t2.JoinedCellData = c;
        let l = class e3 {
          constructor(e4) {
            this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();
          }
          register(e4) {
            const t3 = { id: this._nextCharacterJoinerId++, handler: e4 };
            return this._characterJoiners.push(t3), t3.id;
          }
          deregister(e4) {
            for (let t3 = 0; t3 < this._characterJoiners.length; t3++)
              if (this._characterJoiners[t3].id === e4)
                return this._characterJoiners.splice(t3, 1), true;
            return false;
          }
          getJoinedCharacters(e4) {
            if (0 === this._characterJoiners.length)
              return [];
            const t3 = this._bufferService.buffer.lines.get(e4);
            if (!t3 || 0 === t3.length)
              return [];
            const i3 = [], s3 = t3.translateToString(true);
            let r2 = 0, n3 = 0, a2 = 0, h2 = t3.getFg(0), c2 = t3.getBg(0);
            for (let e5 = 0; e5 < t3.getTrimmedLength(); e5++)
              if (t3.loadCell(e5, this._workCell), 0 !== this._workCell.getWidth()) {
                if (this._workCell.fg !== h2 || this._workCell.bg !== c2) {
                  if (e5 - r2 > 1) {
                    const e6 = this._getJoinedRanges(s3, a2, n3, t3, r2);
                    for (let t4 = 0; t4 < e6.length; t4++)
                      i3.push(e6[t4]);
                  }
                  r2 = e5, a2 = n3, h2 = this._workCell.fg, c2 = this._workCell.bg;
                }
                n3 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
              }
            if (this._bufferService.cols - r2 > 1) {
              const e5 = this._getJoinedRanges(s3, a2, n3, t3, r2);
              for (let t4 = 0; t4 < e5.length; t4++)
                i3.push(e5[t4]);
            }
            return i3;
          }
          _getJoinedRanges(t3, i3, s3, r2, n3) {
            const o2 = t3.substring(i3, s3);
            let a2 = [];
            try {
              a2 = this._characterJoiners[0].handler(o2);
            } catch (e4) {
              console.error(e4);
            }
            for (let t4 = 1; t4 < this._characterJoiners.length; t4++)
              try {
                const i4 = this._characterJoiners[t4].handler(o2);
                for (let t5 = 0; t5 < i4.length; t5++)
                  e3._mergeRanges(a2, i4[t5]);
              } catch (e4) {
                console.error(e4);
              }
            return this._stringRangesToCellRanges(a2, r2, n3), a2;
          }
          _stringRangesToCellRanges(e4, t3, i3) {
            let s3 = 0, r2 = false, n3 = 0, a2 = e4[s3];
            if (a2) {
              for (let h2 = i3; h2 < this._bufferService.cols; h2++) {
                const i4 = t3.getWidth(h2), c2 = t3.getString(h2).length || o.WHITESPACE_CELL_CHAR.length;
                if (0 !== i4) {
                  if (!r2 && a2[0] <= n3 && (a2[0] = h2, r2 = true), a2[1] <= n3) {
                    if (a2[1] = h2, a2 = e4[++s3], !a2)
                      break;
                    a2[0] <= n3 ? (a2[0] = h2, r2 = true) : r2 = false;
                  }
                  n3 += c2;
                }
              }
              a2 && (a2[1] = this._bufferService.cols);
            }
          }
          static _mergeRanges(e4, t3) {
            let i3 = false;
            for (let s3 = 0; s3 < e4.length; s3++) {
              const r2 = e4[s3];
              if (i3) {
                if (t3[1] <= r2[0])
                  return e4[s3 - 1][1] = t3[1], e4;
                if (t3[1] <= r2[1])
                  return e4[s3 - 1][1] = Math.max(t3[1], r2[1]), e4.splice(s3, 1), e4;
                e4.splice(s3, 1), s3--;
              } else {
                if (t3[1] <= r2[0])
                  return e4.splice(s3, 0, t3), e4;
                if (t3[1] <= r2[1])
                  return r2[0] = Math.min(t3[0], r2[0]), e4;
                t3[0] < r2[1] && (r2[0] = Math.min(t3[0], r2[0]), i3 = true);
              }
            }
            return i3 ? e4[e4.length - 1][1] = t3[1] : e4.push(t3), e4;
          }
        };
        l = s2([r(0, h.IBufferService)], l), t2.CharacterJoinerService = l;
      }, 5114: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreBrowserService = void 0, t2.CoreBrowserService = class {
          constructor(e3, t3) {
            this._textarea = e3, this.window = t3, this._isFocused = false, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = true), this._textarea.addEventListener("blur", () => this._isFocused = false);
          }
          get dpr() {
            return this.window.devicePixelRatio;
          }
          get isFocused() {
            return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
          }
        };
      }, 8934: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.MouseService = void 0;
        const n2 = i2(4725), o = i2(9806);
        let a = class {
          constructor(e3, t3) {
            this._renderService = e3, this._charSizeService = t3;
          }
          getCoords(e3, t3, i3, s3, r2) {
            return (0, o.getCoords)(window, e3, t3, i3, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
          }
          getMouseReportCoords(e3, t3) {
            const i3 = (0, o.getCoordsRelativeToElement)(window, e3, t3);
            if (!(!this._charSizeService.hasValidSize || i3[0] < 0 || i3[1] < 0 || i3[0] >= this._renderService.dimensions.css.canvas.width || i3[1] >= this._renderService.dimensions.css.canvas.height))
              return { col: Math.floor(i3[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(i3[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(i3[0]), y: Math.floor(i3[1]) };
          }
        };
        a = s2([r(0, n2.IRenderService), r(1, n2.ICharSizeService)], a), t2.MouseService = a;
      }, 3230: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderService = void 0;
        const n2 = i2(6193), o = i2(8460), a = i2(844), h = i2(5596), c = i2(3656), l = i2(2585), d = i2(4725), _ = i2(7226);
        let u = class extends a.Disposable {
          constructor(e3, t3, i3, s3, r2, a2, l2, d2) {
            if (super(), this._rowCount = e3, this._charSizeService = s3, this._pausedResizeTask = new _.DebouncedIdleTask(), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: false }, this._onDimensionsChange = this.register(new o.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new o.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new o.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new o.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this.register({ dispose: () => {
              var e4;
              return null === (e4 = this._renderer) || void 0 === e4 ? void 0 : e4.dispose();
            } }), this._renderDebouncer = new n2.RenderDebouncer(l2.window, (e4, t4) => this._renderRows(e4, t4)), this.register(this._renderDebouncer), this._screenDprMonitor = new h.ScreenDprMonitor(l2.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(a2.onResize(() => this._fullRefresh())), this.register(a2.buffers.onBufferActivate(() => {
              var e4;
              return null === (e4 = this._renderer) || void 0 === e4 ? void 0 : e4.clear();
            })), this.register(i3.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(r2.onDecorationRegistered(() => this._fullRefresh())), this.register(r2.onDecorationRemoved(() => this._fullRefresh())), this.register(i3.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
              this.clear(), this.handleResize(a2.cols, a2.rows), this._fullRefresh();
            })), this.register(i3.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(a2.buffer.y, a2.buffer.y, true))), this.register((0, c.addDisposableDomListener)(l2.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(d2.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in l2.window) {
              const e4 = new l2.window.IntersectionObserver((e5) => this._handleIntersectionChange(e5[e5.length - 1]), { threshold: 0 });
              e4.observe(t3), this.register({ dispose: () => e4.disconnect() });
            }
          }
          get dimensions() {
            return this._renderer.dimensions;
          }
          _handleIntersectionChange(e3) {
            this._isPaused = void 0 === e3.isIntersecting ? 0 === e3.intersectionRatio : !e3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
          }
          refreshRows(e3, t3, i3 = false) {
            this._isPaused ? this._needsFullRefresh = true : (i3 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e3, t3, this._rowCount));
          }
          _renderRows(e3, t3) {
            this._renderer && (e3 = Math.min(e3, this._rowCount - 1), t3 = Math.min(t3, this._rowCount - 1), this._renderer.renderRows(e3, t3), this._needsSelectionRefresh && (this._renderer.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: e3, end: t3 }), this._onRender.fire({ start: e3, end: t3 }), this._isNextRenderRedrawOnly = true);
          }
          resize(e3, t3) {
            this._rowCount = t3, this._fireOnCanvasResize();
          }
          _handleOptionsChanged() {
            this._renderer && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
          }
          _fireOnCanvasResize() {
            this._renderer && (this._renderer.dimensions.css.canvas.width === this._canvasWidth && this._renderer.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.dimensions));
          }
          hasRenderer() {
            return !!this._renderer;
          }
          setRenderer(e3) {
            var t3;
            null === (t3 = this._renderer) || void 0 === t3 || t3.dispose(), this._renderer = e3, this._renderer.onRequestRedraw((e4) => this.refreshRows(e4.start, e4.end, true)), this._needsSelectionRefresh = true, this._fullRefresh();
          }
          addRefreshCallback(e3) {
            return this._renderDebouncer.addRefreshCallback(e3);
          }
          _fullRefresh() {
            this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
          }
          clearTextureAtlas() {
            var e3, t3;
            this._renderer && (null === (t3 = (e3 = this._renderer).clearTextureAtlas) || void 0 === t3 || t3.call(e3), this._fullRefresh());
          }
          handleDevicePixelRatioChange() {
            this._charSizeService.measure(), this._renderer && (this._renderer.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
          }
          handleResize(e3, t3) {
            this._renderer && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.handleResize(e3, t3)) : this._renderer.handleResize(e3, t3), this._fullRefresh());
          }
          handleCharSizeChanged() {
            var e3;
            null === (e3 = this._renderer) || void 0 === e3 || e3.handleCharSizeChanged();
          }
          handleBlur() {
            var e3;
            null === (e3 = this._renderer) || void 0 === e3 || e3.handleBlur();
          }
          handleFocus() {
            var e3;
            null === (e3 = this._renderer) || void 0 === e3 || e3.handleFocus();
          }
          handleSelectionChanged(e3, t3, i3) {
            var s3;
            this._selectionState.start = e3, this._selectionState.end = t3, this._selectionState.columnSelectMode = i3, null === (s3 = this._renderer) || void 0 === s3 || s3.handleSelectionChanged(e3, t3, i3);
          }
          handleCursorMove() {
            var e3;
            null === (e3 = this._renderer) || void 0 === e3 || e3.handleCursorMove();
          }
          clear() {
            var e3;
            null === (e3 = this._renderer) || void 0 === e3 || e3.clear();
          }
        };
        u = s2([r(2, l.IOptionsService), r(3, d.ICharSizeService), r(4, l.IDecorationService), r(5, l.IBufferService), r(6, d.ICoreBrowserService), r(7, d.IThemeService)], u), t2.RenderService = u;
      }, 9312: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionService = void 0;
        const n2 = i2(6114), o = i2(456), a = i2(511), h = i2(8460), c = i2(4725), l = i2(2585), d = i2(9806), _ = i2(9504), u = i2(844), f = i2(4841), v = String.fromCharCode(160), g = new RegExp(v, "g");
        let p = class extends u.Disposable {
          constructor(e3, t3, i3, s3, r2, n3, c2, l2, d2) {
            super(), this._element = e3, this._screenElement = t3, this._linkifier = i3, this._bufferService = s3, this._coreService = r2, this._mouseService = n3, this._optionsService = c2, this._renderService = l2, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new a.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new h.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new h.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new h.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new h.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e4) => this._handleMouseMove(e4), this._mouseUpListener = (e4) => this._handleMouseUp(e4), this._coreService.onUserInput(() => {
              this.hasSelection && this.clearSelection();
            }), this._trimListener = this._bufferService.buffer.lines.onTrim((e4) => this._handleTrim(e4)), this.register(this._bufferService.buffers.onBufferActivate((e4) => this._handleBufferActivate(e4))), this.enable(), this._model = new o.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, u.toDisposable)(() => {
              this._removeMouseDownListeners();
            }));
          }
          reset() {
            this.clearSelection();
          }
          disable() {
            this.clearSelection(), this._enabled = false;
          }
          enable() {
            this._enabled = true;
          }
          get selectionStart() {
            return this._model.finalSelectionStart;
          }
          get selectionEnd() {
            return this._model.finalSelectionEnd;
          }
          get hasSelection() {
            const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
            return !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
          }
          get selectionText() {
            const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
            if (!e3 || !t3)
              return "";
            const i3 = this._bufferService.buffer, s3 = [];
            if (3 === this._activeSelectionMode) {
              if (e3[0] === t3[0])
                return "";
              const r2 = e3[0] < t3[0] ? e3[0] : t3[0], n3 = e3[0] < t3[0] ? t3[0] : e3[0];
              for (let o2 = e3[1]; o2 <= t3[1]; o2++) {
                const e4 = i3.translateBufferLineToString(o2, true, r2, n3);
                s3.push(e4);
              }
            } else {
              const r2 = e3[1] === t3[1] ? t3[0] : void 0;
              s3.push(i3.translateBufferLineToString(e3[1], true, e3[0], r2));
              for (let r3 = e3[1] + 1; r3 <= t3[1] - 1; r3++) {
                const e4 = i3.lines.get(r3), t4 = i3.translateBufferLineToString(r3, true);
                (null == e4 ? void 0 : e4.isWrapped) ? s3[s3.length - 1] += t4 : s3.push(t4);
              }
              if (e3[1] !== t3[1]) {
                const e4 = i3.lines.get(t3[1]), r3 = i3.translateBufferLineToString(t3[1], true, 0, t3[0]);
                e4 && e4.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
              }
            }
            return s3.map((e4) => e4.replace(g, " ")).join(n2.isWindows ? "\r\n" : "\n");
          }
          clearSelection() {
            this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
          }
          refresh(e3) {
            this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), n2.isLinux && e3 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
          }
          _refresh() {
            this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: 3 === this._activeSelectionMode });
          }
          _isClickInSelection(e3) {
            const t3 = this._getMouseBufferCoords(e3), i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
            return !!(i3 && s3 && t3) && this._areCoordsInSelection(t3, i3, s3);
          }
          isCellInSelection(e3, t3) {
            const i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
            return !(!i3 || !s3) && this._areCoordsInSelection([e3, t3], i3, s3);
          }
          _areCoordsInSelection(e3, t3, i3) {
            return e3[1] > t3[1] && e3[1] < i3[1] || t3[1] === i3[1] && e3[1] === t3[1] && e3[0] >= t3[0] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === i3[1] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === t3[1] && e3[0] >= t3[0];
          }
          _selectWordAtCursor(e3, t3) {
            var i3, s3;
            const r2 = null === (s3 = null === (i3 = this._linkifier.currentLink) || void 0 === i3 ? void 0 : i3.link) || void 0 === s3 ? void 0 : s3.range;
            if (r2)
              return this._model.selectionStart = [r2.start.x - 1, r2.start.y - 1], this._model.selectionStartLength = (0, f.getRangeLength)(r2, this._bufferService.cols), this._model.selectionEnd = void 0, true;
            const n3 = this._getMouseBufferCoords(e3);
            return !!n3 && (this._selectWordAt(n3, t3), this._model.selectionEnd = void 0, true);
          }
          selectAll() {
            this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
          }
          selectLines(e3, t3) {
            this._model.clearSelection(), e3 = Math.max(e3, 0), t3 = Math.min(t3, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e3], this._model.selectionEnd = [this._bufferService.cols, t3], this.refresh(), this._onSelectionChange.fire();
          }
          _handleTrim(e3) {
            this._model.handleTrim(e3) && this.refresh();
          }
          _getMouseBufferCoords(e3) {
            const t3 = this._mouseService.getCoords(e3, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
            if (t3)
              return t3[0]--, t3[1]--, t3[1] += this._bufferService.buffer.ydisp, t3;
          }
          _getMouseEventScrollAmount(e3) {
            let t3 = (0, d.getCoordsRelativeToElement)(this._coreBrowserService.window, e3, this._screenElement)[1];
            const i3 = this._renderService.dimensions.css.canvas.height;
            return t3 >= 0 && t3 <= i3 ? 0 : (t3 > i3 && (t3 -= i3), t3 = Math.min(Math.max(t3, -50), 50), t3 /= 50, t3 / Math.abs(t3) + Math.round(14 * t3));
          }
          shouldForceSelection(e3) {
            return n2.isMac ? e3.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e3.shiftKey;
          }
          handleMouseDown(e3) {
            if (this._mouseDownTimeStamp = e3.timeStamp, (2 !== e3.button || !this.hasSelection) && 0 === e3.button) {
              if (!this._enabled) {
                if (!this.shouldForceSelection(e3))
                  return;
                e3.stopPropagation();
              }
              e3.preventDefault(), this._dragScrollAmount = 0, this._enabled && e3.shiftKey ? this._handleIncrementalClick(e3) : 1 === e3.detail ? this._handleSingleClick(e3) : 2 === e3.detail ? this._handleDoubleClick(e3) : 3 === e3.detail && this._handleTripleClick(e3), this._addMouseDownListeners(), this.refresh(true);
            }
          }
          _addMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
          }
          _removeMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
          }
          _handleIncrementalClick(e3) {
            this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e3));
          }
          _handleSingleClick(e3) {
            if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e3) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e3), !this._model.selectionStart)
              return;
            this._model.selectionEnd = void 0;
            const t3 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
            t3 && t3.length !== this._model.selectionStart[0] && 0 === t3.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
          }
          _handleDoubleClick(e3) {
            this._selectWordAtCursor(e3, true) && (this._activeSelectionMode = 1);
          }
          _handleTripleClick(e3) {
            const t3 = this._getMouseBufferCoords(e3);
            t3 && (this._activeSelectionMode = 2, this._selectLineAt(t3[1]));
          }
          shouldColumnSelect(e3) {
            return e3.altKey && !(n2.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
          }
          _handleMouseMove(e3) {
            if (e3.stopImmediatePropagation(), !this._model.selectionStart)
              return;
            const t3 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
            if (this._model.selectionEnd = this._getMouseBufferCoords(e3), !this._model.selectionEnd)
              return void this.refresh(true);
            2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e3), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
            const i3 = this._bufferService.buffer;
            if (this._model.selectionEnd[1] < i3.lines.length) {
              const e4 = i3.lines.get(this._model.selectionEnd[1]);
              e4 && 0 === e4.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0]++;
            }
            t3 && t3[0] === this._model.selectionEnd[0] && t3[1] === this._model.selectionEnd[1] || this.refresh(true);
          }
          _dragScroll() {
            if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
              this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
              const e3 = this._bufferService.buffer;
              this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e3.ydisp + this._bufferService.rows, e3.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e3.ydisp), this.refresh();
            }
          }
          _handleMouseUp(e3) {
            const t3 = e3.timeStamp - this._mouseDownTimeStamp;
            if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t3 < 500 && e3.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
              if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                const t4 = this._mouseService.getCoords(e3, this._element, this._bufferService.cols, this._bufferService.rows, false);
                if (t4 && void 0 !== t4[0] && void 0 !== t4[1]) {
                  const e4 = (0, _.moveToCellSequence)(t4[0] - 1, t4[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                  this._coreService.triggerDataEvent(e4, true);
                }
              }
            } else
              this._fireEventIfSelectionChanged();
          }
          _fireEventIfSelectionChanged() {
            const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd, i3 = !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
            i3 ? e3 && t3 && (this._oldSelectionStart && this._oldSelectionEnd && e3[0] === this._oldSelectionStart[0] && e3[1] === this._oldSelectionStart[1] && t3[0] === this._oldSelectionEnd[0] && t3[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e3, t3, i3)) : this._oldHasSelection && this._fireOnSelectionChange(e3, t3, i3);
          }
          _fireOnSelectionChange(e3, t3, i3) {
            this._oldSelectionStart = e3, this._oldSelectionEnd = t3, this._oldHasSelection = i3, this._onSelectionChange.fire();
          }
          _handleBufferActivate(e3) {
            this.clearSelection(), this._trimListener.dispose(), this._trimListener = e3.activeBuffer.lines.onTrim((e4) => this._handleTrim(e4));
          }
          _convertViewportColToCharacterIndex(e3, t3) {
            let i3 = t3;
            for (let s3 = 0; t3 >= s3; s3++) {
              const r2 = e3.loadCell(s3, this._workCell).getChars().length;
              0 === this._workCell.getWidth() ? i3-- : r2 > 1 && t3 !== s3 && (i3 += r2 - 1);
            }
            return i3;
          }
          setSelection(e3, t3, i3) {
            this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e3, t3], this._model.selectionStartLength = i3, this.refresh(), this._fireEventIfSelectionChanged();
          }
          rightClickSelect(e3) {
            this._isClickInSelection(e3) || (this._selectWordAtCursor(e3, false) && this.refresh(true), this._fireEventIfSelectionChanged());
          }
          _getWordAt(e3, t3, i3 = true, s3 = true) {
            if (e3[0] >= this._bufferService.cols)
              return;
            const r2 = this._bufferService.buffer, n3 = r2.lines.get(e3[1]);
            if (!n3)
              return;
            const o2 = r2.translateBufferLineToString(e3[1], false);
            let a2 = this._convertViewportColToCharacterIndex(n3, e3[0]), h2 = a2;
            const c2 = e3[0] - a2;
            let l2 = 0, d2 = 0, _2 = 0, u2 = 0;
            if (" " === o2.charAt(a2)) {
              for (; a2 > 0 && " " === o2.charAt(a2 - 1); )
                a2--;
              for (; h2 < o2.length && " " === o2.charAt(h2 + 1); )
                h2++;
            } else {
              let t4 = e3[0], i4 = e3[0];
              0 === n3.getWidth(t4) && (l2++, t4--), 2 === n3.getWidth(i4) && (d2++, i4++);
              const s4 = n3.getString(i4).length;
              for (s4 > 1 && (u2 += s4 - 1, h2 += s4 - 1); t4 > 0 && a2 > 0 && !this._isCharWordSeparator(n3.loadCell(t4 - 1, this._workCell)); ) {
                n3.loadCell(t4 - 1, this._workCell);
                const e4 = this._workCell.getChars().length;
                0 === this._workCell.getWidth() ? (l2++, t4--) : e4 > 1 && (_2 += e4 - 1, a2 -= e4 - 1), a2--, t4--;
              }
              for (; i4 < n3.length && h2 + 1 < o2.length && !this._isCharWordSeparator(n3.loadCell(i4 + 1, this._workCell)); ) {
                n3.loadCell(i4 + 1, this._workCell);
                const e4 = this._workCell.getChars().length;
                2 === this._workCell.getWidth() ? (d2++, i4++) : e4 > 1 && (u2 += e4 - 1, h2 += e4 - 1), h2++, i4++;
              }
            }
            h2++;
            let f2 = a2 + c2 - l2 + _2, v2 = Math.min(this._bufferService.cols, h2 - a2 + l2 + d2 - _2 - u2);
            if (t3 || "" !== o2.slice(a2, h2).trim()) {
              if (i3 && 0 === f2 && 32 !== n3.getCodePoint(0)) {
                const t4 = r2.lines.get(e3[1] - 1);
                if (t4 && n3.isWrapped && 32 !== t4.getCodePoint(this._bufferService.cols - 1)) {
                  const t5 = this._getWordAt([this._bufferService.cols - 1, e3[1] - 1], false, true, false);
                  if (t5) {
                    const e4 = this._bufferService.cols - t5.start;
                    f2 -= e4, v2 += e4;
                  }
                }
              }
              if (s3 && f2 + v2 === this._bufferService.cols && 32 !== n3.getCodePoint(this._bufferService.cols - 1)) {
                const t4 = r2.lines.get(e3[1] + 1);
                if ((null == t4 ? void 0 : t4.isWrapped) && 32 !== t4.getCodePoint(0)) {
                  const t5 = this._getWordAt([0, e3[1] + 1], false, false, true);
                  t5 && (v2 += t5.length);
                }
              }
              return { start: f2, length: v2 };
            }
          }
          _selectWordAt(e3, t3) {
            const i3 = this._getWordAt(e3, t3);
            if (i3) {
              for (; i3.start < 0; )
                i3.start += this._bufferService.cols, e3[1]--;
              this._model.selectionStart = [i3.start, e3[1]], this._model.selectionStartLength = i3.length;
            }
          }
          _selectToWordAt(e3) {
            const t3 = this._getWordAt(e3, true);
            if (t3) {
              let i3 = e3[1];
              for (; t3.start < 0; )
                t3.start += this._bufferService.cols, i3--;
              if (!this._model.areSelectionValuesReversed())
                for (; t3.start + t3.length > this._bufferService.cols; )
                  t3.length -= this._bufferService.cols, i3++;
              this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t3.start : t3.start + t3.length, i3];
            }
          }
          _isCharWordSeparator(e3) {
            return 0 !== e3.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e3.getChars()) >= 0;
          }
          _selectLineAt(e3) {
            const t3 = this._bufferService.buffer.getWrappedRangeForLine(e3), i3 = { start: { x: 0, y: t3.first }, end: { x: this._bufferService.cols - 1, y: t3.last } };
            this._model.selectionStart = [0, t3.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, f.getRangeLength)(i3, this._bufferService.cols);
          }
        };
        p = s2([r(3, l.IBufferService), r(4, l.ICoreService), r(5, c.IMouseService), r(6, l.IOptionsService), r(7, c.IRenderService), r(8, c.ICoreBrowserService)], p), t2.SelectionService = p;
      }, 4725: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.IThemeService = t2.ICharacterJoinerService = t2.ISelectionService = t2.IRenderService = t2.IMouseService = t2.ICoreBrowserService = t2.ICharSizeService = void 0;
        const s2 = i2(8343);
        t2.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t2.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t2.IMouseService = (0, s2.createDecorator)("MouseService"), t2.IRenderService = (0, s2.createDecorator)("RenderService"), t2.ISelectionService = (0, s2.createDecorator)("SelectionService"), t2.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t2.IThemeService = (0, s2.createDecorator)("ThemeService");
      }, 6731: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ThemeService = t2.DEFAULT_ANSI_COLORS = void 0;
        const n2 = i2(7239), o = i2(8055), a = i2(8460), h = i2(844), c = i2(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
        t2.DEFAULT_ANSI_COLORS = Object.freeze((() => {
          const e3 = [o.css.toColor("#2e3436"), o.css.toColor("#cc0000"), o.css.toColor("#4e9a06"), o.css.toColor("#c4a000"), o.css.toColor("#3465a4"), o.css.toColor("#75507b"), o.css.toColor("#06989a"), o.css.toColor("#d3d7cf"), o.css.toColor("#555753"), o.css.toColor("#ef2929"), o.css.toColor("#8ae234"), o.css.toColor("#fce94f"), o.css.toColor("#729fcf"), o.css.toColor("#ad7fa8"), o.css.toColor("#34e2e2"), o.css.toColor("#eeeeec")], t3 = [0, 95, 135, 175, 215, 255];
          for (let i3 = 0; i3 < 216; i3++) {
            const s3 = t3[i3 / 36 % 6 | 0], r2 = t3[i3 / 6 % 6 | 0], n3 = t3[i3 % 6];
            e3.push({ css: o.channels.toCss(s3, r2, n3), rgba: o.channels.toRgba(s3, r2, n3) });
          }
          for (let t4 = 0; t4 < 24; t4++) {
            const i3 = 8 + 10 * t4;
            e3.push({ css: o.channels.toCss(i3, i3, i3), rgba: o.channels.toRgba(i3, i3, i3) });
          }
          return e3;
        })());
        let v = class extends h.Disposable {
          constructor(e3) {
            super(), this._optionsService = e3, this._onChangeColors = this.register(new a.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._contrastCache = new n2.ColorContrastCache(), this._colors = { foreground: l, background: d, cursor: _, cursorAccent: u, selectionForeground: void 0, selectionBackgroundTransparent: f, selectionBackgroundOpaque: o.color.blend(d, f), selectionInactiveBackgroundTransparent: f, selectionInactiveBackgroundOpaque: o.color.blend(d, f), ansi: t2.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
          }
          get colors() {
            return this._colors;
          }
          _setTheme(e3 = {}) {
            const i3 = this._colors;
            if (i3.foreground = g(e3.foreground, l), i3.background = g(e3.background, d), i3.cursor = g(e3.cursor, _), i3.cursorAccent = g(e3.cursorAccent, u), i3.selectionBackgroundTransparent = g(e3.selectionBackground, f), i3.selectionBackgroundOpaque = o.color.blend(i3.background, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundTransparent = g(e3.selectionInactiveBackground, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundOpaque = o.color.blend(i3.background, i3.selectionInactiveBackgroundTransparent), i3.selectionForeground = e3.selectionForeground ? g(e3.selectionForeground, o.NULL_COLOR) : void 0, i3.selectionForeground === o.NULL_COLOR && (i3.selectionForeground = void 0), o.color.isOpaque(i3.selectionBackgroundTransparent)) {
              const e4 = 0.3;
              i3.selectionBackgroundTransparent = o.color.opacity(i3.selectionBackgroundTransparent, e4);
            }
            if (o.color.isOpaque(i3.selectionInactiveBackgroundTransparent)) {
              const e4 = 0.3;
              i3.selectionInactiveBackgroundTransparent = o.color.opacity(i3.selectionInactiveBackgroundTransparent, e4);
            }
            if (i3.ansi = t2.DEFAULT_ANSI_COLORS.slice(), i3.ansi[0] = g(e3.black, t2.DEFAULT_ANSI_COLORS[0]), i3.ansi[1] = g(e3.red, t2.DEFAULT_ANSI_COLORS[1]), i3.ansi[2] = g(e3.green, t2.DEFAULT_ANSI_COLORS[2]), i3.ansi[3] = g(e3.yellow, t2.DEFAULT_ANSI_COLORS[3]), i3.ansi[4] = g(e3.blue, t2.DEFAULT_ANSI_COLORS[4]), i3.ansi[5] = g(e3.magenta, t2.DEFAULT_ANSI_COLORS[5]), i3.ansi[6] = g(e3.cyan, t2.DEFAULT_ANSI_COLORS[6]), i3.ansi[7] = g(e3.white, t2.DEFAULT_ANSI_COLORS[7]), i3.ansi[8] = g(e3.brightBlack, t2.DEFAULT_ANSI_COLORS[8]), i3.ansi[9] = g(e3.brightRed, t2.DEFAULT_ANSI_COLORS[9]), i3.ansi[10] = g(e3.brightGreen, t2.DEFAULT_ANSI_COLORS[10]), i3.ansi[11] = g(e3.brightYellow, t2.DEFAULT_ANSI_COLORS[11]), i3.ansi[12] = g(e3.brightBlue, t2.DEFAULT_ANSI_COLORS[12]), i3.ansi[13] = g(e3.brightMagenta, t2.DEFAULT_ANSI_COLORS[13]), i3.ansi[14] = g(e3.brightCyan, t2.DEFAULT_ANSI_COLORS[14]), i3.ansi[15] = g(e3.brightWhite, t2.DEFAULT_ANSI_COLORS[15]), e3.extendedAnsi) {
              const s3 = Math.min(i3.ansi.length - 16, e3.extendedAnsi.length);
              for (let r2 = 0; r2 < s3; r2++)
                i3.ansi[r2 + 16] = g(e3.extendedAnsi[r2], t2.DEFAULT_ANSI_COLORS[r2 + 16]);
            }
            this._contrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
          }
          restoreColor(e3) {
            this._restoreColor(e3), this._onChangeColors.fire(this.colors);
          }
          _restoreColor(e3) {
            if (void 0 !== e3)
              switch (e3) {
                case 256:
                  this._colors.foreground = this._restoreColors.foreground;
                  break;
                case 257:
                  this._colors.background = this._restoreColors.background;
                  break;
                case 258:
                  this._colors.cursor = this._restoreColors.cursor;
                  break;
                default:
                  this._colors.ansi[e3] = this._restoreColors.ansi[e3];
              }
            else
              for (let e4 = 0; e4 < this._restoreColors.ansi.length; ++e4)
                this._colors.ansi[e4] = this._restoreColors.ansi[e4];
          }
          modifyColors(e3) {
            e3(this._colors), this._onChangeColors.fire(this.colors);
          }
          _updateRestoreColors() {
            this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
          }
        };
        function g(e3, t3) {
          if (void 0 !== e3)
            try {
              return o.css.toColor(e3);
            } catch (e4) {
            }
          return t3;
        }
        v = s2([r(0, c.IOptionsService)], v), t2.ThemeService = v;
      }, 6349: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CircularList = void 0;
        const s2 = i2(8460), r = i2(844);
        class n2 extends r.Disposable {
          constructor(e3) {
            super(), this._maxLength = e3, this.onDeleteEmitter = this.register(new s2.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
          }
          get maxLength() {
            return this._maxLength;
          }
          set maxLength(e3) {
            if (this._maxLength === e3)
              return;
            const t3 = new Array(e3);
            for (let i3 = 0; i3 < Math.min(e3, this.length); i3++)
              t3[i3] = this._array[this._getCyclicIndex(i3)];
            this._array = t3, this._maxLength = e3, this._startIndex = 0;
          }
          get length() {
            return this._length;
          }
          set length(e3) {
            if (e3 > this._length)
              for (let t3 = this._length; t3 < e3; t3++)
                this._array[t3] = void 0;
            this._length = e3;
          }
          get(e3) {
            return this._array[this._getCyclicIndex(e3)];
          }
          set(e3, t3) {
            this._array[this._getCyclicIndex(e3)] = t3;
          }
          push(e3) {
            this._array[this._getCyclicIndex(this._length)] = e3, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
          }
          recycle() {
            if (this._length !== this._maxLength)
              throw new Error("Can only recycle when the buffer is full");
            return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
          }
          get isFull() {
            return this._length === this._maxLength;
          }
          pop() {
            return this._array[this._getCyclicIndex(this._length-- - 1)];
          }
          splice(e3, t3, ...i3) {
            if (t3) {
              for (let i4 = e3; i4 < this._length - t3; i4++)
                this._array[this._getCyclicIndex(i4)] = this._array[this._getCyclicIndex(i4 + t3)];
              this._length -= t3, this.onDeleteEmitter.fire({ index: e3, amount: t3 });
            }
            for (let t4 = this._length - 1; t4 >= e3; t4--)
              this._array[this._getCyclicIndex(t4 + i3.length)] = this._array[this._getCyclicIndex(t4)];
            for (let t4 = 0; t4 < i3.length; t4++)
              this._array[this._getCyclicIndex(e3 + t4)] = i3[t4];
            if (i3.length && this.onInsertEmitter.fire({ index: e3, amount: i3.length }), this._length + i3.length > this._maxLength) {
              const e4 = this._length + i3.length - this._maxLength;
              this._startIndex += e4, this._length = this._maxLength, this.onTrimEmitter.fire(e4);
            } else
              this._length += i3.length;
          }
          trimStart(e3) {
            e3 > this._length && (e3 = this._length), this._startIndex += e3, this._length -= e3, this.onTrimEmitter.fire(e3);
          }
          shiftElements(e3, t3, i3) {
            if (!(t3 <= 0)) {
              if (e3 < 0 || e3 >= this._length)
                throw new Error("start argument out of range");
              if (e3 + i3 < 0)
                throw new Error("Cannot shift elements in list beyond index 0");
              if (i3 > 0) {
                for (let s4 = t3 - 1; s4 >= 0; s4--)
                  this.set(e3 + s4 + i3, this.get(e3 + s4));
                const s3 = e3 + t3 + i3 - this._length;
                if (s3 > 0)
                  for (this._length += s3; this._length > this._maxLength; )
                    this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
              } else
                for (let s3 = 0; s3 < t3; s3++)
                  this.set(e3 + s3 + i3, this.get(e3 + s3));
            }
          }
          _getCyclicIndex(e3) {
            return (this._startIndex + e3) % this._maxLength;
          }
        }
        t2.CircularList = n2;
      }, 1439: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = void 0, t2.clone = function e3(t3, i2 = 5) {
          if ("object" != typeof t3)
            return t3;
          const s2 = Array.isArray(t3) ? [] : {};
          for (const r in t3)
            s2[r] = i2 <= 1 ? t3[r] : t3[r] && e3(t3[r], i2 - 1);
          return s2;
        };
      }, 8055: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.contrastRatio = t2.toPaddedHex = t2.rgba = t2.rgb = t2.css = t2.color = t2.channels = t2.NULL_COLOR = void 0;
        const s2 = i2(6114);
        let r = 0, n2 = 0, o = 0, a = 0;
        var h, c, l;
        function d(e3) {
          const t3 = e3.toString(16);
          return t3.length < 2 ? "0" + t3 : t3;
        }
        function _(e3, t3) {
          return e3 < t3 ? (t3 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t3 + 0.05);
        }
        t2.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(e3) {
          e3.toCss = function(e4, t3, i3, s3) {
            return void 0 !== s3 ? `#${d(e4)}${d(t3)}${d(i3)}${d(s3)}` : `#${d(e4)}${d(t3)}${d(i3)}`;
          }, e3.toRgba = function(e4, t3, i3, s3 = 255) {
            return (e4 << 24 | t3 << 16 | i3 << 8 | s3) >>> 0;
          };
        }(h = t2.channels || (t2.channels = {})), function(e3) {
          function t3(e4, t4) {
            return a = Math.round(255 * t4), [r, n2, o] = l.toChannels(e4.rgba), { css: h.toCss(r, n2, o, a), rgba: h.toRgba(r, n2, o, a) };
          }
          e3.blend = function(e4, t4) {
            if (a = (255 & t4.rgba) / 255, 1 === a)
              return { css: t4.css, rgba: t4.rgba };
            const i3 = t4.rgba >> 24 & 255, s3 = t4.rgba >> 16 & 255, c2 = t4.rgba >> 8 & 255, l2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _2 = e4.rgba >> 8 & 255;
            return r = l2 + Math.round((i3 - l2) * a), n2 = d2 + Math.round((s3 - d2) * a), o = _2 + Math.round((c2 - _2) * a), { css: h.toCss(r, n2, o), rgba: h.toRgba(r, n2, o) };
          }, e3.isOpaque = function(e4) {
            return 255 == (255 & e4.rgba);
          }, e3.ensureContrastRatio = function(e4, t4, i3) {
            const s3 = l.ensureContrastRatio(e4.rgba, t4.rgba, i3);
            if (s3)
              return l.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
          }, e3.opaque = function(e4) {
            const t4 = (255 | e4.rgba) >>> 0;
            return [r, n2, o] = l.toChannels(t4), { css: h.toCss(r, n2, o), rgba: t4 };
          }, e3.opacity = t3, e3.multiplyOpacity = function(e4, i3) {
            return a = 255 & e4.rgba, t3(e4, a * i3 / 255);
          }, e3.toColorRGB = function(e4) {
            return [e4.rgba >> 24 & 255, e4.rgba >> 16 & 255, e4.rgba >> 8 & 255];
          };
        }(t2.color || (t2.color = {})), function(e3) {
          let t3, i3;
          if (!s2.isNode) {
            const e4 = document.createElement("canvas");
            e4.width = 1, e4.height = 1;
            const s3 = e4.getContext("2d", { willReadFrequently: true });
            s3 && (t3 = s3, t3.globalCompositeOperation = "copy", i3 = t3.createLinearGradient(0, 0, 1, 1));
          }
          e3.toColor = function(e4) {
            if (e4.match(/#[\da-f]{3,8}/i))
              switch (e4.length) {
                case 4:
                  return r = parseInt(e4.slice(1, 2).repeat(2), 16), n2 = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), l.toColor(r, n2, o);
                case 5:
                  return r = parseInt(e4.slice(1, 2).repeat(2), 16), n2 = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), a = parseInt(e4.slice(4, 5).repeat(2), 16), l.toColor(r, n2, o, a);
                case 7:
                  return { css: e4, rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0 };
                case 9:
                  return { css: e4, rgba: parseInt(e4.slice(1), 16) >>> 0 };
              }
            const s3 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
            if (s3)
              return r = parseInt(s3[1]), n2 = parseInt(s3[2]), o = parseInt(s3[3]), a = Math.round(255 * (void 0 === s3[5] ? 1 : parseFloat(s3[5]))), l.toColor(r, n2, o, a);
            if (!t3 || !i3)
              throw new Error("css.toColor: Unsupported css format");
            if (t3.fillStyle = i3, t3.fillStyle = e4, "string" != typeof t3.fillStyle)
              throw new Error("css.toColor: Unsupported css format");
            if (t3.fillRect(0, 0, 1, 1), [r, n2, o, a] = t3.getImageData(0, 0, 1, 1).data, 255 !== a)
              throw new Error("css.toColor: Unsupported css format");
            return { rgba: h.toRgba(r, n2, o, a), css: e4 };
          };
        }(t2.css || (t2.css = {})), function(e3) {
          function t3(e4, t4, i3) {
            const s3 = e4 / 255, r2 = t4 / 255, n3 = i3 / 255;
            return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n3 <= 0.03928 ? n3 / 12.92 : Math.pow((n3 + 0.055) / 1.055, 2.4));
          }
          e3.relativeLuminance = function(e4) {
            return t3(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
          }, e3.relativeLuminance2 = t3;
        }(c = t2.rgb || (t2.rgb = {})), function(e3) {
          function t3(e4, t4, i4) {
            const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n3 = e4 >> 8 & 255;
            let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a2, h2), c.relativeLuminance2(s3, r2, n3));
            for (; l2 < i4 && (o2 > 0 || a2 > 0 || h2 > 0); )
              o2 -= Math.max(0, Math.ceil(0.1 * o2)), a2 -= Math.max(0, Math.ceil(0.1 * a2)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), l2 = _(c.relativeLuminance2(o2, a2, h2), c.relativeLuminance2(s3, r2, n3));
            return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
          }
          function i3(e4, t4, i4) {
            const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n3 = e4 >> 8 & 255;
            let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a2, h2), c.relativeLuminance2(s3, r2, n3));
            for (; l2 < i4 && (o2 < 255 || a2 < 255 || h2 < 255); )
              o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a2 = Math.min(255, a2 + Math.ceil(0.1 * (255 - a2))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), l2 = _(c.relativeLuminance2(o2, a2, h2), c.relativeLuminance2(s3, r2, n3));
            return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
          }
          e3.ensureContrastRatio = function(e4, s3, r2) {
            const n3 = c.relativeLuminance(e4 >> 8), o2 = c.relativeLuminance(s3 >> 8);
            if (_(n3, o2) < r2) {
              if (o2 < n3) {
                const o3 = t3(e4, s3, r2), a3 = _(n3, c.relativeLuminance(o3 >> 8));
                if (a3 < r2) {
                  const t4 = i3(e4, s3, r2);
                  return a3 > _(n3, c.relativeLuminance(t4 >> 8)) ? o3 : t4;
                }
                return o3;
              }
              const a2 = i3(e4, s3, r2), h2 = _(n3, c.relativeLuminance(a2 >> 8));
              if (h2 < r2) {
                const i4 = t3(e4, s3, r2);
                return h2 > _(n3, c.relativeLuminance(i4 >> 8)) ? a2 : i4;
              }
              return a2;
            }
          }, e3.reduceLuminance = t3, e3.increaseLuminance = i3, e3.toChannels = function(e4) {
            return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
          }, e3.toColor = function(e4, t4, i4, s3) {
            return { css: h.toCss(e4, t4, i4, s3), rgba: h.toRgba(e4, t4, i4, s3) };
          };
        }(l = t2.rgba || (t2.rgba = {})), t2.toPaddedHex = d, t2.contrastRatio = _;
      }, 8969: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreTerminal = void 0;
        const s2 = i2(844), r = i2(2585), n2 = i2(4348), o = i2(7866), a = i2(744), h = i2(7302), c = i2(6975), l = i2(8460), d = i2(1753), _ = i2(1480), u = i2(7994), f = i2(9282), v = i2(5435), g = i2(5981), p = i2(2660);
        let S = false;
        class m extends s2.Disposable {
          constructor(e3) {
            super(), this._onBinary = this.register(new l.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter()), this._instantiationService = new n2.InstantiationService(), this.optionsService = this.register(new h.OptionsService(e3)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(p.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((e4) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this.register(this._inputHandler.onScroll((e4) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this._writeBuffer = this.register(new g.WriteBuffer((e4, t3) => this._inputHandler.parse(e4, t3))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed)), this.register((0, s2.toDisposable)(() => {
              var e4;
              null === (e4 = this._windowsWrappingHeuristics) || void 0 === e4 || e4.dispose(), this._windowsWrappingHeuristics = void 0;
            }));
          }
          get onScroll() {
            return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter()), this._onScroll.event((e3) => {
              var t3;
              null === (t3 = this._onScrollApi) || void 0 === t3 || t3.fire(e3.position);
            })), this._onScrollApi.event;
          }
          get cols() {
            return this._bufferService.cols;
          }
          get rows() {
            return this._bufferService.rows;
          }
          get buffers() {
            return this._bufferService.buffers;
          }
          get options() {
            return this.optionsService.options;
          }
          set options(e3) {
            for (const t3 in e3)
              this.optionsService.options[t3] = e3[t3];
          }
          write(e3, t3) {
            this._writeBuffer.write(e3, t3);
          }
          writeSync(e3, t3) {
            this._logService.logLevel <= r.LogLevelEnum.WARN && !S && (this._logService.warn("writeSync is unreliable and will be removed soon."), S = true), this._writeBuffer.writeSync(e3, t3);
          }
          resize(e3, t3) {
            isNaN(e3) || isNaN(t3) || (e3 = Math.max(e3, a.MINIMUM_COLS), t3 = Math.max(t3, a.MINIMUM_ROWS), this._bufferService.resize(e3, t3));
          }
          scroll(e3, t3 = false) {
            this._bufferService.scroll(e3, t3);
          }
          scrollLines(e3, t3, i3) {
            this._bufferService.scrollLines(e3, t3, i3);
          }
          scrollPages(e3) {
            this._bufferService.scrollPages(e3);
          }
          scrollToTop() {
            this._bufferService.scrollToTop();
          }
          scrollToBottom() {
            this._bufferService.scrollToBottom();
          }
          scrollToLine(e3) {
            this._bufferService.scrollToLine(e3);
          }
          registerEscHandler(e3, t3) {
            return this._inputHandler.registerEscHandler(e3, t3);
          }
          registerDcsHandler(e3, t3) {
            return this._inputHandler.registerDcsHandler(e3, t3);
          }
          registerCsiHandler(e3, t3) {
            return this._inputHandler.registerCsiHandler(e3, t3);
          }
          registerOscHandler(e3, t3) {
            return this._inputHandler.registerOscHandler(e3, t3);
          }
          _setup() {
            this._handleWindowsPtyOptionChange();
          }
          reset() {
            this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
          }
          _handleWindowsPtyOptionChange() {
            var e3;
            let t3 = false;
            const i3 = this.optionsService.rawOptions.windowsPty;
            i3 && void 0 !== i3.buildNumber && void 0 !== i3.buildNumber ? t3 = !!("conpty" === i3.backend && i3.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (t3 = true), t3 ? this._enableWindowsWrappingHeuristics() : (null === (e3 = this._windowsWrappingHeuristics) || void 0 === e3 || e3.dispose(), this._windowsWrappingHeuristics = void 0);
          }
          _enableWindowsWrappingHeuristics() {
            if (!this._windowsWrappingHeuristics) {
              const e3 = [];
              e3.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e3.push(this.registerCsiHandler({ final: "H" }, () => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false))), this._windowsWrappingHeuristics = (0, s2.toDisposable)(() => {
                for (const t3 of e3)
                  t3.dispose();
              });
            }
          }
        }
        t2.CoreTerminal = m;
      }, 8460: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.forwardEvent = t2.EventEmitter = void 0, t2.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = false;
          }
          get event() {
            return this._event || (this._event = (e3) => (this._listeners.push(e3), { dispose: () => {
              if (!this._disposed) {
                for (let t3 = 0; t3 < this._listeners.length; t3++)
                  if (this._listeners[t3] === e3)
                    return void this._listeners.splice(t3, 1);
              }
            } })), this._event;
          }
          fire(e3, t3) {
            const i2 = [];
            for (let e4 = 0; e4 < this._listeners.length; e4++)
              i2.push(this._listeners[e4]);
            for (let s2 = 0; s2 < i2.length; s2++)
              i2[s2].call(void 0, e3, t3);
          }
          dispose() {
            this._listeners && (this._listeners.length = 0), this._disposed = true;
          }
        }, t2.forwardEvent = function(e3, t3) {
          return e3((e4) => t3.fire(e4));
        };
      }, 5435: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.InputHandler = t2.WindowsOptionsReportType = void 0;
        const n2 = i2(2584), o = i2(7116), a = i2(2015), h = i2(844), c = i2(482), l = i2(8437), d = i2(8460), _ = i2(643), u = i2(511), f = i2(3734), v = i2(2585), g = i2(6242), p = i2(6351), S = i2(5941), m = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, C = 131072;
        function b(e3, t3) {
          if (e3 > 24)
            return t3.setWinLines || false;
          switch (e3) {
            case 1:
              return !!t3.restoreWin;
            case 2:
              return !!t3.minimizeWin;
            case 3:
              return !!t3.setWinPosition;
            case 4:
              return !!t3.setWinSizePixels;
            case 5:
              return !!t3.raiseWin;
            case 6:
              return !!t3.lowerWin;
            case 7:
              return !!t3.refreshWin;
            case 8:
              return !!t3.setWinSizeChars;
            case 9:
              return !!t3.maximizeWin;
            case 10:
              return !!t3.fullscreenWin;
            case 11:
              return !!t3.getWinState;
            case 13:
              return !!t3.getWinPosition;
            case 14:
              return !!t3.getWinSizePixels;
            case 15:
              return !!t3.getScreenSizePixels;
            case 16:
              return !!t3.getCellSizePixels;
            case 18:
              return !!t3.getWinSizeChars;
            case 19:
              return !!t3.getScreenSizeChars;
            case 20:
              return !!t3.getIconTitle;
            case 21:
              return !!t3.getWinTitle;
            case 22:
              return !!t3.pushTitle;
            case 23:
              return !!t3.popTitle;
            case 24:
              return !!t3.setWinLines;
          }
          return false;
        }
        var y;
        !function(e3) {
          e3[e3.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e3[e3.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
        }(y = t2.WindowsOptionsReportType || (t2.WindowsOptionsReportType = {}));
        let w = 0;
        class E extends h.Disposable {
          constructor(e3, t3, i3, s3, r2, h2, _2, f2, v2 = new a.EscapeSequenceParser()) {
            super(), this._bufferService = e3, this._charsetService = t3, this._coreService = i3, this._logService = s3, this._optionsService = r2, this._oscLinkService = h2, this._coreMouseService = _2, this._unicodeService = f2, this._parser = v2, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32(), this._utf8Decoder = new c.Utf8ToUtf32(), this._workCell = new u.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new L(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._parser.setCsiHandlerFallback((e4, t4) => {
              this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(e4), params: t4.toArray() });
            }), this._parser.setEscHandlerFallback((e4) => {
              this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(e4) });
            }), this._parser.setExecuteHandlerFallback((e4) => {
              this._logService.debug("Unknown EXECUTE code: ", { code: e4 });
            }), this._parser.setOscHandlerFallback((e4, t4, i4) => {
              this._logService.debug("Unknown OSC code: ", { identifier: e4, action: t4, data: i4 });
            }), this._parser.setDcsHandlerFallback((e4, t4, i4) => {
              "HOOK" === t4 && (i4 = i4.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(e4), action: t4, payload: i4 });
            }), this._parser.setPrintHandler((e4, t4, i4) => this.print(e4, t4, i4)), this._parser.registerCsiHandler({ final: "@" }, (e4) => this.insertChars(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (e4) => this.scrollLeft(e4)), this._parser.registerCsiHandler({ final: "A" }, (e4) => this.cursorUp(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (e4) => this.scrollRight(e4)), this._parser.registerCsiHandler({ final: "B" }, (e4) => this.cursorDown(e4)), this._parser.registerCsiHandler({ final: "C" }, (e4) => this.cursorForward(e4)), this._parser.registerCsiHandler({ final: "D" }, (e4) => this.cursorBackward(e4)), this._parser.registerCsiHandler({ final: "E" }, (e4) => this.cursorNextLine(e4)), this._parser.registerCsiHandler({ final: "F" }, (e4) => this.cursorPrecedingLine(e4)), this._parser.registerCsiHandler({ final: "G" }, (e4) => this.cursorCharAbsolute(e4)), this._parser.registerCsiHandler({ final: "H" }, (e4) => this.cursorPosition(e4)), this._parser.registerCsiHandler({ final: "I" }, (e4) => this.cursorForwardTab(e4)), this._parser.registerCsiHandler({ final: "J" }, (e4) => this.eraseInDisplay(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (e4) => this.eraseInDisplay(e4, true)), this._parser.registerCsiHandler({ final: "K" }, (e4) => this.eraseInLine(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (e4) => this.eraseInLine(e4, true)), this._parser.registerCsiHandler({ final: "L" }, (e4) => this.insertLines(e4)), this._parser.registerCsiHandler({ final: "M" }, (e4) => this.deleteLines(e4)), this._parser.registerCsiHandler({ final: "P" }, (e4) => this.deleteChars(e4)), this._parser.registerCsiHandler({ final: "S" }, (e4) => this.scrollUp(e4)), this._parser.registerCsiHandler({ final: "T" }, (e4) => this.scrollDown(e4)), this._parser.registerCsiHandler({ final: "X" }, (e4) => this.eraseChars(e4)), this._parser.registerCsiHandler({ final: "Z" }, (e4) => this.cursorBackwardTab(e4)), this._parser.registerCsiHandler({ final: "`" }, (e4) => this.charPosAbsolute(e4)), this._parser.registerCsiHandler({ final: "a" }, (e4) => this.hPositionRelative(e4)), this._parser.registerCsiHandler({ final: "b" }, (e4) => this.repeatPrecedingCharacter(e4)), this._parser.registerCsiHandler({ final: "c" }, (e4) => this.sendDeviceAttributesPrimary(e4)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (e4) => this.sendDeviceAttributesSecondary(e4)), this._parser.registerCsiHandler({ final: "d" }, (e4) => this.linePosAbsolute(e4)), this._parser.registerCsiHandler({ final: "e" }, (e4) => this.vPositionRelative(e4)), this._parser.registerCsiHandler({ final: "f" }, (e4) => this.hVPosition(e4)), this._parser.registerCsiHandler({ final: "g" }, (e4) => this.tabClear(e4)), this._parser.registerCsiHandler({ final: "h" }, (e4) => this.setMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (e4) => this.setModePrivate(e4)), this._parser.registerCsiHandler({ final: "l" }, (e4) => this.resetMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (e4) => this.resetModePrivate(e4)), this._parser.registerCsiHandler({ final: "m" }, (e4) => this.charAttributes(e4)), this._parser.registerCsiHandler({ final: "n" }, (e4) => this.deviceStatus(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (e4) => this.deviceStatusPrivate(e4)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (e4) => this.softReset(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (e4) => this.setCursorStyle(e4)), this._parser.registerCsiHandler({ final: "r" }, (e4) => this.setScrollRegion(e4)), this._parser.registerCsiHandler({ final: "s" }, (e4) => this.saveCursor(e4)), this._parser.registerCsiHandler({ final: "t" }, (e4) => this.windowOptions(e4)), this._parser.registerCsiHandler({ final: "u" }, (e4) => this.restoreCursor(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (e4) => this.insertColumns(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (e4) => this.deleteColumns(e4)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (e4) => this.selectProtected(e4)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, true)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, false)), this._parser.setExecuteHandler(n2.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n2.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n2.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n2.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n2.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n2.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n2.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n2.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n2.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n2.C1.IND, () => this.index()), this._parser.setExecuteHandler(n2.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n2.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new g.OscHandler((e4) => (this.setTitle(e4), this.setIconName(e4), true))), this._parser.registerOscHandler(1, new g.OscHandler((e4) => this.setIconName(e4))), this._parser.registerOscHandler(2, new g.OscHandler((e4) => this.setTitle(e4))), this._parser.registerOscHandler(4, new g.OscHandler((e4) => this.setOrReportIndexedColor(e4))), this._parser.registerOscHandler(8, new g.OscHandler((e4) => this.setHyperlink(e4))), this._parser.registerOscHandler(10, new g.OscHandler((e4) => this.setOrReportFgColor(e4))), this._parser.registerOscHandler(11, new g.OscHandler((e4) => this.setOrReportBgColor(e4))), this._parser.registerOscHandler(12, new g.OscHandler((e4) => this.setOrReportCursorColor(e4))), this._parser.registerOscHandler(104, new g.OscHandler((e4) => this.restoreIndexedColor(e4))), this._parser.registerOscHandler(110, new g.OscHandler((e4) => this.restoreFgColor(e4))), this._parser.registerOscHandler(111, new g.OscHandler((e4) => this.restoreBgColor(e4))), this._parser.registerOscHandler(112, new g.OscHandler((e4) => this.restoreCursorColor(e4))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
            for (const e4 in o.CHARSETS)
              this._parser.registerEscHandler({ intermediates: "(", final: e4 }, () => this.selectCharset("(" + e4)), this._parser.registerEscHandler({ intermediates: ")", final: e4 }, () => this.selectCharset(")" + e4)), this._parser.registerEscHandler({ intermediates: "*", final: e4 }, () => this.selectCharset("*" + e4)), this._parser.registerEscHandler({ intermediates: "+", final: e4 }, () => this.selectCharset("+" + e4)), this._parser.registerEscHandler({ intermediates: "-", final: e4 }, () => this.selectCharset("-" + e4)), this._parser.registerEscHandler({ intermediates: ".", final: e4 }, () => this.selectCharset("." + e4)), this._parser.registerEscHandler({ intermediates: "/", final: e4 }, () => this.selectCharset("/" + e4));
            this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((e4) => (this._logService.error("Parsing error: ", e4), e4)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new p.DcsHandler((e4, t4) => this.requestStatusString(e4, t4)));
          }
          getAttrData() {
            return this._curAttrData;
          }
          _preserveStack(e3, t3, i3, s3) {
            this._parseStack.paused = true, this._parseStack.cursorStartX = e3, this._parseStack.cursorStartY = t3, this._parseStack.decodedLength = i3, this._parseStack.position = s3;
          }
          _logSlowResolvingAsync(e3) {
            this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([e3, new Promise((e4, t3) => setTimeout(() => t3("#SLOW_TIMEOUT"), 5e3))]).catch((e4) => {
              if ("#SLOW_TIMEOUT" !== e4)
                throw e4;
              console.warn("async parser handler taking longer than 5000 ms");
            });
          }
          _getCurrentLinkId() {
            return this._curAttrData.extended.urlId;
          }
          parse(e3, t3) {
            let i3, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n3 = 0;
            const o2 = this._parseStack.paused;
            if (o2) {
              if (i3 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t3))
                return this._logSlowResolvingAsync(i3), i3;
              s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e3.length > C && (n3 = this._parseStack.position + C);
            }
            if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e3 ? ` "${e3}"` : ` "${Array.prototype.map.call(e3, (e4) => String.fromCharCode(e4)).join("")}"`), "string" == typeof e3 ? e3.split("").map((e4) => e4.charCodeAt(0)) : e3), this._parseBuffer.length < e3.length && this._parseBuffer.length < C && (this._parseBuffer = new Uint32Array(Math.min(e3.length, C))), o2 || this._dirtyRowTracker.clearRange(), e3.length > C)
              for (let t4 = n3; t4 < e3.length; t4 += C) {
                const n4 = t4 + C < e3.length ? t4 + C : e3.length, o3 = "string" == typeof e3 ? this._stringDecoder.decode(e3.substring(t4, n4), this._parseBuffer) : this._utf8Decoder.decode(e3.subarray(t4, n4), this._parseBuffer);
                if (i3 = this._parser.parse(this._parseBuffer, o3))
                  return this._preserveStack(s3, r2, o3, t4), this._logSlowResolvingAsync(i3), i3;
              }
            else if (!o2) {
              const t4 = "string" == typeof e3 ? this._stringDecoder.decode(e3, this._parseBuffer) : this._utf8Decoder.decode(e3, this._parseBuffer);
              if (i3 = this._parser.parse(this._parseBuffer, t4))
                return this._preserveStack(s3, r2, t4, 0), this._logSlowResolvingAsync(i3), i3;
            }
            this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
          }
          print(e3, t3, i3) {
            let s3, r2;
            const n3 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h2 = this._coreService.decPrivateModes.wraparound, l2 = this._coreService.modes.insertMode, d2 = this._curAttrData;
            let u2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i3 - t3 > 0 && 2 === u2.getWidth(this._activeBuffer.x - 1) && u2.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, d2.fg, d2.bg, d2.extended);
            for (let f2 = t3; f2 < i3; ++f2) {
              if (s3 = e3[f2], r2 = this._unicodeService.wcwidth(s3), s3 < 127 && n3) {
                const e4 = n3[String.fromCharCode(s3)];
                e4 && (s3 = e4.charCodeAt(0));
              }
              if (o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), r2 || !this._activeBuffer.x) {
                if (this._activeBuffer.x + r2 - 1 >= a2) {
                  if (h2) {
                    for (; this._activeBuffer.x < a2; )
                      u2.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, d2.fg, d2.bg, d2.extended);
                    this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), u2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                  } else if (this._activeBuffer.x = a2 - 1, 2 === r2)
                    continue;
                }
                if (l2 && (u2.insertCells(this._activeBuffer.x, r2, this._activeBuffer.getNullCell(d2), d2), 2 === u2.getWidth(a2 - 1) && u2.setCellFromCodePoint(a2 - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, d2.fg, d2.bg, d2.extended)), u2.setCellFromCodePoint(this._activeBuffer.x++, s3, r2, d2.fg, d2.bg, d2.extended), r2 > 0)
                  for (; --r2; )
                    u2.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, d2.fg, d2.bg, d2.extended);
              } else
                u2.getWidth(this._activeBuffer.x - 1) ? u2.addCodepointToCell(this._activeBuffer.x - 1, s3) : u2.addCodepointToCell(this._activeBuffer.x - 2, s3);
            }
            i3 - t3 > 0 && (u2.loadCell(this._activeBuffer.x - 1, this._workCell), 2 === this._workCell.getWidth() || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < a2 && i3 - t3 > 0 && 0 === u2.getWidth(this._activeBuffer.x) && !u2.hasContent(this._activeBuffer.x) && u2.setCellFromCodePoint(this._activeBuffer.x, 0, 1, d2.fg, d2.bg, d2.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          registerCsiHandler(e3, t3) {
            return "t" !== e3.final || e3.prefix || e3.intermediates ? this._parser.registerCsiHandler(e3, t3) : this._parser.registerCsiHandler(e3, (e4) => !b(e4.params[0], this._optionsService.rawOptions.windowOptions) || t3(e4));
          }
          registerDcsHandler(e3, t3) {
            return this._parser.registerDcsHandler(e3, new p.DcsHandler(t3));
          }
          registerEscHandler(e3, t3) {
            return this._parser.registerEscHandler(e3, t3);
          }
          registerOscHandler(e3, t3) {
            return this._parser.registerOscHandler(e3, new g.OscHandler(t3));
          }
          bell() {
            return this._onRequestBell.fire(), true;
          }
          lineFeed() {
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
          }
          carriageReturn() {
            return this._activeBuffer.x = 0, true;
          }
          backspace() {
            var e3;
            if (!this._coreService.decPrivateModes.reverseWraparound)
              return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
            if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0)
              this._activeBuffer.x--;
            else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (null === (e3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) || void 0 === e3 ? void 0 : e3.isWrapped)) {
              this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
              const e4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              e4.hasWidth(this._activeBuffer.x) && !e4.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
            }
            return this._restrictCursor(), true;
          }
          tab() {
            if (this._activeBuffer.x >= this._bufferService.cols)
              return true;
            const e3 = this._activeBuffer.x;
            return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e3), true;
          }
          shiftOut() {
            return this._charsetService.setgLevel(1), true;
          }
          shiftIn() {
            return this._charsetService.setgLevel(0), true;
          }
          _restrictCursor(e3 = this._bufferService.cols - 1) {
            this._activeBuffer.x = Math.min(e3, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _setCursor(e3, t3) {
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e3, this._activeBuffer.y = this._activeBuffer.scrollTop + t3) : (this._activeBuffer.x = e3, this._activeBuffer.y = t3), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _moveCursor(e3, t3) {
            this._restrictCursor(), this._setCursor(this._activeBuffer.x + e3, this._activeBuffer.y + t3);
          }
          cursorUp(e3) {
            const t3 = this._activeBuffer.y - this._activeBuffer.scrollTop;
            return t3 >= 0 ? this._moveCursor(0, -Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, -(e3.params[0] || 1)), true;
          }
          cursorDown(e3) {
            const t3 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
            return t3 >= 0 ? this._moveCursor(0, Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, e3.params[0] || 1), true;
          }
          cursorForward(e3) {
            return this._moveCursor(e3.params[0] || 1, 0), true;
          }
          cursorBackward(e3) {
            return this._moveCursor(-(e3.params[0] || 1), 0), true;
          }
          cursorNextLine(e3) {
            return this.cursorDown(e3), this._activeBuffer.x = 0, true;
          }
          cursorPrecedingLine(e3) {
            return this.cursorUp(e3), this._activeBuffer.x = 0, true;
          }
          cursorCharAbsolute(e3) {
            return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
          }
          cursorPosition(e3) {
            return this._setCursor(e3.length >= 2 ? (e3.params[1] || 1) - 1 : 0, (e3.params[0] || 1) - 1), true;
          }
          charPosAbsolute(e3) {
            return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
          }
          hPositionRelative(e3) {
            return this._moveCursor(e3.params[0] || 1, 0), true;
          }
          linePosAbsolute(e3) {
            return this._setCursor(this._activeBuffer.x, (e3.params[0] || 1) - 1), true;
          }
          vPositionRelative(e3) {
            return this._moveCursor(0, e3.params[0] || 1), true;
          }
          hVPosition(e3) {
            return this.cursorPosition(e3), true;
          }
          tabClear(e3) {
            const t3 = e3.params[0];
            return 0 === t3 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t3 && (this._activeBuffer.tabs = {}), true;
          }
          cursorForwardTab(e3) {
            if (this._activeBuffer.x >= this._bufferService.cols)
              return true;
            let t3 = e3.params[0] || 1;
            for (; t3--; )
              this._activeBuffer.x = this._activeBuffer.nextStop();
            return true;
          }
          cursorBackwardTab(e3) {
            if (this._activeBuffer.x >= this._bufferService.cols)
              return true;
            let t3 = e3.params[0] || 1;
            for (; t3--; )
              this._activeBuffer.x = this._activeBuffer.prevStop();
            return true;
          }
          selectProtected(e3) {
            const t3 = e3.params[0];
            return 1 === t3 && (this._curAttrData.bg |= 536870912), 2 !== t3 && 0 !== t3 || (this._curAttrData.bg &= -536870913), true;
          }
          _eraseInBufferLine(e3, t3, i3, s3 = false, r2 = false) {
            const n3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
            n3.replaceCells(t3, i3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), r2), s3 && (n3.isWrapped = false);
          }
          _resetBufferLine(e3, t3 = false) {
            const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
            i3 && (i3.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t3), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e3), i3.isWrapped = false);
          }
          eraseInDisplay(e3, t3 = false) {
            let i3;
            switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
              case 0:
                for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3); i3 < this._bufferService.rows; i3++)
                  this._resetBufferLine(i3, t3);
                this._dirtyRowTracker.markDirty(i3);
                break;
              case 1:
                for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3, 0, this._activeBuffer.x + 1, true, t3), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i3 + 1).isWrapped = false); i3--; )
                  this._resetBufferLine(i3, t3);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 2:
                for (i3 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i3 - 1); i3--; )
                  this._resetBufferLine(i3, t3);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 3:
                const e4 = this._activeBuffer.lines.length - this._bufferService.rows;
                e4 > 0 && (this._activeBuffer.lines.trimStart(e4), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e4, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e4, 0), this._onScroll.fire(0));
            }
            return true;
          }
          eraseInLine(e3, t3 = false) {
            switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
              case 0:
                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3);
                break;
              case 1:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t3);
                break;
              case 2:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t3);
            }
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
          }
          insertLines(e3) {
            this._restrictCursor();
            let t3 = e3.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return true;
            const i3 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
            for (; t3--; )
              this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
          }
          deleteLines(e3) {
            this._restrictCursor();
            let t3 = e3.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return true;
            const i3 = this._activeBuffer.ybase + this._activeBuffer.y;
            let s3;
            for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3; t3--; )
              this._activeBuffer.lines.splice(i3, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
          }
          insertChars(e3) {
            this._restrictCursor();
            const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t3 && (t3.insertCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          deleteChars(e3) {
            this._restrictCursor();
            const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t3 && (t3.deleteCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          scrollUp(e3) {
            let t3 = e3.params[0] || 1;
            for (; t3--; )
              this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollDown(e3) {
            let t3 = e3.params[0] || 1;
            for (; t3--; )
              this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollLeft(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.deleteCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollRight(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.insertCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          insertColumns(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.insertCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          deleteColumns(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
              return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.deleteCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          eraseChars(e3) {
            this._restrictCursor();
            const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t3 && (t3.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e3.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          repeatPrecedingCharacter(e3) {
            if (!this._parser.precedingCodepoint)
              return true;
            const t3 = e3.params[0] || 1, i3 = new Uint32Array(t3);
            for (let e4 = 0; e4 < t3; ++e4)
              i3[e4] = this._parser.precedingCodepoint;
            return this.print(i3, 0, i3.length), true;
          }
          sendDeviceAttributesPrimary(e3) {
            return e3.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n2.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n2.C0.ESC + "[?6c")), true;
          }
          sendDeviceAttributesSecondary(e3) {
            return e3.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n2.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n2.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e3.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n2.C0.ESC + "[>83;40003;0c")), true;
          }
          _is(e3) {
            return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e3);
          }
          setMode(e3) {
            for (let t3 = 0; t3 < e3.length; t3++)
              switch (e3.params[t3]) {
                case 4:
                  this._coreService.modes.insertMode = true;
                  break;
                case 20:
                  this._optionsService.options.convertEol = true;
              }
            return true;
          }
          setModePrivate(e3) {
            for (let t3 = 0; t3 < e3.length; t3++)
              switch (e3.params[t3]) {
                case 1:
                  this._coreService.decPrivateModes.applicationCursorKeys = true;
                  break;
                case 2:
                  this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                  break;
                case 3:
                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                  break;
                case 6:
                  this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                  break;
                case 7:
                  this._coreService.decPrivateModes.wraparound = true;
                  break;
                case 12:
                  this._optionsService.options.cursorBlink = true;
                  break;
                case 45:
                  this._coreService.decPrivateModes.reverseWraparound = true;
                  break;
                case 66:
                  this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                  break;
                case 9:
                  this._coreMouseService.activeProtocol = "X10";
                  break;
                case 1e3:
                  this._coreMouseService.activeProtocol = "VT200";
                  break;
                case 1002:
                  this._coreMouseService.activeProtocol = "DRAG";
                  break;
                case 1003:
                  this._coreMouseService.activeProtocol = "ANY";
                  break;
                case 1004:
                  this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                  break;
                case 1005:
                  this._logService.debug("DECSET 1005 not supported (see #2507)");
                  break;
                case 1006:
                  this._coreMouseService.activeEncoding = "SGR";
                  break;
                case 1015:
                  this._logService.debug("DECSET 1015 not supported (see #2507)");
                  break;
                case 1016:
                  this._coreMouseService.activeEncoding = "SGR_PIXELS";
                  break;
                case 25:
                  this._coreService.isCursorHidden = false;
                  break;
                case 1048:
                  this.saveCursor();
                  break;
                case 1049:
                  this.saveCursor();
                case 47:
                case 1047:
                  this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                  break;
                case 2004:
                  this._coreService.decPrivateModes.bracketedPasteMode = true;
              }
            return true;
          }
          resetMode(e3) {
            for (let t3 = 0; t3 < e3.length; t3++)
              switch (e3.params[t3]) {
                case 4:
                  this._coreService.modes.insertMode = false;
                  break;
                case 20:
                  this._optionsService.options.convertEol = false;
              }
            return true;
          }
          resetModePrivate(e3) {
            for (let t3 = 0; t3 < e3.length; t3++)
              switch (e3.params[t3]) {
                case 1:
                  this._coreService.decPrivateModes.applicationCursorKeys = false;
                  break;
                case 3:
                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                  break;
                case 6:
                  this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                  break;
                case 7:
                  this._coreService.decPrivateModes.wraparound = false;
                  break;
                case 12:
                  this._optionsService.options.cursorBlink = false;
                  break;
                case 45:
                  this._coreService.decPrivateModes.reverseWraparound = false;
                  break;
                case 66:
                  this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                  break;
                case 9:
                case 1e3:
                case 1002:
                case 1003:
                  this._coreMouseService.activeProtocol = "NONE";
                  break;
                case 1004:
                  this._coreService.decPrivateModes.sendFocus = false;
                  break;
                case 1005:
                  this._logService.debug("DECRST 1005 not supported (see #2507)");
                  break;
                case 1006:
                case 1016:
                  this._coreMouseService.activeEncoding = "DEFAULT";
                  break;
                case 1015:
                  this._logService.debug("DECRST 1015 not supported (see #2507)");
                  break;
                case 25:
                  this._coreService.isCursorHidden = true;
                  break;
                case 1048:
                  this.restoreCursor();
                  break;
                case 1049:
                case 47:
                case 1047:
                  this._bufferService.buffers.activateNormalBuffer(), 1049 === e3.params[t3] && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                  break;
                case 2004:
                  this._coreService.decPrivateModes.bracketedPasteMode = false;
              }
            return true;
          }
          requestMode(e3, t3) {
            const i3 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h2 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _2 = (e4) => e4 ? 1 : 2, u2 = e3.params[0];
            return f2 = u2, v2 = t3 ? 2 === u2 ? 4 : 4 === u2 ? _2(o2.modes.insertMode) : 12 === u2 ? 3 : 20 === u2 ? _2(d2.convertEol) : 0 : 1 === u2 ? _2(i3.applicationCursorKeys) : 3 === u2 ? d2.windowOptions.setWinLines ? 80 === h2 ? 2 : 132 === h2 ? 1 : 0 : 0 : 6 === u2 ? _2(i3.origin) : 7 === u2 ? _2(i3.wraparound) : 8 === u2 ? 3 : 9 === u2 ? _2("X10" === s3) : 12 === u2 ? _2(d2.cursorBlink) : 25 === u2 ? _2(!o2.isCursorHidden) : 45 === u2 ? _2(i3.reverseWraparound) : 66 === u2 ? _2(i3.applicationKeypad) : 67 === u2 ? 4 : 1e3 === u2 ? _2("VT200" === s3) : 1002 === u2 ? _2("DRAG" === s3) : 1003 === u2 ? _2("ANY" === s3) : 1004 === u2 ? _2(i3.sendFocus) : 1005 === u2 ? 4 : 1006 === u2 ? _2("SGR" === r2) : 1015 === u2 ? 4 : 1016 === u2 ? _2("SGR_PIXELS" === r2) : 1048 === u2 ? 1 : 47 === u2 || 1047 === u2 || 1049 === u2 ? _2(c2 === l2) : 2004 === u2 ? _2(i3.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n2.C0.ESC}[${t3 ? "" : "?"}${f2};${v2}$y`), true;
            var f2, v2;
          }
          _updateAttrColor(e3, t3, i3, s3, r2) {
            return 2 === t3 ? (e3 |= 50331648, e3 &= -16777216, e3 |= f.AttributeData.fromColorRGB([i3, s3, r2])) : 5 === t3 && (e3 &= -50331904, e3 |= 33554432 | 255 & i3), e3;
          }
          _extractColor(e3, t3, i3) {
            const s3 = [0, 0, -1, 0, 0, 0];
            let r2 = 0, n3 = 0;
            do {
              if (s3[n3 + r2] = e3.params[t3 + n3], e3.hasSubParams(t3 + n3)) {
                const i4 = e3.getSubParams(t3 + n3);
                let o2 = 0;
                do {
                  5 === s3[1] && (r2 = 1), s3[n3 + o2 + 1 + r2] = i4[o2];
                } while (++o2 < i4.length && o2 + n3 + 1 + r2 < s3.length);
                break;
              }
              if (5 === s3[1] && n3 + r2 >= 2 || 2 === s3[1] && n3 + r2 >= 5)
                break;
              s3[1] && (r2 = 1);
            } while (++n3 + t3 < e3.length && n3 + r2 < s3.length);
            for (let e4 = 2; e4 < s3.length; ++e4)
              -1 === s3[e4] && (s3[e4] = 0);
            switch (s3[0]) {
              case 38:
                i3.fg = this._updateAttrColor(i3.fg, s3[1], s3[3], s3[4], s3[5]);
                break;
              case 48:
                i3.bg = this._updateAttrColor(i3.bg, s3[1], s3[3], s3[4], s3[5]);
                break;
              case 58:
                i3.extended = i3.extended.clone(), i3.extended.underlineColor = this._updateAttrColor(i3.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
            }
            return n3;
          }
          _processUnderline(e3, t3) {
            t3.extended = t3.extended.clone(), (!~e3 || e3 > 5) && (e3 = 1), t3.extended.underlineStyle = e3, t3.fg |= 268435456, 0 === e3 && (t3.fg &= -268435457), t3.updateExtended();
          }
          _processSGR0(e3) {
            e3.fg = l.DEFAULT_ATTR_DATA.fg, e3.bg = l.DEFAULT_ATTR_DATA.bg, e3.extended = e3.extended.clone(), e3.extended.underlineStyle = 0, e3.extended.underlineColor &= -67108864, e3.updateExtended();
          }
          charAttributes(e3) {
            if (1 === e3.length && 0 === e3.params[0])
              return this._processSGR0(this._curAttrData), true;
            const t3 = e3.length;
            let i3;
            const s3 = this._curAttrData;
            for (let r2 = 0; r2 < t3; r2++)
              i3 = e3.params[r2], i3 >= 30 && i3 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i3 - 30) : i3 >= 40 && i3 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i3 - 40) : i3 >= 90 && i3 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i3 - 90) : i3 >= 100 && i3 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i3 - 100) : 0 === i3 ? this._processSGR0(s3) : 1 === i3 ? s3.fg |= 134217728 : 3 === i3 ? s3.bg |= 67108864 : 4 === i3 ? (s3.fg |= 268435456, this._processUnderline(e3.hasSubParams(r2) ? e3.getSubParams(r2)[0] : 1, s3)) : 5 === i3 ? s3.fg |= 536870912 : 7 === i3 ? s3.fg |= 67108864 : 8 === i3 ? s3.fg |= 1073741824 : 9 === i3 ? s3.fg |= 2147483648 : 2 === i3 ? s3.bg |= 134217728 : 21 === i3 ? this._processUnderline(2, s3) : 22 === i3 ? (s3.fg &= -134217729, s3.bg &= -134217729) : 23 === i3 ? s3.bg &= -67108865 : 24 === i3 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : 25 === i3 ? s3.fg &= -536870913 : 27 === i3 ? s3.fg &= -67108865 : 28 === i3 ? s3.fg &= -1073741825 : 29 === i3 ? s3.fg &= 2147483647 : 39 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i3 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i3 || 48 === i3 || 58 === i3 ? r2 += this._extractColor(e3, r2, s3) : 53 === i3 ? s3.bg |= 1073741824 : 55 === i3 ? s3.bg &= -1073741825 : 59 === i3 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : 100 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i3);
            return true;
          }
          deviceStatus(e3) {
            switch (e3.params[0]) {
              case 5:
                this._coreService.triggerDataEvent(`${n2.C0.ESC}[0n`);
                break;
              case 6:
                const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${n2.C0.ESC}[${e4};${t3}R`);
            }
            return true;
          }
          deviceStatusPrivate(e3) {
            if (6 === e3.params[0]) {
              const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${n2.C0.ESC}[?${e4};${t3}R`);
            }
            return true;
          }
          softReset(e3) {
            return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
          }
          setCursorStyle(e3) {
            const t3 = e3.params[0] || 1;
            switch (t3) {
              case 1:
              case 2:
                this._optionsService.options.cursorStyle = "block";
                break;
              case 3:
              case 4:
                this._optionsService.options.cursorStyle = "underline";
                break;
              case 5:
              case 6:
                this._optionsService.options.cursorStyle = "bar";
            }
            const i3 = t3 % 2 == 1;
            return this._optionsService.options.cursorBlink = i3, true;
          }
          setScrollRegion(e3) {
            const t3 = e3.params[0] || 1;
            let i3;
            return (e3.length < 2 || (i3 = e3.params[1]) > this._bufferService.rows || 0 === i3) && (i3 = this._bufferService.rows), i3 > t3 && (this._activeBuffer.scrollTop = t3 - 1, this._activeBuffer.scrollBottom = i3 - 1, this._setCursor(0, 0)), true;
          }
          windowOptions(e3) {
            if (!b(e3.params[0], this._optionsService.rawOptions.windowOptions))
              return true;
            const t3 = e3.length > 1 ? e3.params[1] : 0;
            switch (e3.params[0]) {
              case 14:
                2 !== t3 && this._onRequestWindowsOptionsReport.fire(y.GET_WIN_SIZE_PIXELS);
                break;
              case 16:
                this._onRequestWindowsOptionsReport.fire(y.GET_CELL_SIZE_PIXELS);
                break;
              case 18:
                this._bufferService && this._coreService.triggerDataEvent(`${n2.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                break;
              case 22:
                0 !== t3 && 2 !== t3 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t3 && 1 !== t3 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                break;
              case 23:
                0 !== t3 && 2 !== t3 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t3 && 1 !== t3 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
            }
            return true;
          }
          saveCursor(e3) {
            return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
          }
          restoreCursor(e3) {
            return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
          }
          setTitle(e3) {
            return this._windowTitle = e3, this._onTitleChange.fire(e3), true;
          }
          setIconName(e3) {
            return this._iconName = e3, true;
          }
          setOrReportIndexedColor(e3) {
            const t3 = [], i3 = e3.split(";");
            for (; i3.length > 1; ) {
              const e4 = i3.shift(), s3 = i3.shift();
              if (/^\d+$/.exec(e4)) {
                const i4 = parseInt(e4);
                if (0 <= i4 && i4 < 256)
                  if ("?" === s3)
                    t3.push({ type: 0, index: i4 });
                  else {
                    const e5 = (0, S.parseColor)(s3);
                    e5 && t3.push({ type: 1, index: i4, color: e5 });
                  }
              }
            }
            return t3.length && this._onColor.fire(t3), true;
          }
          setHyperlink(e3) {
            const t3 = e3.split(";");
            return !(t3.length < 2) && (t3[1] ? this._createHyperlink(t3[0], t3[1]) : !t3[0] && this._finishHyperlink());
          }
          _createHyperlink(e3, t3) {
            this._getCurrentLinkId() && this._finishHyperlink();
            const i3 = e3.split(":");
            let s3;
            const r2 = i3.findIndex((e4) => e4.startsWith("id="));
            return -1 !== r2 && (s3 = i3[r2].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: s3, uri: t3 }), this._curAttrData.updateExtended(), true;
          }
          _finishHyperlink() {
            return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
          }
          _setOrReportSpecialColor(e3, t3) {
            const i3 = e3.split(";");
            for (let e4 = 0; e4 < i3.length && !(t3 >= this._specialColors.length); ++e4, ++t3)
              if ("?" === i3[e4])
                this._onColor.fire([{ type: 0, index: this._specialColors[t3] }]);
              else {
                const s3 = (0, S.parseColor)(i3[e4]);
                s3 && this._onColor.fire([{ type: 1, index: this._specialColors[t3], color: s3 }]);
              }
            return true;
          }
          setOrReportFgColor(e3) {
            return this._setOrReportSpecialColor(e3, 0);
          }
          setOrReportBgColor(e3) {
            return this._setOrReportSpecialColor(e3, 1);
          }
          setOrReportCursorColor(e3) {
            return this._setOrReportSpecialColor(e3, 2);
          }
          restoreIndexedColor(e3) {
            if (!e3)
              return this._onColor.fire([{ type: 2 }]), true;
            const t3 = [], i3 = e3.split(";");
            for (let e4 = 0; e4 < i3.length; ++e4)
              if (/^\d+$/.exec(i3[e4])) {
                const s3 = parseInt(i3[e4]);
                0 <= s3 && s3 < 256 && t3.push({ type: 2, index: s3 });
              }
            return t3.length && this._onColor.fire(t3), true;
          }
          restoreFgColor(e3) {
            return this._onColor.fire([{ type: 2, index: 256 }]), true;
          }
          restoreBgColor(e3) {
            return this._onColor.fire([{ type: 2, index: 257 }]), true;
          }
          restoreCursorColor(e3) {
            return this._onColor.fire([{ type: 2, index: 258 }]), true;
          }
          nextLine() {
            return this._activeBuffer.x = 0, this.index(), true;
          }
          keypadApplicationMode() {
            return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
          }
          keypadNumericMode() {
            return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
          }
          selectDefaultCharset() {
            return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
          }
          selectCharset(e3) {
            return 2 !== e3.length ? (this.selectDefaultCharset(), true) : ("/" === e3[0] || this._charsetService.setgCharset(m[e3[0]], o.CHARSETS[e3[1]] || o.DEFAULT_CHARSET), true);
          }
          index() {
            return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
          }
          tabSet() {
            return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
          }
          reverseIndex() {
            if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
              const e3 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
              this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e3, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
            } else
              this._activeBuffer.y--, this._restrictCursor();
            return true;
          }
          fullReset() {
            return this._parser.reset(), this._onRequestReset.fire(), true;
          }
          reset() {
            this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
          }
          _eraseAttrData() {
            return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
          }
          setgLevel(e3) {
            return this._charsetService.setgLevel(e3), true;
          }
          screenAlignmentPattern() {
            const e3 = new u.CellData();
            e3.content = 1 << 22 | "E".charCodeAt(0), e3.fg = this._curAttrData.fg, e3.bg = this._curAttrData.bg, this._setCursor(0, 0);
            for (let t3 = 0; t3 < this._bufferService.rows; ++t3) {
              const i3 = this._activeBuffer.ybase + this._activeBuffer.y + t3, s3 = this._activeBuffer.lines.get(i3);
              s3 && (s3.fill(e3), s3.isWrapped = false);
            }
            return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
          }
          requestStatusString(e3, t3) {
            const i3 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
            return ((e4) => (this._coreService.triggerDataEvent(`${n2.C0.ESC}${e4}${n2.C0.ESC}\\`), true))('"q' === e3 ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e3 ? 'P1$r61;1"p' : "r" === e3 ? `P1$r${i3.scrollTop + 1};${i3.scrollBottom + 1}r` : "m" === e3 ? "P1$r0m" : " q" === e3 ? `P1$r${{ block: 2, underline: 4, bar: 6 }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
          }
          markRangeDirty(e3, t3) {
            this._dirtyRowTracker.markRangeDirty(e3, t3);
          }
        }
        t2.InputHandler = E;
        let L = class {
          constructor(e3) {
            this._bufferService = e3, this.clearRange();
          }
          clearRange() {
            this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
          }
          markDirty(e3) {
            e3 < this.start ? this.start = e3 : e3 > this.end && (this.end = e3);
          }
          markRangeDirty(e3, t3) {
            e3 > t3 && (w = e3, e3 = t3, t3 = w), e3 < this.start && (this.start = e3), t3 > this.end && (this.end = t3);
          }
          markAllDirty() {
            this.markRangeDirty(0, this._bufferService.rows - 1);
          }
        };
        L = s2([r(0, v.IBufferService)], L);
      }, 844: (e2, t2) => {
        function i2(e3) {
          for (const t3 of e3)
            t3.dispose();
          e3.length = 0;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getDisposeArrayDisposable = t2.disposeArray = t2.toDisposable = t2.Disposable = void 0, t2.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = false;
          }
          dispose() {
            this._isDisposed = true;
            for (const e3 of this._disposables)
              e3.dispose();
            this._disposables.length = 0;
          }
          register(e3) {
            return this._disposables.push(e3), e3;
          }
          unregister(e3) {
            const t3 = this._disposables.indexOf(e3);
            -1 !== t3 && this._disposables.splice(t3, 1);
          }
        }, t2.toDisposable = function(e3) {
          return { dispose: e3 };
        }, t2.disposeArray = i2, t2.getDisposeArrayDisposable = function(e3) {
          return { dispose: () => i2(e3) };
        };
      }, 1505: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.FourKeyMap = t2.TwoKeyMap = void 0;
        class i2 {
          constructor() {
            this._data = {};
          }
          set(e3, t3, i3) {
            this._data[e3] || (this._data[e3] = {}), this._data[e3][t3] = i3;
          }
          get(e3, t3) {
            return this._data[e3] ? this._data[e3][t3] : void 0;
          }
          clear() {
            this._data = {};
          }
        }
        t2.TwoKeyMap = i2, t2.FourKeyMap = class {
          constructor() {
            this._data = new i2();
          }
          set(e3, t3, s2, r, n2) {
            this._data.get(e3, t3) || this._data.set(e3, t3, new i2()), this._data.get(e3, t3).set(s2, r, n2);
          }
          get(e3, t3, i3, s2) {
            var r;
            return null === (r = this._data.get(e3, t3)) || void 0 === r ? void 0 : r.get(i3, s2);
          }
          clear() {
            this._data.clear();
          }
        };
      }, 6114: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isChromeOS = t2.isLinux = t2.isWindows = t2.isIphone = t2.isIpad = t2.isMac = t2.getSafariVersion = t2.isSafari = t2.isLegacyEdge = t2.isFirefox = t2.isNode = void 0, t2.isNode = "undefined" == typeof navigator;
        const i2 = t2.isNode ? "node" : navigator.userAgent, s2 = t2.isNode ? "node" : navigator.platform;
        t2.isFirefox = i2.includes("Firefox"), t2.isLegacyEdge = i2.includes("Edge"), t2.isSafari = /^((?!chrome|android).)*safari/i.test(i2), t2.getSafariVersion = function() {
          if (!t2.isSafari)
            return 0;
          const e3 = i2.match(/Version\/(\d+)/);
          return null === e3 || e3.length < 2 ? 0 : parseInt(e3[1]);
        }, t2.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t2.isIpad = "iPad" === s2, t2.isIphone = "iPhone" === s2, t2.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t2.isLinux = s2.indexOf("Linux") >= 0, t2.isChromeOS = /\bCrOS\b/.test(i2);
      }, 6106: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SortedList = void 0;
        let i2 = 0;
        t2.SortedList = class {
          constructor(e3) {
            this._getKey = e3, this._array = [];
          }
          clear() {
            this._array.length = 0;
          }
          insert(e3) {
            0 !== this._array.length ? (i2 = this._search(this._getKey(e3), 0, this._array.length - 1), this._array.splice(i2, 0, e3)) : this._array.push(e3);
          }
          delete(e3) {
            if (0 === this._array.length)
              return false;
            const t3 = this._getKey(e3);
            if (void 0 === t3)
              return false;
            if (i2 = this._search(t3, 0, this._array.length - 1), -1 === i2)
              return false;
            if (this._getKey(this._array[i2]) !== t3)
              return false;
            do {
              if (this._array[i2] === e3)
                return this._array.splice(i2, 1), true;
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === t3);
            return false;
          }
          *getKeyIterator(e3) {
            if (0 !== this._array.length && (i2 = this._search(e3, 0, this._array.length - 1), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
              do {
                yield this._array[i2];
              } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
          }
          forEachByKey(e3, t3) {
            if (0 !== this._array.length && (i2 = this._search(e3, 0, this._array.length - 1), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
              do {
                t3(this._array[i2]);
              } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
          }
          values() {
            return this._array.values();
          }
          _search(e3, t3, i3) {
            if (i3 < t3)
              return t3;
            let s2 = Math.floor((t3 + i3) / 2);
            const r = this._getKey(this._array[s2]);
            if (r > e3)
              return this._search(e3, t3, s2 - 1);
            if (r < e3)
              return this._search(e3, s2 + 1, i3);
            for (; s2 > 0 && this._getKey(this._array[s2 - 1]) === e3; )
              s2--;
            return s2;
          }
        };
      }, 7226: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DebouncedIdleTask = t2.IdleTaskQueue = t2.PriorityTaskQueue = void 0;
        const s2 = i2(6114);
        class r {
          constructor() {
            this._tasks = [], this._i = 0;
          }
          enqueue(e3) {
            this._tasks.push(e3), this._start();
          }
          flush() {
            for (; this._i < this._tasks.length; )
              this._tasks[this._i]() || this._i++;
            this.clear();
          }
          clear() {
            this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
          }
          _start() {
            this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
          }
          _process(e3) {
            this._idleCallback = void 0;
            let t3 = 0, i3 = 0, s3 = e3.timeRemaining(), r2 = 0;
            for (; this._i < this._tasks.length; ) {
              if (t3 = Date.now(), this._tasks[this._i]() || this._i++, t3 = Math.max(1, Date.now() - t3), i3 = Math.max(t3, i3), r2 = e3.timeRemaining(), 1.5 * i3 > r2)
                return s3 - t3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t3))}ms`), void this._start();
              s3 = r2;
            }
            this.clear();
          }
        }
        class n2 extends r {
          _requestCallback(e3) {
            return setTimeout(() => e3(this._createDeadline(16)));
          }
          _cancelCallback(e3) {
            clearTimeout(e3);
          }
          _createDeadline(e3) {
            const t3 = Date.now() + e3;
            return { timeRemaining: () => Math.max(0, t3 - Date.now()) };
          }
        }
        t2.PriorityTaskQueue = n2, t2.IdleTaskQueue = !s2.isNode && "requestIdleCallback" in window ? class extends r {
          _requestCallback(e3) {
            return requestIdleCallback(e3);
          }
          _cancelCallback(e3) {
            cancelIdleCallback(e3);
          }
        } : n2, t2.DebouncedIdleTask = class {
          constructor() {
            this._queue = new t2.IdleTaskQueue();
          }
          set(e3) {
            this._queue.clear(), this._queue.enqueue(e3);
          }
          flush() {
            this._queue.flush();
          }
        };
      }, 9282: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.updateWindowsModeWrappedState = void 0;
        const s2 = i2(643);
        t2.updateWindowsModeWrappedState = function(e3) {
          const t3 = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y - 1), i3 = null == t3 ? void 0 : t3.get(e3.cols - 1), r = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y);
          r && i3 && (r.isWrapped = i3[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i3[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
        };
      }, 3734: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ExtendedAttrs = t2.AttributeData = void 0;
        class i2 {
          constructor() {
            this.fg = 0, this.bg = 0, this.extended = new s2();
          }
          static toColorRGB(e3) {
            return [e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
          }
          static fromColorRGB(e3) {
            return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
          }
          clone() {
            const e3 = new i2();
            return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
          }
          isInverse() {
            return 67108864 & this.fg;
          }
          isBold() {
            return 134217728 & this.fg;
          }
          isUnderline() {
            return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
          }
          isBlink() {
            return 536870912 & this.fg;
          }
          isInvisible() {
            return 1073741824 & this.fg;
          }
          isItalic() {
            return 67108864 & this.bg;
          }
          isDim() {
            return 134217728 & this.bg;
          }
          isStrikethrough() {
            return 2147483648 & this.fg;
          }
          isProtected() {
            return 536870912 & this.bg;
          }
          isOverline() {
            return 1073741824 & this.bg;
          }
          getFgColorMode() {
            return 50331648 & this.fg;
          }
          getBgColorMode() {
            return 50331648 & this.bg;
          }
          isFgRGB() {
            return 50331648 == (50331648 & this.fg);
          }
          isBgRGB() {
            return 50331648 == (50331648 & this.bg);
          }
          isFgPalette() {
            return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
          }
          isBgPalette() {
            return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
          }
          isFgDefault() {
            return 0 == (50331648 & this.fg);
          }
          isBgDefault() {
            return 0 == (50331648 & this.bg);
          }
          isAttributeDefault() {
            return 0 === this.fg && 0 === this.bg;
          }
          getFgColor() {
            switch (50331648 & this.fg) {
              case 16777216:
              case 33554432:
                return 255 & this.fg;
              case 50331648:
                return 16777215 & this.fg;
              default:
                return -1;
            }
          }
          getBgColor() {
            switch (50331648 & this.bg) {
              case 16777216:
              case 33554432:
                return 255 & this.bg;
              case 50331648:
                return 16777215 & this.bg;
              default:
                return -1;
            }
          }
          hasExtendedAttrs() {
            return 268435456 & this.bg;
          }
          updateExtended() {
            this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
          }
          getUnderlineColor() {
            if (268435456 & this.bg && ~this.extended.underlineColor)
              switch (50331648 & this.extended.underlineColor) {
                case 16777216:
                case 33554432:
                  return 255 & this.extended.underlineColor;
                case 50331648:
                  return 16777215 & this.extended.underlineColor;
                default:
                  return this.getFgColor();
              }
            return this.getFgColor();
          }
          getUnderlineColorMode() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
          }
          isUnderlineColorRGB() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
          }
          isUnderlineColorPalette() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
          }
          isUnderlineColorDefault() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
          }
          getUnderlineStyle() {
            return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
          }
        }
        t2.AttributeData = i2;
        class s2 {
          constructor(e3 = 0, t3 = 0) {
            this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t3;
          }
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(e3) {
            this._ext = e3;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(e3) {
            this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(e3) {
            this._ext &= -67108864, this._ext |= 67108863 & e3;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(e3) {
            this._urlId = e3;
          }
          clone() {
            return new s2(this._ext, this._urlId);
          }
          isEmpty() {
            return 0 === this.underlineStyle && 0 === this._urlId;
          }
        }
        t2.ExtendedAttrs = s2;
      }, 9092: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Buffer = t2.MAX_BUFFER_SIZE = void 0;
        const s2 = i2(6349), r = i2(8437), n2 = i2(511), o = i2(643), a = i2(4634), h = i2(4863), c = i2(7116), l = i2(3734), d = i2(7226);
        t2.MAX_BUFFER_SIZE = 4294967295, t2.Buffer = class {
          constructor(e3, t3, i3) {
            this._hasScrollback = e3, this._optionsService = t3, this._bufferService = i3, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = r.DEFAULT_ATTR_DATA.clone(), this.savedCharset = c.DEFAULT_CHARSET, this.markers = [], this._nullCell = n2.CellData.fromCharData([0, o.NULL_CELL_CHAR, o.NULL_CELL_WIDTH, o.NULL_CELL_CODE]), this._whitespaceCell = n2.CellData.fromCharData([0, o.WHITESPACE_CELL_CHAR, o.WHITESPACE_CELL_WIDTH, o.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new d.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          getNullCell(e3) {
            return e3 ? (this._nullCell.fg = e3.fg, this._nullCell.bg = e3.bg, this._nullCell.extended = e3.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new l.ExtendedAttrs()), this._nullCell;
          }
          getWhitespaceCell(e3) {
            return e3 ? (this._whitespaceCell.fg = e3.fg, this._whitespaceCell.bg = e3.bg, this._whitespaceCell.extended = e3.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new l.ExtendedAttrs()), this._whitespaceCell;
          }
          getBlankLine(e3, t3) {
            return new r.BufferLine(this._bufferService.cols, this.getNullCell(e3), t3);
          }
          get hasScrollback() {
            return this._hasScrollback && this.lines.maxLength > this._rows;
          }
          get isCursorInViewport() {
            const e3 = this.ybase + this.y - this.ydisp;
            return e3 >= 0 && e3 < this._rows;
          }
          _getCorrectBufferLength(e3) {
            if (!this._hasScrollback)
              return e3;
            const i3 = e3 + this._optionsService.rawOptions.scrollback;
            return i3 > t2.MAX_BUFFER_SIZE ? t2.MAX_BUFFER_SIZE : i3;
          }
          fillViewportRows(e3) {
            if (0 === this.lines.length) {
              void 0 === e3 && (e3 = r.DEFAULT_ATTR_DATA);
              let t3 = this._rows;
              for (; t3--; )
                this.lines.push(this.getBlankLine(e3));
            }
          }
          clear() {
            this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          resize(e3, t3) {
            const i3 = this.getNullCell(r.DEFAULT_ATTR_DATA);
            let s3 = 0;
            const n3 = this._getCorrectBufferLength(t3);
            if (n3 > this.lines.maxLength && (this.lines.maxLength = n3), this.lines.length > 0) {
              if (this._cols < e3)
                for (let t4 = 0; t4 < this.lines.length; t4++)
                  s3 += +this.lines.get(t4).resize(e3, i3);
              let o2 = 0;
              if (this._rows < t3)
                for (let s4 = this._rows; s4 < t3; s4++)
                  this.lines.length < t3 + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new r.BufferLine(e3, i3)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + o2 + 1 ? (this.ybase--, o2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new r.BufferLine(e3, i3)));
              else
                for (let e4 = this._rows; e4 > t3; e4--)
                  this.lines.length > t3 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
              if (n3 < this.lines.maxLength) {
                const e4 = this.lines.length - n3;
                e4 > 0 && (this.lines.trimStart(e4), this.ybase = Math.max(this.ybase - e4, 0), this.ydisp = Math.max(this.ydisp - e4, 0), this.savedY = Math.max(this.savedY - e4, 0)), this.lines.maxLength = n3;
              }
              this.x = Math.min(this.x, e3 - 1), this.y = Math.min(this.y, t3 - 1), o2 && (this.y += o2), this.savedX = Math.min(this.savedX, e3 - 1), this.scrollTop = 0;
            }
            if (this.scrollBottom = t3 - 1, this._isReflowEnabled && (this._reflow(e3, t3), this._cols > e3))
              for (let t4 = 0; t4 < this.lines.length; t4++)
                s3 += +this.lines.get(t4).resize(e3, i3);
            this._cols = e3, this._rows = t3, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
          }
          _batchedMemoryCleanup() {
            let e3 = true;
            this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e3 = false);
            let t3 = 0;
            for (; this._memoryCleanupPosition < this.lines.length; )
              if (t3 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t3 > 100)
                return true;
            return e3;
          }
          get _isReflowEnabled() {
            const e3 = this._optionsService.rawOptions.windowsPty;
            return e3 && e3.buildNumber ? this._hasScrollback && "conpty" === e3.backend && e3.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
          }
          _reflow(e3, t3) {
            this._cols !== e3 && (e3 > this._cols ? this._reflowLarger(e3, t3) : this._reflowSmaller(e3, t3));
          }
          _reflowLarger(e3, t3) {
            const i3 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e3, this.ybase + this.y, this.getNullCell(r.DEFAULT_ATTR_DATA));
            if (i3.length > 0) {
              const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i3);
              (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e3, t3, s3.countRemoved);
            }
          }
          _reflowLargerAdjustViewport(e3, t3, i3) {
            const s3 = this.getNullCell(r.DEFAULT_ATTR_DATA);
            let n3 = i3;
            for (; n3-- > 0; )
              0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t3 && this.lines.push(new r.BufferLine(e3, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
            this.savedY = Math.max(this.savedY - i3, 0);
          }
          _reflowSmaller(e3, t3) {
            const i3 = this.getNullCell(r.DEFAULT_ATTR_DATA), s3 = [];
            let n3 = 0;
            for (let o2 = this.lines.length - 1; o2 >= 0; o2--) {
              let h2 = this.lines.get(o2);
              if (!h2 || !h2.isWrapped && h2.getTrimmedLength() <= e3)
                continue;
              const c2 = [h2];
              for (; h2.isWrapped && o2 > 0; )
                h2 = this.lines.get(--o2), c2.unshift(h2);
              const l2 = this.ybase + this.y;
              if (l2 >= o2 && l2 < o2 + c2.length)
                continue;
              const d2 = c2[c2.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e3), u = _.length - c2.length;
              let f;
              f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
              const v = [];
              for (let e4 = 0; e4 < u; e4++) {
                const e5 = this.getBlankLine(r.DEFAULT_ATTR_DATA, true);
                v.push(e5);
              }
              v.length > 0 && (s3.push({ start: o2 + c2.length + n3, newLines: v }), n3 += v.length), c2.push(...v);
              let g = _.length - 1, p = _[g];
              0 === p && (g--, p = _[g]);
              let S = c2.length - u - 1, m = d2;
              for (; S >= 0; ) {
                const e4 = Math.min(m, p);
                if (void 0 === c2[g])
                  break;
                if (c2[g].copyCellsFrom(c2[S], m - e4, p - e4, e4, true), p -= e4, 0 === p && (g--, p = _[g]), m -= e4, 0 === m) {
                  S--;
                  const e5 = Math.max(S, 0);
                  m = (0, a.getWrappedLineTrimmedLength)(c2, e5, this._cols);
                }
              }
              for (let t4 = 0; t4 < c2.length; t4++)
                _[t4] < e3 && c2[t4].setCell(_[t4], i3);
              let C = u - f;
              for (; C-- > 0; )
                0 === this.ybase ? this.y < t3 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + n3) - t3 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
              this.savedY = Math.min(this.savedY + u, this.ybase + t3 - 1);
            }
            if (s3.length > 0) {
              const e4 = [], t4 = [];
              for (let e5 = 0; e5 < this.lines.length; e5++)
                t4.push(this.lines.get(e5));
              const i4 = this.lines.length;
              let r2 = i4 - 1, o2 = 0, a2 = s3[o2];
              this.lines.length = Math.min(this.lines.maxLength, this.lines.length + n3);
              let h2 = 0;
              for (let c3 = Math.min(this.lines.maxLength - 1, i4 + n3 - 1); c3 >= 0; c3--)
                if (a2 && a2.start > r2 + h2) {
                  for (let e5 = a2.newLines.length - 1; e5 >= 0; e5--)
                    this.lines.set(c3--, a2.newLines[e5]);
                  c3++, e4.push({ index: r2 + 1, amount: a2.newLines.length }), h2 += a2.newLines.length, a2 = s3[++o2];
                } else
                  this.lines.set(c3, t4[r2--]);
              let c2 = 0;
              for (let t5 = e4.length - 1; t5 >= 0; t5--)
                e4[t5].index += c2, this.lines.onInsertEmitter.fire(e4[t5]), c2 += e4[t5].amount;
              const l2 = Math.max(0, i4 + n3 - this.lines.maxLength);
              l2 > 0 && this.lines.onTrimEmitter.fire(l2);
            }
          }
          translateBufferLineToString(e3, t3, i3 = 0, s3) {
            const r2 = this.lines.get(e3);
            return r2 ? r2.translateToString(t3, i3, s3) : "";
          }
          getWrappedRangeForLine(e3) {
            let t3 = e3, i3 = e3;
            for (; t3 > 0 && this.lines.get(t3).isWrapped; )
              t3--;
            for (; i3 + 1 < this.lines.length && this.lines.get(i3 + 1).isWrapped; )
              i3++;
            return { first: t3, last: i3 };
          }
          setupTabStops(e3) {
            for (null != e3 ? this.tabs[e3] || (e3 = this.prevStop(e3)) : (this.tabs = {}, e3 = 0); e3 < this._cols; e3 += this._optionsService.rawOptions.tabStopWidth)
              this.tabs[e3] = true;
          }
          prevStop(e3) {
            for (null == e3 && (e3 = this.x); !this.tabs[--e3] && e3 > 0; )
              ;
            return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
          }
          nextStop(e3) {
            for (null == e3 && (e3 = this.x); !this.tabs[++e3] && e3 < this._cols; )
              ;
            return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
          }
          clearMarkers(e3) {
            this._isClearing = true;
            for (let t3 = 0; t3 < this.markers.length; t3++)
              this.markers[t3].line === e3 && (this.markers[t3].dispose(), this.markers.splice(t3--, 1));
            this._isClearing = false;
          }
          clearAllMarkers() {
            this._isClearing = true;
            for (let e3 = 0; e3 < this.markers.length; e3++)
              this.markers[e3].dispose(), this.markers.splice(e3--, 1);
            this._isClearing = false;
          }
          addMarker(e3) {
            const t3 = new h.Marker(e3);
            return this.markers.push(t3), t3.register(this.lines.onTrim((e4) => {
              t3.line -= e4, t3.line < 0 && t3.dispose();
            })), t3.register(this.lines.onInsert((e4) => {
              t3.line >= e4.index && (t3.line += e4.amount);
            })), t3.register(this.lines.onDelete((e4) => {
              t3.line >= e4.index && t3.line < e4.index + e4.amount && t3.dispose(), t3.line > e4.index && (t3.line -= e4.amount);
            })), t3.register(t3.onDispose(() => this._removeMarker(t3))), t3;
          }
          _removeMarker(e3) {
            this._isClearing || this.markers.splice(this.markers.indexOf(e3), 1);
          }
        };
      }, 8437: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLine = t2.DEFAULT_ATTR_DATA = void 0;
        const s2 = i2(482), r = i2(643), n2 = i2(511), o = i2(3734);
        t2.DEFAULT_ATTR_DATA = Object.freeze(new o.AttributeData());
        let a = 0;
        class h {
          constructor(e3, t3, i3 = false) {
            this.isWrapped = i3, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e3);
            const s3 = t3 || n2.CellData.fromCharData([0, r.NULL_CELL_CHAR, r.NULL_CELL_WIDTH, r.NULL_CELL_CODE]);
            for (let t4 = 0; t4 < e3; ++t4)
              this.setCell(t4, s3);
            this.length = e3;
          }
          get(e3) {
            const t3 = this._data[3 * e3 + 0], i3 = 2097151 & t3;
            return [this._data[3 * e3 + 1], 2097152 & t3 ? this._combined[e3] : i3 ? (0, s2.stringFromCodePoint)(i3) : "", t3 >> 22, 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : i3];
          }
          set(e3, t3) {
            this._data[3 * e3 + 1] = t3[r.CHAR_DATA_ATTR_INDEX], t3[r.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e3] = t3[1], this._data[3 * e3 + 0] = 2097152 | e3 | t3[r.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e3 + 0] = t3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t3[r.CHAR_DATA_WIDTH_INDEX] << 22;
          }
          getWidth(e3) {
            return this._data[3 * e3 + 0] >> 22;
          }
          hasWidth(e3) {
            return 12582912 & this._data[3 * e3 + 0];
          }
          getFg(e3) {
            return this._data[3 * e3 + 1];
          }
          getBg(e3) {
            return this._data[3 * e3 + 2];
          }
          hasContent(e3) {
            return 4194303 & this._data[3 * e3 + 0];
          }
          getCodePoint(e3) {
            const t3 = this._data[3 * e3 + 0];
            return 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : 2097151 & t3;
          }
          isCombined(e3) {
            return 2097152 & this._data[3 * e3 + 0];
          }
          getString(e3) {
            const t3 = this._data[3 * e3 + 0];
            return 2097152 & t3 ? this._combined[e3] : 2097151 & t3 ? (0, s2.stringFromCodePoint)(2097151 & t3) : "";
          }
          isProtected(e3) {
            return 536870912 & this._data[3 * e3 + 2];
          }
          loadCell(e3, t3) {
            return a = 3 * e3, t3.content = this._data[a + 0], t3.fg = this._data[a + 1], t3.bg = this._data[a + 2], 2097152 & t3.content && (t3.combinedData = this._combined[e3]), 268435456 & t3.bg && (t3.extended = this._extendedAttrs[e3]), t3;
          }
          setCell(e3, t3) {
            2097152 & t3.content && (this._combined[e3] = t3.combinedData), 268435456 & t3.bg && (this._extendedAttrs[e3] = t3.extended), this._data[3 * e3 + 0] = t3.content, this._data[3 * e3 + 1] = t3.fg, this._data[3 * e3 + 2] = t3.bg;
          }
          setCellFromCodePoint(e3, t3, i3, s3, r2, n3) {
            268435456 & r2 && (this._extendedAttrs[e3] = n3), this._data[3 * e3 + 0] = t3 | i3 << 22, this._data[3 * e3 + 1] = s3, this._data[3 * e3 + 2] = r2;
          }
          addCodepointToCell(e3, t3) {
            let i3 = this._data[3 * e3 + 0];
            2097152 & i3 ? this._combined[e3] += (0, s2.stringFromCodePoint)(t3) : (2097151 & i3 ? (this._combined[e3] = (0, s2.stringFromCodePoint)(2097151 & i3) + (0, s2.stringFromCodePoint)(t3), i3 &= -2097152, i3 |= 2097152) : i3 = t3 | 1 << 22, this._data[3 * e3 + 0] = i3);
          }
          insertCells(e3, t3, i3, s3) {
            if ((e3 %= this.length) && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs()), t3 < this.length - e3) {
              const s4 = new n2.CellData();
              for (let i4 = this.length - e3 - t3 - 1; i4 >= 0; --i4)
                this.setCell(e3 + t3 + i4, this.loadCell(e3 + i4, s4));
              for (let s5 = 0; s5 < t3; ++s5)
                this.setCell(e3 + s5, i3);
            } else
              for (let t4 = e3; t4 < this.length; ++t4)
                this.setCell(t4, i3);
            2 === this.getWidth(this.length - 1) && this.setCellFromCodePoint(this.length - 1, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs());
          }
          deleteCells(e3, t3, i3, s3) {
            if (e3 %= this.length, t3 < this.length - e3) {
              const s4 = new n2.CellData();
              for (let i4 = 0; i4 < this.length - e3 - t3; ++i4)
                this.setCell(e3 + i4, this.loadCell(e3 + t3 + i4, s4));
              for (let e4 = this.length - t3; e4 < this.length; ++e4)
                this.setCell(e4, i3);
            } else
              for (let t4 = e3; t4 < this.length; ++t4)
                this.setCell(t4, i3);
            e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs()), 0 !== this.getWidth(e3) || this.hasContent(e3) || this.setCellFromCodePoint(e3, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs());
          }
          replaceCells(e3, t3, i3, s3, r2 = false) {
            if (r2)
              for (e3 && 2 === this.getWidth(e3 - 1) && !this.isProtected(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs()), t3 < this.length && 2 === this.getWidth(t3 - 1) && !this.isProtected(t3) && this.setCellFromCodePoint(t3, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs()); e3 < t3 && e3 < this.length; )
                this.isProtected(e3) || this.setCell(e3, i3), e3++;
            else
              for (e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs()), t3 < this.length && 2 === this.getWidth(t3 - 1) && this.setCellFromCodePoint(t3, 0, 1, (null == s3 ? void 0 : s3.fg) || 0, (null == s3 ? void 0 : s3.bg) || 0, (null == s3 ? void 0 : s3.extended) || new o.ExtendedAttrs()); e3 < t3 && e3 < this.length; )
                this.setCell(e3++, i3);
          }
          resize(e3, t3) {
            if (e3 === this.length)
              return 4 * this._data.length * 2 < this._data.buffer.byteLength;
            const i3 = 3 * e3;
            if (e3 > this.length) {
              if (this._data.buffer.byteLength >= 4 * i3)
                this._data = new Uint32Array(this._data.buffer, 0, i3);
              else {
                const e4 = new Uint32Array(i3);
                e4.set(this._data), this._data = e4;
              }
              for (let i4 = this.length; i4 < e3; ++i4)
                this.setCell(i4, t3);
            } else {
              this._data = this._data.subarray(0, i3);
              const t4 = Object.keys(this._combined);
              for (let i4 = 0; i4 < t4.length; i4++) {
                const s4 = parseInt(t4[i4], 10);
                s4 >= e3 && delete this._combined[s4];
              }
              const s3 = Object.keys(this._extendedAttrs);
              for (let t5 = 0; t5 < s3.length; t5++) {
                const i4 = parseInt(s3[t5], 10);
                i4 >= e3 && delete this._extendedAttrs[i4];
              }
            }
            return this.length = e3, 4 * i3 * 2 < this._data.buffer.byteLength;
          }
          cleanupMemory() {
            if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
              const e3 = new Uint32Array(this._data.length);
              return e3.set(this._data), this._data = e3, 1;
            }
            return 0;
          }
          fill(e3, t3 = false) {
            if (t3)
              for (let t4 = 0; t4 < this.length; ++t4)
                this.isProtected(t4) || this.setCell(t4, e3);
            else {
              this._combined = {}, this._extendedAttrs = {};
              for (let t4 = 0; t4 < this.length; ++t4)
                this.setCell(t4, e3);
            }
          }
          copyFrom(e3) {
            this.length !== e3.length ? this._data = new Uint32Array(e3._data) : this._data.set(e3._data), this.length = e3.length, this._combined = {};
            for (const t3 in e3._combined)
              this._combined[t3] = e3._combined[t3];
            this._extendedAttrs = {};
            for (const t3 in e3._extendedAttrs)
              this._extendedAttrs[t3] = e3._extendedAttrs[t3];
            this.isWrapped = e3.isWrapped;
          }
          clone() {
            const e3 = new h(0);
            e3._data = new Uint32Array(this._data), e3.length = this.length;
            for (const t3 in this._combined)
              e3._combined[t3] = this._combined[t3];
            for (const t3 in this._extendedAttrs)
              e3._extendedAttrs[t3] = this._extendedAttrs[t3];
            return e3.isWrapped = this.isWrapped, e3;
          }
          getTrimmedLength() {
            for (let e3 = this.length - 1; e3 >= 0; --e3)
              if (4194303 & this._data[3 * e3 + 0])
                return e3 + (this._data[3 * e3 + 0] >> 22);
            return 0;
          }
          copyCellsFrom(e3, t3, i3, s3, r2) {
            const n3 = e3._data;
            if (r2)
              for (let r3 = s3 - 1; r3 >= 0; r3--) {
                for (let e4 = 0; e4 < 3; e4++)
                  this._data[3 * (i3 + r3) + e4] = n3[3 * (t3 + r3) + e4];
                268435456 & n3[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
              }
            else
              for (let r3 = 0; r3 < s3; r3++) {
                for (let e4 = 0; e4 < 3; e4++)
                  this._data[3 * (i3 + r3) + e4] = n3[3 * (t3 + r3) + e4];
                268435456 & n3[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
              }
            const o2 = Object.keys(e3._combined);
            for (let s4 = 0; s4 < o2.length; s4++) {
              const r3 = parseInt(o2[s4], 10);
              r3 >= t3 && (this._combined[r3 - t3 + i3] = e3._combined[r3]);
            }
          }
          translateToString(e3 = false, t3 = 0, i3 = this.length) {
            e3 && (i3 = Math.min(i3, this.getTrimmedLength()));
            let n3 = "";
            for (; t3 < i3; ) {
              const e4 = this._data[3 * t3 + 0], i4 = 2097151 & e4;
              n3 += 2097152 & e4 ? this._combined[t3] : i4 ? (0, s2.stringFromCodePoint)(i4) : r.WHITESPACE_CELL_CHAR, t3 += e4 >> 22 || 1;
            }
            return n3;
          }
        }
        t2.BufferLine = h;
      }, 4841: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getRangeLength = void 0, t2.getRangeLength = function(e3, t3) {
          if (e3.start.y > e3.end.y)
            throw new Error(`Buffer range end (${e3.end.x}, ${e3.end.y}) cannot be before start (${e3.start.x}, ${e3.start.y})`);
          return t3 * (e3.end.y - e3.start.y) + (e3.end.x - e3.start.x + 1);
        };
      }, 4634: (e2, t2) => {
        function i2(e3, t3, i3) {
          if (t3 === e3.length - 1)
            return e3[t3].getTrimmedLength();
          const s2 = !e3[t3].hasContent(i3 - 1) && 1 === e3[t3].getWidth(i3 - 1), r = 2 === e3[t3 + 1].getWidth(0);
          return s2 && r ? i3 - 1 : i3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getWrappedLineTrimmedLength = t2.reflowSmallerGetNewLineLengths = t2.reflowLargerApplyNewLayout = t2.reflowLargerCreateNewLayout = t2.reflowLargerGetLinesToRemove = void 0, t2.reflowLargerGetLinesToRemove = function(e3, t3, s2, r, n2) {
          const o = [];
          for (let a = 0; a < e3.length - 1; a++) {
            let h = a, c = e3.get(++h);
            if (!c.isWrapped)
              continue;
            const l = [e3.get(a)];
            for (; h < e3.length && c.isWrapped; )
              l.push(c), c = e3.get(++h);
            if (r >= a && r < h) {
              a += l.length - 1;
              continue;
            }
            let d = 0, _ = i2(l, d, t3), u = 1, f = 0;
            for (; u < l.length; ) {
              const e4 = i2(l, u, t3), r2 = e4 - f, o2 = s2 - _, a2 = Math.min(r2, o2);
              l[d].copyCellsFrom(l[u], f, _, a2, false), _ += a2, _ === s2 && (d++, _ = 0), f += a2, f === e4 && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s2 - 1) && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _++, 1, false), l[d - 1].setCell(s2 - 1, n2));
            }
            l[d].replaceCells(_, s2, n2);
            let v = 0;
            for (let e4 = l.length - 1; e4 > 0 && (e4 > d || 0 === l[e4].getTrimmedLength()); e4--)
              v++;
            v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
          }
          return o;
        }, t2.reflowLargerCreateNewLayout = function(e3, t3) {
          const i3 = [];
          let s2 = 0, r = t3[s2], n2 = 0;
          for (let o = 0; o < e3.length; o++)
            if (r === o) {
              const i4 = t3[++s2];
              e3.onDeleteEmitter.fire({ index: o - n2, amount: i4 }), o += i4 - 1, n2 += i4, r = t3[++s2];
            } else
              i3.push(o);
          return { layout: i3, countRemoved: n2 };
        }, t2.reflowLargerApplyNewLayout = function(e3, t3) {
          const i3 = [];
          for (let s2 = 0; s2 < t3.length; s2++)
            i3.push(e3.get(t3[s2]));
          for (let t4 = 0; t4 < i3.length; t4++)
            e3.set(t4, i3[t4]);
          e3.length = t3.length;
        }, t2.reflowSmallerGetNewLineLengths = function(e3, t3, s2) {
          const r = [], n2 = e3.map((s3, r2) => i2(e3, r2, t3)).reduce((e4, t4) => e4 + t4);
          let o = 0, a = 0, h = 0;
          for (; h < n2; ) {
            if (n2 - h < s2) {
              r.push(n2 - h);
              break;
            }
            o += s2;
            const c = i2(e3, a, t3);
            o > c && (o -= c, a++);
            const l = 2 === e3[a].getWidth(o - 1);
            l && o--;
            const d = l ? s2 - 1 : s2;
            r.push(d), h += d;
          }
          return r;
        }, t2.getWrappedLineTrimmedLength = i2;
      }, 5295: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferSet = void 0;
        const s2 = i2(9092), r = i2(8460), n2 = i2(844);
        class o extends n2.Disposable {
          constructor(e3, t3) {
            super(), this._optionsService = e3, this._bufferService = t3, this._onBufferActivate = this.register(new r.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
          }
          reset() {
            this._normal = new s2.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new s2.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
          }
          get alt() {
            return this._alt;
          }
          get active() {
            return this._activeBuffer;
          }
          get normal() {
            return this._normal;
          }
          activateNormalBuffer() {
            this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
          }
          activateAltBuffer(e3) {
            this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e3), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
          }
          resize(e3, t3) {
            this._normal.resize(e3, t3), this._alt.resize(e3, t3), this.setupTabStops(e3);
          }
          setupTabStops(e3) {
            this._normal.setupTabStops(e3), this._alt.setupTabStops(e3);
          }
        }
        t2.BufferSet = o;
      }, 511: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CellData = void 0;
        const s2 = i2(482), r = i2(643), n2 = i2(3734);
        class o extends n2.AttributeData {
          constructor() {
            super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n2.ExtendedAttrs(), this.combinedData = "";
          }
          static fromCharData(e3) {
            const t3 = new o();
            return t3.setFromCharData(e3), t3;
          }
          isCombined() {
            return 2097152 & this.content;
          }
          getWidth() {
            return this.content >> 22;
          }
          getChars() {
            return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
          }
          getCode() {
            return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
          }
          setFromCharData(e3) {
            this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
            let t3 = false;
            if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2)
              t3 = true;
            else if (2 === e3[r.CHAR_DATA_CHAR_INDEX].length) {
              const i3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
              if (55296 <= i3 && i3 <= 56319) {
                const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i3 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t3 = true;
              } else
                t3 = true;
            } else
              this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
            t3 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        t2.CellData = o;
      }, 643: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WHITESPACE_CELL_CODE = t2.WHITESPACE_CELL_WIDTH = t2.WHITESPACE_CELL_CHAR = t2.NULL_CELL_CODE = t2.NULL_CELL_WIDTH = t2.NULL_CELL_CHAR = t2.CHAR_DATA_CODE_INDEX = t2.CHAR_DATA_WIDTH_INDEX = t2.CHAR_DATA_CHAR_INDEX = t2.CHAR_DATA_ATTR_INDEX = t2.DEFAULT_EXT = t2.DEFAULT_ATTR = t2.DEFAULT_COLOR = void 0, t2.DEFAULT_COLOR = 0, t2.DEFAULT_ATTR = 256 | t2.DEFAULT_COLOR << 9, t2.DEFAULT_EXT = 0, t2.CHAR_DATA_ATTR_INDEX = 0, t2.CHAR_DATA_CHAR_INDEX = 1, t2.CHAR_DATA_WIDTH_INDEX = 2, t2.CHAR_DATA_CODE_INDEX = 3, t2.NULL_CELL_CHAR = "", t2.NULL_CELL_WIDTH = 1, t2.NULL_CELL_CODE = 0, t2.WHITESPACE_CELL_CHAR = " ", t2.WHITESPACE_CELL_WIDTH = 1, t2.WHITESPACE_CELL_CODE = 32;
      }, 4863: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Marker = void 0;
        const s2 = i2(8460), r = i2(844);
        class n2 {
          constructor(e3) {
            this.line = e3, this.isDisposed = false, this._disposables = [], this._id = n2._nextId++, this._onDispose = this.register(new s2.EventEmitter()), this.onDispose = this._onDispose.event;
          }
          get id() {
            return this._id;
          }
          dispose() {
            this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
          }
          register(e3) {
            return this._disposables.push(e3), e3;
          }
        }
        t2.Marker = n2, n2._nextId = 1;
      }, 7116: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_CHARSET = t2.CHARSETS = void 0, t2.CHARSETS = {}, t2.DEFAULT_CHARSET = t2.CHARSETS.B, t2.CHARSETS[0] = { "`": "◆", a: "▒", b: "␉", c: "␌", d: "␍", e: "␊", f: "°", g: "±", h: "␤", i: "␋", j: "┘", k: "┐", l: "┌", m: "└", n: "┼", o: "⎺", p: "⎻", q: "─", r: "⎼", s: "⎽", t: "├", u: "┤", v: "┴", w: "┬", x: "│", y: "≤", z: "≥", "{": "π", "|": "≠", "}": "£", "~": "·" }, t2.CHARSETS.A = { "#": "£" }, t2.CHARSETS.B = void 0, t2.CHARSETS[4] = { "#": "£", "@": "¾", "[": "ij", "\\": "½", "]": "|", "{": "¨", "|": "f", "}": "¼", "~": "´" }, t2.CHARSETS.C = t2.CHARSETS[5] = { "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, t2.CHARSETS.R = { "#": "£", "@": "à", "[": "°", "\\": "ç", "]": "§", "{": "é", "|": "ù", "}": "è", "~": "¨" }, t2.CHARSETS.Q = { "@": "à", "[": "â", "\\": "ç", "]": "ê", "^": "î", "`": "ô", "{": "é", "|": "ù", "}": "è", "~": "û" }, t2.CHARSETS.K = { "@": "§", "[": "Ä", "\\": "Ö", "]": "Ü", "{": "ä", "|": "ö", "}": "ü", "~": "ß" }, t2.CHARSETS.Y = { "#": "£", "@": "§", "[": "°", "\\": "ç", "]": "é", "`": "ù", "{": "à", "|": "ò", "}": "è", "~": "ì" }, t2.CHARSETS.E = t2.CHARSETS[6] = { "@": "Ä", "[": "Æ", "\\": "Ø", "]": "Å", "^": "Ü", "`": "ä", "{": "æ", "|": "ø", "}": "å", "~": "ü" }, t2.CHARSETS.Z = { "#": "£", "@": "§", "[": "¡", "\\": "Ñ", "]": "¿", "{": "°", "|": "ñ", "}": "ç" }, t2.CHARSETS.H = t2.CHARSETS[7] = { "@": "É", "[": "Ä", "\\": "Ö", "]": "Å", "^": "Ü", "`": "é", "{": "ä", "|": "ö", "}": "å", "~": "ü" }, t2.CHARSETS["="] = { "#": "ù", "@": "à", "[": "é", "\\": "ç", "]": "ê", "^": "î", _: "è", "`": "ô", "{": "ä", "|": "ö", "}": "ü", "~": "û" };
      }, 2584: (e2, t2) => {
        var i2, s2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.C1_ESCAPED = t2.C1 = t2.C0 = void 0, function(e3) {
          e3.NUL = "\0", e3.SOH = "", e3.STX = "", e3.ETX = "", e3.EOT = "", e3.ENQ = "", e3.ACK = "", e3.BEL = "\x07", e3.BS = "\b", e3.HT = "	", e3.LF = "\n", e3.VT = "\v", e3.FF = "\f", e3.CR = "\r", e3.SO = "", e3.SI = "", e3.DLE = "", e3.DC1 = "", e3.DC2 = "", e3.DC3 = "", e3.DC4 = "", e3.NAK = "", e3.SYN = "", e3.ETB = "", e3.CAN = "", e3.EM = "", e3.SUB = "", e3.ESC = "\x1B", e3.FS = "", e3.GS = "", e3.RS = "", e3.US = "", e3.SP = " ", e3.DEL = "";
        }(i2 = t2.C0 || (t2.C0 = {})), (s2 = t2.C1 || (t2.C1 = {})).PAD = "", s2.HOP = "", s2.BPH = "", s2.NBH = "", s2.IND = "", s2.NEL = "", s2.SSA = "", s2.ESA = "", s2.HTS = "", s2.HTJ = "", s2.VTS = "", s2.PLD = "", s2.PLU = "", s2.RI = "", s2.SS2 = "", s2.SS3 = "", s2.DCS = "", s2.PU1 = "", s2.PU2 = "", s2.STS = "", s2.CCH = "", s2.MW = "", s2.SPA = "", s2.EPA = "", s2.SOS = "", s2.SGCI = "", s2.SCI = "", s2.CSI = "", s2.ST = "", s2.OSC = "", s2.PM = "", s2.APC = "", (t2.C1_ESCAPED || (t2.C1_ESCAPED = {})).ST = `${i2.ESC}\\`;
      }, 7399: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluateKeyboardEvent = void 0;
        const s2 = i2(2584), r = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
        t2.evaluateKeyboardEvent = function(e3, t3, i3, n2) {
          const o = { type: 0, cancel: false, key: void 0 }, a = (e3.shiftKey ? 1 : 0) | (e3.altKey ? 2 : 0) | (e3.ctrlKey ? 4 : 0) | (e3.metaKey ? 8 : 0);
          switch (e3.keyCode) {
            case 0:
              "UIKeyInputUpArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : "UIKeyInputRightArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : "UIKeyInputDownArrow" === e3.key && (o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
              break;
            case 8:
              if (e3.altKey) {
                o.key = s2.C0.ESC + s2.C0.DEL;
                break;
              }
              o.key = s2.C0.DEL;
              break;
            case 9:
              if (e3.shiftKey) {
                o.key = s2.C0.ESC + "[Z";
                break;
              }
              o.key = s2.C0.HT, o.cancel = true;
              break;
            case 13:
              o.key = e3.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
              break;
            case 27:
              o.key = s2.C0.ESC, e3.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
              break;
            case 37:
              if (e3.metaKey)
                break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i3 ? "b" : "[1;5D"))) : o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
              break;
            case 39:
              if (e3.metaKey)
                break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i3 ? "f" : "[1;5C"))) : o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
              break;
            case 38:
              if (e3.metaKey)
                break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i3 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
              break;
            case 40:
              if (e3.metaKey)
                break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i3 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
              break;
            case 45:
              e3.shiftKey || e3.ctrlKey || (o.key = s2.C0.ESC + "[2~");
              break;
            case 46:
              o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
              break;
            case 36:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t3 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
              break;
            case 35:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t3 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
              break;
            case 33:
              e3.shiftKey ? o.type = 2 : e3.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
              break;
            case 34:
              e3.shiftKey ? o.type = 3 : e3.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
              break;
            case 112:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
              break;
            case 113:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
              break;
            case 114:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
              break;
            case 115:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
              break;
            case 116:
              o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
              break;
            case 117:
              o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
              break;
            case 118:
              o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
              break;
            case 119:
              o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
              break;
            case 120:
              o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
              break;
            case 121:
              o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
              break;
            case 122:
              o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
              break;
            case 123:
              o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
              break;
            default:
              if (!e3.ctrlKey || e3.shiftKey || e3.altKey || e3.metaKey)
                if (i3 && !n2 || !e3.altKey || e3.metaKey)
                  !i3 || e3.altKey || e3.ctrlKey || e3.shiftKey || !e3.metaKey ? e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.keyCode >= 48 && 1 === e3.key.length ? o.key = e3.key : e3.key && e3.ctrlKey && ("_" === e3.key && (o.key = s2.C0.US), "@" === e3.key && (o.key = s2.C0.NUL)) : 65 === e3.keyCode && (o.type = 1);
                else {
                  const t4 = r[e3.keyCode], i4 = null == t4 ? void 0 : t4[e3.shiftKey ? 1 : 0];
                  if (i4)
                    o.key = s2.C0.ESC + i4;
                  else if (e3.keyCode >= 65 && e3.keyCode <= 90) {
                    const t5 = e3.ctrlKey ? e3.keyCode - 64 : e3.keyCode + 32;
                    let i5 = String.fromCharCode(t5);
                    e3.shiftKey && (i5 = i5.toUpperCase()), o.key = s2.C0.ESC + i5;
                  } else if (32 === e3.keyCode)
                    o.key = s2.C0.ESC + (e3.ctrlKey ? s2.C0.NUL : " ");
                  else if ("Dead" === e3.key && e3.code.startsWith("Key")) {
                    let t5 = e3.code.slice(3, 4);
                    e3.shiftKey || (t5 = t5.toLowerCase()), o.key = s2.C0.ESC + t5, o.cancel = true;
                  }
                }
              else
                e3.keyCode >= 65 && e3.keyCode <= 90 ? o.key = String.fromCharCode(e3.keyCode - 64) : 32 === e3.keyCode ? o.key = s2.C0.NUL : e3.keyCode >= 51 && e3.keyCode <= 55 ? o.key = String.fromCharCode(e3.keyCode - 51 + 27) : 56 === e3.keyCode ? o.key = s2.C0.DEL : 219 === e3.keyCode ? o.key = s2.C0.ESC : 220 === e3.keyCode ? o.key = s2.C0.FS : 221 === e3.keyCode && (o.key = s2.C0.GS);
          }
          return o;
        };
      }, 482: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utf8ToUtf32 = t2.StringToUtf32 = t2.utf32ToString = t2.stringFromCodePoint = void 0, t2.stringFromCodePoint = function(e3) {
          return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
        }, t2.utf32ToString = function(e3, t3 = 0, i2 = e3.length) {
          let s2 = "";
          for (let r = t3; r < i2; ++r) {
            let t4 = e3[r];
            t4 > 65535 ? (t4 -= 65536, s2 += String.fromCharCode(55296 + (t4 >> 10)) + String.fromCharCode(t4 % 1024 + 56320)) : s2 += String.fromCharCode(t4);
          }
          return s2;
        }, t2.StringToUtf32 = class {
          constructor() {
            this._interim = 0;
          }
          clear() {
            this._interim = 0;
          }
          decode(e3, t3) {
            const i2 = e3.length;
            if (!i2)
              return 0;
            let s2 = 0, r = 0;
            if (this._interim) {
              const i3 = e3.charCodeAt(r++);
              56320 <= i3 && i3 <= 57343 ? t3[s2++] = 1024 * (this._interim - 55296) + i3 - 56320 + 65536 : (t3[s2++] = this._interim, t3[s2++] = i3), this._interim = 0;
            }
            for (let n2 = r; n2 < i2; ++n2) {
              const r2 = e3.charCodeAt(n2);
              if (55296 <= r2 && r2 <= 56319) {
                if (++n2 >= i2)
                  return this._interim = r2, s2;
                const o = e3.charCodeAt(n2);
                56320 <= o && o <= 57343 ? t3[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t3[s2++] = r2, t3[s2++] = o);
              } else
                65279 !== r2 && (t3[s2++] = r2);
            }
            return s2;
          }
        }, t2.Utf8ToUtf32 = class {
          constructor() {
            this.interim = new Uint8Array(3);
          }
          clear() {
            this.interim.fill(0);
          }
          decode(e3, t3) {
            const i2 = e3.length;
            if (!i2)
              return 0;
            let s2, r, n2, o, a = 0, h = 0, c = 0;
            if (this.interim[0]) {
              let s3 = false, r2 = this.interim[0];
              r2 &= 192 == (224 & r2) ? 31 : 224 == (240 & r2) ? 15 : 7;
              let n3, o2 = 0;
              for (; (n3 = 63 & this.interim[++o2]) && o2 < 4; )
                r2 <<= 6, r2 |= n3;
              const h2 = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l2 = h2 - o2;
              for (; c < l2; ) {
                if (c >= i2)
                  return 0;
                if (n3 = e3[c++], 128 != (192 & n3)) {
                  c--, s3 = true;
                  break;
                }
                this.interim[o2++] = n3, r2 <<= 6, r2 |= 63 & n3;
              }
              s3 || (2 === h2 ? r2 < 128 ? c-- : t3[a++] = r2 : 3 === h2 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || 65279 === r2 || (t3[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t3[a++] = r2)), this.interim.fill(0);
            }
            const l = i2 - 4;
            let d = c;
            for (; d < i2; ) {
              for (; !(!(d < l) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (n2 = e3[d + 2]) || 128 & (o = e3[d + 3])); )
                t3[a++] = s2, t3[a++] = r, t3[a++] = n2, t3[a++] = o, d += 4;
              if (s2 = e3[d++], s2 < 128)
                t3[a++] = s2;
              else if (192 == (224 & s2)) {
                if (d >= i2)
                  return this.interim[0] = s2, a;
                if (r = e3[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                  d--;
                  continue;
                }
                t3[a++] = h;
              } else if (224 == (240 & s2)) {
                if (d >= i2)
                  return this.interim[0] = s2, a;
                if (r = e3[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (d >= i2)
                  return this.interim[0] = s2, this.interim[1] = r, a;
                if (n2 = e3[d++], 128 != (192 & n2)) {
                  d--;
                  continue;
                }
                if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & n2, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h)
                  continue;
                t3[a++] = h;
              } else if (240 == (248 & s2)) {
                if (d >= i2)
                  return this.interim[0] = s2, a;
                if (r = e3[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (d >= i2)
                  return this.interim[0] = s2, this.interim[1] = r, a;
                if (n2 = e3[d++], 128 != (192 & n2)) {
                  d--;
                  continue;
                }
                if (d >= i2)
                  return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n2, a;
                if (o = e3[d++], 128 != (192 & o)) {
                  d--;
                  continue;
                }
                if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & n2) << 6 | 63 & o, h < 65536 || h > 1114111)
                  continue;
                t3[a++] = h;
              }
            }
            return a;
          }
        };
      }, 225: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeV6 = void 0;
        const i2 = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], s2 = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
        let r;
        t2.UnicodeV6 = class {
          constructor() {
            if (this.version = "6", !r) {
              r = new Uint8Array(65536), r.fill(1), r[0] = 0, r.fill(0, 1, 32), r.fill(0, 127, 160), r.fill(2, 4352, 4448), r[9001] = 2, r[9002] = 2, r.fill(2, 11904, 42192), r[12351] = 1, r.fill(2, 44032, 55204), r.fill(2, 63744, 64256), r.fill(2, 65040, 65050), r.fill(2, 65072, 65136), r.fill(2, 65280, 65377), r.fill(2, 65504, 65511);
              for (let e3 = 0; e3 < i2.length; ++e3)
                r.fill(0, i2[e3][0], i2[e3][1] + 1);
            }
          }
          wcwidth(e3) {
            return e3 < 32 ? 0 : e3 < 127 ? 1 : e3 < 65536 ? r[e3] : function(e4, t3) {
              let i3, s3 = 0, r2 = t3.length - 1;
              if (e4 < t3[0][0] || e4 > t3[r2][1])
                return false;
              for (; r2 >= s3; )
                if (i3 = s3 + r2 >> 1, e4 > t3[i3][1])
                  s3 = i3 + 1;
                else {
                  if (!(e4 < t3[i3][0]))
                    return true;
                  r2 = i3 - 1;
                }
              return false;
            }(e3, s2) ? 0 : e3 >= 131072 && e3 <= 196605 || e3 >= 196608 && e3 <= 262141 ? 2 : 1;
          }
        };
      }, 5981: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WriteBuffer = void 0;
        const s2 = i2(8460), r = i2(844);
        class n2 extends r.Disposable {
          constructor(e3) {
            super(), this._action = e3, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
          }
          handleUserInput() {
            this._didUserInput = true;
          }
          writeSync(e3, t3) {
            if (void 0 !== t3 && this._syncCalls > t3)
              return void (this._syncCalls = 0);
            if (this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting)
              return;
            let i3;
            for (this._isSyncWriting = true; i3 = this._writeBuffer.shift(); ) {
              this._action(i3);
              const e4 = this._callbacks.shift();
              e4 && e4();
            }
            this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
          }
          write(e3, t3) {
            if (this._pendingData > 5e7)
              throw new Error("write data discarded, use flow control to avoid losing data");
            if (!this._writeBuffer.length) {
              if (this._bufferOffset = 0, this._didUserInput)
                return this._didUserInput = false, this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3), void this._innerWrite();
              setTimeout(() => this._innerWrite());
            }
            this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3);
          }
          _innerWrite(e3 = 0, t3 = true) {
            const i3 = e3 || Date.now();
            for (; this._writeBuffer.length > this._bufferOffset; ) {
              const e4 = this._writeBuffer[this._bufferOffset], s3 = this._action(e4, t3);
              if (s3) {
                const e5 = (e6) => Date.now() - i3 >= 12 ? setTimeout(() => this._innerWrite(0, e6)) : this._innerWrite(i3, e6);
                return void s3.catch((e6) => (queueMicrotask(() => {
                  throw e6;
                }), Promise.resolve(false))).then(e5);
              }
              const r2 = this._callbacks[this._bufferOffset];
              if (r2 && r2(), this._bufferOffset++, this._pendingData -= e4.length, Date.now() - i3 >= 12)
                break;
            }
            this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
          }
        }
        t2.WriteBuffer = n2;
      }, 5941: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.toRgbString = t2.parseColor = void 0;
        const i2 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
        function r(e3, t3) {
          const i3 = e3.toString(16), s3 = i3.length < 2 ? "0" + i3 : i3;
          switch (t3) {
            case 4:
              return i3[0];
            case 8:
              return s3;
            case 12:
              return (s3 + s3).slice(0, 3);
            default:
              return s3 + s3;
          }
        }
        t2.parseColor = function(e3) {
          if (!e3)
            return;
          let t3 = e3.toLowerCase();
          if (0 === t3.indexOf("rgb:")) {
            t3 = t3.slice(4);
            const e4 = i2.exec(t3);
            if (e4) {
              const t4 = e4[1] ? 15 : e4[4] ? 255 : e4[7] ? 4095 : 65535;
              return [Math.round(parseInt(e4[1] || e4[4] || e4[7] || e4[10], 16) / t4 * 255), Math.round(parseInt(e4[2] || e4[5] || e4[8] || e4[11], 16) / t4 * 255), Math.round(parseInt(e4[3] || e4[6] || e4[9] || e4[12], 16) / t4 * 255)];
            }
          } else if (0 === t3.indexOf("#") && (t3 = t3.slice(1), s2.exec(t3) && [3, 6, 9, 12].includes(t3.length))) {
            const e4 = t3.length / 3, i3 = [0, 0, 0];
            for (let s3 = 0; s3 < 3; ++s3) {
              const r2 = parseInt(t3.slice(e4 * s3, e4 * s3 + e4), 16);
              i3[s3] = 1 === e4 ? r2 << 4 : 2 === e4 ? r2 : 3 === e4 ? r2 >> 4 : r2 >> 8;
            }
            return i3;
          }
        }, t2.toRgbString = function(e3, t3 = 16) {
          const [i3, s3, n2] = e3;
          return `rgb:${r(i3, t3)}/${r(s3, t3)}/${r(n2, t3)}`;
        };
      }, 5770: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.PAYLOAD_LIMIT = void 0, t2.PAYLOAD_LIMIT = 1e7;
      }, 6351: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DcsHandler = t2.DcsParser = void 0;
        const s2 = i2(482), r = i2(8742), n2 = i2(5770), o = [];
        t2.DcsParser = class {
          constructor() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
            }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = o;
          }
          registerHandler(e3, t3) {
            void 0 === this._handlers[e3] && (this._handlers[e3] = []);
            const i3 = this._handlers[e3];
            return i3.push(t3), { dispose: () => {
              const e4 = i3.indexOf(t3);
              -1 !== e4 && i3.splice(e4, 1);
            } };
          }
          clearHandler(e3) {
            this._handlers[e3] && delete this._handlers[e3];
          }
          setHandlerFallback(e3) {
            this._handlerFb = e3;
          }
          reset() {
            if (this._active.length)
              for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3)
                this._active[e3].unhook(false);
            this._stack.paused = false, this._active = o, this._ident = 0;
          }
          hook(e3, t3) {
            if (this.reset(), this._ident = e3, this._active = this._handlers[e3] || o, this._active.length)
              for (let e4 = this._active.length - 1; e4 >= 0; e4--)
                this._active[e4].hook(t3);
            else
              this._handlerFb(this._ident, "HOOK", t3);
          }
          put(e3, t3, i3) {
            if (this._active.length)
              for (let s3 = this._active.length - 1; s3 >= 0; s3--)
                this._active[s3].put(e3, t3, i3);
            else
              this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e3, t3, i3));
          }
          unhook(e3, t3 = true) {
            if (this._active.length) {
              let i3 = false, s3 = this._active.length - 1, r2 = false;
              if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                for (; s3 >= 0 && (i3 = this._active[s3].unhook(e3), true !== i3); s3--)
                  if (i3 instanceof Promise)
                    return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                s3--;
              }
              for (; s3 >= 0; s3--)
                if (i3 = this._active[s3].unhook(false), i3 instanceof Promise)
                  return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
            } else
              this._handlerFb(this._ident, "UNHOOK", e3);
            this._active = o, this._ident = 0;
          }
        };
        const a = new r.Params();
        a.addParam(0), t2.DcsHandler = class {
          constructor(e3) {
            this._handler = e3, this._data = "", this._params = a, this._hitLimit = false;
          }
          hook(e3) {
            this._params = e3.length > 1 || e3.params[0] ? e3.clone() : a, this._data = "", this._hitLimit = false;
          }
          put(e3, t3, i3) {
            this._hitLimit || (this._data += (0, s2.utf32ToString)(e3, t3, i3), this._data.length > n2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
          }
          unhook(e3) {
            let t3 = false;
            if (this._hitLimit)
              t3 = false;
            else if (e3 && (t3 = this._handler(this._data, this._params), t3 instanceof Promise))
              return t3.then((e4) => (this._params = a, this._data = "", this._hitLimit = false, e4));
            return this._params = a, this._data = "", this._hitLimit = false, t3;
          }
        };
      }, 2015: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.EscapeSequenceParser = t2.VT500_TRANSITION_TABLE = t2.TransitionTable = void 0;
        const s2 = i2(844), r = i2(8742), n2 = i2(6242), o = i2(6351);
        class a {
          constructor(e3) {
            this.table = new Uint8Array(e3);
          }
          setDefault(e3, t3) {
            this.table.fill(e3 << 4 | t3);
          }
          add(e3, t3, i3, s3) {
            this.table[t3 << 8 | e3] = i3 << 4 | s3;
          }
          addMany(e3, t3, i3, s3) {
            for (let r2 = 0; r2 < e3.length; r2++)
              this.table[t3 << 8 | e3[r2]] = i3 << 4 | s3;
          }
        }
        t2.TransitionTable = a;
        const h = 160;
        t2.VT500_TRANSITION_TABLE = function() {
          const e3 = new a(4095), t3 = Array.apply(null, Array(256)).map((e4, t4) => t4), i3 = (e4, i4) => t3.slice(e4, i4), s3 = i3(32, 127), r2 = i3(0, 24);
          r2.push(25), r2.push.apply(r2, i3(28, 32));
          const n3 = i3(0, 14);
          let o2;
          for (o2 in e3.setDefault(1, 0), e3.addMany(s3, 0, 2, 0), n3)
            e3.addMany([24, 26, 153, 154], o2, 3, 0), e3.addMany(i3(128, 144), o2, 3, 0), e3.addMany(i3(144, 152), o2, 3, 0), e3.add(156, o2, 0, 0), e3.add(27, o2, 11, 1), e3.add(157, o2, 4, 8), e3.addMany([152, 158, 159], o2, 0, 7), e3.add(155, o2, 11, 3), e3.add(144, o2, 11, 9);
          return e3.addMany(r2, 0, 3, 0), e3.addMany(r2, 1, 3, 1), e3.add(127, 1, 0, 1), e3.addMany(r2, 8, 0, 8), e3.addMany(r2, 3, 3, 3), e3.add(127, 3, 0, 3), e3.addMany(r2, 4, 3, 4), e3.add(127, 4, 0, 4), e3.addMany(r2, 6, 3, 6), e3.addMany(r2, 5, 3, 5), e3.add(127, 5, 0, 5), e3.addMany(r2, 2, 3, 2), e3.add(127, 2, 0, 2), e3.add(93, 1, 4, 8), e3.addMany(s3, 8, 5, 8), e3.add(127, 8, 5, 8), e3.addMany([156, 27, 24, 26, 7], 8, 6, 0), e3.addMany(i3(28, 32), 8, 0, 8), e3.addMany([88, 94, 95], 1, 0, 7), e3.addMany(s3, 7, 0, 7), e3.addMany(r2, 7, 0, 7), e3.add(156, 7, 0, 0), e3.add(127, 7, 0, 7), e3.add(91, 1, 11, 3), e3.addMany(i3(64, 127), 3, 7, 0), e3.addMany(i3(48, 60), 3, 8, 4), e3.addMany([60, 61, 62, 63], 3, 9, 4), e3.addMany(i3(48, 60), 4, 8, 4), e3.addMany(i3(64, 127), 4, 7, 0), e3.addMany([60, 61, 62, 63], 4, 0, 6), e3.addMany(i3(32, 64), 6, 0, 6), e3.add(127, 6, 0, 6), e3.addMany(i3(64, 127), 6, 0, 0), e3.addMany(i3(32, 48), 3, 9, 5), e3.addMany(i3(32, 48), 5, 9, 5), e3.addMany(i3(48, 64), 5, 0, 6), e3.addMany(i3(64, 127), 5, 7, 0), e3.addMany(i3(32, 48), 4, 9, 5), e3.addMany(i3(32, 48), 1, 9, 2), e3.addMany(i3(32, 48), 2, 9, 2), e3.addMany(i3(48, 127), 2, 10, 0), e3.addMany(i3(48, 80), 1, 10, 0), e3.addMany(i3(81, 88), 1, 10, 0), e3.addMany([89, 90, 92], 1, 10, 0), e3.addMany(i3(96, 127), 1, 10, 0), e3.add(80, 1, 11, 9), e3.addMany(r2, 9, 0, 9), e3.add(127, 9, 0, 9), e3.addMany(i3(28, 32), 9, 0, 9), e3.addMany(i3(32, 48), 9, 9, 12), e3.addMany(i3(48, 60), 9, 8, 10), e3.addMany([60, 61, 62, 63], 9, 9, 10), e3.addMany(r2, 11, 0, 11), e3.addMany(i3(32, 128), 11, 0, 11), e3.addMany(i3(28, 32), 11, 0, 11), e3.addMany(r2, 10, 0, 10), e3.add(127, 10, 0, 10), e3.addMany(i3(28, 32), 10, 0, 10), e3.addMany(i3(48, 60), 10, 8, 10), e3.addMany([60, 61, 62, 63], 10, 0, 11), e3.addMany(i3(32, 48), 10, 9, 12), e3.addMany(r2, 12, 0, 12), e3.add(127, 12, 0, 12), e3.addMany(i3(28, 32), 12, 0, 12), e3.addMany(i3(32, 48), 12, 9, 12), e3.addMany(i3(48, 64), 12, 0, 11), e3.addMany(i3(64, 127), 12, 12, 13), e3.addMany(i3(64, 127), 10, 12, 13), e3.addMany(i3(64, 127), 9, 12, 13), e3.addMany(r2, 13, 13, 13), e3.addMany(s3, 13, 13, 13), e3.add(127, 13, 0, 13), e3.addMany([27, 156, 24, 26], 13, 14, 0), e3.add(h, 0, 2, 0), e3.add(h, 8, 5, 8), e3.add(h, 6, 0, 6), e3.add(h, 11, 0, 11), e3.add(h, 13, 13, 13), e3;
        }();
        class c extends s2.Disposable {
          constructor(e3 = t2.VT500_TRANSITION_TABLE) {
            super(), this._transitions = e3, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (e4, t3, i3) => {
            }, this._executeHandlerFb = (e4) => {
            }, this._csiHandlerFb = (e4, t3) => {
            }, this._escHandlerFb = (e4) => {
            }, this._errorHandlerFb = (e4) => e4, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, s2.toDisposable)(() => {
              this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
            })), this._oscParser = this.register(new n2.OscParser()), this._dcsParser = this.register(new o.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => true);
          }
          _identifier(e3, t3 = [64, 126]) {
            let i3 = 0;
            if (e3.prefix) {
              if (e3.prefix.length > 1)
                throw new Error("only one byte as prefix supported");
              if (i3 = e3.prefix.charCodeAt(0), i3 && 60 > i3 || i3 > 63)
                throw new Error("prefix must be in range 0x3c .. 0x3f");
            }
            if (e3.intermediates) {
              if (e3.intermediates.length > 2)
                throw new Error("only two bytes as intermediates are supported");
              for (let t4 = 0; t4 < e3.intermediates.length; ++t4) {
                const s4 = e3.intermediates.charCodeAt(t4);
                if (32 > s4 || s4 > 47)
                  throw new Error("intermediate must be in range 0x20 .. 0x2f");
                i3 <<= 8, i3 |= s4;
              }
            }
            if (1 !== e3.final.length)
              throw new Error("final must be a single byte");
            const s3 = e3.final.charCodeAt(0);
            if (t3[0] > s3 || s3 > t3[1])
              throw new Error(`final must be in range ${t3[0]} .. ${t3[1]}`);
            return i3 <<= 8, i3 |= s3, i3;
          }
          identToString(e3) {
            const t3 = [];
            for (; e3; )
              t3.push(String.fromCharCode(255 & e3)), e3 >>= 8;
            return t3.reverse().join("");
          }
          setPrintHandler(e3) {
            this._printHandler = e3;
          }
          clearPrintHandler() {
            this._printHandler = this._printHandlerFb;
          }
          registerEscHandler(e3, t3) {
            const i3 = this._identifier(e3, [48, 126]);
            void 0 === this._escHandlers[i3] && (this._escHandlers[i3] = []);
            const s3 = this._escHandlers[i3];
            return s3.push(t3), { dispose: () => {
              const e4 = s3.indexOf(t3);
              -1 !== e4 && s3.splice(e4, 1);
            } };
          }
          clearEscHandler(e3) {
            this._escHandlers[this._identifier(e3, [48, 126])] && delete this._escHandlers[this._identifier(e3, [48, 126])];
          }
          setEscHandlerFallback(e3) {
            this._escHandlerFb = e3;
          }
          setExecuteHandler(e3, t3) {
            this._executeHandlers[e3.charCodeAt(0)] = t3;
          }
          clearExecuteHandler(e3) {
            this._executeHandlers[e3.charCodeAt(0)] && delete this._executeHandlers[e3.charCodeAt(0)];
          }
          setExecuteHandlerFallback(e3) {
            this._executeHandlerFb = e3;
          }
          registerCsiHandler(e3, t3) {
            const i3 = this._identifier(e3);
            void 0 === this._csiHandlers[i3] && (this._csiHandlers[i3] = []);
            const s3 = this._csiHandlers[i3];
            return s3.push(t3), { dispose: () => {
              const e4 = s3.indexOf(t3);
              -1 !== e4 && s3.splice(e4, 1);
            } };
          }
          clearCsiHandler(e3) {
            this._csiHandlers[this._identifier(e3)] && delete this._csiHandlers[this._identifier(e3)];
          }
          setCsiHandlerFallback(e3) {
            this._csiHandlerFb = e3;
          }
          registerDcsHandler(e3, t3) {
            return this._dcsParser.registerHandler(this._identifier(e3), t3);
          }
          clearDcsHandler(e3) {
            this._dcsParser.clearHandler(this._identifier(e3));
          }
          setDcsHandlerFallback(e3) {
            this._dcsParser.setHandlerFallback(e3);
          }
          registerOscHandler(e3, t3) {
            return this._oscParser.registerHandler(e3, t3);
          }
          clearOscHandler(e3) {
            this._oscParser.clearHandler(e3);
          }
          setOscHandlerFallback(e3) {
            this._oscParser.setHandlerFallback(e3);
          }
          setErrorHandler(e3) {
            this._errorHandler = e3;
          }
          clearErrorHandler() {
            this._errorHandler = this._errorHandlerFb;
          }
          reset() {
            this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
          }
          _preserveStack(e3, t3, i3, s3, r2) {
            this._parseStack.state = e3, this._parseStack.handlers = t3, this._parseStack.handlerPos = i3, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
          }
          parse(e3, t3, i3) {
            let s3, r2 = 0, n3 = 0, o2 = 0;
            if (this._parseStack.state)
              if (2 === this._parseStack.state)
                this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
              else {
                if (void 0 === i3 || 1 === this._parseStack.state)
                  throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
                const t4 = this._parseStack.handlers;
                let n4 = this._parseStack.handlerPos - 1;
                switch (this._parseStack.state) {
                  case 3:
                    if (false === i3 && n4 > -1) {
                      for (; n4 >= 0 && (s3 = t4[n4](this._params), true !== s3); n4--)
                        if (s3 instanceof Promise)
                          return this._parseStack.handlerPos = n4, s3;
                    }
                    this._parseStack.handlers = [];
                    break;
                  case 4:
                    if (false === i3 && n4 > -1) {
                      for (; n4 >= 0 && (s3 = t4[n4](), true !== s3); n4--)
                        if (s3 instanceof Promise)
                          return this._parseStack.handlerPos = n4, s3;
                    }
                    this._parseStack.handlers = [];
                    break;
                  case 6:
                    if (r2 = e3[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2, i3), s3)
                      return s3;
                    27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                    break;
                  case 5:
                    if (r2 = e3[this._parseStack.chunkPos], s3 = this._oscParser.end(24 !== r2 && 26 !== r2, i3), s3)
                      return s3;
                    27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                }
                this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
              }
            for (let i4 = o2; i4 < t3; ++i4) {
              switch (r2 = e3[i4], n3 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h)], n3 >> 4) {
                case 2:
                  for (let s4 = i4 + 1; ; ++s4) {
                    if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                  }
                  break;
                case 3:
                  this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingCodepoint = 0;
                  break;
                case 0:
                  break;
                case 1:
                  if (this._errorHandler({ position: i4, code: r2, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort)
                    return;
                  break;
                case 7:
                  const o3 = this._csiHandlers[this._collect << 8 | r2];
                  let a2 = o3 ? o3.length - 1 : -1;
                  for (; a2 >= 0 && (s3 = o3[a2](this._params), true !== s3); a2--)
                    if (s3 instanceof Promise)
                      return this._preserveStack(3, o3, a2, n3, i4), s3;
                  a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingCodepoint = 0;
                  break;
                case 8:
                  do {
                    switch (r2) {
                      case 59:
                        this._params.addParam(0);
                        break;
                      case 58:
                        this._params.addSubParam(-1);
                        break;
                      default:
                        this._params.addDigit(r2 - 48);
                    }
                  } while (++i4 < t3 && (r2 = e3[i4]) > 47 && r2 < 60);
                  i4--;
                  break;
                case 9:
                  this._collect <<= 8, this._collect |= r2;
                  break;
                case 10:
                  const c2 = this._escHandlers[this._collect << 8 | r2];
                  let l = c2 ? c2.length - 1 : -1;
                  for (; l >= 0 && (s3 = c2[l](), true !== s3); l--)
                    if (s3 instanceof Promise)
                      return this._preserveStack(4, c2, l, n3, i4), s3;
                  l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingCodepoint = 0;
                  break;
                case 11:
                  this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 12:
                  this._dcsParser.hook(this._collect << 8 | r2, this._params);
                  break;
                case 13:
                  for (let s4 = i4 + 1; ; ++s4)
                    if (s4 >= t3 || 24 === (r2 = e3[s4]) || 26 === r2 || 27 === r2 || r2 > 127 && r2 < h) {
                      this._dcsParser.put(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                  break;
                case 14:
                  if (s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2), s3)
                    return this._preserveStack(6, [], 0, n3, i4), s3;
                  27 === r2 && (n3 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                  break;
                case 4:
                  this._oscParser.start();
                  break;
                case 5:
                  for (let s4 = i4 + 1; ; s4++)
                    if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 127 && r2 < h) {
                      this._oscParser.put(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                  break;
                case 6:
                  if (s3 = this._oscParser.end(24 !== r2 && 26 !== r2), s3)
                    return this._preserveStack(5, [], 0, n3, i4), s3;
                  27 === r2 && (n3 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
              }
              this.currentState = 15 & n3;
            }
          }
        }
        t2.EscapeSequenceParser = c;
      }, 6242: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OscHandler = t2.OscParser = void 0;
        const s2 = i2(5770), r = i2(482), n2 = [];
        t2.OscParser = class {
          constructor() {
            this._state = 0, this._active = n2, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
          }
          registerHandler(e3, t3) {
            void 0 === this._handlers[e3] && (this._handlers[e3] = []);
            const i3 = this._handlers[e3];
            return i3.push(t3), { dispose: () => {
              const e4 = i3.indexOf(t3);
              -1 !== e4 && i3.splice(e4, 1);
            } };
          }
          clearHandler(e3) {
            this._handlers[e3] && delete this._handlers[e3];
          }
          setHandlerFallback(e3) {
            this._handlerFb = e3;
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = n2;
          }
          reset() {
            if (2 === this._state)
              for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3)
                this._active[e3].end(false);
            this._stack.paused = false, this._active = n2, this._id = -1, this._state = 0;
          }
          _start() {
            if (this._active = this._handlers[this._id] || n2, this._active.length)
              for (let e3 = this._active.length - 1; e3 >= 0; e3--)
                this._active[e3].start();
            else
              this._handlerFb(this._id, "START");
          }
          _put(e3, t3, i3) {
            if (this._active.length)
              for (let s3 = this._active.length - 1; s3 >= 0; s3--)
                this._active[s3].put(e3, t3, i3);
            else
              this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e3, t3, i3));
          }
          start() {
            this.reset(), this._state = 1;
          }
          put(e3, t3, i3) {
            if (3 !== this._state) {
              if (1 === this._state)
                for (; t3 < i3; ) {
                  const i4 = e3[t3++];
                  if (59 === i4) {
                    this._state = 2, this._start();
                    break;
                  }
                  if (i4 < 48 || 57 < i4)
                    return void (this._state = 3);
                  -1 === this._id && (this._id = 0), this._id = 10 * this._id + i4 - 48;
                }
              2 === this._state && i3 - t3 > 0 && this._put(e3, t3, i3);
            }
          }
          end(e3, t3 = true) {
            if (0 !== this._state) {
              if (3 !== this._state)
                if (1 === this._state && this._start(), this._active.length) {
                  let i3 = false, s3 = this._active.length - 1, r2 = false;
                  if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                    for (; s3 >= 0 && (i3 = this._active[s3].end(e3), true !== i3); s3--)
                      if (i3 instanceof Promise)
                        return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                    s3--;
                  }
                  for (; s3 >= 0; s3--)
                    if (i3 = this._active[s3].end(false), i3 instanceof Promise)
                      return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
                } else
                  this._handlerFb(this._id, "END", e3);
              this._active = n2, this._id = -1, this._state = 0;
            }
          }
        }, t2.OscHandler = class {
          constructor(e3) {
            this._handler = e3, this._data = "", this._hitLimit = false;
          }
          start() {
            this._data = "", this._hitLimit = false;
          }
          put(e3, t3, i3) {
            this._hitLimit || (this._data += (0, r.utf32ToString)(e3, t3, i3), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
          }
          end(e3) {
            let t3 = false;
            if (this._hitLimit)
              t3 = false;
            else if (e3 && (t3 = this._handler(this._data), t3 instanceof Promise))
              return t3.then((e4) => (this._data = "", this._hitLimit = false, e4));
            return this._data = "", this._hitLimit = false, t3;
          }
        };
      }, 8742: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Params = void 0;
        const i2 = 2147483647;
        class s2 {
          constructor(e3 = 32, t3 = 32) {
            if (this.maxLength = e3, this.maxSubParamsLength = t3, t3 > 256)
              throw new Error("maxSubParamsLength must not be greater than 256");
            this.params = new Int32Array(e3), this.length = 0, this._subParams = new Int32Array(t3), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
          }
          static fromArray(e3) {
            const t3 = new s2();
            if (!e3.length)
              return t3;
            for (let i3 = Array.isArray(e3[0]) ? 1 : 0; i3 < e3.length; ++i3) {
              const s3 = e3[i3];
              if (Array.isArray(s3))
                for (let e4 = 0; e4 < s3.length; ++e4)
                  t3.addSubParam(s3[e4]);
              else
                t3.addParam(s3);
            }
            return t3;
          }
          clone() {
            const e3 = new s2(this.maxLength, this.maxSubParamsLength);
            return e3.params.set(this.params), e3.length = this.length, e3._subParams.set(this._subParams), e3._subParamsLength = this._subParamsLength, e3._subParamsIdx.set(this._subParamsIdx), e3._rejectDigits = this._rejectDigits, e3._rejectSubDigits = this._rejectSubDigits, e3._digitIsSub = this._digitIsSub, e3;
          }
          toArray() {
            const e3 = [];
            for (let t3 = 0; t3 < this.length; ++t3) {
              e3.push(this.params[t3]);
              const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
              s3 - i3 > 0 && e3.push(Array.prototype.slice.call(this._subParams, i3, s3));
            }
            return e3;
          }
          reset() {
            this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
          }
          addParam(e3) {
            if (this._digitIsSub = false, this.length >= this.maxLength)
              this._rejectDigits = true;
            else {
              if (e3 < -1)
                throw new Error("values lesser than -1 are not allowed");
              this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e3 > i2 ? i2 : e3;
            }
          }
          addSubParam(e3) {
            if (this._digitIsSub = true, this.length)
              if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength)
                this._rejectSubDigits = true;
              else {
                if (e3 < -1)
                  throw new Error("values lesser than -1 are not allowed");
                this._subParams[this._subParamsLength++] = e3 > i2 ? i2 : e3, this._subParamsIdx[this.length - 1]++;
              }
          }
          hasSubParams(e3) {
            return (255 & this._subParamsIdx[e3]) - (this._subParamsIdx[e3] >> 8) > 0;
          }
          getSubParams(e3) {
            const t3 = this._subParamsIdx[e3] >> 8, i3 = 255 & this._subParamsIdx[e3];
            return i3 - t3 > 0 ? this._subParams.subarray(t3, i3) : null;
          }
          getSubParamsAll() {
            const e3 = {};
            for (let t3 = 0; t3 < this.length; ++t3) {
              const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
              s3 - i3 > 0 && (e3[t3] = this._subParams.slice(i3, s3));
            }
            return e3;
          }
          addDigit(e3) {
            let t3;
            if (this._rejectDigits || !(t3 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits)
              return;
            const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t3 - 1];
            s3[t3 - 1] = ~r ? Math.min(10 * r + e3, i2) : e3;
          }
        }
        t2.Params = s2;
      }, 5741: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AddonManager = void 0, t2.AddonManager = class {
          constructor() {
            this._addons = [];
          }
          dispose() {
            for (let e3 = this._addons.length - 1; e3 >= 0; e3--)
              this._addons[e3].instance.dispose();
          }
          loadAddon(e3, t3) {
            const i2 = { instance: t3, dispose: t3.dispose, isDisposed: false };
            this._addons.push(i2), t3.dispose = () => this._wrappedAddonDispose(i2), t3.activate(e3);
          }
          _wrappedAddonDispose(e3) {
            if (e3.isDisposed)
              return;
            let t3 = -1;
            for (let i2 = 0; i2 < this._addons.length; i2++)
              if (this._addons[i2] === e3) {
                t3 = i2;
                break;
              }
            if (-1 === t3)
              throw new Error("Could not dispose an addon that has not been loaded");
            e3.isDisposed = true, e3.dispose.apply(e3.instance), this._addons.splice(t3, 1);
          }
        };
      }, 8771: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferApiView = void 0;
        const s2 = i2(3785), r = i2(511);
        t2.BufferApiView = class {
          constructor(e3, t3) {
            this._buffer = e3, this.type = t3;
          }
          init(e3) {
            return this._buffer = e3, this;
          }
          get cursorY() {
            return this._buffer.y;
          }
          get cursorX() {
            return this._buffer.x;
          }
          get viewportY() {
            return this._buffer.ydisp;
          }
          get baseY() {
            return this._buffer.ybase;
          }
          get length() {
            return this._buffer.lines.length;
          }
          getLine(e3) {
            const t3 = this._buffer.lines.get(e3);
            if (t3)
              return new s2.BufferLineApiView(t3);
          }
          getNullCell() {
            return new r.CellData();
          }
        };
      }, 3785: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLineApiView = void 0;
        const s2 = i2(511);
        t2.BufferLineApiView = class {
          constructor(e3) {
            this._line = e3;
          }
          get isWrapped() {
            return this._line.isWrapped;
          }
          get length() {
            return this._line.length;
          }
          getCell(e3, t3) {
            if (!(e3 < 0 || e3 >= this._line.length))
              return t3 ? (this._line.loadCell(e3, t3), t3) : this._line.loadCell(e3, new s2.CellData());
          }
          translateToString(e3, t3, i3) {
            return this._line.translateToString(e3, t3, i3);
          }
        };
      }, 8285: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferNamespaceApi = void 0;
        const s2 = i2(8771), r = i2(8460);
        t2.BufferNamespaceApi = class {
          constructor(e3) {
            this._core = e3, this._onBufferChange = new r.EventEmitter(), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
          }
          get active() {
            if (this._core.buffers.active === this._core.buffers.normal)
              return this.normal;
            if (this._core.buffers.active === this._core.buffers.alt)
              return this.alternate;
            throw new Error("Active buffer is neither normal nor alternate");
          }
          get normal() {
            return this._normal.init(this._core.buffers.normal);
          }
          get alternate() {
            return this._alternate.init(this._core.buffers.alt);
          }
        };
      }, 7975: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ParserApi = void 0, t2.ParserApi = class {
          constructor(e3) {
            this._core = e3;
          }
          registerCsiHandler(e3, t3) {
            return this._core.registerCsiHandler(e3, (e4) => t3(e4.toArray()));
          }
          addCsiHandler(e3, t3) {
            return this.registerCsiHandler(e3, t3);
          }
          registerDcsHandler(e3, t3) {
            return this._core.registerDcsHandler(e3, (e4, i2) => t3(e4, i2.toArray()));
          }
          addDcsHandler(e3, t3) {
            return this.registerDcsHandler(e3, t3);
          }
          registerEscHandler(e3, t3) {
            return this._core.registerEscHandler(e3, t3);
          }
          addEscHandler(e3, t3) {
            return this.registerEscHandler(e3, t3);
          }
          registerOscHandler(e3, t3) {
            return this._core.registerOscHandler(e3, t3);
          }
          addOscHandler(e3, t3) {
            return this.registerOscHandler(e3, t3);
          }
        };
      }, 7090: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeApi = void 0, t2.UnicodeApi = class {
          constructor(e3) {
            this._core = e3;
          }
          register(e3) {
            this._core.unicodeService.register(e3);
          }
          get versions() {
            return this._core.unicodeService.versions;
          }
          get activeVersion() {
            return this._core.unicodeService.activeVersion;
          }
          set activeVersion(e3) {
            this._core.unicodeService.activeVersion = e3;
          }
        };
      }, 744: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferService = t2.MINIMUM_ROWS = t2.MINIMUM_COLS = void 0;
        const n2 = i2(2585), o = i2(5295), a = i2(8460), h = i2(844);
        t2.MINIMUM_COLS = 2, t2.MINIMUM_ROWS = 1;
        let c = class extends h.Disposable {
          constructor(e3) {
            super(), this.isUserScrolling = false, this._onResize = this.register(new a.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new a.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e3.rawOptions.cols || 0, t2.MINIMUM_COLS), this.rows = Math.max(e3.rawOptions.rows || 0, t2.MINIMUM_ROWS), this.buffers = this.register(new o.BufferSet(e3, this));
          }
          get buffer() {
            return this.buffers.active;
          }
          resize(e3, t3) {
            this.cols = e3, this.rows = t3, this.buffers.resize(e3, t3), this._onResize.fire({ cols: e3, rows: t3 });
          }
          reset() {
            this.buffers.reset(), this.isUserScrolling = false;
          }
          scroll(e3, t3 = false) {
            const i3 = this.buffer;
            let s3;
            s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e3.fg && s3.getBg(0) === e3.bg || (s3 = i3.getBlankLine(e3, t3), this._cachedBlankLine = s3), s3.isWrapped = t3;
            const r2 = i3.ybase + i3.scrollTop, n3 = i3.ybase + i3.scrollBottom;
            if (0 === i3.scrollTop) {
              const e4 = i3.lines.isFull;
              n3 === i3.lines.length - 1 ? e4 ? i3.lines.recycle().copyFrom(s3) : i3.lines.push(s3.clone()) : i3.lines.splice(n3 + 1, 0, s3.clone()), e4 ? this.isUserScrolling && (i3.ydisp = Math.max(i3.ydisp - 1, 0)) : (i3.ybase++, this.isUserScrolling || i3.ydisp++);
            } else {
              const e4 = n3 - r2 + 1;
              i3.lines.shiftElements(r2 + 1, e4 - 1, -1), i3.lines.set(n3, s3.clone());
            }
            this.isUserScrolling || (i3.ydisp = i3.ybase), this._onScroll.fire(i3.ydisp);
          }
          scrollLines(e3, t3, i3) {
            const s3 = this.buffer;
            if (e3 < 0) {
              if (0 === s3.ydisp)
                return;
              this.isUserScrolling = true;
            } else
              e3 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
            const r2 = s3.ydisp;
            s3.ydisp = Math.max(Math.min(s3.ydisp + e3, s3.ybase), 0), r2 !== s3.ydisp && (t3 || this._onScroll.fire(s3.ydisp));
          }
          scrollPages(e3) {
            this.scrollLines(e3 * (this.rows - 1));
          }
          scrollToTop() {
            this.scrollLines(-this.buffer.ydisp);
          }
          scrollToBottom() {
            this.scrollLines(this.buffer.ybase - this.buffer.ydisp);
          }
          scrollToLine(e3) {
            const t3 = e3 - this.buffer.ydisp;
            0 !== t3 && this.scrollLines(t3);
          }
        };
        c = s2([r(0, n2.IOptionsService)], c), t2.BufferService = c;
      }, 7994: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CharsetService = void 0, t2.CharsetService = class {
          constructor() {
            this.glevel = 0, this._charsets = [];
          }
          reset() {
            this.charset = void 0, this._charsets = [], this.glevel = 0;
          }
          setgLevel(e3) {
            this.glevel = e3, this.charset = this._charsets[e3];
          }
          setgCharset(e3, t3) {
            this._charsets[e3] = t3, this.glevel === e3 && (this.charset = t3);
          }
        };
      }, 1753: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreMouseService = void 0;
        const n2 = i2(2585), o = i2(8460), a = i2(844), h = { NONE: { events: 0, restrict: () => false }, X10: { events: 1, restrict: (e3) => 4 !== e3.button && 1 === e3.action && (e3.ctrl = false, e3.alt = false, e3.shift = false, true) }, VT200: { events: 19, restrict: (e3) => 32 !== e3.action }, DRAG: { events: 23, restrict: (e3) => 32 !== e3.action || 3 !== e3.button }, ANY: { events: 31, restrict: (e3) => true } };
        function c(e3, t3) {
          let i3 = (e3.ctrl ? 16 : 0) | (e3.shift ? 4 : 0) | (e3.alt ? 8 : 0);
          return 4 === e3.button ? (i3 |= 64, i3 |= e3.action) : (i3 |= 3 & e3.button, 4 & e3.button && (i3 |= 64), 8 & e3.button && (i3 |= 128), 32 === e3.action ? i3 |= 32 : 0 !== e3.action || t3 || (i3 |= 3)), i3;
        }
        const l = String.fromCharCode, d = { DEFAULT: (e3) => {
          const t3 = [c(e3, false) + 32, e3.col + 32, e3.row + 32];
          return t3[0] > 255 || t3[1] > 255 || t3[2] > 255 ? "" : `\x1B[M${l(t3[0])}${l(t3[1])}${l(t3[2])}`;
        }, SGR: (e3) => {
          const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
          return `\x1B[<${c(e3, true)};${e3.col};${e3.row}${t3}`;
        }, SGR_PIXELS: (e3) => {
          const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
          return `\x1B[<${c(e3, true)};${e3.x};${e3.y}${t3}`;
        } };
        let _ = class extends a.Disposable {
          constructor(e3, t3) {
            super(), this._bufferService = e3, this._coreService = t3, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
            for (const e4 of Object.keys(h))
              this.addProtocol(e4, h[e4]);
            for (const e4 of Object.keys(d))
              this.addEncoding(e4, d[e4]);
            this.reset();
          }
          addProtocol(e3, t3) {
            this._protocols[e3] = t3;
          }
          addEncoding(e3, t3) {
            this._encodings[e3] = t3;
          }
          get activeProtocol() {
            return this._activeProtocol;
          }
          get areMouseEventsActive() {
            return 0 !== this._protocols[this._activeProtocol].events;
          }
          set activeProtocol(e3) {
            if (!this._protocols[e3])
              throw new Error(`unknown protocol "${e3}"`);
            this._activeProtocol = e3, this._onProtocolChange.fire(this._protocols[e3].events);
          }
          get activeEncoding() {
            return this._activeEncoding;
          }
          set activeEncoding(e3) {
            if (!this._encodings[e3])
              throw new Error(`unknown encoding "${e3}"`);
            this._activeEncoding = e3;
          }
          reset() {
            this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
          }
          triggerMouseEvent(e3) {
            if (e3.col < 0 || e3.col >= this._bufferService.cols || e3.row < 0 || e3.row >= this._bufferService.rows)
              return false;
            if (4 === e3.button && 32 === e3.action)
              return false;
            if (3 === e3.button && 32 !== e3.action)
              return false;
            if (4 !== e3.button && (2 === e3.action || 3 === e3.action))
              return false;
            if (e3.col++, e3.row++, 32 === e3.action && this._lastEvent && this._equalEvents(this._lastEvent, e3, "SGR_PIXELS" === this._activeEncoding))
              return false;
            if (!this._protocols[this._activeProtocol].restrict(e3))
              return false;
            const t3 = this._encodings[this._activeEncoding](e3);
            return t3 && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t3) : this._coreService.triggerDataEvent(t3, true)), this._lastEvent = e3, true;
          }
          explainEvents(e3) {
            return { down: !!(1 & e3), up: !!(2 & e3), drag: !!(4 & e3), move: !!(8 & e3), wheel: !!(16 & e3) };
          }
          _equalEvents(e3, t3, i3) {
            if (i3) {
              if (e3.x !== t3.x)
                return false;
              if (e3.y !== t3.y)
                return false;
            } else {
              if (e3.col !== t3.col)
                return false;
              if (e3.row !== t3.row)
                return false;
            }
            return e3.button === t3.button && e3.action === t3.action && e3.ctrl === t3.ctrl && e3.alt === t3.alt && e3.shift === t3.shift;
          }
        };
        _ = s2([r(0, n2.IBufferService), r(1, n2.ICoreService)], _), t2.CoreMouseService = _;
      }, 6975: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreService = void 0;
        const n2 = i2(2585), o = i2(8460), a = i2(1439), h = i2(844), c = Object.freeze({ insertMode: false }), l = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true });
        let d = class extends h.Disposable {
          constructor(e3, t3, i3) {
            super(), this._bufferService = e3, this._logService = t3, this._optionsService = i3, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, a.clone)(c), this.decPrivateModes = (0, a.clone)(l);
          }
          reset() {
            this.modes = (0, a.clone)(c), this.decPrivateModes = (0, a.clone)(l);
          }
          triggerDataEvent(e3, t3 = false) {
            if (this._optionsService.rawOptions.disableStdin)
              return;
            const i3 = this._bufferService.buffer;
            t3 && this._optionsService.rawOptions.scrollOnUserInput && i3.ybase !== i3.ydisp && this._onRequestScrollToBottom.fire(), t3 && this._onUserInput.fire(), this._logService.debug(`sending data "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onData.fire(e3);
          }
          triggerBinaryEvent(e3) {
            this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onBinary.fire(e3));
          }
        };
        d = s2([r(0, n2.IBufferService), r(1, n2.ILogService), r(2, n2.IOptionsService)], d), t2.CoreService = d;
      }, 9074: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DecorationService = void 0;
        const s2 = i2(8055), r = i2(8460), n2 = i2(844), o = i2(6106);
        let a = 0, h = 0;
        class c extends n2.Disposable {
          constructor() {
            super(), this._decorations = new o.SortedList((e3) => null == e3 ? void 0 : e3.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n2.toDisposable)(() => {
              for (const e3 of this._decorations.values())
                this._onDecorationRemoved.fire(e3);
              this.reset();
            }));
          }
          get decorations() {
            return this._decorations.values();
          }
          registerDecoration(e3) {
            if (e3.marker.isDisposed)
              return;
            const t3 = new l(e3);
            if (t3) {
              const e4 = t3.marker.onDispose(() => t3.dispose());
              t3.onDispose(() => {
                t3 && (this._decorations.delete(t3) && this._onDecorationRemoved.fire(t3), e4.dispose());
              }), this._decorations.insert(t3), this._onDecorationRegistered.fire(t3);
            }
            return t3;
          }
          reset() {
            for (const e3 of this._decorations.values())
              e3.dispose();
            this._decorations.clear();
          }
          *getDecorationsAtCell(e3, t3, i3) {
            var s3, r2, n3;
            let o2 = 0, a2 = 0;
            for (const h2 of this._decorations.getKeyIterator(t3))
              o2 = null !== (s3 = h2.options.x) && void 0 !== s3 ? s3 : 0, a2 = o2 + (null !== (r2 = h2.options.width) && void 0 !== r2 ? r2 : 1), e3 >= o2 && e3 < a2 && (!i3 || (null !== (n3 = h2.options.layer) && void 0 !== n3 ? n3 : "bottom") === i3) && (yield h2);
          }
          forEachDecorationAtCell(e3, t3, i3, s3) {
            this._decorations.forEachByKey(t3, (t4) => {
              var r2, n3, o2;
              a = null !== (r2 = t4.options.x) && void 0 !== r2 ? r2 : 0, h = a + (null !== (n3 = t4.options.width) && void 0 !== n3 ? n3 : 1), e3 >= a && e3 < h && (!i3 || (null !== (o2 = t4.options.layer) && void 0 !== o2 ? o2 : "bottom") === i3) && s3(t4);
            });
          }
          dispose() {
            for (const e3 of this._decorations.values())
              this._onDecorationRemoved.fire(e3);
            this.reset();
          }
        }
        t2.DecorationService = c;
        class l extends n2.Disposable {
          constructor(e3) {
            super(), this.options = e3, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e3.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
          }
          get isDisposed() {
            return this._isDisposed;
          }
          get backgroundColorRGB() {
            return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
          }
          get foregroundColorRGB() {
            return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
          }
          dispose() {
            this._onDispose.fire(), super.dispose();
          }
        }
      }, 4348: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.InstantiationService = t2.ServiceCollection = void 0;
        const s2 = i2(2585), r = i2(8343);
        class n2 {
          constructor(...e3) {
            this._entries = /* @__PURE__ */ new Map();
            for (const [t3, i3] of e3)
              this.set(t3, i3);
          }
          set(e3, t3) {
            const i3 = this._entries.get(e3);
            return this._entries.set(e3, t3), i3;
          }
          forEach(e3) {
            for (const [t3, i3] of this._entries.entries())
              e3(t3, i3);
          }
          has(e3) {
            return this._entries.has(e3);
          }
          get(e3) {
            return this._entries.get(e3);
          }
        }
        t2.ServiceCollection = n2, t2.InstantiationService = class {
          constructor() {
            this._services = new n2(), this._services.set(s2.IInstantiationService, this);
          }
          setService(e3, t3) {
            this._services.set(e3, t3);
          }
          getService(e3) {
            return this._services.get(e3);
          }
          createInstance(e3, ...t3) {
            const i3 = (0, r.getServiceDependencies)(e3).sort((e4, t4) => e4.index - t4.index), s3 = [];
            for (const t4 of i3) {
              const i4 = this._services.get(t4.id);
              if (!i4)
                throw new Error(`[createInstance] ${e3.name} depends on UNKNOWN service ${t4.id}.`);
              s3.push(i4);
            }
            const n3 = i3.length > 0 ? i3[0].index : t3.length;
            if (t3.length !== n3)
              throw new Error(`[createInstance] First service dependency of ${e3.name} at position ${n3 + 1} conflicts with ${t3.length} static arguments`);
            return new e3(...[...t3, ...s3]);
          }
        };
      }, 7866: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a2 = e3.length - 1; a2 >= 0; a2--)
              (r2 = e3[a2]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LogService = void 0;
        const n2 = i2(844), o = i2(2585), a = { debug: o.LogLevelEnum.DEBUG, info: o.LogLevelEnum.INFO, warn: o.LogLevelEnum.WARN, error: o.LogLevelEnum.ERROR, off: o.LogLevelEnum.OFF };
        let h = class extends n2.Disposable {
          constructor(e3) {
            super(), this._optionsService = e3, this.logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel()));
          }
          _updateLogLevel() {
            this.logLevel = a[this._optionsService.rawOptions.logLevel];
          }
          _evalLazyOptionalParams(e3) {
            for (let t3 = 0; t3 < e3.length; t3++)
              "function" == typeof e3[t3] && (e3[t3] = e3[t3]());
          }
          _log(e3, t3, i3) {
            this._evalLazyOptionalParams(i3), e3.call(console, "xterm.js: " + t3, ...i3);
          }
          debug(e3, ...t3) {
            this.logLevel <= o.LogLevelEnum.DEBUG && this._log(console.log, e3, t3);
          }
          info(e3, ...t3) {
            this.logLevel <= o.LogLevelEnum.INFO && this._log(console.info, e3, t3);
          }
          warn(e3, ...t3) {
            this.logLevel <= o.LogLevelEnum.WARN && this._log(console.warn, e3, t3);
          }
          error(e3, ...t3) {
            this.logLevel <= o.LogLevelEnum.ERROR && this._log(console.error, e3, t3);
          }
        };
        h = s2([r(0, o.IOptionsService)], h), t2.LogService = h;
      }, 7302: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionsService = t2.DEFAULT_OPTIONS = void 0;
        const s2 = i2(8460), r = i2(6114), n2 = i2(844);
        t2.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, customGlyphs: true, drawBoldTextInBrightColors: true, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", scrollback: 1e3, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rightClickSelectsWord: r.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
        const o = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
        class a extends n2.Disposable {
          constructor(e3) {
            super(), this._onOptionChange = this.register(new s2.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
            const i3 = Object.assign({}, t2.DEFAULT_OPTIONS);
            for (const t3 in e3)
              if (t3 in i3)
                try {
                  const s3 = e3[t3];
                  i3[t3] = this._sanitizeAndValidateOption(t3, s3);
                } catch (e4) {
                  console.error(e4);
                }
            this.rawOptions = i3, this.options = Object.assign({}, i3), this._setupOptions();
          }
          onSpecificOptionChange(e3, t3) {
            return this.onOptionChange((i3) => {
              i3 === e3 && t3(this.rawOptions[e3]);
            });
          }
          onMultipleOptionChange(e3, t3) {
            return this.onOptionChange((i3) => {
              -1 !== e3.indexOf(i3) && t3();
            });
          }
          _setupOptions() {
            const e3 = (e4) => {
              if (!(e4 in t2.DEFAULT_OPTIONS))
                throw new Error(`No option with key "${e4}"`);
              return this.rawOptions[e4];
            }, i3 = (e4, i4) => {
              if (!(e4 in t2.DEFAULT_OPTIONS))
                throw new Error(`No option with key "${e4}"`);
              i4 = this._sanitizeAndValidateOption(e4, i4), this.rawOptions[e4] !== i4 && (this.rawOptions[e4] = i4, this._onOptionChange.fire(e4));
            };
            for (const t3 in this.rawOptions) {
              const s3 = { get: e3.bind(this, t3), set: i3.bind(this, t3) };
              Object.defineProperty(this.options, t3, s3);
            }
          }
          _sanitizeAndValidateOption(e3, i3) {
            switch (e3) {
              case "cursorStyle":
                if (i3 || (i3 = t2.DEFAULT_OPTIONS[e3]), !function(e4) {
                  return "block" === e4 || "underline" === e4 || "bar" === e4;
                }(i3))
                  throw new Error(`"${i3}" is not a valid value for ${e3}`);
                break;
              case "wordSeparator":
                i3 || (i3 = t2.DEFAULT_OPTIONS[e3]);
                break;
              case "fontWeight":
              case "fontWeightBold":
                if ("number" == typeof i3 && 1 <= i3 && i3 <= 1e3)
                  break;
                i3 = o.includes(i3) ? i3 : t2.DEFAULT_OPTIONS[e3];
                break;
              case "cursorWidth":
                i3 = Math.floor(i3);
              case "lineHeight":
              case "tabStopWidth":
                if (i3 < 1)
                  throw new Error(`${e3} cannot be less than 1, value: ${i3}`);
                break;
              case "minimumContrastRatio":
                i3 = Math.max(1, Math.min(21, Math.round(10 * i3) / 10));
                break;
              case "scrollback":
                if ((i3 = Math.min(i3, 4294967295)) < 0)
                  throw new Error(`${e3} cannot be less than 0, value: ${i3}`);
                break;
              case "fastScrollSensitivity":
              case "scrollSensitivity":
                if (i3 <= 0)
                  throw new Error(`${e3} cannot be less than or equal to 0, value: ${i3}`);
                break;
              case "rows":
              case "cols":
                if (!i3 && 0 !== i3)
                  throw new Error(`${e3} must be numeric, value: ${i3}`);
                break;
              case "windowsPty":
                i3 = null != i3 ? i3 : {};
            }
            return i3;
          }
        }
        t2.OptionsService = a;
      }, 2660: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n3 = arguments.length, o2 = n3 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e3, t3, i3, s3);
          else
            for (var a = e3.length - 1; a >= 0; a--)
              (r2 = e3[a]) && (o2 = (n3 < 3 ? r2(o2) : n3 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n3 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkService = void 0;
        const n2 = i2(2585);
        let o = class {
          constructor(e3) {
            this._bufferService = e3, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
          }
          registerLink(e3) {
            const t3 = this._bufferService.buffer;
            if (void 0 === e3.id) {
              const i4 = t3.addMarker(t3.ybase + t3.y), s4 = { data: e3, id: this._nextId++, lines: [i4] };
              return i4.onDispose(() => this._removeMarkerFromLink(s4, i4)), this._dataByLinkId.set(s4.id, s4), s4.id;
            }
            const i3 = e3, s3 = this._getEntryIdKey(i3), r2 = this._entriesWithId.get(s3);
            if (r2)
              return this.addLineToLink(r2.id, t3.ybase + t3.y), r2.id;
            const n3 = t3.addMarker(t3.ybase + t3.y), o2 = { id: this._nextId++, key: this._getEntryIdKey(i3), data: i3, lines: [n3] };
            return n3.onDispose(() => this._removeMarkerFromLink(o2, n3)), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
          }
          addLineToLink(e3, t3) {
            const i3 = this._dataByLinkId.get(e3);
            if (i3 && i3.lines.every((e4) => e4.line !== t3)) {
              const e4 = this._bufferService.buffer.addMarker(t3);
              i3.lines.push(e4), e4.onDispose(() => this._removeMarkerFromLink(i3, e4));
            }
          }
          getLinkData(e3) {
            var t3;
            return null === (t3 = this._dataByLinkId.get(e3)) || void 0 === t3 ? void 0 : t3.data;
          }
          _getEntryIdKey(e3) {
            return `${e3.id};;${e3.uri}`;
          }
          _removeMarkerFromLink(e3, t3) {
            const i3 = e3.lines.indexOf(t3);
            -1 !== i3 && (e3.lines.splice(i3, 1), 0 === e3.lines.length && (void 0 !== e3.data.id && this._entriesWithId.delete(e3.key), this._dataByLinkId.delete(e3.id)));
          }
        };
        o = s2([r(0, n2.IBufferService)], o), t2.OscLinkService = o;
      }, 8343: (e2, t2) => {
        function i2(e3, t3, i3) {
          t3.di$target === t3 ? t3.di$dependencies.push({ id: e3, index: i3 }) : (t3.di$dependencies = [{ id: e3, index: i3 }], t3.di$target = t3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createDecorator = t2.getServiceDependencies = t2.serviceRegistry = void 0, t2.serviceRegistry = /* @__PURE__ */ new Map(), t2.getServiceDependencies = function(e3) {
          return e3.di$dependencies || [];
        }, t2.createDecorator = function(e3) {
          if (t2.serviceRegistry.has(e3))
            return t2.serviceRegistry.get(e3);
          const s2 = function(e4, t3, r) {
            if (3 !== arguments.length)
              throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            i2(s2, e4, r);
          };
          return s2.toString = () => e3, t2.serviceRegistry.set(e3, s2), s2;
        };
      }, 2585: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.IDecorationService = t2.IUnicodeService = t2.IOscLinkService = t2.IOptionsService = t2.ILogService = t2.LogLevelEnum = t2.IInstantiationService = t2.ICharsetService = t2.ICoreService = t2.ICoreMouseService = t2.IBufferService = void 0;
        const s2 = i2(8343);
        var r;
        t2.IBufferService = (0, s2.createDecorator)("BufferService"), t2.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t2.ICoreService = (0, s2.createDecorator)("CoreService"), t2.ICharsetService = (0, s2.createDecorator)("CharsetService"), t2.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), (r = t2.LogLevelEnum || (t2.LogLevelEnum = {}))[r.DEBUG = 0] = "DEBUG", r[r.INFO = 1] = "INFO", r[r.WARN = 2] = "WARN", r[r.ERROR = 3] = "ERROR", r[r.OFF = 4] = "OFF", t2.ILogService = (0, s2.createDecorator)("LogService"), t2.IOptionsService = (0, s2.createDecorator)("OptionsService"), t2.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t2.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t2.IDecorationService = (0, s2.createDecorator)("DecorationService");
      }, 1480: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeService = void 0;
        const s2 = i2(8460), r = i2(225);
        t2.UnicodeService = class {
          constructor() {
            this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new s2.EventEmitter(), this.onChange = this._onChange.event;
            const e3 = new r.UnicodeV6();
            this.register(e3), this._active = e3.version, this._activeProvider = e3;
          }
          dispose() {
            this._onChange.dispose();
          }
          get versions() {
            return Object.keys(this._providers);
          }
          get activeVersion() {
            return this._active;
          }
          set activeVersion(e3) {
            if (!this._providers[e3])
              throw new Error(`unknown Unicode version "${e3}"`);
            this._active = e3, this._activeProvider = this._providers[e3], this._onChange.fire(e3);
          }
          register(e3) {
            this._providers[e3.version] = e3;
          }
          wcwidth(e3) {
            return this._activeProvider.wcwidth(e3);
          }
          getStringCellWidth(e3) {
            let t3 = 0;
            const i3 = e3.length;
            for (let s3 = 0; s3 < i3; ++s3) {
              let r2 = e3.charCodeAt(s3);
              if (55296 <= r2 && r2 <= 56319) {
                if (++s3 >= i3)
                  return t3 + this.wcwidth(r2);
                const n2 = e3.charCodeAt(s3);
                56320 <= n2 && n2 <= 57343 ? r2 = 1024 * (r2 - 55296) + n2 - 56320 + 65536 : t3 += this.wcwidth(n2);
              }
              t3 += this.wcwidth(r2);
            }
            return t3;
          }
        };
      } }, t = {};
      function i(s2) {
        var r = t[s2];
        if (void 0 !== r)
          return r.exports;
        var n2 = t[s2] = { exports: {} };
        return e[s2].call(n2.exports, n2, n2.exports, i), n2.exports;
      }
      var s = {};
      return (() => {
        var e2 = s;
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Terminal = void 0;
        const t2 = i(3236), r = i(9042), n2 = i(7975), o = i(7090), a = i(5741), h = i(8285), c = ["cols", "rows"];
        e2.Terminal = class {
          constructor(e3) {
            this._core = new t2.Terminal(e3), this._addonManager = new a.AddonManager(), this._publicOptions = Object.assign({}, this._core.options);
            const i2 = (e4) => this._core.options[e4], s2 = (e4, t3) => {
              this._checkReadonlyOptions(e4), this._core.options[e4] = t3;
            };
            for (const e4 in this._core.options) {
              const t3 = { get: i2.bind(this, e4), set: s2.bind(this, e4) };
              Object.defineProperty(this._publicOptions, e4, t3);
            }
          }
          _checkReadonlyOptions(e3) {
            if (c.includes(e3))
              throw new Error(`Option "${e3}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.rawOptions.allowProposedApi)
              throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onKey() {
            return this._core.onKey;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onRender() {
            return this._core.onRender;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onSelectionChange() {
            return this._core.onSelectionChange;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get onWriteParsed() {
            return this._core.onWriteParsed;
          }
          get element() {
            return this._core.element;
          }
          get parser() {
            return this._parser || (this._parser = new n2.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new o.UnicodeApi(this._core);
          }
          get textarea() {
            return this._core.textarea;
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._buffer || (this._buffer = new h.BufferNamespaceApi(this._core)), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const e3 = this._core.coreService.decPrivateModes;
            let t3 = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                t3 = "x10";
                break;
              case "VT200":
                t3 = "vt200";
                break;
              case "DRAG":
                t3 = "drag";
                break;
              case "ANY":
                t3 = "any";
            }
            return { applicationCursorKeysMode: e3.applicationCursorKeys, applicationKeypadMode: e3.applicationKeypad, bracketedPasteMode: e3.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t3, originMode: e3.origin, reverseWraparoundMode: e3.reverseWraparound, sendFocusMode: e3.sendFocus, wraparoundMode: e3.wraparound };
          }
          get options() {
            return this._publicOptions;
          }
          set options(e3) {
            for (const t3 in e3)
              this._publicOptions[t3] = e3[t3];
          }
          blur() {
            this._core.blur();
          }
          focus() {
            this._core.focus();
          }
          resize(e3, t3) {
            this._verifyIntegers(e3, t3), this._core.resize(e3, t3);
          }
          open(e3) {
            this._core.open(e3);
          }
          attachCustomKeyEventHandler(e3) {
            this._core.attachCustomKeyEventHandler(e3);
          }
          registerLinkProvider(e3) {
            return this._core.registerLinkProvider(e3);
          }
          registerCharacterJoiner(e3) {
            return this._checkProposedApi(), this._core.registerCharacterJoiner(e3);
          }
          deregisterCharacterJoiner(e3) {
            this._checkProposedApi(), this._core.deregisterCharacterJoiner(e3);
          }
          registerMarker(e3 = 0) {
            return this._verifyIntegers(e3), this._core.addMarker(e3);
          }
          registerDecoration(e3) {
            var t3, i2, s2;
            return this._checkProposedApi(), this._verifyPositiveIntegers(null !== (t3 = e3.x) && void 0 !== t3 ? t3 : 0, null !== (i2 = e3.width) && void 0 !== i2 ? i2 : 0, null !== (s2 = e3.height) && void 0 !== s2 ? s2 : 0), this._core.registerDecoration(e3);
          }
          hasSelection() {
            return this._core.hasSelection();
          }
          select(e3, t3, i2) {
            this._verifyIntegers(e3, t3, i2), this._core.select(e3, t3, i2);
          }
          getSelection() {
            return this._core.getSelection();
          }
          getSelectionPosition() {
            return this._core.getSelectionPosition();
          }
          clearSelection() {
            this._core.clearSelection();
          }
          selectAll() {
            this._core.selectAll();
          }
          selectLines(e3, t3) {
            this._verifyIntegers(e3, t3), this._core.selectLines(e3, t3);
          }
          dispose() {
            this._addonManager.dispose(), this._core.dispose();
          }
          scrollLines(e3) {
            this._verifyIntegers(e3), this._core.scrollLines(e3);
          }
          scrollPages(e3) {
            this._verifyIntegers(e3), this._core.scrollPages(e3);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(e3) {
            this._verifyIntegers(e3), this._core.scrollToLine(e3);
          }
          clear() {
            this._core.clear();
          }
          write(e3, t3) {
            this._core.write(e3, t3);
          }
          writeln(e3, t3) {
            this._core.write(e3), this._core.write("\r\n", t3);
          }
          paste(e3) {
            this._core.paste(e3);
          }
          refresh(e3, t3) {
            this._verifyIntegers(e3, t3), this._core.refresh(e3, t3);
          }
          reset() {
            this._core.reset();
          }
          clearTextureAtlas() {
            this._core.clearTextureAtlas();
          }
          loadAddon(e3) {
            return this._addonManager.loadAddon(this, e3);
          }
          static get strings() {
            return r;
          }
          _verifyIntegers(...e3) {
            for (const t3 of e3)
              if (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0)
                throw new Error("This API only accepts integers");
          }
          _verifyPositiveIntegers(...e3) {
            for (const t3 of e3)
              if (t3 && (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0 || t3 < 0))
                throw new Error("This API only accepts positive integers");
          }
        };
      })(), s;
    })());
  })(xterm);
  return xterm.exports;
}
var xtermExports = requireXterm();
let xtermConstructor;
const shellIntegrationSupportedShellTypes = [
  "bash",
  "zsh",
  "pwsh",
  "pwsh"
];
let TerminalInstance = (_G = class extends Disposable {
  get domElement() {
    return this._wrapperElement;
  }
  get usedShellIntegrationInjection() {
    return this._usedShellIntegrationInjection;
  }
  get extEnvironmentVariableCollection() {
    return this._processManager.extEnvironmentVariableCollection;
  }
  get waitOnExit() {
    var _a2;
    return ((_a2 = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.waitOnExit) || this._shellLaunchConfig.waitOnExit;
  }
  set waitOnExit(value) {
    this._shellLaunchConfig.waitOnExit = value;
  }
  get target() {
    return this._target;
  }
  set target(value) {
    this._target = value;
  }
  get instanceId() {
    return this._instanceId;
  }
  get resource() {
    return this._resource;
  }
  get cols() {
    if (this._fixedCols !== void 0) {
      return this._fixedCols;
    }
    if (this._dimensionsOverride && this._dimensionsOverride.cols) {
      if (this._dimensionsOverride.forceExactSize) {
        return this._dimensionsOverride.cols;
      }
      return Math.min(Math.max(this._dimensionsOverride.cols, 2), this._cols);
    }
    return this._cols;
  }
  get rows() {
    if (this._fixedRows !== void 0) {
      return this._fixedRows;
    }
    if (this._dimensionsOverride && this._dimensionsOverride.rows) {
      if (this._dimensionsOverride.forceExactSize) {
        return this._dimensionsOverride.rows;
      }
      return Math.min(Math.max(this._dimensionsOverride.rows, 2), this._rows);
    }
    return this._rows;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get fixedCols() {
    return this._fixedCols;
  }
  get fixedRows() {
    return this._fixedRows;
  }
  get maxCols() {
    return this._cols;
  }
  get maxRows() {
    return this._rows;
  }
  get processId() {
    return this._processManager.shellProcessId;
  }
  get processReady() {
    return this._processManager.ptyProcessReady;
  }
  get hasChildProcesses() {
    var _a2;
    return ((_a2 = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.hasChildProcesses) || this._processManager.hasChildProcesses;
  }
  get reconnectionProperties() {
    var _a2;
    return ((_a2 = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.reconnectionProperties) || this.shellLaunchConfig.reconnectionProperties;
  }
  get areLinksReady() {
    return this._areLinksReady;
  }
  get initialDataEvents() {
    return this._initialDataEvents;
  }
  get exitCode() {
    return this._exitCode;
  }
  get exitReason() {
    return this._exitReason;
  }
  get hadFocusOnExit() {
    return this._hadFocusOnExit;
  }
  get isTitleSetByProcess() {
    return !!this._messageTitleDisposable;
  }
  get shellLaunchConfig() {
    return this._shellLaunchConfig;
  }
  get shellType() {
    return this._shellType;
  }
  get os() {
    return this._processManager.os;
  }
  get isRemote() {
    return this._processManager.remoteAuthority !== void 0;
  }
  get remoteAuthority() {
    return this._processManager.remoteAuthority;
  }
  get hasFocus() {
    return this._wrapperElement.contains(document.activeElement) ?? false;
  }
  get title() {
    return this._title;
  }
  get titleSource() {
    return this._titleSource;
  }
  get icon() {
    return this._getIcon();
  }
  get color() {
    return this._getColor();
  }
  get processName() {
    return this._processName;
  }
  get sequence() {
    return this._sequence;
  }
  get staticTitle() {
    return this._staticTitle;
  }
  get workspaceFolder() {
    return this._workspaceFolder;
  }
  get cwd() {
    return this._cwd;
  }
  get initialCwd() {
    return this._initialCwd;
  }
  get description() {
    var _a2;
    if (this._description) {
      return this._description;
    }
    const type = ((_a2 = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.type) || this.shellLaunchConfig.type;
    if (type) {
      if (type === "Task") {
        return localize("terminalTypeTask", "Task");
      }
      return localize("terminalTypeLocal", "Local");
    }
    return void 0;
  }
  get userHome() {
    return this._userHome;
  }
  get shellIntegrationNonce() {
    return this._processManager.shellIntegrationNonce;
  }
  get injectedArgs() {
    return this._injectedArgs;
  }
  constructor(_terminalShellTypeContextKey, _terminalInRunCommandPicker, _terminalSuggestWidgetVisibleContextKey, _configHelper, _shellLaunchConfig, _contextKeyService, instantiationService, _terminalProfileResolverService, _pathService, _keybindingService, _notificationService, _preferencesService, _viewsService, _clipboardService, _themeService, _configurationService, _logService, _dialogService, _storageService, _accessibilityService, _productService, _quickInputService, workbenchEnvironmentService, _workspaceContextService, _editorService, _workspaceTrustRequestService, _historyService, _telemetryService, _openerService, _commandService, _audioCueService, _viewDescriptorService) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    super();
    this._terminalShellTypeContextKey = _terminalShellTypeContextKey;
    this._terminalInRunCommandPicker = _terminalInRunCommandPicker;
    this._terminalSuggestWidgetVisibleContextKey = _terminalSuggestWidgetVisibleContextKey;
    this._configHelper = _configHelper;
    this._shellLaunchConfig = _shellLaunchConfig;
    this._contextKeyService = _contextKeyService;
    this._terminalProfileResolverService = _terminalProfileResolverService;
    this._pathService = _pathService;
    this._keybindingService = _keybindingService;
    this._notificationService = _notificationService;
    this._preferencesService = _preferencesService;
    this._viewsService = _viewsService;
    this._clipboardService = _clipboardService;
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._logService = _logService;
    this._dialogService = _dialogService;
    this._storageService = _storageService;
    this._accessibilityService = _accessibilityService;
    this._productService = _productService;
    this._quickInputService = _quickInputService;
    this._workspaceContextService = _workspaceContextService;
    this._editorService = _editorService;
    this._workspaceTrustRequestService = _workspaceTrustRequestService;
    this._historyService = _historyService;
    this._telemetryService = _telemetryService;
    this._openerService = _openerService;
    this._commandService = _commandService;
    this._audioCueService = _audioCueService;
    this._viewDescriptorService = _viewDescriptorService;
    this._contributions = /* @__PURE__ */ new Map();
    this._latestXtermWriteData = 0;
    this._latestXtermParseData = 0;
    this._title = "";
    this._titleSource = TitleEventSource.Process;
    this._cols = 0;
    this._rows = 0;
    this._cwd = void 0;
    this._initialCwd = void 0;
    this._injectedArgs = void 0;
    this._layoutSettingsChanged = true;
    this._areLinksReady = false;
    this._initialDataEvents = [];
    this._widgetManager = new TerminalWidgetManager();
    this._processName = "";
    this._usedShellIntegrationInjection = false;
    this.capabilities = new TerminalCapabilityStoreMultiplexer();
    this.disableLayout = false;
    this._onExit = new Emitter();
    this.onExit = this._onExit.event;
    this._onDisposed = this._register(new Emitter());
    this.onDisposed = this._onDisposed.event;
    this._onProcessIdReady = this._register(new Emitter());
    this.onProcessIdReady = this._onProcessIdReady.event;
    this._onProcessReplayComplete = this._register(new Emitter());
    this.onProcessReplayComplete = this._onProcessReplayComplete.event;
    this._onTitleChanged = this._register(new Emitter());
    this.onTitleChanged = this._onTitleChanged.event;
    this._onIconChanged = this._register(new Emitter());
    this.onIconChanged = this._onIconChanged.event;
    this._onData = this._register(new Emitter());
    this.onData = this._onData.event;
    this._onBinary = this._register(new Emitter());
    this.onBinary = this._onBinary.event;
    this._onLineData = this._register(new Emitter({
      onDidAddFirstListener: () => this._onLineDataSetup()
    }));
    this.onLineData = this._onLineData.event;
    this._onRequestExtHostProcess = this._register(new Emitter());
    this.onRequestExtHostProcess = this._onRequestExtHostProcess.event;
    this._onDimensionsChanged = this._register(new Emitter());
    this.onDimensionsChanged = this._onDimensionsChanged.event;
    this._onMaximumDimensionsChanged = this._register(new Emitter());
    this.onMaximumDimensionsChanged = this._onMaximumDimensionsChanged.event;
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidRequestFocus = this._register(new Emitter());
    this.onDidRequestFocus = this._onDidRequestFocus.event;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this._onDidInputData = this._register(new Emitter());
    this.onDidInputData = this._onDidInputData.event;
    this._onDidChangeSelection = this._register(new Emitter());
    this.onDidChangeSelection = this._onDidChangeSelection.event;
    this._onRequestAddInstanceToGroup = this._register(new Emitter());
    this.onRequestAddInstanceToGroup = this._onRequestAddInstanceToGroup.event;
    this._onDidChangeHasChildProcesses = this._register(new Emitter());
    this.onDidChangeHasChildProcesses = this._onDidChangeHasChildProcesses.event;
    this._wrapperElement = document.createElement("div");
    this._wrapperElement.classList.add("terminal-wrapper");
    this._skipTerminalCommands = [];
    this._isExiting = false;
    this._hadFocusOnExit = false;
    this._isVisible = false;
    this._isDisposed = false;
    this._instanceId = _G._instanceIdCounter++;
    this._hasHadInput = false;
    this._fixedRows = (_b2 = (_a2 = _shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.fixedDimensions) == null ? void 0 : _b2.rows;
    this._fixedCols = (_d2 = (_c2 = _shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _c2.fixedDimensions) == null ? void 0 : _d2.cols;
    this._resource = getTerminalUri(this._workspaceContextService.getWorkspace().id, this.instanceId, this.title);
    if ((_e2 = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _e2.hideFromUser) {
      this._shellLaunchConfig.hideFromUser = this._shellLaunchConfig.attachPersistentProcess.hideFromUser;
    }
    if ((_f2 = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _f2.isFeatureTerminal) {
      this._shellLaunchConfig.isFeatureTerminal = this._shellLaunchConfig.attachPersistentProcess.isFeatureTerminal;
    }
    if ((_g2 = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _g2.type) {
      this._shellLaunchConfig.type = this._shellLaunchConfig.attachPersistentProcess.type;
    }
    if (this.shellLaunchConfig.cwd) {
      const cwdUri = typeof this._shellLaunchConfig.cwd === "string" ? URI.from({
        scheme: Schemas.file,
        path: this._shellLaunchConfig.cwd
      }) : this._shellLaunchConfig.cwd;
      if (cwdUri) {
        this._workspaceFolder = withNullAsUndefined(this._workspaceContextService.getWorkspaceFolder(cwdUri));
      }
    }
    if (!this._workspaceFolder) {
      const activeWorkspaceRootUri = this._historyService.getLastActiveWorkspaceRoot();
      this._workspaceFolder = activeWorkspaceRootUri ? withNullAsUndefined(this._workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri)) : void 0;
    }
    const scopedContextKeyService = this._register(_contextKeyService.createScoped(this._wrapperElement));
    this._scopedInstantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, scopedContextKeyService]));
    this._terminalFocusContextKey = TerminalContextKeys.focus.bindTo(scopedContextKeyService);
    this._terminalHasFixedWidth = TerminalContextKeys.terminalHasFixedWidth.bindTo(scopedContextKeyService);
    this._terminalHasTextContextKey = TerminalContextKeys.textSelected.bindTo(scopedContextKeyService);
    this._terminalAltBufferActiveContextKey = TerminalContextKeys.altBufferActive.bindTo(scopedContextKeyService);
    this._terminalShellIntegrationEnabledContextKey = TerminalContextKeys.terminalShellIntegrationEnabled.bindTo(scopedContextKeyService);
    this._logService.trace(`terminalInstance#ctor (instanceId: ${this.instanceId})`, this._shellLaunchConfig);
    this._register(this.capabilities.onDidAddCapability((e) => {
      var _a3;
      this._logService.debug("terminalInstance added capability", e);
      if (e === 0) {
        (_a3 = this.capabilities.get(0)) == null ? void 0 : _a3.onDidChangeCwd((e2) => {
          var _a4;
          this._cwd = e2;
          this._setTitle(this.title, TitleEventSource.Config);
          (_a4 = this._scopedInstantiationService.invokeFunction(getDirectoryHistory)) == null ? void 0 : _a4.add(e2, { remoteAuthority: this.remoteAuthority });
        });
      } else if (e === 2) {
        const commandCapability = this.capabilities.get(2);
        commandCapability == null ? void 0 : commandCapability.onCommandFinished((e2) => {
          var _a4;
          if (e2.command.trim().length > 0) {
            (_a4 = this._scopedInstantiationService.invokeFunction(getCommandHistory)) == null ? void 0 : _a4.add(e2.command, { shellType: this._shellType });
          }
        });
      }
    }));
    this._register(this.capabilities.onDidRemoveCapability((e) => this._logService.debug("terminalInstance removed capability", e)));
    if (!this.shellLaunchConfig.executable && !workbenchEnvironmentService.remoteAuthority) {
      this._terminalProfileResolverService.resolveIcon(this._shellLaunchConfig, OS);
    }
    this._icon = ((_h2 = _shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _h2.icon) || _shellLaunchConfig.icon;
    if (this.shellLaunchConfig.customPtyImplementation) {
      this._setTitle(this._shellLaunchConfig.name, TitleEventSource.Api);
    }
    this.statusList = this._scopedInstantiationService.createInstance(TerminalStatusList);
    this._initDimensions();
    this._processManager = this._createProcessManager();
    this._register(toDisposable(() => {
      var _a3;
      return (_a3 = this._dndObserver) == null ? void 0 : _a3.dispose();
    }));
    this._containerReadyBarrier = new AutoOpenBarrier(100);
    this._attachBarrier = new AutoOpenBarrier(1e3);
    this._xtermReadyPromise = this._createXterm();
    this._xtermReadyPromise.then(async () => {
      var _a3, _b3, _c3;
      await this._containerReadyBarrier.wait();
      if (!this.shellLaunchConfig.customPtyImplementation && ((_a3 = this._configHelper.config.shellIntegration) == null ? void 0 : _a3.enabled) && !this.shellLaunchConfig.executable) {
        const os = await this._processManager.getBackendOS();
        const defaultProfile = await this._terminalProfileResolverService.getDefaultProfile({ remoteAuthority: this.remoteAuthority, os });
        this.shellLaunchConfig.executable = defaultProfile.path;
        this.shellLaunchConfig.args = defaultProfile.args;
        if (this.shellLaunchConfig.isExtensionOwnedTerminal) {
          (_b3 = this.shellLaunchConfig).icon ?? (_b3.icon = defaultProfile.icon);
          (_c3 = this.shellLaunchConfig).color ?? (_c3.color = defaultProfile.color);
        } else {
          this.shellLaunchConfig.icon = defaultProfile.icon;
          this.shellLaunchConfig.color = defaultProfile.color;
        }
      }
      await this._createProcess();
      if (this.shellLaunchConfig.attachPersistentProcess) {
        this._cwd = this.shellLaunchConfig.attachPersistentProcess.cwd;
        this._setTitle(this.shellLaunchConfig.attachPersistentProcess.title, this.shellLaunchConfig.attachPersistentProcess.titleSource);
        this.setShellType(this.shellType);
      }
      if (this._fixedCols) {
        await this._addScrollbar();
      }
    }).catch((err) => {
      if (!this._isDisposed) {
        throw err;
      }
    });
    this._register(this._configurationService.onDidChangeConfiguration(async (e) => {
      var _a3, _b3;
      if (e.affectsConfiguration("accessibility.verbosity.terminal")) {
        this._setAriaLabel((_a3 = this.xterm) == null ? void 0 : _a3.raw, this._instanceId, this.title);
      }
      if (e.affectsConfiguration("terminal.integrated")) {
        this.updateConfig();
        this.setVisible(this._isVisible);
      }
      const layoutSettings = [
        "terminal.integrated.fontSize",
        "terminal.integrated.fontFamily",
        "terminal.integrated.fontWeight",
        "terminal.integrated.fontWeightBold",
        "terminal.integrated.letterSpacing",
        "terminal.integrated.lineHeight",
        "editor.fontFamily"
      ];
      if (layoutSettings.some((id) => e.affectsConfiguration(id))) {
        this._layoutSettingsChanged = true;
        await this._resize();
      }
      if (e.affectsConfiguration("terminal.integrated.unicodeVersion")) {
        this._updateUnicodeVersion();
      }
      if (e.affectsConfiguration("editor.accessibilitySupport")) {
        this.updateAccessibilitySupport();
      }
      if (e.affectsConfiguration("terminal.integrated.tabs.title") || e.affectsConfiguration("terminal.integrated.tabs.separator") || e.affectsConfiguration("terminal.integrated.tabs.description")) {
        (_b3 = this._labelComputer) == null ? void 0 : _b3.refreshLabel();
      }
    }));
    this._register(this._workspaceContextService.onDidChangeWorkspaceFolders(() => {
      var _a3;
      return (_a3 = this._labelComputer) == null ? void 0 : _a3.refreshLabel();
    }));
    this._register(this.onDidBlur(() => {
      var _a3, _b3;
      return (_b3 = (_a3 = this.xterm) == null ? void 0 : _a3.suggestController) == null ? void 0 : _b3.hideSuggestWidget();
    }));
    let initialDataEventsTimeout = window.setTimeout(() => {
      initialDataEventsTimeout = void 0;
      this._initialDataEvents = void 0;
    }, 1e4);
    this._register(toDisposable(() => {
      if (initialDataEventsTimeout) {
        window.clearTimeout(initialDataEventsTimeout);
      }
    }));
    const contributionDescs = TerminalExtensionsRegistry.getTerminalContributions();
    for (const desc of contributionDescs) {
      if (this._contributions.has(desc.id)) {
        onUnexpectedError(new Error(`Cannot have two terminal contributions with the same id ${desc.id}`));
        continue;
      }
      let contribution;
      try {
        contribution = this._scopedInstantiationService.createInstance(desc.ctor, this, this._processManager, this._widgetManager);
        this._contributions.set(desc.id, contribution);
      } catch (err) {
        onUnexpectedError(err);
      }
      this._xtermReadyPromise.then((xterm2) => {
        var _a3;
        (_a3 = contribution.xtermReady) == null ? void 0 : _a3.call(contribution, xterm2);
      });
      this.onDisposed(() => {
        contribution.dispose();
      });
    }
  }
  getContribution(id) {
    return this._contributions.get(id);
  }
  _getIcon() {
    if (!this._icon) {
      this._icon = this._processManager.processState >= 2 ? getIconRegistry().getIcon(this._configurationService.getValue("terminal.integrated.tabs.defaultIcon")) : void 0;
    }
    return this._icon;
  }
  _getColor() {
    var _a2, _b2;
    if (this.shellLaunchConfig.color) {
      return this.shellLaunchConfig.color;
    }
    if ((_b2 = (_a2 = this.shellLaunchConfig) == null ? void 0 : _a2.attachPersistentProcess) == null ? void 0 : _b2.color) {
      return this.shellLaunchConfig.attachPersistentProcess.color;
    }
    if (this._processManager.processState >= 2) {
      return void 0;
    }
    return void 0;
  }
  _initDimensions() {
    if (!this._container) {
      this._cols = 80;
      this._rows = 30;
      return;
    }
    const computedStyle = window.getComputedStyle(this._container);
    const width = parseInt(computedStyle.width);
    const height = parseInt(computedStyle.height);
    this._evaluateColsAndRows(width, height);
  }
  _evaluateColsAndRows(width, height) {
    if (!width || !height) {
      this._setLastKnownColsAndRows();
      return null;
    }
    const dimension = this._getDimension(width, height);
    if (!dimension) {
      this._setLastKnownColsAndRows();
      return null;
    }
    const font = this.xterm ? this.xterm.getFont() : this._configHelper.getFont();
    const newRC = getXtermScaledDimensions(font, dimension.width, dimension.height);
    if (!newRC) {
      this._setLastKnownColsAndRows();
      return null;
    }
    if (this._cols !== newRC.cols || this._rows !== newRC.rows) {
      this._cols = newRC.cols;
      this._rows = newRC.rows;
      this._fireMaximumDimensionsChanged();
    }
    return dimension.width;
  }
  _setLastKnownColsAndRows() {
    if (_G._lastKnownGridDimensions) {
      this._cols = _G._lastKnownGridDimensions.cols;
      this._rows = _G._lastKnownGridDimensions.rows;
    }
  }
  _fireMaximumDimensionsChanged() {
    this._onMaximumDimensionsChanged.fire();
  }
  _getDimension(width, height) {
    var _a2;
    const font = this.xterm ? this.xterm.getFont() : this._configHelper.getFont();
    if (!font || !font.charWidth || !font.charHeight) {
      return void 0;
    }
    if (!((_a2 = this.xterm) == null ? void 0 : _a2.raw.element)) {
      return void 0;
    }
    const computedStyle = window.getComputedStyle(this.xterm.raw.element);
    const horizontalPadding = parseInt(computedStyle.paddingLeft) + parseInt(computedStyle.paddingRight);
    const verticalPadding = parseInt(computedStyle.paddingTop) + parseInt(computedStyle.paddingBottom);
    _G._lastKnownCanvasDimensions = new Dimension(Math.min(8e3, width - horizontalPadding), height + (this._hasScrollBar && !this._horizontalScrollbar ? -5 : 0) - 2 - verticalPadding);
    return _G._lastKnownCanvasDimensions;
  }
  get persistentProcessId() {
    return this._processManager.persistentProcessId;
  }
  get shouldPersist() {
    return this._processManager.shouldPersist && !this.shellLaunchConfig.isTransient && (!this.reconnectionProperties || this._configurationService.getValue("task.reconnection") === true);
  }
  static getXtermConstructor(keybindingService, contextKeyService) {
    const keybinding = keybindingService.lookupKeybinding("workbench.action.terminal.focusAccessibleBuffer", contextKeyService);
    if (xtermConstructor) {
      return xtermConstructor;
    }
    xtermConstructor = Promises.withAsyncBody(async (resolve2) => {
      xtermExports.Terminal.strings.promptLabel = localize("terminal.integrated.a11yPromptLabel", "Terminal input");
      xtermExports.Terminal.strings.tooMuchOutput = keybinding ? localize(
        "terminal.integrated.useAccessibleBuffer",
        "Use the accessible buffer {0} to manually review output",
        keybinding.getLabel()
      ) : localize(
        "terminal.integrated.useAccessibleBufferNoKb",
        "Use the Terminal: Focus Accessible Buffer command to manually review output"
      );
      resolve2(xtermExports.Terminal);
    });
    return xtermConstructor;
  }
  async _createXterm() {
    const Terminal = await _G.getXtermConstructor(this._keybindingService, this._contextKeyService);
    if (this._isDisposed) {
      throw new ErrorNoTelemetry("Terminal disposed of during xterm.js creation");
    }
    const disableShellIntegrationReporting = this.shellLaunchConfig.hideFromUser || this.shellLaunchConfig.executable === void 0 || this.shellType === void 0 || !shellIntegrationSupportedShellTypes.includes(this.shellType);
    const xterm2 = this._scopedInstantiationService.createInstance(XtermTerminal, Terminal, this._configHelper, this._cols, this._rows, {
      getBackgroundColor: (theme) => {
        const terminalBackground = theme.getColor(TERMINAL_BACKGROUND_COLOR);
        if (terminalBackground) {
          return terminalBackground;
        }
        if (this.target === TerminalLocation.Editor) {
          return theme.getColor(editorBackground);
        }
        const location = this._viewDescriptorService.getViewLocationById(TERMINAL_VIEW_ID);
        if (location === 1) {
          return theme.getColor(PANEL_BACKGROUND);
        }
        return theme.getColor(SIDE_BAR_BACKGROUND);
      }
    }, this.capabilities, this._processManager.shellIntegrationNonce, this._terminalSuggestWidgetVisibleContextKey, disableShellIntegrationReporting);
    this.xterm = xterm2;
    this.updateAccessibilitySupport();
    this.xterm.onDidRequestRunCommand((e) => {
      if (e.copyAsHtml) {
        this.copySelection(true, e.command);
      } else {
        this.sendText(e.command.command, e.noNewLine ? false : true);
      }
    });
    this.xterm.onDidRequestFocus(() => this.focus());
    this.xterm.onDidRequestSendText((e) => this.sendText(e, false));
    const initialTextWrittenPromise = this._shellLaunchConfig.initialText ? new Promise((r) => this._writeInitialText(xterm2, r)) : void 0;
    const lineDataEventAddon = new LineDataEventAddon(initialTextWrittenPromise);
    lineDataEventAddon.onLineData((e) => this._onLineData.fire(e));
    this._lineDataEventAddon = lineDataEventAddon;
    setTimeout(() => {
      xterm2.raw.onBell(() => {
        if (this._configHelper.config.enableBell) {
          this.statusList.add({
            id: "bell",
            severity: Severity.Warning,
            icon: Codicon.bell,
            tooltip: localize("bellStatus", "Bell")
          }, this._configHelper.config.bellDuration);
          this._audioCueService.playSound(AudioCue.terminalBell.sound.getSound());
        }
      });
    }, 1e3);
    xterm2.raw.onSelectionChange(async () => this._onSelectionChange());
    xterm2.raw.buffer.onBufferChange(() => this._refreshAltBufferContextKey());
    this._processManager.onProcessData((e) => this._onProcessData(e));
    xterm2.raw.onData(async (data) => {
      await this._processManager.write(data);
      this._onDidInputData.fire(this);
    });
    xterm2.raw.onBinary((data) => this._processManager.processBinary(data));
    this._processManager.onProcessReady(async (processTraits) => {
      if (this._processManager.os) {
        lineDataEventAddon.setOperatingSystem(this._processManager.os);
      }
      xterm2.raw.options.windowsPty = processTraits.windowsPty;
    });
    this._processManager.onRestoreCommands((e) => {
      var _a2;
      return (_a2 = this.xterm) == null ? void 0 : _a2.shellIntegration.deserialize(e);
    });
    this._register(this._viewDescriptorService.onDidChangeLocation(({ views }) => {
      if (views.some((v) => v.id === TERMINAL_VIEW_ID)) {
        xterm2.refresh();
      }
    }));
    if (!this.capabilities.has(0)) {
      let onKeyListener = xterm2.raw.onKey((e) => {
        const event = new StandardKeyboardEvent(e.domEvent);
        if (event.equals(3)) {
          this._updateProcessCwd();
        }
      });
      this._register(this.capabilities.onDidAddCapability((e) => {
        if (e === 0) {
          onKeyListener == null ? void 0 : onKeyListener.dispose();
          onKeyListener = void 0;
        }
      }));
    }
    this._pathService.userHome().then((userHome) => {
      this._userHome = userHome.fsPath;
    });
    if (this._isVisible) {
      this._open();
    }
    return xterm2;
  }
  async _onLineDataSetup() {
    const xterm2 = this.xterm || await this._xtermReadyPromise;
    xterm2.raw.loadAddon(this._lineDataEventAddon);
  }
  async runCommand(commandLine, addNewLine) {
    var _a2;
    if (((_a2 = this.capabilities.get(2)) == null ? void 0 : _a2.hasInput) !== false) {
      await this.sendText("", false);
      await timeout(100);
    }
    await this.sendText(commandLine, addNewLine, !addNewLine);
  }
  async runRecent(type, filterMode, value) {
    return this._scopedInstantiationService.invokeFunction(showRunRecentQuickPick, this, this._terminalInRunCommandPicker, type, filterMode, value);
  }
  detachFromElement() {
    this._wrapperElement.remove();
    this._container = void 0;
  }
  attachToElement(container) {
    var _a2;
    if (this._container === container) {
      return;
    }
    this._attachBarrier.open();
    this._container = container;
    this._container.appendChild(this._wrapperElement);
    (_a2 = this.xterm) == null ? void 0 : _a2.refresh();
    setTimeout(() => this._initDragAndDrop(container));
  }
  _open() {
    if (!this.xterm || this.xterm.raw.element) {
      return;
    }
    if (!this._container || !this._container.isConnected) {
      throw new Error("A container element needs to be set with `attachToElement` and be part of the DOM before calling `_open`");
    }
    const xtermElement = document.createElement("div");
    this._wrapperElement.appendChild(xtermElement);
    this._container.appendChild(this._wrapperElement);
    const xterm2 = this.xterm;
    this._wrapperElement.xterm = xterm2.raw;
    const screenElement = xterm2.attachToElement(xtermElement);
    this._register(xterm2.shellIntegration.onDidChangeStatus(() => {
      if (this.hasFocus) {
        this._setShellIntegrationContextKey();
      } else {
        this._terminalShellIntegrationEnabledContextKey.reset();
      }
    }));
    if (!xterm2.raw.element || !xterm2.raw.textarea) {
      throw new Error("xterm elements not set after open");
    }
    this._setAriaLabel(xterm2.raw, this._instanceId, this._title);
    xterm2.raw.attachCustomKeyEventHandler((event) => {
      if (this._isExiting) {
        return false;
      }
      const standardKeyboardEvent = new StandardKeyboardEvent(event);
      const resolveResult = this._keybindingService.softDispatch(standardKeyboardEvent, standardKeyboardEvent.target);
      const isValidChord = resolveResult.kind === 1 && this._configHelper.config.allowChords && event.key !== "Escape";
      if (this._keybindingService.inChordMode || isValidChord) {
        event.preventDefault();
        return false;
      }
      const SHOW_TERMINAL_CONFIG_PROMPT_KEY = "terminal.integrated.showTerminalConfigPrompt";
      const EXCLUDED_KEYS = ["RightArrow", "LeftArrow", "UpArrow", "DownArrow", "Space", "Meta", "Control", "Shift", "Alt", "", "Delete", "Backspace", "Tab"];
      if (this._storageService.getBoolean(SHOW_TERMINAL_CONFIG_PROMPT_KEY, -1, true) && !EXCLUDED_KEYS.includes(event.key) && !event.ctrlKey && !event.shiftKey && !event.altKey) {
        this._hasHadInput = true;
      }
      if (resolveResult.kind === 2 && resolveResult.commandId && this._skipTerminalCommands.some((k) => k === resolveResult.commandId) && !this._configHelper.config.sendKeybindingsToShell) {
        if (this._storageService.getBoolean(SHOW_TERMINAL_CONFIG_PROMPT_KEY, -1, true) && this._hasHadInput && !TERMINAL_CREATION_COMMANDS.includes(resolveResult.commandId)) {
          this._notificationService.prompt(Severity.Info, localize(
            "keybindingHandling",
            "Some keybindings don't go to the terminal by default and are handled by {0} instead.",
            this._productService.nameLong
          ), [
            {
              label: localize("configureTerminalSettings", "Configure Terminal Settings"),
              run: () => {
                this._preferencesService.openSettings({ jsonEditor: false, query: `@id:${"terminal.integrated.commandsToSkipShell"},${"terminal.integrated.sendKeybindingsToShell"},${"terminal.integrated.allowChords"}` });
              }
            }
          ]);
          this._storageService.store(SHOW_TERMINAL_CONFIG_PROMPT_KEY, false, -1, 0);
        }
        event.preventDefault();
        return false;
      }
      if (this._configHelper.config.allowMnemonics && !isMacintosh && event.altKey) {
        return false;
      }
      if (TabFocus.getTabFocusMode("terminalFocus") && event.key === "Tab") {
        return false;
      }
      if (isWindows && event.altKey && event.key === "F4" && !event.ctrlKey) {
        return false;
      }
      if (!BrowserFeatures.clipboard.readText && event.key === "v" && event.ctrlKey) {
        return false;
      }
      return true;
    });
    this._register(addDisposableListener(xterm2.raw.element, "mousedown", () => {
      const listener = addDisposableListener(document, "mouseup", () => {
        setTimeout(() => this._refreshSelectionContextKey(), 0);
        listener.dispose();
      });
    }));
    this._register(addDisposableListener(xterm2.raw.element, "touchstart", () => {
      xterm2.raw.focus();
    }));
    this._register(addDisposableListener(xterm2.raw.element, "keyup", () => {
      setTimeout(() => this._refreshSelectionContextKey(), 0);
    }));
    this._register(addDisposableListener(xterm2.raw.textarea, "focus", () => this._setFocus(true)));
    this._register(addDisposableListener(xterm2.raw.textarea, "blur", () => this._setFocus(false)));
    this._register(addDisposableListener(xterm2.raw.textarea, "focusout", () => this._setFocus(false)));
    this._initDragAndDrop(this._container);
    this._widgetManager.attachToElement(screenElement);
    if (this._lastLayoutDimensions) {
      this.layout(this._lastLayoutDimensions);
    }
    this.updateConfig();
    if (xterm2.raw.options.disableStdin) {
      this._attachPressAnyKeyToCloseListener(xterm2.raw);
    }
  }
  _setFocus(focused) {
    if (focused) {
      this._terminalFocusContextKey.set(true);
      this._setShellIntegrationContextKey();
      this._onDidFocus.fire(this);
    } else {
      this.resetFocusContextKey();
      this._onDidBlur.fire(this);
      this._refreshSelectionContextKey();
    }
  }
  _setShellIntegrationContextKey() {
    if (this.xterm) {
      this._terminalShellIntegrationEnabledContextKey.set(this.xterm.shellIntegration.status === 2);
    }
  }
  resetFocusContextKey() {
    this._terminalFocusContextKey.reset();
    this._terminalShellIntegrationEnabledContextKey.reset();
  }
  _initDragAndDrop(container) {
    var _a2;
    (_a2 = this._dndObserver) == null ? void 0 : _a2.dispose();
    const dndController = this._scopedInstantiationService.createInstance(TerminalInstanceDragAndDropController, container);
    dndController.onDropTerminal((e) => this._onRequestAddInstanceToGroup.fire(e));
    dndController.onDropFile(async (path) => {
      this.focus();
      await this.sendPath(path, false);
    });
    this._dndObserver = new DragAndDropObserver(container, dndController);
  }
  hasSelection() {
    return this.xterm ? this.xterm.raw.hasSelection() : false;
  }
  async copySelection(asHtml, command) {
    const xterm2 = await this._xtermReadyPromise;
    await xterm2.copySelection(asHtml, command);
  }
  get selection() {
    return this.xterm && this.hasSelection() ? this.xterm.raw.getSelection() : void 0;
  }
  clearSelection() {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.raw.clearSelection();
  }
  _refreshAltBufferContextKey() {
    this._terminalAltBufferActiveContextKey.set(!!(this.xterm && this.xterm.raw.buffer.active === this.xterm.raw.buffer.alternate));
  }
  async _shouldPasteText(text) {
    var _a2;
    if ((_a2 = this.xterm) == null ? void 0 : _a2.raw.modes.bracketedPasteMode) {
      return true;
    }
    const textForLines = text.split(/\r?\n/);
    if (textForLines.length === 2 && textForLines[1].trim().length === 0) {
      return true;
    }
    if (textForLines.length === 1 || !this._configurationService.getValue("terminal.integrated.enableMultiLinePasteWarning")) {
      return true;
    }
    const displayItemsCount = 3;
    const maxPreviewLineLength = 30;
    let detail = localize("preview", "Preview:");
    for (let i = 0; i < Math.min(textForLines.length, displayItemsCount); i++) {
      const line = textForLines[i];
      const cleanedLine = line.length > maxPreviewLineLength ? `${line.slice(0, maxPreviewLineLength)}…` : line;
      detail += `
${cleanedLine}`;
    }
    if (textForLines.length > displayItemsCount) {
      detail += `
…`;
    }
    const { confirmed, checkboxChecked } = await this._dialogService.confirm({
      message: localize(
        "confirmMoveTrashMessageFilesAndDirectories",
        "Are you sure you want to paste {0} lines of text into the terminal?",
        textForLines.length
      ),
      detail,
      primaryButton: localize(
        { key: "multiLinePasteButton", comment: ["&& denotes a mnemonic"] },
        "&&Paste"
      ),
      checkbox: {
        label: localize("doNotAskAgain", "Do not ask me again")
      }
    });
    if (confirmed && checkboxChecked) {
      await this._configurationService.updateValue("terminal.integrated.enableMultiLinePasteWarning", false);
    }
    return confirmed;
  }
  dispose(reason) {
    var _a2, _b2;
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    this._logService.trace(`terminalInstance#dispose (instanceId: ${this.instanceId})`);
    dispose(this._widgetManager);
    if ((_a2 = this.xterm) == null ? void 0 : _a2.raw.element) {
      this._hadFocusOnExit = this.hasFocus;
    }
    if (this._wrapperElement.xterm) {
      this._wrapperElement.xterm = void 0;
    }
    if (this._horizontalScrollbar) {
      this._horizontalScrollbar.dispose();
      this._horizontalScrollbar = void 0;
    }
    try {
      (_b2 = this.xterm) == null ? void 0 : _b2.dispose();
    } catch (err) {
      this._logService.error("Exception occurred during xterm disposal", err);
    }
    if (isFirefox) {
      this.resetFocusContextKey();
      this._terminalHasTextContextKey.reset();
      this._onDidBlur.fire(this);
    }
    if (this._pressAnyKeyToCloseListener) {
      this._pressAnyKeyToCloseListener.dispose();
      this._pressAnyKeyToCloseListener = void 0;
    }
    if (this._exitReason === void 0) {
      this._exitReason = reason ?? TerminalExitReason.Unknown;
    }
    this._processManager.dispose();
    this._onProcessExit(void 0);
    this._onDisposed.fire(this);
    super.dispose();
  }
  async detachProcessAndDispose(reason) {
    await this._processManager.detachFromProcess(reason === TerminalExitReason.User);
    this.dispose(reason);
  }
  focus(force) {
    var _a2;
    this._refreshAltBufferContextKey();
    if (!this.xterm) {
      return;
    }
    if (force || !((_a2 = window.getSelection()) == null ? void 0 : _a2.toString())) {
      this.xterm.raw.focus();
      this._onDidRequestFocus.fire();
    }
  }
  async focusWhenReady(force) {
    await this._xtermReadyPromise;
    await this._attachBarrier.wait();
    this.focus(force);
  }
  async paste() {
    if (!this.xterm) {
      return;
    }
    const currentText = await this._clipboardService.readText();
    if (!await this._shouldPasteText(currentText)) {
      return;
    }
    this.focus();
    this.xterm.raw.paste(currentText);
  }
  async pasteSelection() {
    if (!this.xterm) {
      return;
    }
    const currentText = await this._clipboardService.readText("selection");
    if (!await this._shouldPasteText(currentText)) {
      return;
    }
    this.focus();
    this.xterm.raw.paste(currentText);
  }
  async sendText(text, addNewLine, bracketedPasteMode) {
    var _a2, _b2, _c2, _d2;
    if (bracketedPasteMode && ((_a2 = this.xterm) == null ? void 0 : _a2.raw.modes.bracketedPasteMode)) {
      text = `\x1B[200~${text}\x1B[201~`;
    }
    text = text.replace(/\r?\n/g, "\r");
    if (addNewLine && !text.endsWith("\r")) {
      text += "\r";
    }
    await this._processManager.write(text);
    this._onDidInputData.fire(this);
    (_c2 = (_b2 = this.xterm) == null ? void 0 : _b2.suggestController) == null ? void 0 : _c2.handleNonXtermData(text);
    (_d2 = this.xterm) == null ? void 0 : _d2.scrollToBottom();
  }
  async sendPath(originalPath, addNewLine) {
    return this.sendText(await this.preparePathForShell(originalPath), addNewLine);
  }
  async preparePathForShell(originalPath) {
    await this.processReady;
    return preparePathForShell(originalPath, this.shellLaunchConfig.executable, this.title, this.shellType, this._processManager.backend, this._processManager.os);
  }
  setVisible(visible) {
    this._isVisible = visible;
    this._wrapperElement.classList.toggle("active", visible);
    if (visible && this.xterm) {
      this._open();
      this._resize();
      setTimeout(() => this.xterm.forceRefresh(), 0);
    }
  }
  scrollDownLine() {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.scrollDownLine();
  }
  scrollDownPage() {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.scrollDownPage();
  }
  scrollToBottom() {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.scrollToBottom();
  }
  scrollUpLine() {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.scrollUpLine();
  }
  scrollUpPage() {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.scrollUpPage();
  }
  scrollToTop() {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.scrollToTop();
  }
  clearBuffer() {
    var _a2;
    this._processManager.clearBuffer();
    (_a2 = this.xterm) == null ? void 0 : _a2.clearBuffer();
  }
  _refreshSelectionContextKey() {
    const isActive = !!this._viewsService.getActiveViewWithId(TERMINAL_VIEW_ID);
    let isEditorActive = false;
    const editor = this._editorService.activeEditor;
    if (editor) {
      isEditorActive = editor instanceof TerminalEditorInput;
    }
    this._terminalHasTextContextKey.set((isActive || isEditorActive) && this.hasSelection());
  }
  _createProcessManager() {
    var _a2, _b2, _c2;
    let deserializedCollections;
    if ((_a2 = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.environmentVariableCollections) {
      deserializedCollections = deserializeEnvironmentVariableCollections(this.shellLaunchConfig.attachPersistentProcess.environmentVariableCollections);
    }
    const processManager = this._scopedInstantiationService.createInstance(TerminalProcessManager, this._instanceId, this._configHelper, (_b2 = this.shellLaunchConfig) == null ? void 0 : _b2.cwd, deserializedCollections, (_c2 = this.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _c2.shellIntegrationNonce);
    this.capabilities.add(processManager.capabilities);
    processManager.onProcessReady(async (e) => {
      this._onProcessIdReady.fire(this);
      this._initialCwd = await this.getInitialCwd();
      if (!this._labelComputer) {
        this._labelComputer = this._register(this._scopedInstantiationService.createInstance(TerminalLabelComputer, this._configHelper, this));
        this._labelComputer.onDidChangeLabel((e2) => {
          this._title = e2.title;
          this._description = e2.description;
          this._onTitleChanged.fire(this);
        });
      }
      if (this._shellLaunchConfig.name) {
        this._setTitle(this._shellLaunchConfig.name, TitleEventSource.Api);
      } else {
        setTimeout(() => {
          this._xtermReadyPromise.then((xterm2) => {
            this._messageTitleDisposable = xterm2.raw.onTitleChange((e2) => this._onTitleChange(e2));
          });
        });
        this._setTitle(this._shellLaunchConfig.executable, TitleEventSource.Process);
      }
    });
    processManager.onProcessExit((exitCode) => this._onProcessExit(exitCode));
    processManager.onDidChangeProperty(({ type, value }) => {
      var _a3, _b3;
      switch (type) {
        case "cwd":
          this._cwd = value;
          (_a3 = this._labelComputer) == null ? void 0 : _a3.refreshLabel();
          break;
        case "initialCwd":
          this._initialCwd = value;
          this._cwd = this._initialCwd;
          this._setTitle(this.title, TitleEventSource.Config);
          this._icon = ((_b3 = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _b3.icon) || this._shellLaunchConfig.icon;
          this._onIconChanged.fire({ instance: this, userInitiated: false });
          break;
        case "title":
          this._setTitle(value ?? "", TitleEventSource.Process);
          break;
        case "overrideDimensions":
          this.setOverrideDimensions(value, true);
          break;
        case "resolvedShellLaunchConfig":
          this._setResolvedShellLaunchConfig(value);
          break;
        case "shellType":
          this.setShellType(value);
          break;
        case "hasChildProcesses":
          this._onDidChangeHasChildProcesses.fire(value);
          break;
        case "usedShellIntegrationInjection":
          this._usedShellIntegrationInjection = true;
          break;
      }
    });
    processManager.onProcessData((ev) => {
      var _a3;
      (_a3 = this._initialDataEvents) == null ? void 0 : _a3.push(ev.data);
      this._onData.fire(ev.data);
    });
    processManager.onProcessReplayComplete(() => this._onProcessReplayComplete.fire());
    processManager.onEnvironmentVariableInfoChanged((e) => this._onEnvironmentVariableInfoChanged(e));
    processManager.onPtyDisconnect(() => {
      if (this.xterm) {
        this.xterm.raw.options.disableStdin = true;
      }
      this.statusList.add({
        id: "disconnected",
        severity: Severity.Error,
        icon: Codicon.debugDisconnect,
        tooltip: localize("disconnectStatus", "Lost connection to process")
      });
    });
    processManager.onPtyReconnect(() => {
      if (this.xterm) {
        this.xterm.raw.options.disableStdin = false;
      }
      this.statusList.remove("disconnected");
    });
    return processManager;
  }
  async _createProcess() {
    var _a2, _b2, _c2;
    if (this._isDisposed) {
      return;
    }
    const activeWorkspaceRootUri = this._historyService.getLastActiveWorkspaceRoot(Schemas.file);
    if (activeWorkspaceRootUri) {
      const trusted = await this._trust();
      if (!trusted) {
        this._onProcessExit({ message: localize(
          "workspaceNotTrustedCreateTerminal",
          "Cannot launch a terminal process in an untrusted workspace"
        ) });
      }
    } else if (this._cwd && this._userHome && this._cwd !== this._userHome) {
      this._onProcessExit({
        message: localize(
          "workspaceNotTrustedCreateTerminalCwd",
          "Cannot launch a terminal process in an untrusted workspace with cwd {0} and userHome {1}",
          this._cwd,
          this._userHome
        )
      });
    }
    if (this._container && this._cols === 0 && this._rows === 0) {
      this._initDimensions();
      (_a2 = this.xterm) == null ? void 0 : _a2.raw.resize(this._cols || 80, this._rows || 30);
    }
    const originalIcon = this.shellLaunchConfig.icon;
    await this._processManager.createProcess(this._shellLaunchConfig, this._cols || 80, this._rows || 30).then((result) => {
      if (result) {
        if ("message" in result) {
          this._onProcessExit(result);
        } else if ("injectedArgs" in result) {
          this._injectedArgs = result.injectedArgs;
        }
      }
    });
    if ((_b2 = this.xterm) == null ? void 0 : _b2.shellIntegration) {
      this.capabilities.add(this.xterm.shellIntegration.capabilities);
    }
    if (originalIcon !== this.shellLaunchConfig.icon || this.shellLaunchConfig.color) {
      this._icon = ((_c2 = this._shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _c2.icon) || this._shellLaunchConfig.icon;
      this._onIconChanged.fire({ instance: this, userInitiated: false });
    }
  }
  registerMarker() {
    var _a2;
    return (_a2 = this.xterm) == null ? void 0 : _a2.raw.registerMarker();
  }
  addBufferMarker(properties) {
    var _a2;
    (_a2 = this.capabilities.get(4)) == null ? void 0 : _a2.addMark(properties);
  }
  scrollToMark(startMarkId, endMarkId, highlight) {
    var _a2;
    (_a2 = this.xterm) == null ? void 0 : _a2.markTracker.scrollToClosestMarker(startMarkId, endMarkId, highlight);
  }
  async freePortKillProcess(port, command) {
    var _a2;
    await ((_a2 = this._processManager) == null ? void 0 : _a2.freePortKillProcess(port));
    this.runCommand(command, false);
  }
  _onProcessData(ev) {
    var _a2;
    const messageId = ++this._latestXtermWriteData;
    if (ev.trackCommit) {
      ev.writePromise = new Promise((r) => {
        var _a3;
        (_a3 = this.xterm) == null ? void 0 : _a3.raw.write(ev.data, () => {
          this._latestXtermParseData = messageId;
          this._processManager.acknowledgeDataEvent(ev.data.length);
          r();
        });
      });
    } else {
      (_a2 = this.xterm) == null ? void 0 : _a2.raw.write(ev.data, () => {
        this._latestXtermParseData = messageId;
        this._processManager.acknowledgeDataEvent(ev.data.length);
      });
    }
  }
  async _onProcessExit(exitCodeOrError) {
    if (this._isExiting) {
      return;
    }
    const parsedExitResult = parseExitResult(exitCodeOrError, this.shellLaunchConfig, this._processManager.processState, this._initialCwd);
    if (this._usedShellIntegrationInjection && this._processManager.processState === 4 && (parsedExitResult == null ? void 0 : parsedExitResult.code) !== 0) {
      this._relaunchWithShellIntegrationDisabled(parsedExitResult == null ? void 0 : parsedExitResult.message);
      this._onExit.fire(exitCodeOrError);
      return;
    }
    this._isExiting = true;
    await this._flushXtermData();
    this._exitCode = parsedExitResult == null ? void 0 : parsedExitResult.code;
    const exitMessage = parsedExitResult == null ? void 0 : parsedExitResult.message;
    this._logService.debug("Terminal process exit", "instanceId", this.instanceId, "code", this._exitCode, "processState", this._processManager.processState);
    const waitOnExit = this.waitOnExit;
    if (waitOnExit && this._processManager.processState !== 5) {
      this._xtermReadyPromise.then((xterm2) => {
        if (exitMessage) {
          xterm2.raw.write(formatMessageForTerminal(exitMessage));
        }
        switch (typeof waitOnExit) {
          case "string":
            xterm2.raw.write(formatMessageForTerminal(waitOnExit, { excludeLeadingNewLine: true }));
            break;
          case "function":
            if (this.exitCode !== void 0) {
              xterm2.raw.write(formatMessageForTerminal(waitOnExit(this.exitCode), { excludeLeadingNewLine: true }));
            }
            break;
        }
        xterm2.raw.options.disableStdin = true;
        if (xterm2.raw.textarea) {
          this._attachPressAnyKeyToCloseListener(xterm2.raw);
        }
      });
    } else {
      this.dispose(TerminalExitReason.Process);
      if (exitMessage) {
        const failedDuringLaunch = this._processManager.processState === 4;
        if (failedDuringLaunch || this._configHelper.config.showExitAlert) {
          this._notificationService.notify({
            message: exitMessage,
            severity: Severity.Error,
            actions: { primary: [this._scopedInstantiationService.createInstance(TerminalLaunchHelpAction)] }
          });
        } else {
          this._logService.warn(exitMessage);
        }
      }
    }
    this._onExit.fire(exitCodeOrError);
    if (this._isDisposed) {
      this._onExit.dispose();
    }
  }
  _relaunchWithShellIntegrationDisabled(exitMessage) {
    this._shellLaunchConfig.ignoreShellIntegration = true;
    this.relaunch();
    this.statusList.add({
      id: "shell-integration-attention-needed",
      severity: Severity.Warning,
      icon: Codicon.warning,
      tooltip: (`${exitMessage} ` ?? "") + localize(
        "launchFailed.exitCodeOnlyShellIntegration",
        "Disabling shell integration in user settings might help."
      ),
      hoverActions: [{
        commandId: "workbench.action.terminal.learnMore",
        label: localize("shellIntegration.learnMore", "Learn more about shell integration"),
        run: () => {
          this._openerService.open("https://code.visualstudio.com/docs/editor/integrated-terminal#_shell-integration");
        }
      }, {
        commandId: "workbench.action.openSettings",
        label: localize("shellIntegration.openSettings", "Open user settings"),
        run: () => {
          this._commandService.executeCommand("workbench.action.openSettings", "terminal.integrated.shellIntegration.enabled");
        }
      }]
    });
    this._telemetryService.publicLog2("terminal/shellIntegrationFailureProcessExit");
  }
  _flushXtermData() {
    if (this._latestXtermWriteData === this._latestXtermParseData) {
      return Promise.resolve();
    }
    let retries = 0;
    return new Promise((r) => {
      const interval = setInterval(() => {
        if (this._latestXtermWriteData === this._latestXtermParseData || ++retries === 5) {
          clearInterval(interval);
          r();
        }
      }, 20);
    });
  }
  _attachPressAnyKeyToCloseListener(xterm2) {
    if (xterm2.textarea && !this._pressAnyKeyToCloseListener) {
      this._pressAnyKeyToCloseListener = addDisposableListener(xterm2.textarea, "keypress", (event) => {
        if (this._pressAnyKeyToCloseListener) {
          this._pressAnyKeyToCloseListener.dispose();
          this._pressAnyKeyToCloseListener = void 0;
          this.dispose(TerminalExitReason.Process);
          event.preventDefault();
        }
      });
    }
  }
  _writeInitialText(xterm2, callback) {
    var _a2;
    if (!this._shellLaunchConfig.initialText) {
      callback == null ? void 0 : callback();
      return;
    }
    const text = typeof this._shellLaunchConfig.initialText === "string" ? this._shellLaunchConfig.initialText : (_a2 = this._shellLaunchConfig.initialText) == null ? void 0 : _a2.text;
    if (typeof this._shellLaunchConfig.initialText === "string") {
      xterm2.raw.writeln(text, callback);
    } else {
      if (this._shellLaunchConfig.initialText.trailingNewLine) {
        xterm2.raw.writeln(text, callback);
      } else {
        xterm2.raw.write(text, callback);
      }
    }
  }
  async reuseTerminal(shell, reset2 = false) {
    var _a2;
    (_a2 = this._pressAnyKeyToCloseListener) == null ? void 0 : _a2.dispose();
    this._pressAnyKeyToCloseListener = void 0;
    const xterm2 = this.xterm;
    if (xterm2) {
      if (!reset2) {
        await new Promise((r) => xterm2.raw.write("\n\x1B[G", r));
      }
      if (shell.initialText) {
        this._shellLaunchConfig.initialText = shell.initialText;
        await new Promise((r) => this._writeInitialText(xterm2, r));
      }
      if (this._isExiting && this._shellLaunchConfig.waitOnExit) {
        xterm2.raw.options.disableStdin = false;
        this._isExiting = false;
      }
      if (reset2) {
        xterm2.clearDecorations();
      }
    }
    this.statusList.remove("relaunch-needed");
    if (!reset2) {
      shell.initialText = " ";
    }
    this._shellLaunchConfig = shell;
    await this._processManager.relaunch(this._shellLaunchConfig, this._cols || 80, this._rows || 30, reset2).then((result) => {
      if (result) {
        if ("message" in result) {
          this._onProcessExit(result);
        } else if ("injectedArgs" in result) {
          this._injectedArgs = result.injectedArgs;
        }
      }
    });
  }
  relaunch() {
    this.reuseTerminal(this._shellLaunchConfig, true);
  }
  _onTitleChange(title) {
    if (this.isTitleSetByProcess) {
      this._setTitle(title, TitleEventSource.Sequence);
    }
  }
  async _trust() {
    return await this._workspaceTrustRequestService.requestWorkspaceTrust({
      message: localize(
        "terminal.requestTrust",
        "Creating a terminal process requires executing code"
      )
    }) === true;
  }
  async _onSelectionChange() {
    this._onDidChangeSelection.fire(this);
    if (this._configurationService.getValue("terminal.integrated.copyOnSelection")) {
      if (this.hasSelection()) {
        await this.copySelection();
      }
    }
  }
  async _updateProcessCwd() {
    if (this._isDisposed || this.shellLaunchConfig.customPtyImplementation) {
      return;
    }
    try {
      const cwd = await this._refreshProperty("cwd");
      if (typeof cwd !== "string") {
        throw new Error(`cwd is not a string ${cwd}`);
      }
    } catch (e) {
      if (e instanceof Error && e.message === "Cannot refresh property when process is not set") {
        return;
      }
      throw e;
    }
  }
  updateConfig() {
    this._setCommandsToSkipShell(this._configHelper.config.commandsToSkipShell);
    this._refreshEnvironmentVariableInfoWidgetState(this._processManager.environmentVariableInfo);
  }
  async _updateUnicodeVersion() {
    this._processManager.setUnicodeVersion(this._configHelper.config.unicodeVersion);
  }
  updateAccessibilitySupport() {
    this.xterm.raw.options.screenReaderMode = this._accessibilityService.isScreenReaderOptimized();
  }
  _setCommandsToSkipShell(commands) {
    const excludeCommands = commands.filter((command) => command[0] === "-").map((command) => command.slice(1));
    this._skipTerminalCommands = DEFAULT_COMMANDS_TO_SKIP_SHELL.filter((defaultCommand) => {
      return !excludeCommands.includes(defaultCommand);
    }).concat(commands);
  }
  layout(dimension) {
    var _a2;
    this._lastLayoutDimensions = dimension;
    if (this.disableLayout) {
      return;
    }
    if (dimension.width <= 0 || dimension.height <= 0) {
      return;
    }
    const terminalWidth = this._evaluateColsAndRows(dimension.width, dimension.height);
    if (!terminalWidth) {
      return;
    }
    this._resize();
    this._containerReadyBarrier.open();
    for (const contribution of this._contributions.values()) {
      if (!this.xterm) {
        this._xtermReadyPromise.then((xterm2) => {
          var _a3;
          return (_a3 = contribution.layout) == null ? void 0 : _a3.call(contribution, xterm2, dimension);
        });
      } else {
        (_a2 = contribution.layout) == null ? void 0 : _a2.call(contribution, this.xterm, dimension);
      }
    }
  }
  async _resize() {
    this._resizeNow(false);
  }
  async _resizeNow(immediate) {
    let cols = this.cols;
    let rows = this.rows;
    if (this.xterm) {
      if (this._isVisible && this._layoutSettingsChanged) {
        const font = this.xterm.getFont();
        const config = this._configHelper.config;
        this.xterm.raw.options.letterSpacing = font.letterSpacing;
        this.xterm.raw.options.lineHeight = font.lineHeight;
        this.xterm.raw.options.fontSize = font.fontSize;
        this.xterm.raw.options.fontFamily = font.fontFamily;
        this.xterm.raw.options.fontWeight = config.fontWeight;
        this.xterm.raw.options.fontWeightBold = config.fontWeightBold;
        this._initDimensions();
        cols = this.cols;
        rows = this.rows;
        this._layoutSettingsChanged = false;
      }
      if (isNaN(cols) || isNaN(rows)) {
        return;
      }
      if (cols !== this.xterm.raw.cols || rows !== this.xterm.raw.rows) {
        if (this._fixedRows || this._fixedCols) {
          await this._updateProperty("fixedDimensions", { cols: this._fixedCols, rows: this._fixedRows });
        }
        this._onDimensionsChanged.fire();
      }
      this.xterm.raw.resize(cols, rows);
      _G._lastKnownGridDimensions = { cols, rows };
      if (this._isVisible) {
        this.xterm.forceUnpause();
      }
    }
    if (immediate) {
      this._processManager.setDimensions(cols, rows, true);
    } else {
      await this._processManager.setDimensions(cols, rows);
    }
  }
  setShellType(shellType) {
    this._shellType = shellType;
    if (shellType) {
      this._terminalShellTypeContextKey.set(shellType == null ? void 0 : shellType.toString());
    }
  }
  _setAriaLabel(xterm2, terminalId, title) {
    var _a2;
    const labelParts = [];
    if (xterm2 && xterm2.textarea) {
      if (title && title.length > 0) {
        labelParts.push(localize(
          "terminalTextBoxAriaLabelNumberAndTitle",
          "Terminal {0}, {1}",
          terminalId,
          title
        ));
      } else {
        labelParts.push(localize("terminalTextBoxAriaLabel", "Terminal {0}", terminalId));
      }
      const screenReaderOptimized = this._accessibilityService.isScreenReaderOptimized();
      if (!screenReaderOptimized) {
        labelParts.push(localize(
          "terminalScreenReaderMode",
          "Run the command: Toggle Screen Reader Accessibility Mode for an optimized screen reader experience"
        ));
      }
      const accessibilityHelpKeybinding = (_a2 = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")) == null ? void 0 : _a2.getLabel();
      if (this._configurationService.getValue("accessibility.verbosity.terminal") && accessibilityHelpKeybinding) {
        labelParts.push(localize(
          "terminalHelpAriaLabel",
          "Use {0} for terminal accessibility help",
          accessibilityHelpKeybinding
        ));
      }
      xterm2.textarea.setAttribute("aria-label", labelParts.join("\n"));
    }
  }
  _updateTitleProperties(title, eventSource) {
    if (!title) {
      return this._processName;
    }
    switch (eventSource) {
      case TitleEventSource.Process:
        if (this._processManager.os === 1) {
          title = win32.parse(title).name;
        } else {
          const firstSpaceIndex = title.indexOf(" ");
          if (title.startsWith("/")) {
            title = basename(title);
          } else if (firstSpaceIndex > -1) {
            title = title.substring(0, firstSpaceIndex);
          }
        }
        this._processName = title;
        break;
      case TitleEventSource.Api:
        this._staticTitle = title;
        dispose(this._messageTitleDisposable);
        this._messageTitleDisposable = void 0;
        break;
      case TitleEventSource.Sequence:
        this._sequence = title;
        if (this._processManager.os === 1) {
          if (title.match(/^[a-zA-Z]:\\.+\.[a-zA-Z]{1,3}/)) {
            title = win32.parse(title).name;
            this._sequence = title;
          } else {
            this._sequence = void 0;
          }
        }
        break;
    }
    this._titleSource = eventSource;
    return title;
  }
  setOverrideDimensions(dimensions, immediate = false) {
    if (this._dimensionsOverride && this._dimensionsOverride.forceExactSize && !dimensions && this._rows === 0 && this._cols === 0) {
      this._cols = this._dimensionsOverride.cols;
      this._rows = this._dimensionsOverride.rows;
    }
    this._dimensionsOverride = dimensions;
    if (immediate) {
      this._resizeNow(true);
    } else {
      this._resize();
    }
  }
  async setFixedDimensions() {
    var _a2, _b2;
    const cols = await this._quickInputService.input({
      title: localize("setTerminalDimensionsColumn", "Set Fixed Dimensions: Column"),
      placeHolder: "Enter a number of columns or leave empty for automatic width",
      validateInput: async (text) => text.length > 0 && !text.match(/^\d+$/) ? { content: "Enter a number or leave empty size automatically", severity: Severity.Error } : void 0
    });
    if (cols === void 0) {
      return;
    }
    this._fixedCols = this._parseFixedDimension(cols);
    (_a2 = this._labelComputer) == null ? void 0 : _a2.refreshLabel();
    this._terminalHasFixedWidth.set(!!this._fixedCols);
    const rows = await this._quickInputService.input({
      title: localize("setTerminalDimensionsRow", "Set Fixed Dimensions: Row"),
      placeHolder: "Enter a number of rows or leave empty for automatic height",
      validateInput: async (text) => text.length > 0 && !text.match(/^\d+$/) ? { content: "Enter a number or leave empty size automatically", severity: Severity.Error } : void 0
    });
    if (rows === void 0) {
      return;
    }
    this._fixedRows = this._parseFixedDimension(rows);
    (_b2 = this._labelComputer) == null ? void 0 : _b2.refreshLabel();
    await this._refreshScrollbar();
    this._resize();
    this.focus();
  }
  _parseFixedDimension(value) {
    if (value === "") {
      return void 0;
    }
    const parsed = parseInt(value);
    if (parsed <= 0) {
      throw new Error(`Could not parse dimension "${value}"`);
    }
    return parsed;
  }
  async toggleSizeToContentWidth() {
    var _a2, _b2;
    if (!((_a2 = this.xterm) == null ? void 0 : _a2.raw.buffer.active)) {
      return;
    }
    if (this._hasScrollBar) {
      this._terminalHasFixedWidth.set(false);
      this._fixedCols = void 0;
      this._fixedRows = void 0;
      this._hasScrollBar = false;
      this._initDimensions();
      await this._resize();
    } else {
      const proposedCols = Math.max(this.maxCols, Math.min(this.xterm.getLongestViewportWrappedLineLength(), 5e3));
      if (proposedCols > this.xterm.raw.cols) {
        this._fixedCols = proposedCols;
      }
    }
    await this._refreshScrollbar();
    (_b2 = this._labelComputer) == null ? void 0 : _b2.refreshLabel();
    this.focus();
  }
  _refreshScrollbar() {
    if (this._fixedCols || this._fixedRows) {
      return this._addScrollbar();
    }
    return this._removeScrollbar();
  }
  async _addScrollbar() {
    var _a2;
    const charWidth = (this.xterm ? this.xterm.getFont() : this._configHelper.getFont()).charWidth;
    if (!((_a2 = this.xterm) == null ? void 0 : _a2.raw.element) || !this._container || !charWidth || !this._fixedCols) {
      return;
    }
    this._wrapperElement.classList.add("fixed-dims");
    this._hasScrollBar = true;
    this._initDimensions();
    this._fixedRows = this._rows - 1;
    await this._resize();
    this._terminalHasFixedWidth.set(true);
    if (!this._horizontalScrollbar) {
      this._horizontalScrollbar = this._register(new DomScrollableElement(this._wrapperElement, {
        vertical: 2,
        horizontal: 1,
        useShadows: false,
        scrollYToX: false,
        consumeMouseWheelIfScrollbarIsNeeded: false
      }));
      this._container.appendChild(this._horizontalScrollbar.getDomNode());
    }
    this._horizontalScrollbar.setScrollDimensions({
      width: this.xterm.raw.element.clientWidth,
      scrollWidth: this._fixedCols * charWidth + 40
    });
    this._horizontalScrollbar.getDomNode().style.paddingBottom = "16px";
    if (isWindows) {
      for (let i = this.xterm.raw.buffer.active.viewportY; i < this.xterm.raw.buffer.active.length; i++) {
        const line = this.xterm.raw.buffer.active.getLine(i);
        line._line.isWrapped = false;
      }
    }
  }
  async _removeScrollbar() {
    if (!this._container || !this._horizontalScrollbar) {
      return;
    }
    this._horizontalScrollbar.getDomNode().remove();
    this._horizontalScrollbar.dispose();
    this._horizontalScrollbar = void 0;
    this._wrapperElement.remove();
    this._wrapperElement.classList.remove("fixed-dims");
    this._container.appendChild(this._wrapperElement);
  }
  _setResolvedShellLaunchConfig(shellLaunchConfig) {
    this._shellLaunchConfig.args = shellLaunchConfig.args;
    this._shellLaunchConfig.cwd = shellLaunchConfig.cwd;
    this._shellLaunchConfig.executable = shellLaunchConfig.executable;
    this._shellLaunchConfig.env = shellLaunchConfig.env;
  }
  _onEnvironmentVariableInfoChanged(info) {
    var _a2, _b2;
    if (info.requiresAction) {
      (_b2 = (_a2 = this.xterm) == null ? void 0 : _a2.raw.textarea) == null ? void 0 : _b2.setAttribute("aria-label", localize(
        "terminalStaleTextBoxAriaLabel",
        "Terminal {0} environment is stale, run the 'Show Environment Information' command for more information",
        this._instanceId
      ));
    }
    this._refreshEnvironmentVariableInfoWidgetState(info);
  }
  async _refreshEnvironmentVariableInfoWidgetState(info) {
    if (!info) {
      this.statusList.remove("relaunch-needed");
      this.statusList.remove("env-var-info-changes-active");
      return;
    }
    if (info.requiresAction && this._configHelper.config.environmentChangesRelaunch && !this._processManager.hasWrittenData && (!this._shellLaunchConfig.isFeatureTerminal || this.reconnectionProperties && this._configurationService.getValue("task.reconnection") === true) && !this._shellLaunchConfig.customPtyImplementation && !this._shellLaunchConfig.isExtensionOwnedTerminal && !this._shellLaunchConfig.attachPersistentProcess && !(this._processManager.remoteAuthority && this._configHelper.config.windowsEnableConpty && await this._processManager.getBackendOS() === 1)) {
      this.relaunch();
      return;
    }
    const workspaceFolder = getWorkspaceForTerminal(this.shellLaunchConfig.cwd, this._workspaceContextService, this._historyService);
    this.statusList.add(info.getStatus({ workspaceFolder }));
  }
  async getInitialCwd() {
    if (!this._initialCwd) {
      this._initialCwd = this._processManager.initialCwd;
    }
    return this._initialCwd;
  }
  async getCwd() {
    if (this.capabilities.has(0)) {
      return this.capabilities.get(0).getCwd();
    } else if (this.capabilities.has(1)) {
      return this.capabilities.get(1).getCwd();
    }
    return this._processManager.initialCwd;
  }
  async _refreshProperty(type) {
    await this.processReady;
    return this._processManager.refreshProperty(type);
  }
  async _updateProperty(type, value) {
    return this._processManager.updateProperty(type, value);
  }
  async rename(title) {
    this._setTitle(title, TitleEventSource.Api);
  }
  _setTitle(title, eventSource) {
    var _a2, _b2;
    const reset2 = !title;
    title = this._updateTitleProperties(title, eventSource);
    const titleChanged = title !== this._title;
    this._title = title;
    (_a2 = this._labelComputer) == null ? void 0 : _a2.refreshLabel(reset2);
    this._setAriaLabel((_b2 = this.xterm) == null ? void 0 : _b2.raw, this._instanceId, this._title);
    if (titleChanged) {
      this._onTitleChanged.fire(this);
    }
  }
  async changeIcon() {
    const items = [];
    for (const icon of getAllCodicons()) {
      items.push({ label: `$(${icon.id})`, description: `${icon.id}`, icon });
    }
    const result = await this._quickInputService.pick(items, {
      matchOnDescription: true
    });
    if (result) {
      this._icon = result.icon;
      this._onIconChanged.fire({ instance: this, userInitiated: true });
    }
  }
  async changeColor() {
    const icon = this._getIcon();
    if (!icon) {
      return;
    }
    const colorTheme = this._themeService.getColorTheme();
    const standardColors = getStandardColors(colorTheme);
    const styleElement = getColorStyleElement(colorTheme);
    const items = [];
    for (const colorKey of standardColors) {
      const colorClass = getColorClass(colorKey);
      items.push({
        label: `$(${Codicon.circleFilled.id}) ${colorKey.replace("terminal.ansi", "")}`,
        id: colorKey,
        description: colorKey,
        iconClasses: [colorClass]
      });
    }
    items.push({ type: "separator" });
    const showAllColorsItem = { label: "Reset to default" };
    items.push(showAllColorsItem);
    document.body.appendChild(styleElement);
    const quickPick = this._quickInputService.createQuickPick();
    quickPick.items = items;
    quickPick.matchOnDescription = true;
    quickPick.show();
    const disposables = [];
    const result = await new Promise((r) => {
      disposables.push(quickPick.onDidHide(() => r(void 0)));
      disposables.push(quickPick.onDidAccept(() => r(quickPick.selectedItems[0])));
    });
    dispose(disposables);
    if (result) {
      this.shellLaunchConfig.color = result.id;
      this._onIconChanged.fire({ instance: this, userInitiated: true });
    }
    quickPick.hide();
    document.body.removeChild(styleElement);
  }
  selectPreviousSuggestion() {
    var _a2, _b2;
    (_b2 = (_a2 = this.xterm) == null ? void 0 : _a2.suggestController) == null ? void 0 : _b2.selectPreviousSuggestion();
  }
  selectPreviousPageSuggestion() {
    var _a2, _b2;
    (_b2 = (_a2 = this.xterm) == null ? void 0 : _a2.suggestController) == null ? void 0 : _b2.selectPreviousPageSuggestion();
  }
  selectNextSuggestion() {
    var _a2, _b2;
    (_b2 = (_a2 = this.xterm) == null ? void 0 : _a2.suggestController) == null ? void 0 : _b2.selectNextSuggestion();
  }
  selectNextPageSuggestion() {
    var _a2, _b2;
    (_b2 = (_a2 = this.xterm) == null ? void 0 : _a2.suggestController) == null ? void 0 : _b2.selectNextPageSuggestion();
  }
  async acceptSelectedSuggestion(suggestion) {
    var _a2, _b2;
    (_b2 = (_a2 = this.xterm) == null ? void 0 : _a2.suggestController) == null ? void 0 : _b2.acceptSelectedSuggestion(suggestion);
  }
  hideSuggestWidget() {
    var _a2, _b2;
    (_b2 = (_a2 = this.xterm) == null ? void 0 : _a2.suggestController) == null ? void 0 : _b2.hideSuggestWidget();
  }
  forceScrollbarVisibility() {
    this._wrapperElement.classList.add("force-scrollbar");
  }
  resetScrollbarVisibility() {
    this._wrapperElement.classList.remove("force-scrollbar");
  }
}, _G._instanceIdCounter = 1, _G);
TerminalInstance.__decorator = __decorate([
  debounce(50)
], TerminalInstance.prototype, "_fireMaximumDimensionsChanged", null);
TerminalInstance.__decorator = __decorate([
  debounce(1e3)
], TerminalInstance.prototype, "relaunch", null);
TerminalInstance.__decorator = __decorate([
  debounce(2e3)
], TerminalInstance.prototype, "_updateProcessCwd", null);
TerminalInstance.__decorator = __decorate([
  debounce(50)
], TerminalInstance.prototype, "_resize", null);
TerminalInstance = __decorate([
  __param(5, IContextKeyService),
  __param(6, IInstantiationService),
  __param(7, ITerminalProfileResolverService),
  __param(8, IPathService),
  __param(9, IKeybindingService),
  __param(10, INotificationService),
  __param(11, IPreferencesService),
  __param(12, IViewsService),
  __param(13, IClipboardService),
  __param(14, IThemeService),
  __param(15, IConfigurationService),
  __param(16, ITerminalLogService),
  __param(17, IDialogService),
  __param(18, IStorageService),
  __param(19, IAccessibilityService),
  __param(20, IProductService),
  __param(21, IQuickInputService),
  __param(22, IWorkbenchEnvironmentService),
  __param(23, IWorkspaceContextService),
  __param(24, IEditorService),
  __param(25, IWorkspaceTrustRequestService),
  __param(26, IHistoryService),
  __param(27, ITelemetryService),
  __param(28, IOpenerService),
  __param(29, ICommandService),
  __param(30, IAudioCueService),
  __param(31, IViewDescriptorService)
], TerminalInstance);
let TerminalInstanceDragAndDropController = class TerminalInstanceDragAndDropController2 extends Disposable {
  get onDropFile() {
    return this._onDropFile.event;
  }
  get onDropTerminal() {
    return this._onDropTerminal.event;
  }
  constructor(_container, _layoutService, _viewDescriptorService) {
    super();
    this._container = _container;
    this._layoutService = _layoutService;
    this._viewDescriptorService = _viewDescriptorService;
    this._onDropFile = new Emitter();
    this._onDropTerminal = new Emitter();
    this._register(toDisposable(() => this._clearDropOverlay()));
  }
  _clearDropOverlay() {
    if (this._dropOverlay && this._dropOverlay.parentElement) {
      this._dropOverlay.parentElement.removeChild(this._dropOverlay);
    }
    this._dropOverlay = void 0;
  }
  onDragEnter(e) {
    if (!containsDragType(e, DataTransfers.FILES, DataTransfers.RESOURCES, "Terminals", CodeDataTransfers.FILES)) {
      return;
    }
    if (!this._dropOverlay) {
      this._dropOverlay = document.createElement("div");
      this._dropOverlay.classList.add("terminal-drop-overlay");
    }
    if (containsDragType(e, "Terminals")) {
      const side = this._getDropSide(e);
      this._dropOverlay.classList.toggle("drop-before", side === "before");
      this._dropOverlay.classList.toggle("drop-after", side === "after");
    }
    if (!this._dropOverlay.parentElement) {
      this._container.appendChild(this._dropOverlay);
    }
  }
  onDragLeave(e) {
    this._clearDropOverlay();
  }
  onDragEnd(e) {
    this._clearDropOverlay();
  }
  onDragOver(e) {
    if (!e.dataTransfer || !this._dropOverlay) {
      return;
    }
    if (containsDragType(e, "Terminals")) {
      const side = this._getDropSide(e);
      this._dropOverlay.classList.toggle("drop-before", side === "before");
      this._dropOverlay.classList.toggle("drop-after", side === "after");
    }
    this._dropOverlay.style.opacity = "1";
  }
  async onDrop(e) {
    this._clearDropOverlay();
    if (!e.dataTransfer) {
      return;
    }
    const terminalResources = getTerminalResourcesFromDragEvent(e);
    if (terminalResources) {
      for (const uri of terminalResources) {
        const side = this._getDropSide(e);
        this._onDropTerminal.fire({ uri, side });
      }
      return;
    }
    let path;
    const rawResources = e.dataTransfer.getData(DataTransfers.RESOURCES);
    if (rawResources) {
      path = URI.parse(JSON.parse(rawResources)[0]);
    }
    const rawCodeFiles = e.dataTransfer.getData(CodeDataTransfers.FILES);
    if (!path && rawCodeFiles) {
      path = URI.file(JSON.parse(rawCodeFiles)[0]);
    }
    if (!path && e.dataTransfer.files.length > 0 && e.dataTransfer.files[0].path) {
      path = URI.file(e.dataTransfer.files[0].path);
    }
    if (!path) {
      return;
    }
    this._onDropFile.fire(path);
  }
  _getDropSide(e) {
    const target = this._container;
    if (!target) {
      return "after";
    }
    const rect = target.getBoundingClientRect();
    return this._getViewOrientation() === 1 ? e.clientX - rect.left < rect.width / 2 ? "before" : "after" : e.clientY - rect.top < rect.height / 2 ? "before" : "after";
  }
  _getViewOrientation() {
    const panelPosition = this._layoutService.getPanelPosition();
    const terminalLocation = this._viewDescriptorService.getViewLocationById(TERMINAL_VIEW_ID);
    return terminalLocation === 1 && panelPosition === 2 ? 1 : 0;
  }
};
TerminalInstanceDragAndDropController = __decorate([
  __param(1, IWorkbenchLayoutService),
  __param(2, IViewDescriptorService)
], TerminalInstanceDragAndDropController);
let TerminalLabelComputer = class TerminalLabelComputer2 extends Disposable {
  get title() {
    return this._title;
  }
  get description() {
    return this._description;
  }
  constructor(_configHelper, _instance, _fileService, _workspaceContextService) {
    super();
    this._configHelper = _configHelper;
    this._instance = _instance;
    this._fileService = _fileService;
    this._workspaceContextService = _workspaceContextService;
    this._title = "";
    this._description = "";
    this._onDidChangeLabel = this._register(new Emitter());
    this.onDidChangeLabel = this._onDidChangeLabel.event;
  }
  refreshLabel(reset2) {
    this._title = this.computeLabel(this._configHelper.config.tabs.title, "title", reset2);
    this._description = this.computeLabel(this._configHelper.config.tabs.description, "description");
    if (this._title !== this._instance.title || this._description !== this._instance.description || reset2) {
      this._onDidChangeLabel.fire({ title: this._title, description: this._description });
    }
  }
  computeLabel(labelTemplate, labelType, reset2) {
    var _a2, _b2, _c2, _d2;
    const type = ((_a2 = this._instance.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.type) || this._instance.shellLaunchConfig.type;
    const templateProperties = {
      cwd: this._instance.cwd || this._instance.initialCwd || "",
      cwdFolder: "",
      workspaceFolder: this._instance.workspaceFolder ? basename(this._instance.workspaceFolder.uri.fsPath) : void 0,
      local: type === "Local" ? type : void 0,
      process: this._instance.processName,
      sequence: this._instance.sequence,
      task: type === "Task" ? type : void 0,
      fixedDimensions: this._instance.fixedCols ? this._instance.fixedRows ? `↔${this._instance.fixedCols} ↕${this._instance.fixedRows}` : `↔${this._instance.fixedCols}` : this._instance.fixedRows ? `↕${this._instance.fixedRows}` : "",
      separator: { label: this._configHelper.config.tabs.separator }
    };
    labelTemplate = labelTemplate.trim();
    if (!labelTemplate) {
      return labelType === "title" ? this._instance.processName || "" : "";
    }
    if (!reset2 && this._instance.staticTitle && labelType === "title") {
      return this._instance.staticTitle.replace(/[\n\r\t]/g, "") || ((_b2 = templateProperties.process) == null ? void 0 : _b2.replace(/[\n\r\t]/g, "")) || "";
    }
    const detection = this._instance.capabilities.has(0) || this._instance.capabilities.has(1);
    const folders = this._workspaceContextService.getWorkspace().folders;
    const multiRootWorkspace = folders.length > 1;
    if (templateProperties.cwd && detection && (!this._instance.shellLaunchConfig.isFeatureTerminal || labelType === "title")) {
      const cwdUri = URI.from({
        scheme: ((_c2 = this._instance.workspaceFolder) == null ? void 0 : _c2.uri.scheme) || Schemas.file,
        path: this._instance.cwd ? resolve(this._instance.cwd) : void 0
      });
      let showCwd = false;
      if (multiRootWorkspace) {
        showCwd = true;
      } else if ((_d2 = this._instance.workspaceFolder) == null ? void 0 : _d2.uri) {
        const caseSensitive = this._fileService.hasCapability(this._instance.workspaceFolder.uri, 1024);
        showCwd = cwdUri.fsPath.localeCompare(this._instance.workspaceFolder.uri.fsPath, void 0, { sensitivity: caseSensitive ? "case" : "base" }) !== 0;
      }
      if (showCwd) {
        templateProperties.cwdFolder = basename(templateProperties.cwd);
      }
    }
    const label = template(labelTemplate, templateProperties).replace(/[\n\r\t]/g, "").trim();
    return label === "" && labelType === "title" ? this._instance.processName || "" : label;
  }
};
TerminalLabelComputer = __decorate([
  __param(2, IFileService),
  __param(3, IWorkspaceContextService)
], TerminalLabelComputer);
function parseExitResult(exitCodeOrError, shellLaunchConfig, processState, initialCwd) {
  if (exitCodeOrError === void 0 || exitCodeOrError === 0) {
    return { code: exitCodeOrError, message: void 0 };
  }
  const code = typeof exitCodeOrError === "number" ? exitCodeOrError : exitCodeOrError.code;
  let message = void 0;
  switch (typeof exitCodeOrError) {
    case "number": {
      let commandLine = void 0;
      if (shellLaunchConfig.executable) {
        commandLine = shellLaunchConfig.executable;
        if (typeof shellLaunchConfig.args === "string") {
          commandLine += ` ${shellLaunchConfig.args}`;
        } else if (shellLaunchConfig.args && shellLaunchConfig.args.length) {
          commandLine += shellLaunchConfig.args.map((a) => ` '${a}'`).join();
        }
      }
      if (processState === 4) {
        if (commandLine) {
          message = localize(
            "launchFailed.exitCodeAndCommandLine",
            'The terminal process "{0}" failed to launch (exit code: {1}).',
            commandLine,
            code
          );
        } else {
          message = localize(
            "launchFailed.exitCodeOnly",
            "The terminal process failed to launch (exit code: {0}).",
            code
          );
        }
      } else {
        if (commandLine) {
          message = localize(
            "terminated.exitCodeAndCommandLine",
            'The terminal process "{0}" terminated with exit code: {1}.',
            commandLine,
            code
          );
        } else {
          message = localize(
            "terminated.exitCodeOnly",
            "The terminal process terminated with exit code: {0}.",
            code
          );
        }
      }
      break;
    }
    case "object": {
      if (exitCodeOrError.message.toString().includes("Could not find pty with id")) {
        break;
      }
      let innerMessage = exitCodeOrError.message;
      const conptyError = exitCodeOrError.message.match(/.*error code:\s*(\d+).*$/);
      if (conptyError) {
        const errorCode = conptyError.length > 1 ? parseInt(conptyError[1]) : void 0;
        switch (errorCode) {
          case 5:
            innerMessage = `Access was denied to the path containing your executable "${shellLaunchConfig.executable}". Manage and change your permissions to get this to work`;
            break;
          case 267:
            innerMessage = `Invalid starting directory "${initialCwd}", review your terminal.integrated.cwd setting`;
            break;
          case 1260:
            innerMessage = `Windows cannot open this program because it has been prevented by a software restriction policy. For more information, open Event Viewer or contact your system Administrator`;
            break;
        }
      }
      message = localize(
        "launchFailed.errorMessage",
        "The terminal process failed to launch: {0}.",
        innerMessage
      );
      break;
    }
  }
  return { code, message };
}
let TerminalService = class TerminalService2 {
  get isProcessSupportRegistered() {
    return !!this._processSupportContextKey.get();
  }
  get connectionState() {
    return this._connectionState;
  }
  get whenConnected() {
    return this._whenConnected.p;
  }
  get restoredGroupCount() {
    return this._restoredGroupCount;
  }
  get configHelper() {
    return this._configHelper;
  }
  get instances() {
    return this._terminalGroupService.instances.concat(this._terminalEditorService.instances);
  }
  get detachedXterms() {
    return this._detachedXterms;
  }
  getReconnectedTerminals(reconnectionOwner) {
    return this._reconnectedTerminals.get(reconnectionOwner);
  }
  get defaultLocation() {
    return this.configHelper.config.defaultLocation === "editor" ? TerminalLocation.Editor : TerminalLocation.Panel;
  }
  get activeInstance() {
    for (const activeHostTerminal of this._hostActiveTerminals.values()) {
      if (activeHostTerminal == null ? void 0 : activeHostTerminal.hasFocus) {
        return activeHostTerminal;
      }
    }
    return this._activeInstance;
  }
  get onDidChangeActiveGroup() {
    return this._onDidChangeActiveGroup.event;
  }
  get onDidCreateInstance() {
    return this._onDidCreateInstance.event;
  }
  get onDidDisposeInstance() {
    return this._onDidDisposeInstance.event;
  }
  get onDidFocusInstance() {
    return this._onDidFocusInstance.event;
  }
  get onDidReceiveProcessId() {
    return this._onDidReceiveProcessId.event;
  }
  get onDidRequestStartExtensionTerminal() {
    return this._onDidRequestStartExtensionTerminal.event;
  }
  get onDidChangeInstanceDimensions() {
    return this._onDidChangeInstanceDimensions.event;
  }
  get onDidMaximumDimensionsChange() {
    return this._onDidMaxiumumDimensionsChange.event;
  }
  get onDidChangeInstanceCapability() {
    return this._onDidChangeInstanceCapability.event;
  }
  get onDidChangeInstances() {
    return this._onDidChangeInstances.event;
  }
  get onDidChangeInstanceTitle() {
    return this._onDidChangeInstanceTitle.event;
  }
  get onDidChangeInstanceIcon() {
    return this._onDidChangeInstanceIcon.event;
  }
  get onDidChangeInstanceColor() {
    return this._onDidChangeInstanceColor.event;
  }
  get onDidChangeActiveInstance() {
    return this._onDidChangeActiveInstance.event;
  }
  get onDidChangeInstancePrimaryStatus() {
    return this._onDidChangeInstancePrimaryStatus.event;
  }
  get onDidInputInstanceData() {
    return this._onDidInputInstanceData.event;
  }
  get onDidChangeSelection() {
    return this._onDidChangeSelection.event;
  }
  get onDidDisposeGroup() {
    return this._onDidDisposeGroup.event;
  }
  get onDidChangeGroups() {
    return this._onDidChangeGroups.event;
  }
  get onDidRegisterProcessSupport() {
    return this._onDidRegisterProcessSupport.event;
  }
  get onDidChangeConnectionState() {
    return this._onDidChangeConnectionState.event;
  }
  constructor(_contextKeyService, _lifecycleService, _logService, _dialogService, _instantiationService, _remoteAgentService, _viewsService, _configurationService, _environmentService, _terminalEditorService, _terminalGroupService, _terminalInstanceService, _editorGroupsService, _terminalProfileService, _extensionService, _notificationService, _workspaceContextService, _commandService, _keybindingService, _timerService) {
    this._contextKeyService = _contextKeyService;
    this._lifecycleService = _lifecycleService;
    this._logService = _logService;
    this._dialogService = _dialogService;
    this._instantiationService = _instantiationService;
    this._remoteAgentService = _remoteAgentService;
    this._viewsService = _viewsService;
    this._configurationService = _configurationService;
    this._environmentService = _environmentService;
    this._terminalEditorService = _terminalEditorService;
    this._terminalGroupService = _terminalGroupService;
    this._terminalInstanceService = _terminalInstanceService;
    this._editorGroupsService = _editorGroupsService;
    this._terminalProfileService = _terminalProfileService;
    this._extensionService = _extensionService;
    this._notificationService = _notificationService;
    this._workspaceContextService = _workspaceContextService;
    this._commandService = _commandService;
    this._keybindingService = _keybindingService;
    this._timerService = _timerService;
    this._hostActiveTerminals = /* @__PURE__ */ new Map();
    this._detachedXterms = /* @__PURE__ */ new Set();
    this._isShuttingDown = false;
    this._backgroundedTerminalInstances = [];
    this._backgroundedTerminalDisposables = /* @__PURE__ */ new Map();
    this._connectionState = 0;
    this._whenConnected = new DeferredPromise();
    this._restoredGroupCount = 0;
    this._reconnectedTerminals = /* @__PURE__ */ new Map();
    this._onDidChangeActiveGroup = new Emitter();
    this._onDidCreateInstance = new Emitter();
    this._onDidDisposeInstance = new Emitter();
    this._onDidFocusInstance = new Emitter();
    this._onDidReceiveProcessId = new Emitter();
    this._onDidRequestStartExtensionTerminal = new Emitter();
    this._onDidChangeInstanceDimensions = new Emitter();
    this._onDidMaxiumumDimensionsChange = new Emitter();
    this._onDidChangeInstanceCapability = new Emitter();
    this._onDidChangeInstances = new Emitter();
    this._onDidChangeInstanceTitle = new Emitter();
    this._onDidChangeInstanceIcon = new Emitter();
    this._onDidChangeInstanceColor = new Emitter();
    this._onDidChangeActiveInstance = new Emitter();
    this._onDidChangeInstancePrimaryStatus = new Emitter();
    this._onDidInputInstanceData = new Emitter();
    this._onDidChangeSelection = new Emitter();
    this._onDidDisposeGroup = new Emitter();
    this._onDidChangeGroups = new Emitter();
    this._onDidRegisterProcessSupport = new Emitter();
    this._onDidChangeConnectionState = new Emitter();
    this._configHelper = this._instantiationService.createInstance(TerminalConfigHelper);
    this.onDidCreateInstance(() => this._terminalProfileService.refreshAvailableProfiles());
    this._forwardInstanceHostEvents(this._terminalGroupService);
    this._forwardInstanceHostEvents(this._terminalEditorService);
    this._terminalGroupService.onDidChangeActiveGroup(this._onDidChangeActiveGroup.fire, this._onDidChangeActiveGroup);
    this._terminalInstanceService.onDidCreateInstance((instance) => {
      this._initInstanceListeners(instance);
      this._onDidCreateInstance.fire(instance);
    });
    this._terminalGroupService.onDidChangeActiveInstance((instance) => {
      if (!instance && !this._isShuttingDown) {
        this._terminalGroupService.hidePanel();
      }
      if (instance == null ? void 0 : instance.shellType) {
        this._terminalShellTypeContextKey.set(instance.shellType.toString());
      } else if (!instance) {
        this._terminalShellTypeContextKey.reset();
      }
    });
    this._handleInstanceContextKeys();
    this._terminalShellTypeContextKey = TerminalContextKeys.shellType.bindTo(this._contextKeyService);
    this._processSupportContextKey = TerminalContextKeys.processSupported.bindTo(this._contextKeyService);
    this._processSupportContextKey.set(!isWeb || this._remoteAgentService.getConnection() !== null || Registry.as(TerminalExtensions.Backend).getTerminalBackend() !== void 0);
    this._terminalHasBeenCreated = TerminalContextKeys.terminalHasBeenCreated.bindTo(this._contextKeyService);
    this._terminalCountContextKey = TerminalContextKeys.count.bindTo(this._contextKeyService);
    this._terminalEditorActive = TerminalContextKeys.terminalEditorActive.bindTo(this._contextKeyService);
    this.onDidChangeActiveInstance((instance) => {
      this._terminalEditorActive.set(!!(instance == null ? void 0 : instance.target) && instance.target === TerminalLocation.Editor);
    });
    _lifecycleService.onBeforeShutdown(async (e) => e.veto(this._onBeforeShutdown(e.reason), "veto.terminal"));
    _lifecycleService.onWillShutdown((e) => this._onWillShutdown(e));
    this.initializePrimaryBackend();
    timeout(0).then(() => this._instantiationService.createInstance(TerminalEditorStyle, document.head));
  }
  async showProfileQuickPick(type, cwd) {
    var _a2, _b2;
    const quickPick = this._instantiationService.createInstance(TerminalProfileQuickpick);
    const result = await quickPick.showAndGetResult(type);
    if (!result) {
      return;
    }
    if (typeof result === "string") {
      return;
    }
    const keyMods = result.keyMods;
    if (type === "createInstance") {
      const activeInstance = this.getDefaultInstanceHost().activeInstance;
      let instance;
      if (result.config && "id" in (result == null ? void 0 : result.config)) {
        await this.createContributedTerminalProfile(result.config.extensionIdentifier, result.config.id, {
          icon: (_a2 = result.config.options) == null ? void 0 : _a2.icon,
          color: (_b2 = result.config.options) == null ? void 0 : _b2.color,
          location: !!((keyMods == null ? void 0 : keyMods.alt) && activeInstance) ? { splitActiveTerminal: true } : this.defaultLocation
        });
        return;
      } else if (result.config && "profileName" in result.config) {
        if ((keyMods == null ? void 0 : keyMods.alt) && activeInstance) {
          instance = await this.createTerminal({ location: { parentTerminal: activeInstance }, config: result.config, cwd });
        } else {
          instance = await this.createTerminal({ location: this.defaultLocation, config: result.config, cwd });
        }
      }
      if (instance && this.defaultLocation !== TerminalLocation.Editor) {
        this._terminalGroupService.showPanel(true);
        this.setActiveInstance(instance);
        return instance;
      }
    }
    return void 0;
  }
  async initializePrimaryBackend() {
    var _a2;
    mark("code/terminal/willGetTerminalBackend");
    this._primaryBackend = await this._terminalInstanceService.getBackend(this._environmentService.remoteAuthority);
    mark("code/terminal/didGetTerminalBackend");
    const enableTerminalReconnection = this.configHelper.config.enablePersistentSessions;
    this._connectionState = 0;
    const isPersistentRemote = !!this._environmentService.remoteAuthority && enableTerminalReconnection;
    (_a2 = this._primaryBackend) == null ? void 0 : _a2.onDidRequestDetach(async (e) => {
      var _a3, _b2, _c2;
      const instanceToDetach = this.getInstanceFromResource(getTerminalUri(e.workspaceId, e.instanceId));
      if (instanceToDetach) {
        const persistentProcessId = instanceToDetach == null ? void 0 : instanceToDetach.persistentProcessId;
        if (persistentProcessId && !instanceToDetach.shellLaunchConfig.isFeatureTerminal && !instanceToDetach.shellLaunchConfig.customPtyImplementation) {
          if (instanceToDetach.target === TerminalLocation.Editor) {
            this._terminalEditorService.detachInstance(instanceToDetach);
          } else {
            (_a3 = this._terminalGroupService.getGroupForInstance(instanceToDetach)) == null ? void 0 : _a3.removeInstance(instanceToDetach);
          }
          await instanceToDetach.detachProcessAndDispose(TerminalExitReason.User);
          await ((_b2 = this._primaryBackend) == null ? void 0 : _b2.acceptDetachInstanceReply(e.requestId, persistentProcessId));
        } else {
          await ((_c2 = this._primaryBackend) == null ? void 0 : _c2.acceptDetachInstanceReply(e.requestId, void 0));
        }
      }
    });
    mark("code/terminal/willReconnect");
    let reconnectedPromise;
    if (isPersistentRemote) {
      reconnectedPromise = this._reconnectToRemoteTerminals();
    } else if (enableTerminalReconnection) {
      reconnectedPromise = this._reconnectToLocalTerminals();
    } else {
      reconnectedPromise = Promise.resolve();
    }
    reconnectedPromise.then(async () => {
      var _a3;
      this._setConnected();
      mark("code/terminal/didReconnect");
      mark("code/terminal/willReplay");
      const instances = await ((_a3 = this._reconnectedTerminalGroups) == null ? void 0 : _a3.then((groups) => groups.map((e) => e.terminalInstances).flat())) ?? [];
      await Promise.all(instances.map((e) => new Promise((r) => Event.once(e.onProcessReplayComplete)(r))));
      mark("code/terminal/didReplay");
      mark("code/terminal/willGetPerformanceMarks");
      await Promise.all(Array.from(this._terminalInstanceService.getRegisteredBackends()).map(async (backend) => {
        this._timerService.setPerformanceMarks(backend.remoteAuthority === void 0 ? "localPtyHost" : "remotePtyHost", await backend.getPerformanceMarks());
        backend.setReady();
      }));
      mark("code/terminal/didGetPerformanceMarks");
      this._whenConnected.complete();
    });
  }
  getPrimaryBackend() {
    return this._primaryBackend;
  }
  _forwardInstanceHostEvents(host) {
    host.onDidChangeInstances(this._onDidChangeInstances.fire, this._onDidChangeInstances);
    host.onDidDisposeInstance(this._onDidDisposeInstance.fire, this._onDidDisposeInstance);
    host.onDidChangeActiveInstance((instance) => this._evaluateActiveInstance(host, instance));
    host.onDidFocusInstance((instance) => {
      this._onDidFocusInstance.fire(instance);
      this._evaluateActiveInstance(host, instance);
    });
    host.onDidChangeInstanceCapability((instance) => {
      this._onDidChangeInstanceCapability.fire(instance);
    });
    this._hostActiveTerminals.set(host, void 0);
  }
  _evaluateActiveInstance(host, instance) {
    this._hostActiveTerminals.set(host, instance);
    if (instance === void 0) {
      for (const active of this._hostActiveTerminals.values()) {
        if (active) {
          instance = active;
        }
      }
    }
    this._activeInstance = instance;
    this._onDidChangeActiveInstance.fire(instance);
  }
  setActiveInstance(value) {
    if (value.shellLaunchConfig.hideFromUser) {
      this._showBackgroundTerminal(value);
    }
    if (value.target === TerminalLocation.Editor) {
      this._terminalEditorService.setActiveInstance(value);
    } else {
      this._terminalGroupService.setActiveInstance(value);
    }
  }
  async focusActiveInstance() {
    if (!this._activeInstance) {
      return;
    }
    if (this._activeInstance.target === TerminalLocation.Editor) {
      return this._terminalEditorService.focusActiveInstance();
    }
    return this._terminalGroupService.focusActiveInstance();
  }
  async createContributedTerminalProfile(extensionIdentifier, id, options) {
    var _a2;
    await this._extensionService.activateByEvent(`onTerminalProfile:${id}`);
    const profileProvider = this._terminalProfileService.getContributedProfileProvider(extensionIdentifier, id);
    if (!profileProvider) {
      this._notificationService.error(`No terminal profile provider registered for id "${id}"`);
      return;
    }
    try {
      await profileProvider.createContributedTerminalProfile(options);
      this._terminalGroupService.setActiveInstanceByIndex(this._terminalGroupService.instances.length - 1);
      await ((_a2 = this._terminalGroupService.activeInstance) == null ? void 0 : _a2.focusWhenReady());
    } catch (e) {
      this._notificationService.error(e.message);
    }
  }
  async safeDisposeTerminal(instance) {
    if (instance.target !== TerminalLocation.Editor && instance.hasChildProcesses && (this.configHelper.config.confirmOnKill === "panel" || this.configHelper.config.confirmOnKill === "always")) {
      const veto = await this._showTerminalCloseConfirmation(true);
      if (veto) {
        return;
      }
    }
    return new Promise((r) => {
      instance.onExit(() => r());
      instance.dispose(TerminalExitReason.User);
    });
  }
  _setConnected() {
    this._connectionState = 1;
    this._onDidChangeConnectionState.fire();
    this._logService.trace("Pty host ready");
  }
  async _reconnectToRemoteTerminals() {
    const remoteAuthority = this._environmentService.remoteAuthority;
    if (!remoteAuthority) {
      return;
    }
    const backend = await this._terminalInstanceService.getBackend(remoteAuthority);
    if (!backend) {
      return;
    }
    mark("code/terminal/willGetTerminalLayoutInfo");
    const layoutInfo = await backend.getTerminalLayoutInfo();
    mark("code/terminal/didGetTerminalLayoutInfo");
    backend.reduceConnectionGraceTime();
    mark("code/terminal/willRecreateTerminalGroups");
    await this._recreateTerminalGroups(layoutInfo);
    mark("code/terminal/didRecreateTerminalGroups");
    this._attachProcessLayoutListeners();
    this._logService.trace("Reconnected to remote terminals");
  }
  async _reconnectToLocalTerminals() {
    const localBackend = await this._terminalInstanceService.getBackend();
    if (!localBackend) {
      return;
    }
    mark("code/terminal/willGetTerminalLayoutInfo");
    const layoutInfo = await localBackend.getTerminalLayoutInfo();
    mark("code/terminal/didGetTerminalLayoutInfo");
    if (layoutInfo && layoutInfo.tabs.length > 0) {
      mark("code/terminal/willRecreateTerminalGroups");
      this._reconnectedTerminalGroups = this._recreateTerminalGroups(layoutInfo);
      mark("code/terminal/didRecreateTerminalGroups");
    }
    this._attachProcessLayoutListeners();
    this._logService.trace("Reconnected to local terminals");
  }
  _recreateTerminalGroups(layoutInfo) {
    const groupPromises = [];
    let activeGroup;
    if (layoutInfo) {
      for (const tabLayout of layoutInfo.tabs) {
        const terminalLayouts = tabLayout.terminals.filter((t) => t.terminal && t.terminal.isOrphan);
        if (terminalLayouts.length) {
          this._restoredGroupCount += terminalLayouts.length;
          const promise = this._recreateTerminalGroup(tabLayout, terminalLayouts);
          groupPromises.push(promise);
          if (tabLayout.isActive) {
            activeGroup = promise;
          }
          const activeInstance = this.instances.find((t) => {
            var _a2;
            return ((_a2 = t.shellLaunchConfig.attachPersistentProcess) == null ? void 0 : _a2.id) === tabLayout.activePersistentProcessId;
          });
          if (activeInstance) {
            this.setActiveInstance(activeInstance);
          }
        }
      }
      if (layoutInfo.tabs.length) {
        activeGroup == null ? void 0 : activeGroup.then((group) => this._terminalGroupService.activeGroup = group);
      }
    }
    return Promise.all(groupPromises).then((result) => result.filter((e) => !!e));
  }
  async _recreateTerminalGroup(tabLayout, terminalLayouts) {
    let lastInstance;
    let group;
    for (const terminalLayout of terminalLayouts) {
      const attachPersistentProcess = terminalLayout.terminal;
      if (this._lifecycleService.startupKind !== 3 && attachPersistentProcess.type === "Task") {
        continue;
      }
      mark(`code/terminal/willRecreateTerminal/${attachPersistentProcess.id}-${attachPersistentProcess.pid}`);
      if (!lastInstance) {
        lastInstance = this.createTerminal({
          config: { attachPersistentProcess },
          location: TerminalLocation.Panel
        });
        group = lastInstance.then((instance) => this._terminalGroupService.getGroupForInstance(instance));
      } else {
        lastInstance = this.createTerminal({
          config: { attachPersistentProcess },
          location: { parentTerminal: lastInstance }
        });
      }
      mark(`code/terminal/didRecreateTerminal/${attachPersistentProcess.id}-${attachPersistentProcess.pid}`);
    }
    group == null ? void 0 : group.then((g) => g == null ? void 0 : g.resizePanes(tabLayout.terminals.map((terminal) => terminal.relativeSize)));
    return group;
  }
  _attachProcessLayoutListeners() {
    this.onDidChangeActiveGroup(() => this._saveState());
    this.onDidChangeActiveInstance(() => this._saveState());
    this.onDidChangeInstances(() => this._saveState());
    this.onDidReceiveProcessId(() => this._saveState());
    this.onDidChangeInstanceTitle((instance) => this._updateTitle(instance));
    this.onDidChangeInstanceIcon((e) => this._updateIcon(e.instance, e.userInitiated));
  }
  _handleInstanceContextKeys() {
    const terminalIsOpenContext = TerminalContextKeys.isOpen.bindTo(this._contextKeyService);
    const updateTerminalContextKeys = () => {
      terminalIsOpenContext.set(this.instances.length > 0);
      this._terminalCountContextKey.set(this.instances.length);
    };
    this.onDidChangeInstances(() => updateTerminalContextKeys());
  }
  async getActiveOrCreateInstance(options) {
    var _a2;
    const activeInstance = this.activeInstance;
    if (!activeInstance) {
      return this.createTerminal();
    }
    if (!(options == null ? void 0 : options.acceptsInput) || ((_a2 = activeInstance.xterm) == null ? void 0 : _a2.isStdinDisabled) !== true) {
      return activeInstance;
    }
    const instance = await this.createTerminal();
    this.setActiveInstance(instance);
    await this.revealActiveTerminal();
    return instance;
  }
  async revealActiveTerminal() {
    const instance = this.activeInstance;
    if (!instance) {
      return;
    }
    if (instance.target === TerminalLocation.Editor) {
      await this._terminalEditorService.revealActiveEditor();
    } else {
      await this._terminalGroupService.showPanel();
    }
  }
  setEditable(instance, data) {
    var _a2;
    if (!data) {
      this._editable = void 0;
    } else {
      this._editable = { instance, data };
    }
    const pane = this._viewsService.getActiveViewWithId(TERMINAL_VIEW_ID);
    const isEditing = this.isEditable(instance);
    (_a2 = pane == null ? void 0 : pane.terminalTabbedView) == null ? void 0 : _a2.setEditable(isEditing);
  }
  isEditable(instance) {
    return !!this._editable && (this._editable.instance === instance || !instance);
  }
  getEditableData(instance) {
    return this._editable && this._editable.instance === instance ? this._editable.data : void 0;
  }
  requestStartExtensionTerminal(proxy, cols, rows) {
    return new Promise((callback) => {
      this._onDidRequestStartExtensionTerminal.fire({ proxy, cols, rows, callback });
    });
  }
  _onBeforeShutdown(reason) {
    if (isWeb) {
      this._isShuttingDown = true;
      return false;
    }
    return this._onBeforeShutdownAsync(reason);
  }
  async _onBeforeShutdownAsync(reason) {
    var _a2, _b2;
    if (this.instances.length === 0) {
      return false;
    }
    try {
      this._shutdownWindowCount = await ((_a2 = this._nativeDelegate) == null ? void 0 : _a2.getWindowCount());
      const shouldReviveProcesses = this._shouldReviveProcesses(reason);
      if (shouldReviveProcesses) {
        await Promise.race([
          (_b2 = this._primaryBackend) == null ? void 0 : _b2.persistTerminalState(),
          timeout(2e3)
        ]);
      }
      const shouldPersistProcesses = this._configHelper.config.enablePersistentSessions && reason === 3;
      if (!shouldPersistProcesses) {
        const hasDirtyInstances = this.configHelper.config.confirmOnExit === "always" && this.instances.length > 0 || this.configHelper.config.confirmOnExit === "hasChildProcesses" && this.instances.some((e) => e.hasChildProcesses);
        if (hasDirtyInstances) {
          return this._onBeforeShutdownConfirmation(reason);
        }
      }
    } catch (err) {
      this._logService.warn("Exception occurred during terminal shutdown", err);
    }
    this._isShuttingDown = true;
    return false;
  }
  setNativeDelegate(nativeDelegate) {
    this._nativeDelegate = nativeDelegate;
  }
  _shouldReviveProcesses(reason) {
    if (!this._configHelper.config.enablePersistentSessions) {
      return false;
    }
    switch (this.configHelper.config.persistentSessionReviveProcess) {
      case "onExit": {
        if (reason === 1 && (this._shutdownWindowCount === 1 && !isMacintosh)) {
          return true;
        }
        return reason === 4 || reason === 2;
      }
      case "onExitAndWindowClose":
        return reason !== 3;
      default:
        return false;
    }
  }
  async _onBeforeShutdownConfirmation(reason) {
    const veto = await this._showTerminalCloseConfirmation();
    if (!veto) {
      this._isShuttingDown = true;
    }
    return veto;
  }
  _onWillShutdown(e) {
    var _a2;
    const shouldPersistTerminals = this._configHelper.config.enablePersistentSessions && e.reason === 3;
    for (const instance of [...this._terminalGroupService.instances, ...this._backgroundedTerminalInstances]) {
      if (shouldPersistTerminals && instance.shouldPersist) {
        instance.detachProcessAndDispose(TerminalExitReason.Shutdown);
      } else {
        instance.dispose(TerminalExitReason.Shutdown);
      }
    }
    if (!shouldPersistTerminals && !this._shouldReviveProcesses(e.reason)) {
      (_a2 = this._primaryBackend) == null ? void 0 : _a2.setTerminalLayoutInfo(void 0);
    }
  }
  _saveState() {
    var _a2;
    if (this._isShuttingDown) {
      return;
    }
    if (!this.configHelper.config.enablePersistentSessions) {
      return;
    }
    const tabs = this._terminalGroupService.groups.map((g) => g.getLayoutInfo(g === this._terminalGroupService.activeGroup));
    const state = { tabs };
    (_a2 = this._primaryBackend) == null ? void 0 : _a2.setTerminalLayoutInfo(state);
  }
  _updateTitle(instance) {
    var _a2, _b2;
    if (!this.configHelper.config.enablePersistentSessions || !instance || !instance.persistentProcessId || !instance.title || instance.isDisposed) {
      return;
    }
    if (instance.staticTitle) {
      (_a2 = this._primaryBackend) == null ? void 0 : _a2.updateTitle(instance.persistentProcessId, instance.staticTitle, TitleEventSource.Api);
    } else {
      (_b2 = this._primaryBackend) == null ? void 0 : _b2.updateTitle(instance.persistentProcessId, instance.title, instance.titleSource);
    }
  }
  _updateIcon(instance, userInitiated) {
    var _a2;
    if (!this.configHelper.config.enablePersistentSessions || !instance || !instance.persistentProcessId || !instance.icon || instance.isDisposed) {
      return;
    }
    (_a2 = this._primaryBackend) == null ? void 0 : _a2.updateIcon(instance.persistentProcessId, userInitiated, instance.icon, instance.color);
  }
  refreshActiveGroup() {
    this._onDidChangeActiveGroup.fire(this._terminalGroupService.activeGroup);
  }
  getInstanceFromId(terminalId) {
    let bgIndex = -1;
    this._backgroundedTerminalInstances.forEach((terminalInstance, i) => {
      if (terminalInstance.instanceId === terminalId) {
        bgIndex = i;
      }
    });
    if (bgIndex !== -1) {
      return this._backgroundedTerminalInstances[bgIndex];
    }
    try {
      return this.instances[this._getIndexFromId(terminalId)];
    } catch {
      return void 0;
    }
  }
  getInstanceFromIndex(terminalIndex) {
    return this.instances[terminalIndex];
  }
  getInstanceFromResource(resource) {
    return getInstanceFromResource(this.instances, resource);
  }
  isAttachedToTerminal(remoteTerm) {
    return this.instances.some((term) => term.processId === remoteTerm.pid);
  }
  moveToEditor(source) {
    if (source.target === TerminalLocation.Editor) {
      return;
    }
    const sourceGroup = this._terminalGroupService.getGroupForInstance(source);
    if (!sourceGroup) {
      return;
    }
    sourceGroup.removeInstance(source);
    this._terminalEditorService.openEditor(source);
  }
  async moveToTerminalView(source, target, side) {
    if (URI.isUri(source)) {
      source = this.getInstanceFromResource(source);
    }
    if (!source) {
      return;
    }
    this._terminalEditorService.detachInstance(source);
    if (source.target !== TerminalLocation.Editor) {
      await this._terminalGroupService.showPanel(true);
      return;
    }
    source.target = TerminalLocation.Panel;
    let group;
    if (target) {
      group = this._terminalGroupService.getGroupForInstance(target);
    }
    if (!group) {
      group = this._terminalGroupService.createGroup();
    }
    group.addInstance(source);
    this.setActiveInstance(source);
    await this._terminalGroupService.showPanel(true);
    if (target && side) {
      const index = group.terminalInstances.indexOf(target) + (side === "after" ? 1 : 0);
      group.moveInstance(source, index);
    }
    this._onDidChangeInstances.fire();
    this._onDidChangeActiveGroup.fire(this._terminalGroupService.activeGroup);
  }
  _initInstanceListeners(instance) {
    const instanceDisposables = [
      instance.onTitleChanged(this._onDidChangeInstanceTitle.fire, this._onDidChangeInstanceTitle),
      instance.onIconChanged(this._onDidChangeInstanceIcon.fire, this._onDidChangeInstanceIcon),
      instance.onIconChanged(this._onDidChangeInstanceColor.fire, this._onDidChangeInstanceColor),
      instance.onProcessIdReady(this._onDidReceiveProcessId.fire, this._onDidReceiveProcessId),
      instance.statusList.onDidChangePrimaryStatus(() => this._onDidChangeInstancePrimaryStatus.fire(instance)),
      instance.onDimensionsChanged(() => {
        this._onDidChangeInstanceDimensions.fire(instance);
        if (this.configHelper.config.enablePersistentSessions && this.isProcessSupportRegistered) {
          this._saveState();
        }
      }),
      instance.onMaximumDimensionsChanged(() => this._onDidMaxiumumDimensionsChange.fire(instance)),
      instance.onDidInputData(this._onDidInputInstanceData.fire, this._onDidInputInstanceData),
      instance.onDidFocus(this._onDidChangeActiveInstance.fire, this._onDidChangeActiveInstance),
      instance.onRequestAddInstanceToGroup(async (e) => await this._addInstanceToGroup(instance, e)),
      instance.onDidChangeSelection(this._onDidChangeSelection.fire, this._onDidChangeSelection)
    ];
    instance.onDisposed(() => dispose(instanceDisposables));
  }
  async _addInstanceToGroup(instance, e) {
    var _a2;
    const terminalIdentifier = parseTerminalUri(e.uri);
    if (terminalIdentifier.instanceId === void 0) {
      return;
    }
    let sourceInstance = this.getInstanceFromResource(e.uri);
    if (!sourceInstance) {
      const attachPersistentProcess = await ((_a2 = this._primaryBackend) == null ? void 0 : _a2.requestDetachInstance(terminalIdentifier.workspaceId, terminalIdentifier.instanceId));
      if (attachPersistentProcess) {
        sourceInstance = await this.createTerminal({ config: { attachPersistentProcess }, resource: e.uri });
        this._terminalGroupService.moveInstance(sourceInstance, instance, e.side);
        return;
      }
    }
    sourceInstance = this._terminalGroupService.getInstanceFromResource(e.uri);
    if (sourceInstance) {
      this._terminalGroupService.moveInstance(sourceInstance, instance, e.side);
      return;
    }
    sourceInstance = this._terminalEditorService.getInstanceFromResource(e.uri);
    if (sourceInstance) {
      this.moveToTerminalView(sourceInstance, instance, e.side);
      return;
    }
    return;
  }
  registerProcessSupport(isSupported) {
    if (!isSupported) {
      return;
    }
    this._processSupportContextKey.set(isSupported);
    this._onDidRegisterProcessSupport.fire();
  }
  _getIndexFromId(terminalId) {
    let terminalIndex = -1;
    this.instances.forEach((terminalInstance, i) => {
      if (terminalInstance.instanceId === terminalId) {
        terminalIndex = i;
      }
    });
    if (terminalIndex === -1) {
      throw new Error(`Terminal with ID ${terminalId} does not exist (has it already been disposed?)`);
    }
    return terminalIndex;
  }
  async _showTerminalCloseConfirmation(singleTerminal) {
    let message;
    if (this.instances.length === 1 || singleTerminal) {
      message = localize(
        "terminalService.terminalCloseConfirmationSingular",
        "Do you want to terminate the active terminal session?"
      );
    } else {
      message = localize(
        "terminalService.terminalCloseConfirmationPlural",
        "Do you want to terminate the {0} active terminal sessions?",
        this.instances.length
      );
    }
    const { confirmed } = await this._dialogService.confirm({
      type: "warning",
      message,
      primaryButton: localize({ key: "terminate", comment: ["&& denotes a mnemonic"] }, "&&Terminate")
    });
    return !confirmed;
  }
  getDefaultInstanceHost() {
    if (this.defaultLocation === TerminalLocation.Editor) {
      return this._terminalEditorService;
    }
    return this._terminalGroupService;
  }
  async getInstanceHost(location) {
    if (location) {
      if (location === TerminalLocation.Editor) {
        return this._terminalEditorService;
      } else if (typeof location === "object") {
        if ("viewColumn" in location) {
          return this._terminalEditorService;
        } else if ("parentTerminal" in location) {
          return (await location.parentTerminal).target === TerminalLocation.Editor ? this._terminalEditorService : this._terminalGroupService;
        }
      } else {
        return this._terminalGroupService;
      }
    }
    return this;
  }
  async createTerminal(options) {
    if (this._terminalProfileService.availableProfiles.length === 0) {
      const isPtyTerminal = (options == null ? void 0 : options.config) && "customPtyImplementation" in options.config;
      const isLocalInRemoteTerminal = this._remoteAgentService.getConnection() && URI.isUri(options == null ? void 0 : options.cwd) && (options == null ? void 0 : options.cwd.scheme) === Schemas.vscodeFileResource;
      if (!isPtyTerminal && !isLocalInRemoteTerminal) {
        if (this._connectionState === 0) {
          mark(`code/terminal/willGetProfiles`);
        }
        await this._terminalProfileService.profilesReady;
        if (this._connectionState === 0) {
          mark(`code/terminal/didGetProfiles`);
        }
      }
    }
    const config = (options == null ? void 0 : options.config) || this._terminalProfileService.getDefaultProfile();
    const shellLaunchConfig = config && "extensionIdentifier" in config ? {} : this._terminalInstanceService.convertProfileToShellLaunchConfig(config || {});
    let contributedProfile = config && "extensionIdentifier" in config ? config : void 0;
    if (!contributedProfile && (!options || !options.config)) {
      contributedProfile = await this._terminalProfileService.getContributedDefaultProfile(shellLaunchConfig);
    }
    const splitActiveTerminal = typeof (options == null ? void 0 : options.location) === "object" && "splitActiveTerminal" in options.location ? options.location.splitActiveTerminal : typeof (options == null ? void 0 : options.location) === "object" ? "parentTerminal" in options.location : false;
    await this._resolveCwd(shellLaunchConfig, splitActiveTerminal, options);
    if (contributedProfile) {
      const resolvedLocation = await this.resolveLocation(options == null ? void 0 : options.location);
      let location2;
      if (splitActiveTerminal) {
        location2 = resolvedLocation === TerminalLocation.Editor ? { viewColumn: SIDE_GROUP } : { splitActiveTerminal: true };
      } else {
        location2 = typeof (options == null ? void 0 : options.location) === "object" && "viewColumn" in options.location ? options.location : resolvedLocation;
      }
      await this.createContributedTerminalProfile(contributedProfile.extensionIdentifier, contributedProfile.id, {
        icon: contributedProfile.icon,
        color: contributedProfile.color,
        location: location2
      });
      const instanceHost = resolvedLocation === TerminalLocation.Editor ? this._terminalEditorService : this._terminalGroupService;
      const instance = instanceHost.instances[instanceHost.instances.length - 1];
      await instance.focusWhenReady();
      this._terminalHasBeenCreated.set(true);
      return instance;
    }
    if (!shellLaunchConfig.customPtyImplementation && !this.isProcessSupportRegistered) {
      throw new Error("Could not create terminal when process support is not registered");
    }
    if (shellLaunchConfig.hideFromUser) {
      const instance = this._terminalInstanceService.createInstance(shellLaunchConfig, TerminalLocation.Panel);
      this._backgroundedTerminalInstances.push(instance);
      this._backgroundedTerminalDisposables.set(instance.instanceId, [
        instance.onDisposed(this._onDidDisposeInstance.fire, this._onDidDisposeInstance)
      ]);
      this._terminalHasBeenCreated.set(true);
      return instance;
    }
    this._evaluateLocalCwd(shellLaunchConfig);
    const location = await this.resolveLocation(options == null ? void 0 : options.location) || this.defaultLocation;
    const parent = await this._getSplitParent(options == null ? void 0 : options.location);
    this._terminalHasBeenCreated.set(true);
    if (parent) {
      return this._splitTerminal(shellLaunchConfig, location, parent);
    }
    return this._createTerminal(shellLaunchConfig, location, options);
  }
  async createDetachedXterm(options) {
    const ctor = await TerminalInstance.getXtermConstructor(this._keybindingService, this._contextKeyService);
    const instance = this._instantiationService.createInstance(XtermTerminal, ctor, this._configHelper, options.cols, options.rows, options.colorProvider, options.capabilities || new TerminalCapabilityStore(), "", void 0, false);
    if (options.readonly) {
      instance.raw.attachCustomKeyEventHandler(() => false);
    }
    this._detachedXterms.add(instance);
    instance.onDidDispose(() => this._detachedXterms.delete(instance));
    return instance;
  }
  async _resolveCwd(shellLaunchConfig, splitActiveTerminal, options) {
    const cwd = shellLaunchConfig.cwd;
    if (!cwd) {
      if (options == null ? void 0 : options.cwd) {
        shellLaunchConfig.cwd = options.cwd;
      } else if (splitActiveTerminal && (options == null ? void 0 : options.location)) {
        let parent = this.activeInstance;
        if (typeof options.location === "object" && "parentTerminal" in options.location) {
          parent = await options.location.parentTerminal;
        }
        if (!parent) {
          throw new Error("Cannot split without an active instance");
        }
        shellLaunchConfig.cwd = await getCwdForSplit(this.configHelper, parent, this._workspaceContextService.getWorkspace().folders, this._commandService);
      }
    }
  }
  _splitTerminal(shellLaunchConfig, location, parent) {
    let instance;
    if (typeof shellLaunchConfig.cwd !== "object" && typeof parent.shellLaunchConfig.cwd === "object") {
      shellLaunchConfig.cwd = URI.from({
        scheme: parent.shellLaunchConfig.cwd.scheme,
        authority: parent.shellLaunchConfig.cwd.authority,
        path: shellLaunchConfig.cwd || parent.shellLaunchConfig.cwd.path
      });
    }
    if (location === TerminalLocation.Editor || parent.target === TerminalLocation.Editor) {
      instance = this._terminalEditorService.splitInstance(parent, shellLaunchConfig);
    } else {
      const group = this._terminalGroupService.getGroupForInstance(parent);
      if (!group) {
        throw new Error(`Cannot split a terminal without a group ${parent}`);
      }
      shellLaunchConfig.parentTerminalId = parent.instanceId;
      instance = group.split(shellLaunchConfig);
    }
    this._addToReconnected(instance);
    return instance;
  }
  _addToReconnected(instance) {
    var _a2;
    if (!((_a2 = instance.reconnectionProperties) == null ? void 0 : _a2.ownerId)) {
      return;
    }
    const reconnectedTerminals = this._reconnectedTerminals.get(instance.reconnectionProperties.ownerId);
    if (reconnectedTerminals) {
      reconnectedTerminals.push(instance);
    } else {
      this._reconnectedTerminals.set(instance.reconnectionProperties.ownerId, [instance]);
    }
  }
  _createTerminal(shellLaunchConfig, location, options) {
    let instance;
    const editorOptions = this._getEditorOptions(options == null ? void 0 : options.location);
    if (location === TerminalLocation.Editor) {
      instance = this._terminalInstanceService.createInstance(shellLaunchConfig, TerminalLocation.Editor);
      this._terminalEditorService.openEditor(instance, editorOptions);
    } else {
      const group = this._terminalGroupService.createGroup(shellLaunchConfig);
      instance = group.terminalInstances[0];
    }
    this._addToReconnected(instance);
    return instance;
  }
  async resolveLocation(location) {
    var _a2, _b2;
    if (location && typeof location === "object") {
      if ("parentTerminal" in location) {
        const parentTerminal = await location.parentTerminal;
        return !parentTerminal.target ? TerminalLocation.Panel : parentTerminal.target;
      } else if ("viewColumn" in location) {
        return TerminalLocation.Editor;
      } else if ("splitActiveTerminal" in location) {
        return !((_a2 = this._activeInstance) == null ? void 0 : _a2.target) ? TerminalLocation.Panel : (_b2 = this._activeInstance) == null ? void 0 : _b2.target;
      }
    }
    return location;
  }
  async _getSplitParent(location) {
    if (location && typeof location === "object" && "parentTerminal" in location) {
      return location.parentTerminal;
    } else if (location && typeof location === "object" && "splitActiveTerminal" in location) {
      return this.activeInstance;
    }
    return void 0;
  }
  _getEditorOptions(location) {
    if (location && typeof location === "object" && "viewColumn" in location) {
      location.viewColumn = columnToEditorGroup(this._editorGroupsService, this._configurationService, location.viewColumn);
      return location;
    }
    return void 0;
  }
  _evaluateLocalCwd(shellLaunchConfig) {
    var _a2;
    if (typeof shellLaunchConfig.cwd !== "string" && ((_a2 = shellLaunchConfig.cwd) == null ? void 0 : _a2.scheme) === Schemas.file) {
      if (VirtualWorkspaceContext.getValue(this._contextKeyService)) {
        shellLaunchConfig.initialText = formatMessageForTerminal(localize(
          "localTerminalVirtualWorkspace",
          "This shell is open to a {0}local{1} folder, NOT to the virtual folder",
          "\x1B[3m",
          "\x1B[23m"
        ), { excludeLeadingNewLine: true, loudFormatting: true });
        shellLaunchConfig.type = "Local";
      } else if (this._remoteAgentService.getConnection()) {
        shellLaunchConfig.initialText = formatMessageForTerminal(localize(
          "localTerminalRemote",
          "This shell is running on your {0}local{1} machine, NOT on the connected remote machine",
          "\x1B[3m",
          "\x1B[23m"
        ), { excludeLeadingNewLine: true, loudFormatting: true });
        shellLaunchConfig.type = "Local";
      }
    }
  }
  _showBackgroundTerminal(instance) {
    this._backgroundedTerminalInstances.splice(this._backgroundedTerminalInstances.indexOf(instance), 1);
    const disposables = this._backgroundedTerminalDisposables.get(instance.instanceId);
    if (disposables) {
      dispose(disposables);
    }
    this._backgroundedTerminalDisposables.delete(instance.instanceId);
    instance.shellLaunchConfig.hideFromUser = false;
    this._terminalGroupService.createGroup(instance);
    if (this.instances.length === 1) {
      this._terminalGroupService.setActiveInstanceByIndex(0);
    }
    this._onDidChangeInstances.fire();
    this._onDidChangeGroups.fire();
  }
  async setContainers(panelContainer, terminalContainer) {
    this._configHelper.panelContainer = panelContainer;
    this._terminalGroupService.setContainer(terminalContainer);
  }
  getEditingTerminal() {
    return this._editingTerminal;
  }
  setEditingTerminal(instance) {
    this._editingTerminal = instance;
  }
};
TerminalService.__decorator = __decorate([
  debounce(500)
], TerminalService.prototype, "_saveState", null);
TerminalService.__decorator = __decorate([
  debounce(500)
], TerminalService.prototype, "_updateTitle", null);
TerminalService.__decorator = __decorate([
  debounce(500)
], TerminalService.prototype, "_updateIcon", null);
TerminalService = __decorate([
  __param(0, IContextKeyService),
  __param(1, ILifecycleService),
  __param(2, ITerminalLogService),
  __param(3, IDialogService),
  __param(4, IInstantiationService),
  __param(5, IRemoteAgentService),
  __param(6, IViewsService),
  __param(7, IConfigurationService),
  __param(8, IWorkbenchEnvironmentService),
  __param(9, ITerminalEditorService),
  __param(10, ITerminalGroupService),
  __param(11, ITerminalInstanceService),
  __param(12, IEditorGroupsService),
  __param(13, ITerminalProfileService),
  __param(14, IExtensionService),
  __param(15, INotificationService),
  __param(16, IWorkspaceContextService),
  __param(17, ICommandService),
  __param(18, IKeybindingService),
  __param(19, ITimerService)
], TerminalService);
let TerminalEditorStyle = class TerminalEditorStyle2 extends Themable {
  constructor(container, _terminalService, _themeService, _terminalProfileService, _editorService) {
    super(_themeService);
    this._terminalService = _terminalService;
    this._themeService = _themeService;
    this._terminalProfileService = _terminalProfileService;
    this._editorService = _editorService;
    this._registerListeners();
    this._styleElement = document.createElement("style");
    container.appendChild(this._styleElement);
    this._register(toDisposable(() => container.removeChild(this._styleElement)));
    this.updateStyles();
  }
  _registerListeners() {
    this._register(this._terminalService.onDidChangeInstanceIcon(() => this.updateStyles()));
    this._register(this._terminalService.onDidChangeInstanceColor(() => this.updateStyles()));
    this._register(this._terminalService.onDidCreateInstance(() => this.updateStyles()));
    this._register(this._editorService.onDidActiveEditorChange(() => {
      if (this._editorService.activeEditor instanceof TerminalEditorInput) {
        this.updateStyles();
      }
    }));
    this._register(this._editorService.onDidCloseEditor(() => {
      if (this._editorService.activeEditor instanceof TerminalEditorInput) {
        this.updateStyles();
      }
    }));
    this._register(this._terminalProfileService.onDidChangeAvailableProfiles(() => this.updateStyles()));
  }
  updateStyles() {
    var _a2;
    super.updateStyles();
    const colorTheme = this._themeService.getColorTheme();
    let css2 = "";
    const productIconTheme = this._themeService.getProductIconTheme();
    for (const instance of this._terminalService.instances) {
      const icon = instance.icon;
      if (!icon) {
        continue;
      }
      let uri = void 0;
      if (icon instanceof URI) {
        uri = icon;
      } else if (icon instanceof Object && "light" in icon && "dark" in icon) {
        uri = colorTheme.type === ColorScheme.LIGHT ? icon.light : icon.dark;
      }
      const iconClasses = getUriClasses(instance, colorTheme.type);
      if (uri instanceof URI && iconClasses && iconClasses.length > 1) {
        css2 += `.monaco-workbench .terminal-tab.${iconClasses[0]}::before{background-image: ${asCSSUrl(uri)};}`;
      }
      if (ThemeIcon.isThemeIcon(icon)) {
        const iconRegistry = getIconRegistry();
        const iconContribution = iconRegistry.getIcon(icon.id);
        if (iconContribution) {
          const def = productIconTheme.getIcon(iconContribution);
          if (def) {
            css2 += `.monaco-workbench .terminal-tab.codicon-${icon.id}::before{content: '${def.fontCharacter}' !important; font-family: ${asCSSPropertyValue(((_a2 = def.font) == null ? void 0 : _a2.id) ?? "codicon")} !important;}`;
          }
        }
      }
    }
    const iconForegroundColor = colorTheme.getColor(iconForeground);
    if (iconForegroundColor) {
      css2 += `.monaco-workbench .show-file-icons .file-icon.terminal-tab::before { color: ${iconForegroundColor}; }`;
    }
    css2 += getColorStyleContent(colorTheme, true);
    this._styleElement.textContent = css2;
  }
};
TerminalEditorStyle = __decorate([
  __param(1, ITerminalService),
  __param(2, IThemeService),
  __param(3, ITerminalProfileService),
  __param(4, IEditorService)
], TerminalEditorStyle);
let TerminalEditorService = class TerminalEditorService2 extends Disposable {
  constructor(_editorService, _editorGroupsService, _terminalInstanceService, _instantiationService, lifecycleService, contextKeyService) {
    super();
    this._editorService = _editorService;
    this._editorGroupsService = _editorGroupsService;
    this._terminalInstanceService = _terminalInstanceService;
    this._instantiationService = _instantiationService;
    this.instances = [];
    this._activeInstanceIndex = -1;
    this._isShuttingDown = false;
    this._editorInputs = /* @__PURE__ */ new Map();
    this._instanceDisposables = /* @__PURE__ */ new Map();
    this._onDidDisposeInstance = new Emitter();
    this.onDidDisposeInstance = this._onDidDisposeInstance.event;
    this._onDidFocusInstance = new Emitter();
    this.onDidFocusInstance = this._onDidFocusInstance.event;
    this._onDidChangeInstanceCapability = new Emitter();
    this.onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event;
    this._onDidChangeActiveInstance = new Emitter();
    this.onDidChangeActiveInstance = this._onDidChangeActiveInstance.event;
    this._onDidChangeInstances = new Emitter();
    this.onDidChangeInstances = this._onDidChangeInstances.event;
    this._terminalEditorActive = TerminalContextKeys.terminalEditorActive.bindTo(contextKeyService);
    this._register(toDisposable(() => {
      for (const d of this._instanceDisposables.values()) {
        dispose(d);
      }
    }));
    this._register(lifecycleService.onWillShutdown(() => this._isShuttingDown = true));
    this._register(this._editorService.onDidActiveEditorChange(() => {
      var _a2;
      const activeEditor = this._editorService.activeEditor;
      const instance = activeEditor instanceof TerminalEditorInput ? activeEditor == null ? void 0 : activeEditor.terminalInstance : void 0;
      const terminalEditorActive = !!instance && activeEditor instanceof TerminalEditorInput;
      this._terminalEditorActive.set(terminalEditorActive);
      if (terminalEditorActive) {
        activeEditor == null ? void 0 : activeEditor.setGroup((_a2 = this._editorService.activeEditorPane) == null ? void 0 : _a2.group);
        this.setActiveInstance(instance);
      } else {
        for (const instance2 of this.instances) {
          instance2.resetFocusContextKey();
        }
      }
    }));
    this._register(this._editorService.onDidVisibleEditorsChange(() => {
      const knownIds = this.instances.map((i) => i.instanceId);
      const terminalEditors = this._getActiveTerminalEditors();
      const unknownEditor = terminalEditors.find((input) => {
        var _a2;
        const inputId = input instanceof TerminalEditorInput ? (_a2 = input.terminalInstance) == null ? void 0 : _a2.instanceId : void 0;
        if (inputId === void 0) {
          return false;
        }
        return !knownIds.includes(inputId);
      });
      if (unknownEditor instanceof TerminalEditorInput && unknownEditor.terminalInstance) {
        this._editorInputs.set(unknownEditor.terminalInstance.resource.path, unknownEditor);
        this.instances.push(unknownEditor.terminalInstance);
      }
    }));
    this._register(this._editorService.onDidCloseEditor((e) => {
      const instance = e.editor instanceof TerminalEditorInput ? e.editor.terminalInstance : void 0;
      if (instance) {
        const instanceIndex = this.instances.findIndex((e2) => e2 === instance);
        if (instanceIndex !== -1) {
          const wasActiveInstance = this.instances[instanceIndex] === this.activeInstance;
          this._removeInstance(instance);
          if (wasActiveInstance) {
            this.setActiveInstance(void 0);
          }
        }
      }
    }));
  }
  _getActiveTerminalEditors() {
    return this._editorService.visibleEditors.filter((e) => {
      var _a2;
      return e instanceof TerminalEditorInput && ((_a2 = e.terminalInstance) == null ? void 0 : _a2.instanceId);
    });
  }
  get activeInstance() {
    if (this.instances.length === 0 || this._activeInstanceIndex === -1) {
      return void 0;
    }
    return this.instances[this._activeInstanceIndex];
  }
  setActiveInstance(instance) {
    this._activeInstanceIndex = instance ? this.instances.findIndex((e) => e === instance) : -1;
    this._onDidChangeActiveInstance.fire(this.activeInstance);
  }
  async focusActiveInstance() {
    var _a2;
    return (_a2 = this.activeInstance) == null ? void 0 : _a2.focusWhenReady(true);
  }
  async openEditor(instance, editorOptions) {
    var _a2, _b2;
    const resource = this.resolveResource(instance);
    if (resource) {
      await ((_a2 = this._activeOpenEditorRequest) == null ? void 0 : _a2.promise);
      this._activeOpenEditorRequest = {
        instanceId: instance.instanceId,
        promise: this._editorService.openEditor({
          resource,
          description: instance.description || instance.shellLaunchConfig.type,
          options: {
            pinned: true,
            forceReload: true,
            preserveFocus: editorOptions == null ? void 0 : editorOptions.preserveFocus
          }
        }, (editorOptions == null ? void 0 : editorOptions.viewColumn) ?? ACTIVE_GROUP)
      };
      await ((_b2 = this._activeOpenEditorRequest) == null ? void 0 : _b2.promise);
      this._activeOpenEditorRequest = void 0;
    }
  }
  resolveResource(instance) {
    const resource = instance.resource;
    const inputKey = resource.path;
    const cachedEditor = this._editorInputs.get(inputKey);
    if (cachedEditor) {
      return cachedEditor.resource;
    }
    instance.target = TerminalLocation.Editor;
    const input = this._instantiationService.createInstance(TerminalEditorInput, resource, instance);
    this._registerInstance(inputKey, input, instance);
    return input.resource;
  }
  getInputFromResource(resource) {
    const input = this._editorInputs.get(resource.path);
    if (!input) {
      throw new Error(`Could not get input from resource: ${resource.path}`);
    }
    return input;
  }
  _registerInstance(inputKey, input, instance) {
    this._editorInputs.set(inputKey, input);
    this._instanceDisposables.set(inputKey, [
      instance.onDidFocus(this._onDidFocusInstance.fire, this._onDidFocusInstance),
      instance.onDisposed(this._onDidDisposeInstance.fire, this._onDidDisposeInstance),
      instance.capabilities.onDidAddCapability(() => this._onDidChangeInstanceCapability.fire(instance)),
      instance.capabilities.onDidRemoveCapability(() => this._onDidChangeInstanceCapability.fire(instance))
    ]);
    this.instances.push(instance);
    this._onDidChangeInstances.fire();
  }
  _removeInstance(instance) {
    const inputKey = instance.resource.path;
    this._editorInputs.delete(inputKey);
    const instanceIndex = this.instances.findIndex((e) => e === instance);
    if (instanceIndex !== -1) {
      this.instances.splice(instanceIndex, 1);
    }
    const disposables = this._instanceDisposables.get(inputKey);
    this._instanceDisposables.delete(inputKey);
    if (disposables) {
      dispose(disposables);
    }
    this._onDidChangeInstances.fire();
  }
  getInstanceFromResource(resource) {
    return getInstanceFromResource(this.instances, resource);
  }
  splitInstance(instanceToSplit, shellLaunchConfig = {}) {
    var _a2;
    if (instanceToSplit.target === TerminalLocation.Editor) {
      const group = (_a2 = this._editorInputs.get(instanceToSplit.resource.path)) == null ? void 0 : _a2.group;
      if (group) {
        this._editorGroupsService.activateGroup(group);
      }
    }
    const instance = this._terminalInstanceService.createInstance(shellLaunchConfig, TerminalLocation.Editor);
    const resource = this.resolveResource(instance);
    if (resource) {
      this._editorService.openEditor({
        resource: URI.revive(resource),
        description: instance.description,
        options: {
          pinned: true,
          forceReload: true
        }
      }, SIDE_GROUP);
    }
    return instance;
  }
  reviveInput(deserializedInput) {
    if ("pid" in deserializedInput) {
      const newDeserializedInput = { ...deserializedInput, findRevivedId: true };
      const instance = this._terminalInstanceService.createInstance({ attachPersistentProcess: newDeserializedInput }, TerminalLocation.Editor);
      const input = this._instantiationService.createInstance(TerminalEditorInput, instance.resource, instance);
      this._registerInstance(instance.resource.path, input, instance);
      return input;
    } else {
      throw new Error(`Could not revive terminal editor input, ${deserializedInput}`);
    }
  }
  detachInstance(instance) {
    const inputKey = instance.resource.path;
    const editorInput = this._editorInputs.get(inputKey);
    editorInput == null ? void 0 : editorInput.detachInstance();
    this._removeInstance(instance);
    if (!this._isShuttingDown) {
      editorInput == null ? void 0 : editorInput.dispose();
    }
  }
  async revealActiveEditor(preserveFocus) {
    var _a2;
    const instance = this.activeInstance;
    if (!instance) {
      return;
    }
    if (((_a2 = this._activeOpenEditorRequest) == null ? void 0 : _a2.instanceId) === instance.instanceId) {
      return;
    }
    const editorInput = this._editorInputs.get(instance.resource.path);
    this._editorService.openEditor(editorInput, {
      pinned: true,
      forceReload: true,
      preserveFocus,
      activation: EditorActivation.PRESERVE
    });
  }
};
TerminalEditorService = __decorate([
  __param(0, IEditorService),
  __param(1, IEditorGroupsService),
  __param(2, ITerminalInstanceService),
  __param(3, IInstantiationService),
  __param(4, ILifecycleService),
  __param(5, IContextKeyService)
], TerminalEditorService);
let SplitPaneContainer = class SplitPaneContainer2 extends Disposable {
  get onDidChange() {
    return this._onDidChange;
  }
  constructor(_container, orientation, _layoutService) {
    super();
    this._container = _container;
    this.orientation = orientation;
    this._layoutService = _layoutService;
    this._splitViewDisposables = this._register(new DisposableStore());
    this._children = [];
    this._terminalToPane = /* @__PURE__ */ new Map();
    this._onDidChange = Event.None;
    this._width = this._container.offsetWidth;
    this._height = this._container.offsetHeight;
    this._createSplitView();
    this._splitView.layout(this.orientation === 1 ? this._width : this._height);
  }
  _createSplitView() {
    this._splitView = new SplitView(this._container, { orientation: this.orientation });
    this._splitViewDisposables.clear();
    this._splitViewDisposables.add(this._splitView.onDidSashReset(() => this._splitView.distributeViewSizes()));
  }
  split(instance, index) {
    this._addChild(instance, index);
  }
  resizePane(index, direction, amount, part) {
    const isHorizontal = direction === 0 || direction === 1;
    if (isHorizontal && this.orientation !== 1 || !isHorizontal && this.orientation !== 0) {
      if (this.orientation === 1 && direction === 3 || this.orientation === 0 && direction === 1) {
        amount *= -1;
      }
      this._layoutService.resizePart(part, amount, amount);
      return;
    }
    if (this._children.length <= 1) {
      return;
    }
    const sizes = [];
    for (let i = 0; i < this._splitView.length; i++) {
      sizes.push(this._splitView.getViewSize(i));
    }
    const isSizingEndPane = index !== this._children.length - 1;
    const indexToChange = isSizingEndPane ? index + 1 : index - 1;
    if (isSizingEndPane && direction === 0) {
      amount *= -1;
    } else if (!isSizingEndPane && direction === 1) {
      amount *= -1;
    } else if (isSizingEndPane && direction === 2) {
      amount *= -1;
    } else if (!isSizingEndPane && direction === 3) {
      amount *= -1;
    }
    if (sizes[index] + amount < 80) {
      amount = 80 - sizes[index];
    } else if (sizes[indexToChange] - amount < 80) {
      amount = sizes[indexToChange] - 80;
    }
    sizes[index] += amount;
    sizes[indexToChange] -= amount;
    for (let i = 0; i < this._splitView.length - 1; i++) {
      this._splitView.resizeView(i, sizes[i]);
    }
  }
  resizePanes(relativeSizes) {
    if (this._children.length <= 1) {
      return;
    }
    relativeSizes[relativeSizes.length - 1] += 1 - relativeSizes.reduce((totalValue, currentValue) => totalValue + currentValue, 0);
    let totalSize = 0;
    for (let i = 0; i < this._splitView.length; i++) {
      totalSize += this._splitView.getViewSize(i);
    }
    for (let i = 0; i < this._splitView.length; i++) {
      this._splitView.resizeView(i, totalSize * relativeSizes[i]);
    }
  }
  getPaneSize(instance) {
    const paneForInstance = this._terminalToPane.get(instance);
    if (!paneForInstance) {
      return 0;
    }
    const index = this._children.indexOf(paneForInstance);
    return this._splitView.getViewSize(index);
  }
  _addChild(instance, index) {
    const child = new SplitPane(
      instance,
      this.orientation === 1 ? this._height : this._width
    );
    child.orientation = this.orientation;
    if (typeof index === "number") {
      this._children.splice(index, 0, child);
    } else {
      this._children.push(child);
    }
    this._terminalToPane.set(instance, this._children[this._children.indexOf(child)]);
    this._withDisabledLayout(() => this._splitView.addView(child, Sizing.Distribute, index));
    this.layout(this._width, this._height);
    this._onDidChange = Event.any(...this._children.map((c) => c.onDidChange));
  }
  remove(instance) {
    let index = null;
    for (let i = 0; i < this._children.length; i++) {
      if (this._children[i].instance === instance) {
        index = i;
      }
    }
    if (index !== null) {
      this._children.splice(index, 1);
      this._terminalToPane.delete(instance);
      this._splitView.removeView(index, Sizing.Distribute);
      instance.detachFromElement();
    }
  }
  layout(width, height) {
    this._width = width;
    this._height = height;
    if (this.orientation === 1) {
      this._children.forEach((c) => c.orthogonalLayout(height));
      this._splitView.layout(width);
    } else {
      this._children.forEach((c) => c.orthogonalLayout(width));
      this._splitView.layout(height);
    }
  }
  setOrientation(orientation) {
    if (this.orientation === orientation) {
      return;
    }
    this.orientation = orientation;
    while (this._container.children.length > 0) {
      this._container.removeChild(this._container.children[0]);
    }
    this._splitViewDisposables.clear();
    this._splitView.dispose();
    this._createSplitView();
    this._withDisabledLayout(() => {
      this._children.forEach((child) => {
        child.orientation = orientation;
        this._splitView.addView(child, 1);
      });
    });
  }
  _withDisabledLayout(innerFunction) {
    this._children.forEach((c) => c.instance.disableLayout = true);
    innerFunction();
    this._children.forEach((c) => c.instance.disableLayout = false);
  }
};
SplitPaneContainer = __decorate([
  __param(2, IWorkbenchLayoutService)
], SplitPaneContainer);
class SplitPane {
  get onDidChange() {
    return this._onDidChange;
  }
  constructor(instance, orthogonalSize) {
    this.instance = instance;
    this.orthogonalSize = orthogonalSize;
    this.minimumSize = 80;
    this.maximumSize = Number.MAX_VALUE;
    this._onDidChange = Event.None;
    this.element = document.createElement("div");
    this.element.className = "terminal-split-pane";
    this.instance.attachToElement(this.element);
  }
  layout(size) {
    if (!size || !this.orthogonalSize) {
      return;
    }
    if (this.orientation === 0) {
      this.instance.layout({ width: this.orthogonalSize, height: size });
    } else {
      this.instance.layout({ width: size, height: this.orthogonalSize });
    }
  }
  orthogonalLayout(size) {
    this.orthogonalSize = size;
  }
}
let TerminalGroup = class TerminalGroup2 extends Disposable {
  get terminalInstances() {
    return this._terminalInstances;
  }
  constructor(_container, shellLaunchConfigOrInstance, _terminalService, _terminalInstanceService, _layoutService, _viewDescriptorService, _instantiationService) {
    super();
    this._container = _container;
    this._terminalService = _terminalService;
    this._terminalInstanceService = _terminalInstanceService;
    this._layoutService = _layoutService;
    this._viewDescriptorService = _viewDescriptorService;
    this._instantiationService = _instantiationService;
    this._terminalInstances = [];
    this._panelPosition = 2;
    this._terminalLocation = 1;
    this._instanceDisposables = /* @__PURE__ */ new Map();
    this._activeInstanceIndex = -1;
    this._onDidDisposeInstance = this._register(new Emitter());
    this.onDidDisposeInstance = this._onDidDisposeInstance.event;
    this._onDidFocusInstance = this._register(new Emitter());
    this.onDidFocusInstance = this._onDidFocusInstance.event;
    this._onDidChangeInstanceCapability = this._register(new Emitter());
    this.onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event;
    this._onDisposed = this._register(new Emitter());
    this.onDisposed = this._onDisposed.event;
    this._onInstancesChanged = this._register(new Emitter());
    this.onInstancesChanged = this._onInstancesChanged.event;
    this._onDidChangeActiveInstance = new Emitter();
    this.onDidChangeActiveInstance = this._onDidChangeActiveInstance.event;
    this._onPanelOrientationChanged = new Emitter();
    this.onPanelOrientationChanged = this._onPanelOrientationChanged.event;
    if (shellLaunchConfigOrInstance) {
      this.addInstance(shellLaunchConfigOrInstance);
    }
    if (this._container) {
      this.attachToElement(this._container);
    }
    this._onPanelOrientationChanged.fire(this._terminalLocation === 1 && this._panelPosition === 2 ? 1 : 0);
  }
  addInstance(shellLaunchConfigOrInstance, parentTerminalId) {
    let instance;
    const parentIndex = parentTerminalId ? this._terminalInstances.findIndex((t) => t.instanceId === parentTerminalId) : this._activeInstanceIndex;
    if ("instanceId" in shellLaunchConfigOrInstance) {
      instance = shellLaunchConfigOrInstance;
    } else {
      instance = this._terminalInstanceService.createInstance(shellLaunchConfigOrInstance, TerminalLocation.Panel);
    }
    if (this._terminalInstances.length === 0) {
      this._terminalInstances.push(instance);
      this._activeInstanceIndex = 0;
    } else {
      this._terminalInstances.splice(parentIndex + 1, 0, instance);
    }
    this._initInstanceListeners(instance);
    if (this._splitPaneContainer) {
      this._splitPaneContainer.split(instance, parentIndex + 1);
    }
    this._onInstancesChanged.fire();
  }
  dispose() {
    super.dispose();
    if (this._container && this._groupElement) {
      this._container.removeChild(this._groupElement);
      this._groupElement = void 0;
    }
    this._terminalInstances = [];
    this._onInstancesChanged.fire();
  }
  get activeInstance() {
    if (this._terminalInstances.length === 0) {
      return void 0;
    }
    return this._terminalInstances[this._activeInstanceIndex];
  }
  getLayoutInfo(isActive) {
    const instances = this.terminalInstances.filter((instance) => typeof instance.persistentProcessId === "number" && instance.shouldPersist);
    const totalSize = instances.map((t) => {
      var _a2;
      return ((_a2 = this._splitPaneContainer) == null ? void 0 : _a2.getPaneSize(t)) || 0;
    }).reduce((total, size) => total += size, 0);
    return {
      isActive,
      activePersistentProcessId: this.activeInstance ? this.activeInstance.persistentProcessId : void 0,
      terminals: instances.map((t) => {
        return {
          relativeSize: totalSize > 0 ? this._splitPaneContainer.getPaneSize(t) / totalSize : 0,
          terminal: t.persistentProcessId || 0
        };
      })
    };
  }
  _initInstanceListeners(instance) {
    this._instanceDisposables.set(instance.instanceId, [
      instance.onDisposed((instance2) => {
        this._onDidDisposeInstance.fire(instance2);
        this._handleOnDidDisposeInstance(instance2);
      }),
      instance.onDidFocus((instance2) => {
        this._setActiveInstance(instance2);
        this._onDidFocusInstance.fire(instance2);
      }),
      instance.capabilities.onDidAddCapability(() => this._onDidChangeInstanceCapability.fire(instance)),
      instance.capabilities.onDidRemoveCapability(() => this._onDidChangeInstanceCapability.fire(instance))
    ]);
  }
  _handleOnDidDisposeInstance(instance) {
    this._removeInstance(instance);
  }
  removeInstance(instance) {
    this._removeInstance(instance);
    const disposables = this._instanceDisposables.get(instance.instanceId);
    if (disposables) {
      dispose(disposables);
      this._instanceDisposables.delete(instance.instanceId);
    }
  }
  _removeInstance(instance) {
    var _a2, _b2;
    const index = this._terminalInstances.indexOf(instance);
    if (index === -1) {
      return;
    }
    const wasActiveInstance = instance === this.activeInstance;
    this._terminalInstances.splice(index, 1);
    if (wasActiveInstance && this._terminalInstances.length > 0) {
      const newIndex = index < this._terminalInstances.length ? index : this._terminalInstances.length - 1;
      this.setActiveInstanceByIndex(newIndex);
      (_a2 = this.activeInstance) == null ? void 0 : _a2.focus(true);
    } else if (index < this._activeInstanceIndex) {
      this._activeInstanceIndex--;
    }
    (_b2 = this._splitPaneContainer) == null ? void 0 : _b2.remove(instance);
    if (this._terminalInstances.length === 0) {
      this._onDisposed.fire(this);
      this.dispose();
    } else {
      this._onInstancesChanged.fire();
    }
  }
  moveInstance(instance, index) {
    const sourceIndex = this.terminalInstances.indexOf(instance);
    if (sourceIndex === -1) {
      return;
    }
    this._terminalInstances.splice(sourceIndex, 1);
    this._terminalInstances.splice(index, 0, instance);
    if (this._splitPaneContainer) {
      this._splitPaneContainer.remove(instance);
      this._splitPaneContainer.split(instance, index);
    }
    this._onInstancesChanged.fire();
  }
  _setActiveInstance(instance) {
    this.setActiveInstanceByIndex(this._getIndexFromId(instance.instanceId));
  }
  _getIndexFromId(terminalId) {
    let terminalIndex = -1;
    this.terminalInstances.forEach((terminalInstance, i) => {
      if (terminalInstance.instanceId === terminalId) {
        terminalIndex = i;
      }
    });
    if (terminalIndex === -1) {
      throw new Error(`Terminal with ID ${terminalId} does not exist (has it already been disposed?)`);
    }
    return terminalIndex;
  }
  setActiveInstanceByIndex(index, force) {
    if (index < 0 || index >= this._terminalInstances.length) {
      return;
    }
    const oldActiveInstance = this.activeInstance;
    this._activeInstanceIndex = index;
    if (oldActiveInstance !== this.activeInstance || force) {
      this._onInstancesChanged.fire();
      this._onDidChangeActiveInstance.fire(this.activeInstance);
    }
  }
  attachToElement(element) {
    this._container = element;
    if (!this._groupElement) {
      this._groupElement = document.createElement("div");
      this._groupElement.classList.add("terminal-group");
    }
    this._container.appendChild(this._groupElement);
    if (!this._splitPaneContainer) {
      this._panelPosition = this._layoutService.getPanelPosition();
      this._terminalLocation = this._viewDescriptorService.getViewLocationById(TERMINAL_VIEW_ID);
      const orientation = this._terminalLocation === 1 && this._panelPosition === 2 ? 1 : 0;
      this._splitPaneContainer = this._instantiationService.createInstance(SplitPaneContainer, this._groupElement, orientation);
      this.terminalInstances.forEach((instance) => this._splitPaneContainer.split(instance, this._activeInstanceIndex + 1));
      if (this._initialRelativeSizes) {
        this.resizePanes(this._initialRelativeSizes);
        this._initialRelativeSizes = void 0;
      }
    }
  }
  get title() {
    if (this._terminalInstances.length === 0) {
      return "";
    }
    let title = this.terminalInstances[0].title + this._getBellTitle(this.terminalInstances[0]);
    if (this.terminalInstances[0].description) {
      title += ` (${this.terminalInstances[0].description})`;
    }
    for (let i = 1; i < this.terminalInstances.length; i++) {
      const instance = this.terminalInstances[i];
      if (instance.title) {
        title += `, ${instance.title + this._getBellTitle(instance)}`;
        if (instance.description) {
          title += ` (${instance.description})`;
        }
      }
    }
    return title;
  }
  _getBellTitle(instance) {
    if (this._terminalService.configHelper.config.enableBell && instance.statusList.statuses.some((e) => e.id === "bell")) {
      return "*";
    }
    return "";
  }
  setVisible(visible) {
    if (this._groupElement) {
      this._groupElement.style.display = visible ? "" : "none";
    }
    this.terminalInstances.forEach((i) => i.setVisible(visible));
  }
  split(shellLaunchConfig) {
    const instance = this._terminalInstanceService.createInstance(shellLaunchConfig, TerminalLocation.Panel);
    this.addInstance(instance, shellLaunchConfig.parentTerminalId);
    this._setActiveInstance(instance);
    return instance;
  }
  addDisposable(disposable) {
    this._register(disposable);
  }
  layout(width, height) {
    if (this._splitPaneContainer) {
      const newPanelPosition = this._layoutService.getPanelPosition();
      const newTerminalLocation = this._viewDescriptorService.getViewLocationById(TERMINAL_VIEW_ID);
      const terminalPositionChanged = newPanelPosition !== this._panelPosition || newTerminalLocation !== this._terminalLocation;
      if (terminalPositionChanged) {
        const newOrientation = newTerminalLocation === 1 && newPanelPosition === 2 ? 1 : 0;
        this._splitPaneContainer.setOrientation(newOrientation);
        this._panelPosition = newPanelPosition;
        this._terminalLocation = newTerminalLocation;
        this._onPanelOrientationChanged.fire(this._splitPaneContainer.orientation);
      }
      this._splitPaneContainer.layout(width, height);
    }
  }
  focusPreviousPane() {
    const newIndex = this._activeInstanceIndex === 0 ? this._terminalInstances.length - 1 : this._activeInstanceIndex - 1;
    this.setActiveInstanceByIndex(newIndex);
  }
  focusNextPane() {
    const newIndex = this._activeInstanceIndex === this._terminalInstances.length - 1 ? 0 : this._activeInstanceIndex + 1;
    this.setActiveInstanceByIndex(newIndex);
  }
  resizePane(direction) {
    if (!this._splitPaneContainer) {
      return;
    }
    const isHorizontal = direction === 0 || direction === 1;
    const font = this._terminalService.configHelper.getFont();
    const charSize = isHorizontal ? font.charWidth : font.charHeight;
    if (charSize) {
      this._splitPaneContainer.resizePane(this._activeInstanceIndex, direction, charSize * 4, getPartByLocation(this._terminalLocation));
    }
  }
  resizePanes(relativeSizes) {
    if (!this._splitPaneContainer) {
      this._initialRelativeSizes = relativeSizes;
      return;
    }
    this._splitPaneContainer.resizePanes(relativeSizes);
  }
};
TerminalGroup = __decorate([
  __param(2, ITerminalService),
  __param(3, ITerminalInstanceService),
  __param(4, IWorkbenchLayoutService),
  __param(5, IViewDescriptorService),
  __param(6, IInstantiationService)
], TerminalGroup);
let TerminalGroupService = class TerminalGroupService2 extends Disposable {
  get instances() {
    return this.groups.reduce((p, c) => p.concat(c.terminalInstances), []);
  }
  constructor(_contextKeyService, _instantiationService, _viewsService, _viewDescriptorService, _configurationService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._viewsService = _viewsService;
    this._viewDescriptorService = _viewDescriptorService;
    this._configurationService = _configurationService;
    this.groups = [];
    this.activeGroupIndex = -1;
    this._onDidChangeActiveGroup = new Emitter();
    this.onDidChangeActiveGroup = this._onDidChangeActiveGroup.event;
    this._onDidDisposeGroup = new Emitter();
    this.onDidDisposeGroup = this._onDidDisposeGroup.event;
    this._onDidChangeGroups = new Emitter();
    this.onDidChangeGroups = this._onDidChangeGroups.event;
    this._onDidShow = new Emitter();
    this.onDidShow = this._onDidShow.event;
    this._onDidDisposeInstance = new Emitter();
    this.onDidDisposeInstance = this._onDidDisposeInstance.event;
    this._onDidFocusInstance = new Emitter();
    this.onDidFocusInstance = this._onDidFocusInstance.event;
    this._onDidChangeActiveInstance = new Emitter();
    this.onDidChangeActiveInstance = this._onDidChangeActiveInstance.event;
    this._onDidChangeInstances = new Emitter();
    this.onDidChangeInstances = this._onDidChangeInstances.event;
    this._onDidChangeInstanceCapability = new Emitter();
    this.onDidChangeInstanceCapability = this._onDidChangeInstanceCapability.event;
    this._onDidChangePanelOrientation = new Emitter();
    this.onDidChangePanelOrientation = this._onDidChangePanelOrientation.event;
    this.onDidDisposeGroup((group) => this._removeGroup(group));
    this._terminalGroupCountContextKey = TerminalContextKeys.groupCount.bindTo(this._contextKeyService);
    this.onDidChangeGroups(() => this._terminalGroupCountContextKey.set(this.groups.length));
    Event.any(this.onDidChangeActiveGroup, this.onDidChangeInstances)(() => this.updateVisibility());
  }
  hidePanel() {
    const panel = this._viewDescriptorService.getViewContainerByViewId(TERMINAL_VIEW_ID);
    if (panel && this._viewDescriptorService.getViewContainerModel(panel).activeViewDescriptors.length === 1) {
      this._viewsService.closeView(TERMINAL_VIEW_ID);
      TerminalContextKeys.tabsMouse.bindTo(this._contextKeyService).set(false);
    }
  }
  showTabs() {
    this._configurationService.updateValue("terminal.integrated.tabs.enabled", true);
  }
  get activeGroup() {
    if (this.activeGroupIndex < 0 || this.activeGroupIndex >= this.groups.length) {
      return void 0;
    }
    return this.groups[this.activeGroupIndex];
  }
  set activeGroup(value) {
    if (value === void 0) {
      return;
    }
    const index = this.groups.findIndex((e) => e === value);
    this.setActiveGroupByIndex(index);
  }
  get activeInstance() {
    var _a2;
    return (_a2 = this.activeGroup) == null ? void 0 : _a2.activeInstance;
  }
  setActiveInstance(instance) {
    this.setActiveInstanceByIndex(this._getIndexFromId(instance.instanceId));
  }
  _getIndexFromId(terminalId) {
    const terminalIndex = this.instances.findIndex((e) => e.instanceId === terminalId);
    if (terminalIndex === -1) {
      throw new Error(`Terminal with ID ${terminalId} does not exist (has it already been disposed?)`);
    }
    return terminalIndex;
  }
  setContainer(container) {
    this._container = container;
    this.groups.forEach((group) => group.attachToElement(container));
  }
  async focusTabs() {
    var _a2;
    if (this.instances.length === 0) {
      return;
    }
    await this.showPanel(true);
    const pane = this._viewsService.getActiveViewWithId(TERMINAL_VIEW_ID);
    (_a2 = pane == null ? void 0 : pane.terminalTabbedView) == null ? void 0 : _a2.focusTabs();
  }
  async focusHover() {
    var _a2;
    if (this.instances.length === 0) {
      return;
    }
    const pane = this._viewsService.getActiveViewWithId(TERMINAL_VIEW_ID);
    (_a2 = pane == null ? void 0 : pane.terminalTabbedView) == null ? void 0 : _a2.focusHover();
  }
  async focusActiveInstance() {
    return this.showPanel(true);
  }
  createGroup(slcOrInstance) {
    const group = this._instantiationService.createInstance(TerminalGroup, this._container, slcOrInstance);
    group.onPanelOrientationChanged((orientation) => this._onDidChangePanelOrientation.fire(orientation));
    this.groups.push(group);
    group.addDisposable(group.onDidDisposeInstance(this._onDidDisposeInstance.fire, this._onDidDisposeInstance));
    group.addDisposable(group.onDidFocusInstance(this._onDidFocusInstance.fire, this._onDidFocusInstance));
    group.addDisposable(group.onDidChangeActiveInstance((e) => {
      if (group === this.activeGroup) {
        this._onDidChangeActiveInstance.fire(e);
      }
    }));
    group.addDisposable(group.onDidChangeInstanceCapability(this._onDidChangeInstanceCapability.fire, this._onDidChangeInstanceCapability));
    group.addDisposable(group.onInstancesChanged(this._onDidChangeInstances.fire, this._onDidChangeInstances));
    group.addDisposable(group.onDisposed(this._onDidDisposeGroup.fire, this._onDidDisposeGroup));
    if (group.terminalInstances.length > 0) {
      this._onDidChangeInstances.fire();
    }
    if (this.instances.length === 1) {
      this.setActiveInstanceByIndex(0);
    }
    this._onDidChangeGroups.fire();
    return group;
  }
  async showPanel(focus) {
    const pane = this._viewsService.getActiveViewWithId(TERMINAL_VIEW_ID) ?? await this._viewsService.openView(TERMINAL_VIEW_ID, focus);
    pane == null ? void 0 : pane.setExpanded(true);
    if (focus) {
      await timeout(0);
      const instance = this.activeInstance;
      if (instance) {
        if (pane && !pane.isVisible()) {
          await this._viewsService.openView(TERMINAL_VIEW_ID, focus);
        }
        await instance.focusWhenReady(true);
      }
    }
    this._onDidShow.fire();
  }
  getInstanceFromResource(resource) {
    return getInstanceFromResource(this.instances, resource);
  }
  _removeGroup(group) {
    var _a2;
    const activeGroup = this.activeGroup;
    const wasActiveGroup = group === activeGroup;
    const index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
      this._onDidChangeGroups.fire();
    }
    if (wasActiveGroup) {
      if (this.groups.length > 0) {
        const newIndex = index < this.groups.length ? index : this.groups.length - 1;
        this.setActiveGroupByIndex(newIndex, true);
        (_a2 = this.activeInstance) == null ? void 0 : _a2.focus(true);
      }
    } else {
      if (this.activeGroupIndex > index) {
        this.setActiveGroupByIndex(this.activeGroupIndex - 1);
      }
    }
    if (this.activeGroupIndex >= this.groups.length) {
      this.setActiveGroupByIndex(this.groups.length - 1);
    }
    this._onDidChangeInstances.fire();
    this._onDidChangeGroups.fire();
    if (wasActiveGroup) {
      this._onDidChangeActiveGroup.fire(this.activeGroup);
      this._onDidChangeActiveInstance.fire(this.activeInstance);
    }
  }
  setActiveGroupByIndex(index, force) {
    if (index === -1 && this.groups.length === 0) {
      if (this.activeGroupIndex !== -1) {
        this.activeGroupIndex = -1;
        this._onDidChangeActiveGroup.fire(this.activeGroup);
        this._onDidChangeActiveInstance.fire(this.activeInstance);
      }
      return;
    }
    if (index < 0 || index >= this.groups.length) {
      return;
    }
    const oldActiveGroup = this.activeGroup;
    this.activeGroupIndex = index;
    if (force || oldActiveGroup !== this.activeGroup) {
      this._onDidChangeActiveGroup.fire(this.activeGroup);
      this._onDidChangeActiveInstance.fire(this.activeInstance);
    }
  }
  _getInstanceLocation(index) {
    let currentGroupIndex = 0;
    while (index >= 0 && currentGroupIndex < this.groups.length) {
      const group = this.groups[currentGroupIndex];
      const count = group.terminalInstances.length;
      if (index < count) {
        return {
          group,
          groupIndex: currentGroupIndex,
          instance: group.terminalInstances[index],
          instanceIndex: index
        };
      }
      index -= count;
      currentGroupIndex++;
    }
    return void 0;
  }
  setActiveInstanceByIndex(index) {
    const activeInstance = this.activeInstance;
    const instanceLocation = this._getInstanceLocation(index);
    const newActiveInstance = instanceLocation == null ? void 0 : instanceLocation.group.terminalInstances[instanceLocation.instanceIndex];
    if (!instanceLocation || activeInstance === newActiveInstance) {
      return;
    }
    const activeInstanceIndex = instanceLocation.instanceIndex;
    this.activeGroupIndex = instanceLocation.groupIndex;
    this._onDidChangeActiveGroup.fire(this.activeGroup);
    instanceLocation.group.setActiveInstanceByIndex(activeInstanceIndex, true);
  }
  setActiveGroupToNext() {
    if (this.groups.length <= 1) {
      return;
    }
    let newIndex = this.activeGroupIndex + 1;
    if (newIndex >= this.groups.length) {
      newIndex = 0;
    }
    this.setActiveGroupByIndex(newIndex);
  }
  setActiveGroupToPrevious() {
    if (this.groups.length <= 1) {
      return;
    }
    let newIndex = this.activeGroupIndex - 1;
    if (newIndex < 0) {
      newIndex = this.groups.length - 1;
    }
    this.setActiveGroupByIndex(newIndex);
  }
  moveGroup(source, target) {
    const sourceGroup = this.getGroupForInstance(source);
    const targetGroup = this.getGroupForInstance(target);
    if (!sourceGroup || !targetGroup) {
      return;
    }
    if (sourceGroup === targetGroup) {
      const index = sourceGroup.terminalInstances.indexOf(target);
      if (index !== -1) {
        sourceGroup.moveInstance(source, index);
      }
      return;
    }
    const sourceGroupIndex = this.groups.indexOf(sourceGroup);
    const targetGroupIndex = this.groups.indexOf(targetGroup);
    this.groups.splice(sourceGroupIndex, 1);
    this.groups.splice(targetGroupIndex, 0, sourceGroup);
    this._onDidChangeInstances.fire();
  }
  moveGroupToEnd(source) {
    const sourceGroup = this.getGroupForInstance(source);
    if (!sourceGroup) {
      return;
    }
    const sourceGroupIndex = this.groups.indexOf(sourceGroup);
    this.groups.splice(sourceGroupIndex, 1);
    this.groups.push(sourceGroup);
    this._onDidChangeInstances.fire();
  }
  moveInstance(source, target, side) {
    const sourceGroup = this.getGroupForInstance(source);
    const targetGroup = this.getGroupForInstance(target);
    if (!sourceGroup || !targetGroup) {
      return;
    }
    if (sourceGroup !== targetGroup) {
      sourceGroup.removeInstance(source);
      targetGroup.addInstance(source);
    }
    const index = targetGroup.terminalInstances.indexOf(target) + (side === "after" ? 1 : 0);
    targetGroup.moveInstance(source, index);
  }
  unsplitInstance(instance) {
    const oldGroup = this.getGroupForInstance(instance);
    if (!oldGroup || oldGroup.terminalInstances.length < 2) {
      return;
    }
    oldGroup.removeInstance(instance);
    this.createGroup(instance);
  }
  joinInstances(instances) {
    const group = this.getGroupForInstance(instances[0]);
    if (group) {
      let differentGroups = true;
      for (let i = 1; i < group.terminalInstances.length; i++) {
        if (group.terminalInstances.includes(instances[i])) {
          differentGroups = false;
          break;
        }
      }
      if (!differentGroups) {
        return;
      }
    }
    let candidateInstance = void 0;
    let candidateGroup = void 0;
    for (const instance of instances) {
      const group2 = this.getGroupForInstance(instance);
      if ((group2 == null ? void 0 : group2.terminalInstances.length) === 1) {
        candidateInstance = instance;
        candidateGroup = group2;
        break;
      }
    }
    if (!candidateGroup) {
      candidateGroup = this.createGroup();
    }
    const wasActiveGroup = this.activeGroup === candidateGroup;
    for (const instance of instances) {
      if (instance === candidateInstance) {
        continue;
      }
      const oldGroup = this.getGroupForInstance(instance);
      if (!oldGroup) {
        continue;
      }
      oldGroup.removeInstance(instance);
      candidateGroup.addInstance(instance);
    }
    this.setActiveInstance(instances[0]);
    this._onDidChangeInstances.fire();
    if (!wasActiveGroup) {
      this._onDidChangeActiveGroup.fire(this.activeGroup);
    }
  }
  instanceIsSplit(instance) {
    const group = this.getGroupForInstance(instance);
    if (!group) {
      return false;
    }
    return group.terminalInstances.length > 1;
  }
  getGroupForInstance(instance) {
    return this.groups.find((group) => group.terminalInstances.includes(instance));
  }
  getGroupLabels() {
    return this.groups.filter((group) => group.terminalInstances.length > 0).map((group, index) => {
      return `${index + 1}: ${group.title ? group.title : ""}`;
    });
  }
  updateVisibility() {
    const visible = this._viewsService.isViewVisible(TERMINAL_VIEW_ID);
    this.groups.forEach((g, i) => g.setVisible(visible && i === this.activeGroupIndex));
  }
};
TerminalGroupService = __decorate([
  __param(0, IContextKeyService),
  __param(1, IInstantiationService),
  __param(2, IViewsService),
  __param(3, IViewDescriptorService),
  __param(4, IConfigurationService)
], TerminalGroupService);
let TerminalInstanceService = class TerminalInstanceService2 extends Disposable {
  get onDidCreateInstance() {
    return this._onDidCreateInstance.event;
  }
  constructor(_instantiationService, _contextKeyService, _environmentService) {
    super();
    this._instantiationService = _instantiationService;
    this._contextKeyService = _contextKeyService;
    this._environmentService = _environmentService;
    this._backendRegistration = /* @__PURE__ */ new Map();
    this._onDidCreateInstance = new Emitter();
    this._terminalShellTypeContextKey = TerminalContextKeys.shellType.bindTo(this._contextKeyService);
    this._terminalInRunCommandPicker = TerminalContextKeys.inTerminalRunCommandPicker.bindTo(this._contextKeyService);
    this._terminalSuggestWidgetVisibleContextKey = TerminalContextKeys.suggestWidgetVisible.bindTo(this._contextKeyService);
    this._configHelper = _instantiationService.createInstance(TerminalConfigHelper);
    for (const remoteAuthority of [void 0, _environmentService.remoteAuthority]) {
      let resolve2;
      const p = new Promise((r) => resolve2 = r);
      this._backendRegistration.set(remoteAuthority, { promise: p, resolve: resolve2 });
    }
  }
  createInstance(config, target) {
    const shellLaunchConfig = this.convertProfileToShellLaunchConfig(config);
    const instance = this._instantiationService.createInstance(TerminalInstance, this._terminalShellTypeContextKey, this._terminalInRunCommandPicker, this._terminalSuggestWidgetVisibleContextKey, this._configHelper, shellLaunchConfig);
    instance.target = target;
    this._onDidCreateInstance.fire(instance);
    return instance;
  }
  convertProfileToShellLaunchConfig(shellLaunchConfigOrProfile, cwd) {
    if (shellLaunchConfigOrProfile && "profileName" in shellLaunchConfigOrProfile) {
      const profile = shellLaunchConfigOrProfile;
      if (!profile.path) {
        return shellLaunchConfigOrProfile;
      }
      return {
        executable: profile.path,
        args: profile.args,
        env: profile.env,
        icon: profile.icon,
        color: profile.color,
        name: profile.overrideName ? profile.profileName : void 0,
        cwd
      };
    }
    if (shellLaunchConfigOrProfile) {
      if (cwd) {
        shellLaunchConfigOrProfile.cwd = cwd;
      }
      return shellLaunchConfigOrProfile;
    }
    return {};
  }
  async getBackend(remoteAuthority) {
    var _a2;
    let backend = Registry.as(TerminalExtensions.Backend).getTerminalBackend(remoteAuthority);
    if (!backend) {
      await ((_a2 = this._backendRegistration.get(remoteAuthority)) == null ? void 0 : _a2.promise);
      backend = Registry.as(TerminalExtensions.Backend).getTerminalBackend(remoteAuthority);
    }
    return backend;
  }
  getRegisteredBackends() {
    return Registry.as(TerminalExtensions.Backend).backends.values();
  }
  didRegisterBackend(remoteAuthority) {
    var _a2;
    (_a2 = this._backendRegistration.get(remoteAuthority)) == null ? void 0 : _a2.resolve();
  }
};
TerminalInstanceService = __decorate([
  __param(0, IInstantiationService),
  __param(1, IContextKeyService),
  __param(2, IWorkbenchEnvironmentService)
], TerminalInstanceService);
const terminalColorSchema = {
  type: ["string", "null"],
  enum: [
    "terminal.ansiBlack",
    "terminal.ansiRed",
    "terminal.ansiGreen",
    "terminal.ansiYellow",
    "terminal.ansiBlue",
    "terminal.ansiMagenta",
    "terminal.ansiCyan",
    "terminal.ansiWhite"
  ],
  default: null
};
const terminalIconSchema = {
  type: "string",
  enum: Array.from(getAllCodicons(), (icon) => icon.id),
  markdownEnumDescriptions: Array.from(getAllCodicons(), (icon) => `$(${icon.id})`)
};
const terminalProfileBaseProperties = {
  args: {
    description: localize(
      "terminalProfile.args",
      "An optional set of arguments to run the shell executable with."
    ),
    type: "array",
    items: {
      type: "string"
    }
  },
  overrideName: {
    description: localize(
      "terminalProfile.overrideName",
      "Controls whether or not the profile name overrides the auto detected one."
    ),
    type: "boolean"
  },
  icon: {
    description: localize(
      "terminalProfile.icon",
      "A codicon ID to associate with the terminal icon."
    ),
    ...terminalIconSchema
  },
  color: {
    description: localize(
      "terminalProfile.color",
      "A theme color ID to associate with the terminal icon."
    ),
    ...terminalColorSchema
  },
  env: {
    markdownDescription: localize(
      "terminalProfile.env",
      "An object with environment variables that will be added to the terminal profile process. Set to `null` to delete environment variables from the base environment."
    ),
    type: "object",
    additionalProperties: {
      type: ["string", "null"]
    },
    default: {}
  }
};
const terminalProfileSchema = {
  type: "object",
  required: ["path"],
  properties: {
    path: {
      description: localize(
        "terminalProfile.path",
        "A single path to a shell executable or an array of paths that will be used as fallbacks when one fails."
      ),
      type: ["string", "array"],
      items: {
        type: "string"
      }
    },
    ...terminalProfileBaseProperties
  }
};
const terminalAutomationProfileSchema = {
  type: "object",
  required: ["path"],
  properties: {
    path: {
      description: localize("terminalAutomationProfile.path", "A single path to a shell executable."),
      type: ["string"],
      items: {
        type: "string"
      }
    },
    ...terminalProfileBaseProperties
  }
};
function createTerminalProfileMarkdownDescription(platform) {
  const key = platform === 2 ? "linux" : platform === 1 ? "osx" : "windows";
  return localize({
    key: "terminal.integrated.profile",
    comment: ["{0} is the platform, {1} is a code block, {2} and {3} are a link start and end"]
  }, "A set of terminal profile customizations for {0} which allows adding, removing or changing how terminals are launched. Profiles are made up of a mandatory path, optional arguments and other presentation options.\n\nTo override an existing profile use its profile name as the key, for example:\n\n{1}\n\n{2}Read more about configuring profiles{3}.", PlatformToString(platform), '```json\n"terminal.integrated.profile.' + key + '": {\n  "bash": null\n}\n```', "[", "](https://code.visualstudio.com/docs/terminal/profiles)");
}
const terminalPlatformConfiguration = {
  id: "terminal",
  order: 100,
  title: localize("terminalIntegratedConfigurationTitle", "Integrated Terminal"),
  type: "object",
  properties: {
    ["terminal.integrated.automationProfile.linux"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.automationProfile.linux",
        "The terminal profile to use on Linux for automation-related terminal usage like tasks and debug."
      ),
      type: ["object", "null"],
      default: null,
      "anyOf": [
        { type: "null" },
        terminalAutomationProfileSchema
      ],
      defaultSnippets: [
        {
          body: {
            path: "${1}",
            icon: "${2}"
          }
        }
      ]
    },
    ["terminal.integrated.automationProfile.osx"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.automationProfile.osx",
        "The terminal profile to use on macOS for automation-related terminal usage like tasks and debug."
      ),
      type: ["object", "null"],
      default: null,
      "anyOf": [
        { type: "null" },
        terminalAutomationProfileSchema
      ],
      defaultSnippets: [
        {
          body: {
            path: "${1}",
            icon: "${2}"
          }
        }
      ]
    },
    ["terminal.integrated.automationProfile.windows"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.automationProfile.windows",
        "The terminal profile to use for automation-related terminal usage like tasks and debug. This setting will currently be ignored if {0} (now deprecated) is set.",
        "`terminal.integrated.automationShell.windows`"
      ),
      type: ["object", "null"],
      default: null,
      "anyOf": [
        { type: "null" },
        terminalAutomationProfileSchema
      ],
      defaultSnippets: [
        {
          body: {
            path: "${1}",
            icon: "${2}"
          }
        }
      ]
    },
    ["terminal.integrated.profiles.windows"]: {
      restricted: true,
      markdownDescription: createTerminalProfileMarkdownDescription(3),
      type: "object",
      default: {
        "PowerShell": {
          source: "PowerShell",
          icon: "terminal-powershell"
        },
        "Command Prompt": {
          path: [
            "${env:windir}\\Sysnative\\cmd.exe",
            "${env:windir}\\System32\\cmd.exe"
          ],
          args: [],
          icon: "terminal-cmd"
        },
        "Git Bash": {
          source: "Git Bash"
        }
      },
      additionalProperties: {
        "anyOf": [
          {
            type: "object",
            required: ["source"],
            properties: {
              source: {
                description: localize(
                  "terminalProfile.windowsSource",
                  "A profile source that will auto detect the paths to the shell. Note that non-standard executable locations are not supported and must be created manually in a new profile."
                ),
                enum: ["PowerShell", "Git Bash"]
              },
              ...terminalProfileBaseProperties
            }
          },
          {
            type: "object",
            required: ["extensionIdentifier", "id", "title"],
            properties: {
              extensionIdentifier: {
                description: localize(
                  "terminalProfile.windowsExtensionIdentifier",
                  "The extension that contributed this profile."
                ),
                type: "string"
              },
              id: {
                description: localize("terminalProfile.windowsExtensionId", "The id of the extension terminal"),
                type: "string"
              },
              title: {
                description: localize(
                  "terminalProfile.windowsExtensionTitle",
                  "The name of the extension terminal"
                ),
                type: "string"
              },
              ...terminalProfileBaseProperties
            }
          },
          { type: "null" },
          terminalProfileSchema
        ]
      }
    },
    ["terminal.integrated.profiles.osx"]: {
      restricted: true,
      markdownDescription: createTerminalProfileMarkdownDescription(1),
      type: "object",
      default: {
        "bash": {
          path: "bash",
          args: ["-l"],
          icon: "terminal-bash"
        },
        "zsh": {
          path: "zsh",
          args: ["-l"]
        },
        "fish": {
          path: "fish",
          args: ["-l"]
        },
        "tmux": {
          path: "tmux",
          icon: "terminal-tmux"
        },
        "pwsh": {
          path: "pwsh",
          icon: "terminal-powershell"
        }
      },
      additionalProperties: {
        "anyOf": [
          {
            type: "object",
            required: ["extensionIdentifier", "id", "title"],
            properties: {
              extensionIdentifier: {
                description: localize(
                  "terminalProfile.osxExtensionIdentifier",
                  "The extension that contributed this profile."
                ),
                type: "string"
              },
              id: {
                description: localize("terminalProfile.osxExtensionId", "The id of the extension terminal"),
                type: "string"
              },
              title: {
                description: localize("terminalProfile.osxExtensionTitle", "The name of the extension terminal"),
                type: "string"
              },
              ...terminalProfileBaseProperties
            }
          },
          { type: "null" },
          terminalProfileSchema
        ]
      }
    },
    ["terminal.integrated.profiles.linux"]: {
      restricted: true,
      markdownDescription: createTerminalProfileMarkdownDescription(2),
      type: "object",
      default: {
        "bash": {
          path: "bash",
          icon: "terminal-bash"
        },
        "zsh": {
          path: "zsh"
        },
        "fish": {
          path: "fish"
        },
        "tmux": {
          path: "tmux",
          icon: "terminal-tmux"
        },
        "pwsh": {
          path: "pwsh",
          icon: "terminal-powershell"
        }
      },
      additionalProperties: {
        "anyOf": [
          {
            type: "object",
            required: ["extensionIdentifier", "id", "title"],
            properties: {
              extensionIdentifier: {
                description: localize(
                  "terminalProfile.linuxExtensionIdentifier",
                  "The extension that contributed this profile."
                ),
                type: "string"
              },
              id: {
                description: localize("terminalProfile.linuxExtensionId", "The id of the extension terminal"),
                type: "string"
              },
              title: {
                description: localize(
                  "terminalProfile.linuxExtensionTitle",
                  "The name of the extension terminal"
                ),
                type: "string"
              },
              ...terminalProfileBaseProperties
            }
          },
          { type: "null" },
          terminalProfileSchema
        ]
      }
    },
    ["terminal.integrated.useWslProfiles"]: {
      description: localize(
        "terminal.integrated.useWslProfiles",
        "Controls whether or not WSL distros are shown in the terminal dropdown"
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.inheritEnv"]: {
      scope: 1,
      description: localize(
        "terminal.integrated.inheritEnv",
        "Whether new shells should inherit their environment from VS Code, which may source a login shell to ensure $PATH and other development variables are initialized. This has no effect on Windows."
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.persistentSessionScrollback"]: {
      scope: 1,
      markdownDescription: localize(
        "terminal.integrated.persistentSessionScrollback",
        "Controls the maximum amount of lines that will be restored when reconnecting to a persistent terminal session. Increasing this will restore more lines of scrollback at the cost of more memory and increase the time it takes to connect to terminals on start up. This setting requires a restart to take effect and should be set to a value less than or equal to `#terminal.integrated.scrollback#`."
      ),
      type: "number",
      default: 100
    },
    ["terminal.integrated.showLinkHover"]: {
      scope: 1,
      description: localize(
        "terminal.integrated.showLinkHover",
        "Whether to show hovers for links in the terminal output."
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.ignoreProcessNames"]: {
      description: localize(
        "terminal.integrated.confirmIgnoreProcesses",
        "A set of process names to ignore when using the {0} setting.",
        "`terminal.integrated.confirmOnKill`"
      ),
      type: "array",
      items: {
        type: "string",
        uniqueItems: true
      },
      default: [
        "starship",
        "oh-my-posh",
        "bash",
        "zsh"
      ]
    }
  }
};
function registerTerminalPlatformConfiguration() {
  Registry.as(Extensions.Configuration).registerConfiguration(terminalPlatformConfiguration);
  registerTerminalDefaultProfileConfiguration();
}
let defaultProfilesConfiguration;
function registerTerminalDefaultProfileConfiguration(detectedProfiles, extensionContributedProfiles) {
  const registry = Registry.as(Extensions.Configuration);
  let profileEnum;
  if (detectedProfiles) {
    profileEnum = createProfileSchemaEnums(detectedProfiles == null ? void 0 : detectedProfiles.profiles, extensionContributedProfiles);
  }
  const oldDefaultProfilesConfiguration = defaultProfilesConfiguration;
  defaultProfilesConfiguration = {
    id: "terminal",
    order: 100,
    title: localize("terminalIntegratedConfigurationTitle", "Integrated Terminal"),
    type: "object",
    properties: {
      ["terminal.integrated.defaultProfile.linux"]: {
        restricted: true,
        markdownDescription: localize(
          "terminal.integrated.defaultProfile.linux",
          "The default terminal profile on Linux."
        ),
        type: ["string", "null"],
        default: null,
        enum: (detectedProfiles == null ? void 0 : detectedProfiles.os) === 3 ? profileEnum == null ? void 0 : profileEnum.values : void 0,
        markdownEnumDescriptions: (detectedProfiles == null ? void 0 : detectedProfiles.os) === 3 ? profileEnum == null ? void 0 : profileEnum.markdownDescriptions : void 0
      },
      ["terminal.integrated.defaultProfile.osx"]: {
        restricted: true,
        markdownDescription: localize(
          "terminal.integrated.defaultProfile.osx",
          "The default terminal profile on macOS."
        ),
        type: ["string", "null"],
        default: null,
        enum: (detectedProfiles == null ? void 0 : detectedProfiles.os) === 2 ? profileEnum == null ? void 0 : profileEnum.values : void 0,
        markdownEnumDescriptions: (detectedProfiles == null ? void 0 : detectedProfiles.os) === 2 ? profileEnum == null ? void 0 : profileEnum.markdownDescriptions : void 0
      },
      ["terminal.integrated.defaultProfile.windows"]: {
        restricted: true,
        markdownDescription: localize(
          "terminal.integrated.defaultProfile.windows",
          "The default terminal profile on Windows."
        ),
        type: ["string", "null"],
        default: null,
        enum: (detectedProfiles == null ? void 0 : detectedProfiles.os) === 1 ? profileEnum == null ? void 0 : profileEnum.values : void 0,
        markdownEnumDescriptions: (detectedProfiles == null ? void 0 : detectedProfiles.os) === 1 ? profileEnum == null ? void 0 : profileEnum.markdownDescriptions : void 0
      }
    }
  };
  registry.updateConfigurations({ add: [defaultProfilesConfiguration], remove: oldDefaultProfilesConfiguration ? [oldDefaultProfilesConfiguration] : [] });
}
let TerminalProfileService = class TerminalProfileService2 {
  get onDidChangeAvailableProfiles() {
    return this._onDidChangeAvailableProfiles.event;
  }
  get profilesReady() {
    return this._profilesReadyBarrier.wait().then(() => {
    });
  }
  get availableProfiles() {
    if (!this._platformConfigJustRefreshed) {
      this.refreshAvailableProfiles();
    }
    return this._availableProfiles || [];
  }
  get contributedProfiles() {
    return this._contributedProfiles || [];
  }
  constructor(_contextKeyService, _configurationService, _terminalContributionService, _extensionService, _remoteAgentService, _environmentService, _terminalInstanceService) {
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._terminalContributionService = _terminalContributionService;
    this._extensionService = _extensionService;
    this._remoteAgentService = _remoteAgentService;
    this._environmentService = _environmentService;
    this._terminalInstanceService = _terminalInstanceService;
    this._contributedProfiles = [];
    this._platformConfigJustRefreshed = false;
    this._profileProviders = /* @__PURE__ */ new Map();
    this._onDidChangeAvailableProfiles = new Emitter();
    this._extensionService.onDidChangeExtensions(() => this.refreshAvailableProfiles());
    this._webExtensionContributedProfileContextKey = TerminalContextKeys.webExtensionContributedProfile.bindTo(this._contextKeyService);
    this._updateWebContextKey();
    this._profilesReadyBarrier = new AutoOpenBarrier(2e4);
    this.refreshAvailableProfiles();
    this._setupConfigListener();
  }
  async _setupConfigListener() {
    const platformKey = await this.getPlatformKey();
    this._configurationService.onDidChangeConfiguration(async (e) => {
      if (e.affectsConfiguration("terminal.integrated.defaultProfile." + platformKey) || e.affectsConfiguration("terminal.integrated.profiles." + platformKey) || e.affectsConfiguration("terminal.integrated.useWslProfiles")) {
        if (e.source !== 7) {
          this.refreshAvailableProfiles();
          this._platformConfigJustRefreshed = false;
        } else {
          this._platformConfigJustRefreshed = true;
        }
      }
    });
  }
  getDefaultProfileName() {
    return this._defaultProfileName;
  }
  getDefaultProfile(os) {
    let defaultProfileName;
    if (os) {
      defaultProfileName = this._configurationService.getValue(`${"terminal.integrated.defaultProfile."}${this._getOsKey(os)}`);
      if (!defaultProfileName || typeof defaultProfileName !== "string") {
        return void 0;
      }
    } else {
      defaultProfileName = this._defaultProfileName;
    }
    if (!defaultProfileName) {
      return void 0;
    }
    return this.availableProfiles.find((e) => e.profileName === defaultProfileName && !e.isAutoDetected);
  }
  _getOsKey(os) {
    switch (os) {
      case 3:
        return "linux";
      case 2:
        return "osx";
      case 1:
        return "windows";
    }
  }
  refreshAvailableProfiles() {
    this._refreshAvailableProfilesNow();
  }
  async _refreshAvailableProfilesNow() {
    const profiles = await this._detectProfiles(true);
    const profilesChanged = !equals(profiles, this._availableProfiles, profilesEqual);
    const contributedProfilesChanged = await this._updateContributedProfiles();
    if (profilesChanged || contributedProfilesChanged) {
      this._availableProfiles = profiles;
      this._onDidChangeAvailableProfiles.fire(this._availableProfiles);
      this._profilesReadyBarrier.open();
      this._updateWebContextKey();
      await this._refreshPlatformConfig(this._availableProfiles);
    }
  }
  async _updateContributedProfiles() {
    const platformKey = await this.getPlatformKey();
    const excludedContributedProfiles = [];
    const configProfiles = this._configurationService.getValue("terminal.integrated.profiles." + platformKey);
    for (const [profileName, value] of Object.entries(configProfiles)) {
      if (value === null) {
        excludedContributedProfiles.push(profileName);
      }
    }
    const filteredContributedProfiles = Array.from(this._terminalContributionService.terminalProfiles.filter((p) => !excludedContributedProfiles.includes(p.title)));
    const contributedProfilesChanged = !equals(filteredContributedProfiles, this._contributedProfiles, contributedProfilesEqual);
    this._contributedProfiles = filteredContributedProfiles;
    return contributedProfilesChanged;
  }
  getContributedProfileProvider(extensionIdentifier, id) {
    const extMap = this._profileProviders.get(extensionIdentifier);
    return extMap == null ? void 0 : extMap.get(id);
  }
  async _detectProfiles(includeDetectedProfiles) {
    const primaryBackend = await this._terminalInstanceService.getBackend(this._environmentService.remoteAuthority);
    if (!primaryBackend) {
      return this._availableProfiles || [];
    }
    const platform = await this.getPlatformKey();
    this._defaultProfileName = this._configurationService.getValue(`${"terminal.integrated.defaultProfile."}${platform}`) ?? void 0;
    return primaryBackend.getProfiles(this._configurationService.getValue(`${"terminal.integrated.profiles."}${platform}`), this._defaultProfileName, includeDetectedProfiles);
  }
  _updateWebContextKey() {
    this._webExtensionContributedProfileContextKey.set(isWeb && this._contributedProfiles.length > 0);
  }
  async _refreshPlatformConfig(profiles) {
    const env2 = await this._remoteAgentService.getEnvironment();
    registerTerminalDefaultProfileConfiguration({ os: (env2 == null ? void 0 : env2.os) || OS, profiles }, this._contributedProfiles);
    refreshTerminalActions(profiles);
  }
  async getPlatformKey() {
    const env2 = await this._remoteAgentService.getEnvironment();
    if (env2) {
      return env2.os === 1 ? "windows" : env2.os === 2 ? "osx" : "linux";
    }
    return isWindows ? "windows" : isMacintosh ? "osx" : "linux";
  }
  registerTerminalProfileProvider(extensionIdentifier, id, profileProvider) {
    let extMap = this._profileProviders.get(extensionIdentifier);
    if (!extMap) {
      extMap = /* @__PURE__ */ new Map();
      this._profileProviders.set(extensionIdentifier, extMap);
    }
    extMap.set(id, profileProvider);
    return toDisposable(() => this._profileProviders.delete(id));
  }
  async registerContributedProfile(args) {
    const platformKey = await this.getPlatformKey();
    const profilesConfig = await this._configurationService.getValue(`${"terminal.integrated.profiles."}${platformKey}`);
    if (typeof profilesConfig === "object") {
      const newProfile = {
        extensionIdentifier: args.extensionIdentifier,
        icon: args.options.icon,
        id: args.id,
        title: args.title,
        color: args.options.color
      };
      profilesConfig[args.title] = newProfile;
    }
    await this._configurationService.updateValue(`${"terminal.integrated.profiles."}${platformKey}`, profilesConfig, 2);
    return;
  }
  async getContributedDefaultProfile(shellLaunchConfig) {
    if (shellLaunchConfig && !shellLaunchConfig.extHostTerminalId && !("executable" in shellLaunchConfig)) {
      const key = await this.getPlatformKey();
      const defaultProfileName = this._configurationService.getValue(`${"terminal.integrated.defaultProfile."}${key}`);
      const contributedDefaultProfile = this.contributedProfiles.find((p) => p.title === defaultProfileName);
      return contributedDefaultProfile;
    }
    return void 0;
  }
};
TerminalProfileService.__decorator = __decorate([
  throttle(2e3)
], TerminalProfileService.prototype, "refreshAvailableProfiles", null);
TerminalProfileService = __decorate([
  __param(0, IContextKeyService),
  __param(1, IConfigurationService),
  __param(2, ITerminalContributionService),
  __param(3, IExtensionService),
  __param(4, IRemoteAgentService),
  __param(5, IWorkbenchEnvironmentService),
  __param(6, ITerminalInstanceService)
], TerminalProfileService);
function profilesEqual(one, other) {
  return one.profileName === other.profileName && terminalProfileArgsMatch(one.args, other.args) && one.color === other.color && terminalIconsEqual(one.icon, other.icon) && one.isAutoDetected === other.isAutoDetected && one.isDefault === other.isDefault && one.overrideName === other.overrideName && one.path === other.path;
}
function contributedProfilesEqual(one, other) {
  return one.extensionIdentifier === other.extensionIdentifier && one.color === other.color && one.icon === other.icon && one.id === other.id && one.title === other.title;
}
class TerminalLinkProviderService {
  constructor() {
    this._linkProviders = /* @__PURE__ */ new Set();
    this._onDidAddLinkProvider = new Emitter();
    this._onDidRemoveLinkProvider = new Emitter();
  }
  get linkProviders() {
    return this._linkProviders;
  }
  get onDidAddLinkProvider() {
    return this._onDidAddLinkProvider.event;
  }
  get onDidRemoveLinkProvider() {
    return this._onDidRemoveLinkProvider.event;
  }
  registerLinkProvider(linkProvider) {
    const disposables = [];
    this._linkProviders.add(linkProvider);
    this._onDidAddLinkProvider.fire(linkProvider);
    return {
      dispose: () => {
        for (const disposable of disposables) {
          disposable.dispose();
        }
        this._linkProviders.delete(linkProvider);
        this._onDidRemoveLinkProvider.fire(linkProvider);
      }
    };
  }
}
const generatedProfileName = "Generated";
class BaseTerminalProfileResolverService {
  get defaultProfileName() {
    return this._defaultProfileName;
  }
  constructor(_context, _configurationService, _configurationResolverService, _historyService, _logService, _terminalProfileService, _workspaceContextService, _remoteAgentService) {
    this._context = _context;
    this._configurationService = _configurationService;
    this._configurationResolverService = _configurationResolverService;
    this._historyService = _historyService;
    this._logService = _logService;
    this._terminalProfileService = _terminalProfileService;
    this._workspaceContextService = _workspaceContextService;
    this._remoteAgentService = _remoteAgentService;
    this._iconRegistry = getIconRegistry();
    if (this._remoteAgentService.getConnection()) {
      this._remoteAgentService.getEnvironment().then((env2) => this._primaryBackendOs = (env2 == null ? void 0 : env2.os) || OS);
    } else {
      this._primaryBackendOs = OS;
    }
    this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("terminal.integrated.defaultProfile.windows") || e.affectsConfiguration("terminal.integrated.defaultProfile.osx") || e.affectsConfiguration("terminal.integrated.defaultProfile.linux")) {
        this._refreshDefaultProfileName();
      }
    });
    this._terminalProfileService.onDidChangeAvailableProfiles(() => this._refreshDefaultProfileName());
  }
  async _refreshDefaultProfileName() {
    var _a2, _b2;
    if (this._primaryBackendOs) {
      this._defaultProfileName = (_b2 = await this.getDefaultProfile({
        remoteAuthority: (_a2 = this._remoteAgentService.getConnection()) == null ? void 0 : _a2.remoteAuthority,
        os: this._primaryBackendOs
      })) == null ? void 0 : _b2.profileName;
    }
  }
  resolveIcon(shellLaunchConfig, os) {
    if (shellLaunchConfig.icon) {
      shellLaunchConfig.icon = this._getCustomIcon(shellLaunchConfig.icon) || this.getDefaultIcon();
      return;
    }
    if (shellLaunchConfig.customPtyImplementation) {
      shellLaunchConfig.icon = this.getDefaultIcon();
      return;
    }
    if (shellLaunchConfig.executable) {
      return;
    }
    const defaultProfile = this._getUnresolvedRealDefaultProfile(os);
    if (defaultProfile) {
      shellLaunchConfig.icon = defaultProfile.icon;
    }
    if (!shellLaunchConfig.icon) {
      shellLaunchConfig.icon = this.getDefaultIcon();
    }
  }
  getDefaultIcon(resource) {
    return this._iconRegistry.getIcon(this._configurationService.getValue("terminal.integrated.tabs.defaultIcon", { resource })) || Codicon.terminal;
  }
  async resolveShellLaunchConfig(shellLaunchConfig, options) {
    let resolvedProfile;
    if (shellLaunchConfig.executable) {
      resolvedProfile = await this._resolveProfile({
        path: shellLaunchConfig.executable,
        args: shellLaunchConfig.args,
        profileName: generatedProfileName,
        isDefault: false
      }, options);
    } else {
      resolvedProfile = await this.getDefaultProfile(options);
    }
    shellLaunchConfig.executable = resolvedProfile.path;
    shellLaunchConfig.args = resolvedProfile.args;
    if (resolvedProfile.env) {
      if (shellLaunchConfig.env) {
        shellLaunchConfig.env = { ...shellLaunchConfig.env, ...resolvedProfile.env };
      } else {
        shellLaunchConfig.env = resolvedProfile.env;
      }
    }
    const resource = shellLaunchConfig === void 0 || typeof shellLaunchConfig.cwd === "string" ? void 0 : shellLaunchConfig.cwd;
    shellLaunchConfig.icon = this._getCustomIcon(shellLaunchConfig.icon) || this._getCustomIcon(resolvedProfile.icon) || this.getDefaultIcon(resource);
    if (resolvedProfile.overrideName) {
      shellLaunchConfig.name = resolvedProfile.profileName;
    }
    shellLaunchConfig.color = shellLaunchConfig.color || resolvedProfile.color || this._configurationService.getValue("terminal.integrated.tabs.defaultColor", { resource });
    if (shellLaunchConfig.useShellEnvironment === void 0) {
      shellLaunchConfig.useShellEnvironment = this._configurationService.getValue("terminal.integrated.inheritEnv");
    }
  }
  async getDefaultShell(options) {
    return (await this.getDefaultProfile(options)).path;
  }
  async getDefaultShellArgs(options) {
    return (await this.getDefaultProfile(options)).args || [];
  }
  async getDefaultProfile(options) {
    return this._resolveProfile(await this._getUnresolvedDefaultProfile(options), options);
  }
  getEnvironment(remoteAuthority) {
    return this._context.getEnvironment(remoteAuthority);
  }
  _getCustomIcon(icon) {
    if (!icon) {
      return void 0;
    }
    if (typeof icon === "string") {
      return ThemeIcon.fromId(icon);
    }
    if (ThemeIcon.isThemeIcon(icon)) {
      return icon;
    }
    if (URI.isUri(icon) || isUriComponents(icon)) {
      return URI.revive(icon);
    }
    if (typeof icon === "object" && "light" in icon && "dark" in icon) {
      const castedIcon = icon;
      if ((URI.isUri(castedIcon.light) || isUriComponents(castedIcon.light)) && (URI.isUri(castedIcon.dark) || isUriComponents(castedIcon.dark))) {
        return { light: URI.revive(castedIcon.light), dark: URI.revive(castedIcon.dark) };
      }
    }
    return void 0;
  }
  async _getUnresolvedDefaultProfile(options) {
    if (options.allowAutomationShell) {
      const automationShellProfile = this._getUnresolvedAutomationShellProfile(options);
      if (automationShellProfile) {
        return automationShellProfile;
      }
    }
    await this._terminalProfileService.profilesReady;
    const defaultProfile = this._getUnresolvedRealDefaultProfile(options.os);
    if (defaultProfile) {
      return this._setIconForAutomation(options, defaultProfile);
    }
    return this._setIconForAutomation(options, await this._getUnresolvedFallbackDefaultProfile(options));
  }
  _setIconForAutomation(options, profile) {
    if (options.allowAutomationShell) {
      const profileClone = deepClone(profile);
      profileClone.icon = Codicon.tools;
      return profileClone;
    }
    return profile;
  }
  _getUnresolvedRealDefaultProfile(os) {
    return this._terminalProfileService.getDefaultProfile(os);
  }
  async _getUnresolvedFallbackDefaultProfile(options) {
    const executable = await this._context.getDefaultSystemShell(options.remoteAuthority, options.os);
    if (options.os === OS) {
      let existingProfile = this._terminalProfileService.availableProfiles.find((e) => parse$1(e.path).name === parse$1(executable).name);
      if (existingProfile) {
        if (options.allowAutomationShell) {
          existingProfile = deepClone(existingProfile);
          existingProfile.icon = Codicon.tools;
        }
        return existingProfile;
      }
    }
    let args;
    if (options.os === 2 && parse$1(executable).name.match(/(zsh|bash)/)) {
      args = ["--login"];
    } else {
      args = [];
    }
    const icon = this._guessProfileIcon(executable);
    return {
      profileName: generatedProfileName,
      path: executable,
      args,
      icon,
      isDefault: false
    };
  }
  _getUnresolvedAutomationShellProfile(options) {
    const automationProfile = this._configurationService.getValue(`terminal.integrated.automationProfile.${this._getOsKey(options.os)}`);
    if (this._isValidAutomationProfile(automationProfile, options.os)) {
      automationProfile.icon = this._getCustomIcon(automationProfile.icon) || Codicon.tools;
      return automationProfile;
    }
    return void 0;
  }
  async _resolveProfile(profile, options) {
    const env2 = await this._context.getEnvironment(options.remoteAuthority);
    if (options.os === 1) {
      const isWoW64 = !!env2.hasOwnProperty("PROCESSOR_ARCHITEW6432");
      const windir = env2.windir;
      if (!isWoW64 && windir) {
        const sysnativePath = join(windir, "Sysnative").replace(/\//g, "\\").toLowerCase();
        if (profile.path && profile.path.toLowerCase().indexOf(sysnativePath) === 0) {
          profile.path = join(windir, "System32", profile.path.substr(sysnativePath.length + 1));
        }
      }
      if (profile.path) {
        profile.path = profile.path.replace(/\//g, "\\");
      }
    }
    const activeWorkspaceRootUri = this._historyService.getLastActiveWorkspaceRoot(options.remoteAuthority ? Schemas.vscodeRemote : Schemas.file);
    const lastActiveWorkspace = activeWorkspaceRootUri ? withNullAsUndefined(this._workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri)) : void 0;
    profile.path = await this._resolveVariables(profile.path, env2, lastActiveWorkspace);
    if (profile.args) {
      if (typeof profile.args === "string") {
        profile.args = await this._resolveVariables(profile.args, env2, lastActiveWorkspace);
      } else {
        profile.args = await Promise.all(profile.args.map((arg) => this._resolveVariables(arg, env2, lastActiveWorkspace)));
      }
    }
    return profile;
  }
  async _resolveVariables(value, env2, lastActiveWorkspace) {
    try {
      value = await this._configurationResolverService.resolveWithEnvironment(env2, lastActiveWorkspace, value);
    } catch (e) {
      this._logService.error(`Could not resolve shell`, e);
    }
    return value;
  }
  _getOsKey(os) {
    switch (os) {
      case 3:
        return "linux";
      case 2:
        return "osx";
      case 1:
        return "windows";
    }
  }
  _guessProfileIcon(shell) {
    const file = parse$1(shell).name;
    switch (file) {
      case "bash":
        return Codicon.terminalBash;
      case "pwsh":
      case "powershell":
        return Codicon.terminalPowershell;
      case "tmux":
        return Codicon.terminalTmux;
      case "cmd":
        return Codicon.terminalCmd;
      default:
        return void 0;
    }
  }
  _isValidShellArgs(shellArgs, os) {
    if (shellArgs === void 0) {
      return true;
    }
    if (os === 1 && typeof shellArgs === "string") {
      return true;
    }
    if (Array.isArray(shellArgs) && shellArgs.every((e) => typeof e === "string")) {
      return true;
    }
    return false;
  }
  async createProfileFromShellAndShellArgs(shell, shellArgs) {
    var _a2, _b2;
    const detectedProfile = (_a2 = this._terminalProfileService.availableProfiles) == null ? void 0 : _a2.find((p) => {
      if (p.path !== shell) {
        return false;
      }
      if (p.args === void 0 || typeof p.args === "string") {
        return p.args === shellArgs;
      }
      return p.path === shell && equals(p.args, shellArgs || []);
    });
    const fallbackProfile = await this.getDefaultProfile({
      remoteAuthority: (_b2 = this._remoteAgentService.getConnection()) == null ? void 0 : _b2.remoteAuthority,
      os: this._primaryBackendOs
    });
    fallbackProfile.profileName = `${fallbackProfile.path} (migrated)`;
    const profile = detectedProfile || fallbackProfile;
    const args = this._isValidShellArgs(shellArgs, this._primaryBackendOs) ? shellArgs : profile.args;
    const createdProfile = {
      profileName: profile.profileName,
      path: profile.path,
      args,
      isDefault: true
    };
    if (detectedProfile && detectedProfile.profileName === createdProfile.profileName && detectedProfile.path === createdProfile.path && terminalProfileArgsMatch(detectedProfile.args, createdProfile.args)) {
      return detectedProfile.profileName;
    }
    return createdProfile;
  }
  _isValidAutomationProfile(profile, os) {
    if (profile === null || profile === void 0 || typeof profile !== "object") {
      return false;
    }
    if ("path" in profile && typeof profile.path === "string") {
      return true;
    }
    return false;
  }
}
BaseTerminalProfileResolverService.__decorator = __decorate([
  debounce(200)
], BaseTerminalProfileResolverService.prototype, "_refreshDefaultProfileName", null);
let ElectronTerminalProfileResolverService = class ElectronTerminalProfileResolverService2 extends BaseTerminalProfileResolverService {
  constructor(configurationResolverService, configurationService, historyService, logService, workspaceContextService, terminalProfileService, remoteAgentService, terminalInstanceService) {
    super({
      getDefaultSystemShell: async (remoteAuthority, platform) => {
        const backend = await terminalInstanceService.getBackend(remoteAuthority);
        if (!backend) {
          throw new ErrorNoTelemetry(`Cannot get default system shell when there is no backend for remote authority '${remoteAuthority}'`);
        }
        return backend.getDefaultSystemShell(platform);
      },
      getEnvironment: async (remoteAuthority) => {
        const backend = await terminalInstanceService.getBackend(remoteAuthority);
        if (!backend) {
          throw new ErrorNoTelemetry(`Cannot get environment when there is no backend for remote authority '${remoteAuthority}'`);
        }
        return backend.getEnvironment();
      }
    }, configurationService, configurationResolverService, historyService, logService, terminalProfileService, workspaceContextService, remoteAgentService);
  }
};
ElectronTerminalProfileResolverService = __decorate([
  __param(0, IConfigurationResolverService),
  __param(1, IConfigurationService),
  __param(2, IHistoryService),
  __param(3, ITerminalLogService),
  __param(4, IWorkspaceContextService),
  __param(5, ITerminalProfileService),
  __param(6, IRemoteAgentService),
  __param(7, ITerminalInstanceService)
], ElectronTerminalProfileResolverService);
let EnvironmentVariableService = class EnvironmentVariableService2 {
  get onDidChangeCollections() {
    return this._onDidChangeCollections.event;
  }
  constructor(_extensionService, _storageService) {
    this._extensionService = _extensionService;
    this._storageService = _storageService;
    this.collections = /* @__PURE__ */ new Map();
    this._onDidChangeCollections = new Emitter();
    this._storageService.remove("terminal.integrated.environmentVariableCollections", 1);
    const serializedPersistedCollections = this._storageService.get("terminal.integrated.environmentVariableCollectionsV2", 1);
    if (serializedPersistedCollections) {
      const collectionsJson = JSON.parse(serializedPersistedCollections);
      collectionsJson.forEach((c) => this.collections.set(c.extensionIdentifier, {
        persistent: true,
        map: deserializeEnvironmentVariableCollection(c.collection),
        descriptionMap: deserializeEnvironmentDescriptionMap(c.description)
      }));
      this._invalidateExtensionCollections();
    }
    this.mergedCollection = this._resolveMergedCollection();
    this._extensionService.onDidChangeExtensions(() => this._invalidateExtensionCollections());
  }
  set(extensionIdentifier, collection) {
    this.collections.set(extensionIdentifier, collection);
    this._updateCollections();
  }
  delete(extensionIdentifier) {
    this.collections.delete(extensionIdentifier);
    this._updateCollections();
  }
  _updateCollections() {
    this._persistCollectionsEventually();
    this.mergedCollection = this._resolveMergedCollection();
    this._notifyCollectionUpdatesEventually();
  }
  _persistCollectionsEventually() {
    this._persistCollections();
  }
  _persistCollections() {
    const collectionsJson = [];
    this.collections.forEach((collection, extensionIdentifier) => {
      if (collection.persistent) {
        collectionsJson.push({
          extensionIdentifier,
          collection: serializeEnvironmentVariableCollection(this.collections.get(extensionIdentifier).map),
          description: serializeEnvironmentDescriptionMap(collection.descriptionMap)
        });
      }
    });
    const stringifiedJson = JSON.stringify(collectionsJson);
    this._storageService.store("terminal.integrated.environmentVariableCollectionsV2", stringifiedJson, 1, 1);
  }
  _notifyCollectionUpdatesEventually() {
    this._notifyCollectionUpdates();
  }
  _notifyCollectionUpdates() {
    this._onDidChangeCollections.fire(this.mergedCollection);
  }
  _resolveMergedCollection() {
    return new MergedEnvironmentVariableCollection(this.collections);
  }
  async _invalidateExtensionCollections() {
    await this._extensionService.whenInstalledExtensionsRegistered();
    const registeredExtensions = this._extensionService.extensions;
    let changes = false;
    this.collections.forEach((_, extensionIdentifier) => {
      const isExtensionRegistered = registeredExtensions.some((r) => r.identifier.value === extensionIdentifier);
      if (!isExtensionRegistered) {
        this.collections.delete(extensionIdentifier);
        changes = true;
      }
    });
    if (changes) {
      this._updateCollections();
    }
  }
};
EnvironmentVariableService.__decorator = __decorate([
  throttle(1e3)
], EnvironmentVariableService.prototype, "_persistCollectionsEventually", null);
EnvironmentVariableService.__decorator = __decorate([
  debounce(1e3)
], EnvironmentVariableService.prototype, "_notifyCollectionUpdatesEventually", null);
EnvironmentVariableService = __decorate([
  __param(0, IExtensionService),
  __param(1, IStorageService)
], EnvironmentVariableService);
let TerminalLogService = class TerminalLogService2 extends Disposable {
  get onDidChangeLogLevel() {
    return this._logger.onDidChangeLogLevel;
  }
  constructor(_loggerService, workspaceContextService) {
    super();
    this._loggerService = _loggerService;
    this._logger = this._loggerService.createLogger("terminal", { name: localize("terminalLoggerName", "Terminal") });
    this._register(Event.runAndSubscribe(workspaceContextService.onDidChangeWorkspaceFolders, () => {
      this._workspaceId = workspaceContextService.getWorkspace().id.substring(0, 7);
    }));
  }
  getLevel() {
    return this._logger.getLevel();
  }
  setLevel(level) {
    this._logger.setLevel(level);
  }
  flush() {
    this._logger.flush();
  }
  trace(message, ...args) {
    this._logger.trace(this._formatMessage(message), args);
  }
  debug(message, ...args) {
    this._logger.debug(this._formatMessage(message), args);
  }
  info(message, ...args) {
    this._logger.info(this._formatMessage(message), args);
  }
  warn(message, ...args) {
    this._logger.warn(this._formatMessage(message), args);
  }
  error(message, ...args) {
    if (message instanceof Error) {
      this._logger.error(this._formatMessage(""), message, args);
      return;
    }
    this._logger.error(this._formatMessage(message), args);
  }
  _formatMessage(message) {
    if (this._logger.getLevel() === LogLevel.Trace) {
      return `[${this._workspaceId}] ${message}`;
    }
    return message;
  }
};
TerminalLogService = __decorate([
  __param(0, ILoggerService),
  __param(1, IWorkspaceContextService)
], TerminalLogService);
class TerminalQuickFixService {
  get providers() {
    return this._providers;
  }
  constructor() {
    this._selectors = /* @__PURE__ */ new Map();
    this._providers = /* @__PURE__ */ new Map();
    this._onDidRegisterProvider = new Emitter();
    this.onDidRegisterProvider = this._onDidRegisterProvider.event;
    this._onDidRegisterCommandSelector = new Emitter();
    this.onDidRegisterCommandSelector = this._onDidRegisterCommandSelector.event;
    this._onDidUnregisterProvider = new Emitter();
    this.onDidUnregisterProvider = this._onDidUnregisterProvider.event;
    this.extensionQuickFixes = new Promise((r) => quickFixExtensionPoint.setHandler((fixes) => {
      r(fixes.filter((c) => isProposedApiEnabled(c.description, "terminalQuickFixProvider")).map((c) => {
        if (!c.value) {
          return [];
        }
        return c.value.map(
          (fix) => {
            return { ...fix, extensionIdentifier: c.description.identifier.value };
          }
        );
      }).flat());
    }));
    this.extensionQuickFixes.then((selectors) => {
      for (const selector of selectors) {
        this.registerCommandSelector(selector);
      }
    });
  }
  registerCommandSelector(selector) {
    this._selectors.set(selector.id, selector);
    this._onDidRegisterCommandSelector.fire(selector);
  }
  registerQuickFixProvider(id, provider) {
    let disposed = false;
    this.extensionQuickFixes.then(() => {
      if (disposed) {
        return;
      }
      this._providers.set(id, provider);
      const selector = this._selectors.get(id);
      if (!selector) {
        throw new Error(`No registered selector for ID: ${id}`);
      }
      this._onDidRegisterProvider.fire({ selector, provider });
    });
    return toDisposable(() => {
      disposed = true;
      this._providers.delete(id);
      const selector = this._selectors.get(id);
      if (selector) {
        this._selectors.delete(id);
        this._onDidUnregisterProvider.fire(selector.id);
      }
    });
  }
}
const quickFixExtensionPoint = ExtensionsRegistry.registerExtensionPoint({
  extensionPoint: "terminalQuickFixes",
  defaultExtensionKind: ["workspace"],
  activationEventsGenerator: (terminalQuickFixes, result) => {
    for (const quickFixContrib of terminalQuickFixes ?? []) {
      result.push(`onTerminalQuickFixRequest:${quickFixContrib.id}`);
    }
  },
  jsonSchema: {
    description: localize(
      "vscode.extension.contributes.terminalQuickFixes",
      "Contributes terminal quick fixes."
    ),
    type: "array",
    items: {
      type: "object",
      additionalProperties: false,
      required: ["id", "commandLineMatcher", "outputMatcher", "commandExitResult"],
      defaultSnippets: [{
        body: {
          id: "$1",
          commandLineMatcher: "$2",
          outputMatcher: "$3",
          exitStatus: "$4"
        }
      }],
      properties: {
        id: {
          description: localize(
            "vscode.extension.contributes.terminalQuickFixes.id",
            "The ID of the quick fix provider"
          ),
          type: "string"
        },
        commandLineMatcher: {
          description: localize(
            "vscode.extension.contributes.terminalQuickFixes.commandLineMatcher",
            "A regular expression or string to test the command line against"
          ),
          type: "string"
        },
        outputMatcher: {
          markdownDescription: localize(
            "vscode.extension.contributes.terminalQuickFixes.outputMatcher",
            "A regular expression or string to match a single line of the output against, which provides groups to be referenced in terminalCommand and uri.\n\nFor example:\n\n `lineMatcher: /git push --set-upstream origin (?<branchName>[^s]+)/;`\n\n`terminalCommand: 'git push --set-upstream origin ${group:branchName}';`\n"
          ),
          type: "object",
          required: ["lineMatcher", "anchor", "offset", "length"],
          properties: {
            lineMatcher: {
              description: "A regular expression or string to test the command line against",
              type: "string"
            },
            anchor: {
              description: "Where the search should begin in the buffer",
              enum: ["top", "bottom"]
            },
            offset: {
              description: "The number of lines vertically from the anchor in the buffer to start matching against",
              type: "number"
            },
            length: {
              description: "The number of rows to match against, this should be as small as possible for performance reasons",
              type: "number"
            }
          }
        },
        commandExitResult: {
          description: localize(
            "vscode.extension.contributes.terminalQuickFixes.commandExitResult",
            "The command exit result to match on"
          ),
          enum: ["success", "error"],
          enumDescriptions: [
            "The command exited with an exit code of zero.",
            "The command exited with a non-zero exit code."
          ]
        }
      }
    }
  }
});
var css$3 = ".monaco-workbench .xterm-viewport{-webkit-text-fill-color:transparent;-webkit-background-clip:text;background-clip:text;scrollbar-width:thin;transition:background-color .8s linear}.monaco-workbench .xterm-viewport::-webkit-scrollbar{width:10px}.monaco-workbench .xterm-viewport::-webkit-scrollbar-track{opacity:0}.monaco-workbench .xterm-viewport::-webkit-scrollbar-thumb{background-color:inherit;min-height:20px}.monaco-workbench .force-scrollbar .xterm .xterm-viewport,.monaco-workbench .xterm.focus .xterm-viewport,.monaco-workbench .xterm:focus .xterm-viewport,.monaco-workbench .xterm:hover .xterm-viewport{cursor:default;transition:opacity .1s linear}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:hover{transition:opacity 0ms linear}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:window-inactive{background-color:inherit}";
n(css$3, {});
var css$2 = '.monaco-workbench .pane-body.integrated-terminal{align-content:flex-start;align-items:baseline;background-color:transparent!important;display:flex;flex-direction:column;position:relative;user-select:auto;-webkit-user-select:initial;z-index:0}.terminal-command-decoration.hide{visibility:hidden}.monaco-workbench .part.panel .pane-body.integrated-terminal .terminal-outer-container{background-color:var(--vscode-terminal-background,--vscode-panel-background)}.monaco-workbench .pane-body.integrated-terminal .terminal-group,.monaco-workbench .pane-body.integrated-terminal .terminal-groups-container,.monaco-workbench .pane-body.integrated-terminal .terminal-outer-container,.monaco-workbench .pane-body.integrated-terminal .terminal-split-pane,.monaco-workbench .terminal-editor .terminal-outer-container,.monaco-workbench .terminal-editor .terminal-split-pane{height:100%}.monaco-workbench .part.auxiliarybar .pane-body.integrated-terminal .terminal-outer-container,.monaco-workbench .part.sidebar .pane-body.integrated-terminal .terminal-outer-container{background-color:var(--vscode-terminal-background,--vscode-sideBar-background)}.monaco-workbench .pane-body.integrated-terminal .split-view-view:not(:first-child),.monaco-workbench .pane-body.integrated-terminal .tabs-container{border-color:var(--vscode-terminal-border)}.monaco-workbench .pane-body.integrated-terminal .terminal-drop-overlay{background-color:var(--vscode-terminal-dropBackground,--vscode-editorGroup-dropBackground)}.monaco-workbench .pane-body.integrated-terminal .terminal-tabs-entry.is-active:before{background-color:var(--vscode-terminal-tab-activeBorder)}.monaco-workbench .terminal-editor .xterm textarea:focus{opacity:0!important;outline:0!important}.monaco-workbench .terminal-tab:before{font-family:codicon!important;font-size:16px!important}.monaco-workbench .terminal-tab:not(.terminal-uri-icon):before{background-image:none!important}.monaco-workbench .terminal-editor .terminal-wrapper{background-color:var(--vscode-terminal-background,--vscode-editorPane-background)}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper,.monaco-workbench .terminal-editor .terminal-wrapper{box-sizing:border-box;display:block;height:100%}.monaco-workbench .xterm{padding:0 10px 2px}.monaco-workbench .pane-body.integrated-terminal .xterm,.monaco-workbench .terminal-editor .xterm{bottom:0;left:0;position:absolute;right:0}.terminal-side-view .terminal.xterm{top:0}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper.fixed-dims .xterm,.monaco-workbench .terminal-editor .terminal-wrapper.fixed-dims .xterm{position:static}.monaco-workbench .pane-body.integrated-terminal .xterm-viewport,.monaco-workbench .terminal-editor .xterm-viewport{z-index:30}.monaco-workbench .pane-body.integrated-terminal .xterm-decoration-overview-ruler,.monaco-workbench .terminal-editor .xterm-decoration-overview-ruler{pointer-events:none;z-index:31}.monaco-workbench .pane-body.integrated-terminal .xterm-screen,.monaco-workbench .terminal-editor .xterm-screen{z-index:31}.xterm .xterm-screen{cursor:text}.monaco-workbench .simple-find-part-wrapper.result-count{z-index:33!important}.xterm .xterm-accessibility{pointer-events:none;z-index:32!important}.xterm.enable-mouse-events .xterm-screen{cursor:default}.xterm.xterm-cursor-pointer .xterm-screen{cursor:pointer}.xterm.column-select.focus .xterm-screen{cursor:crosshair}.integrated-terminal.shell-integration .xterm,.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.horizontal .split-view-view:first-child .xterm,.monaco-workbench .terminal-editor .xterm{padding-left:20px!important}.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.horizontal .split-view-view:last-child .xterm,.monaco-workbench .terminal-editor .terminal-group .monaco-split-view2.horizontal .split-view-view:last-child .xterm{padding-right:20px}.monaco-workbench .pane-body.integrated-terminal .xterm a:not(.xterm-invalid-link),.monaco-workbench .terminal-editor .xterm a:not(.xterm-invalid-link){position:relative}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper>div,.monaco-workbench .terminal-editor .terminal-wrapper>div{height:100%}.monaco-workbench .pane-body.integrated-terminal .xterm-viewport,.monaco-workbench .terminal-editor .xterm-viewport{box-sizing:border-box}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper.fixed-dims,.monaco-workbench .terminal-editor .terminal-wrapper.fixed-dims{position:relative}.monaco-workbench .pane-body.integrated-terminal .terminal-wrapper:not(.fixed-dims) .xterm-viewport,.monaco-workbench .terminal-editor .terminal-wrapper:not(.fixed-dims) .xterm-viewport{width:auto!important}.monaco-workbench .pane-body.integrated-terminal{font-variant-ligatures:none}.monaco-workbench .pane-body.integrated-terminal .split-view-view{box-sizing:border-box;overflow:hidden}.monaco-workbench .pane-body.integrated-terminal .split-view-view:first-child .tabs-container{border-right-style:solid;border-right-width:1px}.monaco-workbench .pane-body.integrated-terminal .split-view-view:last-child .tabs-container,.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.horizontal .split-view-view:not(:first-child){border-left-style:solid;border-left-width:1px}.monaco-workbench .pane-body.integrated-terminal .terminal-group .monaco-split-view2.vertical .split-view-view:not(:first-child){border-top-style:solid;border-top-width:1px}.monaco-workbench .pane-body.integrated-terminal .terminal-groups-container.alt-active .xterm{cursor:default}.monaco-workbench .pane-body.integrated-terminal .xterm{user-select:none;-webkit-user-select:none}.monaco-workbench .pane-body.integrated-terminal .monaco-split-view2.vertical .split-view-view:not(:last-child) .xterm{bottom:auto;top:0}.monaco-workbench .pane-body.integrated-terminal .xterm:focus{outline:none}.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm:focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm:focus:before{border:1px solid;bottom:0;content:"";display:block;left:0;pointer-events:none;position:absolute;right:0;top:0;z-index:32}.monaco-workbench.hc-black .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm.focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm:focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm.focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .monaco-split-view2.horizontal .split-view-view:not(:only-child) .xterm:focus:before{right:0}.monaco-workbench .pane-body.integrated-terminal .xterm .xterm-helpers{position:absolute;top:0}.monaco-workbench .xterm .xterm-helper-textarea:focus{opacity:0!important}.monaco-workbench.hc-black.mac .pane-body.integrated-terminal .terminal-groups-container:not(.alt-active) .terminal:not(.enable-mouse-events),.monaco-workbench.vs-dark.mac .pane-body.integrated-terminal .terminal-groups-container:not(.alt-active) .terminal:not(.enable-mouse-events){cursor:-webkit-image-set(url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAL0lEQVQoz2NgCD3x//9/BhBYBWdhgFVAiVW4JBFKGIa4AqD0//9D3pt4I4tAdAMAHTQ/j5Zom30AAAAASUVORK5CYII=") 1x,url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAz0lEQVRIx2NgYGBY/R8I/vx5eelX3n82IJ9FxGf6tksvf/8FiTMQAcAGQMDvSwu09abffY8QYSAScNk45G198eX//yev73/4///701eh//kZSARckrNBRvz//+8+6ZohwCzjGNjdgQxkAg7B9WADeBjIBqtJCbhRA0YNoIkBSNmaPEMoNmA0FkYNoFKhapJ6FGyAH3nauaSmPfwI0v/3OukVi0CIZ+F25KrtYcx/CTIy0e+rC7R1Z4KMICVTQQ14feVXIbR695u14+Ir4gwAAD49E54wc1kWAAAAAElFTkSuQmCC") 2x) 5 8,text}.xterm .xterm-cursor-pointer,.xterm.xterm-cursor-pointer{cursor:pointer!important}.monaco-pane-view .pane>.pane-header .monaco-action-bar .switch-terminal,.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal,.part.panel>.title>.title-actions .switch-terminal>.monaco-select-box{border-style:solid;border-width:1px}.xterm-screen .xterm-decoration-container .xterm-decoration.quick-fix{z-index:7}.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal{align-items:center;display:flex;flex-shrink:1;font-size:11px;height:20px;margin-right:.3em;margin-top:7px}.monaco-workbench.mac .part.sidebar>.title>.title-actions .switch-terminal{border-radius:4px}.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal>.monaco-select-box{background-color:unset!important;border:none!important;display:block!important}.monaco-pane-view .pane>.pane-header .monaco-action-bar .switch-terminal.action-item.select-container{border:none!important}.monaco-workbench .part.sidebar>.title>.title-actions .switch-terminal>.monaco-select-box{padding:0 22px 0 6px}.monaco-workbench .pane-body.integrated-terminal .tabs-container{display:flex;flex-direction:column;height:100%}.monaco-workbench .terminal-overflow-guard{height:100%;overflow:hidden;position:relative}.monaco-workbench .pane-body.integrated-terminal .tabs-list-container{height:100%;overflow:hidden}.monaco-workbench .pane-body.integrated-terminal .tabs-container>.monaco-toolbar{margin:auto;padding:4px 0 2px}.monaco-workbench .pane-body.integrated-terminal .terminal-tabs-entry.is-active:before{bottom:0;content:"";display:block;left:0;position:absolute;top:0;width:1px}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text>.monaco-toolbar{margin:0;padding:4px 7px 2px;text-align:left}.monaco-workbench .pane-body.integrated-terminal .tabs-list{height:100%}.monaco-workbench .pane-body.integrated-terminal .tabs-list .terminal-tabs-entry{text-align:center}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text .tabs-list .terminal-tabs-entry{padding-left:10px;padding-right:10px;text-align:left}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text .tabs-list .terminal-tabs-entry .monaco-icon-label:after{margin-right:0}.monaco-workbench .pane-body.integrated-terminal .tabs-container:not(.has-text) .terminal-tabs-entry .codicon{color:inherit}.monaco-workbench .pane-body.integrated-terminal .tabs-container:not(.has-text) .monaco-icon-description-container{display:none}.monaco-workbench .pane-body.integrated-terminal .tabs-list .codicon{vertical-align:text-bottom}.monaco-workbench .pane-body.integrated-terminal .tabs-list .actions,.monaco-workbench .pane-body.integrated-terminal .tabs-list .editable-tab .monaco-icon-name-container{display:none}.monaco-workbench .pane-body.integrated-terminal .tabs-list .actions .action-label{padding:2px}.monaco-workbench .pane-body.integrated-terminal .tabs-list .monaco-list-row:hover .actions,.monaco-workbench .pane-body.integrated-terminal .tabs-list:focus-within .monaco-list-row.focused .actions,.monaco-workbench .pane-body.integrated-terminal .tabs-list:focus-within .monaco-list-row.selected .actions{display:block}.monaco-action-bar .action-item .single-terminal-tab{align-items:center;display:flex!important}.monaco-action-bar .action-item .single-terminal-tab .codicon:first-child{margin-right:4px}.monaco-action-bar .action-item .single-terminal-tab .codicon:nth-child(2){color:inherit;margin-left:4px}.monaco-workbench .pane-body.integrated-terminal .tabs-container.has-text .tabs-list .terminal-tabs-entry .uri-icon{background-repeat:no-repeat;background-size:contain;height:100%;margin-right:4px}.monaco-action-bar .terminal-uri-icon.single-terminal-tab.action-label .codicon,.monaco-workbench .terminal-uri-icon .monaco-highlighted-label .codicon{background-size:16px}.monaco-action-bar .terminal-uri-icon.single-terminal-tab.action-label:not(.alt-command) .codicon:before,.monaco-workbench .terminal-uri-icon .monaco-highlighted-label .codicon:before{content:"";display:inline-block;height:16px;width:16px}.monaco-workbench .pane-body.integrated-terminal .terminal-drop-overlay{bottom:0;display:block;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;z-index:34}.monaco-workbench:not(.reduce-motion) .pane-body.integrated-terminal .terminal-drop-overlay{transition:left 70ms ease-out,right 70ms ease-out,top 70ms ease-out,bottom 70ms ease-out,opacity .15s ease-out}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.horizontal .terminal-drop-overlay.drop-before{right:50%}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.horizontal .terminal-drop-overlay.drop-after{left:50%}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.vertical .terminal-drop-overlay.drop-before{bottom:50%}.monaco-workbench .pane-body.integrated-terminal .terminal-group>.monaco-split-view2.vertical .terminal-drop-overlay.drop-after{top:50%}.monaco-workbench .terminal .terminal-command-decoration:not(.default):hover{background-color:var(--vscode-toolbar-hoverBackground);border-radius:5px;cursor:pointer}.monaco-workbench .terminal .terminal-command-decoration{color:var(--vscode-terminalCommandDecoration-successBackground)}.monaco-workbench .terminal .terminal-command-decoration.error{color:var(--vscode-terminalCommandDecoration-errorBackground)}.monaco-workbench .terminal .terminal-command-decoration.default{color:var(--vscode-terminalCommandDecoration-defaultBackground);pointer-events:none}.monaco-workbench .terminal .terminal-command-decoration.quick-fix{background-color:var(--vscode-terminal-background,--vscode-panel-background);color:var(--vscode-editorLightBulb-foreground)!important}.terminal-scroll-highlight{border-left:5px solid #fff;border-left-width:5px!important;left:0;pointer-events:none;right:0}.terminal-scroll-highlight-outline{border:1px solid #fff;pointer-events:none}.terminal-scroll-highlight{border-color:var(--vscode-focusBorder)}.hc-black .xterm-find-result-decoration,.hc-light .xterm-find-result-decoration{outline-style:dotted!important;outline-style:solid!important}.xterm-find-active-result-decoration{outline-style:solid!important;outline-width:2px!important;z-index:7!important}.monaco-workbench.hc-black .editor-instance .xterm.focus:before,.monaco-workbench.hc-black .editor-instance .xterm:focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-black .pane-body.integrated-terminal .xterm:focus:before,.monaco-workbench.hc-light .editor-instance .xterm.focus:before,.monaco-workbench.hc-light .editor-instance .xterm:focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm.focus:before,.monaco-workbench.hc-light .pane-body.integrated-terminal .xterm:focus:before{border-color:var(--vscode-contrastActiveBorder)}.monaco-workbench .integrated-terminal .hoverHighlight{background-color:var(--vscode-terminal-hoverHighlightBackground)}.force-scrollbar .xterm .xterm-viewport,.monaco-workbench .xterm.focus .xterm-viewport,.monaco-workbench .xterm:focus .xterm-viewport,.monaco-workbench .xterm:hover .xterm-viewport{background-color:var(--vscode-scrollbarSlider-background)!important}.monaco-workbench .xterm-viewport{scrollbar-color:var(--vscode-scrollbarSlider-background) transparent}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:hover{background-color:var(--vscode-scrollbarSlider-hoverBackground)}.monaco-workbench .xterm-viewport:hover{scrollbar-color:var(--vscode-scrollbarSlider-hoverBackground) transparent}.monaco-workbench .xterm .xterm-viewport::-webkit-scrollbar-thumb:active{background-color:var(--vscode-scrollbarSlider-activeBackground)}.monaco-workbench .terminal-accessible-widget{bottom:0;cursor:default;left:10px;opacity:0;overflow:initial;overflow-x:initial;padding:0;pointer-events:none;position:absolute;right:0;top:0;z-index:0}.monaco-workbench .terminal-accessible-widget div{white-space:pre-wrap}.monaco-workbench .terminal-accessible-widget.active,.monaco-workbench .terminal-accessible-widget.focus-within{background-color:var(--vscode-terminal-background,--vscode-panel-background);opacity:1;pointer-events:all;z-index:33}.monaco-workbench .xterm.terminal.hide{visibility:hidden}';
n(css$2, {});
var css$1 = ".monaco-workbench .terminal-widget-container{bottom:0;left:0;overflow:visible;position:absolute;right:0;top:0}.monaco-workbench .terminal-overlay-widget{bottom:0;color:#3794ff;left:0;position:absolute}.monaco-workbench .terminal-hover-target{position:absolute;z-index:33}.monaco-workbench .terminal-env-var-info{height:28px;opacity:.5;position:absolute;right:10px;text-align:center;top:0;width:28px;z-index:32}.monaco-workbench .terminal-env-var-info.requires-action,.monaco-workbench .terminal-env-var-info:hover{opacity:1}.monaco-workbench .terminal-env-var-info.codicon{line-height:28px}";
n(css$1, {});
var css = ".xterm{cursor:text;position:relative;user-select:none;-ms-user-select:none;-webkit-user-select:none}.xterm.focus,.xterm:focus{outline:none}.xterm .xterm-helpers{position:absolute;top:0;z-index:5}.xterm .xterm-helper-textarea{border:0;height:0;left:-9999em;margin:0;opacity:0;overflow:hidden;padding:0;position:absolute;resize:none;top:0;white-space:nowrap;width:0;z-index:-5}.xterm .composition-view{background:#000;color:#fff;display:none;position:absolute;white-space:nowrap;z-index:1}.xterm .composition-view.active{display:block}.xterm .xterm-viewport{background-color:#000;bottom:0;cursor:default;left:0;overflow-y:scroll;position:absolute;right:0;top:0}.xterm .xterm-screen{position:relative}.xterm .xterm-screen canvas{left:0;position:absolute;top:0}.xterm .xterm-scroll-area{visibility:hidden}.xterm-char-measure-element{display:inline-block;left:-9999em;line-height:normal;position:absolute;top:0;visibility:hidden}.xterm.enable-mouse-events{cursor:default}.xterm .xterm-cursor-pointer,.xterm.xterm-cursor-pointer{cursor:pointer}.xterm.column-select.focus{cursor:crosshair}.xterm .xterm-accessibility,.xterm .xterm-message{bottom:0;color:transparent;left:0;pointer-events:none;position:absolute;right:0;top:0;z-index:10}.xterm .live-region{height:1px;left:-9999px;overflow:hidden;position:absolute;width:1px}.xterm-dim{opacity:1!important}.xterm-underline-1{text-decoration:underline}.xterm-underline-2{text-decoration:double underline}.xterm-underline-3{text-decoration:wavy underline}.xterm-underline-4{text-decoration:dotted underline}.xterm-underline-5{text-decoration:dashed underline}.xterm-overline{text-decoration:overline}.xterm-overline.xterm-underline-1{text-decoration:overline underline}.xterm-overline.xterm-underline-2{text-decoration:overline double underline}.xterm-overline.xterm-underline-3{text-decoration:overline wavy underline}.xterm-overline.xterm-underline-4{text-decoration:overline dotted underline}.xterm-overline.xterm-underline-5{text-decoration:overline dashed underline}.xterm-strikethrough{text-decoration:line-through}.xterm-screen .xterm-decoration-container .xterm-decoration{position:absolute;z-index:6}.xterm-screen .xterm-decoration-container .xterm-decoration.xterm-decoration-top-layer{z-index:7}.xterm-decoration-overview-ruler{pointer-events:none;position:absolute;right:0;top:0;z-index:8}.xterm-decoration-top{position:relative;z-index:2}";
n(css, {});
function getInstanceHoverInfo(instance) {
  var _a2;
  let statusString = "";
  const statuses = instance.statusList.statuses;
  const actions = [];
  for (const status of statuses) {
    statusString += `

---

${status.icon ? `$(${(_a2 = status.icon) == null ? void 0 : _a2.id}) ` : ""}${status.tooltip || status.id}`;
    if (status.hoverActions) {
      actions.push(...status.hoverActions);
    }
  }
  const shellProcessString = getShellProcessTooltip(instance, true);
  const shellIntegrationString = getShellIntegrationTooltip(instance, true);
  const content = new MarkdownString(
    instance.title + shellProcessString + shellIntegrationString + statusString,
    { supportThemeIcons: true }
  );
  return { content, actions };
}
function getShellIntegrationTooltip(instance, markdown) {
  const shellIntegrationCapabilities = [];
  if (instance.capabilities.has(2)) {
    shellIntegrationCapabilities.push(2);
  }
  if (instance.capabilities.has(0)) {
    shellIntegrationCapabilities.push(0);
  }
  let shellIntegrationString = "";
  if (shellIntegrationCapabilities.length > 0) {
    shellIntegrationString += `${markdown ? "\n\n---\n\n" : "\n\n"}${localize("shellIntegration.enabled", "Shell integration activated")}`;
  } else {
    if (instance.shellLaunchConfig.ignoreShellIntegration) {
      shellIntegrationString += `${markdown ? "\n\n---\n\n" : "\n\n"}${localize(
        "launchFailed.exitCodeOnlyShellIntegration",
        "The terminal process failed to launch. Disabling shell integration with terminal.integrated.shellIntegration.enabled might help."
      )}`;
    } else {
      if (instance.usedShellIntegrationInjection) {
        shellIntegrationString += `${markdown ? "\n\n---\n\n" : "\n\n"}${localize(
          "shellIntegration.activationFailed",
          "Shell integration failed to activate"
        )}`;
      }
    }
  }
  return shellIntegrationString;
}
function getShellProcessTooltip(instance, markdown) {
  const lines = [];
  if (instance.processId) {
    lines.push(localize(
      { key: "shellProcessTooltip.processId", comment: [`The first arg is "PID" which shouldn't be translated`] },
      "Process ID ({0}): {1}",
      "PID",
      instance.processId
    ) + "\n");
  }
  if (instance.shellLaunchConfig.executable) {
    let commandLine = instance.shellLaunchConfig.executable;
    const args = asArray(instance.injectedArgs || instance.shellLaunchConfig.args || []).map((x) => `'${x}'`).join(" ");
    if (args) {
      commandLine += ` ${args}`;
    }
    lines.push(localize("shellProcessTooltip.commandLine", "Command line: {0}", commandLine));
  }
  return lines.length ? `${markdown ? "\n\n---\n\n" : "\n\n"}${lines.join("\n")}` : "";
}
const $$1 = $$3;
let TerminalTabList = class TerminalTabList2 extends WorkbenchList {
  constructor(container, contextKeyService, listService, themeService, _configurationService, _terminalService, _terminalGroupService, instantiationService, decorationsService, _themeService, lifecycleService, _hoverService) {
    super("TerminalTabsList", container, {
      getHeight: () => 22,
      getTemplateId: () => "terminal.tabs"
    }, [instantiationService.createInstance(TerminalTabsRenderer, container, instantiationService.createInstance(ResourceLabels, DEFAULT_LABELS_CONTAINER), () => this.getSelectedElements())], {
      horizontalScrolling: false,
      supportDynamicHeights: false,
      selectionNavigation: true,
      identityProvider: {
        getId: (e) => e == null ? void 0 : e.instanceId
      },
      accessibilityProvider: instantiationService.createInstance(TerminalTabsAccessibilityProvider),
      smoothScrolling: _configurationService.getValue("workbench.list.smoothScrolling"),
      multipleSelectionSupport: true,
      paddingBottom: 22,
      dnd: instantiationService.createInstance(TerminalTabsDragAndDrop),
      openOnSingleClick: true
    }, contextKeyService, listService, _configurationService, instantiationService);
    this._configurationService = _configurationService;
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._themeService = _themeService;
    this._hoverService = _hoverService;
    const instanceDisposables = [
      this._terminalGroupService.onDidChangeInstances(() => this.refresh()),
      this._terminalGroupService.onDidChangeGroups(() => this.refresh()),
      this._terminalGroupService.onDidShow(() => this.refresh()),
      this._terminalGroupService.onDidChangeInstanceCapability(() => this.refresh()),
      this._terminalService.onDidChangeInstanceTitle(() => this.refresh()),
      this._terminalService.onDidChangeInstanceIcon(() => this.refresh()),
      this._terminalService.onDidChangeInstancePrimaryStatus(() => this.refresh()),
      this._terminalService.onDidChangeConnectionState(() => this.refresh()),
      this._themeService.onDidColorThemeChange(() => this.refresh()),
      this._terminalGroupService.onDidChangeActiveInstance((e) => {
        if (e) {
          const i = this._terminalGroupService.instances.indexOf(e);
          this.setSelection([i]);
          this.reveal(i);
        }
        this.refresh();
      })
    ];
    lifecycleService.onWillShutdown((e) => {
      dispose(instanceDisposables);
    });
    this.onMouseDblClick(async (e) => {
      var _a2, _b2, _c2;
      const focus = this.getFocus();
      if (focus.length === 0) {
        const instance = await this._terminalService.createTerminal({ location: TerminalLocation.Panel });
        this._terminalGroupService.setActiveInstance(instance);
        await instance.focusWhenReady();
      }
      if (((_a2 = this._terminalService.getEditingTerminal()) == null ? void 0 : _a2.instanceId) === ((_b2 = e.element) == null ? void 0 : _b2.instanceId)) {
        return;
      }
      if (this._getFocusMode() === "doubleClick" && this.getFocus().length === 1) {
        (_c2 = e.element) == null ? void 0 : _c2.focus(true);
      }
    });
    this.onMouseClick(async (e) => {
      var _a2, _b2, _c2;
      if (((_a2 = this._terminalService.getEditingTerminal()) == null ? void 0 : _a2.instanceId) === ((_b2 = e.element) == null ? void 0 : _b2.instanceId)) {
        return;
      }
      if (e.browserEvent.altKey && e.element) {
        await this._terminalService.createTerminal({ location: { parentTerminal: e.element } });
      } else if (this._getFocusMode() === "singleClick") {
        if (this.getSelection().length <= 1) {
          (_c2 = e.element) == null ? void 0 : _c2.focus(true);
        }
      }
    });
    this.onContextMenu((e) => {
      if (!e.element) {
        this.setSelection([]);
        return;
      }
      const selection = this.getSelectedElements();
      if (!selection || !selection.find((s) => e.element === s)) {
        this.setFocus(e.index !== void 0 ? [e.index] : []);
      }
    });
    this._terminalTabsSingleSelectedContextKey = TerminalContextKeys.tabsSingularSelection.bindTo(contextKeyService);
    this._isSplitContextKey = TerminalContextKeys.splitTerminal.bindTo(contextKeyService);
    this.onDidChangeSelection((e) => this._updateContextKey());
    this.onDidChangeFocus(() => this._updateContextKey());
    this.onDidOpen(async (e) => {
      const instance = e.element;
      if (!instance) {
        return;
      }
      this._terminalGroupService.setActiveInstance(instance);
      if (!e.editorOptions.preserveFocus) {
        await instance.focusWhenReady();
      }
    });
    if (!this._decorationsProvider) {
      this._decorationsProvider = instantiationService.createInstance(TabDecorationsProvider);
      decorationsService.registerDecorationsProvider(this._decorationsProvider);
    }
    this.refresh();
  }
  _getFocusMode() {
    return this._configurationService.getValue("terminal.integrated.tabs.focusMode");
  }
  refresh(cancelEditing = true) {
    if (cancelEditing && this._terminalService.isEditable(void 0)) {
      this.domFocus();
    }
    this.splice(0, this.length, this._terminalGroupService.instances.slice());
  }
  focusHover() {
    const instance = this.getSelectedElements()[0];
    if (!instance) {
      return;
    }
    this._hoverService.showHover({
      ...getInstanceHoverInfo(instance),
      target: this.getHTMLElement(),
      trapFocus: true
    }, true);
  }
  _updateContextKey() {
    this._terminalTabsSingleSelectedContextKey.set(this.getSelectedElements().length === 1);
    const instance = this.getFocusedElements();
    this._isSplitContextKey.set(instance.length > 0 && this._terminalGroupService.instanceIsSplit(instance[0]));
  }
};
TerminalTabList = __decorate([
  __param(1, IContextKeyService),
  __param(2, IListService),
  __param(3, IThemeService),
  __param(4, IConfigurationService),
  __param(5, ITerminalService),
  __param(6, ITerminalGroupService),
  __param(7, IInstantiationService),
  __param(8, IDecorationsService),
  __param(9, IThemeService),
  __param(10, ILifecycleService),
  __param(11, IHoverService)
], TerminalTabList);
let TerminalTabsRenderer = class TerminalTabsRenderer2 {
  constructor(_container, _labels, _getSelection, _instantiationService, _terminalService, _terminalGroupService, _hoverService, _configurationService, _keybindingService, _listService, _themeService, _contextViewService) {
    this._container = _container;
    this._labels = _labels;
    this._getSelection = _getSelection;
    this._instantiationService = _instantiationService;
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._hoverService = _hoverService;
    this._configurationService = _configurationService;
    this._keybindingService = _keybindingService;
    this._listService = _listService;
    this._themeService = _themeService;
    this._contextViewService = _contextViewService;
    this.templateId = "terminal.tabs";
  }
  renderTemplate(container) {
    const element = append(container, $$1(".terminal-tabs-entry"));
    const context = {};
    const label = this._labels.create(element, {
      supportHighlights: true,
      supportDescriptionHighlights: true,
      supportIcons: true,
      hoverDelegate: {
        delay: this._configurationService.getValue("workbench.hover.delay"),
        showHover: (options) => {
          return this._hoverService.showHover({
            ...options,
            actions: context.hoverActions,
            hideOnHover: true
          });
        }
      }
    });
    const actionsContainer = append(label.element, $$1(".actions"));
    const actionBar = new ActionBar(actionsContainer, {
      actionViewItemProvider: (action) => action instanceof MenuItemAction ? this._instantiationService.createInstance(MenuEntryActionViewItem, action, void 0) : void 0
    });
    return {
      element,
      label,
      actionBar,
      context,
      elementDisposables: new DisposableStore()
    };
  }
  shouldHideText() {
    return this._container ? this._container.clientWidth < 63 : false;
  }
  shouldHideActionBar() {
    return this._container ? this._container.clientWidth <= 105 : false;
  }
  renderElement(instance, index, template2) {
    var _a2;
    const hasText = !this.shouldHideText();
    const group = this._terminalGroupService.getGroupForInstance(instance);
    if (!group) {
      throw new Error(`Could not find group for instance "${instance.instanceId}"`);
    }
    template2.element.classList.toggle("has-text", hasText);
    template2.element.classList.toggle("is-active", this._terminalGroupService.activeInstance === instance);
    let prefix = "";
    if (group.terminalInstances.length > 1) {
      const terminalIndex = group.terminalInstances.indexOf(instance);
      if (terminalIndex === 0) {
        prefix = `┌ `;
      } else if (terminalIndex === group.terminalInstances.length - 1) {
        prefix = `└ `;
      } else {
        prefix = `├ `;
      }
    }
    const hoverInfo = getInstanceHoverInfo(instance);
    template2.context.hoverActions = hoverInfo.actions;
    const iconId = this._instantiationService.invokeFunction(getIconId, instance);
    const hasActionbar = !this.shouldHideActionBar();
    let label = "";
    if (!hasText) {
      const primaryStatus = instance.statusList.primary;
      if (primaryStatus && primaryStatus.severity > Severity$1.Ignore) {
        label = `${prefix}$(${((_a2 = primaryStatus.icon) == null ? void 0 : _a2.id) || iconId})`;
      } else {
        label = `${prefix}$(${iconId})`;
      }
    } else {
      this.fillActionBar(instance, template2);
      label = prefix;
      if (instance.icon) {
        label += `$(${iconId}) ${instance.title}`;
      }
    }
    if (!hasActionbar) {
      template2.actionBar.clear();
    }
    template2.elementDisposables.add(addDisposableListener(template2.element, EventType.AUXCLICK, (e) => {
      e.stopImmediatePropagation();
      if (e.button === 1) {
        this._terminalService.safeDisposeTerminal(instance);
      }
    }));
    const extraClasses = [];
    const colorClass = getColorClass(instance);
    if (colorClass) {
      extraClasses.push(colorClass);
    }
    const uriClasses = getUriClasses(instance, this._themeService.getColorTheme().type);
    if (uriClasses) {
      extraClasses.push(...uriClasses);
    }
    template2.label.setResource({
      resource: instance.resource,
      name: label,
      description: hasText ? instance.description : void 0
    }, {
      fileDecorations: {
        colors: true,
        badges: hasText
      },
      title: {
        markdown: hoverInfo.content,
        markdownNotSupportedFallback: void 0
      },
      extraClasses
    });
    const editableData = this._terminalService.getEditableData(instance);
    template2.label.element.classList.toggle("editable-tab", !!editableData);
    if (editableData) {
      template2.elementDisposables.add(this._renderInputBox(template2.label.element.querySelector(".monaco-icon-label-container"), instance, editableData));
      template2.actionBar.clear();
    }
  }
  _renderInputBox(container, instance, editableData) {
    const value = instance.title || "";
    const inputBox = new InputBox(container, this._contextViewService, {
      validationOptions: {
        validation: (value2) => {
          const message = editableData.validationMessage(value2);
          if (!message || message.severity !== Severity$1.Error) {
            return null;
          }
          return {
            content: message.content,
            formatContent: true,
            type: 3
          };
        }
      },
      ariaLabel: localize(
        "terminalInputAriaLabel",
        "Type terminal name. Press Enter to confirm or Escape to cancel."
      ),
      inputBoxStyles: defaultInputBoxStyles
    });
    inputBox.element.style.height = "22px";
    inputBox.value = value;
    inputBox.focus();
    inputBox.select({ start: 0, end: value.length });
    const done = once((success, finishEditing) => {
      inputBox.element.style.display = "none";
      const value2 = inputBox.value;
      dispose(toDispose);
      inputBox.element.remove();
      if (finishEditing) {
        editableData.onFinish(value2, success);
      }
    });
    const showInputBoxNotification = () => {
      if (inputBox.isInputValid()) {
        const message = editableData.validationMessage(inputBox.value);
        if (message) {
          inputBox.showMessage({
            content: message.content,
            formatContent: true,
            type: message.severity === Severity$1.Info ? 1 : message.severity === Severity$1.Warning ? 2 : 3
          });
        } else {
          inputBox.hideMessage();
        }
      }
    };
    showInputBoxNotification();
    const toDispose = [
      inputBox,
      addStandardDisposableListener(inputBox.inputElement, EventType.KEY_DOWN, (e) => {
        e.stopPropagation();
        if (e.equals(3)) {
          done(inputBox.isInputValid(), true);
        } else if (e.equals(9)) {
          done(false, true);
        }
      }),
      addStandardDisposableListener(inputBox.inputElement, EventType.KEY_UP, (e) => {
        showInputBoxNotification();
      }),
      addDisposableListener(inputBox.inputElement, EventType.BLUR, () => {
        done(inputBox.isInputValid(), true);
      })
    ];
    return toDisposable(() => {
      done(false, false);
    });
  }
  disposeElement(instance, index, templateData) {
    templateData.elementDisposables.clear();
    templateData.actionBar.clear();
  }
  disposeTemplate(templateData) {
    templateData.elementDisposables.dispose();
    templateData.label.dispose();
    templateData.actionBar.dispose();
  }
  fillActionBar(instance, template2) {
    var _a2;
    const actions = [
      new Action(
        "workbench.action.terminal.splitInstance",
        terminalStrings.split.short,
        ThemeIcon.asClassName(Codicon.splitHorizontal),
        true,
        async () => {
          this._runForSelectionOrInstance(instance, async (e) => {
            this._terminalService.createTerminal({ location: { parentTerminal: e } });
          });
        }
      ),
      new Action(
        "workbench.action.terminal.killInstance",
        terminalStrings.kill.short,
        ThemeIcon.asClassName(Codicon.trashcan),
        true,
        async () => {
          this._runForSelectionOrInstance(instance, (e) => this._terminalService.safeDisposeTerminal(e));
        }
      )
    ];
    template2.actionBar.clear();
    for (const action of actions) {
      template2.actionBar.push(action, { icon: true, label: false, keybinding: (_a2 = this._keybindingService.lookupKeybinding(action.id)) == null ? void 0 : _a2.getLabel() });
    }
  }
  _runForSelectionOrInstance(instance, callback) {
    var _a2;
    const selection = this._getSelection();
    if (selection.includes(instance)) {
      for (const s of selection) {
        if (s) {
          callback(s);
        }
      }
    } else {
      callback(instance);
    }
    this._terminalGroupService.focusTabs();
    (_a2 = this._listService.lastFocusedList) == null ? void 0 : _a2.focusNext();
  }
};
TerminalTabsRenderer = __decorate([
  __param(3, IInstantiationService),
  __param(4, ITerminalService),
  __param(5, ITerminalGroupService),
  __param(6, IHoverService),
  __param(7, IConfigurationService),
  __param(8, IKeybindingService),
  __param(9, IListService),
  __param(10, IThemeService),
  __param(11, IContextViewService)
], TerminalTabsRenderer);
let TerminalTabsAccessibilityProvider = class TerminalTabsAccessibilityProvider2 {
  constructor(_terminalGroupService) {
    this._terminalGroupService = _terminalGroupService;
  }
  getWidgetAriaLabel() {
    return localize("terminal.tabs", "Terminal tabs");
  }
  getAriaLabel(instance) {
    var _a2;
    let ariaLabel = "";
    const tab = this._terminalGroupService.getGroupForInstance(instance);
    if (tab && ((_a2 = tab.terminalInstances) == null ? void 0 : _a2.length) > 1) {
      const terminalIndex = tab.terminalInstances.indexOf(instance);
      ariaLabel = localize({
        key: "splitTerminalAriaLabel",
        comment: [
          `The terminal's ID`,
          `The terminal's title`,
          `The terminal's split number`,
          `The terminal group's total split number`
        ]
      }, "Terminal {0} {1}, split {2} of {3}", instance.instanceId, instance.title, terminalIndex + 1, tab.terminalInstances.length);
    } else {
      ariaLabel = localize({
        key: "terminalAriaLabel",
        comment: [
          `The terminal's ID`,
          `The terminal's title`
        ]
      }, "Terminal {0} {1}", instance.instanceId, instance.title);
    }
    return ariaLabel;
  }
};
TerminalTabsAccessibilityProvider = __decorate([
  __param(0, ITerminalGroupService)
], TerminalTabsAccessibilityProvider);
let TerminalTabsDragAndDrop = class TerminalTabsDragAndDrop2 {
  constructor(_terminalService, _terminalGroupService) {
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._autoFocusDisposable = Disposable.None;
    this._primaryBackend = this._terminalService.getPrimaryBackend();
  }
  getDragURI(instance) {
    var _a2;
    if (((_a2 = this._terminalService.getEditingTerminal()) == null ? void 0 : _a2.instanceId) === instance.instanceId) {
      return null;
    }
    return instance.resource.toString();
  }
  getDragLabel(elements, originalEvent) {
    return elements.length === 1 ? elements[0].title : void 0;
  }
  onDragLeave() {
    this._autoFocusInstance = void 0;
    this._autoFocusDisposable.dispose();
    this._autoFocusDisposable = Disposable.None;
  }
  onDragStart(data, originalEvent) {
    if (!originalEvent.dataTransfer) {
      return;
    }
    const dndData = data.getData();
    if (!Array.isArray(dndData)) {
      return;
    }
    const terminals = dndData.filter((e) => "instanceId" in e);
    if (terminals.length > 0) {
      originalEvent.dataTransfer.setData("Terminals", JSON.stringify(terminals.map((e) => e.resource.toString())));
    }
  }
  onDragOver(data, targetInstance, targetIndex, originalEvent) {
    if (data instanceof NativeDragAndDropData) {
      if (!containsDragType(originalEvent, DataTransfers.FILES, DataTransfers.RESOURCES, "Terminals", CodeDataTransfers.FILES)) {
        return false;
      }
    }
    const didChangeAutoFocusInstance = this._autoFocusInstance !== targetInstance;
    if (didChangeAutoFocusInstance) {
      this._autoFocusDisposable.dispose();
      this._autoFocusInstance = targetInstance;
    }
    if (!targetInstance && !containsDragType(originalEvent, "Terminals")) {
      return data instanceof ElementsDragAndDropData;
    }
    if (didChangeAutoFocusInstance && targetInstance) {
      this._autoFocusDisposable = disposableTimeout(() => {
        this._terminalService.setActiveInstance(targetInstance);
        this._autoFocusInstance = void 0;
      }, 500);
    }
    return {
      feedback: targetIndex ? [targetIndex] : void 0,
      accept: true,
      effect: 1
    };
  }
  async drop(data, targetInstance, targetIndex, originalEvent) {
    this._autoFocusDisposable.dispose();
    this._autoFocusInstance = void 0;
    let sourceInstances;
    const promises = [];
    const resources = getTerminalResourcesFromDragEvent(originalEvent);
    if (resources) {
      for (const uri of resources) {
        const instance = this._terminalService.getInstanceFromResource(uri);
        if (instance) {
          sourceInstances = [instance];
          this._terminalService.moveToTerminalView(instance);
        } else if (this._primaryBackend) {
          const terminalIdentifier = parseTerminalUri(uri);
          if (terminalIdentifier.instanceId) {
            promises.push(this._primaryBackend.requestDetachInstance(terminalIdentifier.workspaceId, terminalIdentifier.instanceId));
          }
        }
      }
    }
    if (promises.length) {
      let processes = await Promise.all(promises);
      processes = processes.filter((p) => p !== void 0);
      let lastInstance;
      for (const attachPersistentProcess of processes) {
        lastInstance = await this._terminalService.createTerminal({ config: { attachPersistentProcess } });
      }
      if (lastInstance) {
        this._terminalService.setActiveInstance(lastInstance);
      }
      return;
    }
    if (sourceInstances === void 0) {
      if (!(data instanceof ElementsDragAndDropData)) {
        this._handleExternalDrop(targetInstance, originalEvent);
        return;
      }
      const draggedElement = data.getData();
      if (!draggedElement || !Array.isArray(draggedElement)) {
        return;
      }
      sourceInstances = [];
      for (const e of draggedElement) {
        if ("instanceId" in e) {
          sourceInstances.push(e);
        }
      }
    }
    if (!targetInstance) {
      this._terminalGroupService.moveGroupToEnd(sourceInstances[0]);
      this._terminalService.setActiveInstance(sourceInstances[0]);
      return;
    }
    let focused = false;
    for (const instance of sourceInstances) {
      this._terminalGroupService.moveGroup(instance, targetInstance);
      if (!focused) {
        this._terminalService.setActiveInstance(instance);
        focused = true;
      }
    }
  }
  async _handleExternalDrop(instance, e) {
    if (!instance || !e.dataTransfer) {
      return;
    }
    let resource;
    const rawResources = e.dataTransfer.getData(DataTransfers.RESOURCES);
    if (rawResources) {
      resource = URI.parse(JSON.parse(rawResources)[0]);
    }
    const rawCodeFiles = e.dataTransfer.getData(CodeDataTransfers.FILES);
    if (!resource && rawCodeFiles) {
      resource = URI.file(JSON.parse(rawCodeFiles)[0]);
    }
    if (!resource && e.dataTransfer.files.length > 0 && e.dataTransfer.files[0].path) {
      resource = URI.file(e.dataTransfer.files[0].path);
    }
    if (!resource) {
      return;
    }
    this._terminalService.setActiveInstance(instance);
    instance.focus();
    await instance.sendPath(resource, false);
  }
};
TerminalTabsDragAndDrop = __decorate([
  __param(0, ITerminalService),
  __param(1, ITerminalGroupService)
], TerminalTabsDragAndDrop);
let TabDecorationsProvider = class TabDecorationsProvider2 {
  constructor(_terminalService) {
    this._terminalService = _terminalService;
    this.label = localize("label", "Terminal");
    this._onDidChange = new Emitter();
    this._terminalService.onDidChangeInstancePrimaryStatus((e) => this._onDidChange.fire([e.resource]));
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  provideDecorations(resource) {
    var _a2;
    if (resource.scheme !== Schemas.vscodeTerminal) {
      return void 0;
    }
    const instance = this._terminalService.getInstanceFromResource(resource);
    if (!instance) {
      return void 0;
    }
    const primaryStatus = (_a2 = instance == null ? void 0 : instance.statusList) == null ? void 0 : _a2.primary;
    if (!(primaryStatus == null ? void 0 : primaryStatus.icon)) {
      return void 0;
    }
    return {
      color: getColorForSeverity(primaryStatus.severity),
      letter: primaryStatus.icon,
      tooltip: primaryStatus.tooltip
    };
  }
  dispose() {
    this.dispose();
  }
};
TabDecorationsProvider = __decorate([
  __param(0, ITerminalService)
], TabDecorationsProvider);
function openContextMenu(event, parent, menu, contextMenuService, extraActions) {
  const standardEvent = new StandardMouseEvent(event);
  const actions = [];
  createAndFillInContextMenuActions(menu, void 0, actions);
  if (extraActions) {
    actions.push(...extraActions);
  }
  contextMenuService.showContextMenu({
    getAnchor: () => standardEvent,
    getActions: () => actions,
    getActionsContext: () => parent
  });
}
const $ = $$3;
let TerminalTabbedView = class TerminalTabbedView2 extends Disposable {
  constructor(parentElement, _terminalService, _terminalGroupService, _instantiationService, _notificationService, _contextMenuService, _configurationService, menuService, _storageService, contextKeyService, _hoverService) {
    super();
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._instantiationService = _instantiationService;
    this._notificationService = _notificationService;
    this._contextMenuService = _contextMenuService;
    this._configurationService = _configurationService;
    this._storageService = _storageService;
    this._hoverService = _hoverService;
    this._cancelContextMenu = false;
    this._parentElement = parentElement;
    this._tabContainer = $(".tabs-container");
    const tabListContainer = $(".tabs-list-container");
    this._tabListElement = $(".tabs-list");
    tabListContainer.appendChild(this._tabListElement);
    this._tabContainer.appendChild(tabListContainer);
    this._instanceMenu = this._register(menuService.createMenu(MenuId.TerminalInstanceContext, contextKeyService));
    this._tabsListMenu = this._register(menuService.createMenu(MenuId.TerminalTabContext, contextKeyService));
    this._tabsListEmptyMenu = this._register(menuService.createMenu(MenuId.TerminalTabEmptyAreaContext, contextKeyService));
    this._tabList = this._register(this._instantiationService.createInstance(TerminalTabList, this._tabListElement));
    const terminalOuterContainer = $(".terminal-outer-container");
    this._terminalContainer = $(".terminal-groups-container");
    terminalOuterContainer.appendChild(this._terminalContainer);
    this._terminalService.setContainers(parentElement, this._terminalContainer);
    this._terminalIsTabsNarrowContextKey = TerminalContextKeys.tabsNarrow.bindTo(contextKeyService);
    this._terminalTabsFocusContextKey = TerminalContextKeys.tabsFocus.bindTo(contextKeyService);
    this._terminalTabsMouseContextKey = TerminalContextKeys.tabsMouse.bindTo(contextKeyService);
    this._tabTreeIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 0 : 1;
    this._terminalContainerIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 1 : 0;
    _configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("terminal.integrated.tabs.enabled") || e.affectsConfiguration("terminal.integrated.tabs.hideCondition")) {
        this._refreshShowTabs();
      } else if (e.affectsConfiguration("terminal.integrated.tabs.location")) {
        this._tabTreeIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 0 : 1;
        this._terminalContainerIndex = this._terminalService.configHelper.config.tabs.location === "left" ? 1 : 0;
        if (this._shouldShowTabs()) {
          this._splitView.swapViews(0, 1);
          this._removeSashListener();
          this._addSashListener();
          this._splitView.resizeView(this._tabTreeIndex, this._getLastListWidth());
        }
      }
    });
    this._register(this._terminalGroupService.onDidChangeInstances(() => this._refreshShowTabs()));
    this._register(this._terminalGroupService.onDidChangeGroups(() => this._refreshShowTabs()));
    this._attachEventListeners(parentElement, this._terminalContainer);
    this._terminalGroupService.onDidChangePanelOrientation((orientation) => {
      this._panelOrientation = orientation;
      if (this._panelOrientation === 0) {
        this._terminalContainer.classList.add("terminal-side-view");
      } else {
        this._terminalContainer.classList.remove("terminal-side-view");
      }
    });
    this._splitView = new SplitView(
      parentElement,
      { orientation: 1, proportionalLayout: false }
    );
    this._setupSplitView(terminalOuterContainer);
  }
  _shouldShowTabs() {
    const enabled = this._terminalService.configHelper.config.tabs.enabled;
    const hide2 = this._terminalService.configHelper.config.tabs.hideCondition;
    if (!enabled) {
      return false;
    }
    if (hide2 === "never") {
      return true;
    }
    if (hide2 === "singleTerminal" && this._terminalGroupService.instances.length > 1) {
      return true;
    }
    if (hide2 === "singleGroup" && this._terminalGroupService.groups.length > 1) {
      return true;
    }
    return false;
  }
  _refreshShowTabs() {
    if (this._shouldShowTabs()) {
      if (this._splitView.length === 1) {
        this._addTabTree();
        this._addSashListener();
        this._splitView.resizeView(this._tabTreeIndex, this._getLastListWidth());
        this.rerenderTabs();
      }
    } else {
      if (this._splitView.length === 2 && !this._terminalTabsMouseContextKey.get()) {
        this._splitView.removeView(this._tabTreeIndex);
        if (this._plusButton) {
          this._tabContainer.removeChild(this._plusButton);
        }
        this._removeSashListener();
      }
    }
  }
  _getLastListWidth() {
    const widthKey = this._panelOrientation === 0 ? "tabs-list-width-vertical" : "tabs-list-width-horizontal";
    const storedValue = this._storageService.get(widthKey, 0);
    if (!storedValue || !parseInt(storedValue)) {
      return this._panelOrientation === 0 ? 46 : 120;
    }
    return parseInt(storedValue);
  }
  _handleOnDidSashReset() {
    let idealWidth = 80;
    const offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = 1;
    offscreenCanvas.height = 1;
    const ctx = offscreenCanvas.getContext("2d");
    if (ctx) {
      const style = window.getComputedStyle(this._tabListElement);
      ctx.font = `${style.fontStyle} ${style.fontSize} ${style.fontFamily}`;
      const maxInstanceWidth = this._terminalGroupService.instances.reduce((p, c) => {
        return Math.max(p, ctx.measureText(c.title + (c.description || "")).width + this._getAdditionalWidth(c));
      }, 0);
      idealWidth = Math.ceil(Math.max(maxInstanceWidth, 80));
    }
    const currentWidth = Math.ceil(this._splitView.getViewSize(this._tabTreeIndex));
    if (currentWidth === idealWidth) {
      idealWidth = 46;
    }
    this._splitView.resizeView(this._tabTreeIndex, idealWidth);
    this._updateListWidth(idealWidth);
  }
  _getAdditionalWidth(instance) {
    var _a2;
    const additionalWidth = 40;
    const statusIconWidth = instance.statusList.statuses.length > 0 ? 30 : 0;
    const splitAnnotationWidth = (((_a2 = this._terminalGroupService.getGroupForInstance(instance)) == null ? void 0 : _a2.terminalInstances.length) || 0) > 1 ? 30 : 0;
    return additionalWidth + splitAnnotationWidth + statusIconWidth;
  }
  _handleOnDidSashChange() {
    const listWidth = this._splitView.getViewSize(this._tabTreeIndex);
    if (!this._width || listWidth <= 0) {
      return;
    }
    this._updateListWidth(listWidth);
  }
  _updateListWidth(width) {
    if (width < 63 && width >= 46) {
      width = 46;
      this._splitView.resizeView(this._tabTreeIndex, width);
    } else if (width >= 63 && width < 80) {
      width = 80;
      this._splitView.resizeView(this._tabTreeIndex, width);
    }
    this.rerenderTabs();
    const widthKey = this._panelOrientation === 0 ? "tabs-list-width-vertical" : "tabs-list-width-horizontal";
    this._storageService.store(widthKey, width, 0, 0);
  }
  _setupSplitView(terminalOuterContainer) {
    this._register(this._splitView.onDidSashReset(() => this._handleOnDidSashReset()));
    this._register(this._splitView.onDidSashChange(() => this._handleOnDidSashChange()));
    if (this._shouldShowTabs()) {
      this._addTabTree();
    }
    this._splitView.addView({
      element: terminalOuterContainer,
      layout: (width) => this._terminalGroupService.groups.forEach((tab) => tab.layout(width, this._height || 0)),
      minimumSize: 120,
      maximumSize: Number.POSITIVE_INFINITY,
      onDidChange: () => Disposable.None,
      priority: 2
    }, Sizing.Distribute, this._terminalContainerIndex);
    if (this._shouldShowTabs()) {
      this._addSashListener();
    }
  }
  _addTabTree() {
    this._splitView.addView({
      element: this._tabContainer,
      layout: (width) => this._tabList.layout(this._height || 0, width),
      minimumSize: 46,
      maximumSize: 500,
      onDidChange: () => Disposable.None,
      priority: 1
    }, Sizing.Distribute, this._tabTreeIndex);
    this.rerenderTabs();
  }
  rerenderTabs() {
    this._updateHasText();
    this._tabList.refresh();
  }
  _addSashListener() {
    let interval;
    this._sashDisposables = [
      this._splitView.sashes[0].onDidStart((e) => {
        interval = window.setInterval(() => {
          this.rerenderTabs();
        }, 100);
      }),
      this._splitView.sashes[0].onDidEnd((e) => {
        window.clearInterval(interval);
        interval = 0;
      })
    ];
  }
  _removeSashListener() {
    if (this._sashDisposables) {
      dispose(this._sashDisposables);
      this._sashDisposables = void 0;
    }
  }
  _updateHasText() {
    const hasText = this._tabListElement.clientWidth > 63;
    this._tabContainer.classList.toggle("has-text", hasText);
    this._terminalIsTabsNarrowContextKey.set(!hasText);
  }
  layout(width, height) {
    this._height = height;
    this._width = width;
    this._splitView.layout(width);
    if (this._shouldShowTabs()) {
      this._splitView.resizeView(this._tabTreeIndex, this._getLastListWidth());
    }
    this._updateHasText();
  }
  _attachEventListeners(parentDomElement, terminalContainer) {
    this._register(addDisposableListener(this._tabContainer, "mouseleave", async (event) => {
      this._terminalTabsMouseContextKey.set(false);
      this._refreshShowTabs();
      event.stopPropagation();
    }));
    this._register(addDisposableListener(this._tabContainer, "mouseenter", async (event) => {
      this._terminalTabsMouseContextKey.set(true);
      event.stopPropagation();
    }));
    this._register(addDisposableListener(terminalContainer, "mousedown", async (event) => {
      const terminal = this._terminalGroupService.activeInstance;
      if (this._terminalGroupService.instances.length === 0 || !terminal) {
        this._cancelContextMenu = true;
        return;
      }
      if (event.which === 2 && isLinux) {
        terminal.focus();
      } else if (event.which === 3) {
        const rightClickBehavior = this._terminalService.configHelper.config.rightClickBehavior;
        if (rightClickBehavior === "nothing") {
          if (!event.shiftKey) {
            this._cancelContextMenu = true;
          }
          return;
        } else if (rightClickBehavior === "copyPaste" || rightClickBehavior === "paste") {
          if (rightClickBehavior === "copyPaste" && event.shiftKey) {
            openContextMenu(event, this._parentElement, this._instanceMenu, this._contextMenuService);
            return;
          }
          if (rightClickBehavior === "copyPaste" && terminal.hasSelection()) {
            await terminal.copySelection();
            terminal.clearSelection();
          } else {
            if (BrowserFeatures.clipboard.readText) {
              terminal.paste();
            } else {
              this._notificationService.info(`This browser doesn't support the clipboard.readText API needed to trigger a paste, try ${isMacintosh ? "⌘" : "Ctrl"}+V instead.`);
            }
          }
          if (isMacintosh) {
            setTimeout(() => {
              terminal.clearSelection();
            }, 0);
          }
          this._cancelContextMenu = true;
        }
      }
    }));
    this._register(addDisposableListener(terminalContainer, "contextmenu", (event) => {
      const rightClickBehavior = this._terminalService.configHelper.config.rightClickBehavior;
      if (rightClickBehavior === "nothing" && !event.shiftKey) {
        this._cancelContextMenu = true;
      }
      if (!this._cancelContextMenu) {
        openContextMenu(event, this._parentElement, this._instanceMenu, this._contextMenuService);
      }
      event.preventDefault();
      event.stopImmediatePropagation();
      this._cancelContextMenu = false;
    }));
    this._register(addDisposableListener(this._tabContainer, "contextmenu", (event) => {
      const rightClickBehavior = this._terminalService.configHelper.config.rightClickBehavior;
      if (rightClickBehavior === "nothing" && !event.shiftKey) {
        this._cancelContextMenu = true;
      }
      if (!this._cancelContextMenu) {
        const emptyList = this._tabList.getFocus().length === 0;
        openContextMenu(event, this._parentElement, emptyList ? this._tabsListEmptyMenu : this._tabsListMenu, this._contextMenuService, emptyList ? this._getTabActions() : void 0);
      }
      event.preventDefault();
      event.stopImmediatePropagation();
      this._cancelContextMenu = false;
    }));
    this._register(addDisposableListener(document, "keydown", (event) => {
      terminalContainer.classList.toggle("alt-active", !!event.altKey);
    }));
    this._register(addDisposableListener(document, "keyup", (event) => {
      terminalContainer.classList.toggle("alt-active", !!event.altKey);
    }));
    this._register(addDisposableListener(parentDomElement, "keyup", (event) => {
      if (event.keyCode === 27) {
        event.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this._tabContainer, EventType.FOCUS_IN, () => {
      this._terminalTabsFocusContextKey.set(true);
    }));
    this._register(addDisposableListener(this._tabContainer, EventType.FOCUS_OUT, () => {
      this._terminalTabsFocusContextKey.set(false);
    }));
  }
  _getTabActions() {
    return [
      new Separator(),
      this._configurationService.inspect("terminal.integrated.tabs.location").userValue === "left" ? new Action("moveRight", localize("moveTabsRight", "Move Tabs Right"), void 0, void 0, async () => {
        this._configurationService.updateValue("terminal.integrated.tabs.location", "right");
      }) : new Action("moveLeft", localize("moveTabsLeft", "Move Tabs Left"), void 0, void 0, async () => {
        this._configurationService.updateValue("terminal.integrated.tabs.location", "left");
      }),
      new Action("hideTabs", localize("hideTabs", "Hide Tabs"), void 0, void 0, async () => {
        this._configurationService.updateValue("terminal.integrated.tabs.enabled", false);
      })
    ];
  }
  setEditable(isEditing) {
    if (!isEditing) {
      this._tabList.domFocus();
    }
    this._tabList.refresh(false);
  }
  focusTabs() {
    if (!this._shouldShowTabs()) {
      return;
    }
    this._terminalTabsFocusContextKey.set(true);
    const selected = this._tabList.getSelection();
    this._tabList.domFocus();
    if (selected) {
      this._tabList.setFocus(selected);
    }
  }
  focus() {
    if (this._terminalService.connectionState === 0) {
      const activeElement = document.activeElement;
      this._register(this._terminalService.onDidChangeConnectionState(() => {
        if (document.activeElement === activeElement) {
          this._focus();
        }
      }));
      return;
    }
    this._focus();
  }
  focusHover() {
    if (this._shouldShowTabs()) {
      this._tabList.focusHover();
      return;
    }
    const instance = this._terminalGroupService.activeInstance;
    if (!instance) {
      return;
    }
    this._hoverService.showHover({
      ...getInstanceHoverInfo(instance),
      target: this._terminalContainer,
      trapFocus: true
    }, true);
  }
  _focus() {
    var _a2;
    (_a2 = this._terminalGroupService.activeInstance) == null ? void 0 : _a2.focusWhenReady();
  }
};
TerminalTabbedView = __decorate([
  __param(1, ITerminalService),
  __param(2, ITerminalGroupService),
  __param(3, IInstantiationService),
  __param(4, INotificationService),
  __param(5, IContextMenuService),
  __param(6, IConfigurationService),
  __param(7, IMenuService),
  __param(8, IStorageService),
  __param(9, IContextKeyService),
  __param(10, IHoverService)
], TerminalTabbedView);
function setupTerminalMenus() {
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.MenubarTerminalMenu,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.new",
          title: localize(
            { key: "miNewTerminal", comment: ["&& denotes a mnemonic"] },
            "&&New Terminal"
          )
        },
        order: 1
      }
    },
    {
      id: MenuId.MenubarTerminalMenu,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.split",
          title: localize(
            { key: "miSplitTerminal", comment: ["&& denotes a mnemonic"] },
            "&&Split Terminal"
          ),
          precondition: ContextKeyExpr.has("terminalIsOpen")
        },
        order: 2,
        when: TerminalContextKeys.processSupported
      }
    },
    {
      id: MenuId.MenubarTerminalMenu,
      item: {
        group: "2_run",
        command: {
          id: "workbench.action.terminal.runActiveFile",
          title: localize(
            { key: "miRunActiveFile", comment: ["&& denotes a mnemonic"] },
            "Run &&Active File"
          )
        },
        order: 3,
        when: TerminalContextKeys.processSupported
      }
    },
    {
      id: MenuId.MenubarTerminalMenu,
      item: {
        group: "2_run",
        command: {
          id: "workbench.action.terminal.runSelectedText",
          title: localize(
            { key: "miRunSelectedText", comment: ["&& denotes a mnemonic"] },
            "Run &&Selected Text"
          )
        },
        order: 4,
        when: TerminalContextKeys.processSupported
      }
    }
  ]);
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.split",
          title: terminalStrings.split.value
        }
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: terminalStrings.new
        },
        group: "1_create"
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.kill",
          title: terminalStrings.kill.value
        },
        group: "4_kill"
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelection",
          title: localize("workbench.action.terminal.copySelection.short", "Copy")
        },
        group: "2_edit",
        order: 1
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelectionAsHtml",
          title: localize("workbench.action.terminal.copySelectionAsHtml", "Copy as HTML")
        },
        group: "2_edit",
        order: 2
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.paste",
          title: localize("workbench.action.terminal.paste.short", "Paste")
        },
        group: "2_edit",
        order: 3
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.clear",
          title: localize("workbench.action.terminal.clear", "Clear")
        },
        group: "3_clear"
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.showTabs",
          title: localize("workbench.action.terminal.showsTabs", "Show Tabs")
        },
        when: ContextKeyExpr.not(`config.${"terminal.integrated.tabs.enabled"}`),
        group: "5_config"
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidth",
          title: terminalStrings.toggleSizeToContentWidth
        },
        group: "5_config"
      }
    },
    {
      id: MenuId.TerminalInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.selectAll",
          title: localize("workbench.action.terminal.selectAll", "Select All")
        },
        group: "2_edit",
        order: 3
      }
    }
  ]);
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        group: "1_create",
        command: {
          id: "workbench.action.terminal.split",
          title: terminalStrings.split.value
        }
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: terminalStrings.new
        },
        group: "1_create"
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.killEditor",
          title: terminalStrings.kill.value
        },
        group: "4_kill"
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelection",
          title: localize("workbench.action.terminal.copySelection.short", "Copy")
        },
        group: "2_edit",
        order: 1
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.copySelectionAsHtml",
          title: localize("workbench.action.terminal.copySelectionAsHtml", "Copy as HTML")
        },
        group: "2_edit",
        order: 2
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.paste",
          title: localize("workbench.action.terminal.paste.short", "Paste")
        },
        group: "2_edit",
        order: 3
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.clear",
          title: localize("workbench.action.terminal.clear", "Clear")
        },
        group: "3_clear"
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.selectAll",
          title: localize("workbench.action.terminal.selectAll", "Select All")
        },
        group: "2_edit",
        order: 3
      }
    },
    {
      id: MenuId.TerminalEditorInstanceContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidth",
          title: terminalStrings.toggleSizeToContentWidth
        },
        group: "5_config"
      }
    }
  ]);
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.TerminalTabEmptyAreaContext,
      item: {
        command: {
          id: "workbench.action.terminal.newWithProfile",
          title: localize(
            "workbench.action.terminal.newWithProfile.short",
            "New Terminal With Profile"
          )
        },
        group: "1_create"
      }
    },
    {
      id: MenuId.TerminalTabEmptyAreaContext,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: terminalStrings.new
        },
        group: "1_create"
      }
    }
  ]);
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.terminal.selectDefaultShell",
          title: { value: localize("workbench.action.terminal.selectDefaultProfile", "Select Default Profile"), original: "Select Default Profile" }
        },
        group: "3_configure"
      }
    },
    {
      id: MenuId.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.terminal.openSettings",
          title: localize("workbench.action.terminal.openSettings", "Configure Terminal Settings")
        },
        group: "3_configure"
      }
    },
    {
      id: MenuId.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.tasks.runTask",
          title: localize("workbench.action.tasks.runTask", "Run Task...")
        },
        when: TaskExecutionSupportedContext,
        group: "4_tasks",
        order: 1
      }
    },
    {
      id: MenuId.TerminalNewDropdownContext,
      item: {
        command: {
          id: "workbench.action.tasks.configureTaskRunner",
          title: localize("workbench.action.tasks.configureTaskRunner", "Configure Tasks...")
        },
        when: TaskExecutionSupportedContext,
        group: "4_tasks",
        order: 2
      }
    }
  ]);
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.switchTerminal",
          title: { value: localize("workbench.action.terminal.switchTerminal", "Switch Terminal"), original: "Switch Terminal" }
        },
        group: "navigation",
        order: 0,
        when: ContextKeyExpr.and(ContextKeyExpr.equals("view", TERMINAL_VIEW_ID), ContextKeyExpr.not(`config.${"terminal.integrated.tabs.enabled"}`))
      }
    },
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.focus",
          title: terminalStrings.focus
        },
        alt: {
          id: "workbench.action.terminal.split",
          title: terminalStrings.split.value,
          icon: Codicon.splitHorizontal
        },
        group: "navigation",
        order: 0,
        when: ContextKeyExpr.and(ContextKeyExpr.equals("view", TERMINAL_VIEW_ID), ContextKeyExpr.has(
          `config.${"terminal.integrated.tabs.enabled"}`
        ), ContextKeyExpr.or(ContextKeyExpr.and(ContextKeyExpr.equals(
          `config.${"terminal.integrated.tabs.showActiveTerminal"}`,
          "singleTerminal"
        ), ContextKeyExpr.equals("terminalCount", 1)), ContextKeyExpr.and(ContextKeyExpr.equals(
          `config.${"terminal.integrated.tabs.showActiveTerminal"}`,
          "singleTerminalOrNarrow"
        ), ContextKeyExpr.or(ContextKeyExpr.equals("terminalCount", 1), ContextKeyExpr.has("isTerminalTabsNarrow"))), ContextKeyExpr.and(ContextKeyExpr.equals(
          `config.${"terminal.integrated.tabs.showActiveTerminal"}`,
          "singleGroup"
        ), ContextKeyExpr.equals("terminalGroupCount", 1)), ContextKeyExpr.equals(
          `config.${"terminal.integrated.tabs.showActiveTerminal"}`,
          "always"
        )))
      }
    },
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.split",
          title: terminalStrings.split,
          icon: Codicon.splitHorizontal
        },
        group: "navigation",
        order: 2,
        when: ContextKeyExpr.and(ContextKeyExpr.equals("view", TERMINAL_VIEW_ID), ContextKeyExpr.notEquals(
          `config.${"terminal.integrated.tabs.hideCondition"}`,
          "never"
        ), ContextKeyExpr.or(
          ContextKeyExpr.not(`config.${"terminal.integrated.tabs.enabled"}`),
          ContextKeyExpr.and(ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "singleTerminal"
          ), ContextKeyExpr.equals("terminalCount", 1)),
          ContextKeyExpr.and(ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "singleTerminalOrNarrow"
          ), ContextKeyExpr.or(ContextKeyExpr.equals("terminalCount", 1), ContextKeyExpr.has("isTerminalTabsNarrow"))),
          ContextKeyExpr.and(ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "singleGroup"
          ), ContextKeyExpr.equals("terminalGroupCount", 1)),
          ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "always"
          )
        ))
      }
    },
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.kill",
          title: terminalStrings.kill,
          icon: Codicon.trash
        },
        group: "navigation",
        order: 3,
        when: ContextKeyExpr.and(ContextKeyExpr.equals("view", TERMINAL_VIEW_ID), ContextKeyExpr.notEquals(
          `config.${"terminal.integrated.tabs.hideCondition"}`,
          "never"
        ), ContextKeyExpr.or(
          ContextKeyExpr.not(`config.${"terminal.integrated.tabs.enabled"}`),
          ContextKeyExpr.and(ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "singleTerminal"
          ), ContextKeyExpr.equals("terminalCount", 1)),
          ContextKeyExpr.and(ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "singleTerminalOrNarrow"
          ), ContextKeyExpr.or(ContextKeyExpr.equals("terminalCount", 1), ContextKeyExpr.has("isTerminalTabsNarrow"))),
          ContextKeyExpr.and(ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "singleGroup"
          ), ContextKeyExpr.equals("terminalGroupCount", 1)),
          ContextKeyExpr.equals(
            `config.${"terminal.integrated.tabs.showActions"}`,
            "always"
          )
        ))
      }
    },
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.new",
          title: terminalStrings.new,
          icon: Codicon.plus
        },
        alt: {
          id: "workbench.action.terminal.split",
          title: terminalStrings.split.value,
          icon: Codicon.splitHorizontal
        },
        group: "navigation",
        order: 0,
        when: ContextKeyExpr.and(ContextKeyExpr.equals("view", TERMINAL_VIEW_ID), ContextKeyExpr.or(
          TerminalContextKeys.webExtensionContributedProfile,
          TerminalContextKeys.processSupported
        ))
      }
    },
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.clear",
          title: localize("workbench.action.terminal.clearLong", "Clear Terminal"),
          icon: Codicon.clearAll
        },
        group: "navigation",
        order: 4,
        when: ContextKeyExpr.equals("view", TERMINAL_VIEW_ID),
        isHiddenByDefault: true
      }
    },
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.runActiveFile",
          title: localize("workbench.action.terminal.runActiveFile", "Run Active File"),
          icon: Codicon.run
        },
        group: "navigation",
        order: 5,
        when: ContextKeyExpr.equals("view", TERMINAL_VIEW_ID),
        isHiddenByDefault: true
      }
    },
    {
      id: MenuId.ViewTitle,
      item: {
        command: {
          id: "workbench.action.terminal.runSelectedText",
          title: localize("workbench.action.terminal.runSelectedText", "Run Selected Text"),
          icon: Codicon.selection
        },
        group: "navigation",
        order: 6,
        when: ContextKeyExpr.equals("view", TERMINAL_VIEW_ID),
        isHiddenByDefault: true
      }
    }
  ]);
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.split",
          title: terminalStrings.split.value
        },
        group: "1_create",
        order: 1
      }
    },
    {
      id: MenuId.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.moveToEditor",
          title: terminalStrings.moveToEditor.value
        },
        group: "1_create",
        order: 2
      }
    },
    {
      id: MenuId.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeIconPanel",
          title: terminalStrings.changeIcon.value
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeColorPanel",
          title: terminalStrings.changeColor.value
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.renamePanel",
          title: terminalStrings.rename.value
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidthInstance",
          title: localize(
            "workbench.action.terminal.sizeToContentWidthInstance",
            "Toggle Size to Content Width"
          )
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalInlineTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.kill",
          title: terminalStrings.kill.value
        },
        group: "4_kill"
      }
    }
  ]);
  MenuRegistry.appendMenuItems([
    {
      id: MenuId.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.splitInstance",
          title: terminalStrings.split.value
        },
        group: "1_create",
        order: 1
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.moveToEditorInstance",
          title: terminalStrings.moveToEditor.value
        },
        group: "1_create",
        order: 2
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.renameInstance",
          title: localize("workbench.action.terminal.renameInstance", "Rename...")
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeIconInstance",
          title: localize("workbench.action.terminal.changeIcon", "Change Icon...")
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.changeColorInstance",
          title: localize("workbench.action.terminal.changeColor", "Change Color...")
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.sizeToContentWidthInstance",
          title: localize(
            "workbench.action.terminal.sizeToContentWidthInstance",
            "Toggle Size to Content Width"
          )
        },
        group: "2_edit"
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        group: "5_config",
        command: {
          id: "workbench.action.terminal.joinInstance",
          title: localize("workbench.action.terminal.joinInstance", "Join Terminals")
        },
        when: TerminalContextKeys.tabsSingularSelection.toNegated()
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        group: "5_config",
        command: {
          id: "workbench.action.terminal.unsplitInstance",
          title: terminalStrings.unsplit.value
        },
        when: ContextKeyExpr.and(
          TerminalContextKeys.tabsSingularSelection,
          TerminalContextKeys.splitTerminal
        )
      }
    },
    {
      id: MenuId.TerminalTabContext,
      item: {
        command: {
          id: "workbench.action.terminal.killInstance",
          title: terminalStrings.kill.value
        },
        group: "4_kill"
      }
    }
  ]);
  MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.moveToTerminalPanel",
      title: terminalStrings.moveToTerminalPanel
    },
    when: ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal),
    group: "2_files"
  });
  MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.rename",
      title: terminalStrings.rename
    },
    when: ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal),
    group: "3_files"
  });
  MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.changeColor",
      title: terminalStrings.changeColor
    },
    when: ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal),
    group: "3_files"
  });
  MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.changeIcon",
      title: terminalStrings.changeIcon
    },
    when: ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal),
    group: "3_files"
  });
  MenuRegistry.appendMenuItem(MenuId.EditorTitleContext, {
    command: {
      id: "workbench.action.terminal.sizeToContentWidth",
      title: terminalStrings.toggleSizeToContentWidth
    },
    when: ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal),
    group: "3_files"
  });
  MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
    command: {
      id: "workbench.action.createTerminalEditorSameGroup",
      title: terminalStrings.new,
      icon: Codicon.plus
    },
    alt: {
      id: "workbench.action.terminal.split",
      title: terminalStrings.split.value,
      icon: Codicon.splitHorizontal
    },
    group: "navigation",
    order: 0,
    when: ResourceContextKey.Scheme.isEqualTo(Schemas.vscodeTerminal)
  });
}
function getTerminalActionBarArgs(location, profiles, defaultProfileName, contributedProfiles, terminalService, dropdownMenu) {
  let dropdownActions = [];
  let submenuActions = [];
  profiles = profiles.filter((e) => !e.isAutoDetected);
  const splitLocation = location === TerminalLocation.Editor || typeof location === "object" && "viewColumn" in location && location.viewColumn === ACTIVE_GROUP ? { viewColumn: SIDE_GROUP } : { splitActiveTerminal: true };
  for (const p of profiles) {
    const isDefault = p.profileName === defaultProfileName;
    const options = { config: p, location };
    const splitOptions = { config: p, location: splitLocation };
    const sanitizedProfileName = p.profileName.replace(/[\n\r\t]/g, "");
    dropdownActions.push(new Action(
      "workbench.action.terminal.newWithProfile",
      isDefault ? localize("defaultTerminalProfile", "{0} (Default)", sanitizedProfileName) : sanitizedProfileName,
      void 0,
      true,
      async () => {
        const instance = await terminalService.createTerminal(options);
        terminalService.setActiveInstance(instance);
        await terminalService.focusActiveInstance();
      }
    ));
    submenuActions.push(new Action(
      "workbench.action.terminal.split",
      isDefault ? localize("defaultTerminalProfile", "{0} (Default)", sanitizedProfileName) : sanitizedProfileName,
      void 0,
      true,
      async () => {
        const instance = await terminalService.createTerminal(splitOptions);
        terminalService.setActiveInstance(instance);
        await terminalService.focusActiveInstance();
      }
    ));
  }
  for (const contributed of contributedProfiles) {
    const isDefault = contributed.title === defaultProfileName;
    const title = isDefault ? localize(
      "defaultTerminalProfile",
      "{0} (Default)",
      contributed.title.replace(/[\n\r\t]/g, "")
    ) : contributed.title.replace(/[\n\r\t]/g, "");
    dropdownActions.push(new Action(
      "contributed",
      title,
      void 0,
      true,
      () => terminalService.createTerminal({
        config: {
          extensionIdentifier: contributed.extensionIdentifier,
          id: contributed.id,
          title
        },
        location
      })
    ));
    submenuActions.push(new Action(
      "contributed-split",
      title,
      void 0,
      true,
      () => terminalService.createTerminal({
        config: {
          extensionIdentifier: contributed.extensionIdentifier,
          id: contributed.id,
          title
        },
        location: splitLocation
      })
    ));
  }
  const defaultProfileAction = dropdownActions.find((d) => d.label.endsWith("(Default)"));
  if (defaultProfileAction) {
    dropdownActions = dropdownActions.filter((d) => d !== defaultProfileAction).sort((a, b) => a.label.localeCompare(b.label));
    dropdownActions.unshift(defaultProfileAction);
  }
  if (dropdownActions.length > 0) {
    dropdownActions.push(new SubmenuAction("split.profile", localize("splitTerminal", "Split Terminal"), submenuActions));
    dropdownActions.push(new Separator());
  }
  const actions = dropdownMenu.getActions();
  dropdownActions.push(...Separator.join(...actions.map((a) => a[1])));
  const defaultSubmenuProfileAction = submenuActions.find((d) => d.label.endsWith("(Default)"));
  if (defaultSubmenuProfileAction) {
    submenuActions = submenuActions.filter((d) => d !== defaultSubmenuProfileAction).sort((a, b) => a.label.localeCompare(b.label));
    submenuActions.unshift(defaultSubmenuProfileAction);
  }
  const dropdownAction = new Action("refresh profiles", "Launch Profile...", "codicon-chevron-down", true);
  return { dropdownAction, dropdownMenuActions: dropdownActions, className: `terminal-tab-actions-${terminalService.resolveLocation(location)}` };
}
let TerminalViewPane = class TerminalViewPane2 extends ViewPane {
  get terminalTabbedView() {
    return this._terminalTabbedView;
  }
  constructor(options, keybindingService, _contextKeyService, viewDescriptorService, _configurationService, _contextMenuService, _instantiationService, _terminalService, _terminalGroupService, themeService, telemetryService, _notificationService, _keybindingService, openerService, _menuService, _terminalProfileService, _terminalProfileResolverService, _themeService, _accessibilityService) {
    super(options, keybindingService, _contextMenuService, _configurationService, _contextKeyService, viewDescriptorService, _instantiationService, openerService, themeService, telemetryService);
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._contextMenuService = _contextMenuService;
    this._instantiationService = _instantiationService;
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._notificationService = _notificationService;
    this._keybindingService = _keybindingService;
    this._menuService = _menuService;
    this._terminalProfileService = _terminalProfileService;
    this._terminalProfileResolverService = _terminalProfileResolverService;
    this._themeService = _themeService;
    this._accessibilityService = _accessibilityService;
    this._isWelcomeShowing = false;
    this._register(this._terminalService.onDidRegisterProcessSupport(() => {
      this._onDidChangeViewWelcomeState.fire();
    }));
    this._register(this._terminalService.onDidChangeInstances(() => {
      if (!this._isWelcomeShowing) {
        return;
      }
      this._isWelcomeShowing = true;
      this._onDidChangeViewWelcomeState.fire();
      if (!this._terminalTabbedView && this._parentDomElement) {
        this._createTabsView();
        this.layoutBody(this._parentDomElement.offsetHeight, this._parentDomElement.offsetWidth);
      }
    }));
    this._dropdownMenu = this._register(this._menuService.createMenu(MenuId.TerminalNewDropdownContext, this._contextKeyService));
    this._singleTabMenu = this._register(this._menuService.createMenu(MenuId.TerminalInlineTabContext, this._contextKeyService));
    this._register(this._terminalProfileService.onDidChangeAvailableProfiles((profiles) => this._updateTabActionBar(profiles)));
    this._viewShowing = TerminalContextKeys.viewShowing.bindTo(this._contextKeyService);
    this._register(this.onDidChangeBodyVisibility((e) => {
      var _a2;
      if (e) {
        (_a2 = this._terminalTabbedView) == null ? void 0 : _a2.rerenderTabs();
      }
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (this._parentDomElement && (e.affectsConfiguration("terminal.integrated.shellIntegration.decorationsEnabled") || e.affectsConfiguration("terminal.integrated.shellIntegration.enabled"))) {
        this._updateForShellIntegration(this._parentDomElement);
      }
    }));
    this._register(this._terminalService.onDidCreateInstance((i) => {
      i.capabilities.onDidAddCapability((c) => {
        var _a2;
        if (c === 2 && this._gutterDecorationsEnabled()) {
          (_a2 = this._parentDomElement) == null ? void 0 : _a2.classList.add("shell-integration");
        }
      });
    }));
  }
  _updateForShellIntegration(container) {
    container.classList.toggle("shell-integration", this._gutterDecorationsEnabled());
  }
  _gutterDecorationsEnabled() {
    const decorationsEnabled = this._configurationService.getValue("terminal.integrated.shellIntegration.decorationsEnabled");
    return (decorationsEnabled === "both" || decorationsEnabled === "gutter") && this._configurationService.getValue("terminal.integrated.shellIntegration.enabled");
  }
  _initializeTerminal(checkRestoredTerminals) {
    if (this.isBodyVisible() && this._terminalService.isProcessSupportRegistered && this._terminalService.connectionState === 1) {
      let shouldCreate = this._terminalGroupService.groups.length === 0;
      if (checkRestoredTerminals) {
        shouldCreate && (shouldCreate = this._terminalService.restoredGroupCount === 0);
      }
      if (shouldCreate) {
        this._terminalService.createTerminal({ location: TerminalLocation.Panel });
      }
    }
  }
  renderBody(container) {
    super.renderBody(container);
    if (!this._parentDomElement) {
      this._updateForShellIntegration(container);
    }
    this._parentDomElement = container;
    this._parentDomElement.classList.add("integrated-terminal");
    this._fontStyleElement = document.createElement("style");
    this._instantiationService.createInstance(TerminalThemeIconStyle, this._parentDomElement);
    if (!this.shouldShowWelcome()) {
      this._createTabsView();
    }
    this._parentDomElement.appendChild(this._fontStyleElement);
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("terminal.integrated.fontFamily") || e.affectsConfiguration("editor.fontFamily")) {
        const configHelper = this._terminalService.configHelper;
        if (!configHelper.configFontIsMonospace()) {
          const choices = [{
            label: localize("terminal.useMonospace", "Use 'monospace'"),
            run: () => this.configurationService.updateValue("terminal.integrated.fontFamily", "monospace")
          }];
          this._notificationService.prompt(Severity.Warning, localize(
            "terminal.monospaceOnly",
            "The terminal only supports monospace fonts. Be sure to restart VS Code if this is a newly installed font."
          ), choices);
        }
      }
    }));
    this._register(this.onDidChangeBodyVisibility(async (visible) => {
      this._viewShowing.set(visible);
      if (visible) {
        if (!this._terminalService.isProcessSupportRegistered) {
          this._onDidChangeViewWelcomeState.fire();
        }
        this._initializeTerminal(false);
        this._terminalGroupService.showPanel(false);
      } else {
        for (const instance of this._terminalGroupService.instances) {
          instance.resetFocusContextKey();
        }
      }
      this._terminalGroupService.updateVisibility();
    }));
    this._register(this._terminalService.onDidChangeConnectionState(() => this._initializeTerminal(true)));
    this.layoutBody(this._parentDomElement.offsetHeight, this._parentDomElement.offsetWidth);
  }
  _createTabsView() {
    if (!this._parentDomElement) {
      return;
    }
    this._terminalTabbedView = this.instantiationService.createInstance(TerminalTabbedView, this._parentDomElement);
  }
  layoutBody(height, width) {
    var _a2;
    super.layoutBody(height, width);
    (_a2 = this._terminalTabbedView) == null ? void 0 : _a2.layout(width, height);
  }
  getActionViewItem(action) {
    var _a2;
    switch (action.id) {
      case "workbench.action.terminal.split": {
        const that = this;
        const panelOnlySplitAction = new class extends Action {
          constructor() {
            super(action.id, action.label, action.class, action.enabled);
            this.checked = action.checked;
            this.tooltip = action.tooltip;
          }
          dispose() {
            action.dispose();
          }
          async run() {
            const instance = that._terminalGroupService.activeInstance;
            if (instance) {
              const newInstance = await that._terminalService.createTerminal({ location: { parentTerminal: instance } });
              return newInstance == null ? void 0 : newInstance.focusWhenReady();
            }
            return;
          }
        }();
        return new ActionViewItem(
          action,
          panelOnlySplitAction,
          { icon: true, label: false, keybinding: this._getKeybindingLabel(action) }
        );
      }
      case "workbench.action.terminal.switchTerminal": {
        return this._instantiationService.createInstance(SwitchTerminalActionViewItem, action);
      }
      case "workbench.action.terminal.focus": {
        if (action instanceof MenuItemAction) {
          const actions = [];
          createAndFillInContextMenuActions(this._singleTabMenu, void 0, actions);
          return this._instantiationService.createInstance(SingleTerminalTabActionViewItem, action, actions);
        }
      }
      case "workbench.action.terminal.new": {
        if (action instanceof MenuItemAction) {
          const actions = getTerminalActionBarArgs(TerminalLocation.Panel, this._terminalProfileService.availableProfiles, this._getDefaultProfileName(), this._terminalProfileService.contributedProfiles, this._terminalService, this._dropdownMenu);
          (_a2 = this._newDropdown) == null ? void 0 : _a2.dispose();
          this._newDropdown = new DropdownWithPrimaryActionViewItem(
            action,
            actions.dropdownAction,
            actions.dropdownMenuActions,
            actions.className,
            this._contextMenuService,
            {},
            this._keybindingService,
            this._notificationService,
            this._contextKeyService,
            this._themeService,
            this._accessibilityService
          );
          this._updateTabActionBar(this._terminalProfileService.availableProfiles);
          return this._newDropdown;
        }
      }
    }
    return super.getActionViewItem(action);
  }
  _getDefaultProfileName() {
    let defaultProfileName;
    try {
      defaultProfileName = this._terminalProfileService.getDefaultProfileName();
    } catch (e) {
      defaultProfileName = this._terminalProfileResolverService.defaultProfileName;
    }
    return defaultProfileName;
  }
  _getKeybindingLabel(action) {
    var _a2;
    return withNullAsUndefined((_a2 = this._keybindingService.lookupKeybinding(action.id)) == null ? void 0 : _a2.getLabel());
  }
  _updateTabActionBar(profiles) {
    var _a2;
    const actions = getTerminalActionBarArgs(TerminalLocation.Panel, profiles, this._getDefaultProfileName(), this._terminalProfileService.contributedProfiles, this._terminalService, this._dropdownMenu);
    (_a2 = this._newDropdown) == null ? void 0 : _a2.update(actions.dropdownAction, actions.dropdownMenuActions);
  }
  focus() {
    if (this._terminalService.connectionState === 0) {
      const activeElement = document.activeElement;
      this._register(this._terminalService.onDidChangeConnectionState(() => {
        if (document.activeElement === activeElement) {
          this._terminalGroupService.showPanel(true);
        }
      }));
      return;
    }
    this._terminalGroupService.showPanel(true);
  }
  shouldShowWelcome() {
    this._isWelcomeShowing = !this._terminalService.isProcessSupportRegistered && this._terminalService.instances.length === 0;
    return this._isWelcomeShowing;
  }
};
TerminalViewPane = __decorate([
  __param(1, IKeybindingService),
  __param(2, IContextKeyService),
  __param(3, IViewDescriptorService),
  __param(4, IConfigurationService),
  __param(5, IContextMenuService),
  __param(6, IInstantiationService),
  __param(7, ITerminalService),
  __param(8, ITerminalGroupService),
  __param(9, IThemeService),
  __param(10, ITelemetryService),
  __param(11, INotificationService),
  __param(12, IKeybindingService),
  __param(13, IOpenerService),
  __param(14, IMenuService),
  __param(15, ITerminalProfileService),
  __param(16, ITerminalProfileResolverService),
  __param(17, IThemeService),
  __param(18, IAccessibilityService)
], TerminalViewPane);
let SwitchTerminalActionViewItem = class SwitchTerminalActionViewItem2 extends SelectActionViewItem {
  constructor(action, _terminalService, _terminalGroupService, contextViewService, terminalProfileService) {
    super(null, action, getTerminalSelectOpenItems(_terminalService, _terminalGroupService), _terminalGroupService.activeGroupIndex, contextViewService, defaultSelectBoxStyles, { ariaLabel: localize("terminals", "Open Terminals."), optionsAsChildren: true });
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._register(_terminalService.onDidChangeInstances(() => this._updateItems(), this));
    this._register(_terminalService.onDidChangeActiveGroup(() => this._updateItems(), this));
    this._register(_terminalService.onDidChangeActiveInstance(() => this._updateItems(), this));
    this._register(_terminalService.onDidChangeInstanceTitle(() => this._updateItems(), this));
    this._register(_terminalGroupService.onDidChangeGroups(() => this._updateItems(), this));
    this._register(_terminalService.onDidChangeConnectionState(() => this._updateItems(), this));
    this._register(terminalProfileService.onDidChangeAvailableProfiles(() => this._updateItems(), this));
    this._register(_terminalService.onDidChangeInstancePrimaryStatus(() => this._updateItems(), this));
  }
  render(container) {
    super.render(container);
    container.classList.add("switch-terminal");
    container.style.borderColor = asCssVariable(selectBorder);
  }
  _updateItems() {
    const options = getTerminalSelectOpenItems(this._terminalService, this._terminalGroupService);
    this.setOptions(options, this._terminalGroupService.activeGroupIndex);
  }
};
SwitchTerminalActionViewItem = __decorate([
  __param(1, ITerminalService),
  __param(2, ITerminalGroupService),
  __param(3, IContextViewService),
  __param(4, ITerminalProfileService)
], SwitchTerminalActionViewItem);
function getTerminalSelectOpenItems(terminalService, terminalGroupService) {
  let items;
  if (terminalService.connectionState === 1) {
    items = terminalGroupService.getGroupLabels().map((label) => {
      return { text: label };
    });
  } else {
    items = [{ text: localize("terminalConnectingLabel", "Starting...") }];
  }
  items.push({ text: switchTerminalActionViewItemSeparator, isDisabled: true });
  items.push({ text: switchTerminalShowTabsTitle });
  return items;
}
let SingleTerminalTabActionViewItem = class SingleTerminalTabActionViewItem2 extends MenuEntryActionViewItem {
  constructor(action, _actions, keybindingService, notificationService, contextKeyService, themeService, _terminalService, _terminalGroupService, contextMenuService, _commandService, _instantiationService, _accessibilityService) {
    super(action, {
      draggable: true,
      hoverDelegate: _instantiationService.createInstance(SingleTabHoverDelegate)
    }, keybindingService, notificationService, contextKeyService, themeService, contextMenuService, _accessibilityService);
    this._actions = _actions;
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._commandService = _commandService;
    this._instantiationService = _instantiationService;
    this._elementDisposables = [];
    this._register(Event.debounce(Event.any(this._terminalService.onDidChangeInstancePrimaryStatus, this._terminalGroupService.onDidChangeActiveInstance, Event.map(this._terminalService.onDidChangeInstanceIcon, (e) => e.instance), Event.map(this._terminalService.onDidChangeInstanceColor, (e) => e.instance), this._terminalService.onDidChangeInstanceTitle, this._terminalService.onDidChangeInstanceCapability), (last, e) => {
      if (!last) {
        last = /* @__PURE__ */ new Set();
      }
      if (e) {
        last.add(e);
      }
      return last;
    })((merged) => {
      for (const e of merged) {
        this.updateLabel(e);
      }
    }));
    this._register(toDisposable(() => dispose(this._elementDisposables)));
  }
  async onClick(event) {
    if (event.altKey && this._menuItemAction.alt) {
      this._commandService.executeCommand(this._menuItemAction.alt.id, { target: TerminalLocation.Panel });
    } else {
      this._openContextMenu();
    }
  }
  updateLabel(e) {
    if (e && e !== this._terminalGroupService.activeInstance) {
      return;
    }
    if (this._elementDisposables.length === 0 && this.element && this.label) {
      this._elementDisposables.push(addDisposableListener(this.element, EventType.CONTEXT_MENU, (e2) => {
        if (e2.button === 2) {
          this._openContextMenu();
          e2.preventDefault();
        }
      }));
      this._elementDisposables.push(addDisposableListener(this.element, EventType.AUXCLICK, (e2) => {
        if (e2.button === 1) {
          const instance = this._terminalGroupService.activeInstance;
          if (instance) {
            this._terminalService.safeDisposeTerminal(instance);
          }
          e2.preventDefault();
        }
      }));
      this._elementDisposables.push(addDisposableListener(this.element, EventType.DRAG_START, (e2) => {
        const instance = this._terminalGroupService.activeInstance;
        if (e2.dataTransfer && instance) {
          e2.dataTransfer.setData("Terminals", JSON.stringify([instance.resource.toString()]));
        }
      }));
    }
    if (this.label) {
      const label = this.label;
      const instance = this._terminalGroupService.activeInstance;
      if (!instance) {
        reset(label, "");
        return;
      }
      label.classList.add("single-terminal-tab");
      let colorStyle = "";
      const primaryStatus = instance.statusList.primary;
      if (primaryStatus) {
        const colorKey = getColorForSeverity(primaryStatus.severity);
        this._themeService.getColorTheme();
        const foundColor = this._themeService.getColorTheme().getColor(colorKey);
        if (foundColor) {
          colorStyle = foundColor.toString();
        }
      }
      label.style.color = colorStyle;
      reset(label, ...renderLabelWithIcons(this._instantiationService.invokeFunction(getSingleTabLabel, instance, this._terminalService.configHelper.config.tabs.separator, ThemeIcon.isThemeIcon(this._commandAction.item.icon) ? this._commandAction.item.icon : void 0)));
      if (this._altCommand) {
        label.classList.remove(this._altCommand);
        this._altCommand = void 0;
      }
      if (this._color) {
        label.classList.remove(this._color);
        this._color = void 0;
      }
      if (this._class) {
        label.classList.remove(this._class);
        label.classList.remove("terminal-uri-icon");
        this._class = void 0;
      }
      const colorClass = getColorClass(instance);
      if (colorClass) {
        this._color = colorClass;
        label.classList.add(colorClass);
      }
      const uriClasses = getUriClasses(instance, this._themeService.getColorTheme().type);
      if (uriClasses) {
        this._class = uriClasses == null ? void 0 : uriClasses[0];
        label.classList.add(...uriClasses);
      }
      if (this._commandAction.item.icon) {
        this._altCommand = `alt-command`;
        label.classList.add(this._altCommand);
      }
      this.updateTooltip();
    }
  }
  _openContextMenu() {
    this._contextMenuService.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this._actions,
      getActionsContext: () => this.label
    });
  }
};
SingleTerminalTabActionViewItem = __decorate([
  __param(2, IKeybindingService),
  __param(3, INotificationService),
  __param(4, IContextKeyService),
  __param(5, IThemeService),
  __param(6, ITerminalService),
  __param(7, ITerminalGroupService),
  __param(8, IContextMenuService),
  __param(9, ICommandService),
  __param(10, IInstantiationService),
  __param(11, IAccessibilityService)
], SingleTerminalTabActionViewItem);
function getSingleTabLabel(accessor, instance, separator, icon) {
  if (!instance || !instance.title) {
    return "";
  }
  const iconId = ThemeIcon.isThemeIcon(instance.icon) ? instance.icon.id : accessor.get(ITerminalProfileResolverService).getDefaultIcon().id;
  const label = `$(${(icon == null ? void 0 : icon.id) || iconId}) ${getSingleTabTitle(instance, separator)}`;
  const primaryStatus = instance.statusList.primary;
  if (!(primaryStatus == null ? void 0 : primaryStatus.icon)) {
    return label;
  }
  return `${label} $(${primaryStatus.icon.id})`;
}
function getSingleTabTitle(instance, separator) {
  if (!instance) {
    return "";
  }
  return !instance.description ? instance.title : `${instance.title} ${separator} ${instance.description}`;
}
let TerminalThemeIconStyle = class TerminalThemeIconStyle2 extends Themable {
  constructor(container, _themeService, _terminalService, _terminalGroupService) {
    super(_themeService);
    this._themeService = _themeService;
    this._terminalService = _terminalService;
    this._terminalGroupService = _terminalGroupService;
    this._registerListeners();
    this._styleElement = document.createElement("style");
    container.appendChild(this._styleElement);
    this._register(toDisposable(() => container.removeChild(this._styleElement)));
    this.updateStyles();
  }
  _registerListeners() {
    this._register(this._terminalService.onDidChangeInstanceIcon(() => this.updateStyles()));
    this._register(this._terminalService.onDidChangeInstanceColor(() => this.updateStyles()));
    this._register(this._terminalService.onDidChangeInstances(() => this.updateStyles()));
    this._register(this._terminalGroupService.onDidChangeGroups(() => this.updateStyles()));
  }
  updateStyles() {
    super.updateStyles();
    const colorTheme = this._themeService.getColorTheme();
    let css2 = "";
    for (const instance of this._terminalService.instances) {
      const icon = instance.icon;
      if (!icon) {
        continue;
      }
      let uri = void 0;
      if (icon instanceof URI) {
        uri = icon;
      } else if (icon instanceof Object && "light" in icon && "dark" in icon) {
        uri = colorTheme.type === ColorScheme.LIGHT ? icon.light : icon.dark;
      }
      const iconClasses = getUriClasses(instance, colorTheme.type);
      if (uri instanceof URI && iconClasses && iconClasses.length > 1) {
        css2 += `.monaco-workbench .${iconClasses[0]} .monaco-highlighted-label .codicon, .monaco-action-bar .terminal-uri-icon.single-terminal-tab.action-label:not(.alt-command) .codicon{background-image: ${asCSSUrl(uri)};}`;
      }
    }
    for (const instance of this._terminalService.instances) {
      const colorClass = getColorClass(instance);
      if (!colorClass || !instance.color) {
        continue;
      }
      const color = colorTheme.getColor(instance.color);
      if (color) {
        css2 += `.monaco-workbench .${colorClass} .codicon:first-child:not(.codicon-split-horizontal):not(.codicon-trashcan):not(.file-icon){ color: ${color} !important; }`;
      }
    }
    this._styleElement.textContent = css2;
  }
};
TerminalThemeIconStyle = __decorate([
  __param(1, IThemeService),
  __param(2, ITerminalService),
  __param(3, ITerminalGroupService)
], TerminalThemeIconStyle);
let SingleTabHoverDelegate = class SingleTabHoverDelegate2 {
  constructor(_configurationService, _hoverService, _terminalGroupService) {
    this._configurationService = _configurationService;
    this._hoverService = _hoverService;
    this._terminalGroupService = _terminalGroupService;
    this._lastHoverHideTime = 0;
    this.placement = "element";
  }
  get delay() {
    return Date.now() - this._lastHoverHideTime < 200 ? 0 : this._configurationService.getValue("workbench.hover.delay");
  }
  showHover(options, focus) {
    const instance = this._terminalGroupService.activeInstance;
    if (!instance) {
      return;
    }
    const hoverInfo = getInstanceHoverInfo(instance);
    return this._hoverService.showHover({
      ...options,
      content: hoverInfo.content,
      actions: hoverInfo.actions
    }, focus);
  }
  onDidHideHover() {
    this._lastHoverHideTime = Date.now();
  }
};
SingleTabHoverDelegate = __decorate([
  __param(0, IConfigurationService),
  __param(1, IHoverService),
  __param(2, ITerminalGroupService)
], SingleTabHoverDelegate);
function setupTerminalCommands() {
  registerOpenTerminalAtIndexCommands();
}
function registerOpenTerminalAtIndexCommands() {
  for (let i = 0; i < 9; i++) {
    const terminalIndex = i;
    const visibleIndex = i + 1;
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: `workbench.action.terminal.focusAtIndex${visibleIndex}`,
      weight: 200,
      when: void 0,
      primary: 0,
      handler: (accessor) => {
        accessor.get(ITerminalGroupService).setActiveInstanceByIndex(terminalIndex);
        return accessor.get(ITerminalGroupService).showPanel(true);
      }
    });
  }
}
const terminalDescriptors = "\n- " + [
  "`${cwd}`: " + localize("cwd", "the terminal's current working directory"),
  "`${cwdFolder}`: " + localize(
    "cwdFolder",
    "the terminal's current working directory, displayed for multi-root workspaces or in a single root workspace when the value differs from the initial working directory. On Windows, this will only be displayed when shell integration is enabled."
  ),
  "`${workspaceFolder}`: " + localize("workspaceFolder", "the workspace in which the terminal was launched"),
  "`${local}`: " + localize("local", "indicates a local terminal in a remote workspace"),
  "`${process}`: " + localize("process", "the name of the terminal process"),
  "`${separator}`: " + localize(
    "separator",
    "a conditional separator {0} that only shows when surrounded by variables with values or static text.",
    "(` - `)"
  ),
  "`${sequence}`: " + localize("sequence", "the name provided to the terminal by the process"),
  "`${task}`: " + localize("task", "indicates this terminal is associated with a task")
].join("\n- ");
let terminalTitle = localize(
  "terminalTitle",
  "Controls the terminal title. Variables are substituted based on the context:"
);
terminalTitle += terminalDescriptors;
let terminalDescription = localize(
  "terminalDescription",
  "Controls the terminal description, which appears to the right of the title. Variables are substituted based on the context:"
);
terminalDescription += terminalDescriptors;
const terminalConfiguration = {
  id: "terminal",
  order: 100,
  title: localize("terminalIntegratedConfigurationTitle", "Integrated Terminal"),
  type: "object",
  properties: {
    ["terminal.integrated.sendKeybindingsToShell"]: {
      markdownDescription: localize(
        "terminal.integrated.sendKeybindingsToShell",
        "Dispatches most keybindings to the terminal instead of the workbench, overriding {0}, which can be used alternatively for fine tuning.",
        "`#terminal.integrated.commandsToSkipShell#`"
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.tabs.defaultColor"]: {
      description: localize(
        "terminal.integrated.tabs.defaultColor",
        "A theme color ID to associate with terminal icons by default."
      ),
      ...terminalColorSchema,
      scope: 4
    },
    ["terminal.integrated.tabs.defaultIcon"]: {
      description: localize(
        "terminal.integrated.tabs.defaultIcon",
        "A codicon ID to associate with terminal icons by default."
      ),
      ...terminalIconSchema,
      default: Codicon.terminal.id,
      scope: 4
    },
    ["terminal.integrated.tabs.enabled"]: {
      description: localize(
        "terminal.integrated.tabs.enabled",
        "Controls whether terminal tabs display as a list to the side of the terminal. When this is disabled a dropdown will display instead."
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.tabs.enableAnimation"]: {
      description: localize(
        "terminal.integrated.tabs.enableAnimation",
        "Controls whether terminal tab statuses support animation (eg. in progress tasks)."
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.tabs.hideCondition"]: {
      description: localize(
        "terminal.integrated.tabs.hideCondition",
        "Controls whether the terminal tabs view will hide under certain conditions."
      ),
      type: "string",
      enum: ["never", "singleTerminal", "singleGroup"],
      enumDescriptions: [
        localize(
          "terminal.integrated.tabs.hideCondition.never",
          "Never hide the terminal tabs view"
        ),
        localize(
          "terminal.integrated.tabs.hideCondition.singleTerminal",
          "Hide the terminal tabs view when there is only a single terminal opened"
        ),
        localize(
          "terminal.integrated.tabs.hideCondition.singleGroup",
          "Hide the terminal tabs view when there is only a single terminal group opened"
        )
      ],
      default: "singleTerminal"
    },
    ["terminal.integrated.tabs.showActiveTerminal"]: {
      description: localize(
        "terminal.integrated.tabs.showActiveTerminal",
        "Shows the active terminal information in the view. This is particularly useful when the title within the tabs aren't visible."
      ),
      type: "string",
      enum: ["always", "singleTerminal", "singleTerminalOrNarrow", "never"],
      enumDescriptions: [
        localize(
          "terminal.integrated.tabs.showActiveTerminal.always",
          "Always show the active terminal"
        ),
        localize(
          "terminal.integrated.tabs.showActiveTerminal.singleTerminal",
          "Show the active terminal when it is the only terminal opened"
        ),
        localize(
          "terminal.integrated.tabs.showActiveTerminal.singleTerminalOrNarrow",
          "Show the active terminal when it is the only terminal opened or when the tabs view is in its narrow textless state"
        ),
        localize(
          "terminal.integrated.tabs.showActiveTerminal.never",
          "Never show the active terminal"
        )
      ],
      default: "singleTerminalOrNarrow"
    },
    ["terminal.integrated.tabs.showActions"]: {
      description: localize(
        "terminal.integrated.tabs.showActions",
        "Controls whether terminal split and kill buttons are displays next to the new terminal button."
      ),
      type: "string",
      enum: ["always", "singleTerminal", "singleTerminalOrNarrow", "never"],
      enumDescriptions: [
        localize("terminal.integrated.tabs.showActions.always", "Always show the actions"),
        localize(
          "terminal.integrated.tabs.showActions.singleTerminal",
          "Show the actions when it is the only terminal opened"
        ),
        localize(
          "terminal.integrated.tabs.showActions.singleTerminalOrNarrow",
          "Show the actions when it is the only terminal opened or when the tabs view is in its narrow textless state"
        ),
        localize("terminal.integrated.tabs.showActions.never", "Never show the actions")
      ],
      default: "singleTerminalOrNarrow"
    },
    ["terminal.integrated.tabs.location"]: {
      type: "string",
      enum: ["left", "right"],
      enumDescriptions: [
        localize(
          "terminal.integrated.tabs.location.left",
          "Show the terminal tabs view to the left of the terminal"
        ),
        localize(
          "terminal.integrated.tabs.location.right",
          "Show the terminal tabs view to the right of the terminal"
        )
      ],
      default: "right",
      description: localize(
        "terminal.integrated.tabs.location",
        "Controls the location of the terminal tabs, either to the left or right of the actual terminal(s)."
      )
    },
    ["terminal.integrated.tabFocusMode"]: {
      markdownDescription: localize(
        "tabFocusMode",
        "Controls whether the terminal receives tabs or defers them to the workbench for navigation. When set, this overrides {0} when the terminal is focused.",
        "`#editor.tabFocusMode#`"
      ),
      type: ["boolean", "null"],
      default: null
    },
    ["terminal.integrated.defaultLocation"]: {
      type: "string",
      enum: ["editor", "view"],
      enumDescriptions: [
        localize(
          "terminal.integrated.defaultLocation.editor",
          "Create terminals in the editor"
        ),
        localize(
          "terminal.integrated.defaultLocation.view",
          "Create terminals in the terminal view"
        )
      ],
      default: "view",
      description: localize(
        "terminal.integrated.defaultLocation",
        "Controls where newly created terminals will appear."
      )
    },
    ["terminal.integrated.tabs.focusMode"]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      enumDescriptions: [
        localize(
          "terminal.integrated.tabs.focusMode.singleClick",
          "Focus the terminal when clicking a terminal tab"
        ),
        localize(
          "terminal.integrated.tabs.focusMode.doubleClick",
          "Focus the terminal when double-clicking a terminal tab"
        )
      ],
      default: "doubleClick",
      description: localize(
        "terminal.integrated.tabs.focusMode",
        "Controls whether focusing the terminal of a tab happens on double or single click."
      )
    },
    ["terminal.integrated.macOptionIsMeta"]: {
      description: localize(
        "terminal.integrated.macOptionIsMeta",
        "Controls whether to treat the option key as the meta key in the terminal on macOS."
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.macOptionClickForcesSelection"]: {
      description: localize(
        "terminal.integrated.macOptionClickForcesSelection",
        "Controls whether to force selection when using Option+click on macOS. This will force a regular (line) selection and disallow the use of column selection mode. This enables copying and pasting using the regular terminal selection, for example, when mouse mode is enabled in tmux."
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.altClickMovesCursor"]: {
      markdownDescription: localize(
        "terminal.integrated.altClickMovesCursor",
        "If enabled, alt/option + click will reposition the prompt cursor to underneath the mouse when {0} is set to {1} (the default value). This may not work reliably depending on your shell.",
        "`#editor.multiCursorModifier#`",
        "`'alt'`"
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.copyOnSelection"]: {
      description: localize(
        "terminal.integrated.copyOnSelection",
        "Controls whether text selected in the terminal will be copied to the clipboard."
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.enableMultiLinePasteWarning"]: {
      markdownDescription: localize(
        "terminal.integrated.enableMultiLinePasteWarning",
        "Show a warning dialog when pasting multiple lines into the terminal. The dialog does not show when:\n\n- Bracketed paste mode is enabled (the shell supports multi-line paste natively)\n- The paste is handled by the shell's readline (in the case of pwsh)"
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.drawBoldTextInBrightColors"]: {
      description: localize(
        "terminal.integrated.drawBoldTextInBrightColors",
        'Controls whether bold text in the terminal will always use the "bright" ANSI color variant.'
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.fontFamily"]: {
      markdownDescription: localize(
        "terminal.integrated.fontFamily",
        "Controls the font family of the terminal. Defaults to {0}'s value.",
        "`#editor.fontFamily#`"
      ),
      type: "string"
    },
    ["terminal.integrated.fontSize"]: {
      description: localize(
        "terminal.integrated.fontSize",
        "Controls the font size in pixels of the terminal."
      ),
      type: "number",
      default: isMacintosh ? 12 : 14,
      minimum: 6,
      maximum: 100
    },
    ["terminal.integrated.letterSpacing"]: {
      description: localize(
        "terminal.integrated.letterSpacing",
        "Controls the letter spacing of the terminal. This is an integer value which represents the number of additional pixels to add between characters."
      ),
      type: "number",
      default: DEFAULT_LETTER_SPACING
    },
    ["terminal.integrated.lineHeight"]: {
      description: localize(
        "terminal.integrated.lineHeight",
        "Controls the line height of the terminal. This number is multiplied by the terminal font size to get the actual line-height in pixels."
      ),
      type: "number",
      default: DEFAULT_LINE_HEIGHT
    },
    ["terminal.integrated.minimumContrastRatio"]: {
      markdownDescription: localize(
        "terminal.integrated.minimumContrastRatio",
        "When set, the foreground color of each cell will change to try meet the contrast ratio specified. Note that this will not apply to `powerline` characters per #146406. Example values:\n\n- 1: Do nothing and use the standard theme colors.\n- 4.5: [WCAG AA compliance (minimum)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html) (default).\n- 7: [WCAG AAA compliance (enhanced)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html).\n- 21: White on black or black on white."
      ),
      type: "number",
      default: 4.5,
      tags: ["accessibility"]
    },
    ["terminal.integrated.tabStopWidth"]: {
      markdownDescription: localize("terminal.integrated.tabStopWidth", "The number of cells in a tab stop."),
      type: "number",
      minimum: 1,
      default: 8
    },
    ["terminal.integrated.fastScrollSensitivity"]: {
      markdownDescription: localize(
        "terminal.integrated.fastScrollSensitivity",
        "Scrolling speed multiplier when pressing `Alt`."
      ),
      type: "number",
      default: 5
    },
    ["terminal.integrated.mouseWheelScrollSensitivity"]: {
      markdownDescription: localize(
        "terminal.integrated.mouseWheelScrollSensitivity",
        "A multiplier to be used on the `deltaY` of mouse wheel scroll events."
      ),
      type: "number",
      default: 1
    },
    ["terminal.integrated.bellDuration"]: {
      markdownDescription: localize(
        "terminal.integrated.bellDuration",
        "The number of milliseconds to show the bell within a terminal tab when triggered."
      ),
      type: "number",
      default: 1e3
    },
    ["terminal.integrated.fontWeight"]: {
      "anyOf": [
        {
          type: "number",
          minimum: MINIMUM_FONT_WEIGHT,
          maximum: MAXIMUM_FONT_WEIGHT,
          errorMessage: localize(
            "terminal.integrated.fontWeightError",
            'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.'
          )
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: SUGGESTIONS_FONT_WEIGHT
        }
      ],
      description: localize(
        "terminal.integrated.fontWeight",
        'The font weight to use within the terminal for non-bold text. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.'
      ),
      default: "normal"
    },
    ["terminal.integrated.fontWeightBold"]: {
      "anyOf": [
        {
          type: "number",
          minimum: MINIMUM_FONT_WEIGHT,
          maximum: MAXIMUM_FONT_WEIGHT,
          errorMessage: localize(
            "terminal.integrated.fontWeightError",
            'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.'
          )
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: SUGGESTIONS_FONT_WEIGHT
        }
      ],
      description: localize(
        "terminal.integrated.fontWeightBold",
        'The font weight to use within the terminal for bold text. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.'
      ),
      default: "bold"
    },
    ["terminal.integrated.cursorBlinking"]: {
      description: localize(
        "terminal.integrated.cursorBlinking",
        "Controls whether the terminal cursor blinks."
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.cursorStyle"]: {
      description: localize(
        "terminal.integrated.cursorStyle",
        "Controls the style of terminal cursor."
      ),
      enum: [TerminalCursorStyle.BLOCK, TerminalCursorStyle.LINE, TerminalCursorStyle.UNDERLINE],
      default: TerminalCursorStyle.BLOCK
    },
    ["terminal.integrated.cursorWidth"]: {
      markdownDescription: localize(
        "terminal.integrated.cursorWidth",
        "Controls the width of the cursor when {0} is set to {1}.",
        "`#terminal.integrated.cursorStyle#`",
        "`line`"
      ),
      type: "number",
      default: 1
    },
    ["terminal.integrated.scrollback"]: {
      description: localize(
        "terminal.integrated.scrollback",
        "Controls the maximum number of lines the terminal keeps in its buffer. We pre-allocate memory based on this value in order to ensure a smooth experience. As such, as the value increases, so will the amount of memory."
      ),
      type: "number",
      default: 1e3
    },
    ["terminal.integrated.detectLocale"]: {
      markdownDescription: localize(
        "terminal.integrated.detectLocale",
        "Controls whether to detect and set the `$LANG` environment variable to a UTF-8 compliant option since VS Code's terminal only supports UTF-8 encoded data coming from the shell."
      ),
      type: "string",
      enum: ["auto", "off", "on"],
      markdownEnumDescriptions: [
        localize(
          "terminal.integrated.detectLocale.auto",
          "Set the `$LANG` environment variable if the existing variable does not exist or it does not end in `'.UTF-8'`."
        ),
        localize(
          "terminal.integrated.detectLocale.off",
          "Do not set the `$LANG` environment variable."
        ),
        localize(
          "terminal.integrated.detectLocale.on",
          "Always set the `$LANG` environment variable."
        )
      ],
      default: "auto"
    },
    ["terminal.integrated.gpuAcceleration"]: {
      type: "string",
      enum: ["auto", "on", "off", "canvas"],
      markdownEnumDescriptions: [
        localize(
          "terminal.integrated.gpuAcceleration.auto",
          "Let VS Code detect which renderer will give the best experience."
        ),
        localize(
          "terminal.integrated.gpuAcceleration.on",
          "Enable GPU acceleration within the terminal."
        ),
        localize(
          "terminal.integrated.gpuAcceleration.off",
          "Disable GPU acceleration within the terminal. The terminal will render much slower when GPU acceleration is off but it should reliably work on all systems."
        ),
        localize(
          "terminal.integrated.gpuAcceleration.canvas",
          "Use the terminal's fallback canvas renderer which uses a 2d context instead of webgl which may perform better on some systems. Note that some features are limited in the canvas renderer like opaque selection."
        )
      ],
      default: "auto",
      description: localize(
        "terminal.integrated.gpuAcceleration",
        "Controls whether the terminal will leverage the GPU to do its rendering."
      )
    },
    ["terminal.integrated.tabs.separator"]: {
      "type": "string",
      "default": " - ",
      "markdownDescription": localize(
        "terminal.integrated.tabs.separator",
        "Separator used by {0} and {0}.",
        `\`${"terminal.integrated.tabs.title"}\``,
        `\`${"terminal.integrated.tabs.description"}\``
      )
    },
    ["terminal.integrated.tabs.title"]: {
      "type": "string",
      "default": "${process}",
      "markdownDescription": terminalTitle
    },
    ["terminal.integrated.tabs.description"]: {
      "type": "string",
      "default": "${task}${separator}${local}${separator}${cwdFolder}",
      "markdownDescription": terminalDescription
    },
    ["terminal.integrated.rightClickBehavior"]: {
      type: "string",
      enum: ["default", "copyPaste", "paste", "selectWord", "nothing"],
      enumDescriptions: [
        localize("terminal.integrated.rightClickBehavior.default", "Show the context menu."),
        localize(
          "terminal.integrated.rightClickBehavior.copyPaste",
          "Copy when there is a selection, otherwise paste."
        ),
        localize("terminal.integrated.rightClickBehavior.paste", "Paste on right click."),
        localize(
          "terminal.integrated.rightClickBehavior.selectWord",
          "Select the word under the cursor and show the context menu."
        ),
        localize(
          "terminal.integrated.rightClickBehavior.nothing",
          "Do nothing and pass event to terminal."
        )
      ],
      default: isMacintosh ? "selectWord" : isWindows ? "copyPaste" : "default",
      description: localize(
        "terminal.integrated.rightClickBehavior",
        "Controls how terminal reacts to right click."
      )
    },
    ["terminal.integrated.cwd"]: {
      restricted: true,
      description: localize(
        "terminal.integrated.cwd",
        "An explicit start path where the terminal will be launched, this is used as the current working directory (cwd) for the shell process. This may be particularly useful in workspace settings if the root directory is not a convenient cwd."
      ),
      type: "string",
      default: void 0,
      scope: 4
    },
    ["terminal.integrated.confirmOnExit"]: {
      description: localize(
        "terminal.integrated.confirmOnExit",
        "Controls whether to confirm when the window closes if there are active terminal sessions."
      ),
      type: "string",
      enum: ["never", "always", "hasChildProcesses"],
      enumDescriptions: [
        localize("terminal.integrated.confirmOnExit.never", "Never confirm."),
        localize(
          "terminal.integrated.confirmOnExit.always",
          "Always confirm if there are terminals."
        ),
        localize(
          "terminal.integrated.confirmOnExit.hasChildProcesses",
          "Confirm if there are any terminals that have child processes."
        )
      ],
      default: "never"
    },
    ["terminal.integrated.confirmOnKill"]: {
      description: localize(
        "terminal.integrated.confirmOnKill",
        "Controls whether to confirm killing terminals when they have child processes. When set to editor, terminals in the editor area will be marked as changed when they have child processes. Note that child process detection may not work well for shells like Git Bash which don't run their processes as child processes of the shell."
      ),
      type: "string",
      enum: ["never", "editor", "panel", "always"],
      enumDescriptions: [
        localize("terminal.integrated.confirmOnKill.never", "Never confirm."),
        localize(
          "terminal.integrated.confirmOnKill.editor",
          "Confirm if the terminal is in the editor."
        ),
        localize(
          "terminal.integrated.confirmOnKill.panel",
          "Confirm if the terminal is in the panel."
        ),
        localize(
          "terminal.integrated.confirmOnKill.always",
          "Confirm if the terminal is either in the editor or panel."
        )
      ],
      default: "editor"
    },
    ["terminal.integrated.enableBell"]: {
      description: localize(
        "terminal.integrated.enableBell",
        "Controls whether the terminal bell is enabled. This shows up as a visual bell next to the terminal's name."
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.commandsToSkipShell"]: {
      markdownDescription: localize(
        "terminal.integrated.commandsToSkipShell",
        "A set of command IDs whose keybindings will not be sent to the shell but instead always be handled by VS Code. This allows keybindings that would normally be consumed by the shell to act instead the same as when the terminal is not focused, for example `Ctrl+P` to launch Quick Open.\n\n&nbsp;\n\nMany commands are skipped by default. To override a default and pass that command's keybinding to the shell instead, add the command prefixed with the `-` character. For example add `-workbench.action.quickOpen` to allow `Ctrl+P` to reach the shell.\n\n&nbsp;\n\nThe following list of default skipped commands is truncated when viewed in Settings Editor. To see the full list, {1} and search for the first command from the list below.\n\n&nbsp;\n\nDefault Skipped Commands:\n\n{0}",
        DEFAULT_COMMANDS_TO_SKIP_SHELL.sort().map((command) => `- ${command}`).join("\n"),
        `[${localize("openDefaultSettingsJson", "open the default settings JSON")}](command:workbench.action.openRawDefaultSettings '${localize("openDefaultSettingsJson.capitalized", "Open Default Settings (JSON)")}')`
      ),
      type: "array",
      items: {
        type: "string"
      },
      default: []
    },
    ["terminal.integrated.allowChords"]: {
      markdownDescription: localize(
        "terminal.integrated.allowChords",
        "Whether or not to allow chord keybindings in the terminal. Note that when this is true and the keystroke results in a chord it will bypass {0}, setting this to false is particularly useful when you want ctrl+k to go to your shell (not VS Code).",
        "`#terminal.integrated.commandsToSkipShell#`"
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.allowMnemonics"]: {
      markdownDescription: localize(
        "terminal.integrated.allowMnemonics",
        "Whether to allow menubar mnemonics (for example Alt+F) to trigger the open of the menubar. Note that this will cause all alt keystrokes to skip the shell when true. This does nothing on macOS."
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.env.osx"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.env.osx",
        "Object with environment variables that will be added to the VS Code process to be used by the terminal on macOS. Set to `null` to delete the environment variable."
      ),
      type: "object",
      additionalProperties: {
        type: ["string", "null"]
      },
      default: {}
    },
    ["terminal.integrated.env.linux"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.env.linux",
        "Object with environment variables that will be added to the VS Code process to be used by the terminal on Linux. Set to `null` to delete the environment variable."
      ),
      type: "object",
      additionalProperties: {
        type: ["string", "null"]
      },
      default: {}
    },
    ["terminal.integrated.env.windows"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.env.windows",
        "Object with environment variables that will be added to the VS Code process to be used by the terminal on Windows. Set to `null` to delete the environment variable."
      ),
      type: "object",
      additionalProperties: {
        type: ["string", "null"]
      },
      default: {}
    },
    ["terminal.integrated.environmentChangesIndicator"]: {
      markdownDescription: localize(
        "terminal.integrated.environmentChangesIndicator",
        "Whether to display the environment changes indicator on each terminal which explains whether extensions have made, or want to make changes to the terminal's environment."
      ),
      type: "string",
      enum: ["off", "on", "warnonly"],
      enumDescriptions: [
        localize(
          "terminal.integrated.environmentChangesIndicator.off",
          "Disable the indicator."
        ),
        localize(
          "terminal.integrated.environmentChangesIndicator.on",
          "Enable the indicator."
        ),
        localize(
          "terminal.integrated.environmentChangesIndicator.warnonly",
          "Only show the warning indicator when a terminal's environment is 'stale', not the information indicator that shows a terminal has had its environment modified by an extension."
        )
      ],
      default: "warnonly"
    },
    ["terminal.integrated.environmentChangesRelaunch"]: {
      markdownDescription: localize(
        "terminal.integrated.environmentChangesRelaunch",
        "Whether to relaunch terminals automatically if extension want to contribute to their environment and have not been interacted with yet."
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.showExitAlert"]: {
      description: localize(
        "terminal.integrated.showExitAlert",
        'Controls whether to show the alert "The terminal process terminated with exit code" when exit code is non-zero.'
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.splitCwd"]: {
      description: localize(
        "terminal.integrated.splitCwd",
        "Controls the working directory a split terminal starts with."
      ),
      type: "string",
      enum: ["workspaceRoot", "initial", "inherited"],
      enumDescriptions: [
        localize(
          "terminal.integrated.splitCwd.workspaceRoot",
          "A new split terminal will use the workspace root as the working directory. In a multi-root workspace a choice for which root folder to use is offered."
        ),
        localize(
          "terminal.integrated.splitCwd.initial",
          "A new split terminal will use the working directory that the parent terminal started with."
        ),
        localize(
          "terminal.integrated.splitCwd.inherited",
          "On macOS and Linux, a new split terminal will use the working directory of the parent terminal. On Windows, this behaves the same as initial."
        )
      ],
      default: "inherited"
    },
    ["terminal.integrated.windowsEnableConpty"]: {
      description: localize(
        "terminal.integrated.windowsEnableConpty",
        "Whether to use ConPTY for Windows terminal process communication (requires Windows 10 build number 18309+). Winpty will be used if this is false."
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.wordSeparators"]: {
      markdownDescription: localize(
        "terminal.integrated.wordSeparators",
        "A string containing all characters to be considered word separators when double-clicking to select word and in the fallback 'word' link detection. Since this is used for link detection, including characters such as `:` that are used when detecting links will cause the line and column part of links like `file:10:5` to be ignored."
      ),
      type: "string",
      default: " ()[]{}',\"`─‘’|"
    },
    ["terminal.integrated.enableFileLinks"]: {
      description: localize(
        "terminal.integrated.enableFileLinks",
        "Whether to enable file links in terminals. Links can be slow when working on a network drive in particular because each file link is verified against the file system. Changing this will take effect only in new terminals."
      ),
      type: "string",
      enum: ["off", "on", "notRemote"],
      enumDescriptions: [
        localize("enableFileLinks.off", "Always off."),
        localize("enableFileLinks.on", "Always on."),
        localize("enableFileLinks.notRemote", "Enable only when not in a remote workspace.")
      ],
      default: "on"
    },
    ["terminal.integrated.unicodeVersion"]: {
      type: "string",
      enum: ["6", "11"],
      enumDescriptions: [
        localize(
          "terminal.integrated.unicodeVersion.six",
          "Version 6 of Unicode. This is an older version which should work better on older systems."
        ),
        localize(
          "terminal.integrated.unicodeVersion.eleven",
          "Version 11 of Unicode. This version provides better support on modern systems that use modern versions of Unicode."
        )
      ],
      default: "11",
      description: localize(
        "terminal.integrated.unicodeVersion",
        "Controls what version of Unicode to use when evaluating the width of characters in the terminal. If you experience emoji or other wide characters not taking up the right amount of space or backspace either deleting too much or too little then you may want to try tweaking this setting."
      )
    },
    ["terminal.integrated.localEchoLatencyThreshold"]: {
      description: localize(
        "terminal.integrated.localEchoLatencyThreshold",
        "Length of network delay, in milliseconds, where local edits will be echoed on the terminal without waiting for server acknowledgement. If '0', local echo will always be on, and if '-1' it will be disabled."
      ),
      type: "integer",
      minimum: -1,
      default: 30
    },
    ["terminal.integrated.localEchoEnabled"]: {
      markdownDescription: localize(
        "terminal.integrated.localEchoEnabled",
        "When local echo should be enabled. This will override {0}",
        "`#terminal.integrated.localEchoLatencyThreshold#`"
      ),
      type: "string",
      enum: ["on", "off", "auto"],
      enumDescriptions: [
        localize("terminal.integrated.localEchoEnabled.on", "Always enabled"),
        localize("terminal.integrated.localEchoEnabled.off", "Always disabled"),
        localize(
          "terminal.integrated.localEchoEnabled.auto",
          "Enabled only for remote workspaces"
        )
      ],
      default: "auto"
    },
    ["terminal.integrated.localEchoExcludePrograms"]: {
      description: localize(
        "terminal.integrated.localEchoExcludePrograms",
        "Local echo will be disabled when any of these program names are found in the terminal title."
      ),
      type: "array",
      items: {
        type: "string",
        uniqueItems: true
      },
      default: DEFAULT_LOCAL_ECHO_EXCLUDE
    },
    ["terminal.integrated.localEchoStyle"]: {
      description: localize(
        "terminal.integrated.localEchoStyle",
        "Terminal style of locally echoed text; either a font style or an RGB color."
      ),
      default: "dim",
      oneOf: [
        {
          type: "string",
          default: "dim",
          enum: ["bold", "dim", "italic", "underlined", "inverted"]
        },
        {
          type: "string",
          format: "color-hex",
          default: "#ff0000"
        }
      ]
    },
    ["terminal.integrated.enablePersistentSessions"]: {
      description: localize(
        "terminal.integrated.enablePersistentSessions",
        "Persist terminal sessions/history for the workspace across window reloads."
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.persistentSessionReviveProcess"]: {
      markdownDescription: localize(
        "terminal.integrated.persistentSessionReviveProcess",
        "When the terminal process must be shut down (for example on window or application close), this determines when the previous terminal session contents/history should be restored and processes be recreated when the workspace is next opened.\n\nCaveats:\n\n- Restoring of the process current working directory depends on whether it is supported by the shell.\n- Time to persist the session during shutdown is limited, so it may be aborted when using high-latency remote connections."
      ),
      type: "string",
      enum: ["onExit", "onExitAndWindowClose", "never"],
      markdownEnumDescriptions: [
        localize(
          "terminal.integrated.persistentSessionReviveProcess.onExit",
          "Revive the processes after the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu)."
        ),
        localize(
          "terminal.integrated.persistentSessionReviveProcess.onExitAndWindowClose",
          "Revive the processes after the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu), or when the window is closed."
        ),
        localize(
          "terminal.integrated.persistentSessionReviveProcess.never",
          "Never restore the terminal buffers or recreate the process."
        )
      ],
      default: "onExit"
    },
    ["terminal.integrated.customGlyphs"]: {
      description: localize(
        "terminal.integrated.customGlyphs",
        "Whether to draw custom glyphs for block element and box drawing characters instead of using the font, which typically yields better rendering with continuous lines. Note that this doesn't work when {0} is disabled.",
        `\`#${"terminal.integrated.gpuAcceleration"}#\``
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.autoReplies"]: {
      markdownDescription: localize(
        "terminal.integrated.autoReplies",
        "A set of messages that, when encountered in the terminal, will be automatically responded to. Provided the message is specific enough, this can help automate away common responses.\n\nRemarks:\n\n- Use {0} to automatically respond to the terminate batch job prompt on Windows.\n- The message includes escape sequences so the reply might not happen with styled text.\n- Each reply can only happen once every second.\n- Use {1} in the reply to mean the enter key.\n- To unset a default key, set the value to null.\n- Restart VS Code if new don't apply.",
        '`"Terminate batch job (Y/N)": "Y\\r"`',
        '`"\\r"`'
      ),
      type: "object",
      additionalProperties: {
        oneOf: [
          {
            type: "string",
            description: localize(
              "terminal.integrated.autoReplies.reply",
              "The reply to send to the process."
            )
          },
          { type: "null" }
        ]
      },
      default: {}
    },
    ["terminal.integrated.shellIntegration.enabled"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.shellIntegration.enabled",
        "Determines whether or not shell integration is auto-injected to support features like enhanced command tracking and current working directory detection. \n\nShell integration works by injecting the shell with a startup script. The script gives VS Code insight into what is happening within the terminal.\n\nSupported shells:\n\n- Linux/macOS: bash, fish, pwsh, zsh\n - Windows: pwsh\n\nThis setting applies only when terminals are created, so you will need to restart your terminals for it to take effect.\n\n Note that the script injection may not work if you have custom arguments defined in the terminal profile, have enabled {1}, have a [complex bash `PROMPT_COMMAND`](https://code.visualstudio.com/docs/editor/integrated-terminal#_complex-bash-promptcommand), or other unsupported setup. To disable decorations, see {0}",
        "`#terminal.integrated.shellIntegrations.decorationsEnabled#`",
        "`#editor.accessibilitySupport#`"
      ),
      type: "boolean",
      default: true
    },
    ["terminal.integrated.shellIntegration.decorationsEnabled"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.shellIntegration.decorationsEnabled",
        "When shell integration is enabled, adds a decoration for each command."
      ),
      type: "string",
      enum: ["both", "gutter", "overviewRuler", "never"],
      enumDescriptions: [
        localize(
          "terminal.integrated.shellIntegration.decorationsEnabled.both",
          "Show decorations in the gutter (left) and overview ruler (right)"
        ),
        localize(
          "terminal.integrated.shellIntegration.decorationsEnabled.gutter",
          "Show gutter decorations to the left of the terminal"
        ),
        localize(
          "terminal.integrated.shellIntegration.decorationsEnabled.overviewRuler",
          "Show overview ruler decorations to the right of the terminal"
        ),
        localize(
          "terminal.integrated.shellIntegration.decorationsEnabled.never",
          "Do not show decorations"
        )
      ],
      default: "both"
    },
    ["terminal.integrated.shellIntegration.history"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.shellIntegration.history",
        "Controls the number of recently used commands to keep in the terminal command history. Set to 0 to disable terminal command history."
      ),
      type: "number",
      default: 100
    },
    ["terminal.integrated.shellIntegration.suggestEnabled"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.shellIntegration.suggestEnabled",
        "Enables experimental terminal Intellisense suggestions for supported shells when {0} is set to {1}. If shell integration is installed manually, {2} needs to be set to {3} before calling the script.",
        "`#terminal.integrated.shellIntegration.enabled#`",
        "`true`",
        "`VSCODE_SUGGEST`",
        "`1`"
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.smoothScrolling"]: {
      markdownDescription: localize(
        "terminal.integrated.smoothScrolling",
        "Controls whether the terminal will scroll using an animation."
      ),
      type: "boolean",
      default: false
    },
    ["terminal.integrated.enableImages"]: {
      restricted: true,
      markdownDescription: localize(
        "terminal.integrated.enableImages",
        "Enables image support in the terminal, this will only work when {0} is enabled. Both sixel and iTerm's inline image protocol are supported on Linux and macOS, Windows support will light up automatically when ConPTY passes through the sequences. Images will currently not be restored between window reloads/reconnects.",
        `\`#${"terminal.integrated.gpuAcceleration"}#\``
      ),
      type: "boolean",
      default: true
    }
  }
};
function registerTerminalConfiguration() {
  const configurationRegistry = Registry.as(Extensions.Configuration);
  configurationRegistry.registerConfiguration(terminalConfiguration);
}
let TerminalEditor = class TerminalEditor2 extends EditorPane {
  constructor(telemetryService, themeService, storageService, _terminalEditorService, _terminalProfileResolverService, _terminalService, contextKeyService, menuService, _instantiationService, _contextMenuService, _notificationService, _terminalProfileService, _workbenchLayoutService) {
    super(terminalEditorId, telemetryService, themeService, storageService);
    this._terminalEditorService = _terminalEditorService;
    this._terminalProfileResolverService = _terminalProfileResolverService;
    this._terminalService = _terminalService;
    this._instantiationService = _instantiationService;
    this._contextMenuService = _contextMenuService;
    this._notificationService = _notificationService;
    this._terminalProfileService = _terminalProfileService;
    this._workbenchLayoutService = _workbenchLayoutService;
    this._editorInput = void 0;
    this._cancelContextMenu = false;
    this._dropdownMenu = this._register(menuService.createMenu(MenuId.TerminalNewDropdownContext, contextKeyService));
    this._instanceMenu = this._register(menuService.createMenu(MenuId.TerminalEditorInstanceContext, contextKeyService));
  }
  async setInput(newInput, options, context, token) {
    var _a2, _b2, _c2, _d2;
    (_b2 = (_a2 = this._editorInput) == null ? void 0 : _a2.terminalInstance) == null ? void 0 : _b2.detachFromElement();
    this._editorInput = newInput;
    await super.setInput(newInput, options, context, token);
    (_c2 = this._editorInput.terminalInstance) == null ? void 0 : _c2.attachToElement(this._overflowGuardElement);
    if (this._lastDimension) {
      this.layout(this._lastDimension);
    }
    (_d2 = this._editorInput.terminalInstance) == null ? void 0 : _d2.setVisible(this.isVisible() && this._workbenchLayoutService.isVisible("workbench.parts.editor"));
    if (this._editorInput.terminalInstance) {
      this._register(this._editorInput.terminalInstance.onDidFocus(() => this._setActiveInstance()));
      this._editorInput.setCopyLaunchConfig(this._editorInput.terminalInstance.shellLaunchConfig);
    }
  }
  clearInput() {
    var _a2, _b2;
    super.clearInput();
    (_b2 = (_a2 = this._editorInput) == null ? void 0 : _a2.terminalInstance) == null ? void 0 : _b2.detachFromElement();
    this._editorInput = void 0;
  }
  _setActiveInstance() {
    var _a2;
    if (!((_a2 = this._editorInput) == null ? void 0 : _a2.terminalInstance)) {
      return;
    }
    this._terminalEditorService.setActiveInstance(this._editorInput.terminalInstance);
  }
  focus() {
    var _a2, _b2;
    (_b2 = (_a2 = this._editorInput) == null ? void 0 : _a2.terminalInstance) == null ? void 0 : _b2.focus();
  }
  createEditor(parent) {
    this._editorInstanceElement = parent;
    this._overflowGuardElement = $$3(".terminal-overflow-guard.terminal-editor");
    this._editorInstanceElement.appendChild(this._overflowGuardElement);
    this._registerListeners();
  }
  _registerListeners() {
    if (!this._editorInstanceElement) {
      return;
    }
    this._register(addDisposableListener(this._editorInstanceElement, "mousedown", async (event) => {
      if (this._terminalEditorService.instances.length === 0) {
        return;
      }
      if (event.which === 2 && isLinux) {
        const terminal = this._terminalEditorService.activeInstance;
        terminal == null ? void 0 : terminal.focus();
      } else if (event.which === 3) {
        const rightClickBehavior = this._terminalService.configHelper.config.rightClickBehavior;
        if (rightClickBehavior === "nothing") {
          if (!event.shiftKey) {
            this._cancelContextMenu = true;
          }
          return;
        } else if (rightClickBehavior === "copyPaste" || rightClickBehavior === "paste") {
          const terminal = this._terminalEditorService.activeInstance;
          if (!terminal) {
            return;
          }
          if (rightClickBehavior === "copyPaste" && event.shiftKey) {
            openContextMenu(event, this._editorInstanceElement, this._instanceMenu, this._contextMenuService);
            return;
          }
          if (rightClickBehavior === "copyPaste" && terminal.hasSelection()) {
            await terminal.copySelection();
            terminal.clearSelection();
          } else {
            if (BrowserFeatures.clipboard.readText) {
              terminal.paste();
            } else {
              this._notificationService.info(`This browser doesn't support the clipboard.readText API needed to trigger a paste, try ${isMacintosh ? "⌘" : "Ctrl"}+V instead.`);
            }
          }
          if (isMacintosh) {
            setTimeout(() => {
              terminal.clearSelection();
            }, 0);
          }
          this._cancelContextMenu = true;
        }
      }
    }));
    this._register(addDisposableListener(this._editorInstanceElement, "contextmenu", (event) => {
      const rightClickBehavior = this._terminalService.configHelper.config.rightClickBehavior;
      if (rightClickBehavior === "nothing" && !event.shiftKey) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this._cancelContextMenu = false;
        return;
      } else if (!this._cancelContextMenu && rightClickBehavior !== "copyPaste" && rightClickBehavior !== "paste") {
        if (!this._cancelContextMenu) {
          openContextMenu(event, this._editorInstanceElement, this._instanceMenu, this._contextMenuService);
        }
        event.preventDefault();
        event.stopImmediatePropagation();
        this._cancelContextMenu = false;
      }
    }));
  }
  layout(dimension) {
    var _a2, _b2;
    (_b2 = (_a2 = this._editorInput) == null ? void 0 : _a2.terminalInstance) == null ? void 0 : _b2.layout(dimension);
    this._lastDimension = dimension;
  }
  setVisible(visible, group) {
    var _a2, _b2;
    super.setVisible(visible, group);
    (_b2 = (_a2 = this._editorInput) == null ? void 0 : _a2.terminalInstance) == null ? void 0 : _b2.setVisible(visible && this._workbenchLayoutService.isVisible("workbench.parts.editor"));
  }
  getActionViewItem(action) {
    switch (action.id) {
      case "workbench.action.createTerminalEditor": {
        if (action instanceof MenuItemAction) {
          const location = { viewColumn: ACTIVE_GROUP };
          const actions = getTerminalActionBarArgs(location, this._terminalProfileService.availableProfiles, this._getDefaultProfileName(), this._terminalProfileService.contributedProfiles, this._terminalService, this._dropdownMenu);
          const button = this._instantiationService.createInstance(DropdownWithPrimaryActionViewItem, action, actions.dropdownAction, actions.dropdownMenuActions, actions.className, this._contextMenuService, {});
          return button;
        }
      }
    }
    return super.getActionViewItem(action);
  }
  _getDefaultProfileName() {
    let defaultProfileName;
    try {
      defaultProfileName = this._terminalProfileService.getDefaultProfileName();
    } catch (e) {
      defaultProfileName = this._terminalProfileResolverService.defaultProfileName;
    }
    return defaultProfileName;
  }
};
TerminalEditor = __decorate([
  __param(0, ITelemetryService),
  __param(1, IThemeService),
  __param(2, IStorageService),
  __param(3, ITerminalEditorService),
  __param(4, ITerminalProfileResolverService),
  __param(5, ITerminalService),
  __param(6, IContextKeyService),
  __param(7, IMenuService),
  __param(8, IInstantiationService),
  __param(9, IContextMenuService),
  __param(10, INotificationService),
  __param(11, ITerminalProfileService),
  __param(12, IWorkbenchLayoutService)
], TerminalEditor);
let TerminalMainContribution = class TerminalMainContribution2 extends Disposable {
  constructor(editorResolverService, embedderTerminalService, labelService, terminalService, terminalEditorService, terminalGroupService, terminalInstanceService) {
    super();
    editorResolverService.registerEditor(`${Schemas.vscodeTerminal}:/**`, {
      id: terminalEditorId,
      label: terminalStrings.terminal,
      priority: RegisteredEditorPriority.exclusive
    }, {
      canSupportResource: (uri) => uri.scheme === Schemas.vscodeTerminal,
      singlePerResource: true
    }, {
      createEditorInput: async ({ resource, options }) => {
        let instance = terminalService.getInstanceFromResource(resource);
        if (instance) {
          const sourceGroup = terminalGroupService.getGroupForInstance(instance);
          sourceGroup == null ? void 0 : sourceGroup.removeInstance(instance);
        } else {
          const terminalIdentifier = parseTerminalUri(resource);
          if (!terminalIdentifier.instanceId) {
            throw new Error("Terminal identifier without instanceId");
          }
          const primaryBackend = terminalService.getPrimaryBackend();
          if (!primaryBackend) {
            throw new Error("No terminal primary backend");
          }
          const attachPersistentProcess = await primaryBackend.requestDetachInstance(terminalIdentifier.workspaceId, terminalIdentifier.instanceId);
          if (!attachPersistentProcess) {
            throw new Error("No terminal persistent process to attach");
          }
          instance = terminalInstanceService.createInstance({ attachPersistentProcess }, TerminalLocation.Editor);
        }
        const resolvedResource = terminalEditorService.resolveResource(instance);
        const editor = terminalEditorService.getInputFromResource(resolvedResource);
        return {
          editor,
          options: {
            ...options,
            pinned: true,
            forceReload: true,
            override: terminalEditorId
          }
        };
      }
    });
    labelService.registerFormatter({
      scheme: Schemas.vscodeTerminal,
      formatting: {
        label: "${path}",
        separator: ""
      }
    });
    embedderTerminalService.onDidCreateTerminal(async (embedderTerminal) => {
      const terminal = await terminalService.createTerminal({
        config: embedderTerminal,
        location: TerminalLocation.Panel
      });
      terminalService.setActiveInstance(terminal);
      await terminalService.revealActiveTerminal();
    });
  }
};
TerminalMainContribution = __decorate([
  __param(0, IEditorResolverService),
  __param(1, IEmbedderTerminalService),
  __param(2, ILabelService),
  __param(3, ITerminalService),
  __param(4, ITerminalEditorService),
  __param(5, ITerminalGroupService),
  __param(6, ITerminalInstanceService)
], TerminalMainContribution);
const quickAccessRegistry = Registry.as(Extensions$1.Quickaccess);
const inTerminalsPicker = "inTerminalPicker";
quickAccessRegistry.registerQuickAccessProvider({
  ctor: TerminalQuickAccessProvider,
  prefix: TerminalQuickAccessProvider.PREFIX,
  contextKey: inTerminalsPicker,
  placeholder: localize("tasksQuickAccessPlaceholder", "Type the name of a terminal to open."),
  helpEntries: [{ description: localize("tasksQuickAccessHelp", "Show All Opened Terminals"), commandId: "workbench.action.quickOpenTerm" }]
});
const quickAccessNavigateNextInTerminalPickerId = "workbench.action.quickOpenNavigateNextInTerminalPicker";
CommandsRegistry.registerCommand({ id: quickAccessNavigateNextInTerminalPickerId, handler: getQuickNavigateHandler(quickAccessNavigateNextInTerminalPickerId, true) });
const quickAccessNavigatePreviousInTerminalPickerId = "workbench.action.quickOpenNavigatePreviousInTerminalPicker";
CommandsRegistry.registerCommand({ id: quickAccessNavigatePreviousInTerminalPickerId, handler: getQuickNavigateHandler(quickAccessNavigatePreviousInTerminalPickerId, false) });
const workbenchRegistry = Registry.as(Extensions$2.Workbench);
workbenchRegistry.registerWorkbenchContribution(TerminalMainContribution, 3);
registerTerminalPlatformConfiguration();
registerTerminalConfiguration();
Registry.as(EditorExtensions.EditorPane).registerEditorPane(EditorPaneDescriptor.create(TerminalEditor, terminalEditorId, terminalStrings.terminal), [
  new SyncDescriptor(TerminalEditorInput)
]);
Registry.as(Extensions$3.DragAndDropContribution).register({
  dataFormatKey: "Terminals",
  getEditorInputs(data) {
    const editors = [];
    try {
      const terminalEditors = JSON.parse(data);
      for (const terminalEditor of terminalEditors) {
        editors.push({ resource: URI.parse(terminalEditor) });
      }
    } catch (error) {
    }
    return editors;
  },
  setData(resources, event) {
    var _a2;
    const terminalResources = resources.filter(({ resource }) => resource.scheme === Schemas.vscodeTerminal);
    if (terminalResources.length) {
      (_a2 = event.dataTransfer) == null ? void 0 : _a2.setData("Terminals", JSON.stringify(terminalResources.map(({ resource }) => resource.toString())));
    }
  }
});
const VIEW_CONTAINER = Registry.as(Extensions$4.ViewContainersRegistry).registerViewContainer({
  id: TERMINAL_VIEW_ID,
  title: localize("terminal", "Terminal"),
  icon: terminalViewIcon,
  ctorDescriptor: new SyncDescriptor(
    ViewPaneContainer,
    [TERMINAL_VIEW_ID, { mergeViewWithContainerWhenSingleView: true }]
  ),
  storageId: TERMINAL_VIEW_ID,
  hideIfEmpty: true,
  order: 3
}, 1, { doNotRegisterOpenCommand: true, isDefault: true });
Registry.as(Extensions$4.ViewsRegistry).registerViews([{
  id: TERMINAL_VIEW_ID,
  name: localize("terminal", "Terminal"),
  containerIcon: terminalViewIcon,
  canToggleVisibility: false,
  canMoveView: true,
  ctorDescriptor: new SyncDescriptor(TerminalViewPane),
  openCommandActionDescriptor: {
    id: "workbench.action.terminal.toggleTerminal",
    mnemonicTitle: localize(
      { key: "miToggleIntegratedTerminal", comment: ["&& denotes a mnemonic"] },
      "&&Terminal"
    ),
    keybindings: {
      primary: 2048 | 91,
      mac: { primary: 256 | 91 }
    },
    order: 3
  }
}], VIEW_CONTAINER);
registerTerminalActions();
function registerSendSequenceKeybinding(text, rule) {
  KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: "workbench.action.terminal.sendSequence",
    weight: 200,
    when: rule.when || TerminalContextKeys.focus,
    primary: rule.primary,
    mac: rule.mac,
    linux: rule.linux,
    win: rule.win,
    handler: terminalSendSequenceCommand,
    args: { text }
  });
}
if (isWindows) {
  registerSendSequenceKeybinding(String.fromCharCode("V".charCodeAt(0) - 64), {
    when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
      "terminalShellType",
      "pwsh"
    ), CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
    primary: 2048 | 52
  });
}
registerSendSequenceKeybinding("\x1B[24~a", {
  when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
    "terminalShellType",
    "pwsh"
  ), TerminalContextKeys.terminalShellIntegrationEnabled, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
  primary: 2048 | 10,
  mac: { primary: 256 | 10 }
});
registerSendSequenceKeybinding("\x1B[24~b", {
  when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
    "terminalShellType",
    "pwsh"
  ), TerminalContextKeys.terminalShellIntegrationEnabled, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
  primary: 512 | 10
});
registerSendSequenceKeybinding("\x1B[24~c", {
  when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
    "terminalShellType",
    "pwsh"
  ), TerminalContextKeys.terminalShellIntegrationEnabled, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
  primary: 1024 | 3
});
registerSendSequenceKeybinding("\x1B[24~d", {
  when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
    "terminalShellType",
    "pwsh"
  ), TerminalContextKeys.terminalShellIntegrationEnabled, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
  mac: { primary: 1024 | 2048 | 17 }
});
registerSendSequenceKeybinding("\x1B[24~e", {
  when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
    "terminalShellType",
    "pwsh"
  ), TerminalContextKeys.terminalShellIntegrationEnabled, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate(), ContextKeyExpr.equals(
    `config.${"terminal.integrated.shellIntegration.suggestEnabled"}`,
    true
  )),
  primary: 2048 | 10,
  mac: { primary: 256 | 10 }
});
registerSendSequenceKeybinding("\x1B[1;2H", {
  when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
    "terminalShellType",
    "pwsh"
  )),
  mac: { primary: 1024 | 2048 | 15 }
});
registerSendSequenceKeybinding("", {
  when: ContextKeyExpr.and(TerminalContextKeys.focus, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
  primary: 2048 | 512 | 48,
  mac: { primary: 256 | 512 | 48 }
});
registerSendSequenceKeybinding("\x07", {
  when: TerminalContextKeys.focus,
  primary: 2048 | 512 | 37,
  mac: { primary: 256 | 512 | 37 }
});
if (isIOS) {
  registerSendSequenceKeybinding(String.fromCharCode("C".charCodeAt(0) - 64), {
    when: ContextKeyExpr.and(TerminalContextKeys.focus),
    primary: 256 | 33
  });
}
registerSendSequenceKeybinding(String.fromCharCode("W".charCodeAt(0) - 64), {
  primary: 2048 | 1,
  mac: { primary: 512 | 1 }
});
if (isWindows) {
  registerSendSequenceKeybinding(String.fromCharCode("H".charCodeAt(0) - 64), {
    when: ContextKeyExpr.and(TerminalContextKeys.focus, ContextKeyExpr.equals(
      "terminalShellType",
      "cmd"
    )),
    primary: 2048 | 1
  });
}
registerSendSequenceKeybinding("\x1Bd", {
  primary: 2048 | 20,
  mac: { primary: 512 | 20 }
});
registerSendSequenceKeybinding("", {
  mac: { primary: 2048 | 1 }
});
registerSendSequenceKeybinding(String.fromCharCode("A".charCodeAt(0) - 64), {
  mac: { primary: 2048 | 15 }
});
registerSendSequenceKeybinding(String.fromCharCode("E".charCodeAt(0) - 64), {
  mac: { primary: 2048 | 17 }
});
registerSendSequenceKeybinding("\0", {
  primary: 2048 | 1024 | 23,
  mac: { primary: 256 | 1024 | 23 }
});
registerSendSequenceKeybinding("", {
  primary: 2048 | 1024 | 27,
  mac: { primary: 256 | 1024 | 27 }
});
registerSendSequenceKeybinding("", {
  primary: 2048 | 90,
  mac: { primary: 256 | 90 }
});
setupTerminalCommands();
setupTerminalMenus();
registerColors();
let TerminalAccessibleContentProvider = class TerminalAccessibleContentProvider2 extends Disposable {
  onClose() {
    this._instance.focus();
    this.dispose();
  }
  constructor(_instance, _xterm, _instantiationService, _keybindingService, _accessibilityService) {
    super();
    this._instance = _instance;
    this._keybindingService = _keybindingService;
    this._accessibilityService = _accessibilityService;
    this._hasShellIntegration = false;
    this.options = {
      type: "help",
      ariaLabel: localize("terminal-help-label", "terminal accessibility help"),
      readMoreUrl: "https://code.visualstudio.com/docs/editor/accessibility#_terminal-accessibility"
    };
    this.verbositySettingKey = "accessibility.verbosity.terminal";
    this._hasShellIntegration = _xterm.shellIntegration.status === 2;
  }
  _descriptionForCommand(commandId, msg, noKbMsg) {
    const kb = this._keybindingService.lookupKeybindings(commandId);
    switch (kb.length) {
      case 0:
        return format(noKbMsg, commandId);
      case 1:
        return format(msg, kb[0].getAriaLabel());
    }
    return this._accessibilityService.isScreenReaderOptimized() ? format(msg, kb[1].getAriaLabel()) : format(msg, kb[0].getAriaLabel());
  }
  provideContent() {
    const content = [];
    content.push(this._descriptionForCommand("workbench.action.terminal.focusAccessibleBuffer", localize(
      "focusAccessibleBuffer",
      "The Focus Accessible Buffer ({0}) command enables screen readers to read terminal contents."
    ), localize(
      "focusAccessibleBufferNoKb",
      "The Focus Accessible Buffer command enables screen readers to read terminal contents and is currently not triggerable by a keybinding."
    )));
    if (this._instance.shellType === "cmd") {
      content.push(localize(
        "commandPromptMigration",
        "Consider using powershell instead of command prompt for an improved experience"
      ));
    }
    if (this._hasShellIntegration) {
      content.push(localize(
        "shellIntegration",
        "The terminal has a feature called shell integration that offers an enhanced experience and provides useful commands for screen readers such as:"
      ));
      content.push("- " + this._descriptionForCommand("workbench.action.terminal.accessibleBufferGoToNextCommand", localize("goToNextCommand", "Go to Next Command ({0})"), localize(
        "goToNextCommandNoKb",
        "Go to Next Command is currently not triggerable by a keybinding."
      )));
      content.push("- " + this._descriptionForCommand("workbench.action.terminal.accessibleBufferGoToPreviousCommand", localize("goToPreviousCommand", "Go to Previous Command ({0})"), localize(
        "goToPreviousCommandNoKb",
        "Go to Previous Command is currently not triggerable by a keybinding."
      )));
      content.push("- " + this._descriptionForCommand("workbench.action.terminal.navigateAccessibleBuffer", localize("navigateAccessibleBuffer", "Navigate Accessible Buffer ({0})"), localize(
        "navigateAccessibleBufferNoKb",
        "Navigate Accessible Buffer is currently not triggerable by a keybinding."
      )));
      content.push("- " + this._descriptionForCommand("workbench.action.terminal.runRecentCommand", localize("runRecentCommand", "Run Recent Command ({0})"), localize(
        "runRecentCommandNoKb",
        "Run Recent Command is currently not triggerable by a keybinding."
      )));
      content.push("- " + this._descriptionForCommand("workbench.action.terminal.goToRecentDirectory", localize("goToRecentDirectory", "Go to Recent Directory ({0})"), localize(
        "goToRecentDirectoryNoKb",
        "Go to Recent Directory is currently not triggerable by a keybinding."
      )));
    } else {
      content.push(this._descriptionForCommand("workbench.action.terminal.runRecentCommand", localize(
        "goToRecentDirectoryNoShellIntegration",
        "The Go to Recent Directory command ({0}) enables screen readers to easily navigate to a directory that has been used in the terminal."
      ), localize(
        "goToRecentDirectoryNoKbNoShellIntegration",
        "The Go to Recent Directory command enables screen readers to easily navigate to a directory that has been used in the terminal and is currently not triggerable by a keybinding."
      )));
    }
    content.push(this._descriptionForCommand("workbench.action.terminal.openDetectedLink", localize(
      "openDetectedLink",
      "The Open Detected Link ({0}) command enables screen readers to easily open links found in the terminal."
    ), localize(
      "openDetectedLinkNoKb",
      "The Open Detected Link command enables screen readers to easily open links found in the terminal and is currently not triggerable by a keybinding."
    )));
    content.push(this._descriptionForCommand("workbench.action.terminal.newWithProfile", localize(
      "newWithProfile",
      "The Create New Terminal (With Profile) ({0}) command allows for easy terminal creation using a specific profile."
    ), localize(
      "newWithProfileNoKb",
      "The Create New Terminal (With Profile) command allows for easy terminal creation using a specific profile and is currently not triggerable by a keybinding."
    )));
    content.push(localize(
      "accessibilitySettings",
      "Access accessibility settings such as `terminal.integrated.tabFocusMode` via the Preferences: Open Accessibility Settings command."
    ));
    return content.join("\n");
  }
};
TerminalAccessibleContentProvider = __decorate([
  __param(2, IInstantiationService),
  __param(3, IKeybindingService),
  __param(4, IAccessibilityService)
], TerminalAccessibleContentProvider);
let BufferContentTracker = class BufferContentTracker2 {
  get lines() {
    return this._lines;
  }
  constructor(_xterm, _logService, _configurationService) {
    this._xterm = _xterm;
    this._logService = _logService;
    this._configurationService = _configurationService;
    this._priorEditorViewportLineCount = 0;
    this._lines = [];
    this.bufferToEditorLineMapping = /* @__PURE__ */ new Map();
  }
  reset() {
    this._lines = [];
    this._lastCachedMarker = void 0;
    this.update();
  }
  update() {
    var _a2;
    if ((_a2 = this._lastCachedMarker) == null ? void 0 : _a2.isDisposed) {
      this._lines = [];
      this._lastCachedMarker = void 0;
    }
    this._removeViewportContent();
    this._updateCachedContent();
    this._updateViewportContent();
    this._lastCachedMarker = this._xterm.raw.registerMarker();
    this._logService.debug("Buffer content tracker: set ", this._lines.length, " lines");
  }
  _updateCachedContent() {
    var _a2, _b2;
    const buffer = this._xterm.raw.buffer.active;
    const start = ((_a2 = this._lastCachedMarker) == null ? void 0 : _a2.line) ? this._lastCachedMarker.line - this._xterm.raw.rows + 1 : 0;
    const end = buffer.baseY;
    if (start < 0 || start > end) {
      return;
    }
    const scrollback = this._configurationService.getValue("terminal.integrated.scrollback");
    const maxBufferSize = scrollback + this._xterm.raw.rows - 1;
    const linesToAdd = end - start;
    if (linesToAdd + this._lines.length > maxBufferSize) {
      const numToRemove = linesToAdd + this._lines.length - maxBufferSize;
      for (let i = 0; i < numToRemove; i++) {
        this._lines.shift();
      }
      this._logService.debug("Buffer content tracker: removed ", numToRemove, " lines from top of cached lines, now ", this._lines.length, " lines");
    }
    const cachedLines = [];
    let currentLine = "";
    for (let i = start; i < end; i++) {
      const line = buffer.getLine(i);
      if (!line) {
        continue;
      }
      this.bufferToEditorLineMapping.set(i, this._lines.length + cachedLines.length);
      const isWrapped = (_b2 = buffer.getLine(i + 1)) == null ? void 0 : _b2.isWrapped;
      currentLine += line.translateToString(!isWrapped);
      if (currentLine && !isWrapped || i === buffer.baseY + this._xterm.raw.rows - 1) {
        if (line.length) {
          cachedLines.push(currentLine);
          currentLine = "";
        }
      }
    }
    this._logService.debug("Buffer content tracker:", cachedLines.length, " lines cached");
    this._lines.push(...cachedLines);
  }
  _removeViewportContent() {
    if (!this._lines.length) {
      return;
    }
    let linesToRemove = this._priorEditorViewportLineCount;
    let index = 1;
    while (linesToRemove) {
      this.bufferToEditorLineMapping.forEach((value, key) => {
        if (value === this._lines.length - index) {
          this.bufferToEditorLineMapping.delete(key);
        }
      });
      this._lines.pop();
      index++;
      linesToRemove--;
    }
    this._logService.debug("Buffer content tracker: removed lines from viewport, now ", this._lines.length, " lines cached");
  }
  _updateViewportContent() {
    var _a2;
    const buffer = this._xterm.raw.buffer.active;
    this._priorEditorViewportLineCount = 0;
    let currentLine = "";
    for (let i = buffer.baseY; i < buffer.baseY + this._xterm.raw.rows; i++) {
      const line = buffer.getLine(i);
      if (!line) {
        continue;
      }
      this.bufferToEditorLineMapping.set(i, this._lines.length);
      const isWrapped = (_a2 = buffer.getLine(i + 1)) == null ? void 0 : _a2.isWrapped;
      currentLine += line.translateToString(!isWrapped);
      if (currentLine && !isWrapped || i === buffer.baseY + this._xterm.raw.rows - 1) {
        if (currentLine.length) {
          this._priorEditorViewportLineCount++;
          this._lines.push(currentLine);
          currentLine = "";
        }
      }
    }
    this._logService.debug("Viewport content update complete, ", this._lines.length, " lines in the viewport");
  }
};
BufferContentTracker = __decorate([
  __param(1, ITerminalLogService),
  __param(2, IConfigurationService)
], BufferContentTracker);
let TerminalAccessibleWidget = class TerminalAccessibleWidget2 extends DisposableStore {
  get element() {
    return this._element;
  }
  get editorWidget() {
    return this._editorWidget;
  }
  constructor(_className, _instance, _xterm, _focusContextKey, _instantiationService, _modelService, _configurationService, _contextKeyService, _terminalService) {
    super();
    this._className = _className;
    this._instance = _instance;
    this._xterm = _xterm;
    this._focusContextKey = _focusContextKey;
    this._instantiationService = _instantiationService;
    this._modelService = _modelService;
    this._configurationService = _configurationService;
    this._contextKeyService = _contextKeyService;
    this._terminalService = _terminalService;
    this._listeners = [];
    this._xtermElement = _xterm.raw.element;
    this._element = document.createElement("div");
    this._element.setAttribute("role", "document");
    this._element.classList.add(_className);
    this._element.classList.add("terminal-accessible-widget");
    this._editorContainer = document.createElement("div");
    const codeEditorWidgetOptions = {
      contributions: EditorExtensionsRegistry.getEditorContributions().filter((c) => c.id !== CodeActionController.ID)
    };
    const font = _xterm.getFont();
    const editorOptions = {
      ...getSimpleEditorOptions(this._configurationService),
      lineDecorationsWidth: 6,
      dragAndDrop: true,
      cursorWidth: 1,
      fontSize: font.fontSize,
      lineHeight: font.charHeight ? font.charHeight * font.lineHeight : 1,
      letterSpacing: font.letterSpacing,
      fontFamily: font.fontFamily,
      wrappingStrategy: "advanced",
      wrappingIndent: "none",
      padding: { top: 2, bottom: 2 },
      quickSuggestions: false,
      renderWhitespace: "none",
      dropIntoEditor: { enabled: true },
      readOnly: true
    };
    this._editorWidget = this.add(this._instantiationService.createInstance(CodeEditorWidget, this._editorContainer, editorOptions, codeEditorWidgetOptions));
    this._element.replaceChildren(this._editorContainer);
    this._xtermElement.insertAdjacentElement("beforebegin", this._element);
    if (this._focusContextKey) {
      this._focusTracker = this.add(trackFocus(this._editorContainer));
      this._focusedContextKey = this._focusContextKey.bindTo(this._contextKeyService);
      this.add(this._focusTracker.onDidFocus(() => {
        var _a2;
        return (_a2 = this._focusedContextKey) == null ? void 0 : _a2.set(true);
      }));
      this.add(this._focusTracker.onDidBlur(() => {
        var _a2;
        return (_a2 = this._focusedContextKey) == null ? void 0 : _a2.reset();
      }));
    }
    this.add(Event.runAndSubscribe(this._xterm.raw.onResize, () => this.layout()));
    this.add(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectedKeys.has("terminal.integrated.fontFamily") || e.affectedKeys.has("terminal.integrated.fontSize") || e.affectedKeys.has("terminal.integrated.lineHeight") || e.affectedKeys.has("terminal.integrated.letterSpacing")) {
        const font2 = this._xterm.getFont();
        this._editorWidget.updateOptions({ fontFamily: font2.fontFamily, fontSize: font2.fontSize, lineHeight: font2.charHeight ? font2.charHeight * font2.lineHeight : 1, letterSpacing: font2.letterSpacing });
      }
    }));
    this.add(this._editorWidget.onKeyDown((e) => {
      switch (e.keyCode) {
        case 9:
          this.hide();
          this._xterm.raw.focus();
          break;
        case 2:
          this.hide();
          break;
      }
    }));
    this.add(this._editorWidget.onDidFocusEditorText(async () => {
      this._terminalService.setActiveInstance(this._instance);
      this._xtermElement.classList.add("hide");
    }));
  }
  registerListeners() {
    this._listeners.push(this._instance.onDidRequestFocus(() => this.editorWidget.focus()));
  }
  layout() {
    this._editorWidget.layout({ width: this._xtermElement.clientWidth, height: this._xtermElement.clientHeight });
  }
  async show() {
    this.registerListeners();
    await this.updateEditor();
    this.element.tabIndex = -1;
    this.layout();
    this.element.classList.add("active");
    this._xtermElement.classList.add("hide");
    this.editorWidget.focus();
  }
  dispose() {
    this._disposeListeners();
    super.dispose();
  }
  _disposeListeners() {
    for (const listener of this._listeners) {
      listener.dispose();
    }
  }
  hide() {
    this._disposeListeners();
    this.element.classList.remove("active");
    this._xtermElement.classList.remove("hide");
  }
  async getTextModel(resource) {
    const existing = this._modelService.getModel(resource);
    if (existing && !existing.isDisposed()) {
      return existing;
    }
    return this._modelService.createModel(`${this._className}-${resource.fragment}`, null, resource, false);
  }
};
TerminalAccessibleWidget = __decorate([
  __param(4, IInstantiationService),
  __param(5, IModelService),
  __param(6, IConfigurationService),
  __param(7, IContextKeyService),
  __param(8, ITerminalService)
], TerminalAccessibleWidget);
let AccessibleBufferWidget = class AccessibleBufferWidget2 extends TerminalAccessibleWidget {
  constructor(_instance, _xterm, _instantiationService, _modelService, _configurationService, _quickInputService, _audioCueService, _contextKeyService, _logService, _terminalService) {
    super("accessible-buffer", _instance, _xterm, TerminalContextKeys.accessibleBufferFocus, _instantiationService, _modelService, _configurationService, _contextKeyService, _terminalService);
    this._quickInputService = _quickInputService;
    this._audioCueService = _audioCueService;
    this._logService = _logService;
    this._isUpdating = false;
    this._pendingUpdates = 0;
    this._bufferTracker = _instantiationService.createInstance(BufferContentTracker, _xterm);
    this.element.ariaRoleDescription = localize("terminal.integrated.accessibleBuffer", "Terminal buffer");
    this.updateEditor();
    this.add(this.editorWidget.onDidFocusEditorText(async () => {
      if (this.element.classList.contains("active")) {
        return;
      }
      this.registerListeners();
      await this.updateEditor();
      this.element.classList.add("active");
    }));
    this.layout();
  }
  navigateToCommand(type) {
    var _a2, _b2;
    const currentLine = ((_a2 = this.editorWidget.getPosition()) == null ? void 0 : _a2.lineNumber) || ((_b2 = this._getDefaultCursorPosition()) == null ? void 0 : _b2.lineNumber);
    const commands = this._getCommandsWithEditorLine();
    if (!(commands == null ? void 0 : commands.length) || !currentLine) {
      return;
    }
    const filteredCommands = type === "previous" ? commands.filter((c) => c.lineNumber < currentLine).sort((a, b) => b.lineNumber - a.lineNumber) : commands.filter((c) => c.lineNumber > currentLine).sort((a, b) => a.lineNumber - b.lineNumber);
    if (!filteredCommands.length) {
      return;
    }
    this._cursorPosition = { lineNumber: filteredCommands[0].lineNumber, column: 1 };
    this._resetPosition();
  }
  _getEditorLineForCommand(command) {
    var _a2;
    let line = (_a2 = command.marker) == null ? void 0 : _a2.line;
    if (line === void 0 || !command.command.length || line < 0) {
      return;
    }
    line = this._bufferTracker.bufferToEditorLineMapping.get(line);
    if (line === void 0) {
      return;
    }
    return line + 1;
  }
  _getCommandsWithEditorLine() {
    var _a2;
    const commands = (_a2 = this._instance.capabilities.get(2)) == null ? void 0 : _a2.commands;
    if (!(commands == null ? void 0 : commands.length)) {
      return;
    }
    const result = [];
    for (const command of commands) {
      const lineNumber = this._getEditorLineForCommand(command);
      if (!lineNumber) {
        continue;
      }
      result.push({ command, lineNumber });
    }
    return result;
  }
  async createQuickPick() {
    this._cursorPosition = withNullAsUndefined(this.editorWidget.getPosition());
    const commands = this._getCommandsWithEditorLine();
    if (!commands) {
      return;
    }
    const quickPickItems = [];
    for (const { command, lineNumber } of commands) {
      const line = this._getEditorLineForCommand(command);
      if (!line) {
        continue;
      }
      quickPickItems.push({
        label: localize(
          "terminal.integrated.symbolQuickPick.labelNoExitCode",
          "{0}",
          command.command
        ),
        lineNumber,
        exitCode: command.exitCode
      });
    }
    const quickPick = this._quickInputService.createQuickPick();
    quickPick.canSelectMany = false;
    quickPick.onDidChangeActive(() => {
      const activeItem = quickPick.activeItems[0];
      if (!activeItem) {
        return;
      }
      if (activeItem.exitCode) {
        this._audioCueService.playAudioCue(AudioCue.error, true);
      }
      this.editorWidget.revealLine(activeItem.lineNumber, 0);
    });
    quickPick.onDidHide(() => {
      this._resetPosition();
      quickPick.dispose();
    });
    quickPick.onDidAccept(() => {
      const item = quickPick.activeItems[0];
      const model = this.editorWidget.getModel();
      if (!model) {
        return;
      }
      if (!item && this._cursorPosition) {
        this._resetPosition();
      } else {
        this._cursorPosition = { lineNumber: item.lineNumber, column: 1 };
      }
      quickPick.dispose();
      this.editorWidget.focus();
      return;
    });
    quickPick.items = quickPickItems.reverse();
    return quickPick;
  }
  _resetPosition() {
    this._cursorPosition = this._cursorPosition ?? this._getDefaultCursorPosition();
    if (!this._cursorPosition) {
      return;
    }
    this.editorWidget.setPosition(this._cursorPosition);
    this.editorWidget.setScrollPosition({ scrollTop: this.editorWidget.getTopForLineNumber(this._cursorPosition.lineNumber) });
  }
  layout() {
    if (this._bufferTracker) {
      this._bufferTracker.reset();
    }
    super.layout();
  }
  async updateEditor(dataChanged) {
    if (this._isUpdating) {
      this._pendingUpdates++;
      return;
    }
    this._isUpdating = true;
    const model = await this._updateModel(dataChanged);
    if (!model) {
      return;
    }
    this._isUpdating = false;
    if (this._pendingUpdates) {
      this._logService.debug("TerminalAccessibleBuffer._updateEditor: pending updates", this._pendingUpdates);
      this._pendingUpdates--;
      await this.updateEditor(dataChanged);
    }
  }
  registerListeners() {
    super.registerListeners();
    this._xterm.raw.onWriteParsed(async () => {
      if (this._xterm.raw.buffer.active.baseY === 0) {
        await this.updateEditor(true);
      }
    });
    const onRequestUpdateEditor = Event.latch(this._xterm.raw.onScroll);
    this._listeners.push(onRequestUpdateEditor(async () => await this.updateEditor(true)));
  }
  _getDefaultCursorPosition() {
    var _a2;
    const modelLineCount = (_a2 = this.editorWidget.getModel()) == null ? void 0 : _a2.getLineCount();
    return modelLineCount ? { lineNumber: modelLineCount, column: 1 } : void 0;
  }
  async _updateModel(dataChanged) {
    var _a2, _b2;
    const linesBefore = this._bufferTracker.lines.length;
    this._bufferTracker.update();
    const linesAfter = this._bufferTracker.lines.length;
    const modelChanged = linesBefore !== linesAfter;
    let savedViewState;
    if (dataChanged) {
      savedViewState = withNullAsUndefined(this.editorWidget.saveViewState());
    }
    let model = this.editorWidget.getModel();
    const text = this._bufferTracker.lines.join("\n");
    if (model) {
      model.setValue(text);
    } else {
      model = await this.getTextModel(this._instance.resource.with({ fragment: `${"accessible-buffer"}-${text}` }));
    }
    this.editorWidget.setModel(model);
    const positionTopOfBuffer = ((_a2 = this.editorWidget.getPosition()) == null ? void 0 : _a2.lineNumber) === 1 && ((_b2 = this.editorWidget.getPosition()) == null ? void 0 : _b2.column) === 1;
    if (savedViewState) {
      this.editorWidget.restoreViewState(savedViewState);
    } else if (modelChanged || positionTopOfBuffer) {
      const defaultPosition = this._getDefaultCursorPosition();
      if (defaultPosition) {
        this.editorWidget.setPosition(defaultPosition);
        this.editorWidget.setScrollPosition({ scrollTop: this.editorWidget.getTopForLineNumber(defaultPosition.lineNumber) });
      }
    }
    return model;
  }
};
AccessibleBufferWidget = __decorate([
  __param(2, IInstantiationService),
  __param(3, IModelService),
  __param(4, IConfigurationService),
  __param(5, IQuickInputService),
  __param(6, IAudioCueService),
  __param(7, IContextKeyService),
  __param(8, ITerminalLogService),
  __param(9, ITerminalService)
], AccessibleBufferWidget);
let AccessibleBufferContribution = (_H = class extends DisposableStore {
  static get(instance) {
    return instance.getContribution(_H.ID);
  }
  constructor(_instance, processManager, widgetManager, _instantiationService) {
    super();
    this._instance = _instance;
    this._instantiationService = _instantiationService;
  }
  layout(xterm2) {
    this._xterm = xterm2;
  }
  async show() {
    if (!this._xterm) {
      return;
    }
    if (!this._accessibleBufferWidget) {
      this._accessibleBufferWidget = this.add(this._instantiationService.createInstance(AccessibleBufferWidget, this._instance, this._xterm));
    }
    await this._accessibleBufferWidget.show();
  }
  async createCommandQuickPick() {
    var _a2;
    return (_a2 = this._accessibleBufferWidget) == null ? void 0 : _a2.createQuickPick();
  }
  navigateToCommand(type) {
    var _a2;
    return (_a2 = this._accessibleBufferWidget) == null ? void 0 : _a2.navigateToCommand(type);
  }
}, _H.ID = "terminal.accessible-buffer", _H);
AccessibleBufferContribution = __decorate([
  __param(3, IInstantiationService)
], AccessibleBufferContribution);
registerTerminalContribution(AccessibleBufferContribution.ID, AccessibleBufferContribution);
class TerminalAccessibilityHelpContribution extends Disposable {
  constructor() {
    super();
    this._register(AccessibilityHelpAction.addImplementation(105, "terminal", async (accessor) => {
      const instantiationService = accessor.get(IInstantiationService);
      const terminalService = accessor.get(ITerminalService);
      const accessibleViewService = accessor.get(IAccessibleViewService);
      const instance = await terminalService.getActiveOrCreateInstance();
      await terminalService.revealActiveTerminal();
      const terminal = instance == null ? void 0 : instance.xterm;
      if (!terminal) {
        return;
      }
      accessibleViewService.show(instantiationService.createInstance(TerminalAccessibleContentProvider, instance, terminal));
    }, TerminalContextKeys.focus));
  }
}
registerTerminalContribution(TerminalAccessibilityHelpContribution.ID, TerminalAccessibilityHelpContribution);
registerTerminalAction({
  id: "workbench.action.terminal.focusAccessibleBuffer",
  title: { value: localize(
    "workbench.action.terminal.focusAccessibleBuffer",
    "Focus Accessible Buffer"
  ), original: "Focus Accessible Buffer" },
  precondition: ContextKeyExpr.or(
    TerminalContextKeys.processSupported,
    TerminalContextKeys.terminalHasBeenCreated
  ),
  keybinding: [
    {
      primary: 1024 | 2,
      weight: 200,
      when: ContextKeyExpr.and(
        CONTEXT_ACCESSIBILITY_MODE_ENABLED,
        TerminalContextKeys.focus,
        ContextKeyExpr.or(terminalTabFocusModeContextKey, TerminalContextKeys.accessibleBufferFocus.negate())
      )
    }
  ],
  run: async (c) => {
    var _a2;
    const instance = await c.service.getActiveOrCreateInstance();
    await c.service.revealActiveTerminal();
    if (!instance) {
      return;
    }
    await ((_a2 = AccessibleBufferContribution.get(instance)) == null ? void 0 : _a2.show());
  }
});
registerTerminalAction({
  id: "workbench.action.terminal.navigateAccessibleBuffer",
  title: { value: localize(
    "workbench.action.terminal.navigateAccessibleBuffer",
    "Navigate Accessible Buffer"
  ), original: "Navigate Accessible Buffer" },
  precondition: ContextKeyExpr.or(
    TerminalContextKeys.processSupported,
    TerminalContextKeys.terminalHasBeenCreated
  ),
  keybinding: [
    {
      primary: 2048 | 1024 | 37,
      weight: 200 + 2,
      when: TerminalContextKeys.accessibleBufferFocus
    }
  ],
  run: async (c) => {
    var _a2;
    const instance = await c.service.getActiveOrCreateInstance();
    await c.service.revealActiveTerminal();
    if (!instance) {
      return;
    }
    const quickPick = await ((_a2 = AccessibleBufferContribution.get(instance)) == null ? void 0 : _a2.createCommandQuickPick());
    quickPick == null ? void 0 : quickPick.show();
  }
});
registerTerminalAction({
  id: "workbench.action.terminal.accessibleBufferGoToNextCommand",
  title: { value: localize(
    "workbench.action.terminal.accessibleBufferGoToNextCommand",
    "Accessible Buffer Go to Next Command"
  ), original: "Accessible Buffer Go to Next Command" },
  precondition: ContextKeyExpr.or(
    TerminalContextKeys.processSupported,
    TerminalContextKeys.terminalHasBeenCreated,
    TerminalContextKeys.accessibleBufferFocus
  ),
  keybinding: [
    {
      primary: 2048 | 18,
      when: ContextKeyExpr.and(TerminalContextKeys.accessibleBufferFocus, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
      weight: 200 + 2
    },
    {
      primary: 2048 | 18,
      mac: { primary: 512 | 18 },
      when: ContextKeyExpr.and(
        TerminalContextKeys.accessibleBufferFocus,
        CONTEXT_ACCESSIBILITY_MODE_ENABLED
      ),
      weight: 200 + 2
    }
  ],
  run: async (c) => {
    var _a2;
    const instance = await c.service.getActiveOrCreateInstance();
    await c.service.revealActiveTerminal();
    if (!instance) {
      return;
    }
    await ((_a2 = AccessibleBufferContribution.get(instance)) == null ? void 0 : _a2.navigateToCommand("next"));
  }
});
registerTerminalAction({
  id: "workbench.action.terminal.accessibleBufferGoToPreviousCommand",
  title: { value: localize(
    "workbench.action.terminal.accessibleBufferGoToPreviousCommand",
    "Accessible Buffer Go to Previous Command"
  ), original: "Accessible Buffer Go to Previous Command" },
  precondition: ContextKeyExpr.and(ContextKeyExpr.or(
    TerminalContextKeys.processSupported,
    TerminalContextKeys.terminalHasBeenCreated
  ), TerminalContextKeys.accessibleBufferFocus),
  keybinding: [
    {
      primary: 2048 | 16,
      when: ContextKeyExpr.and(TerminalContextKeys.accessibleBufferFocus, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
      weight: 200 + 2
    },
    {
      primary: 2048 | 16,
      mac: { primary: 512 | 16 },
      when: ContextKeyExpr.and(
        TerminalContextKeys.accessibleBufferFocus,
        CONTEXT_ACCESSIBILITY_MODE_ENABLED
      ),
      weight: 200 + 2
    }
  ],
  run: async (c) => {
    var _a2;
    const instance = await c.service.getActiveOrCreateInstance();
    await c.service.revealActiveTerminal();
    if (!instance) {
      return;
    }
    await ((_a2 = AccessibleBufferContribution.get(instance)) == null ? void 0 : _a2.navigateToCommand("previous"));
  }
});
class SimpleTerminalBackend {
  constructor() {
    this.getLatency = async () => [];
    this.isResponsive = true;
    this._whenConnected = new DeferredPromise();
    this.restartPtyHost = unsupported;
    this.remoteAuthority = void 0;
    this.onPtyHostUnresponsive = Event.None;
    this.onPtyHostResponsive = Event.None;
    this.onPtyHostRestart = Event.None;
    this.onDidRequestDetach = Event.None;
    this.attachToProcess = unsupported;
    this.attachToRevivedProcess = unsupported;
    this.listProcesses = unsupported;
    this.getProfiles = async () => [];
    this.getWslPath = unsupported;
    this.getEnvironment = async () => ({});
    this.getShellEnvironment = async () => void 0;
    this.setTerminalLayoutInfo = async () => {
    };
    this.updateTitle = async () => {
    };
    this.updateIcon = async () => {
    };
    this.getTerminalLayoutInfo = async () => void 0;
    this.reduceConnectionGraceTime = unsupported;
    this.requestDetachInstance = unsupported;
    this.acceptDetachInstanceReply = unsupported;
    this.persistTerminalState = unsupported;
  }
  get whenReady() {
    return this._whenConnected.p;
  }
  setReady() {
    void this._whenConnected.complete();
  }
  async getPerformanceMarks() {
    return [];
  }
}
class SimpleTerminalProcess {
  constructor(id, pid, cwd, onData) {
    this.id = id;
    this.pid = pid;
    this.cwd = cwd;
    this.onData = onData;
    this.onReady = new Emitter();
    this.shouldPersist = false;
    this.onProcessData = this.onData;
    this.onProcessReady = this.onReady.event;
    this.onDidChangeProperty = Event.None;
    this.onProcessExit = Event.None;
    this.processBinary = unsupported;
    this.refreshProperty = async () => void 0;
    setTimeout(() => {
      this.onReady.fire({
        cwd,
        pid,
        windowsPty: void 0
      });
    });
  }
  acknowledgeDataEvent() {
  }
  async setUnicodeVersion() {
  }
  async getInitialCwd() {
    return this.cwd;
  }
  async getCwd() {
    return this.cwd;
  }
  async getLatency() {
    return 0;
  }
  async updateProperty() {
  }
}
function getServiceOverride(backend) {
  Registry.as(TerminalExtensions.Backend).registerTerminalBackend(backend);
  return {
    [ITerminalService.toString()]: new SyncDescriptor(TerminalService, [], true),
    [ITerminalLogService.toString()]: new SyncDescriptor(TerminalLogService, [], true),
    [ITerminalEditorService.toString()]: new SyncDescriptor(TerminalEditorService, [], true),
    [ITerminalGroupService.toString()]: new SyncDescriptor(TerminalGroupService, [], true),
    [ITerminalInstanceService.toString()]: new SyncDescriptor(TerminalInstanceService, [], true),
    [ITerminalProfileService.toString()]: new SyncDescriptor(TerminalProfileService, [], true),
    [ITerminalContributionService.toString()]: new SyncDescriptor(TerminalContributionService, [], true),
    [ITerminalLinkProviderService.toString()]: new SyncDescriptor(TerminalLinkProviderService, [], true),
    [ITerminalProfileResolverService.toString()]: new SyncDescriptor(ElectronTerminalProfileResolverService, [], true),
    [IEnvironmentVariableService.toString()]: new SyncDescriptor(EnvironmentVariableService, [], true),
    [ITerminalQuickFixService.toString()]: new SyncDescriptor(TerminalQuickFixService, [], true)
  };
}
export {
  SimpleTerminalBackend,
  SimpleTerminalProcess,
  getServiceOverride as default
};
